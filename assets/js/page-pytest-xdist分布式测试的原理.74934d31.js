(window.webpackJsonp=window.webpackJsonp||[]).push([[189],{1245:function(t,r,e){"use strict";e.r(r);var s=e(1),_=Object(s.a)({},(function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"pytest-xdist-分布式测试的原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pytest-xdist-分布式测试的原理"}},[t._v("#")]),t._v(" pytest-xdist 分布式测试的原理")]),t._v(" "),e("h2",{attrs:{id:"分布式结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分布式结构"}},[t._v("#")]),t._v(" 分布式结构")]),t._v(" "),e("ul",[e("li",[t._v("xdist 的分布式类似于一主多从的结构，master 机负责下发命令，控制 slave 机")]),t._v(" "),e("li",[t._v("slave 机根据 master 机的命令执行特定测试任务")]),t._v(" "),e("li",[t._v("在 xdist 中，主是 master，从是 workers")])]),t._v(" "),e("h2",{attrs:{id:"原理简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原理简介"}},[t._v("#")]),t._v(" 原理简介")]),t._v(" "),e("ul",[e("li",[t._v("xdist 会产生一个或多个 workers，workers 都通过 master 来控制")]),t._v(" "),e("li",[t._v("每个 worker 负责执行完整的测试用例集，然后按照 master 的要求运行测试，而 master 机不执行测试任务")])]),t._v(" "),e("h2",{attrs:{id:"pytest-xdist-分布式测试的流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pytest-xdist-分布式测试的流程"}},[t._v("#")]),t._v(" pytest-xdist 分布式测试的流程")]),t._v(" "),e("h3",{attrs:{id:"第一步-创建worker"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一步-创建worker"}},[t._v("#")]),t._v(" 第一步：创建worker")]),t._v(" "),e("ul",[e("li",[t._v("master 会在总测试会话（test session）开始前产生一个或多个 worker")]),t._v(" "),e("li",[t._v("master 和 worker 之间是通过 execnet 和网关来通信的")]),t._v(" "),e("li",[t._v("实际编译执行测试代码的 worker 可能是本地机器也可能是远程机器")])]),t._v(" "),e("h3",{attrs:{id:"第二步-收集测试项用例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第二步-收集测试项用例"}},[t._v("#")]),t._v(" 第二步：收集测试项用例")]),t._v(" "),e("ul",[e("li",[t._v("每个 worker 类似一个迷你型的 Pytest 执行器")]),t._v(" "),e("li",[t._v("worker 会执行一个完整的 test collection 过程【收集所有测试用例的过程】")]),t._v(" "),e("li",[t._v("然后把测试用例的 ids 返回给 master")]),t._v(" "),e("li",[t._v("master 是不会执行任何测试用例集的")])]),t._v(" "),e("p",[e("strong",[t._v("注意")]),t._v("：")]),t._v(" "),e("p",[t._v("为什么上面通过分布式测试的结果截图是没有输出用例的 print 内容，因为主机并不执行测试用例，pycharm 相当于一个 master")]),t._v(" "),e("h3",{attrs:{id:"第三步-master-检测-workers-收集到的测试用例集"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第三步-master-检测-workers-收集到的测试用例集"}},[t._v("#")]),t._v(" 第三步：master 检测 workers 收集到的测试用例集")]),t._v(" "),e("ul",[e("li",[t._v("master 接收到所有 worker 收集的测试用例集之后，master 会进行一些完整性检查，以确保所有 worker 都收集到一样的测试用例集（包括顺序）")]),t._v(" "),e("li",[t._v("如果检查通过，会将测试用例的 ids 列表转换成简单的索引列表，每个索引对应一个测试用例的在原来测试集中的位置")]),t._v(" "),e("li",[t._v("这个方案可行的原因是：所有的节点都保存着相同的测试用例集")]),t._v(" "),e("li",[t._v("并且使用这种方式可以节省带宽，因为 master 只需要告知 workers 需要执行的测试用例对应的索引，而不用告知完整的测试用例信息")])]),t._v(" "),e("h3",{attrs:{id:"第四步-测试用例分发"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第四步-测试用例分发"}},[t._v("#")]),t._v(" 第四步：测试用例分发")]),t._v(" "),e("p",[e("code",[t._v("--dist-mode")]),t._v(" 选项:")]),t._v(" "),e("p",[t._v("each：master 将完整的测试索引列表分发到每个 worker")]),t._v(" "),e("p",[t._v("load：master 将大约 25% 的测试用例以轮询的方式分发到各个 worker，剩余的测试用例则会等待 workers 执行完测试用例以后再分发")]),t._v(" "),e("p",[e("strong",[t._v("注意")]),t._v(":\n可以使用 "),e("code",[t._v("pytest_xdist_make_scheduler")]),t._v(" 这个 hook 来实现自定义测试分发逻辑")]),t._v(" "),e("h3",{attrs:{id:"第五步-测试用例的执行"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第五步-测试用例的执行"}},[t._v("#")]),t._v(" 第五步：测试用例的执行")]),t._v(" "),e("ul",[e("li",[t._v("workers 重写了 "),e("code",[t._v("pytest_runtestloop")]),t._v("：Pytest 的默认实现是循环执行所有在 test session 这个对象里面收集到的测试用例")]),t._v(" "),e("li",[t._v("但是在 xdist 里, workers 实际上是等待 master 为其发送需要执行的测试用例")]),t._v(" "),e("li",[t._v("当 worker 收到测试任务, 就顺序执行 "),e("code",[t._v("pytest_runtest_protocol")])]),t._v(" "),e("li",[t._v("值得注意的一个细节是：workers 必须始终保持至少一个测试用例在的任务队列里, 以兼容 "),e("code",[t._v("pytest_runtest_protocol（item, nextitem）hook")]),t._v(" 的参数要求，为了将 nextitem 传给 hook")]),t._v(" "),e("li",[t._v("worker 会在执行最后一个测试项前等待 master 的更多指令")]),t._v(" "),e("li",[t._v("如果它收到了更多测试项, 那么就可以安全的执行 "),e("code",[t._v("pytest_runtest_protocol")]),t._v("，因为这时 nextitem 参数已经可以确定")]),t._v(" "),e("li",[t._v("如果它收到一个 "),e("code",[t._v("shutdown")]),t._v(" 信号, 那么就将 nextitem 参数设为 None, 然后执行 "),e("code",[t._v("pytest_runtest_protocol")])])]),t._v(" "),e("h3",{attrs:{id:"第六步-测试用例再分发-dist-mode-load"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第六步-测试用例再分发-dist-mode-load"}},[t._v("#")]),t._v(" 第六步：测试用例再分发（--dist-mode=load）")]),t._v(" "),e("ul",[e("li",[t._v("当 workers 开始/结束执行时，会把测试结果返回给 master，这样其他 Pytest hook 比如："),e("code",[t._v("pytest_runtest_protocol")]),t._v(" 就可以正常执行")]),t._v(" "),e("li",[t._v("master 在 worker 执行完一个测试后，基于测试执行时长以及每个 work 剩余测试用例综合决定是否向这个 worker 发送更多的测试用例")])]),t._v(" "),e("h3",{attrs:{id:"第七步-测试结束"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第七步-测试结束"}},[t._v("#")]),t._v(" 第七步：测试结束")]),t._v(" "),e("ul",[e("li",[t._v("当 master 没有更多执行测试任务时，它会发送一个 “shutdown” 信号给所有 worker")]),t._v(" "),e("li",[t._v("当 worker 将剩余测试用例执行完后退出进程")]),t._v(" "),e("li",[t._v("master 等待所有 worker 全部退出")]),t._v(" "),e("li",[t._v("此时仍需要处理诸如 "),e("code",[t._v("pytest_runtest_logreport")]),t._v(" 等事件")])]),t._v(" "),e("h2",{attrs:{id:"参考资料"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://www.jianshu.com/p/4c3ffa2",target:"_blank",rel:"noopener noreferrer"}},[t._v("pytest-xdist"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("（完）")])])}),[],!1,null,null,null);r.default=_.exports}}]);