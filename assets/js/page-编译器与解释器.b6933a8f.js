(window.webpackJsonp=window.webpackJsonp||[]).push([[204],{636:function(t,_,n){"use strict";n.r(_);var o=n(1),v=Object(o.a)({},(function(){var t=this,_=t.$createElement,n=t._self._c||_;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"编译器与解释器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#编译器与解释器"}},[t._v("#")]),t._v(" 编译器与解释器")]),t._v(" "),n("h2",{attrs:{id:"区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[t._v("#")]),t._v(" 区别")]),t._v(" "),n("p",[t._v("编译器与解释器作为高级语言与机器之间的翻译官，都是将代码翻译成机器可以执行的二进制机器码，只不过在运行原理和翻译过程有不同。")]),t._v(" "),n("p",[n("strong",[t._v("编译器")]),t._v("：先整体编译再执行。特点是运行速度快，但任何一个小改动都需要整体重新编译。可脱离编译环境运行。代表语言是 C 语言。")]),t._v(" "),n("p",[n("strong",[t._v("解释器")]),t._v("：边解释边执行。特点是运行速度慢，但部分改动不需要整体重新编译。不可脱离解释器环境运行。代表语言是 Python 语言。")]),t._v(" "),n("h2",{attrs:{id:"python-解释器种类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#python-解释器种类"}},[t._v("#")]),t._v(" Python 解释器种类")]),t._v(" "),n("p",[t._v("Python 有多种版本的解释器：")]),t._v(" "),n("p",[n("strong",[t._v("CPython")]),t._v("：官方版本的解释器。这个解释器是用 C 语言开发的，所以叫 CPython。CPython 是使用最广的 Python 解释器。如果没有特殊情况，我们通常下载和使用的默认都是这个解释器。\n"),n("strong",[t._v("Ipython")]),t._v("：基于 CPython 之上的一个交互式解释器，在交互方式上有所增强，执行 Python 代码的功能和 CPython 是完全一样的。CPython 用 "),n("code",[t._v(">>>")]),t._v(" 作为提示符，而 IPython 用 "),n("code",[t._v("In [序号]:")]),t._v(" 作为提示符。\n"),n("strong",[t._v("PyPy")]),t._v("：一个追求执行速度的 Python 解释器。采用 JIT 技术，对 Python 代码进行动态编译（注意，不是解释），可以显著提高 Python 代码的执行速度。绝大部分 CPython 代码都可以在 PyPy 下运行，但还是有一些不同的，这就导致相同的 Python 代码在两种解释器下执行可能会有不同的结果。\n"),n("strong",[t._v("Jython")]),t._v("：运行在 Java 平台上的 Python 解释器，可以直接把 Python 代码编译成 Java 字节码执行。\n"),n("strong",[t._v("IronPython")]),t._v("：和 Jython 类似，只不过 IronPython 是运行在微软 .Net 平台上的 Python 解释器，可以直接把 Python 代码编译成 .Net 的字节码。")]),t._v(" "),n("h2",{attrs:{id:"pyc文件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#pyc文件"}},[t._v("#")]),t._v(" pyc文件")]),t._v(" "),n("p",[t._v("鉴于解释器的缺点是慢，Python 也是有办法提高一下运行速度的，那就是使用 pyc 文件。这点参考了 JAVA 的字节码做法，但并不完全类同。")]),t._v(" "),n("p",[t._v("我们编写的代码一般都会保存在以 "),n("code",[t._v(".py")]),t._v(" 为后缀的文件中。在执行程序时，解释器逐行读取源代码并逐行解释运行。每执行一次，就重复一次这个过程，这其中耗费了大量的重复性的解释工作。为了减少这一重复性的解释工作，Python 引入了 pyc 文件，pyc 文件是将 py 文件的解释结果保存下来的文件，这样，下次再运行的时候就不用再解释了，直接使用 pyc 文件就可以了，这无疑大大提高了程序运行速度。")]),t._v(" "),n("p",[t._v("对于 pyc 文件，你必须知道以下几点：")]),t._v(" "),n("ul",[n("li",[t._v("对于当前调用的主程序不会生成 pyc 文件。")]),t._v(" "),n("li",[t._v("以 "),n("code",[t._v("import xxx")]),t._v(" 或 "),n("code",[t._v("from xxx import xxx")]),t._v(" 等方式导入主程序的模块才会生成 pyc 文件。")]),t._v(" "),n("li",[t._v("每次使用 pyc 文件时，都会根据 pyc 文件的创建时间和源模块进行对比，如果源模块有修改，则重新创建 pyc 文件，并覆盖先前的 pyc 文件，如果没有修改，直接使用 pyc 文件代替模块。")]),t._v(" "),n("li",[t._v("pyc 文件统一保存在模块所在目录的 "),n("code",[t._v("__pycache__")]),t._v(" 文件夹内。")])]),t._v(" "),n("p",[t._v("（完）")])])}),[],!1,null,null,null);_.default=v.exports}}]);