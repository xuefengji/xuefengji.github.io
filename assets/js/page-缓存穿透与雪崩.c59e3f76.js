(window.webpackJsonp=window.webpackJsonp||[]).push([[322],{1160:function(t,a,s){"use strict";s.r(a);var v=s(1),_=Object(v.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"缓存穿透与雪崩"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存穿透与雪崩"}},[t._v("#")]),t._v(" 缓存穿透与雪崩")]),t._v(" "),v("p",[t._v("Redis 缓存的使用，极大的提升了数据查询方面的性能和效率")]),t._v(" "),v("p",[t._v("同时也带来了一些问题：")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("其中最严重的就是数据一致性问题，如果对数据的一致性要求很高，就不能使用缓存")])]),t._v(" "),v("li",[v("p",[t._v("另外典型的问题：缓存穿透、缓存击穿和缓存雪崩")])])]),t._v(" "),v("h2",{attrs:{id:"缓存穿透"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存穿透"}},[t._v("#")]),t._v(" 缓存穿透")]),t._v(" "),v("h3",{attrs:{id:"什么是缓存穿透"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是缓存穿透"}},[t._v("#")]),t._v(" 什么是缓存穿透")]),t._v(" "),v("p",[t._v("一般在数据库之前都会有一个缓存")]),t._v(" "),v("p",[v("img",{attrs:{src:s(613),alt:"cache"}})]),t._v(" "),v("ul",[v("li",[v("p",[t._v("默认情况下，用户请求数据时，会先在缓存中查找")])]),t._v(" "),v("li",[v("p",[t._v("若在缓存中没找到，再去数据库查找")])]),t._v(" "),v("li",[v("p",[t._v("数量少时可能问题不大，一旦大量的请求数据(如秒杀场景)缓存中都没有命中，就会全部转移到数据库上，给数据库造成极大的压力，可能导致其崩溃")])])]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("总结")]),t._v(" "),v("p",[t._v("缓存穿透的主要原因就是："),v("strong",[t._v("查不到")])])]),t._v(" "),v("h3",{attrs:{id:"解决方案"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解决方案"}},[t._v("#")]),t._v(" 解决方案")]),t._v(" "),v("h4",{attrs:{id:"布隆过滤器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#布隆过滤器"}},[t._v("#")]),t._v(" 布隆过滤器")]),t._v(" "),v("p",[v("img",{attrs:{src:s(614),alt:"cache"}})]),t._v(" "),v("ul",[v("li",[t._v("对所有可能查询的参数以 Hash 形式存储")]),t._v(" "),v("li",[t._v("在控制层先进行校验，不符合规则丢弃，避免了对底层存储系统的查询压力")])]),t._v(" "),v("h4",{attrs:{id:"缓存空对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存空对象"}},[t._v("#")]),t._v(" 缓存空对象")]),t._v(" "),v("p",[v("img",{attrs:{src:s(615),alt:"cache"}})]),t._v(" "),v("ul",[v("li",[t._v("当存储层不命中后，将返回的空对象也缓存起来，同时设置一个过期时间")]),t._v(" "),v("li",[t._v("之后在访问这个数据会从缓存中获取，保护后端数据源")])]),t._v(" "),v("p",[v("strong",[t._v("但这种方法存在两个问题")]),t._v("：")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("存储空对象也需要空间，大量的空对象会耗费一定的空间，存储效率并不高，解决这个问题的方式就是设置较短过期时间")])]),t._v(" "),v("li",[v("p",[t._v("即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响")])])]),t._v(" "),v("h2",{attrs:{id:"缓存击穿"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存击穿"}},[t._v("#")]),t._v(" 缓存击穿")]),t._v(" "),v("h3",{attrs:{id:"什么缓存击穿"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么缓存击穿"}},[t._v("#")]),t._v(" 什么缓存击穿")]),t._v(" "),v("p",[t._v("相较于缓存穿透，缓存击穿的目的性更强")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("一个热点的 key ，大并发集中对这一个点进行访问")])]),t._v(" "),v("li",[v("p",[t._v("在缓存过期的一刻，这些请求都会击穿到 DB，造成瞬时 DB  请求量大、压力骤增")])]),t._v(" "),v("li",[v("p",[t._v("这就是缓存被击穿，只是针对其中某个key 的缓存不可用而导致击穿，但是其他的 key 依然可以使用缓存响应")])])]),t._v(" "),v("p",[t._v("比如热搜排行榜，一个热点新闻被同时大量访问就可能导致缓存击穿")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("总结")]),t._v(" "),v("p",[t._v("缓存击穿的主要原因就是："),v("strong",[t._v("量太大，缓存过期")])])]),t._v(" "),v("h3",{attrs:{id:"解决方案-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解决方案-2"}},[t._v("#")]),t._v(" 解决方案")]),t._v(" "),v("h4",{attrs:{id:"设置热点数据永不过期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#设置热点数据永不过期"}},[t._v("#")]),t._v(" 设置热点数据永不过期")]),t._v(" "),v("ul",[v("li",[t._v("从缓存层面，没有设置过期时间，就不会出现热点数据过期的情况")]),t._v(" "),v("li",[t._v("但是当 Redis 内存空间满的时候也会清理部分数据，而且此种方案会占用空间，一旦热点数据多了起来，就会占用部分空间")])]),t._v(" "),v("h4",{attrs:{id:"加互斥锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#加互斥锁"}},[t._v("#")]),t._v(" 加互斥锁")]),t._v(" "),v("ul",[v("li",[t._v("使用分布式锁，保证对于每个 key 同时只有一个线程去查询后端")]),t._v(" "),v("li",[t._v("其他线程没有获得分布式锁的权限，只需等待即可")]),t._v(" "),v("li",[t._v("这种方式将高并发的压力转移到了分布式锁")])]),t._v(" "),v("h2",{attrs:{id:"缓存雪崩"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩"}},[t._v("#")]),t._v(" 缓存雪崩")]),t._v(" "),v("h3",{attrs:{id:"什么是缓存雪崩"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是缓存雪崩"}},[t._v("#")]),t._v(" 什么是缓存雪崩")]),t._v(" "),v("ul",[v("li",[t._v("在指定某一个时间段，大量缓存集中过期或缓存服务宕机")]),t._v(" "),v("li",[t._v("造成瞬时 DB 请求量大、压力骤增，引起雪崩")])]),t._v(" "),v("p",[v("img",{attrs:{src:s(616),alt:"cache"}})]),t._v(" "),v("h3",{attrs:{id:"解决方案-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解决方案-3"}},[t._v("#")]),t._v(" 解决方案")]),t._v(" "),v("h4",{attrs:{id:"redis-高可用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis-高可用"}},[t._v("#")]),t._v(" Redis 高可用")]),t._v(" "),v("ul",[v("li",[t._v("既然 Redis 有可能挂掉，那我多增设几台 Redis")]),t._v(" "),v("li",[t._v("一台挂掉之后其他的还可以继续工作，其实就是搭建的集群")])]),t._v(" "),v("h4",{attrs:{id:"限流降级"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#限流降级"}},[t._v("#")]),t._v(" 限流降级")]),t._v(" "),v("ul",[v("li",[t._v("在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量")]),t._v(" "),v("li",[t._v("比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待")])]),t._v(" "),v("h4",{attrs:{id:"数据预热"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据预热"}},[t._v("#")]),t._v(" 数据预热")]),t._v(" "),v("ul",[v("li",[t._v("在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中")]),t._v(" "),v("li",[t._v("在即将发生大并发访问前手动触发加载缓存不同的 key，设置不同的过期时间，让缓存失效的时间点尽量均匀")])]),t._v(" "),v("p",[t._v("（完）")])])}),[],!1,null,null,null);a.default=_.exports},613:function(t,a,s){t.exports=s.p+"assets/img/cache1.67f9e4b0.png"},614:function(t,a,s){t.exports=s.p+"assets/img/cache2.0937ddd8.png"},615:function(t,a,s){t.exports=s.p+"assets/img/cache3.3f1eb85f.png"},616:function(t,a,s){t.exports=s.p+"assets/img/cache4.a24a086b.png"}}]);