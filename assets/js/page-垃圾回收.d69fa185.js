(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{474:function(t,a,s){t.exports=s.p+"assets/img/gc-mark-compact.8ed138b5.png"},475:function(t,a,s){t.exports=s.p+"assets/img/v8-memory-allocation.1c1ad13d.png"},476:function(t,a,s){t.exports=s.p+"assets/img/incremental-marking.0c6ca703.png"},573:function(t,a,s){"use strict";s.r(a);var n=s(1),r=Object(n.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"垃圾回收"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[t._v("#")]),t._v(" 垃圾回收")]),t._v(" "),n("h2",{attrs:{id:"前置概念"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#前置概念"}},[t._v("#")]),t._v(" 前置概念")]),t._v(" "),n("h3",{attrs:{id:"内存管理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#内存管理"}},[t._v("#")]),t._v(" 内存管理")]),t._v(" "),n("p",[t._v("内存管理指申请内存空间、使用内存空间和释放内存空间的这一系列步骤。")]),t._v(" "),n("p",[t._v("JavaScript 不能像 C 或 C++ 那样由开发者主动调用 API 来完成内存管理，而是使用垃圾回收机制来自动管理内存，其好处是可以大幅简化程序的内存管理代码，降低程序员的负担，减少因长时间运转而带来的内存泄露问题。")]),t._v(" "),n("h3",{attrs:{id:"何为垃圾"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#何为垃圾"}},[t._v("#")]),t._v(" 何为垃圾")]),t._v(" "),n("p",[t._v("在 JavaScript 中以下两种对象数据被定义为垃圾：")]),t._v(" "),n("ul",[n("li",[t._v("对象不再被引用时就是垃圾。")]),t._v(" "),n("li",[t._v("对象不能"),n("strong",[t._v("从根上访问到")]),t._v("时就是垃圾（对象不是可达对象 === 垃圾）。")])]),t._v(" "),n("h3",{attrs:{id:"可达对象"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#可达对象"}},[t._v("#")]),t._v(" 可达对象")]),t._v(" "),n("p",[t._v("在谈到 JavaScript 的垃圾回收时，「可达对象」这个名词会经常提及，那么什么是可达对象呢？")]),t._v(" "),n("ul",[n("li",[t._v("可以访问到的对象就是可达对象（通过引用、作用域链可以查找到）。")]),t._v(" "),n("li",[t._v("可达的标准就是从根出发是否能够被找到。")]),t._v(" "),n("li",[t._v("JavaScript 中的根可以理解为是全局变量对象（全局执行上下文）。")])]),t._v(" "),n("p",[t._v("在清楚上述这些前置概念后，就可以进入正文了。")]),t._v(" "),n("h2",{attrs:{id:"gc-算法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#gc-算法"}},[t._v("#")]),t._v(" GC 算法")]),t._v(" "),n("h3",{attrs:{id:"gc-里的垃圾"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#gc-里的垃圾"}},[t._v("#")]),t._v(" GC 里的垃圾")]),t._v(" "),n("p",[t._v("GC（Garbage Collection）是垃圾回收机制的简写，它可以查找内存中的垃圾、释放空间和回收空间。在 GC 中，有两种判定为垃圾的标准（当作垃圾 ≠ 被回收）：")]),t._v(" "),n("ul",[n("li",[t._v("程序中不再需要使用的对象")])]),t._v(" "),n("div",{staticClass:"language-javascript line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-javascript"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("func")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 没有声明变量的关键字，name 被挂载在当前的 Window 对象下")]),t._v("\n  name "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'peter'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token template-string"}},[n("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),n("span",{pre:!0,attrs:{class:"token interpolation"}},[n("span",{pre:!0,attrs:{class:"token interpolation-punctuation punctuation"}},[t._v("${")]),t._v("name"),n("span",{pre:!0,attrs:{class:"token interpolation-punctuation punctuation"}},[t._v("}")])]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v(" is a dog.")]),n("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("func")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br"),n("span",{staticClass:"line-number"},[t._v("5")]),n("br"),n("span",{staticClass:"line-number"},[t._v("6")]),n("br"),n("span",{staticClass:"line-number"},[t._v("7")]),n("br")])]),n("ul",[n("li",[t._v("程序中不能再访问到的对象")])]),t._v(" "),n("div",{staticClass:"language-javascript line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-javascript"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("func")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 增加声明变量的关键字，当函数调用结束后，在外部空间就不能访问到 name 了")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" name "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'peter'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token template-string"}},[n("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),n("span",{pre:!0,attrs:{class:"token interpolation"}},[n("span",{pre:!0,attrs:{class:"token interpolation-punctuation punctuation"}},[t._v("${")]),t._v("name"),n("span",{pre:!0,attrs:{class:"token interpolation-punctuation punctuation"}},[t._v("}")])]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v(" is a dog.")]),n("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("func")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br"),n("span",{staticClass:"line-number"},[t._v("5")]),n("br"),n("span",{staticClass:"line-number"},[t._v("6")]),n("br"),n("span",{staticClass:"line-number"},[t._v("7")]),n("br")])]),n("p",[t._v("在垃圾回收器进行工作的时候，如何查找垃圾、怎样释放空间、回收空间时如何进行分配，这一系列过程中遵循的规则，就是 GC 算法。")]),t._v(" "),n("p",[t._v("常见的 GC 算法有：")]),t._v(" "),n("ul",[n("li",[t._v("引用计数：通过一个数字判断当前对象是不是垃圾。")]),t._v(" "),n("li",[t._v("标记清除：在 GC 工作时给活动对象添加一个标记，来判断它是否是一个垃圾。")]),t._v(" "),n("li",[t._v("标记整理：同标记清除，但在后续回收过程中可以做一些不同的事情。")]),t._v(" "),n("li",[t._v("分代回收：V8 中的回收机制。")])]),t._v(" "),n("p",[t._v("下面分别讲一下这几种常见算法的实现原理。")]),t._v(" "),n("h3",{attrs:{id:"引用计数算法实现原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#引用计数算法实现原理"}},[t._v("#")]),t._v(" 引用计数算法实现原理")]),t._v(" "),n("p",[t._v("核心思想：在内部通过一个引用计数器，维护当前对象的引用数。在引用关系改变时修改引用计数器的数字。当这个数值为 0 的时候，GC 开始工作，将其所在的对象空间进行回收和释放。")]),t._v(" "),n("p",[t._v("引用计数算法优点：")]),t._v(" "),n("ul",[n("li",[t._v("可以即时回收垃圾对象")]),t._v(" "),n("li",[t._v("最大限度减少程序卡顿时间（能尽可能保证内存不会有占满的时候）")])]),t._v(" "),n("p",[t._v("引用计数算法缺点：")]),t._v(" "),n("ul",[n("li",[t._v("无法回收循环引用的对象")])]),t._v(" "),n("div",{staticClass:"language-javascript line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-javascript"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("fn")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" obj1 "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" obj2 "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  obj1"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" obj2"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  obj2"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" obj1"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'peter is a dog.'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 函数调用完后，虽然全局作用域内找不到 obj1 和 obj2")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 但由于他们两者之间有互相指引关系，所以引用计数器数值不为 0，因此空间无法回收")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("fn")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br"),n("span",{staticClass:"line-number"},[t._v("5")]),n("br"),n("span",{staticClass:"line-number"},[t._v("6")]),n("br"),n("span",{staticClass:"line-number"},[t._v("7")]),n("br"),n("span",{staticClass:"line-number"},[t._v("8")]),n("br"),n("span",{staticClass:"line-number"},[t._v("9")]),n("br"),n("span",{staticClass:"line-number"},[t._v("10")]),n("br"),n("span",{staticClass:"line-number"},[t._v("11")]),n("br")])]),n("ul",[n("li",[t._v("资源消耗较大（需要时刻监控当前对象的引用数值）")])]),t._v(" "),n("h3",{attrs:{id:"标记清除算法实现原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#标记清除算法实现原理"}},[t._v("#")]),t._v(" 标记清除算法实现原理")]),t._v(" "),n("p",[t._v("核心思想：将整个垃圾回收操作分成「标记」和「清除」二个阶段完成。")]),t._v(" "),n("p",[t._v("第一个阶段会遍历所有对象，找出活动对象（可达对象）并标记。第二个阶段仍是遍历所有对象，清除没有标记的对象，同时消除在第一阶段设置的标记，便于 GC 下一次的正常工作。")]),t._v(" "),n("p",[t._v("经过两个阶段的遍历行为，可以回收相应的空间，交给空闲列表维护以供后续的程序代码使用。")]),t._v(" "),n("p",[t._v("标记清除算法优点：")]),t._v(" "),n("ul",[n("li",[t._v("可以回收循环引用的对象（例如函数局部作用域内互相引用的变量，当函数调用结束之后，局部空间的变量失去了与全局空间在作用域上的连接，成为了不可达对象，在标记阶段就无法完成标记，在清除阶段会被清除）")])]),t._v(" "),n("p",[t._v("标记清除算法缺点：")]),t._v(" "),n("ul",[n("li",[t._v("容易产生碎片化空间，浪费空间（由于当前所回收的垃圾对象在地址上本身是不连续的，在回收之后它们会分散在各个角落，后续使用的时候如果新的生成空间刚好大小匹配就可以直接用，如果多了或者少了就不太适合使用了）")]),t._v(" "),n("li",[t._v("不会立即回收垃圾对象")])]),t._v(" "),n("h3",{attrs:{id:"标记整理算法实现原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#标记整理算法实现原理"}},[t._v("#")]),t._v(" 标记整理算法实现原理")]),t._v(" "),n("p",[t._v("核心思想：标记整理可以看作是标记清除的增强。标记阶段的操作和标记清除一致，清除阶段会先执行整理，移动对象位置（让它们在地址上产生连续）。")]),t._v(" "),n("div",{staticStyle:{"text-align":"center"}},[n("img",{staticStyle:{width:"600px"},attrs:{src:s(474),alt:"标记整理算法图示"}}),t._v(" "),n("p",{staticStyle:{"text-align":"center",color:"#888"}},[t._v("（标记整理算法图示）")])]),t._v(" "),n("p",[t._v("标记整理算法优点：")]),t._v(" "),n("ul",[n("li",[t._v("减少碎片化空间")])]),t._v(" "),n("p",[t._v("标记整理算法缺点：")]),t._v(" "),n("ul",[n("li",[t._v("不会立即回收垃圾对象")])]),t._v(" "),n("h2",{attrs:{id:"v8-垃圾回收"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#v8-垃圾回收"}},[t._v("#")]),t._v(" V8 垃圾回收")]),t._v(" "),n("h3",{attrs:{id:"认识-v8"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#认识-v8"}},[t._v("#")]),t._v(" 认识 V8")]),t._v(" "),n("p",[t._v("V8 是一款主流的 JavaScript 执行引擎，日常使用的 Chrome 浏览器和目前的 Node.js 平台都采用这个引擎去执行 JavaScript 代码。因为 V8 采用即时编译，能将源代码直接翻译成可直接执行的机器码，所以速度非常快。")]),t._v(" "),n("p",[t._v("V8 对所能使用的内存空间进行了上限约束：64 位操作系统为 1.5GB，32 位操作系统为 800MB。")]),t._v(" "),n("div",{staticClass:"custom-block tip"},[n("p",{staticClass:"custom-block-title"},[t._v("为什么是 1.5GB 这个数值？")]),t._v(" "),n("p",[t._v("V8 最初是作为浏览器的 JavaScript 引擎而设计，所以对网页应用来说不太可能遇到大量内存的场景。"),n("br"),t._v("\nV8 内部实现的垃圾回收机制，也决定了这个数值设定比较合理（V8 在执行垃圾回收时会阻塞 JavaScript应用逻辑，经官方测试，当垃圾内存达到 1.5GB 时，采用增量标记算法进行垃圾回收需要消耗 50ms，采用非增量标记算法进行垃圾回收需要消耗 1s，这样浏览器将在 1s 内失去对用户的响应，造成假死现象）。")])]),t._v(" "),n("h3",{attrs:{id:"v8-内存分配"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#v8-内存分配"}},[t._v("#")]),t._v(" V8 内存分配")]),t._v(" "),n("p",[t._v("V8 将内存（堆）空间一分为二，其中小空间用于存储新生代对象（64 位 - 32MB | 32 位 - 16MB），另一部分较大空间用于存储老生代对象（64 位 - 1.4GB | 32 位 - 700MB）。")]),t._v(" "),n("div",{staticClass:"custom-block tip"},[n("p",{staticClass:"custom-block-title"},[t._v("解释")]),t._v(" "),n("p",[t._v("新生代对象指的是存活时间较短的对象（例如局部作用域中的变量）。"),n("br"),t._v("\n老生代对象指的是存活时间较长的对象（例如全局作用域下的变量、闭包中放置的变量）。")])]),t._v(" "),n("div",{staticStyle:{"text-align":"center"}},[n("img",{attrs:{src:s(475),alt:"V8 内存分配"}}),t._v(" "),n("p",{staticStyle:{"text-align":"center",color:"#888"}},[t._v("（V8 内存分配）")])]),t._v(" "),n("h3",{attrs:{id:"v8-垃圾回收策略"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#v8-垃圾回收策略"}},[t._v("#")]),t._v(" V8 垃圾回收策略")]),t._v(" "),n("p",[t._v("在 JavaScript 中的数据，分为基本数据类型和引用数据类型两种，其中基本数据类型由程序语言自身进行控制，V8 所进行的垃圾回收操作主要针对存在堆内存中的引用数据类型。")]),t._v(" "),n("p",[t._v("V8 采用分代回收的思想，将内存分为新生代、老生代。针对不同代的对象采用不同的 GC 算法进行回收。")]),t._v(" "),n("p",[t._v("V8 中常用的 GC 算法有：")]),t._v(" "),n("ul",[n("li",[t._v("分代回收")]),t._v(" "),n("li",[t._v("空间复制")]),t._v(" "),n("li",[t._v("标记清除")]),t._v(" "),n("li",[t._v("标记整理")]),t._v(" "),n("li",[t._v("增量标记")])]),t._v(" "),n("h3",{attrs:{id:"v8-如何回收新生代对象"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#v8-如何回收新生代对象"}},[t._v("#")]),t._v(" V8 如何回收新生代对象")]),t._v(" "),n("ul",[n("li",[t._v("采用复制算法 + 标记整理算法。")]),t._v(" "),n("li",[t._v("新生代内存区分为两个大小相等的空间：使用空间为 From，空闲空间为 To。")]),t._v(" "),n("li",[t._v("每当有新生对象诞生，就会在 From 空间出现。")]),t._v(" "),n("li",[t._v("一旦 From 空间被占满，就触发 GC。")]),t._v(" "),n("li",[t._v("对 From 空间的活动对象进行标记整理，然后将它们整个拷贝至 To。")]),t._v(" "),n("li",[t._v("清空 From 空间 （这样就可以实现把不活跃的对象给回收掉）。")]),t._v(" "),n("li",[t._v("From 与 To 交换空间，开始下一轮循环。")])]),t._v(" "),n("p",[t._v("注意点：")]),t._v(" "),n("ul",[n("li",[t._v("拷贝过程中可能出现晋升：将新生代对象移动至老生代存储区。")]),t._v(" "),n("li",[t._v("一轮 GC 结束还存活的新生代对象需要晋升。")]),t._v(" "),n("li",[t._v("拷贝时发现 To 空间的使用率超过 25%，则将本次拷贝对象直接移动至老生代存储区（25%：防止交换空间后，From 空间直接爆满，新的活动对象存不进去）。")])]),t._v(" "),n("h3",{attrs:{id:"v8-如何回收老生代对象"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#v8-如何回收老生代对象"}},[t._v("#")]),t._v(" V8 如何回收老生代对象")]),t._v(" "),n("ul",[n("li",[t._v("主要采用标记清除、标记整理、增量标记算法")]),t._v(" "),n("li",[t._v("首先使用标记清除完成垃圾空间的回收（相对于空间碎片的问题，能够明显提升速度）")]),t._v(" "),n("li",[t._v("采用标记整理进行空间优化（新生代对象晋升时，如果老生代存储区空间不够，就触发标记整理）")]),t._v(" "),n("li",[t._v("采用增量标记进行效率优化")])]),t._v(" "),n("p",[t._v("细节对比：")]),t._v(" "),n("ul",[n("li",[t._v("新生代区域垃圾回收使用空间换时间（复制算法导致每时每刻都会存在一个空闲空间）")]),t._v(" "),n("li",[t._v("老生代区域垃圾回收不适合复制算法（老生代存储空间较大，如果一分为二会浪费太多空间。且老生代存储空间会存储较多对象数据，如果进行复制操作会消耗过多时间。）")])]),t._v(" "),n("p",[t._v("增量标记算法如何优化垃圾回收：")]),t._v(" "),n("p",[t._v("当垃圾回收开始工作的时候，会阻塞当前 JavaScript 程序的执行，于是就会产生「空档期」。增量标记算法能够将原本一整段的垃圾回收操作拆分成多个小步骤，从而替代原先一口气完成的垃圾回收操作，这样做可以让垃圾回收与程序执行交替工作。")]),t._v(" "),n("p",[t._v("如下图所示，当程序运行到某个时刻，触发垃圾回收机制。首先对老生代存储区的对象数据进行遍历，先找到第一层的可达对象，然后程序继续执行，接着对子元素（第二层可达对象）进行标记操作，接着程序继续执行，以此循环直到标记过程结束，最后完成垃圾回收操作后，程序继续执行。")]),t._v(" "),n("div",{staticStyle:{"text-align":"center"}},[n("img",{attrs:{src:s(476),alt:"增量标记算法如何优化垃圾回收"}}),t._v(" "),n("p",{staticStyle:{"text-align":"center",color:"#888"}},[t._v("（增量标记算法如何优化垃圾回收）")])]),t._v(" "),n("p",[t._v("上述这个过程看似程序停顿了很多次，但整个 V8 最大的垃圾回收（达到 1.5GB）即使采用非增量标记的方式去回收也不会超过 1s。")]),t._v(" "),n("h2",{attrs:{id:"垃圾"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#垃圾"}},[t._v("#")]),t._v(" 垃圾")])])}),[],!1,null,null,null);a.default=r.exports}}]);