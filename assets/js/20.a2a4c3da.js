(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{369:function(_,v,e){"use strict";e.r(v);var t=e(25),a=Object(t.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",{attrs:{id:"数据类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据类型"}},[_._v("#")]),_._v(" 数据类型")]),_._v(" "),e("p",[_._v("JavaScript 中共有 5 种基本数据类型和 1 种复杂数据类型。")]),_._v(" "),e("h2",{attrs:{id:"_1-六种数据类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-六种数据类型"}},[_._v("#")]),_._v(" 1. 六种数据类型")]),_._v(" "),e("ul",[e("li",[_._v("5 种基本数据类型：Undefined、Null、Boolean、Number 和 String。")]),_._v(" "),e("li",[_._v("1 种复杂数据类型：Object。")])]),_._v(" "),e("h2",{attrs:{id:"_2-typeof-操作符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-typeof-操作符"}},[_._v("#")]),_._v(" 2. typeof 操作符")]),_._v(" "),e("p",[e("code",[_._v("typeof")]),_._v(" 用于检测给定变量的数据类型，对一个值使用 typeof 操作符可能返回下列某个字符串：")]),_._v(" "),e("ul",[e("li",[e("code",[_._v('"undefined"')]),_._v(" —— 如果这个值未定义；")]),_._v(" "),e("li",[e("code",[_._v('"boolean"')]),_._v(" —— 如果这个值是布尔值；")]),_._v(" "),e("li",[e("code",[_._v('"string"')]),_._v(" —— 如果这个值是字符串；")]),_._v(" "),e("li",[e("code",[_._v('"number"')]),_._v(" —— 如果这个值是数值；")]),_._v(" "),e("li",[e("code",[_._v('"object"')]),_._v(" —— 如果这个值是对象或 null；")]),_._v(" "),e("li",[e("code",[_._v('"function"')]),_._v(" —— 如果这个值是函数。")])]),_._v(" "),e("p",[_._v("注："),e("code",[_._v("typeof")]),_._v(" 是一个操作符而不是函数，后面可加括号也可省略。")]),_._v(" "),e("h2",{attrs:{id:"_3-数据类型详解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-数据类型详解"}},[_._v("#")]),_._v(" 3. 数据类型详解")]),_._v(" "),e("h3",{attrs:{id:"_3-1-undefined-类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-undefined-类型"}},[_._v("#")]),_._v(" 3.1 Undefined 类型")]),_._v(" "),e("p",[_._v("Undefined 类型只有一个值，即特殊的 "),e("code",[_._v("undefined")]),_._v("。"),e("br"),_._v("\n在使用 "),e("code",[_._v("var")]),_._v(" 声明变量但未对其加以初始化时，这个变量的值就是 "),e("code",[_._v("undefined")]),_._v("；")]),_._v(" "),e("p",[_._v("对未初始化和未声明的变量执行 "),e("code",[_._v("typeof")]),_._v(" 操作符都会返回 "),e("code",[_._v("undefined")]),_._v(" 值。")]),_._v(" "),e("p",[e("strong",[_._v("显示地初始化变量是明智的选择")]),_._v("，这样当 "),e("code",[_._v("typeof")]),_._v(" 操作符返回 "),e("code",[_._v('"undefined"')]),_._v(" 值时，我们就知道被检测地变量还没有被声明，而不是尚未初始化。（—— 出自红宝书）")]),_._v(" "),e("h3",{attrs:{id:"_3-2-null-类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-null-类型"}},[_._v("#")]),_._v(" 3.2 Null 类型")]),_._v(" "),e("p",[_._v("Null 类型也只有一个值，即特殊的 "),e("code",[_._v("null")]),_._v("。"),e("br"),_._v("\n从逻辑角度来看，"),e("code",[_._v("null")]),_._v(" 值表示一个"),e("strong",[_._v("空对象指针")]),_._v("，所以使用 "),e("code",[_._v("typeof")]),_._v(" 操作符检测 "),e("code",[_._v("null")]),_._v(" 值时会返回 "),e("code",[_._v('"object"')]),_._v("。")]),_._v(" "),e("p",[_._v("如果定义的变量准备在将来"),e("strong",[_._v("用于保存对象")]),_._v("，那么最好将该变量初始化为 null 而不是其他值。这样一来，只要直接检查相应的变量是否等于 null 值就可以知道它是否已经保存了一个对象的引用。（—— 出自红宝书）")]),_._v(" "),e("p",[_._v("实际上，"),e("code",[_._v("undefined")]),_._v(" 值是派生自 "),e("code",[_._v("null")]),_._v(" 值的，因此 null == undefined 会返回 true，但 "),e("code",[_._v("null === undefined")]),_._v(" 则返回 "),e("code",[_._v("false")]),_._v(" 了。")]),_._v(" "),e("h3",{attrs:{id:"_3-3-boolean-类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-boolean-类型"}},[_._v("#")]),_._v(" 3.3 Boolean 类型")]),_._v(" "),e("p",[_._v("Boolean 类型只有两个字面值："),e("code",[_._v("true")]),_._v(" 和 "),e("code",[_._v("false")]),_._v("。")]),_._v(" "),e("h3",{attrs:{id:"_3-4-number-类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-number-类型"}},[_._v("#")]),_._v(" 3.4 Number 类型")]),_._v(" "),e("p",[_._v("Number 类型使用 "),e("a",{attrs:{href:"https://baike.baidu.com/item/IEEE%20754/3869922?fr=aladdin",target:"_blank",rel:"noopener noreferrer"}},[_._v("IEEE754"),e("OutboundLink")],1),_._v(" 格式来表示整数和浮点数值。")]),_._v(" "),e("h4",{attrs:{id:"_3-4-1-浮点数值的整数化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-1-浮点数值的整数化"}},[_._v("#")]),_._v(" 3.4.1 浮点数值的整数化")]),_._v(" "),e("p",[_._v("因为保存浮点数值需要得内存空间是保存整数值的两倍，所以凡是可以「整数化」的浮点数都会被转换为整数值，例如："),e("code",[_._v("1.")]),_._v(" 和 "),e("code",[_._v("1.0")]),_._v(" 都会被解析为 "),e("code",[_._v("1")]),_._v("。")]),_._v(" "),e("p",[_._v("对于那些极大或极小的数值，可以用 e 表示法（即科学计数法）表示的浮点数值表示。（用 e 表示法表示的数值等于 e 前面的数值乘以 10 的指数次幂）")]),_._v(" "),e("h4",{attrs:{id:"_3-4-2-数值范围限制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-2-数值范围限制"}},[_._v("#")]),_._v(" 3.4.2 数值范围限制")]),_._v(" "),e("p",[_._v("JavaScript 能够表示的"),e("strong",[_._v("最小数值")]),_._v("为 "),e("code",[_._v("Number.MIN_VALUE")]),_._v("，在大多数浏览器中这个值是 "),e("code",[_._v("5e-324")]),_._v("；"),e("br"),_._v("\nJavaScript 能够表示的"),e("strong",[_._v("最大数值")]),_._v("为 "),e("code",[_._v("Number.MAX_VALUE")]),_._v("，在大多数浏览器中这个值是 "),e("code",[_._v("1.7976931348623157e+308")]),_._v("。")]),_._v(" "),e("p",[_._v("超出范围的正数会被转换成 "),e("code",[_._v("Infinity")]),_._v("（正无穷），超出范围的负数会被转换成 "),e("code",[_._v("-Infinity")]),_._v("（负无穷）。")]),_._v(" "),e("p",[_._v("可以使用 "),e("code",[_._v("isFinite()")]),_._v(" 函数判断括号里的参数是否位于最小与最大数值之间。")]),_._v(" "),e("h4",{attrs:{id:"_3-4-3-特殊的-nan"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-3-特殊的-nan"}},[_._v("#")]),_._v(" 3.4.3 特殊的 NaN")]),_._v(" "),e("p",[e("code",[_._v("NaN")]),_._v("，即非数值（Not a Number）是一个特殊的数值。它有两个特点：一是任何涉及 "),e("code",[_._v("NaN")]),_._v(" 的操作都会返回 "),e("code",[_._v("NaN")]),_._v("，二是 "),e("code",[_._v("NaN")]),_._v(" 与任何值都不相等，包括 "),e("code",[_._v("NaN")]),_._v(" 本身。")]),_._v(" "),e("p",[_._v("可以通过 "),e("code",[_._v("isNaN()")]),_._v(" 函数来确认括号里的参数是否「不是数值」，需要注意的是，"),e("code",[_._v("isNaN()")]),_._v(" 在接收到一个参数后，会尝试将这个值转换为数值，某些不是数值的值会直接转换为数值，例如字符串 "),e("code",[_._v('"10"')]),_._v(" 或 "),e("code",[_._v("Boolean")]),_._v(" 值。")]),_._v(" "),e("h4",{attrs:{id:"_3-4-4-数值转换函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-4-数值转换函数"}},[_._v("#")]),_._v(" 3.4.4 数值转换函数")]),_._v(" "),e("p",[_._v("有 3 个函数可以把非数值转换为数值："),e("code",[_._v("Number()")]),_._v("、"),e("code",[_._v("parseInt()")]),_._v(" 和 "),e("code",[_._v("parseFloat()")]),_._v("。")]),_._v(" "),e("p",[_._v("由于 "),e("code",[_._v("Number()")]),_._v(" 函数在转换字符串时比较复杂而且不够合理，因此更常用过的是另外两个函数。（—— 出自红宝书）")]),_._v(" "),e("p",[e("code",[_._v("parseInt()")]),_._v(" 在转换时可以拥有第二个参数：转换时使用的基数（即多少进制），建议无论在什么情况下都明确指定基数。（—— 出自红宝书）")]),_._v(" "),e("p",[e("code",[_._v("parseFloat()")]),_._v(" 只解析十进制值，因此它没有用第二个参数指定基数的用法。另外如果字符串没有小数点，或者小数点后都是零，"),e("code",[_._v("parseFloat()")]),_._v(" 会返回整数。")]),_._v(" "),e("p",[e("strong",[_._v("转换规则")]),_._v("：这 3 个函数都会忽略字符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或负号，就会返回 "),e("code",[_._v("NaN")]),_._v("，直到解析完所有后续字符或者遇到了一个非数字字符。"),e("br"),_._v("\n区别是 "),e("code",[_._v("parseInt()")]),_._v(" 转换过程中，小数点不是有效的数字字符；而 "),e("code",[_._v("parseFloat()")]),_._v(" 转换过程中，第一个小数点是有效的，后面的小数点是无效的，从第二个小数点开始的后面所有字符会被忽略。")]),_._v(" "),e("h3",{attrs:{id:"_3-5-string-类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-string-类型"}},[_._v("#")]),_._v(" 3.5 String 类型")]),_._v(" "),e("p",[_._v("String 类型用于表示由零或多个 16 位 Unicode 字符组成的字符序列，即字符串。")]),_._v(" "),e("h4",{attrs:{id:"数值转换字符串"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数值转换字符串"}},[_._v("#")]),_._v(" 数值转换字符串")]),_._v(" "),e("p",[_._v("要把一个值转换为一个字符串有两种方式：")]),_._v(" "),e("p",[_._v("第一种，几乎每个值都有的 "),e("code",[_._v("toString()")]),_._v(" 方法（除了 "),e("code",[_._v("null")]),_._v(" 和 "),e("code",[_._v("undefined")]),_._v("）。其中数值型字符串在调用该方法时，可以传递一个参数——输出数值的基数（默认是十进制）。")]),_._v(" "),e("p",[_._v("第二种，"),e("code",[_._v("String()")]),_._v(" 函数，它在转换过程中，如果值有 "),e("code",[_._v("toString()")]),_._v(" 方法，则调用该方法（没有参数）；如果值是 "),e("code",[_._v("null")]),_._v("，则返回 "),e("code",[_._v('"null"')]),_._v("；如果值是 "),e("code",[_._v("undefined")]),_._v("，则返回 "),e("code",[_._v('"undefined"')]),_._v("。")]),_._v(" "),e("h3",{attrs:{id:"_3-6-object-类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-6-object-类型"}},[_._v("#")]),_._v(" 3.6 Object 类型")]),_._v(" "),e("p",[_._v("JavaScript 中的对象是一组数据和功能的集合。对象可以通过执行 "),e("code",[_._v("new")]),_._v(" 操作符后跟要创建的对象类型的名称来创建。")]),_._v(" "),e("p",[_._v("简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。")])])}),[],!1,null,null,null);v.default=a.exports}}]);