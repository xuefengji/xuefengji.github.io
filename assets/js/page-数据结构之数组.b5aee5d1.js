(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{472:function(_,a,t){"use strict";t.r(a);var s=t(1),v=Object(s.a)({},(function(){var _=this,a=_.$createElement,t=_._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"数据结构之数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据结构之数组"}},[_._v("#")]),_._v(" 数据结构之数组")]),_._v(" "),t("h2",{attrs:{id:"_1-数组的定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-数组的定义"}},[_._v("#")]),_._v(" 1. 数组的定义")]),_._v(" "),t("p",[_._v("数组（Array）是一种线性表数据结构。它用一组"),t("strong",[_._v("连续的内存空间")]),_._v("，来存储一组具有相同类型的数据。")]),_._v(" "),t("h3",{attrs:{id:"_1-1-线性表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-线性表"}},[_._v("#")]),_._v(" 1.1 线性表")]),_._v(" "),t("p",[_._v("线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。")]),_._v(" "),t("p",[_._v("不仅是数组，链表、队列、栈等也是线性表结构。")]),_._v(" "),t("p",[_._v("与线性表相对立的概念是非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为在非线性表中，数据之间并不是简单的前后关系。")]),_._v(" "),t("h3",{attrs:{id:"_1-2-随机访问"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-随机访问"}},[_._v("#")]),_._v(" 1.2 随机访问")]),_._v(" "),t("p",[_._v("所谓随机访问，就是指根据下标随机访问数组元素。")]),_._v(" "),t("p",[_._v("当我们创建一个数组后，计算机会分配给它一块连续内存空间。假定内存块的首地址为 "),t("code",[_._v("base_address = 1000")]),_._v("。当计算机需要随机访问数组中的某个元素时，它会通过下面的寻址公式，计算出该元素存储的内存地址：")]),_._v(" "),t("div",{staticClass:"language-C line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-c"}},[t("code",[_._v("a"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("[")]),_._v("i"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("]")]),_._v("_address "),t("span",{pre:!0,attrs:{class:"token operator"}},[_._v("=")]),_._v(" base_address "),t("span",{pre:!0,attrs:{class:"token operator"}},[_._v("+")]),_._v(" i "),t("span",{pre:!0,attrs:{class:"token operator"}},[_._v("*")]),_._v(" data_type_size\n")])]),_._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[_._v("1")]),t("br")])]),t("p",[_._v("其中 "),t("code",[_._v("i")]),_._v(" 是数组索引，"),t("code",[_._v("data_type_size")]),_._v(" 表示数组中每个元素的大小（例如 int 类型数据的大小为 4 个字节）。")]),_._v(" "),t("h2",{attrs:{id:"_2-高效的查找操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-高效的查找操作"}},[_._v("#")]),_._v(" 2. 高效的查找操作")]),_._v(" "),t("p",[_._v("数组和链接最大的区别在于数组的查询效率高，链表的插入和删除效率高。但这里的查询效率高仅是指"),t("strong",[_._v("根据下标随机访问元素")]),_._v("。")]),_._v(" "),t("p",[_._v("当我们根据下标随机访问数组元素时，查询的的时间复杂度为 "),t("code",[_._v("O(1)")]),_._v("。")]),_._v(" "),t("p",[_._v("而当我们要具体查找数组里的某个值时，时间复杂度取决于用什么算法（例如用二分查找查询排好序的数组，时间复杂度是 "),t("code",[_._v("O(logn)")]),_._v("）。")]),_._v(" "),t("h2",{attrs:{id:"_3-低效的插入和删除操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-低效的插入和删除操作"}},[_._v("#")]),_._v(" 3. 低效的插入和删除操作")]),_._v(" "),t("h3",{attrs:{id:"_3-1-插入操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-插入操作"}},[_._v("#")]),_._v(" 3.1 插入操作")]),_._v(" "),t("p",[_._v("假设数组的长度为 n，如果需要将一个数据插入到数组中的第 k 个位置。为了将第 k 个位置腾出来，就需要将第 k～n 这部分的元素都顺序地往后挪一位。")]),_._v(" "),t("p",[_._v("如果在末尾插入元素，则不需要移动数据，时间复杂度为 "),t("code",[_._v("O(1)")]),_._v("；如果在开头插入元素，时间复杂度为 "),t("code",[_._v("O(n)")]),_._v("。因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 "),t("code",[_._v("(1+2+...n)/n=O(n)")]),_._v("。")]),_._v(" "),t("p",[t("strong",[_._v("优化")]),_._v("：如果数组中的数据是有序的，就必须要这么操作。但如果数组中的数据是无序的，则可以取巧来优化：直接将第 k 位的数据搬移到数组的最后，把新的元素直接放入第 k 个位置。利用这种处理技巧，在特定场景下，在第 k 个位置插入一个元素的时间复杂度就会降为 "),t("code",[_._v("O(1)")]),_._v("。这个处理思想在快排中也会用到。")]),_._v(" "),t("h3",{attrs:{id:"_3-2-删除操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-删除操作"}},[_._v("#")]),_._v(" 3.2 删除操作")]),_._v(" "),t("p",[_._v("跟插入数据类似，如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。")]),_._v(" "),t("p",[t("strong",[_._v("优化")]),_._v("：在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率就会提高很多。"),t("br"),_._v("\n例如要依次删除三个元素，为了避免后续数据被搬移三次，可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。这也是 JVM 标记清除垃圾回收算法的核心思想。")]),_._v(" "),t("h2",{attrs:{id:"_4-支持动态扩容的容器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-支持动态扩容的容器"}},[_._v("#")]),_._v(" 4. 支持动态扩容的容器")]),_._v(" "),t("p",[_._v("数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间。当我们需要插入更多的元素时，需要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。")]),_._v(" "),t("p",[_._v("我们平时用高级语言编写代码时，往往不需要关心底层的扩容逻辑，因为这些语言都提供了容器类（比如 Java 中的 ArrayList、Python 中的 list），它们将很多数组操作的细节封装起来（在插入、删除数据时的搬移操作），并且还支持动态扩容。")]),_._v(" "),t("p",[_._v("需要注意的是，因为扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好在创建容器的时候事先指定数据大小。")]),_._v(" "),t("p",[_._v("对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。")]),_._v(" "),t("p",[_._v("（完）")])])}),[],!1,null,null,null);a.default=v.exports}}]);