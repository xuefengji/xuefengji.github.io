(window.webpackJsonp=window.webpackJsonp||[]).push([[105],{1176:function(t,a,_){"use strict";_.r(a);var v=_(1),r=Object(v.a)({},(function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"pep8"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#pep8"}},[t._v("#")]),t._v(" PEP8")]),t._v(" "),_("h3",{attrs:{id:"与空白有关的建议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#与空白有关的建议"}},[t._v("#")]),t._v(" 与空白有关的建议")]),t._v(" "),_("p",[t._v("在Python中，空白（whitespace）在语法上相当重要")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("用空格（space）表示缩进，而不要用制表符（tab）")])]),t._v(" "),_("li",[_("p",[t._v("和语法相关的每一层缩进都用 4 个空格表示")])]),t._v(" "),_("li",[_("p",[t._v("每行不超过 79 个字符")])]),t._v(" "),_("li",[_("p",[t._v("对于占据多行的长表达式来说，除了首行之外的其余各行都应该在通常的缩进级别之上再加 4 个空格")])]),t._v(" "),_("li",[_("p",[t._v("在同一份文件中，函数与类之间用 2 个空行隔开")])]),t._v(" "),_("li",[_("p",[t._v("在同一个类中，方法与方法之间用 1 个空行隔开")])]),t._v(" "),_("li",[_("p",[t._v("使用字典时，键与冒号之间不加空格，写在同一行的冒号和值之间应该加 1 个空格")])]),t._v(" "),_("li",[_("p",[t._v("给变量赋值时，赋值符号的左边和右边各加 1 个空格，并且只加一个空格就好")])]),t._v(" "),_("li",[_("p",[t._v("给变量的类型做注解（annotation）时，不要把变量名和冒号隔开，但在类型信息前应该有一个空格")])])]),t._v(" "),_("p",[t._v("这个其实不用硬背，用 pycharm 的同学应该都知道，代码格式化会自动完成这些事")]),t._v(" "),_("h3",{attrs:{id:"与命名有关的建议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#与命名有关的建议"}},[t._v("#")]),t._v(" 与命名有关的建议")]),t._v(" "),_("h4",{attrs:{id:"函数、变量及属性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#函数、变量及属性"}},[t._v("#")]),t._v(" 函数、变量及属性")]),t._v(" "),_("ul",[_("li",[t._v("用小写字母来拼写，各单词之间用下划线相连")]),t._v(" "),_("li",[t._v("lowercase_underscore")])]),t._v(" "),_("h4",{attrs:{id:"受保护的实例属性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#受保护的实例属性"}},[t._v("#")]),t._v(" 受保护的实例属性")]),t._v(" "),_("ul",[_("li",[t._v("用一个下划线开头")]),t._v(" "),_("li",[t._v("_leading_underscore")])]),t._v(" "),_("h4",{attrs:{id:"私有的实例属性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#私有的实例属性"}},[t._v("#")]),t._v(" 私有的实例属性")]),t._v(" "),_("ul",[_("li",[t._v("用两个下划线开头")]),t._v(" "),_("li",[t._v("__double_leading_underscore")])]),t._v(" "),_("h4",{attrs:{id:"类-包括异常-命名"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类-包括异常-命名"}},[t._v("#")]),t._v(" 类（包括异常）命名")]),t._v(" "),_("ul",[_("li",[t._v("每个单词的首字母均大写")]),t._v(" "),_("li",[t._v("CapitalizedWord")])]),t._v(" "),_("h4",{attrs:{id:"模块级别的常量"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#模块级别的常量"}},[t._v("#")]),t._v(" 模块级别的常量")]),t._v(" "),_("ul",[_("li",[t._v("所有字母都大写，各单词之间用下划线相连")]),t._v(" "),_("li",[t._v("ALL_CAPS")])]),t._v(" "),_("h4",{attrs:{id:"类中的实例方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类中的实例方法"}},[t._v("#")]),t._v(" 类中的实例方法")]),t._v(" "),_("p",[t._v("应该把第一个参数命名为 self，用来表示该对象本身")]),t._v(" "),_("h4",{attrs:{id:"类方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类方法"}},[t._v("#")]),t._v(" 类方法")]),t._v(" "),_("p",[t._v("第一个参数，应该命名为 cls，用来表示这个类本身")]),t._v(" "),_("h3",{attrs:{id:"与表达式和语句有关的建议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#与表达式和语句有关的建议"}},[t._v("#")]),t._v(" 与表达式和语句有关的建议")]),t._v(" "),_("h4",{attrs:{id:"采用行内否定"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#采用行内否定"}},[t._v("#")]),t._v(" 采用行内否定")]),t._v(" "),_("ul",[_("li",[t._v("把否定词直接写在要否定的内容前面，而不要放在整个表达式的前面")]),t._v(" "),_("li",[t._v("例如应该写 "),_("code",[t._v("if a is not b")]),t._v(" ，而不是"),_("code",[t._v("if not a is b")])])]),t._v(" "),_("h4",{attrs:{id:"不要通过长度判断容器或序列是不是空的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#不要通过长度判断容器或序列是不是空的"}},[t._v("#")]),t._v(" 不要通过长度判断容器或序列是不是空的")]),t._v(" "),_("ul",[_("li",[t._v("例如不要通过 "),_("code",[t._v("if len(somelist) == 0")]),t._v(" 判断 somelist 是否为 [] 或 '' 等空值")]),t._v(" "),_("li",[t._v("而是应该采用 "),_("code",[t._v("if not somelist")]),t._v(" 这样的写法来判断，因为 Python 会把空值自动评估为 False")])]),t._v(" "),_("h4",{attrs:{id:"不要通过长度判断容器或序列里面有没有内容"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#不要通过长度判断容器或序列里面有没有内容"}},[t._v("#")]),t._v(" 不要通过长度判断容器或序列里面有没有内容")]),t._v(" "),_("ul",[_("li",[t._v("比如要判断 somelist 是否为 [1] 或 'hi' 这样非空的值，也不应该通过长度来判断")]),t._v(" "),_("li",[t._v("而是应该采用 "),_("code",[t._v("if somelist")]),t._v(" ，因为 Python 会把非空的值自动判定为 True")])]),t._v(" "),_("h4",{attrs:{id:"不要把-if-语句、for-循环、while-循环及-except-复合语句挤在一行"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#不要把-if-语句、for-循环、while-循环及-except-复合语句挤在一行"}},[t._v("#")]),t._v(" 不要把 if 语句、for 循环、while 循环及 except 复合语句挤在一行")]),t._v(" "),_("ul",[_("li",[t._v("应该把这些语句分成多行来写，这样更加清晰")]),t._v(" "),_("li",[t._v("如果表达式一行写不下，可以用括号将其括起来，而且要适当地添加换行与缩进以便于阅读")])]),t._v(" "),_("h4",{attrs:{id:"多行的表达式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多行的表达式"}},[t._v("#")]),t._v(" 多行的表达式")]),t._v(" "),_("p",[t._v("应该用括号括起来，而不要用"),_("code",[t._v("\\")])]),t._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v('# 错误示范 folder["interfaces"] = db.query(Interface). \\    filter(folder_id == Interface.folder_id,           Interface.is_delete == 0). \\    all() # 正确示范 folder["interfaces"] = (    db.query(Interface)    .filter(folder_id == Interface.folder_id, Interface.is_delete == 0)    .all() )\n')])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br")])]),_("h3",{attrs:{id:"与-import-有关的建议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#与-import-有关的建议"}},[t._v("#")]),t._v(" 与 import 有关的建议")]),t._v(" "),_("ul",[_("li",[t._v("import 语句（含  "),_("code",[t._v("from x import y")]),t._v(" ）总是应该放在文件开头")]),t._v(" "),_("li",[t._v("引入模块时，总是应该使用绝对名称，而不应该根据当前模块路径来使用相对名称")]),t._v(" "),_("li",[t._v("例如，要引入 bar 包中的 foo 模块，应该完整地写出 "),_("code",[t._v("from bar import foo")]),t._v(" ，即便当前路径为 bar 包里，也不应该简写为 "),_("code",[t._v("import foo")])]),t._v(" "),_("li",[t._v("如果一定要用相对名称来编写 import 语句，那就应该明确地写成 "),_("code",[t._v("from . import foo")])])]),t._v(" "),_("h4",{attrs:{id:"文件中的-import-语句应该按顺序划分成三个部分"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#文件中的-import-语句应该按顺序划分成三个部分"}},[t._v("#")]),t._v(" 文件中的 import 语句应该按顺序划分成三个部分")]),t._v(" "),_("ol",[_("li",[t._v("首先引入标准库里的模块")]),t._v(" "),_("li",[t._v("然后引入第三方模块")]),t._v(" "),_("li",[t._v("最后引入自己的模块")])]),t._v(" "),_("p",[t._v("属于同一个部分的 import 语句按字母顺序排列")]),t._v(" "),_("h4",{attrs:{id:"提醒"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#提醒"}},[t._v("#")]),t._v(" 提醒")]),t._v(" "),_("p",[t._v("不想自己手动来保证 import 的顺序是符合规范的，可以借助 isort 这个工具来自动完成哦！")]),t._v(" "),_("p",[t._v("https://www.cnblogs.com/poloyy/p/15549542.html")]),t._v(" "),_("h3",{attrs:{id:"pylint"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#pylint"}},[t._v("#")]),t._v(" Pylint")]),t._v(" "),_("ul",[_("li",[t._v("是 Python 源码静态分析工具")]),t._v(" "),_("li",[t._v("它可以自动检查受测代码是否符合 PEP 8 风格指南，而且还能找出 Python 程序里的许多种常见错误")]),t._v(" "),_("li",[t._v("感兴趣可以自行百度学习，这里不展开讲解了")])]),t._v(" "),_("p",[t._v("（完）")])])}),[],!1,null,null,null);a.default=r.exports}}]);