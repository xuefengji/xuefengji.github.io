(window.webpackJsonp=window.webpackJsonp||[]).push([[297],{1296:function(v,_,t){"use strict";t.r(_);var s=t(1),r=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"测试覆盖率"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#测试覆盖率"}},[v._v("#")]),v._v(" 测试覆盖率")]),v._v(" "),t("p",[v._v("测试覆盖率通常被用来衡量测试的充分性和完整性， 主要分为两大类：")]),v._v(" "),t("ul",[t("li",[v._v("面向项目的需求覆盖率")]),v._v(" "),t("li",[v._v("是更偏向技术的代码覆盖率")])]),v._v(" "),t("h2",{attrs:{id:"需求覆盖率"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#需求覆盖率"}},[v._v("#")]),v._v(" 需求覆盖率")]),v._v(" "),t("p",[t("strong",[v._v("概念")]),v._v("： 是指测试对需求的覆盖程度")]),v._v(" "),t("p",[t("strong",[v._v("如何做")]),v._v("： 将每一条分解后的软件需求和对应的测试建立"),t("strong",[v._v("一对多")]),v._v("的映射关系，保证测试可以覆盖每个需求")]),v._v(" "),t("p",[t("strong",[v._v("统计方法")]),v._v("：传统瀑布模型， 自上而下地制定计划、分析需求、设计软件、编写代码、测试和运维等")]),v._v(" "),t("p",[t("strong",[v._v("缺点")]),v._v("：传统瀑布模型在流程上是重量级的，已经很难适应当今互联网时代下的敏捷开发实践")]),v._v(" "),t("p",[t("strong",[v._v("结论")]),v._v("：互联网测试项目中很少直接基于需求来衡量测试覆盖率，而是将软件需求转换成测试需求，然后基于测试需求再来设计测试点，测试覆盖率，通常默认指代码覆盖率，而不是需求覆盖率")]),v._v(" "),t("h3",{attrs:{id:"代码覆盖率"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码覆盖率"}},[v._v("#")]),v._v(" 代码覆盖率")]),v._v(" "),t("p",[t("strong",[v._v("定义")]),v._v("：至少被执行了一次"),t("strong",[v._v("条目数")]),v._v("占整个条目数的百分比")]),v._v(" "),t("p",[t("strong",[v._v("条目数")]),v._v("：")]),v._v(" "),t("ul",[t("li",[v._v("如果是语句：对应的就是代码行覆盖率")]),v._v(" "),t("li",[v._v("如果是函数：对应的就是函数覆盖率")]),v._v(" "),t("li",[v._v("如果是路径：对应的就是路径覆盖率")])]),v._v(" "),t("p",[t("strong",[v._v("3 种最常用代码覆盖率指标")]),v._v("：")]),v._v(" "),t("ul",[t("li",[v._v("行覆盖率( 语句覆盖率 )：")])]),v._v(" "),t("p",[v._v("指已经被执行到的语句占总可执行语句（不包含类似C++的头文件声明、代码注释、空行等等）的百分比")]),v._v(" "),t("ul",[t("li",[v._v("判定覆盖 ( 分支覆盖 )：")])]),v._v(" "),t("p",[v._v("代码中每个判断的取真分支和取假分支是否各被覆盖至少各一次 ， 比如，对于 "),t("code",[v._v("if(a>0 && b>0)")]),v._v("，就要求覆盖 "),t("code",[v._v("a>0 && b>0")]),v._v(" 为 TURE 和 FALSE 各一次")]),v._v(" "),t("ul",[t("li",[v._v("条件覆盖")])]),v._v(" "),t("p",[v._v("判定中的每个条件的可能取值至少满足一次，度量判定中的每个条件的结果 TRUE 和 FALSE 是否都被测试到了。比如，对于 "),t("code",[v._v("if(a>0 && b>0)")]),v._v("，就要求 "),t("code",[v._v("a>0")]),v._v(" 取 TRUE 和 FALSE 各一次，同时要求 "),t("code",[v._v("b>0")]),v._v(" 取 TRUE 和 FALSE 各一次")]),v._v(" "),t("p",[t("strong",[v._v("目的")]),v._v("：找出潜在的遗漏测试用例，并有针对性的进行补充，同时还可以识别出代码中那些由于需求变更等原因造成的不可达的废弃代码")]),v._v(" "),t("p",[t("strong",[v._v("局限性")]),v._v("：")]),v._v(" "),t("p",[v._v("所设计的测试用例已经达到 100% 的代码覆盖率，软件产品的质量也做不到万无一失")]),v._v(" "),t("p",[v._v("其根本原因在于代码覆盖率的计算是基于现有代码的，并不能发现那些“未考虑某些输入”以及“未处理某些情况”形成的缺陷")]),v._v(" "),t("p",[v._v("极端例子： 一个被测函数里面只有一行代码，只要这个函数被调用过了，那么衡量这一行代码质量的所有覆盖率指标都会是 100%，但是这个函数是否真正实现了应该需要实现的功能？")]),v._v(" "),t("p",[t("strong",[v._v("结论")]),v._v("：")]),v._v(" "),t("ul",[t("li",[v._v("代码覆盖率反映的仅仅是已有代码的哪些逻辑被执行过了，哪些逻辑还没有被执行过 ， 对于那些压根还没有代码实现的部分，基于代码覆盖率的统计指标就无能为力了")]),v._v(" "),t("li",[v._v("高的代码覆盖率不一定能保证软件的质量，但是低的代码覆盖率一定不能能保证软件的质量")])]),v._v(" "),t("p",[v._v("（完）")])])}),[],!1,null,null,null);_.default=r.exports}}]);