(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{398:function(t,a,e){t.exports=e.p+"assets/img/dom-js.5a2c887a.png"},542:function(t,a,e){"use strict";e.r(a);var v=e(1),s=Object(v.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"虚拟-dom-与-diff-算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#虚拟-dom-与-diff-算法"}},[t._v("#")]),t._v(" 虚拟 DOM 与 diff 算法")]),t._v(" "),v("h2",{attrs:{id:"_1-虚拟-dom"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-虚拟-dom"}},[t._v("#")]),t._v(" 1. 虚拟 DOM")]),t._v(" "),v("p",[t._v("虚拟 DOM（Virtual DOM）的简写为 vdom，它是实现 Vue 和 React 的重要基石。")]),t._v(" "),v("p",[t._v("在 jQuery 及更早的时代，我们需要手动调整 DOM，这是一个非常耗费性能的操作，因此需要自行控制 DOM 操作的时机来优化 jQuery 性能。")]),t._v(" "),v("p",[t._v("DOM 更新非常耗时，但 JS 执行速度很快，因此现代前端框架（如 Vue 和 React）都引入了 vdom 的概念：用 JS 模拟 DOM 结构（vnode），新旧 vnode 对比，得出最小的更新范围，最后更新 DOM。")]),t._v(" "),v("p",[t._v("在数据驱动视图的模式下，vdom 能有效控制 DOM 操作。")]),t._v(" "),v("div",{staticStyle:{"text-align":"center"}},[v("img",{attrs:{src:e(398),alt:"用 JS 模拟 DOM 结构"}}),t._v(" "),v("p",{staticStyle:{"text-align":"center",color:"#888"}},[t._v("（用 JS 模拟 DOM 结构）")])]),t._v(" "),v("h2",{attrs:{id:"_2-diff-算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-diff-算法"}},[t._v("#")]),t._v(" 2. diff 算法")]),t._v(" "),v("p",[t._v("diff 算法是 vdom 中最核心、最关键的部分。")]),t._v(" "),v("p",[t._v("为了将时间复杂度优化到 O(n)，diff 算法的思路是：")]),t._v(" "),v("ul",[v("li",[t._v("只比较同一层级，不跨级比较。")]),t._v(" "),v("li",[t._v("tag 不相同，则直接删掉重建，不再深度比较。")]),t._v(" "),v("li",[t._v("tag 和 key 两者都相同，则认为是相同节点，不再深度比较。")])])])}),[],!1,null,null,null);a.default=s.exports}}]);