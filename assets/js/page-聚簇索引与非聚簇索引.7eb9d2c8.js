(window.webpackJsonp=window.webpackJsonp||[]).push([[326],{1132:function(v,_,t){"use strict";t.r(_);var a=t(1),i=Object(a.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"聚簇索引与非聚簇索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#聚簇索引与非聚簇索引"}},[v._v("#")]),v._v(" 聚簇索引与非聚簇索引")]),v._v(" "),a("h2",{attrs:{id:"什么是聚簇索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是聚簇索引"}},[v._v("#")]),v._v(" 什么是聚簇索引")]),v._v(" "),a("ul",[a("li",[v._v("将数据存储与索引结构放到了一块")]),v._v(" "),a("li",[v._v("索引结构的叶子节点保存了行数据")])]),v._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[v._v("注意")]),v._v(" "),a("ul",[a("li",[v._v("主键索引一定是聚簇索引")]),v._v(" "),a("li",[v._v("聚簇索引不一定就是主键索引")])])]),v._v(" "),a("h2",{attrs:{id:"什么是非聚簇索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是非聚簇索引"}},[v._v("#")]),v._v(" 什么是非聚簇索引")]),v._v(" "),a("ul",[a("li",[v._v("将数据与索引结构分开存储")]),v._v(" "),a("li",[v._v("索引结构的叶子节点指向了数据对应的位置")]),v._v(" "),a("li",[v._v("InnoDB 中建立在主键索引之上的辅助索引都是非聚簇索引")]),v._v(" "),a("li",[v._v("非聚簇索引中的叶子节点存储的不是行的物理位置，而是主键值")]),v._v(" "),a("li",[v._v("辅助索引查找数据时总是需要二次查找")])]),v._v(" "),a("div",{staticClass:"custom-block danger"},[a("p",{staticClass:"custom-block-title"},[v._v("重点")]),v._v(" "),a("p",[v._v("为什么非聚簇索引中的叶子节点存的是主键 id 而不是数据的地址？")]),v._v(" "),a("p",[v._v("因为数据库的增删改，会使得地址改变")])]),v._v(" "),a("h2",{attrs:{id:"innodb-与-myisam-中索引对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#innodb-与-myisam-中索引对比"}},[v._v("#")]),v._v(" InnoDB 与 MyISAM 中索引对比")]),v._v(" "),a("h3",{attrs:{id:"innodb-中"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#innodb-中"}},[v._v("#")]),v._v(" InnoDB 中")]),v._v(" "),a("ul",[a("li",[v._v("使用的是聚簇索引，将主键组织到一颗 B+树 中，行数据存储在叶子节点上")]),v._v(" "),a("li",[v._v("使用 "),a("code",[v._v("where id=14")]),v._v(" 查找主键，则按照 B+树 的检索算法即可找到对应的叶节点获取数据")]),v._v(" "),a("li",[v._v("若对 Name 列进行条件搜索需要两个步骤(在建立非聚簇索引的情况下)：\n"),a("ul",[a("li",[v._v("在辅助索引 B+树 中检索 Name，在对应的叶子节点上获取对应的主键")]),v._v(" "),a("li",[v._v("使用主键在主键索引 B+树 中再执行 B+树 检索操作，最终到达叶子节点获取整行数据")])])]),v._v(" "),a("li",[v._v("聚簇索引默认是主键：\n"),a("ul",[a("li",[v._v("如果没有定义主键，InnoDB 会选择一个**唯一且非空的索引(unique 索引)**代替")]),v._v(" "),a("li",[v._v("如果没有这样的索引，InnoDB 会**隐式定义一个主键(类似于 oracle 中的 RowId)**作为聚簇索引")]),v._v(" "),a("li",[v._v("如果已经设置了主键为聚簇索引，又希望单独设置其他的聚簇索引，必须先删除主键添加想要的聚簇索引，然后恢复主键")])])])]),v._v(" "),a("p",[a("img",{attrs:{src:t(601),alt:"index"}})]),v._v(" "),a("h3",{attrs:{id:"myisam-中"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#myisam-中"}},[v._v("#")]),v._v(" MyISAM 中")]),v._v(" "),a("ul",[a("li",[v._v("使用的是非聚簇索引")]),v._v(" "),a("li",[v._v("非聚簇索引的两颗 B+树 结构一致，只有存储的内容不一致")]),v._v(" "),a("li",[v._v("主键索引 B+树 的节点存储了主键，辅助索引 B+树 存储了辅助键")]),v._v(" "),a("li",[v._v("表数据存储在独立的地方")]),v._v(" "),a("li",[v._v("两颗 B+树 的叶子节点都使用一个地址指向真正的表数据")]),v._v(" "),a("li",[v._v("由于索引树是独立的，通过辅助键检索无需访问主键的索引树")])]),v._v(" "),a("p",[a("img",{attrs:{src:t(602),alt:"index"}})]),v._v(" "),a("h3",{attrs:{id:"聚簇索引的优势"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#聚簇索引的优势"}},[v._v("#")]),v._v(" 聚簇索引的优势")]),v._v(" "),a("p",[v._v("每次使用辅助索引检索都要经过两次 B+树 查找，看上去聚簇索引的效率明显要低于非聚簇索引，那聚簇索引的优势在哪？")]),v._v(" "),a("ul",[a("li",[v._v("由于数据和聚簇索引的叶子节点存储在一起，同一页会有多条行数据，访问同一数据页不同行记录时，已经把页加载到 Buffer(缓存器)，再次访问时，会在内存在访问，不用进行 I/O 操作这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键 Id 来组织数据，获得数据更快")]),v._v(" "),a("li",[v._v("辅助索引的叶子节点，存储主键值，不是数据的存放地址")]),v._v(" "),a("li",[v._v("当行数据发生变化时，索引树的节点也需要分裂变化")]),v._v(" "),a("li",[v._v("需要查找数据时，在上一次 IO 读写的缓存中没有，需要发生一次新的 IO 操作时，可以避免对辅助索引的维护工作，只要维护聚簇索引树就好了")]),v._v(" "),a("li",[v._v("辅助索引存放的是主键值，减少了辅助索引占用的存储空间大小")])]),v._v(" "),a("h2",{attrs:{id:"使用聚簇索引的注意点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用聚簇索引的注意点"}},[v._v("#")]),v._v(" 使用聚簇索引的注意点")]),v._v(" "),a("ul",[a("li",[v._v("使用主键为聚簇索引时，主键最好不要使用 uuid，uuid 的值太过离散，不适合排序且可能出现新增记录的 uuid 会插入在索引树中间位置，导致索引树调整复杂度变大，消耗更多的时间和资源")]),v._v(" "),a("li",[v._v("建议使用 int  类型的自增，方便排序且默认会在索引树的末尾增加主键值，对索引树的结构影响最小而且，主键值占用的存储空间越大，辅助索引中保存的主键值也会跟着变大，占用存储空间，也会影响到 IO 操作读取到的数据量")])]),v._v(" "),a("h2",{attrs:{id:"为什么主键通常建议使用自增-id"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么主键通常建议使用自增-id"}},[v._v("#")]),v._v(" 为什么主键通常建议使用自增 id")]),v._v(" "),a("ul",[a("li",[v._v("聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻存放在磁盘上")]),v._v(" "),a("li",[v._v("如果主键不是自增 id ，会不断调整数据的物理地址、分页")]),v._v(" "),a("li",[v._v("如果是自增的，只需要一页一页的写，索引结构相对紧凑，磁盘碎片少，效率也高")])]),v._v(" "),a("h2",{attrs:{id:"什么情况下无法利用索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么情况下无法利用索引"}},[v._v("#")]),v._v(" 什么情况下无法利用索引")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("查询语句中使用 like 关键字")]),v._v(" "),a("ul",[a("li",[v._v("如果匹配字符串的第一个字符为 % ，索引不会被使用")]),v._v(" "),a("li",[v._v("如果 % 不是在第一个位置，索引会被使用")])])]),v._v(" "),a("li",[a("p",[v._v("查询语句中使用多列索引")]),v._v(" "),a("ul",[a("li",[v._v("只有查询条件中使用了这些字段中的第一个字段，索引才会被使用")])])]),v._v(" "),a("li",[a("p",[v._v("查询语句中使用 or 关键字")]),v._v(" "),a("ul",[a("li",[v._v("如果 or 前后的两个条件的列都是索引，那么会使用索引")]),v._v(" "),a("li",[v._v("如果 or 前后有一个列不是索引，那么不会使用索引")])])])]),v._v(" "),a("h2",{attrs:{id:"参考文档"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考文档"}},[v._v("#")]),v._v(" 参考文档")]),v._v(" "),a("p",[a("a",{attrs:{href:"https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("Clustered and Secondary Indexes"),a("OutboundLink")],1)]),v._v(" "),a("p",[a("a",{attrs:{href:"https://www.bilibili.com/video/BV19y4y127h4?p=3",target:"_blank",rel:"noopener noreferrer"}},[v._v("聚簇索引与非聚簇索引"),a("OutboundLink")],1)]),v._v(" "),a("p",[v._v("（完）")])])}),[],!1,null,null,null);_.default=i.exports},601:function(v,_,t){v.exports=t.p+"assets/img/index4.ad525763.png"},602:function(v,_,t){v.exports=t.p+"assets/img/index3.5578e5cf.png"}}]);