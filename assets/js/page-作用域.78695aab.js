(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{827:function(t,a,s){"use strict";s.r(a);var n=s(1),v=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作用域"}},[t._v("#")]),t._v(" 作用域")]),t._v(" "),s("h2",{attrs:{id:"作用域定义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作用域定义"}},[t._v("#")]),t._v(" 作用域定义")]),t._v(" "),s("p",[t._v("作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。")]),t._v(" "),s("p",[t._v("通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。")]),t._v(" "),s("h2",{attrs:{id:"作用域的分类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作用域的分类"}},[t._v("#")]),t._v(" 作用域的分类")]),t._v(" "),s("p",[t._v("JavaScript 一共有三种作用域：")]),t._v(" "),s("ul",[s("li",[t._v("全局作用域")]),t._v(" "),s("li",[t._v("函数作用域")]),t._v(" "),s("li",[t._v("块级作用域")])]),t._v(" "),s("h3",{attrs:{id:"全局作用域和函数作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#全局作用域和函数作用域"}},[t._v("#")]),t._v(" 全局作用域和函数作用域")]),t._v(" "),s("p",[t._v("在 ES6 之前，ES 的作用域只有两种：全局作用域和函数作用域。（ES3 开始，"),s("code",[t._v("try /catch")]),t._v(" 分句结构和 "),s("code",[t._v("with")]),t._v(" 中也具有块作用域，这里不讨论）")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("全局作用域")]),t._v(" 中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。")]),t._v(" "),s("li",[s("strong",[t._v("函数作用域")]),t._v(" 就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。")])]),t._v(" "),s("p",[t._v("在 ES6 之前，JavaScript 只支持这两种作用域，相较而言，其他语言则都普遍支持"),s("strong",[t._v("块级作用域")]),t._v("。块级作用域就是使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句，甚至单独的一个 "),s("code",[t._v("{}")]),t._v(" 都可以被看作是一个块级作用域。")]),t._v(" "),s("p",[t._v("简单来讲，"),s("strong",[t._v("如果一种语言支持块级作用域")]),t._v("，那么其代码块内部定义的变量在代码块外部是访问不到的，并且等该代码块中的代码执行完成之后，代码块中定义的变量会被销毁。")]),t._v(" "),s("p",[t._v("遗憾的是，JavaScript 在 ES6 之前是不支持块级作用域的。没有块级作用域，对作者当时设计 JavaScript 来说会比较简单快速，但这也直接导致了「"),s("strong",[t._v("变量提升")]),t._v("」的问题。")]),t._v(" "),s("h3",{attrs:{id:"块级作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#块级作用域"}},[t._v("#")]),t._v(" 块级作用域")]),t._v(" "),s("p",[t._v("为了解决变量提升带来的一系列问题，ES6 引入了 "),s("code",[t._v("let")]),t._v(" 和 "),s("code",[t._v("const")]),t._v(" 关键字，从而"),s("strong",[t._v("使 JavaScript 也能像其他语言一样拥有块级作用域")]),t._v("。")]),t._v(" "),s("p",[t._v("需要注意的是，只有 "),s("code",[t._v("let")]),t._v("，"),s("code",[t._v("const")]),t._v(" + 大括号（"),s("code",[t._v("{}")]),t._v("）才能构成块级作用域，否则单纯的大括号（"),s("code",[t._v("{}")]),t._v("）只是用作代码分割，让代码阅读起来更简单轻快一点，纯粹代码维护上的需求。")]),t._v(" "),s("p",[t._v("通过 "),s("code",[t._v("let")]),t._v(" 或者 "),s("code",[t._v("const")]),t._v(" 声明的变量会在进入块级作用域的时候被创建，但是在该变量没有赋值之前，引用该变量 JavaScript 引擎会抛出错误，这就是「"),s("strong",[t._v("暂时性死区")]),t._v("」。")]),t._v(" "),s("h2",{attrs:{id:"词法作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#词法作用域"}},[t._v("#")]),t._v(" 词法作用域")]),t._v(" "),s("p",[s("strong",[t._v("词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。")]),t._v("（标识符：在 JS 中所有可以由我们自主命名的都可以称为是标识符，例如：变量名、函数名、属性名都属于标识符）"),s("br"),t._v("\n—— 出自《你不知道的JavaScript（上）》")]),t._v(" "),s("h2",{attrs:{id:"作用域链"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作用域链"}},[t._v("#")]),t._v(" 作用域链")]),t._v(" "),s("p",[t._v("作用域链也称词法作用域链，顾名思义，它跟词法作用域有关。")]),t._v(" "),s("p",[t._v("作用域链本质上就是查找变量的链条（确定变量来自于哪里，变量是否可以访问，或者说，确定一个变量来自于哪个作用域）。")]),t._v(" "),s("p",[t._v("查找作用域链的步骤如下：")]),t._v(" "),s("ul",[s("li",[t._v("查看当前作用域，如果当前作用域声明了这个变量，就确定结果。")]),t._v(" "),s("li",[t._v("查找当前作用域的上级作用域，也就是当前函数的上级函数，看看上级函数中有没有声明。")]),t._v(" "),s("li",[t._v("再查找上级函数的上级函数，直到全局作用域为止。")]),t._v(" "),s("li",[t._v("如果全局作用域中也没有，我们就认为这个变量未声明（抛出异常："),s("code",[t._v("xxx is not defined")]),t._v("）。")])]),t._v(" "),s("p",[s("strong",[t._v("重点：词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系")]),t._v("。")]),t._v(" "),s("p",[t._v("举个例子：")]),t._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("innerFunction")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("myName"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("outerFunction")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" myName "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"函数作用域"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("innerFunction")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" myName "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"全局作用域"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("outerFunction")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br")])]),s("p",[t._v("从代码中可以看出，全局执行上下文和 "),s("code",[t._v("outerFunction")]),t._v(" 函数的执行上下文中都包含变量 "),s("code",[t._v("myName")]),t._v("，那 "),s("code",[t._v("innerFunction")]),t._v(" 函数里面 "),s("code",[t._v("myName")]),t._v(" 的值到底该选择哪个？")]),t._v(" "),s("p",[t._v("根据上面提到的查找顺序，如下：")]),t._v(" "),s("ul",[s("li",[t._v("查看当前作用域，"),s("code",[t._v("innerFunction")]),t._v(" 函数里面不存在变量 "),s("code",[t._v("myName")]),t._v("。")]),t._v(" "),s("li",[s("code",[t._v("innerFunction")]),t._v(" 函数中使用了外部变量，向上级查找。")]),t._v(" "),s("li",[t._v("重点来了，由于 "),s("code",[t._v("innerFunction")]),t._v(" 函数里面不存在变量 "),s("code",[t._v("myName")]),t._v(" ，此时 JavaScript 引擎会去全局执行上下文中查找，而不是它的调用方 "),s("code",[t._v("outerFunction")]),t._v(" 函数的执行上下文。这是因为"),s("strong",[t._v("在 JavaScript 执行过程中，其作用域链是由词法作用域决定的，而词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系")]),t._v("。")])]),t._v(" "),s("p",[t._v("既然如此，根据词法作用域，"),s("code",[t._v("outerFunction")]),t._v(" 和 "),s("code",[t._v("innerFunction")]),t._v(" 的上级作用域都是全局作用域，所以如果这两个函数使用了一个它们没有定义的变量，那么它们会到全局作用域去查找。")]),t._v(" "),s("p",[t._v("（完）")])])}),[],!1,null,null,null);a.default=v.exports}}]);