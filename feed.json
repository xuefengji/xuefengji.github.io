{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "前端修炼小册",
  "home_page_url": "https://www.fedbook.cn/",
  "feed_url": "https://www.fedbook.cn/feed.json",
  "description": "Wenyuan's Front-End Development Book",
  "author": {
    "name": "wenyuan"
  },
  "items": [
    {
      "title": "Python",
      "url": "https://www.fedbook.cn/backend-knowledge/python/",
      "id": "https://www.fedbook.cn/backend-knowledge/python/",
      "content_html": "<h1 id=\"python\"> Python</h1>\n<blockquote>\n<p>本系列主要针对 Python3 进行知识点梳理，并会实时跟进 Python 最新稳定版的新特性。</p>\n</blockquote>\n<p>Python 是一门跨平台、可移植、可扩展、交互式、解释型、面向对象的动态语言。</p>\n<ul>\n<li><strong>跨平台</strong>：Python 支持 Windows、Linux 和 MAC OS 等主流操作系统。</li>\n<li><strong>可移植</strong>：代码通常不需要多少改动就能移植到别的平台上使用。</li>\n<li><strong>可扩展</strong>：Python 语言本身由 C 语言编写而成的，你完全可以在 Python 中嵌入 C，从而提高代码的运行速度和效率。你也可以使用 C 语言重写 Python 的任何模块，从根本上改写 Python，PyPy 就是这么干的。</li>\n<li><strong>交互式</strong>：Python 提供很好的人机交互界面，比如 IDLE 和 IPython。可以从终端输入执行代码并获得结果，互动的测试和调试代码片断。</li>\n<li><strong>解释型</strong>：Python 语言在执行过程中由解释器逐行分析，逐行运行并输出结果。</li>\n<li><strong>面向对象</strong>：Python 语言具备所有的面向对象特性和功能，支持基于类的程序开发。</li>\n<li><strong>动态语言</strong>：在运行时可以改变其结构。例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。动态语言非常具有活力。</li>\n</ul>\n<hr>\n<p>Python 的应用场景：</p>\n<ul>\n<li>常规软件开发</li>\n<li>科学计算</li>\n<li>自动化运维</li>\n<li>云计算\n<ul>\n<li>OpenStack 等</li>\n</ul>\n</li>\n<li>Web 开发\n<ul>\n<li>Django，Tornado，Flask 等</li>\n</ul>\n</li>\n<li>网络爬虫</li>\n<li>数据分析</li>\n<li>人工智能</li>\n</ul>\n<hr>\n<p>关于 Python 的知识点，推荐三本书：</p>\n<ul>\n<li>《Python编程 从入门到实践》（绿皮书）</li>\n<li>《Python Cookbook》（当字典用）</li>\n<li>《流畅的Python》（比较深）</li>\n</ul>\n<div style=\"text-align: right\">\n  <svg t=\"1609909378134\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"2255\" width=\"64\" height=\"64\"><path d=\"M420.693333 85.333333C353.28 85.333333 298.666667 139.946667 298.666667 207.36v71.68h183.04c16.64 0 30.293333 24.32 30.293333 40.96H207.36C139.946667 320 85.333333 374.613333 85.333333 442.026667v161.322666c0 67.413333 54.613333 122.026667 122.026667 122.026667h50.346667v-114.346667c0-67.413333 54.186667-122.026667 121.6-122.026666h224c67.413333 0 122.026667-54.229333 122.026666-121.642667V207.36C725.333333 139.946667 670.72 85.333333 603.306667 85.333333z m-30.72 68.693334c17.066667 0 30.72 5.12 30.72 30.293333s-13.653333 38.016-30.72 38.016c-16.64 0-30.293333-12.8-30.293333-37.973333s13.653333-30.336 30.293333-30.336z\" fill=\"#3C78AA\" p-id=\"2256\"></path><path d=\"M766.250667 298.666667v114.346666a121.6 121.6 0 0 1-121.6 121.984H420.693333A121.6 121.6 0 0 0 298.666667 656.597333v160a122.026667 122.026667 0 0 0 122.026666 122.026667h182.613334A122.026667 122.026667 0 0 0 725.333333 816.64v-71.68h-183.082666c-16.64 0-30.250667-24.32-30.250667-40.96h304.64A122.026667 122.026667 0 0 0 938.666667 581.973333v-161.28a122.026667 122.026667 0 0 0-122.026667-122.026666zM354.986667 491.221333l-0.170667 0.170667c0.512-0.085333 1.066667-0.042667 1.621333-0.170667z m279.04 310.442667c16.64 0 30.293333 12.8 30.293333 37.973333a30.293333 30.293333 0 0 1-30.293333 30.293334c-17.066667 0-30.72-5.12-30.72-30.293334s13.653333-37.973333 30.72-37.973333z\" fill=\"#FDD835\" p-id=\"2257\"></path></svg>\n</div>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2021-12-01T10:10:18.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "类成员保护",
      "url": "https://www.fedbook.cn/backend-knowledge/python/class-access-modifiers/",
      "id": "https://www.fedbook.cn/backend-knowledge/python/class-access-modifiers/",
      "content_html": "<h1 id=\"类成员保护\"> 类成员保护</h1>\n<p>在 JAVA 语言中，有 <code>private</code> 关键字，可以将类的某些变量和方法设为私有，阻止外部访问。但是 Python 没有这个机制。</p>\n<p>在 Python 中，如果要让内部成员不被外部访问，可以利用变量和方法名字的变化：在成员的名字前加上两个下划线 <code>__</code>，这个成员就变成了一个私有成员（private）。私有成员只能在类的内部访问，外部无法访问。</p>\n<h2 id=\"设置私有成员\"> 设置私有成员</h2>\n<p>如下所示，在 <code>Student</code> 类中，<code>title</code> 可以在外部访问；而 <code>__name</code> 和 <code>__age</code> 由于加了两个下划线，已经变成了私有成员，只能在类的内部访问，外部访问时会报错。</p>\n<div><pre><code><span>class</span> <span>Student</span><span>:</span>\n    title <span>=</span> <span>\"学生\"</span>\n\n    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>,</span> age<span>)</span><span>:</span>\n        self<span>.</span>__name <span>=</span> name\n        self<span>.</span>__age <span>=</span> age\n\n    <span>def</span> <span>print_age</span><span>(</span>self<span>)</span><span>:</span>\n        <span>print</span><span>(</span><span>'%s: %s'</span> <span>%</span> <span>(</span>self<span>.</span>__name<span>,</span> self<span>.</span>__age<span>)</span><span>)</span>\n\nobj <span>=</span> Student<span>(</span><span>\"zhangsan\"</span><span>,</span> <span>13</span><span>)</span>\n<span>print</span><span>(</span>obj<span>.</span>title<span>)</span>\n<span>print</span><span>(</span>obj<span>.</span>__name<span>)</span> <span># 这里会报错</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id=\"外部访问和修改私有成员\"> 外部访问和修改私有成员</h2>\n<p>如果要在外部访问和修改类的私有成员，可以通过在类的内部创建 get 和 set 方法。这种设计思想在很多编程语言中都很常见。</p>\n<p>如下代码所示：</p>\n<div><pre><code><span>class</span> <span>Student</span><span>:</span>\n    title <span>=</span> <span>\"学生\"</span>\n\n    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>,</span> age<span>)</span><span>:</span>\n        self<span>.</span>__name <span>=</span> name\n        self<span>.</span>__age <span>=</span> age\n\n    <span>def</span> <span>print_age</span><span>(</span>self<span>)</span><span>:</span>\n        <span>print</span><span>(</span><span>'%s: %s'</span> <span>%</span> <span>(</span>self<span>.</span>__name<span>,</span> self<span>.</span>__age<span>)</span><span>)</span>\n\n    <span>def</span> <span>get_name</span><span>(</span>self<span>)</span><span>:</span>\n        <span>return</span> self<span>.</span>__name\n\n    <span>def</span> <span>get_age</span><span>(</span>self<span>)</span><span>:</span>\n        <span>return</span> self<span>.</span>__age\n\n    <span>def</span> <span>set_name</span><span>(</span>self<span>,</span> name<span>)</span><span>:</span>\n        self<span>.</span>__name <span>=</span> name\n\n    <span>def</span> <span>set_age</span><span>(</span>self<span>,</span> age<span>)</span><span>:</span>\n        self<span>.</span>__age <span>=</span> age\n\nobj <span>=</span> Student<span>(</span><span>\"zhangsan\"</span><span>,</span> <span>13</span><span>)</span>\nobj<span>.</span>get_name<span>(</span><span>)</span>\nobj<span>.</span>set_name<span>(</span><span>\"lisi\"</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>这样做，不但对数据进行了保护的同时也提供了外部访问的接口，而且在 <code>get_name</code>，<code>set_name</code> 这些方法中，可以额外添加对数据进行检测、处理、加工、包裹等等各种操作。</p>\n<p>比如下面这个方法，会在设置年龄之前对参数进行检测，如果参数不是一个整数类型，则抛出异常。</p>\n<div><pre><code><span>def</span> <span>set_age</span><span>(</span>self<span>,</span> age<span>)</span><span>:</span>\n    <span>if</span> <span>isinstance</span><span>(</span>age<span>,</span> <span>int</span><span>)</span><span>:</span>\n        self<span>.</span>__age <span>=</span> age\n    <span>else</span><span>:</span>\n        <span>raise</span> ValueError\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"私有成员的原理\"> 私有成员的原理</h2>\n<p>为什么以双下划线开头的数据成员就不能从外部访问了呢？</p>\n<p>以上面的代码为例，从内部机制原理讲，外部不能直接访问 <code>__age</code> 是因为 Python 解释器对外把 <code>__age</code> 变量改成了 <code>_Student__age</code> ，也就是 <code>_类名__age</code>（类名前是一个下划线）。因此，投机取巧的话，你可以通过 <code>_Student__age</code> 在类的外部访问 <code>__age</code> 变量。</p>\n<p>知道了这样一个原理，我们就要规避这样一个问题：</p>\n<div><pre><code>obj <span>=</span> Student<span>(</span><span>\"zhangsan\"</span><span>,</span> <span>13</span><span>)</span>\nobj<span>.</span>__name <span>=</span> <span>\"lisi\"</span> <span># 注意这一行</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>注意上面第二行，千万不要写这样的代码，因为这相当于给 <code>obj</code> 实例添加了一个新的实例变量 <code>__name</code>，而不是对原有私有成员 <code>__name</code> 重新赋值。</p>\n<h2 id=\"类的成员与下划线总结\"> 类的成员与下划线总结</h2>\n<ul>\n<li><code>_name</code>、<code>_name_</code>、<code>_name__</code>：建议性的私有成员，不要在外部访问。</li>\n<li><code>__name</code>、 <code>__name_</code>：强制的私有成员，但是你依然可以蛮横地在外部危险访问。</li>\n<li><code>__name__</code>：特殊成员，与私有性质无关，尽量不要给自定义的成员这样命名，它们都是 Python 中具有特殊意义的魔法方法名。例如 <code>__doc__</code>。</li>\n<li><code>name_</code>、<code>name__</code>：没有任何特殊性，普通的标识符，但最好不要这么起名。</li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2021-11-19T03:27:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Home",
      "url": "https://www.fedbook.cn/",
      "id": "https://www.fedbook.cn/",
      "content_html": "<div>\n  <h1>我的技术栈</h1>\n  <div>\n    <div data-tooltip=\"HTML 5\">\n      <svg t=\"1594449205433\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"1511\" width=\"200\" height=\"200\"><path d=\"M89.088 59.392l62.464 803.84c1.024 12.288 9.216 22.528 20.48 25.6L502.784 993.28c6.144 2.048 12.288 2.048 18.432 0l330.752-104.448c11.264-4.096 19.456-14.336 20.48-25.6l62.464-803.84c1.024-17.408-12.288-31.744-29.696-31.744H118.784c-17.408 0-31.744 14.336-29.696 31.744z\" fill=\"#FC490B\" p-id=\"1512\"></path><path d=\"M774.144 309.248h-409.6l12.288 113.664h388.096l-25.6 325.632-227.328 71.68-227.328-71.68-13.312-169.984h118.784v82.944l124.928 33.792 123.904-33.792 10.24-132.096H267.264L241.664 204.8h540.672z\" fill=\"#FFFFFF\" p-id=\"1513\"></path></svg>\n    </div>\n    <div data-tooltip=\"CSS 3\">\n      <svg t=\"1594449320423\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"5999\" width=\"200\" height=\"200\"><path d=\"M88.064 27.648l77.824 871.424L512 996.352l346.112-97.28 77.824-871.424z\" fill=\"#2196F3\" p-id=\"6000\"></path><path d=\"M771.072 312.32l-10.24 109.568-29.696 328.704L512 811.008l-220.16-60.416-14.336-172.032h107.52l7.168 89.088L512 700.416l119.808-32.768 16.384-148.48-375.808 1.024-11.264-101.376 395.264-4.096 8.192-108.544-413.696 1.024-7.168-101.376h536.576z\" fill=\"#FAFAFA\" p-id=\"6001\"></path></svg>\n    </div>\n    <div data-tooltip=\"JavaScript\">\n      <svg t=\"1594452832532\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"978\" width=\"200\" height=\"200\"><path d=\"M38.56886067 38.56886067h946.86227866v946.86227866H38.56886067V38.56886067m248.81436505 791.1560377c21.04138438 44.71294135 62.5981169 81.53536248 133.61278901 81.53536246 78.9051899 0 133.08675402-42.08276753 133.08675281-134.13882281v-304.04799797h-89.42588147V775.01729921c0 45.23897512-18.41121055 56.81173672-47.34311392 56.81173673-30.51000717 0-43.13483754-21.04138438-57.33777176-45.76501015l-72.59277467 43.66087258m314.56869076-9.4686228c26.30172955 51.55139031 79.4312249 91.00398527 162.54469117 91.00398526 84.16553629 0 147.28968821-43.66087133 147.2896882-124.14416501 0-74.17087849-42.60880254-107.31105826-118.35778483-139.92520422l-22.09345319-9.46862279c-38.40052617-16.307073-54.70759791-27.35379957-54.70759912-53.65552911 0-21.56741817 16.307073-38.40052617 42.60880252-38.40052493 25.24966076 0 42.08276753 11.04672657 57.33777173 38.40052493l68.91053209-45.76501015c-28.93190337-50.49932154-69.96260211-69.96260211-126.24830382-69.96260088-79.4312249 0-130.45658021 50.49932154-130.45658019 117.30571482 0 72.5927747 42.60880254 106.78502324 106.78502324 134.13882281l22.09345315 9.46862278c41.03069875 17.88517679 65.22829073 28.93190337 65.22829072 59.44191054 0 25.24966076-23.67155698 43.66087133-60.49397931 43.66087133-43.66087133 0-68.91053209-22.61948818-87.84777766-54.18156414l-72.5927747 42.08276876z\" fill=\"#FFCA28\" p-id=\"979\"></path></svg>\n    </div>\n    <div data-tooltip=\"TypeScript\">\n      <svg t=\"1625995896568\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"4145\" width=\"200\" height=\"200\"><path d=\"M94.208 94.208v835.584h835.584V94.208H94.208z m634.92096 405.85216v0.012288c8.011776 0.024576 17.119232 0.436224 23.967744 1.179648 27.891712 3.016704 49.6128 15.050752 68.091904 37.715968 9.201664 11.290624 12.34944 16.2304 11.679744 18.343936-0.432128 1.363968-6.746112 5.885952-26.820608 19.21024-19.720192 13.092864-26.07104 17.014784-27.5456 17.014784-1.497088 0-4.614144-3.207168-9.105408-9.365504-8.6528-11.855872-17.485824-17.266688-31.13984-19.070976-14.68416-1.9456-27.856896 2.68288-34.308096 12.058624-5.515264 8.011776-6.3488 20.901888-1.96608 30.26944 5.07904 10.848256 14.270464 16.846848 49.494016 32.290816 40.624128 17.813504 61.210624 30.005248 76.204032 45.13792 16.146432 16.293888 24.326144 35.106816 26.83904 61.718528 1.226752 12.972032-0.272384 28.34432-3.98336 40.843264-9.10336 30.640128-33.66912 53.075968-69.67296 63.635456-9.95328 2.9184-19.214336 4.661248-28.37504 5.332992-13.985792 1.030144-34.002944 0.462848-46.051328-1.29024-30.482432-4.442112-64.892928-22.17984-82.051072-42.2912-8.423424-9.873408-19.177472-26.12224-19.177472-28.9792 0-1.380352 0.684032-2.164736 3.391488-3.885056 8.032256-5.103616 54.054912-31.412224 54.94784-31.412224 0.540672 0 2.945024 2.832384 5.341184 6.295552 5.429248 7.839744 18.78016 21.313536 25.567232 25.808896 5.543936 3.672064 12.634112 6.619136 21.051392 8.747008 4.820992 1.202176 7.3728 1.417216 17.891328 1.417216 10.747904-0.004096 12.951552-0.18432 17.760256-1.476608 12.71808-3.422208 22.644736-10.50624 26.851328-19.156992 1.8432-3.7376 1.880064-4.204544 1.880064-13.27104v-9.40032l-2.260992-4.48512c-5.474304-10.866688-17.270784-18.323456-54.56896-34.47808-17.13152-7.421952-38.11328-17.885184-46.30528-23.0912-18.696192-11.880448-31.653888-25.462784-40.157184-42.088448-8.45824-16.533504-9.71776-22.687744-9.73824-47.548416-0.02048-19.462144-0.053248-19.222528 3.975168-31.643648 3.65568-11.272192 11.139072-23.863296 19.400704-32.64512 16.4864-17.524736 40.577024-28.788736 66.367488-31.029248 3.29728-0.313344 7.716864-0.434176 12.52352-0.41984z m-221.92128 3.844096h0.008192c49.670144 0.024576 78.143488 0.196608 78.600192 0.483328 0.86016 0.53248 0.968704 4.855808 0.968704 32.444416v31.827968l-49.563648 0.180224-49.563648 0.180224v140.724224c0 77.400064-0.157696 141.185024-0.372736 141.748224-0.350208 0.948224-4.163584 1.019904-36.41344 1.019904h-36.018176l-0.372736-1.45408c-0.239616-0.79872-0.415744-64.587776-0.41984-141.750272l-0.012288-140.296192-49.5616-0.176128-49.565696-0.180224v-31.451136c0-24.94464 0.172032-31.625216 0.837632-32.288768 0.681984-0.702464 25.976832-0.882688 134.967296-0.991232 21.01248-0.02048 39.92576-0.03072 56.48384-0.02048z\" fill=\"#0288D1\" p-id=\"4146\"></path></svg>\n    </div>\n    <div data-tooltip=\"Vue.js\">\n      <svg t=\"1594449992255\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"1022\" width=\"200\" height=\"200\"><path d=\"M627.85285817 77.66360895h185.07382266L512 598.88964363 211.07331917 77.66360895H10.45553197L512 946.33639105l501.54446803-868.78460919z\" fill=\"#41B883\" p-id=\"1023\"></path><path d=\"M812.92668083 77.66360895H627.85285817L512 278.28139617 396.14714183 77.66360895H211.07331917L512 598.88964363z\" fill=\"#34495E\" p-id=\"1024\"></path></svg>\n    </div>\n    <div data-tooltip=\"React\">\n      <svg t=\"1628346090690\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"9901\" width=\"200\" height=\"200\"><path d=\"M512 511.8m-80 0a80 80 0 1 0 160 0 80 80 0 1 0-160 0Z\" fill=\"#61DAFB\" p-id=\"9902\"></path><path d=\"M960.5 511.8c0-62.8-73.8-117.2-188.5-150.1 28.9-115.8 18.7-206.9-35.7-238.3-54.5-31.4-138.5 5.3-224.3 88.2-85.8-82.9-169.8-119.6-224.3-88.2-54.4 31.4-64.6 122.6-35.7 238.3C137.3 394.6 63.5 449 63.5 511.8S137.3 629 252 661.9c-28.9 115.7-18.7 206.9 35.7 238.3 13.4 7.8 28.6 11.6 45.2 11.6 39.7 0 87.8-21.8 140-64.2 13-10.6 26.1-22.6 39.1-35.2 13 12.6 26.1 24.6 39.1 35.2 52.2 42.4 100.2 64.2 140 64.2 16.6 0 31.8-3.8 45.2-11.6 54.4-31.4 64.6-122.5 35.7-238.3 114.7-32.9 188.5-87.3 188.5-150.1zM716.8 157.2c35.3 20.4 42.7 94.3 17.6 194.8-36.7-8.4-76.7-14.7-119.3-18.6-24.7-34.9-50.2-66.4-75.8-94 59.2-57.3 114.2-88.4 152-88.4 9.6-0.1 18.2 2 25.5 6.2zM637 584c-13.8 24-28.4 47-43.3 69-26.1 2-53.3 3.1-81.7 3.1-28.3 0-55.5-1.1-81.6-3.1-15-22-29.5-45.1-43.3-69-14.1-24.5-26.7-48.6-38.1-72.2 11.4-23.6 24-47.7 38.1-72.2 14.1-24.5 28.7-47.4 43.4-69.1 26.1-2 53.3-3.1 81.6-3.1 28.3 0 55.5 1.1 81.6 3.1 14.7 21.6 29.3 44.6 43.4 69 14.1 24.5 26.7 48.6 38.1 72.2-11.5 23.7-24.1 47.8-38.2 72.3z m58.8-26.4c11.2 26.6 20.4 52.1 28 76.5-24.9 5.6-51.7 10.4-80.3 14 9.3-14.5 18.4-29.3 27.3-44.6 8.8-15.4 17.1-30.7 25-45.9zM512 756.5c-17.7-19.2-35.1-40.1-52.2-62.6 17.1 0.8 34.5 1.3 52.2 1.3 17.7 0 35.1-0.5 52.2-1.3-17.1 22.5-34.5 43.4-52.2 62.6zM380.5 648.1c-28.6-3.6-55.3-8.4-80.3-14 7.6-24.4 16.8-49.9 28-76.5 7.9 15.2 16.1 30.5 25 45.9 8.9 15.2 18 30 27.3 44.6zM328.2 466c-11.2-26.6-20.4-52.1-28-76.5 24.9-5.6 51.6-10.4 80.2-14-9.2 14.4-18.4 29.2-27.2 44.6-8.8 15.4-17.1 30.7-25 45.9zM512 267.1c17.3 18.7 34.8 39.8 52.1 62.7-17.1-0.8-34.4-1.3-52.1-1.3-17.7 0-35 0.5-52.1 1.3 17.3-22.9 34.8-44 52.1-62.7z m158.7 153c-8.9-15.3-18-30.1-27.2-44.6 28.6 3.6 55.3 8.4 80.2 14-7.6 24.4-16.8 49.9-28 76.5-7.8-15.2-16.1-30.5-25-45.9zM307.2 157.2c7.2-4.2 15.8-6.2 25.6-6.2 37.8 0 92.7 31.1 151.9 88.4-25.6 27.6-51.1 59.2-75.8 94-42.5 3.9-82.6 10.2-119.3 18.6-25.1-100.6-17.6-174.5 17.6-194.8zM102.5 511.8c0-40.8 60.3-84.2 160-112.6 11.1 36 25.6 73.8 43.5 112.6-17.8 38.8-32.4 76.6-43.5 112.6-99.7-28.4-160-71.9-160-112.6z m345.8 305.5c-59.7 48.5-111.1 66.4-141.1 49.2-35.3-20.4-42.7-94.3-17.6-194.8 36.7 8.4 76.7 14.7 119.3 18.6 24.4 34.5 49.9 66.1 75.8 94.2-12.1 11.7-24.2 22.9-36.4 32.8z m268.5 49.2c-29.9 17.3-81.4-0.6-141.1-49.2-12.1-9.9-24.3-21.1-36.5-32.8 26-28.1 51.4-59.7 75.8-94.2 42.5-3.9 82.6-10.2 119.3-18.7 25.2 100.6 17.7 174.5-17.5 194.9z m44.8-242.1c-11.1-36-25.6-73.8-43.5-112.6 17.8-38.8 32.4-76.6 43.5-112.6 99.7 28.5 160 71.9 160 112.6-0.1 40.7-60.4 84.2-160 112.6z\" fill=\"#61DAFB\" p-id=\"9903\"></path></svg>\n    </div>\n    <div data-tooltip=\"Webpack\">\n      <svg t=\"1622560777342\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"1108\" width=\"200\" height=\"200\"><path d=\"M882.23288889 749.45422222L526.90488889 950.38577778V793.94133333l221.41155556-121.856 133.91644444 77.36888889z m24.34844444-22.07288889V307.08622222l-129.93422222 75.09333333v270.22222223l129.93422222 74.97955555z m-766.17955555 22.07288889l355.328 201.04533333V793.94133333L274.20444445 672.08533333l-133.80266667 77.36888889zM116.05333333 727.38133333V307.08622222l129.93422222 75.09333333v270.22222223L116.05333333 727.38133333z m15.24622222-447.60177778l364.43022223-206.16533333v151.32444445L262.144 353.39377778l-1.82044445 1.024c0 0.11377778-129.024-74.63822222-129.024-74.63822223z m760.03555556 0L526.90488889 73.728v151.32444445l233.472 128.34133333 1.82044444 1.024 129.13777778-74.63822223z\" fill=\"#8ED6FB\" p-id=\"1109\"></path><path d=\"M495.72977778 758.21511111l-218.45333333-120.14933333V400.15644445l218.45333333 126.17955555v231.87911111z m31.17511111 0l218.45333333-120.03555556V400.15644445l-218.45333333 126.17955555v231.87911111zM291.95377778 372.62222222l219.24977777-120.49066667L730.45333333 372.62222222 511.31733333 499.25688889 291.95377778 372.62222222z\" fill=\"#1C78C0\" p-id=\"1110\"></path></svg>\n    </div>\n    <div data-tooltip=\"Python\">\n      <svg t=\"1597990804379\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"3374\" width=\"200\" height=\"200\"><path d=\"M420.693333 85.333333C353.28 85.333333 298.666667 139.946667 298.666667 207.36v71.68h183.04c16.64 0 30.293333 24.32 30.293333 40.96H207.36C139.946667 320 85.333333 374.613333 85.333333 442.026667v161.322666c0 67.413333 54.613333 122.026667 122.026667 122.026667h50.346667v-114.346667c0-67.413333 54.186667-122.026667 121.6-122.026666h224c67.413333 0 122.026667-54.229333 122.026666-121.642667V207.36C725.333333 139.946667 670.72 85.333333 603.306667 85.333333z m-30.72 68.693334c17.066667 0 30.72 5.12 30.72 30.293333s-13.653333 38.016-30.72 38.016c-16.64 0-30.293333-12.8-30.293333-37.973333s13.653333-30.336 30.293333-30.336z\" fill=\"#3C78AA\" p-id=\"3375\"></path><path d=\"M766.250667 298.666667v114.346666a121.6 121.6 0 0 1-121.6 121.984H420.693333A121.6 121.6 0 0 0 298.666667 656.597333v160a122.026667 122.026667 0 0 0 122.026666 122.026667h182.613334A122.026667 122.026667 0 0 0 725.333333 816.64v-71.68h-183.082666c-16.64 0-30.250667-24.32-30.250667-40.96h304.64A122.026667 122.026667 0 0 0 938.666667 581.973333v-161.28a122.026667 122.026667 0 0 0-122.026667-122.026666zM354.986667 491.221333l-0.170667 0.170667c0.512-0.085333 1.066667-0.042667 1.621333-0.170667z m279.04 310.442667c16.64 0 30.293333 12.8 30.293333 37.973333a30.293333 30.293333 0 0 1-30.293333 30.293334c-17.066667 0-30.72-5.12-30.72-30.293334s13.653333-37.973333 30.72-37.973333z\" fill=\"#FDD835\" p-id=\"3376\"></path></svg>\n    </div>\n    <div data-tooltip=\"Django\">\n      <svg t=\"1597990902539\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"3649\" width=\"200\" height=\"200\"><path d=\"M481.655483 85.33675h139.530244v645.870954c-71.577602 13.585067-124.129284 19.022507-181.210459 19.022508-170.342406-0.003413-259.133449-77.004803-259.133449-224.699741 0-142.254085 94.23531-234.663261 240.100702-234.663261 22.650881 0 39.867735 1.809067 60.706135 7.243093z m0 325.102944c-16.308907-5.430614-29.900801-7.243094-47.114242-7.243094-70.673069 0-111.445337 43.492695-111.445337 119.596377 0 74.301442 38.963201 115.070297 110.53739 115.070298 15.394134 0 28.088321-0.904533 48.018775-3.618134z\" fill=\"#43A047\" p-id=\"3650\"></path><path d=\"M843.168455 300.817077v323.457717c0 111.445337-8.154454 164.898139-32.614401 211.114674-22.654294 44.404055-52.558508 72.482136-114.165764 103.294297l-129.570138-61.610669c61.610669-28.992854 91.51147-54.357335 110.537391-93.330777 19.937281-39.864321 26.282668-86.070616 26.282667-207.482886V300.823903z m-139.526832-214.732807h139.526832v143.155204h-139.526832z\" fill=\"#43A047\" p-id=\"3651\"></path></svg>\n    </div>\n    <div data-tooltip=\"MySQL\">\n      <svg t=\"1597992373909\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"9841\" width=\"200\" height=\"200\"><path d=\"M715.8 312.4l-5.6-11.7c-2.4-3.4-5.9-6-7.9-10h-0.6v-0.6c3.3-0.8 6.7-1.2 10.1-1.1 2 1.9 5.1 3.3 6.7 5.6 1.2 1.7 1.4 3.6 2.8 5 0 5.9-1.6 9.8-5.1 12.3 0.2-0.1-0.4 0.5-0.4 0.5z m251.9 251.1c-9.3-5.9-20.1-9.2-29.8-15.1-5.4-3.3-10.7-7.4-15.7-11.2-4.7-3.5-9.9-10.1-12.9-15.1-1.6-2.6-1.9-5.7-3.9-7.8 0.6-4.6 6.4-4.6 10.1-6.1 12.9-5.4 28-7.2 47.8-6.7-0.6-5-12.9-11.2-16.9-13.9-8-5.6-16.2-11.6-24.7-16.8-4.5-2.7-12.2-4.7-16.9-6.7-6.7-2.8-21.5-5.5-25.3-10.6-7.3-9.6-12.3-21.3-17.4-32.9-5.2-11.6-11.7-23.8-16.9-35.7-2.6-5.9-3.8-11.2-6.7-16.7-18.1-34.5-44.6-63.4-77-83.7-10.6-6.7-22.4-12.8-35.4-16.7-7.4-2.2-16.3-1-24.2-2.8h-5.1c-4.4-1.3-8.1-6-11.8-8.4-7.6-5-15.2-8.6-24.2-12.3-3.4-1.4-12.5-4.7-15.7-2.2-1.9 0.6-2.8 1.4-3.4 3.3-1.9 2.9-0.2 7.3 1.1 10 3.6 7.8 8.8 12.5 13.5 19 4.2 5.8 9.3 12.4 12.4 19 6.3 13.7 9.2 28.9 15.2 42.4 2.3 5.2 5.7 11.1 9 15.6 2.7 3.6 7.5 6.4 9 11.2 3.1 4.8-4.5 21.1-6.2 26.2-6.5 20-5.1 47.9 2.2 65.3 2.9 6.9 5.7 14.9 13.5 16.7 0.6-0.4 0.1-0.2 1.1-0.5 1.7-13.4 2.2-26.3 6.7-36.8 2.8-6.6 8.2-11.1 11.8-16.7 2.7 1.5 2.6 6 3.9 8.9 3.3 7.6 6.8 15.9 10.7 23.4 8.3 15.7 17.3 30.8 27.6 44.6 3.6 4.9 8.5 10.2 12.9 14.5 1.9 1.8 4.2 2.8 5.6 5h0.6v0.6c-7.6-2.6-12.1-10.1-18-14.5-11.3-8.4-24.6-21-32-32.9l-10.1-20.1v-0.6c-1.4 1.9-1 3.9-1.7 6.7-3.2 12.3-0.7 26.2-11.8 30.7-12.7 5.1-21.9-8.3-25.9-14.5-12.8-20.3-16.1-54.5-7.3-82 1.9-6.1 2.1-13.6 5.6-18.4-0.6-4.3-4.1-5.6-6.2-8.4-3.4-4.6-6.3-10-9-15.1-5.3-10.1-8.8-22-12.9-32.9-1.7-4.4-2-8.6-3.9-12.8-2.9-6.4-8.2-12.7-12.4-18.4-5.9-8.1-22.3-23.7-15.7-39.6 10.4-25.3 46.6-6.1 60.7 2.8 3.5 2.2 7.5 6.8 11.2 8.4l18.6 1.1c11.5 2.7 22.4 4.8 31.5 10 42.6 24.7 70 49.9 95.6 91.5 5.3 8.7 8.1 18.2 12.4 27.9 6.3 14.4 13 28.5 20.3 42.4 3.4 6.4 5.8 13.5 10.1 19 1.8 2.3 6.8 3.1 9.6 4.5 8.3 4.2 18 7.3 25.9 12.3 14.2 8.9 27.9 19.5 40.5 30.1 4.8 4.1 8 10 12.4 14.5v2.2c-3.9 1.1-7.9 2.2-11.8 3.3-8.7 2.2-16.3 1.7-24.7 3.9-5 1.3-11.4 3.3-16.9 3.9l0.6 0.5c3.2 8.9 20.4 16.3 28.1 21.8 9.6 6.9 18.7 15.1 25.9 24.5l7.3 7.3c1.7 2.4 2.1 5.5 3.9 7.8v0.5c-3.4-1.2-5.2-4.2-7.9-6.1-5.7-3.8-11.1-8.1-16.6-11.6zM373 728.9H271.4v-21.5h101.7c20.7-2.2 18.3-12.4 18.3-15.8v-8.4h-68.3c-31.8-0.3-52.1-14.1-52.3-29.9 0-1.5 0.7-71 0-71.6H303v69.5c-0.3 3.8 1.2 12.6 18.8 12.9 9 0.1 69.4 0 69.9 0v-82.7h32.2c0.2 0 0 112.8 0 113.3 0.2 27.7-34.8 33.7-50.9 34.2zM211.8 558.2L162 668.1c-5.9 13.3-13.6 18-29.4 18-15.8 0-23.8-4.7-29.7-18L53.2 558.2v126.1H21V558.4c0-12.3 4.9-18.2 15.2-21.3 24.4-7.6 41.1-1 48.2 15.3l47.3 108.5 48.9-108.5c7.4-16.4 23.8-22.9 48.3-15.3 10.2 3.1 15.2 9 15.2 21.3v125.9h-32.2l-0.1-126.1z\" fill=\"#00758F\" p-id=\"9842\"></path><path d=\"M659.8 536.6h61.1c3.1 0 5.9 0.2 9 0.6 27 3.7 40.6 15.4 40.6 34.7v75.9c0 15.6-5.8 24-19.1 29.5l31.7 28.4h-37.3l-25.6-23-25.8 1.6H660c-6.4 0-12.8-0.9-18.9-2.7-20.5-5.5-30.4-16.2-30.4-33.8v-75.9c0-19.3 13.6-31 40.6-34.7 2.6-0.4 5.7-0.6 8.5-0.6z m-14.6 109.3c0 1 0.3 2.1 0.6 3.3 1.9 8.8 10.2 13.7 22.9 13.7H698l-26.8-24.1h37.3l23.4 21c4.3-2.3 7.2-5.8 8.2-10.3 0.3-1 0.3-2.1 0.3-3.1v-72.8c0-0.8 0-1.9-0.3-2.9-1.9-8.2-10.2-12.9-22.6-12.9h-48.7c-14.3 0-23.6 6.2-23.6 15.8v72.3z m-148.9-88.1c-11.5 1-14.9 2.9-16.4 9.4-0.3 1-0.3 1.9-0.3 2.7v14.5c0 1 0 1.8 0.3 2.9 1.5 8.6 7.7 12.5 20.7 12.5h39c9.6 0 19.5 1.6 27.5 4.7 15.2 5.7 22.9 14.3 22.9 23.5v23.3c0 11.3-6.8 19.9-20.7 26.2-8.3 3.9-18.9 6.1-29.7 6.1h-92.5v-21.3h88.8c1.2 0 2.2-0.2 3.4-0.2 6.2-0.4 10.8-2.1 13.6-4.5 3.1-2.5 4.6-5.3 4.6-7.6v-18.6c0-2.2-0.9-4.3-2.5-5.7-3.1-3.7-7.4-5.5-17.6-6.3-0.9-0.2-2.2-0.2-3.4-0.2h-33.4c-3.1 0-6.2-0.2-9.3-0.4-27.5-2.9-43.9-15.1-43.9-29.5v-18.6c0-16.4 8.4-25.8 27.5-31.7 6.2-1.8 13-2.7 26-2.7h90.3v21.3h-91.9c-0.9 0-2.1 0.2-3 0.2z m326.5 88.6c0 11.3 7.1 16 26 16h84.4v21.3h-83.8c-3.1 0-6.2-0.2-9.3-0.4-33.1-2.4-49.5-14.7-49.5-36.6V536.3h32.2v110.1z m149.2-8.2c12.5 0 23.7 9.5 23.7 23.5 0 14.1-11.2 23.5-23.7 23.5s-23.7-9.5-23.7-23.5 11.2-23.5 23.7-23.5z m0 42.2c10.2 0 18.4-8 18.4-18.6 0-10.7-8.2-18.6-18.4-18.6-10.3 0-18.4 8-18.4 18.6 0.1 10.6 8.1 18.6 18.4 18.6z m11.3-24.3c0 4.9-3.2 6.9-7.3 7.3l7.8 11.8h-5.3l-7.1-11.6h-4.2v11.6h-4.5v-26.9h10.6c6.5 0 10 2.3 10 7.8z m-16.2-4v7.7h4.9c3.4 0 6.4-0.3 6.4-4.1 0-3.1-3.3-3.6-6-3.6h-5.3z\" fill=\"#F2A72F\" p-id=\"9843\"></path></svg>\n    </div>\n    <div data-tooltip=\"Elasticsearch\">\n      <svg width=\"64px\" height=\"64px\" viewBox=\"0 0 64 64\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"><g id=\"icon-/-product-logo-/-64x64px-/-elastic-sesrch-/-color\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\"><g id=\"logo-elastic-search-64x64-color\" transform=\"translate(8.000000, 4.999500)\"><path d=\"M47.7246,9.708 L47.7276,9.702 C42.7746,3.774 35.3286,0 26.9996,0 C16.4006,0 7.2326,6.112 2.8136,15 L38.0056,15 C40.5306,15 42.9886,14.13 44.9206,12.504 C45.9246,11.659 46.8636,10.739 47.7246,9.708\" id=\"Fill-1\" fill=\"#FEC514\"></path><path d=\"M0,27.0005 C0,29.4225 0.324,31.7675 0.922,34.0005 L34,34.0005 C37.866,34.0005 41,30.8665 41,27.0005 C41,23.1345 37.866,20.0005 34,20.0005 L0.922,20.0005 C0.324,22.2335 0,24.5785 0,27.0005\" id=\"Fill-4\" fill=\"#343741\"></path><path d=\"M47.7246,44.293 L47.7276,44.299 C42.7746,50.227 35.3286,54.001 26.9996,54.001 C16.4006,54.001 7.2326,47.889 2.8136,39.001 L38.0056,39.001 C40.5306,39.001 42.9886,39.871 44.9206,41.497 C45.9246,42.342 46.8636,43.262 47.7246,44.293\" id=\"Fill-6\" fill=\"#00BFB3\"></path></g></g></svg>\n    </div>\n    <div data-tooltip=\"NGINX\">\n      <svg t=\"1597992219506\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"2608\" width=\"200\" height=\"200\"><path d=\"M512 0L68.48 256v512L512 1024l443.52-256V256z m256 707.84c0 30.08-27.552 55.04-65.248 55.04-26.912 0-57.632-10.88-76.832-34.56l-256-304.672v284.16c0 30.752-24.32 55.04-54.368 55.04H312.32c-30.752 0-55.04-25.6-55.04-55.04V316.16c0-30.08 26.88-55.04 64-55.04 27.552 0 58.88 10.88 78.08 34.56l254.72 304.672V316.16c0-30.752 25.6-55.04 55.04-55.04h3.2c30.72 0 55.04 25.6 55.04 55.04v391.68z\" fill=\"#269539\" p-id=\"2609\"></path></svg>\n    </div>\n    <div data-tooltip=\"Ubuntu\">\n      <svg t=\"1597991636564\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"10406\" width=\"200\" height=\"200\"><path d=\"M1022.548 510.732c0 282.056-228.66 510.72-510.732 510.72C229.736 1021.452 1.08 792.788 1.08 510.732 1.08 228.66 229.744 0 511.816 0c282.076 0 510.732 228.66 510.732 510.732z\" fill=\"#DD4814\" p-id=\"10407\"></path><path d=\"M164.532 442.532c-37.676 0-68.2 30.524-68.2 68.2 0 37.656 30.524 68.184 68.2 68.184 37.66 0 68.184-30.528 68.184-68.184 0-37.676-30.524-68.2-68.184-68.2z m486.86 309.912c-32.612 18.84-43.8 60.52-24.96 93.116 18.82 32.616 60.5 43.796 93.116 24.96 32.612-18.82 43.796-60.5 24.96-93.12-18.82-32.592-60.524-43.772-93.116-24.956z m-338.744-241.712c0-67.384 33.472-126.92 84.684-162.968L347.48 264.268c-59.656 39.88-104.048 100.816-122.496 172.188 21.528 17.56 35.304 44.3 35.304 74.272 0 29.956-13.776 56.696-35.304 74.26C243.408 656.376 287.8 717.32 347.48 757.2l49.852-83.52c-51.212-36.028-84.684-95.56-84.684-162.948z m199.168-199.188c104.052 0 189.42 79.776 198.38 181.52l97.16-1.432c-4.776-75.112-37.592-142.544-88.008-192.128-25.928 9.796-55.88 8.296-81.76-6.624-25.932-14.964-42.192-40.208-46.636-67.608a297.04 297.04 0 0 0-79.14-10.76 295.148 295.148 0 0 0-131.276 30.652l47.38 84.908a198.384 198.384 0 0 1 83.9-18.528z m0 398.36a198.404 198.404 0 0 1-83.896-18.528l-47.38 84.9a294.848 294.848 0 0 0 131.28 30.684 296.16 296.16 0 0 0 79.136-10.788c4.444-27.4 20.708-52.62 46.632-67.608 25.904-14.948 55.836-16.42 81.76-6.624 50.42-49.584 83.232-117.016 88.016-192.128l-97.188-1.432c-8.94 101.772-94.304 181.52-198.36 181.52z m139.552-440.924c32.616 18.832 74.3 7.68 93.116-24.936 18.84-32.616 7.68-74.3-24.936-93.14-32.616-18.816-74.296-7.64-93.14 24.976-18.812 32.6-7.632 74.28 24.96 93.1z\" fill=\"#FFFFFF\" p-id=\"10408\"></path></svg>\n    </div>\n    <div data-tooltip=\"Git\">\n      <svg t=\"1594452867673\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"837\" width=\"200\" height=\"200\"><path d=\"M63.49884471 444.72482676L339.27934283 168.4672005l80.63478137 81.1119106c-11.45109332 40.55595587 7.15693331 84.92894248 44.3729866 106.39974246v264.32940369c-28.62773329 16.22238256-47.7128892 47.23575993-47.71288806 82.54329842a95.42577726 95.42577726 0 0 0 95.42577726 95.42577726 95.42577726 95.42577726 0 0 0 95.42577726-95.42577726c0-35.30753736-19.08515589-66.32091583-47.71288806-82.54329842V388.42361757l98.76567986 99.7199384c-3.33990259 7.15693331-3.33990259 15.26812405-3.33990261 23.85644403a95.42577726 95.42577726 0 0 0 95.42577728 95.42577726 95.42577726 95.42577726 0 0 0 95.42577839-95.42577726 95.42577726 95.42577726 0 0 0-95.42577839-95.42577726c-8.58831998 0-16.69951071 0-23.85644403 3.33990146L604.0858758 297.2920003a94.47151987 94.47151987 0 0 0-54.86982251-111.64815985c-20.51654257-7.63406259-41.98734253-9.54257739-61.07249732-4.29415998L407.03164421 100.71489799l37.69318255-37.21605328c37.21605328-37.69318254 97.3342932-37.69318254 134.55034648 0l381.22598205 381.22598205c37.69318254 37.21605328 37.69318254 97.3342932 0 134.55034648l-381.22598205 381.22598205c-37.21605328 37.69318254-97.3342932 37.69318254-134.55034648 0L63.49884471 579.27517324c-37.69318254-37.21605328-37.69318254-97.3342932 0-134.55034648z\" fill=\"#E64A19\" p-id=\"838\"></path></svg>\n    </div>\n  </div>\n</div>\n",
      "date_published": "2020-08-08T09:13:58.000Z",
      "date_modified": "2021-11-17T06:13:21.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "关于本站",
      "url": "https://www.fedbook.cn/about/",
      "id": "https://www.fedbook.cn/about/",
      "content_html": "<h1 id=\"关于本站\"> 关于本站</h1>\n<h2 id=\"前言\"> 前言</h2>\n<p>该小册是我的个人文档库，开源在 GitHub，它不是什么官方文档，仅仅是一本个人笔记，用于知识点的梳理。</p>\n<p>小册是本人一边学习一边总结的，可能会存在错误，希望大家能够「<strong>带着怀疑的态度</strong>」去阅读，如果有不同的看法，可以在 <a href=\"https://github.com/wenyuan/fedbook/issues/new?title=%E3%80%90%E8%AE%A8%E8%AE%BA%E3%80%91%E6%AD%A4%E5%A4%84%E5%A1%AB%E5%86%99%E6%96%87%E7%AB%A0%E6%A0%87%E9%A2%98&amp;body=-%20%E6%96%87%E7%AB%A0%E6%A0%87%E9%A2%98%EF%BC%9A%0A-%20%E6%96%87%E7%AB%A0%E9%93%BE%E6%8E%A5%EF%BC%9A%0A-%20%E6%88%91%E7%9A%84%E7%96%91%E9%97%AE/%E8%A7%82%E7%82%B9%EF%BC%9A%0A-%20%E6%8E%A8%E8%8D%90%E8%B5%84%E6%96%99%EF%BC%9A\" title=\"留言版\" target=\"_blank\" rel=\"noopener noreferrer\">留言板</a> 提出，大家共同进步，让这本小册日趋完善。</p>\n<h2 id=\"建立小册的目的\"> 建立小册的目的</h2>\n<p>用输出倒逼输入，写文档的过程，是对自己所学知识的沉淀，分享交流的过程是对知识的复盘，这些都能够加深对知识的理解。（<a href=\"https://36kr.com/p/1721599983617\" target=\"_blank\" rel=\"noopener noreferrer\">费曼学习法</a>）</p>\n<h2 id=\"编写小册的想法\"> 编写小册的想法</h2>\n<p>高中时候有摘笔记的习惯，每天都会挤时间抄课堂讲义，但到高考结束都几乎没有翻完那一堆本子。后来发现这是一种比较愚蠢的课堂笔记 —— 什么都记还不如不记。经过一次次的尝试后，觉得根据文章理大纲也比较低效。目前来看，还是通过判断个人对知识点吸收的难易程度去记，更容易自己成长。把认为重要的、容易遗忘的、经常要查阅的记录下来，形成自己的学习小册，定期温故知新。未来需要用到的时候，还能节省时间成本，不用一一百度/Google。</p>\n<p>小册内的所有文章参考自官方文档、经典书籍、优质文章、付费课程等，并结合了自己学习过程中对每个知识点实践和理解。感谢广大行业前辈、教育工作者和知识传播者，得益于你们的探索，我们能够站在巨人的肩膀上去学习。</p>\n<p>如果其中有一些内容能够帮到他人，那是极好的。但一个人对知识点的理解总会有偏差，因此这份小册是开源的。如果读者对小册中某块内容有异议，欢迎通过 <a href=\"https://github.com/wenyuan/fedbook/issues/new?title=%E3%80%90%E8%AE%A8%E8%AE%BA%E3%80%91%E6%AD%A4%E5%A4%84%E5%A1%AB%E5%86%99%E6%96%87%E7%AB%A0%E6%A0%87%E9%A2%98&amp;body=-%20%E6%96%87%E7%AB%A0%E6%A0%87%E9%A2%98%EF%BC%9A%0A-%20%E6%96%87%E7%AB%A0%E9%93%BE%E6%8E%A5%EF%BC%9A%0A-%20%E6%88%91%E7%9A%84%E7%96%91%E9%97%AE/%E8%A7%82%E7%82%B9%EF%BC%9A%0A-%20%E6%8E%A8%E8%8D%90%E8%B5%84%E6%96%99%EF%BC%9A\" title=\"issues\" target=\"_blank\" rel=\"noopener noreferrer\">Issues</a> 提出您宝贵的建议。</p>\n<h2 id=\"小册与博客的区别\"> 小册与博客的区别</h2>\n<p>在写这个小册之前，已经搭建了个人博客，但随着自己的使用，有了不同的需求。</p>\n<ul>\n<li>博客记录开发经验、读书笔记、生活随笔、理财心得等，涉及面比较广泛。撰写博客的目的是为了留下成长的足迹。</li>\n<li>小册是个人文档库，系统梳理前端开发的知识脉络，记录学习时自己认为重要或易忘的知识点，更有利于定期回顾。</li>\n</ul>\n<h2 id=\"关于作者\"> 关于作者</h2>\n<p>你好，我是 wenyuan，江苏人，本科专业是自动化方向，转行自学的 IT 类编程语言，目前是一名前端开发工程师，爱好阅读、运动和二次元。</p>\n<p>没有建群，没有公众号，未从事自媒体，不过为了及时获取多领域信息，会在很多自媒体大小 V 的社群里潜水。</p>\n<p><a href=\"https://github.com/wenyuan\" title=\"GitHub\" target=\"_blank\" rel=\"noopener noreferrer\">GitHub@wenyuan</a>：目前没有 star 过千、特别有价值的项目，不过有些可能对你有点帮助，可以瞧瞧。</p>\n<p><a href=\"https://www.douban.com/people/wenyuan1024/\" title=\"豆瓣\" target=\"_blank\" rel=\"noopener noreferrer\">豆瓣@wenyuan1024</a>：除了技术书外，2019 年开始大量阅读，欢迎推荐你觉得不错的书籍。</p>\n<h2 id=\"小册历程\"> 小册历程</h2>\n<ul>\n<li>2021.11.08   升级 vuepress-theme-hope 主题至最新版本（1.20.5）。\n<ul>\n<li><code>npm install</code> 下载依赖包时需要切换成官方源，淘宝镜像源未更新。</li>\n<li>行业大事记：<a href=\"https://www.yuque.com/afx/blog/cnpm-new-registry\" target=\"_blank\" rel=\"noopener noreferrer\">淘宝 NPM 镜像站切换新域名啦</a>（npm.taobao.org =&gt; npmmirror.com）。</li>\n</ul>\n</li>\n<li>2021.07.16   升级 vuepress-theme-hope 主题至最新版本（1.19.0），并删除/覆盖一些样式。</li>\n<li>2021.01.09   升级 vuepress-theme-hope 主题至最新版本（1.8.1），并覆盖一些过于酷炫的样式。</li>\n<li>2020.10.26   移除 vuepress-plugin-demo-block 插件，改用 CodePen。</li>\n<li>2020.10.11   使用 <a href=\"https://daxigua.me/vuepress-plugin-demo-block/zh/\" title=\"vuepress-plugin-demo-block\" target=\"_blank\" rel=\"noopener noreferrer\">vuepress-plugin-demo-block</a> 插件。\n<ul>\n<li>让 Demo 演示框（主要是 CSS 知识点中的代码）更直观，方便调试。</li>\n</ul>\n</li>\n<li>2020.09.27   使用 <a href=\"https://github.com/vuepress-theme-hope/vuepress-theme-hope\" title=\"vuepress-theme-hope\" target=\"_blank\" rel=\"noopener noreferrer\">vuepress-theme-hope</a> 主题。\n<ul>\n<li>在内容页，左侧展示文章标题列表、右侧展示当前文章的子标题，这样的排版可读性较好。</li>\n</ul>\n</li>\n<li>2020.08.17   服务方不稳定，新增多线路切换访问。</li>\n<li>2020.07.26   购买域名，部署上线。</li>\n<li>2020.07.11   使用 VuePress 搭建小册。</li>\n</ul>\n<h2 id=\"最后\"> 最后</h2>\n<p>Thank you for your attention…</p>\n",
      "date_published": "2020-08-31T09:36:42.000Z",
      "date_modified": "2022-03-01T14:30:18.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "类的继承",
      "url": "https://www.fedbook.cn/backend-knowledge/python/class-inheritance/",
      "id": "https://www.fedbook.cn/backend-knowledge/python/class-inheritance/",
      "content_html": "<h1 id=\"类的继承\"> 类的继承</h1>\n<p>Python 支持多父类的继承机制，所以需要注意圆括号中基类的顺序，若是基类中有相同的方法名，并且在子类使用时未指定，Python 会从左至右搜索基类中是否包含该方法。一旦查找到则直接调用，后面不再继续查找。</p>\n<h2 id=\"继承机制\"> 继承机制</h2>\n<p>Python3 的继承机制不同于 Python2。其核心原则是下面两条：</p>\n<ul>\n<li>子类在调用某个方法或变量的时候，首先在自己内部查找，如果没有找到，则开始根据继承机制在父类里查找。</li>\n<li>根据父类定义中的顺序，以<strong>深度优先</strong>的方式逐一查找父类。</li>\n</ul>\n<h3 id=\"第一个例子\"> 第一个例子</h3>\n<p>设想有下面的继承关系：</p>\n<div><pre><code><span>class</span> <span>A</span><span>(</span>B<span>,</span> E<span>)</span><span>:</span>\n    <span>pass</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><ul>\n<li>A 继承 B 和 E\n<ul>\n<li>B 继承 C，C 继承 D</li>\n<li>E 继承 F，F 继承 G</li>\n</ul>\n</li>\n</ul>\n<p>如下图所示：</p>\n<div style=\"text-align: center;\">\n  <svg id=\"SvgjsSvg1074\" width=\"225\" height=\"300\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><defs id=\"SvgjsDefs1075\"><marker id=\"SvgjsMarker1120\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1121\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1124\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1125\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1128\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1129\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1132\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1133\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1136\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1137\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1140\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1141\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker></defs><g id=\"SvgjsG1076\" transform=\"translate(84,243)\"><path id=\"SvgjsPath1077\" d=\"M 0 0L 52 0L 52 32L 0 32Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1078\"><text id=\"SvgjsText1079\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"32px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"3.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1080\" dy=\"20\" x=\"26\"><tspan id=\"SvgjsTspan1081\" style=\"text-decoration:;\">A</tspan></tspan></text></g></g><g id=\"SvgjsG1082\" transform=\"translate(25,155)\"><path id=\"SvgjsPath1083\" d=\"M 0 0L 52 0L 52 32L 0 32Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1084\"><text id=\"SvgjsText1085\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"32px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"3.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1086\" dy=\"20\" x=\"26\"><tspan id=\"SvgjsTspan1087\" style=\"text-decoration:;\">B</tspan></tspan></text></g></g><g id=\"SvgjsG1088\" transform=\"translate(148,155)\"><path id=\"SvgjsPath1089\" d=\"M 0 0L 52 0L 52 32L 0 32Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1090\"><text id=\"SvgjsText1091\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"32px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"3.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1092\" dy=\"20\" x=\"26\"><tspan id=\"SvgjsTspan1093\" style=\"text-decoration:;\">E</tspan></tspan></text></g></g><g id=\"SvgjsG1094\" transform=\"translate(25,90)\"><path id=\"SvgjsPath1095\" d=\"M 0 0L 52 0L 52 32L 0 32Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1096\"><text id=\"SvgjsText1097\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"32px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"3.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1098\" dy=\"20\" x=\"26\"><tspan id=\"SvgjsTspan1099\" style=\"text-decoration:;\">C</tspan></tspan></text></g></g><g id=\"SvgjsG1100\" transform=\"translate(148,90)\"><path id=\"SvgjsPath1101\" d=\"M 0 0L 52 0L 52 32L 0 32Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1102\"><text id=\"SvgjsText1103\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"32px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"3.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1104\" dy=\"20\" x=\"26\"><tspan id=\"SvgjsTspan1105\" style=\"text-decoration:;\">F</tspan></tspan></text></g></g><g id=\"SvgjsG1106\" transform=\"translate(25,25)\"><path id=\"SvgjsPath1107\" d=\"M 0 0L 52 0L 52 32L 0 32Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1108\"><text id=\"SvgjsText1109\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"32px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"3.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1110\" dy=\"20\" x=\"26\"><tspan id=\"SvgjsTspan1111\" style=\"text-decoration:;\">D</tspan></tspan></text></g></g><g id=\"SvgjsG1112\" transform=\"translate(148,25)\"><path id=\"SvgjsPath1113\" d=\"M 0 0L 52 0L 52 32L 0 32Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1114\"><text id=\"SvgjsText1115\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"32px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"3.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1116\" dy=\"20\" x=\"26\"><tspan id=\"SvgjsTspan1117\" style=\"text-decoration:;\">G</tspan></tspan></text></g></g><g id=\"SvgjsG1118\"><path id=\"SvgjsPath1119\" d=\"M110 243L110 215L174 215L174 187\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1120)\"></path></g><g id=\"SvgjsG1122\"><path id=\"SvgjsPath1123\" d=\"M110 243L110 215L51 215L51 187\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1124)\"></path></g><g id=\"SvgjsG1126\"><path id=\"SvgjsPath1127\" d=\"M51 155L51 138.5L51 138.5L51 122\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1128)\"></path></g><g id=\"SvgjsG1130\"><path id=\"SvgjsPath1131\" d=\"M174 155L174 138.5L174 138.5L174 122\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1132)\"></path></g><g id=\"SvgjsG1134\"><path id=\"SvgjsPath1135\" d=\"M51 90L51 73.5L51 73.5L51 57\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1136)\"></path></g><g id=\"SvgjsG1138\"><path id=\"SvgjsPath1139\" d=\"M174 90L174 73.5L174 73.5L174 57\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1140)\"></path></g></svg>\n  <p style=\"text-align:center; color: #888;\">（继承关系 - 第一个例子）</p>\n</div>\n<p>在这种继承结构关系中，子类在调用某个方法或变量的时候，搜索顺序是这样的（按下图中红色箭头路径指向）：</p>\n<div style=\"text-align: center;\">\n  <svg id=\"SvgjsSvg1142\" width=\"356\" height=\"300\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><defs id=\"SvgjsDefs1143\"><marker id=\"SvgjsMarker1188\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1189\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1192\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1193\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1196\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1197\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1200\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1201\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1204\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1205\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1208\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1209\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1212\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1213\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#ff3333\" stroke=\"#ff3333\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1216\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1217\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#ff3333\" stroke=\"#ff3333\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1220\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1221\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#ff3333\" stroke=\"#ff3333\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1224\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1225\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#ff3333\" stroke=\"#ff3333\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1228\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1229\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#ff3333\" stroke=\"#ff3333\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1232\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1233\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#ff3333\" stroke=\"#ff3333\" stroke-width=\"2\"></path></marker></defs><g id=\"SvgjsG1144\" transform=\"translate(152,243)\"><path id=\"SvgjsPath1145\" d=\"M 0 0L 52 0L 52 32L 0 32Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1146\"><text id=\"SvgjsText1147\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"32px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"3.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1148\" dy=\"20\" x=\"26\"><tspan id=\"SvgjsTspan1149\" style=\"text-decoration:;\">A</tspan></tspan></text></g></g><g id=\"SvgjsG1150\" transform=\"translate(93,155)\"><path id=\"SvgjsPath1151\" d=\"M 0 0L 52 0L 52 32L 0 32Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1152\"><text id=\"SvgjsText1153\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"32px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"3.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1154\" dy=\"20\" x=\"26\"><tspan id=\"SvgjsTspan1155\" style=\"text-decoration:;\">B</tspan></tspan></text></g></g><g id=\"SvgjsG1156\" transform=\"translate(216,155)\"><path id=\"SvgjsPath1157\" d=\"M 0 0L 52 0L 52 32L 0 32Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1158\"><text id=\"SvgjsText1159\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"32px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"3.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1160\" dy=\"20\" x=\"26\"><tspan id=\"SvgjsTspan1161\" style=\"text-decoration:;\">E</tspan></tspan></text></g></g><g id=\"SvgjsG1162\" transform=\"translate(93,90)\"><path id=\"SvgjsPath1163\" d=\"M 0 0L 52 0L 52 32L 0 32Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1164\"><text id=\"SvgjsText1165\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"32px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"3.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1166\" dy=\"20\" x=\"26\"><tspan id=\"SvgjsTspan1167\" style=\"text-decoration:;\">C</tspan></tspan></text></g></g><g id=\"SvgjsG1168\" transform=\"translate(216,90)\"><path id=\"SvgjsPath1169\" d=\"M 0 0L 52 0L 52 32L 0 32Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1170\"><text id=\"SvgjsText1171\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"32px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"3.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1172\" dy=\"20\" x=\"26\"><tspan id=\"SvgjsTspan1173\" style=\"text-decoration:;\">F</tspan></tspan></text></g></g><g id=\"SvgjsG1174\" transform=\"translate(93,25)\"><path id=\"SvgjsPath1175\" d=\"M 0 0L 52 0L 52 32L 0 32Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1176\"><text id=\"SvgjsText1177\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"32px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"3.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1178\" dy=\"20\" x=\"26\"><tspan id=\"SvgjsTspan1179\" style=\"text-decoration:;\">D</tspan></tspan></text></g></g><g id=\"SvgjsG1180\" transform=\"translate(216,25)\"><path id=\"SvgjsPath1181\" d=\"M 0 0L 52 0L 52 32L 0 32Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1182\"><text id=\"SvgjsText1183\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"32px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"3.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1184\" dy=\"20\" x=\"26\"><tspan id=\"SvgjsTspan1185\" style=\"text-decoration:;\">G</tspan></tspan></text></g></g><g id=\"SvgjsG1186\"><path id=\"SvgjsPath1187\" d=\"M178 243L178 215L242 215L242 187\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1188)\"></path></g><g id=\"SvgjsG1190\"><path id=\"SvgjsPath1191\" d=\"M178 243L178 215L119 215L119 187\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1192)\"></path></g><g id=\"SvgjsG1194\"><path id=\"SvgjsPath1195\" d=\"M119 155L119 138.5L119 138.5L119 122\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1196)\"></path></g><g id=\"SvgjsG1198\"><path id=\"SvgjsPath1199\" d=\"M242 155L242 138.5L242 138.5L242 122\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1200)\"></path></g><g id=\"SvgjsG1202\"><path id=\"SvgjsPath1203\" d=\"M119 90L119 73.5L119 73.5L119 57\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1204)\"></path></g><g id=\"SvgjsG1206\"><path id=\"SvgjsPath1207\" d=\"M242 90L242 73.5L242 73.5L242 57\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1208)\"></path></g><g id=\"SvgjsG1210\"><path id=\"SvgjsPath1211\" d=\"M145 263L98 198\" stroke=\"#ff3333\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1212)\"></path></g><g id=\"SvgjsG1214\"><path id=\"SvgjsPath1215\" d=\"M100 154L100 121\" stroke=\"#ff3333\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1216)\"></path></g><g id=\"SvgjsG1218\"><path id=\"SvgjsPath1219\" d=\"M99 91L99 58\" stroke=\"#ff3333\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1220)\"></path></g><g id=\"SvgjsG1222\"><path id=\"SvgjsPath1223\" d=\"M152 48L207 163\" stroke=\"#ff3333\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1224)\"></path></g><g id=\"SvgjsG1226\"><path id=\"SvgjsPath1227\" d=\"M257 156L257 123\" stroke=\"#ff3333\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1228)\"></path></g><g id=\"SvgjsG1230\"><path id=\"SvgjsPath1231\" d=\"M259 90L259 57\" stroke=\"#ff3333\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1232)\"></path></g><g id=\"SvgjsG1234\" transform=\"translate(50,214)\"><path id=\"SvgjsPath1235\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1236\"><text id=\"SvgjsText1237\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"120px\" fill=\"#ff3333\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"7.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1238\" dy=\"20\" x=\"60\"><tspan id=\"SvgjsTspan1239\" style=\"text-decoration:;\">1</tspan></tspan></text></g></g><g id=\"SvgjsG1240\" transform=\"translate(25,122)\"><path id=\"SvgjsPath1241\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1242\"><text id=\"SvgjsText1243\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"120px\" fill=\"#ff3333\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"7.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1244\" dy=\"20\" x=\"60\"><tspan id=\"SvgjsTspan1245\" style=\"text-decoration:;\">2</tspan></tspan></text></g></g><g id=\"SvgjsG1246\" transform=\"translate(25,57)\"><path id=\"SvgjsPath1247\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1248\"><text id=\"SvgjsText1249\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"120px\" fill=\"#ff3333\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"7.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1250\" dy=\"20\" x=\"60\"><tspan id=\"SvgjsTspan1251\" style=\"text-decoration:;\">3</tspan></tspan></text></g></g><g id=\"SvgjsG1252\" transform=\"translate(112,97)\"><path id=\"SvgjsPath1253\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1254\"><text id=\"SvgjsText1255\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"120px\" fill=\"#ff3333\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"7.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1256\" dy=\"20\" x=\"60\"><tspan id=\"SvgjsTspan1257\" style=\"text-decoration:;\">4</tspan></tspan></text></g></g><g id=\"SvgjsG1258\" transform=\"translate(211,122)\"><path id=\"SvgjsPath1259\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1260\"><text id=\"SvgjsText1261\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"120px\" fill=\"#ff3333\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"7.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1262\" dy=\"20\" x=\"60\"><tspan id=\"SvgjsTspan1263\" style=\"text-decoration:;\">5</tspan></tspan></text></g></g><g id=\"SvgjsG1264\" transform=\"translate(211,57)\"><path id=\"SvgjsPath1265\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1266\"><text id=\"SvgjsText1267\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"120px\" fill=\"#ff3333\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"7.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1268\" dy=\"20\" x=\"60\"><tspan id=\"SvgjsTspan1269\" style=\"text-decoration:;\">6</tspan></tspan></text></g></g></svg>\n  <p style=\"text-align:center; color: #888;\">（第一个例子的搜索顺序）</p>\n</div>\n<h3 id=\"第二个例子\"> 第二个例子</h3>\n<p>如果继承结构是这样的：类 D 和类 G 又同时继承了类 H，如下图所示：</p>\n<div style=\"text-align: center;\">\n  <svg id=\"SvgjsSvg1422\" width=\"225\" height=\"375\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><defs id=\"SvgjsDefs1423\"><marker id=\"SvgjsMarker1468\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1469\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1472\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1473\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1476\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1477\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1480\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1481\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1484\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1485\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1488\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1489\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1498\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1499\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1502\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1503\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker></defs><g id=\"SvgjsG1424\" transform=\"translate(84,318)\"><path id=\"SvgjsPath1425\" d=\"M 0 0L 52 0L 52 32L 0 32Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1426\"><text id=\"SvgjsText1427\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"32px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"3.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1428\" dy=\"20\" x=\"26\"><tspan id=\"SvgjsTspan1429\" style=\"text-decoration:;\">A</tspan></tspan></text></g></g><g id=\"SvgjsG1430\" transform=\"translate(25,230)\"><path id=\"SvgjsPath1431\" d=\"M 0 0L 52 0L 52 32L 0 32Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1432\"><text id=\"SvgjsText1433\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"32px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"3.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1434\" dy=\"20\" x=\"26\"><tspan id=\"SvgjsTspan1435\" style=\"text-decoration:;\">B</tspan></tspan></text></g></g><g id=\"SvgjsG1436\" transform=\"translate(148,230)\"><path id=\"SvgjsPath1437\" d=\"M 0 0L 52 0L 52 32L 0 32Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1438\"><text id=\"SvgjsText1439\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"32px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"3.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1440\" dy=\"20\" x=\"26\"><tspan id=\"SvgjsTspan1441\" style=\"text-decoration:;\">E</tspan></tspan></text></g></g><g id=\"SvgjsG1442\" transform=\"translate(25,165)\"><path id=\"SvgjsPath1443\" d=\"M 0 0L 52 0L 52 32L 0 32Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1444\"><text id=\"SvgjsText1445\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"32px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"3.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1446\" dy=\"20\" x=\"26\"><tspan id=\"SvgjsTspan1447\" style=\"text-decoration:;\">C</tspan></tspan></text></g></g><g id=\"SvgjsG1448\" transform=\"translate(148,165)\"><path id=\"SvgjsPath1449\" d=\"M 0 0L 52 0L 52 32L 0 32Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1450\"><text id=\"SvgjsText1451\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"32px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"3.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1452\" dy=\"20\" x=\"26\"><tspan id=\"SvgjsTspan1453\" style=\"text-decoration:;\">F</tspan></tspan></text></g></g><g id=\"SvgjsG1454\" transform=\"translate(25,100)\"><path id=\"SvgjsPath1455\" d=\"M 0 0L 52 0L 52 32L 0 32Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1456\"><text id=\"SvgjsText1457\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"32px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"3.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1458\" dy=\"20\" x=\"26\"><tspan id=\"SvgjsTspan1459\" style=\"text-decoration:;\">D</tspan></tspan></text></g></g><g id=\"SvgjsG1460\" transform=\"translate(148,100)\"><path id=\"SvgjsPath1461\" d=\"M 0 0L 52 0L 52 32L 0 32Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1462\"><text id=\"SvgjsText1463\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"32px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"3.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1464\" dy=\"20\" x=\"26\"><tspan id=\"SvgjsTspan1465\" style=\"text-decoration:;\">G</tspan></tspan></text></g></g><g id=\"SvgjsG1466\"><path id=\"SvgjsPath1467\" d=\"M110 318L110 290L174 290L174 262\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1468)\"></path></g><g id=\"SvgjsG1470\"><path id=\"SvgjsPath1471\" d=\"M110 318L110 290L51 290L51 262\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1472)\"></path></g><g id=\"SvgjsG1474\"><path id=\"SvgjsPath1475\" d=\"M51 230L51 213.5L51 213.5L51 197\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1476)\"></path></g><g id=\"SvgjsG1478\"><path id=\"SvgjsPath1479\" d=\"M174 230L174 213.5L174 213.5L174 197\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1480)\"></path></g><g id=\"SvgjsG1482\"><path id=\"SvgjsPath1483\" d=\"M51 165L51 148.5L51 148.5L51 132\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1484)\"></path></g><g id=\"SvgjsG1486\"><path id=\"SvgjsPath1487\" d=\"M174 165L174 148.5L174 148.5L174 132\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1488)\"></path></g><g id=\"SvgjsG1490\" transform=\"translate(84,25)\"><path id=\"SvgjsPath1491\" d=\"M 0 0L 52 0L 52 32L 0 32Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1492\"><text id=\"SvgjsText1493\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"32px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"3.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1494\" dy=\"20\" x=\"26\"><tspan id=\"SvgjsTspan1495\" style=\"text-decoration:;\">H</tspan></tspan></text></g></g><g id=\"SvgjsG1496\"><path id=\"SvgjsPath1497\" d=\"M51 100L51 78.5L110 78.5L110 57\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1498)\"></path></g><g id=\"SvgjsG1500\"><path id=\"SvgjsPath1501\" d=\"M174 100L174 78.5L110 78.5L110 57\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1502)\"></path></g></svg>\n  <p style=\"text-align:center; color: #888;\">（继承关系 - 第二个例子）</p>\n</div>\n<p>此时的搜索顺序是这样的（按下图中红色箭头路径指向）：</p>\n<div style=\"text-align: center;\">\n  <svg id=\"SvgjsSvg1270\" width=\"356\" height=\"375\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><defs id=\"SvgjsDefs1271\"><marker id=\"SvgjsMarker1316\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1317\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1320\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1321\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1324\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1325\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1328\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1329\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1332\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1333\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1336\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1337\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1340\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1341\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#ff3333\" stroke=\"#ff3333\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1344\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1345\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#ff3333\" stroke=\"#ff3333\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1348\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1349\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#ff3333\" stroke=\"#ff3333\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1352\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1353\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#ff3333\" stroke=\"#ff3333\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1356\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1357\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#ff3333\" stroke=\"#ff3333\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1360\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1361\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#ff3333\" stroke=\"#ff3333\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1406\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1407\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1410\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1411\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1414\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1415\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#ff3333\" stroke=\"#ff3333\" stroke-width=\"2\"></path></marker></defs><g id=\"SvgjsG1272\" transform=\"translate(152,318)\"><path id=\"SvgjsPath1273\" d=\"M 0 0L 52 0L 52 32L 0 32Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1274\"><text id=\"SvgjsText1275\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"32px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"3.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1276\" dy=\"20\" x=\"26\"><tspan id=\"SvgjsTspan1277\" style=\"text-decoration:;\">A</tspan></tspan></text></g></g><g id=\"SvgjsG1278\" transform=\"translate(93,230)\"><path id=\"SvgjsPath1279\" d=\"M 0 0L 52 0L 52 32L 0 32Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1280\"><text id=\"SvgjsText1281\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"32px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"3.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1282\" dy=\"20\" x=\"26\"><tspan id=\"SvgjsTspan1283\" style=\"text-decoration:;\">B</tspan></tspan></text></g></g><g id=\"SvgjsG1284\" transform=\"translate(216,230)\"><path id=\"SvgjsPath1285\" d=\"M 0 0L 52 0L 52 32L 0 32Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1286\"><text id=\"SvgjsText1287\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"32px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"3.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1288\" dy=\"20\" x=\"26\"><tspan id=\"SvgjsTspan1289\" style=\"text-decoration:;\">E</tspan></tspan></text></g></g><g id=\"SvgjsG1290\" transform=\"translate(93,165)\"><path id=\"SvgjsPath1291\" d=\"M 0 0L 52 0L 52 32L 0 32Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1292\"><text id=\"SvgjsText1293\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"32px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"3.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1294\" dy=\"20\" x=\"26\"><tspan id=\"SvgjsTspan1295\" style=\"text-decoration:;\">C</tspan></tspan></text></g></g><g id=\"SvgjsG1296\" transform=\"translate(216,165)\"><path id=\"SvgjsPath1297\" d=\"M 0 0L 52 0L 52 32L 0 32Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1298\"><text id=\"SvgjsText1299\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"32px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"3.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1300\" dy=\"20\" x=\"26\"><tspan id=\"SvgjsTspan1301\" style=\"text-decoration:;\">F</tspan></tspan></text></g></g><g id=\"SvgjsG1302\" transform=\"translate(93,100)\"><path id=\"SvgjsPath1303\" d=\"M 0 0L 52 0L 52 32L 0 32Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1304\"><text id=\"SvgjsText1305\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"32px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"3.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1306\" dy=\"20\" x=\"26\"><tspan id=\"SvgjsTspan1307\" style=\"text-decoration:;\">D</tspan></tspan></text></g></g><g id=\"SvgjsG1308\" transform=\"translate(216,100)\"><path id=\"SvgjsPath1309\" d=\"M 0 0L 52 0L 52 32L 0 32Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1310\"><text id=\"SvgjsText1311\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"32px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"3.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1312\" dy=\"20\" x=\"26\"><tspan id=\"SvgjsTspan1313\" style=\"text-decoration:;\">G</tspan></tspan></text></g></g><g id=\"SvgjsG1314\"><path id=\"SvgjsPath1315\" d=\"M178 318L178 290L242 290L242 262\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1316)\"></path></g><g id=\"SvgjsG1318\"><path id=\"SvgjsPath1319\" d=\"M178 318L178 290L119 290L119 262\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1320)\"></path></g><g id=\"SvgjsG1322\"><path id=\"SvgjsPath1323\" d=\"M119 230L119 213.5L119 213.5L119 197\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1324)\"></path></g><g id=\"SvgjsG1326\"><path id=\"SvgjsPath1327\" d=\"M242 230L242 213.5L242 213.5L242 197\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1328)\"></path></g><g id=\"SvgjsG1330\"><path id=\"SvgjsPath1331\" d=\"M119 165L119 148.5L119 148.5L119 132\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1332)\"></path></g><g id=\"SvgjsG1334\"><path id=\"SvgjsPath1335\" d=\"M242 165L242 148.5L242 148.5L242 132\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1336)\"></path></g><g id=\"SvgjsG1338\"><path id=\"SvgjsPath1339\" d=\"M145 338L98 273\" stroke=\"#ff3333\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1340)\"></path></g><g id=\"SvgjsG1342\"><path id=\"SvgjsPath1343\" d=\"M100 229L100 196\" stroke=\"#ff3333\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1344)\"></path></g><g id=\"SvgjsG1346\"><path id=\"SvgjsPath1347\" d=\"M99 166L99 133\" stroke=\"#ff3333\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1348)\"></path></g><g id=\"SvgjsG1350\"><path id=\"SvgjsPath1351\" d=\"M152 123L207 238\" stroke=\"#ff3333\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1352)\"></path></g><g id=\"SvgjsG1354\"><path id=\"SvgjsPath1355\" d=\"M257 231L257 198\" stroke=\"#ff3333\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1356)\"></path></g><g id=\"SvgjsG1358\"><path id=\"SvgjsPath1359\" d=\"M259 165L259 132\" stroke=\"#ff3333\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1360)\"></path></g><g id=\"SvgjsG1362\" transform=\"translate(50,289)\"><path id=\"SvgjsPath1363\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1364\"><text id=\"SvgjsText1365\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"120px\" fill=\"#ff3333\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"7.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1366\" dy=\"20\" x=\"60\"><tspan id=\"SvgjsTspan1367\" style=\"text-decoration:;\">1</tspan></tspan></text></g></g><g id=\"SvgjsG1368\" transform=\"translate(25,197)\"><path id=\"SvgjsPath1369\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1370\"><text id=\"SvgjsText1371\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"120px\" fill=\"#ff3333\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"7.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1372\" dy=\"20\" x=\"60\"><tspan id=\"SvgjsTspan1373\" style=\"text-decoration:;\">2</tspan></tspan></text></g></g><g id=\"SvgjsG1374\" transform=\"translate(25,132)\"><path id=\"SvgjsPath1375\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1376\"><text id=\"SvgjsText1377\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"120px\" fill=\"#ff3333\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"7.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1378\" dy=\"20\" x=\"60\"><tspan id=\"SvgjsTspan1379\" style=\"text-decoration:;\">3</tspan></tspan></text></g></g><g id=\"SvgjsG1380\" transform=\"translate(112,172)\"><path id=\"SvgjsPath1381\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1382\"><text id=\"SvgjsText1383\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"120px\" fill=\"#ff3333\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"7.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1384\" dy=\"20\" x=\"60\"><tspan id=\"SvgjsTspan1385\" style=\"text-decoration:;\">4</tspan></tspan></text></g></g><g id=\"SvgjsG1386\" transform=\"translate(211,197)\"><path id=\"SvgjsPath1387\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1388\"><text id=\"SvgjsText1389\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"120px\" fill=\"#ff3333\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"7.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1390\" dy=\"20\" x=\"60\"><tspan id=\"SvgjsTspan1391\" style=\"text-decoration:;\">5</tspan></tspan></text></g></g><g id=\"SvgjsG1392\" transform=\"translate(211,132)\"><path id=\"SvgjsPath1393\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1394\"><text id=\"SvgjsText1395\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"120px\" fill=\"#ff3333\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"7.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1396\" dy=\"20\" x=\"60\"><tspan id=\"SvgjsTspan1397\" style=\"text-decoration:;\">6</tspan></tspan></text></g></g><g id=\"SvgjsG1398\" transform=\"translate(152,25)\"><path id=\"SvgjsPath1399\" d=\"M 0 0L 52 0L 52 32L 0 32Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1400\"><text id=\"SvgjsText1401\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"32px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"3.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1402\" dy=\"20\" x=\"26\"><tspan id=\"SvgjsTspan1403\" style=\"text-decoration:;\">H</tspan></tspan></text></g></g><g id=\"SvgjsG1404\"><path id=\"SvgjsPath1405\" d=\"M119 100L119 78.5L178 78.5L178 57\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1406)\"></path></g><g id=\"SvgjsG1408\"><path id=\"SvgjsPath1409\" d=\"M242 100L242 78.5L178 78.5L178 57\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1410)\"></path></g><g id=\"SvgjsG1412\"><path id=\"SvgjsPath1413\" d=\"M258 97L202 57\" stroke=\"#ff3333\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1414)\"></path></g><g id=\"SvgjsG1416\" transform=\"translate(182,46)\"><path id=\"SvgjsPath1417\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1418\"><text id=\"SvgjsText1419\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"120px\" fill=\"#ff3333\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"7.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1420\" dy=\"20\" x=\"60\"><tspan id=\"SvgjsTspan1421\" style=\"text-decoration:;\">7</tspan></tspan></text></g></g></svg>\n  <p style=\"text-align:center; color: #888;\">（第二个例子的搜索顺序）</p>\n</div>\n<p>至于其它更错综复杂的继承情况，其实都能划分成上面两种情况。</p>\n<h2 id=\"super-函数\"> super() 函数</h2>\n<p>在子类中如果有与父类同名的成员，那就会覆盖（Override）掉父类里的成员。</p>\n<p>此时如果想强制调用父类的成员，可以使用 <code>super()</code> 函数。这是一个非常重要的函数，最常见的就是通过 <code>super</code> 调用父类的实例化方法 <code>__init__</code>。</p>\n<p>语法：<code>super(子类名, self).方法名()</code>，需要传入的是子类名和 <code>self</code>，调用的是父类里的方法，按父类的方法需要传入参数。如下例所示：</p>\n<div><pre><code><span>class</span> <span>A</span><span>:</span>\n    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>)</span><span>:</span>\n        self<span>.</span>name <span>=</span> name\n        <span>print</span><span>(</span><span>\"父类的__init__方法被执行了！\"</span><span>)</span>\n    <span>def</span> <span>show</span><span>(</span>self<span>)</span><span>:</span>\n        <span>print</span><span>(</span><span>\"父类的show方法被执行了！\"</span><span>)</span>\n\n<span>class</span> <span>B</span><span>(</span>A<span>)</span><span>:</span>\n    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>,</span> age<span>)</span><span>:</span>\n        <span>super</span><span>(</span>B<span>,</span> self<span>)</span><span>.</span>__init__<span>(</span>name<span>=</span>name<span>)</span>\n        self<span>.</span>age <span>=</span> age\n\n    <span>def</span> <span>show</span><span>(</span>self<span>)</span><span>:</span>\n        <span>super</span><span>(</span>B<span>,</span> self<span>)</span><span>.</span>show<span>(</span><span>)</span>\n\nobj <span>=</span> B<span>(</span><span>\"zhangsan\"</span><span>,</span> <span>13</span><span>)</span>\nobj<span>.</span>show<span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>（完）</p>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2021-11-19T03:27:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "编译器与解释器",
      "url": "https://www.fedbook.cn/backend-knowledge/python/compiler-and-interpreter/",
      "id": "https://www.fedbook.cn/backend-knowledge/python/compiler-and-interpreter/",
      "content_html": "<h1 id=\"编译器与解释器\"> 编译器与解释器</h1>\n<h2 id=\"区别\"> 区别</h2>\n<p>编译器与解释器作为高级语言与机器之间的翻译官，都是将代码翻译成机器可以执行的二进制机器码，只不过在运行原理和翻译过程有不同。</p>\n<p><strong>编译器</strong>：先整体编译再执行。特点是运行速度快，但任何一个小改动都需要整体重新编译。可脱离编译环境运行。代表语言是 C 语言。</p>\n<p><strong>解释器</strong>：边解释边执行。特点是运行速度慢，但部分改动不需要整体重新编译。不可脱离解释器环境运行。代表语言是 Python 语言。</p>\n<h2 id=\"python-解释器种类\"> Python 解释器种类</h2>\n<p>Python 有多种版本的解释器：</p>\n<p><strong>CPython</strong>：官方版本的解释器。这个解释器是用 C 语言开发的，所以叫 CPython。CPython 是使用最广的 Python 解释器。如果没有特殊情况，我们通常下载和使用的默认都是这个解释器。\n<strong>Ipython</strong>：基于 CPython 之上的一个交互式解释器，在交互方式上有所增强，执行 Python 代码的功能和 CPython 是完全一样的。CPython 用 <code>&gt;&gt;&gt;</code> 作为提示符，而 IPython 用 <code>In [序号]:</code> 作为提示符。\n<strong>PyPy</strong>：一个追求执行速度的 Python 解释器。采用 JIT 技术，对 Python 代码进行动态编译（注意，不是解释），可以显著提高 Python 代码的执行速度。绝大部分 CPython 代码都可以在 PyPy 下运行，但还是有一些不同的，这就导致相同的 Python 代码在两种解释器下执行可能会有不同的结果。\n<strong>Jython</strong>：运行在 Java 平台上的 Python 解释器，可以直接把 Python 代码编译成 Java 字节码执行。\n<strong>IronPython</strong>：和 Jython 类似，只不过 IronPython 是运行在微软 .Net 平台上的 Python 解释器，可以直接把 Python 代码编译成 .Net 的字节码。</p>\n<h2 id=\"pyc文件\"> pyc文件</h2>\n<p>鉴于解释器的缺点是慢，Python 也是有办法提高一下运行速度的，那就是使用 pyc 文件。这点参考了 JAVA 的字节码做法，但并不完全类同。</p>\n<p>我们编写的代码一般都会保存在以 <code>.py</code> 为后缀的文件中。在执行程序时，解释器逐行读取源代码并逐行解释运行。每执行一次，就重复一次这个过程，这其中耗费了大量的重复性的解释工作。为了减少这一重复性的解释工作，Python 引入了 pyc 文件，pyc 文件是将 py 文件的解释结果保存下来的文件，这样，下次再运行的时候就不用再解释了，直接使用 pyc 文件就可以了，这无疑大大提高了程序运行速度。</p>\n<p>对于 pyc 文件，你必须知道以下几点：</p>\n<ul>\n<li>对于当前调用的主程序不会生成 pyc 文件。</li>\n<li>以 <code>import xxx</code> 或 <code>from xxx import xxx</code> 等方式导入主程序的模块才会生成 pyc 文件。</li>\n<li>每次使用 pyc 文件时，都会根据 pyc 文件的创建时间和源模块进行对比，如果源模块有修改，则重新创建 pyc 文件，并覆盖先前的 pyc 文件，如果没有修改，直接使用 pyc 文件代替模块。</li>\n<li>pyc 文件统一保存在模块所在目录的 <code>__pycache__</code> 文件夹内。</li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2021-11-19T03:27:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "数据类型",
      "url": "https://www.fedbook.cn/backend-knowledge/python/data-types/",
      "id": "https://www.fedbook.cn/backend-knowledge/python/data-types/",
      "content_html": "<h1 id=\"数据类型\"> 数据类型</h1>\n<p>在 Python 中，数据类型分内置的和自定义的。内置的共有 8 种常用的以及一些不太常用的数据类型；而自定义的一般以类的形式，根据需要组合内置类型成为独特的数据类型。</p>\n<p>8 种常用内置数据类型：</p>\n<ul>\n<li>数字</li>\n<li>布尔</li>\n<li>列表</li>\n<li>元组</li>\n<li>字符串</li>\n<li>字典</li>\n<li>bytes</li>\n<li>集合set</li>\n</ul>\n<h2 id=\"数字\"> 数字</h2>\n<p>Python 支持三种不同的数字类型，整数、浮点数和复数：</p>\n<h3 id=\"整数-int\"> 整数（Int）</h3>\n<p>通常被称为整型，是正或负整数，不带小数点。Python3 的整型可以当作 Long 类型（更长的整型）使用，所以 Python3 没有 Python2 的 Long 类型。</p>\n<ul>\n<li>十进制表示法：1，100，-8080，0</li>\n<li>十六进制表示法：用 <code>0x</code> 前缀和 <code>0-9</code>，<code>a-f</code> 表示，例如：0xff00，0xa5b4c3d2</li>\n<li>八进制表示法：用 <code>0o</code> 前缀和 <code>0-7</code> 表示，例如：0o12</li>\n</ul>\n<p>Python 的整数长度为 32 位，可以通过内置函数获取最大值和最小值：</p>\n<div><pre><code><span>import</span> sys\n\n<span># 最大值</span>\nmax_num <span>=</span> sys<span>.</span>maxsize\n<span>print</span><span>(</span>max_num<span>)</span> <span># 结果为 9223372036854775807</span>\n\n<span># 最小值</span>\nmin_num <span>=</span> <span>-</span>sys<span>.</span>maxsize <span>-</span> <span>1</span>\n<span>print</span><span>(</span>min_num<span>)</span> <span># 结果为 -9223372036854775808</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"浮点数-float\"> 浮点数（float）</h3>\n<p>浮点数也就是小数，如 1.23，3.14，-9.01 等等。</p>\n<p>但是对于很大或很小的浮点数，一般用科学计数法表示，把 10 用 e 替代，1.23x10^9 就是 1.23e9，或者 12.3e8，0.000012 可以写成 1.2e-5 等等。</p>\n<h3 id=\"复数-complex\"> 复数（complex）</h3>\n<p>复数由实数部分和虚数部分构成，可以用 <code>a + bj</code>，或者 <code>complex(a, b)</code> 表示。复数的实部 a 和虚部 b 都是浮点型。关于复数，如果不做科学计算或其它特殊需要通常很难遇到。</p>\n<h2 id=\"布尔\"> 布尔</h2>\n<p>但在 Python 语言中，布尔类型只有两个值：<code>True</code> 与 <code>False</code>。注意首字母要大写。</p>\n<h2 id=\"列表-list\"> 列表（List）</h2>\n<p>列表是 Python 中最基本也是最常用的数据结构之一。列表中的每个元素都被分配一个数字作为索引，用来表示该元素在列表内所排在的位置。第一个元素的索引是 0，第二个索引是 1，依此类推。</p>\n<p>Python 的列表是一个有序可重复的元素集合，可嵌套、迭代、修改、分片、追加、删除，成员判断。</p>\n<p>从数据结构角度看，Python 的列表是一个可变长度的顺序存储结构，每一个位置存放的都是对象的指针。</p>\n<h3 id=\"插入列表元素\"> 插入列表元素</h3>\n<p>使用 append()，insert() 方法插入指定的元素。</p>\n<p>如果待插入的元素是列表、元组等，这种插入方式会将它们视为一个整体，作为一个元素添加进去。</p>\n<div><pre><code><span># 列表的末尾追加元素</span>\nlis <span>=</span> <span>[</span><span>\"element_1\"</span><span>,</span> <span>\"element_2\"</span><span>,</span> <span>\"element_3\"</span><span>]</span>\nlis<span>.</span>append<span>(</span><span>\"element_4\"</span><span>)</span>\n\n<span># 在列表中间某个位置插入元素</span>\n<span># 下面代码将在索引 2 处插入元素</span>\nlis <span>=</span> <span>[</span><span>\"element_1\"</span><span>,</span> <span>\"element_2\"</span><span>,</span> <span>\"element_3\"</span><span>]</span>\nlis<span>.</span>insert<span>(</span><span>1</span><span>,</span> <span>'element'</span><span>)</span>\n<span>print</span><span>(</span>lis<span>)</span> <span># [\"element_1\", \"element\", \"element_2\", \"element_3\"]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"删除列表元素\"> 删除列表元素</h3>\n<p>使用 del 语句或者 remove()，pop() 方法删除指定的元素。</p>\n<div><pre><code><span># 删除索引为 0 的元素</span>\nlis <span>=</span> <span>[</span><span>\"element_1\"</span><span>,</span> <span>\"element_2\"</span><span>,</span> <span>\"element_3\"</span><span>]</span>\n<span>del</span> lis<span>[</span><span>0</span><span>]</span>\n\n<span># 除列表中匹配到的第一个 b 元素</span>\nlis <span>=</span> <span>[</span><span>\"element_1\"</span><span>,</span> <span>\"element_2\"</span><span>,</span> <span>\"element_3\"</span><span>,</span> <span>\"element_1\"</span><span>]</span>\nlis<span>.</span>remove<span>(</span><span>\"element_1\"</span><span>)</span>\n\n<span># 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。</span>\n<span># 可选参数，要移除列表元素的索引值，不能超过列表总长度，默认为 index=-1，即删除最后一个列表值。</span>\nlis <span>=</span> <span>[</span><span>\"element_1\"</span><span>,</span> <span>\"element_2\"</span><span>,</span> <span>\"element_3\"</span><span>,</span> <span>\"element_1\"</span><span>]</span>\na<span>=</span> lis<span>.</span>pop<span>(</span><span>)</span>\nb <span>=</span> lis<span>.</span>pop<span>(</span><span>1</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id=\"列表与列表合并\"> 列表与列表合并</h3>\n<p>使用 <code>+</code> 运算符或者 extend() 方法合并两个列表。</p>\n<div><pre><code><span># 使用 + 运算符</span>\n<span># 该方法会生成一个新的列表，原有的列表不会被改变。</span>\nlis_1 <span>=</span> <span>[</span><span>\"element_1\"</span><span>,</span> <span>\"element_2\"</span><span>]</span>\nlis_2 <span>=</span> <span>[</span><span>\"element_3\"</span><span>,</span> <span>\"element_4\"</span><span>]</span>\n<span>print</span><span>(</span>lis_1 <span>+</span> lis_2<span>)</span> <span># ['element_1', 'element_2', 'element_3', 'element_4']</span>\n\n<span># 使用 extend() </span>\n<span># 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</span>\n<span># 该方法没有返回值，但会在已存在的列表中添加新的列表内容。</span>\nlis_1 <span>=</span> <span>[</span><span>\"element_1\"</span><span>,</span> <span>\"element_2\"</span><span>]</span>\nlis_2 <span>=</span> <span>[</span><span>\"element_3\"</span><span>,</span> <span>\"element_4\"</span><span>]</span>\nlis_1<span>.</span>extend<span>(</span>lis_2<span>)</span>\n<span>print</span><span>(</span>lis_1<span>)</span> <span># ['element_1', 'element_2', 'element_3', 'element_4']</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id=\"切片\"> 切片</h3>\n<p>切片指的是对序列进行截取，选取序列中的某一段。</p>\n<p>切片的语法是：<code>list[start:end]</code>，以冒号分割索引，start 代表起点索引，end 代表结束点索引。省略 start 表示以 0 开始，省略 end 表示到列表的结尾。</p>\n<p>注意，<strong>区间是左闭右开的</strong>！</p>\n<p>分片不会修改原有的列表，可以将结果保存到新的变量，因此切片也是一种安全操作，常被用来复制一个列表，例如 <code>newlist = lis[:]</code>。</p>\n<p>如果提供的是负整数下标，则从列表的最后开始往头部查找。例如 -1 表示最后一个元素，-3 表示倒数第三个元素。</p>\n<p>切片过程中还可以设置步长，以第二个冒号分割，例如 <code>list[3:9:2]</code>，表示每隔多少距离取一个元素：</p>\n<div><pre><code><span># 切片设置步长</span>\nlis <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>,</span> <span>10</span><span>]</span>\n<span>print</span><span>(</span>lis<span>[</span><span>2</span><span>:</span><span>8</span><span>:</span><span>2</span><span>]</span><span>)</span> <span># [3, 5, 7]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"元组-tuple\"> 元组（Tuple）</h2>\n<p>用方括号括起来的是列表，而用圆括号括起来的是元组，形如：</p>\n<div><pre><code>tup <span>=</span> <span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>元组也是序列结构，但是是一种不可变序列，你可以简单的理解为内容不可变的列表。除了在内部元素不可修改的区别外，元组和列表的用法差不多。</p>\n<p><strong>元组与列表相同的操作</strong>：</p>\n<ul>\n<li>使用方括号加下标访问元素</li>\n<li>切片（形成新元组对象）</li>\n<li><code>count()</code> / <code>index()</code></li>\n<li><code>len()</code> / <code>max()</code> / <code>min()</code> / <code>tuple()</code></li>\n</ul>\n<p><strong>元组中不允许的操作，确切的说是元组没有的功能</strong>：</p>\n<ul>\n<li>修改、新增元素</li>\n<li>删除某个元素（但可以删除整个元组）</li>\n<li>所有会对元组内部元素发生修改动作的方法。例如，元组没有 remove，append，pop 等方法。</li>\n</ul>\n<p>但需要注意：元组只保证它的一级子元素不可变，对于嵌套的元素内部，不保证不可变。所以，在使用元组的时候，尽量使用数字、字符串和元组这种不可变的数据类型作为元组的元素，这样就能确保元组不发生变化。</p>\n<p><strong>元组和列表之间的转换：</strong></p>\n<ul>\n<li>使用 list() 函数可以把元组转换成列表：<code>list(元组)</code></li>\n<li>使用 tuple() 函数可以把列表转换成元组：<code>tuple(列表)</code></li>\n</ul>\n<h2 id=\"字符串\"> 字符串</h2>\n<p>字符串是 Python 中最常用的数据类型之一，使用单引号或双引号来创建字符串，使用三引号创建多行字符串。</p>\n<p>Python3 全面支持 Unicode 编码，所有的字符串都是 Unicode 字符串，所以传统 Python2 存在的编码问题不再困扰我们，可以放心大胆的使用中文。</p>\n<h3 id=\"字符编码\"> 字符编码</h3>\n<p>计算机只能处理数字 0 和 1，如果要处理文本，就必须先把文本转换为数字 01，这种转换方式就称为字符编码。</p>\n<p>对于我们而言，你只需要简单记住下面几种常见的编码就好：</p>\n<ul>\n<li><strong>ASCII 编码</strong>：早期专门为英语语系编码，只有 255 个字符，每个字符需要 8 位也就是 1 个字节。不兼容汉字。</li>\n<li><strong>Unicode 编码</strong>：又称万国码，国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。用 2 个字节来表示汉字。</li>\n<li><strong>UTF-8 编码</strong>：为了节省字节数，在 Unicode 的基础上进行优化的编码。用 1 个字节表示英文字符，3 个字符表示汉字。天生兼容 ASCII 编码，所以最为流行。</li>\n<li><strong>GB2312</strong>：我国早期自己制定的中文编码，世界范围内不通用。</li>\n<li><strong>GBK</strong>：全称《汉字内码扩展规范》，向下与 GB2312 兼容，向上支持 ISO10646.1 国际标准，是前者向后者过渡过程中的一个承上启下的产物。Windows 中文版的汉字编码用的就是 GBK。也非世界范围通用的编码。</li>\n<li>其它编码：非以上类型者的统称。属于能不用就不要碰的编码。</li>\n</ul>\n<p>需要再强调一次，<strong>Python3 在运行时全部使用 Unicode 编码!</strong></p>\n<p>另外还有几条规则需要记住：</p>\n<ul>\n<li>操作系统运行时，在内存中，统一使用的都是 Unicode 编码，当需要将数据保存到硬盘或者网络传输的时候，就转换为 UTF-8 编码，进行保存和传输。</li>\n<li>用文本编辑器的时候，从文件系统或者说硬盘上读取的 UTF-8 编码字符被转换为 Unicode 字符到内存里，供程序或者操作系统使用。编辑完成后，保存的时候再把 Unicode 转换为 UTF-8 保存到文件。</li>\n<li>浏览网页的时候，服务器会把动态生成的 Unicode 内容转换为 UTF-8 传输到客户的浏览器。</li>\n</ul>\n<p>这就是为什么我们平时一会说 Unicode，一会又用 UTF-8 的原因。</p>\n<p>总而言之，一定要区分代码自己本身的编码和程序要处理的数据的编码！没有特殊要求的情况，请使用 UTF-8 编码。确保文本编辑器使用的是 <code>UTF-8 without BOM</code> 编码。</p>\n<h2 id=\"字典\"> 字典</h2>\n<p>Python的 字典数据类型是基于 hash 散列算法实现的，采用键值对 (key: value) 的形式，根据 key 的值计算 value 的地址，具有非常快的查取和插入速度。</p>\n<p>字典包含的元素个数不限，值的类型可以是任何数据类型。但是字典的 key 必须是不可变的对象，例如整数、字符串、bytes 和元组，最常见的还是将字符串作为 key。同时，同一个字典内的key必须是唯一的，但值则不必。</p>\n<p><strong>注意：从 Python3.6 开始，字典是有序的！它将保持元素插入时的先后顺序！请务必清楚！</strong></p>\n<h3 id=\"创建字典\"> 创建字典</h3>\n<p>创建字典有两种方法：</p>\n<div><pre><code>dic <span>=</span> <span>{</span><span>'name'</span><span>:</span> <span>'zhangsan'</span><span>,</span> <span>'age'</span><span>:</span> <span>13</span><span>}</span>\n\n<span>dict</span><span>(</span>\n    name<span>=</span><span>'lisi'</span><span>,</span>\n    age<span>=</span><span>14</span>\n<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"访问字典\"> 访问字典</h3>\n<p>可以通过方括号获取对应值，但是如果访问字典里没有的键，会抛出异常：</p>\n<div><pre><code>dic <span>=</span> <span>{</span><span>'name'</span><span>:</span> <span>'zhangsan'</span><span>,</span> <span>'age'</span><span>:</span> <span>13</span><span>}</span>\n\nname <span>=</span> dic<span>[</span><span>'name'</span><span>]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>也可以通过字典的 get() 方法返回指定键的值，如果键不在字典中，则返回 default 值，如果不指定默认值，则返回 <code>None</code>：</p>\n<div><pre><code>dic <span>=</span> <span>{</span><span>'name'</span><span>:</span> <span>'zhangsan'</span><span>,</span> <span>'age'</span><span>:</span> <span>13</span><span>}</span>\n\nname <span>=</span> dic<span>.</span>get<span>(</span><span>'name'</span><span>,</span> <span>'xxx'</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"删除字典元素、清空字典和删除字典\"> 删除字典元素、清空字典和删除字典</h3>\n<p>使用 del 关键字删除字典元素或者字典本身，使用字典的 clear() 方法清空字典。</p>\n<div><pre><code><span># 删除指定的键</span>\ndic <span>=</span> <span>{</span><span>'name'</span><span>:</span> <span>'zhangsan'</span><span>,</span> <span>'age'</span><span>:</span> <span>13</span><span>}</span>\n<span>del</span> dic<span>[</span><span>'name'</span><span>]</span> \n\n<span># 删除指定的键，并返回该键对应的值、</span>\ndic <span>=</span> <span>{</span><span>'name'</span><span>:</span> <span>'zhangsan'</span><span>,</span> <span>'age'</span><span>:</span> <span>13</span><span>}</span>\na <span>=</span> dic<span>.</span>pop<span>(</span><span>'age'</span><span>)</span>\n\n<span># 清空字典</span>\ndic <span>=</span> <span>{</span><span>'name'</span><span>:</span> <span>'zhangsan'</span><span>,</span> <span>'age'</span><span>:</span> <span>13</span><span>}</span>\ndic<span>.</span>clear<span>(</span><span>)</span>\n\n<span># 删除字典本身，删除后该字典就不存在了</span>\ndic <span>=</span> <span>{</span><span>'name'</span><span>:</span> <span>'zhangsan'</span><span>,</span> <span>'age'</span><span>:</span> <span>13</span><span>}</span>\n<span>del</span> dic\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id=\"遍历字典\"> 遍历字典</h3>\n<p>从 Python3.6 开始遍历字典获得的键值对是有序的。</p>\n<p>以下展示的多种遍历方法，都是经常会用到的：</p>\n<div><pre><code>dic <span>=</span> <span>{</span><span>'name'</span><span>:</span> <span>'zhangsan'</span><span>,</span> <span>'age'</span><span>:</span> <span>13</span><span>}</span>\n\n<span># 直接遍历字典获取键，根据键取值</span>\n<span>for</span> key <span>in</span> dic<span>:</span>\n    <span>print</span><span>(</span>key<span>,</span> dic<span>[</span>key<span>]</span><span>)</span>\n\n<span># 利用 items 方法获取键值，速度很慢，少用！</span>\n<span>for</span> key<span>,</span>value <span>in</span> dic<span>.</span>items<span>(</span><span>)</span><span>:</span>\n    <span>print</span><span>(</span>key<span>,</span> value<span>)</span>\n\n<span># 利用 keys 方法获取键</span>\n<span>for</span> key <span>in</span> dic<span>.</span>keys<span>(</span><span>)</span><span>:</span>\n    <span>print</span><span>(</span>key<span>,</span> dic<span>[</span>key<span>]</span><span>)</span>\n\n<span># 利用 values 方法获取值，但无法获取对应的键。</span>\n<span>for</span> value <span>in</span> dic<span>.</span>values<span>(</span><span>)</span><span>:</span>\n    <span>print</span><span>(</span>value<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>此外，如果只是要统计字典内键的个数，可以使用 Python 内置的 len() 函数：</p>\n<div><pre><code>dic <span>=</span> <span>{</span><span>'name'</span><span>:</span> <span>'zhangsan'</span><span>,</span> <span>'age'</span><span>:</span> <span>13</span><span>}</span>\n<span>len</span><span>(</span>dic<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"bytes\"> bytes</h2>\n<p>在 Python3 以后，字符串和 bytes 类型彻底分开了。字符串是以字符为单位进行处理的，bytes 类型是以字节为单位处理的。</p>\n<p>对于 bytes，我们只要知道在 Python3 中某些场合下强制使用，以及它和字符串类型之间的互相转换，其它的基本照抄字符串。</p>\n<p>简单的省事模式：</p>\n<p><code>string = b'xxxxxx'.decode()</code> 直接以默认的 utf-8 编码解码 bytes 成 string。</p>\n<p><code>b = string.encode()</code> 直接以默认的 utf-8 编码 string 为 bytes。</p>\n<h2 id=\"集合set\"> 集合set</h2>\n<p>set 集合是一个无序不重复元素的集，基本功能包括关系测试和消除重复元素。集合使用大括号（<code>{}</code>）框定元素，并以逗号进行分隔。</p>\n<p>但是注意：如果要创建一个空集合，必须用 <code>set()</code> 而不是 <code>{}</code> ，因为后者创建的是一个空字典。</p>\n<p>集合数据类型的核心在于<strong>自动去重</strong>。很多时候，这能给你省不少事。</p>\n<div><pre><code>s <span>=</span> <span>set</span><span>(</span><span>[</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>]</span><span>)</span>\n<span>print</span><span>(</span>s<span>)</span> <span># {1, 2, 3, 4}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>（完）</p>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2021-11-19T03:27:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "函数装饰器",
      "url": "https://www.fedbook.cn/backend-knowledge/python/function-decorators/",
      "id": "https://www.fedbook.cn/backend-knowledge/python/function-decorators/",
      "content_html": "<h1 id=\"函数装饰器\"> 函数装饰器</h1>\n<p>函数装饰器（Function Decorators）：从字面上理解，就是装饰一个函数。可以在不修改原代码的情况下，为被装饰的函数添加一些功能并返回它。</p>\n<p>函数装饰器的语法是将 <code>@装饰器名</code> 放在被装饰函数上面，下面是个例子：</p>\n<div><pre><code><span>@dec</span>\n<span>def</span> <span>func</span><span>(</span><span>)</span><span>:</span>\n    <span>pass</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"前置概念\"> 前置概念</h2>\n<p>首先需要明确以下几个概念和原则，才能更好的理解装饰器：</p>\n<ul>\n<li>Python 程序是从上往下顺序执行的，碰到函数的定义代码块不会立即执行，只有等到该函数被调用时，才会执行其内部的代码块。</li>\n<li>Python 中函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数。</li>\n<li>可以将一个函数作为参数传递给另一个函数。</li>\n</ul>\n<p>有了这些基本的概念，我们就可以通过一个实例来讲解 Python 中函数装饰器的用法了。</p>\n<h2 id=\"模拟场景\"> 模拟场景</h2>\n<p>模拟一个场景，假设在某项目中，有下列五个接口（f1~f5）：</p>\n<div><pre><code><span>def</span> <span>f1</span><span>(</span><span>)</span><span>:</span>\n    <span>print</span><span>(</span><span>\"第一个接口......\"</span><span>)</span>\n<span>def</span> <span>f2</span><span>(</span><span>)</span><span>:</span>\n    <span>print</span><span>(</span><span>\"第二个接口......\"</span><span>)</span>\n<span>def</span> <span>f3</span><span>(</span><span>)</span><span>:</span>\n    <span>print</span><span>(</span><span>\"第三个接口......\"</span><span>)</span>\n<span>def</span> <span>f4</span><span>(</span><span>)</span><span>:</span>\n    <span>print</span><span>(</span><span>\"第四个接口......\"</span><span>)</span>\n<span>def</span> <span>f5</span><span>(</span><span>)</span><span>:</span>\n    <span>print</span><span>(</span><span>\"第五个接口......\"</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>现在有个需求，每个接口执行完后需要记录日志。如果逐次修改这五个接口的内部代码显然是一种比较糟糕的方案，我们可以使用装饰器完成这一任务。代码如下：</p>\n<div><pre><code><span>def</span> <span>outer</span><span>(</span>func<span>)</span><span>:</span>\n    <span>def</span> <span>inner</span><span>(</span><span>)</span><span>:</span>\n        result <span>=</span> func<span>(</span><span>)</span>\n        <span>print</span><span>(</span><span>\"日志添加成功\"</span><span>)</span>\n        <span>return</span> result\n    <span>return</span> inner\n\n<span>@outer</span>\n<span>def</span> <span>f1</span><span>(</span><span>)</span><span>:</span>\n    <span>print</span><span>(</span><span>\"第一个接口......\"</span><span>)</span>\n\n<span>@outer</span>\n<span>def</span> <span>f2</span><span>(</span><span>)</span><span>:</span>\n    <span>print</span><span>(</span><span>\"第二个接口......\"</span><span>)</span>\n\n<span>@outer</span>\n<span>def</span> <span>f3</span><span>(</span><span>)</span><span>:</span>\n    <span>print</span><span>(</span><span>\"第三个接口......\"</span><span>)</span>\n\n<span>@outer</span>\n<span>def</span> <span>f4</span><span>(</span><span>)</span><span>:</span>\n    <span>print</span><span>(</span><span>\"第四个接口......\"</span><span>)</span>\n\n<span>@outer</span>\n<span>def</span> <span>f5</span><span>(</span><span>)</span><span>:</span>\n    <span>print</span><span>(</span><span>\"第五个接口......\"</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>使用装饰器 <code>@outer</code>，仅需对原接口代码进行拓展，就可以实现操作结束后保存日志，并且无需对原接口代码做任何修改，调用方式也不用变。</p>\n<h2 id=\"实现原理\"> 实现原理</h2>\n<p>下面以 <code>f1</code> 函数为例，对函数装饰器的实现原理进行分析：</p>\n<div><pre><code><span>def</span> <span>outer</span><span>(</span>func<span>)</span><span>:</span>\n    <span>def</span> <span>inner</span><span>(</span><span>)</span><span>:</span>\n        result <span>=</span> func<span>(</span><span>)</span>\n        <span>print</span><span>(</span><span>\"日志添加成功\"</span><span>)</span>\n        <span>return</span> result\n    <span>return</span> inner\n\n<span>@outer</span>\n<span>def</span> <span>f1</span><span>(</span><span>)</span><span>:</span>\n    <span>print</span><span>(</span><span>\"第一个接口......\"</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ul>\n<li>\n<p>Step1：程序开始运行，解释器从上往下逐行解释并运行代码，读到 <code>def outer(func):</code> 的时候，把函数体加载到内存里，然后过。</p>\n</li>\n<li>\n<p>Step2：读到 <code>@outer</code> 的时候，程序发现这是个装饰器，按规则要<strong>立即执行它</strong>，于是程序开始运行 <code>@</code> 后面那个名为 <code>outer</code> 的函数。（<code>@outer</code> 相当于 <code>outer(f1)</code>）</p>\n</li>\n<li>\n<p>Step3：程序正式进入到 <code>outer</code> 函数，开始执行装饰器的语法规则。规则是：</p>\n<ul>\n<li>被装饰的函数（整个函数体）会被当作参数传递给装饰函数。</li>\n<li><strong>装饰函数执行它自己内部的代码后，会将它的返回值赋值给被装饰的函数</strong>。</li>\n<li>此处：原来的 <code>f1</code> 函数被当做参数（<code>func</code>）传递给了 <code>outer</code>，而 <code>f1</code> 这个函数名之后会指向 <code>inner</code> 函数。</li>\n</ul>\n</li>\n</ul>\n<div style=\"text-align: center;\">\n  <svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"561\" height=\"331\" viewBox=\"0 0 561 331\">\n    <image id=\"装饰前后_f1_指向\" data-name=\"装饰前后_f1_指向\" width=\"561\" height=\"331\" xlink:href=\"data:img/png;base64,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\"/>\n  </svg>\n  <p style=\"text-align:center; color: #888;\">（装饰前后函数名 f1 指向）</p>\n</div>\n<ul>\n<li>\n<p>Step4：程序开始执行 <code>outer</code> 函数内部的内容，一开始它又碰到了一个函数 <code>inner</code>，<code>inner</code> 函数定义块被程序观察到后不会立刻执行，而是读入内存中（这是默认规则）。</p>\n</li>\n<li>\n<p>Step5：再往下，碰到 <code>return inner</code>，返回值是个函数名，并且这个函数名会被赋值给 <code>f1</code> 这个被装饰的函数，也就是 <code>f1 = inner</code>。<strong>换句话说：此时 <code>f1</code> 函数被新的函数 <code>inner</code> 覆盖了</strong>。</p>\n</li>\n<li>\n<p>Step6：接下来，当调用方依然通过 <code>f1()</code> 的方式调用 <code>f1</code> 函数时，执行的就不再是旧的 <code>f1</code> 函数的代码，而是 <code>inner</code> 函数的代码。</p>\n<ul>\n<li>在本例中，它会先执行 <code>func</code> 函数并将返回值赋值给变量 <code>result</code>，这个 <code>func</code> 函数就是旧的 <code>f1</code> 函数；接着，它会打印日志保存，这只是个示例，可以换成任何你想要的；最后返回 <code>result</code> 这个变量给调用方。</li>\n</ul>\n</li>\n<li>\n<p>Step7：最后，调用方可以和以前一样通过 <code>res = f1()</code> 的方式接受 <code>result</code> 的值。</p>\n</li>\n</ul>\n<h2 id=\"为什么要两层函数\"> 为什么要两层函数</h2>\n<p>这里可能会有疑问，为什么我们要搞一个 <code>outer</code> 函数一个 <code>inner</code> 函数这么复杂呢？一层函数不行吗？</p>\n<p>答：因为 <code>@outer</code> 这句代码在程序执行到这里的时候就会自动执行 <code>outer</code> 函数内部的代码，如果不封装一下，在调用方还未进行调用的时候，就执行了，这和初衷不符。当然，如果你对这个有需求也不是不行。</p>\n<p>请看下面的例子，它只有一层函数：</p>\n<div><pre><code><span>def</span> <span>outer</span><span>(</span>func<span>)</span><span>:</span>\n    result <span>=</span> func<span>(</span><span>)</span>\n    <span>print</span><span>(</span><span>\"日志添加成功\"</span><span>)</span>\n    <span>return</span> result\n\n<span>@outer</span>\n<span>def</span> <span>f1</span><span>(</span><span>)</span><span>:</span>\n    <span>print</span><span>(</span><span>\"第一个接口......\"</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>尝试敲一下上述代码，可以发现我们只是定义好了装饰器，还没有调用 <code>f1</code> 函数呢，程序就把工作全做了。这就是为什么要封装一层函数的原因。</p>\n<h2 id=\"函数参数传递\"> 函数参数传递</h2>\n<p>上面的例子中，<code>f1</code> 函数没有参数，在实际情况中肯定会需要参数的，函数的参数怎么传递的呢？看下面一个例子：</p>\n<div><pre><code><span>def</span> <span>outer</span><span>(</span>func<span>)</span><span>:</span>\n    <span>def</span> <span>inner</span><span>(</span>username<span>)</span><span>:</span>\n        result <span>=</span> func<span>(</span>username<span>)</span>\n        <span>print</span><span>(</span><span>\"日志添加成功\"</span><span>)</span>\n        <span>return</span> result\n    <span>return</span> inner\n\n<span>@outer</span>\n<span>def</span> <span>f1</span><span>(</span>name<span>)</span><span>:</span>\n    <span>print</span><span>(</span><span>\"{0}正在连接第一个接口......\"</span><span>.</span><span>format</span><span>(</span>name<span>)</span><span>)</span>\n\n<span># 调用方法</span>\nf1<span>(</span><span>\"zhangsan\"</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>在 <code>inner</code> 函数的定义部分也加上一个参数，调用 <code>func</code> 函数（即装饰后的 <code>f1</code> 函数）时传递这个参数就可以了。、</p>\n<p>可问题又来了，如果 <code>f2</code> 函数有 2 个参数，<code>f3</code> 函数有 3 个参数，该怎么传递？通过万能参数 <code>*args</code> 和 <code>**kwargs</code> 就可以了。简单修改一下上面的代码：</p>\n<div><pre><code><span>def</span> <span>outer</span><span>(</span>func<span>)</span><span>:</span>\n    <span>def</span> <span>inner</span><span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span>\n        result <span>=</span> func<span>(</span><span>*</span>args<span>,</span><span>**</span>kwargs<span>)</span>\n        <span>print</span><span>(</span><span>\"日志添加成功\"</span><span>)</span>\n        <span>return</span> result\n    <span>return</span> inner\n\n<span>@outer</span>\n<span>def</span> <span>f2</span><span>(</span>name<span>,</span> age<span>)</span><span>:</span>\n    <span>print</span><span>(</span><span>\"{0}正在连接第二个接口......\"</span><span>.</span><span>format</span><span>(</span>name<span>)</span><span>)</span>\n\n<span># 调用方法</span>\nf2<span>(</span><span>\"lisi\"</span><span>,</span> <span>14</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id=\"多层装饰器\"> 多层装饰器</h2>\n<p>上面已经介绍了函数装饰器的基本概念和用法，接下来再进一步，一个函数可以被多个函数装饰吗？答案是可以的。看下面的例子：</p>\n<div><pre><code><span>def</span> <span>outer1</span><span>(</span>func<span>)</span><span>:</span>\n    <span>def</span> <span>inner</span><span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span>\n        <span>print</span><span>(</span><span>\"身份认证成功\"</span><span>)</span>\n        result <span>=</span> func<span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span>\n        <span>print</span><span>(</span><span>\"日志添加成功\"</span><span>)</span>\n        <span>return</span> result\n    <span>return</span> inner\n\n<span>def</span> <span>outer2</span><span>(</span>func<span>)</span><span>:</span>\n    <span>def</span> <span>inner</span><span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span>\n        <span>print</span><span>(</span><span>\"代码开始执行\"</span><span>)</span>\n        result <span>=</span> func<span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span>\n        <span>print</span><span>(</span><span>\"代码执行完毕\"</span><span>)</span>\n        <span>return</span> result\n    <span>return</span> inner\n\n<span>@outer1</span>\n<span>@outer2</span>\n<span>def</span> <span>f1</span><span>(</span>name<span>,</span> age<span>)</span><span>:</span>\n    <span>print</span><span>(</span><span>\"{0}正在连接第一个接口......\"</span><span>.</span><span>format</span><span>(</span>name<span>)</span><span>)</span>\n\n<span># 调用方法</span>\nf1<span>(</span><span>\"zhangsan\"</span><span>,</span> <span>13</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>怎么分析多装饰器情况下的代码运行顺序呢？可以将它理解成洋葱模型：每个装饰器一层层包裹住最内部核心的原始函数，执行的时候逐层穿透进入最核心内部，执行内部核心函数后，再反向逐层穿回来。</p>\n<p>所以，最后的运行结果就显而易见了：</p>\n<div><pre><code>身份认证成功\n代码开始执行\nzhangsan正在连接第一个接口<span>..</span><span>..</span><span>..</span>\n代码执行完毕\n日志添加成功\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"装饰器携带参数\"> 装饰器携带参数</h2>\n<p>装饰器自己可以有参数吗？答案也是可以的。看下面的例子：</p>\n<div><pre><code><span>def</span> <span>say_hello</span><span>(</span>country<span>)</span><span>:</span>\n    <span>def</span> <span>wrapper</span><span>(</span>func<span>)</span><span>:</span>\n        <span>def</span> <span>deco</span><span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span>\n            <span>if</span> country <span>==</span> <span>\"China\"</span><span>:</span>\n                <span>print</span><span>(</span><span>\"你好\"</span><span>)</span>\n            <span>elif</span> country <span>==</span> <span>\"America\"</span><span>:</span>\n                <span>print</span><span>(</span><span>\"Hello\"</span><span>)</span>\n            <span>else</span><span>:</span>\n                <span>return</span>\n            func<span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span>\n        <span>return</span> deco\n    <span>return</span> wrapper\n\n<span>@say_hello</span><span>(</span><span>\"China\"</span><span>)</span>\n<span>def</span> <span>f1</span><span>(</span><span>)</span><span>:</span>\n    <span>print</span><span>(</span><span>\"我来自中国\"</span><span>)</span>\n\n<span>@say_hello</span><span>(</span><span>\"America\"</span><span>)</span>\n<span>def</span> <span>f2</span><span>(</span><span>)</span><span>:</span>\n    <span>print</span><span>(</span><span>'I am from America'</span><span>)</span>\n\nf1<span>(</span><span>)</span>\nf2<span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>运行结果：</p>\n<div><pre><code>你好\n我来自中国\nHello\nI am from America\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"总结\"> 总结</h2>\n<p>装饰器体现的是设计模式中的装饰模式，实际上，在 Python 中装饰器可以用函数实现，也可以用类实现。我在实际开发中函数装饰器用的比较多，所以本文主要介绍的是函数装饰器。</p>\n<p>而如果要对装饰器的用法作更加深入的学习，官方文档和框架源码是比较好的学习对象。</p>\n<p>（完）</p>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2021-11-19T03:27:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "面向对象编程",
      "url": "https://www.fedbook.cn/backend-knowledge/python/oop/",
      "id": "https://www.fedbook.cn/backend-knowledge/python/oop/",
      "content_html": "<h1 id=\"面向对象编程\"> 面向对象编程</h1>\n<p>面向对象编程：Object Oriented Programming，简称 OOP，是一种程序设计方法。与它相对的，是面向过程编程。</p>\n<p>下面分别用简单的例子描述两者的区别。</p>\n<h2 id=\"面向过程编程\"> 面向过程编程</h2>\n<p>面向过程编程的大体流程如下：</p>\n<div><pre><code><span>1</span>. 导入各种外部库\n<span>2</span>. 设计各种全局变量\n<span>3</span>. 写一个函数完成某个功能\n<span>4</span>. 写一个函数完成某个功能\n<span>5</span>. 写一个函数完成某个功能\n<span>6</span>. 写一个函数完成某个功能\n<span>7</span>. 写一个函数完成某个功能\n<span>8</span>. <span>..</span><span>..</span><span>..</span>\n<span>9</span>. 写一个main函数作为程序入口\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>这种结构中函数是核心，函数调用是关键，一切围绕函数展开。</p>\n<p>假如现在要实现一个需求，根据对象的生物种类，发出不同的叫声，比如有狗、猫和牛。</p>\n<p>用函数进行面向过程编程，一般是下面的样子：</p>\n<div><pre><code><span>def</span> <span>speak</span><span>(</span>animal<span>)</span><span>:</span>\n    <span>if</span> animal <span>==</span> <span>\"狗\"</span><span>:</span>\n        <span>print</span><span>(</span><span>\"汪！汪！\"</span><span>)</span>\n    <span>elif</span> animal <span>==</span> <span>\"猫\"</span><span>:</span>\n        <span>print</span><span>(</span><span>\"喵！喵！\"</span><span>)</span>\n    <span>elif</span> animal <span>==</span> <span>\"牛\"</span><span>:</span>\n        <span>print</span><span>(</span><span>\"哞！哞！\"</span><span>)</span>\n    <span>else</span><span>:</span>\n        <span>print</span><span>(</span><span>\"说人话！\"</span><span>)</span>\n\na<span>,</span> b<span>,</span> c<span>,</span> d <span>=</span> <span>\"猫\"</span><span>,</span> <span>\"狗\"</span><span>,</span> <span>\"牛\"</span><span>,</span> <span>\"辛巴\"</span>\n\nspeak<span>(</span>a<span>)</span>\nspeak<span>(</span>b<span>)</span>\nspeak<span>(</span>c<span>)</span>\nspeak<span>(</span>d<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id=\"面向对象编程-2\"> 面向对象编程</h2>\n<p>面向对象编程的大体流程如下：</p>\n<div><pre><code><span>1</span>. 导入各种外部库\n<span>2</span>. 设计各种全局变量\n<span>3</span>. 决定你要的类\n<span>4</span>. 给每个类提供完整的一组操作\n<span>5</span>. 明确地使用继承来表现不同类之间的共同点\n<span>6</span>. 根据需要，决定是否写一个main函数作为程序入口\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>在面向对象编程中，将函数和变量进一步封装成类，类才是程序的基本元素，它将数据和操作紧密地连结在一起，并保护数据不会被外界的函数意外地改变。类和和类的实例（也称对象）是面向对象的核心概念，是和面向过程编程、函数式编程的根本区别。</p>\n<p>还是为了实现上面那个需求，使用面向对象编程，会是下面的样子：</p>\n<div><pre><code><span># 先定义一个动物的类</span>\n<span>class</span> <span>Animal</span><span>:</span>\n    <span># 动物实例的初始化方法，需要提供动物类别和该类动物的叫声</span>\n    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> kind<span>,</span> voice<span>)</span><span>:</span>\n        self<span>.</span>kind <span>=</span> kind\n        self<span>.</span>voice <span>=</span> voice\n    <span># 让动物发出叫声的方法</span>\n    <span>def</span> <span>speak</span><span>(</span>self<span>)</span><span>:</span>\n        <span>print</span><span>(</span>self<span>.</span>voice<span>)</span>\n\n<span># 实例化四种动物对象</span>\na <span>=</span> Animal<span>(</span><span>\"狗\"</span><span>,</span> <span>\"汪！汪！\"</span><span>)</span>\nb <span>=</span> Animal<span>(</span><span>\"猫\"</span><span>,</span> <span>\"喵！喵！\"</span><span>)</span>\nc <span>=</span> Animal<span>(</span><span>\"牛\"</span><span>,</span> <span>\"哞！哞！\"</span><span>)</span>\nd <span>=</span> Animal<span>(</span><span>\"辛巴\"</span><span>,</span> <span>\"说人话！\"</span><span>)</span>\n\n<span># 调用动物类的发声方法</span>\na<span>.</span>speak<span>(</span><span>)</span>\nb<span>.</span>speak<span>(</span><span>)</span>\nc<span>.</span>speak<span>(</span><span>)</span>\nd<span>.</span>speak<span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>（完）</p>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2021-11-19T03:27:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "函数参数",
      "url": "https://www.fedbook.cn/backend-knowledge/python/function-params/",
      "id": "https://www.fedbook.cn/backend-knowledge/python/function-params/",
      "content_html": "<h1 id=\"函数参数\"> 函数参数</h1>\n<p>在 Python 中，函数的参数定义灵活度非常大，分为位置参数、默认参数、动态参数和关键字参数，这些都是形参的种类。</p>\n<h2 id=\"位置参数\"> 位置参数</h2>\n<p>也叫必传参数，顺序参数，是最重要的，也是必须在调用函数时明确提供的参数。位置参数必须按先后顺序，一一对应，个数不多不少的传递。</p>\n<p>代码示例：</p>\n<div><pre><code><span>def</span> <span>add</span><span>(</span>a<span>,</span> b<span>,</span> c<span>)</span><span>:</span>\n    <span>return</span> a <span>+</span> b <span>+</span> c\n\nresult <span>=</span> add<span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>注意: Python 在做函数参数传递的时候不会对数据类型进行检查，理论上你传什么类型都可以，但上面的 add 函数，如果你传递了一个字符串和两个数字，结果是弹出异常，因为字符串无法和数字相加。这就是 Python 的弱数据类型和动态语言的特点。在简单、方便的时候，需要你自己去实现数据类型检查。</p>\n<h2 id=\"默认参数\"> 默认参数</h2>\n<p>在函数定义时，如果给某个参数提供一个默认值，这个参数就变成了默认参数，不再是位置参数了。在调用函数的时候，我们可以给默认参数传递一个自定义的值，也可以使用默认值。</p>\n<p>代码示例：</p>\n<div><pre><code><span>def</span> <span>power</span><span>(</span>x<span>,</span> n <span>=</span> <span>2</span><span>)</span><span>:</span>\n    <span>return</span> x<span>**</span>n\n\nret1 <span>=</span> power<span>(</span><span>10</span><span>)</span>   <span># 使用默认的参数值 n = 2</span>\nret2 <span>=</span> power<span>(</span><span>10</span><span>,</span> <span>4</span><span>)</span>  <span># 将 4 传给 n，实际计算 10**4 的值</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>在设置默认参数时，有几点要注意：</p>\n<ul>\n<li>\n<p>默认参数必须在位置参数后面。</p>\n</li>\n<li>\n<p>当有多个默认参数的时候，通常将更常用的放在前面，变化较少的放后面。</p>\n</li>\n<li>\n<p>在调用函数的时候，尽量给实际参数提供默认参数名。</p>\n<ul>\n<li>一切没有提供参数名的实际参数，都会当做位置参数按顺序从参数列表的左边开头往右匹配。</li>\n</ul>\n</li>\n<li>\n<p>如果在位置参数传递时，给实参指定位置参数的参数名，那么位置参数也可以不按顺序调用。</p>\n</li>\n<li>\n<p>默认参数尽量指向不变的对象</p>\n<ul>\n<li>这个很重要，看如下代码，并分析下打印结果：</li>\n</ul>\n<div><pre><code><span>def</span> <span>func</span><span>(</span>a<span>=</span><span>[</span><span>]</span><span>)</span><span>:</span>\n    a<span>.</span>append<span>(</span><span>\"A\"</span><span>)</span>\n    <span>return</span> a\n\n<span>print</span><span>(</span>func<span>(</span><span>)</span><span>)</span>\n<span>print</span><span>(</span>func<span>(</span><span>)</span><span>)</span>\n<span>print</span><span>(</span>func<span>(</span><span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>分析：Python 函数体在被读入内存的时候，默认参数 <code>a</code> 指向的空列表对象就会被创建，并放在内存里了。因为默认参数 <code>a</code> 本身也是一个变量，保存了指向对象 <code>[]</code> 的地址。每次调用该函数，往 <code>a</code> 指向的列表里添加一个 <code>A</code>。<code>a</code> 没有变，始终保存的是指向列表的地址，变的是列表内的数据。</p>\n<p>为了避免这个问题，需要使用不可变的数据类型作为默认值：</p>\n<div><pre><code><span>def</span> <span>func</span><span>(</span>a<span>=</span><span>None</span><span>)</span><span>:</span>\n    <span># 注意下面的if语句</span>\n    <span>if</span> a <span>is</span> <span>None</span><span>:</span>\n        a <span>=</span> <span>[</span><span>]</span>\n    a<span>.</span>append<span>(</span><span>\"A\"</span><span>)</span>\n    <span>return</span> a\n\n<span>print</span><span>(</span>func<span>(</span><span>)</span><span>)</span>\n<span>print</span><span>(</span>func<span>(</span><span>)</span><span>)</span>\n<span>print</span><span>(</span>func<span>(</span><span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>将默认参数 <code>a</code> 设置为一个类似 <code>None</code>、数字或字符串之类的不可变对象。在函数内部，将它转换为可变的类型，比如空列表。这样一来，不管调用多少次，运行结果都是 <code>['A']</code> 了。</p>\n</li>\n</ul>\n<h2 id=\"动态参数\"> 动态参数</h2>\n<p>顾名思义，动态参数就是传入的参数的个数是动态的，可以是 1 个、2 个到任意个，还可以是 0 个。</p>\n<p>Python 的动态参数有两种，分别是 <code>*args</code> 和 <code>**kwargs</code>，这里面的关键是一个和两个星号的区别，而不是 args 和 kwargs 在名字上的区别，实际上可以使用任何名字，但这似乎是大家默认的规范。</p>\n<p>注意：动态参数，必须放在所有的位置参数和默认参数后面。</p>\n<div><pre><code><span>def</span> <span>func</span><span>(</span>name<span>,</span> age<span>,</span> sex<span>=</span><span>'male'</span><span>,</span> <span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span>\n    <span>pass</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"args\"> *args</h3>\n<p>一个星号表示接收任意个参数。调用时，会将实际参数打包成一个元组传入形式参数。如果参数是个列表，会将整个列表当做一个参数传入。例如：</p>\n<div><pre><code><span>def</span> <span>func</span><span>(</span><span>*</span>args<span>)</span><span>:</span>\n    <span>for</span> arg <span>in</span> args<span>:</span>\n        <span>print</span><span>(</span>arg<span>)</span>\n\nfunc<span>(</span><span>'a'</span><span>,</span> <span>'b'</span><span>,</span> <span>'c'</span><span>)</span>\nfunc<span>(</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"kwargs\"> **kwargs</h3>\n<p>两个星表示接受键值对的动态参数，数量任意。调用的时候会将实际参数打包成字典。例如：</p>\n<div><pre><code><span>def</span> <span>func</span><span>(</span><span>**</span>kwargs<span>)</span><span>:</span>\n    <span>print</span><span>(</span>kwargs<span>)</span>\n    <span>for</span> kwg <span>in</span> kwargs<span>:</span>\n        <span>print</span><span>(</span>kwg<span>,</span> kwargs<span>[</span>kwg<span>]</span><span>)</span>\n\nfunc<span>(</span>k1<span>=</span><span>'v1'</span><span>,</span> k2<span>=</span><span>[</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>]</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"万能参数\"> 万能参数</h3>\n<p>当 <code>*args</code> 和 <code>**kwargs</code> 组合起来使用，理论上能接受任何形式和任意数量的参数，在很多代码中我们都能见到这种定义方式。需要注意的是，<code>*args</code> 必须出现在 <code>**kwargs</code> 之前。</p>\n<h3 id=\"关键字参数\"> 关键字参数</h3>\n<p>关键字参数需要一个特殊分隔符 <code>*</code>（独占一个参数位），<code>*</code> 后面的参数被视为关键字参数。</p>\n<p>在函数调用时，关键字参数必须传入参数名，否则调用将报错。同时，关键字参数没有默认值时必须传递，有默认值时可以不传递。</p>\n<p>代码示例：</p>\n<div><pre><code><span># 没有默认值时必须传递关键字参数</span>\n<span>def</span> <span>student</span><span>(</span>name<span>,</span> age<span>,</span> <span>*</span><span>,</span> sex<span>)</span><span>:</span>\n    <span>pass</span>\n\nstudent<span>(</span>name<span>=</span><span>\"jack\"</span><span>,</span> age<span>=</span><span>18</span><span>,</span> sex<span>=</span><span>'male'</span><span>)</span>\n\n<span># 有默认值时可以不传递关键字参数</span>\n<span>def</span> <span>student</span><span>(</span>name<span>,</span> age<span>,</span> <span>*</span><span>,</span> sex<span>=</span><span>'male'</span><span>)</span><span>:</span>\n    <span>pass</span>\n\nstudent<span>(</span>name<span>=</span><span>\"jack\"</span><span>,</span> age<span>=</span><span>18</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>Python 的函数参数种类多样、形态多变，既可以实现简单的调用，又可以传入非常复杂的参数。需要我们多下功夫，多写实际代码，多做测试，逐步理清并熟练地使用参数。</p>\n<p>（完）</p>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2021-11-19T03:27:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "使用 Fabric 执行 SSH",
      "url": "https://www.fedbook.cn/backend-knowledge/python/python-lib-fabric/",
      "id": "https://www.fedbook.cn/backend-knowledge/python/python-lib-fabric/",
      "content_html": "<h1 id=\"使用-fabric-执行-ssh\"> 使用 Fabric 执行 SSH</h1>\n<h2 id=\"关于-fabric\"> 关于 Fabric</h2>\n<p>Fabric 是 Python 库中的一个模块，它是基于 Paramiko 的基础上做了一层更高的封装，操作起来更加方便。我们可以用它通过网络进行系统管理和应用程序部署，也可以通过 SSH 执行 Shell 命令。</p>\n<p>由于 Fabric 是 Python 的一个第三方库，首先需要安装它：</p>\n<div><pre><code><span>sudo</span> pip <span>install</span> fabric\n</code></pre>\n<div><span>1</span><br></div></div><blockquote>\n<p>题外话：曾经有一段时间 Fabric 只支持到 Python2，所以有人 Fork 官方仓库后改写成了<a href=\"https://github.com/mathiasertl/fabric/\" target=\"_blank\" rel=\"noopener noreferrer\">支持 Python3 的版本</a>，也就是网上大部分教程通过 <code>pip install fabric3</code> 安装的包。<br>\n后来 <a href=\"https://github.com/fabric/fabric/\" target=\"_blank\" rel=\"noopener noreferrer\">fabric 官方</a>对 Python3 做了支持，而后 Fabric3 的作者也在 README 中加了 deprecated 标识，意为不再维护。<br>\n所以尽管 Fabric3 比较好用，大部分网上的教程和书籍也都是基于它在开发，但处于稳定性和持续维护性角度考虑，我在 Python3 中将继续沿用官方版本的 Fabric。<br>\n关于三者的区别：<a href=\"https://github.com/fabric/fabric/issues/1791\" target=\"_blank\" rel=\"noopener noreferrer\">Clarify fabric vs fabric2 vs fabric3 differences</a></p>\n</blockquote>\n<h2 id=\"一个简单的例子\"> 一个简单的例子</h2>\n<p>下面是一个使用 Fabric 连接远程设备的示例程序（<a href=\"https://github.com/wenyuan/practice-in-python/blob/main/devops-case/fabric_example.py\" target=\"_blank\" rel=\"noopener noreferrer\"><code>fabric_example.py</code></a>）：</p>\n<div><pre><code><span>#!/usr/bin/env python</span>\n<span># -*- coding: utf-8 -*-</span>\n\n<span>from</span> fabric <span>import</span> Connection\n<span>from</span> paramiko <span>import</span> AuthenticationException\n\n\n<span>def</span> <span>do_ssh</span><span>(</span>host<span>,</span> username<span>,</span> password<span>,</span> commands<span>)</span><span>:</span>\n    <span>try</span><span>:</span>\n        client <span>=</span> Connection<span>(</span>host<span>=</span>host<span>,</span> user<span>=</span>username<span>,</span> port<span>=</span><span>22</span><span>,</span> connect_kwargs<span>=</span><span>{</span><span>'password'</span><span>:</span> password<span>}</span><span>)</span>\n        <span># 执行操作</span>\n        <span>for</span> command <span>in</span> commands<span>:</span>\n            res <span>=</span> client<span>.</span>run<span>(</span>command<span>,</span> hide<span>=</span><span>True</span><span>)</span>\n            <span>print</span><span>(</span>res<span>.</span>stdout<span>)</span>\n        client<span>.</span>close<span>(</span><span>)</span>\n    <span>except</span> AuthenticationException<span>:</span>\n        <span>print</span><span>(</span><span>'{host} 密码错误'</span><span>.</span><span>format</span><span>(</span>host<span>=</span>host<span>)</span><span>)</span>\n    <span>except</span> Exception <span>as</span> e<span>:</span>\n        <span>print</span><span>(</span><span>repr</span><span>(</span>e<span>)</span><span>)</span>\n\n\n<span>if</span> __name__ <span>==</span> <span>\"__main__\"</span><span>:</span>\n    host <span>=</span> <span>'192.168.10.x'</span>\n    username <span>=</span> <span>'admin'</span>\n    password <span>=</span> <span>'******'</span>\n    commands <span>=</span> <span>[</span><span>'pwd'</span><span>,</span> <span>'ls'</span><span>]</span>\n    do_ssh<span>(</span>host<span>,</span> username<span>,</span> password<span>,</span> commands<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>Fabric 模块里上面代码中用到的方法介绍：</p>\n<ul>\n<li><code>Connection</code> 类：用于创建连接。</li>\n<li><code>run()</code>：该方法可在连接的服务器上运行 Shell 命令。如果需要用管理员权限，则需替换成 <code>sudo()</code> 方法；如果要在本地执行 Shell 命令，则需替换成 <code>local()</code> 方法。\n<ul>\n<li>参数 <code>warn</code>：默认为 <code>False</code>，默认情况下会因为 Shell 命令的错误输出而抛错, 也就是直接抛出 <code>stderr</code>。如果设为 <code>True</code>, 就会将 Shell 命令的错误输出写到 Result 对象的 <code>stderr</code> 内。</li>\n<li>参数 <code>hide</code>：默认为 <code>False</code>，默认情况下将远程的输出信息在当前命令行输出。为 <code>True</code> 时，则不会输出。但不论是什么, 都不会影响 Result 对象的 <code>stdout</code> 和 <code>stderr</code> 结果，还可以只隐藏 <code>stdout</code> 或 <code>stderr</code>。</li>\n<li>参数 <code>watchers</code>：传入的是一个包含诺干 Responder 实例的列表。当需要运行交互式的命令时，可以用 Responder 对象来匹配输出，并写入输入，做自动化部署时很实用。</li>\n<li>参数 <code>pty</code>：默认为 <code>True</code>，这个参数最好别动，不然输出内容可能会混乱。</li>\n</ul>\n</li>\n</ul>\n<p>关于 <code>run()</code> 的输出结果：</p>\n<p>执行 Connection 类的 <code>run()</code> 方法后，直接输出的是一个 fabric.runners.Result 类，我们可以把其中的信息解析出来：</p>\n<div><pre><code><span>print</span><span>(</span>result<span>.</span>stdout<span>)</span>  <span># /home/admin</span>\n<span>print</span><span>(</span>result<span>.</span>exited<span>)</span>  <span># 0</span>\n<span>print</span><span>(</span>result<span>.</span>ok<span>)</span>      <span># True</span>\n<span>print</span><span>(</span>result<span>.</span>failed<span>)</span>  <span># False</span>\n<span>print</span><span>(</span>result<span>.</span>command<span>)</span> <span># pwd</span>\n<span>print</span><span>(</span>result<span>.</span>connection<span>.</span>host<span>)</span> <span># 192.xx.xx.xx</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id=\"命令行用法\"> 命令行用法</h2>\n<p>上例代码可写在任意的 <code>.py</code> 脚本中，然后运行该脚本，或者稍微封装下再导入到其它脚本中使用。</p>\n<p>另外，Fabric 还是个命令行工具，可以通过 <code>fab</code> 命令来执行任务。如下代码示例：</p>\n<div><pre><code><span># 文件名：fabfile.py</span>\n<span>from</span> fabric <span>import</span> Connection\n<span>from</span> fabric <span>import</span> task\n\nhost_ip <span>=</span> <span>'192.168.10.xx'</span>  <span># 服务器地址</span>\nuser_name <span>=</span> <span>'root'</span>         <span># 服务器用户名</span>\npassword <span>=</span> <span>'******'</span>        <span># 服务器密码</span>\ncmd <span>=</span> <span>'date'</span>               <span># Shell 命令，查询服务器上的时间</span>\n\n<span>@task</span>\n<span>def</span> <span>test</span><span>(</span>c<span>)</span><span>:</span>\n    <span>\"\"\"\n    Get date from remote host.\n    \"\"\"</span>\n    con <span>=</span> Connection<span>(</span>host_ip<span>,</span> user_name<span>,</span> connect_kwargs<span>=</span><span>{</span><span>'password'</span><span>:</span> password<span>}</span><span>)</span>\n    result <span>=</span> con<span>.</span>run<span>(</span>cmd<span>,</span> hide<span>=</span><span>True</span><span>)</span>\n    <span>print</span><span>(</span>result<span>.</span>stdout<span>)</span>  <span># 只打印时间</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>解释一下，需要注意的关键点有：</p>\n<ul>\n<li><code>fabfile.py</code> 文件名：入口代码的脚本名必须用这个名字</li>\n<li><code>@task</code> 装饰器：需要从 fabric 中引入这个装饰器，它是对 invoke 的 <code>@task</code> 装饰器的封装，实际用法跟 invoke 一样（注意：它也需要有上下文参数 <code>c</code>，但实际上它并没有在代码块中使用，而是用了 Connection 类的实例）</li>\n</ul>\n<p>然后，在该脚本同级目录的命令行窗口中，可以查看和执行相应的任务：</p>\n<div><pre><code><span>>></span><span>></span> fab -l\nAvailable tasks:\n  <span>test</span>   Get <span>date</span> from remote host.\n\n<span>>></span><span>></span> fab <span>test</span>\nFri Feb <span>14</span> <span>16</span>:10:24 CST <span>2021</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>执行 <code>fab --help</code>，可以看到该命令支持的所有参数与解释：</p>\n<ul>\n<li><code>--prompt-for-login-password</code>：令程序在命令行中输入 SSH 登录密码（上例在代码中指定了 connect_kwargs.password 参数，若用此选项，可要求在执行时再手工输入密码）</li>\n<li><code>--prompt-for-passphrase</code>：令程序在命令行中输入 SSH 私钥加密文件的路径</li>\n<li><code>-H</code> 或 <code>--hosts</code>：指定要连接的 host 名</li>\n<li><code>-i</code> 或 <code>--identity</code>：指定 SSH 连接所用的私钥文件</li>\n<li><code>-S</code> 或 <code>--ssh-config</code>：指定运行时要加载的 SSH 配置文件</li>\n</ul>\n<p>关于 Fabric 的命令行接口，更多内容可<a href=\"https://docs.fabfile.org/en/2.5/cli.html\" target=\"_blank\" rel=\"noopener noreferrer\">查看文档</a>。</p>\n<h2 id=\"交互式操作\"> 交互式操作</h2>\n<p>上面的示例程序我们通过 Fabric 模块连接了一台远程服务器，执行命令后打印了输出结果。</p>\n<p>有时候远程服务器上若有交互式提示，要求输入密码或 yes 之类的信息，这就要求 Fabric 能够监听并作出回应。</p>\n<p>以下是一个简单示例。引入 invoke 的 Responder，初始化内容是一个正则字符串和回应信息，最后赋值给 watchers 参数：</p>\n<div><pre><code><span>from</span> invoke <span>import</span> Responder\n<span>from</span> fabric <span>import</span> Connection\nc <span>=</span> Connection<span>(</span><span>'host'</span><span>)</span>\nsudopass <span>=</span> Responder<span>(</span>\n     pattern<span>=</span><span>r'\\[sudo\\] password:'</span><span>,</span>\n     response<span>=</span><span>'mypassword\\n'</span><span>)</span>\nc<span>.</span>run<span>(</span><span>'sudo whoami'</span><span>,</span> pty<span>=</span><span>True</span><span>,</span> watchers<span>=</span><span>[</span>sudopass<span>]</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"传输文件\"> 传输文件</h2>\n<p>本地与服务器间的文件传输是常见用法。Fabric 在这方面做了很好的封装，Connection 类中有以下两个方法可用：</p>\n<ul>\n<li><code>get(*args, **kwargs)</code>：拉取远端文件到本地文件系统或类文件（file-like）对象</li>\n<li><code>put(*args, **kwargs)</code>：推送本地文件或类文件对象到远端文件系统</li>\n</ul>\n<p>在已建立连接的情况下，示例：</p>\n<div><pre><code><span># (略)</span>\ncon<span>.</span>get<span>(</span><span>'/opt/123.txt'</span><span>,</span> <span>'123.txt'</span><span>)</span>\ncon<span>.</span>put<span>(</span><span>'test.txt'</span><span>,</span> <span>'/opt/test.txt'</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>第一个参数指的是要传输的源文件，第二个参数是要传输的目的地，可以指定成文件名或者文件夹（为空或 <code>None</code> 时，使用默认路径）：</p>\n<div><pre><code><span># (略)</span>\ncon<span>.</span>get<span>(</span><span>'/opt/123.txt'</span><span>,</span> <span>''</span><span>)</span>  <span># 为空时，使用默认路径</span>\ncon<span>.</span>put<span>(</span><span>'test.txt'</span><span>,</span> <span>'/opt/'</span><span>)</span> <span># 指定路径 /opt/</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>get()</code> 方法的默认存储路径是 <code>os.getcwd()</code> ，而 <code>put()</code> 方法的默认存储路径是 <code>home</code> 目录。</p>\n<h2 id=\"服务器批量操作\"> 服务器批量操作</h2>\n<p>对于服务器集群的批量操作，最简单的实现方法是用 for 循环，然后逐一建立 connection 和执行操作，类似这样：</p>\n<div><pre><code><span>for</span> host <span>in</span> <span>(</span><span>'server1'</span><span>,</span> <span>'server2'</span><span>,</span> <span>'server3'</span><span>)</span><span>:</span>\n    result <span>=</span> Connection<span>(</span>host<span>)</span><span>.</span>run<span>(</span><span>'uname -s'</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>但有时候，这样的方案会存在问题：</p>\n<ul>\n<li>如果存在多组不同的服务器集群，需要执行不同操作，那么需要写很多 for 循环</li>\n<li>如果想把每组操作的结果聚合起来（例如字典形式，key-主机，value-结果），还得在 for 循环之外添加额外的操作</li>\n<li>for 循环是顺序同步执行的，效率太低，而且缺乏异常处理机制（若中间出现异常，会导致跳出后续操作）</li>\n</ul>\n<p>对于这些问题，Fabric 提出了 Group 的概念，可将一组主机定义成一个 Group，它的 API 方法跟 Connection 一样，即一个 Group 可简化地视为一个 Connection。</p>\n<p>然后，开发者只需要简单地操作这个 Group，最后得到一个结果集即可，减少了自己在异常处理及执行顺序上的工作。</p>\n<p>Fabric 提供了一个 fabric.group.Group 基类，并由其派生出两个子类，区别是：</p>\n<ul>\n<li><code>SerialGroup(hosts, **kwargs)</code>：按串行方式执行操作</li>\n<li><code>ThreadingGroup(hosts, **kwargs)</code>：按并发方式执行操作</li>\n</ul>\n<p>Group 的类型决定了主机集群的操作方式，我们只需要做出选择即可。然后，它们的执行结果是一个 fabric.group.GroupResult 类，它是 dict 的子类，存储了每个主机 connection 及其执行结果的对应关系。</p>\n<div><pre><code><span>from</span> fabric <span>import</span> SerialGroup\nresults <span>=</span> SerialGroup<span>(</span><span>'server1'</span><span>,</span> <span>'server2'</span><span>,</span> <span>'server3'</span><span>)</span><span>.</span>run<span>(</span><span>'uname -s'</span><span>)</span>\n<span>print</span><span>(</span>results<span>)</span>\n\n<span># 输出：</span>\n<span>&lt;</span>GroupResult<span>:</span> <span>{</span>\n    <span>&lt;</span>Connection <span>'server1'</span><span>></span><span>:</span> <span>&lt;</span>CommandResult <span>'uname -s'</span><span>></span><span>,</span>\n    <span>&lt;</span>Connection <span>'server2'</span><span>></span><span>:</span> <span>&lt;</span>CommandResult <span>'uname -s'</span><span>></span><span>,</span>\n    <span>&lt;</span>Connection <span>'server3'</span><span>></span><span>:</span> <span>&lt;</span>CommandResult <span>'uname -s'</span><span>></span><span>,</span>\n<span>}</span><span>></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>另外，GroupResult 还提供了 failed 与 succeeded 两个属性，可以取出失败/成功的子集。由此，也可以方便地批量进行二次操作。<a href=\"https://docs.fabfile.org/en/2.5/api/group.html\" target=\"_blank\" rel=\"noopener noreferrer\">官方文档</a></p>\n<h2 id=\"身份认证\"> 身份认证</h2>\n<p>Fabric 使用 SSH 协议来建立远程会话，它是一种相对安全的基于应用层的加密传输协议。</p>\n<p>基本来说，它有两种级别的安全认证方式：</p>\n<ul>\n<li>基于口令的身份认证：使用账号与密码来登录远程主机，安全性较低，容易受到「中间人」攻击。</li>\n<li>基于密钥的身份认证：使用密钥对方式（公钥放服务端，私钥放客户端），不会受到「中间人」攻击，但登录耗时较长。</li>\n</ul>\n<p>前面在举例时，我们用了第一种方式，即通过指定 <code>connect_kwargs.password</code> 参数，使用口令来登录。</p>\n<p>Fabric 当然也支持采用第二种方式，有三种方法来指定私钥文件的路径，优先级如下：</p>\n<ul>\n<li>优先查找 <code>connect_kwargs.key_filename</code> 参数，找到则用作私钥；</li>\n<li>其次查找命令行用法的 <code>--identify</code> 选项；</li>\n<li>最后默认使用操作系统的 <code>ssh_config</code> 文件中的 <code>IdentityFile</code> 的值。</li>\n</ul>\n<p>如果私钥文件本身还被加密过，则需要使用 <code>connect_kwargs.passphrase</code> 参数。</p>\n<h2 id=\"配置文件\"> 配置文件</h2>\n<p>Fabric 支持把一些参数项与业务代码分离，即通过配置文件来管理它们，例如前面提到的密码和私钥文件，可写在配置文件中，避免与代码耦合。</p>\n<p>Fabric 基本沿用了 Invoke 的配置文件体系（官方文档中列出了 9 层），同时增加了一些跟 SSH 相关的配置项。支持的文件格式有 .yaml、.yml、.json 与 .py（按此次序排优先级），推荐使用 yaml 格式（后缀可简写成 yml）。</p>\n<p>其中，比较常用的配置文件有：</p>\n<ul>\n<li>系统级的配置文件：<code>/etc/fabric.yml</code></li>\n<li>用户级的配置文件：<code>~/.fabric.yml</code>（Windows 在 <code>C:\\Users\\xxx</code> 下）</li>\n<li>项目级的配置文件：<code>/myproject/fabric.yml</code></li>\n</ul>\n<p>以上文件的优先级递减，由于我的本地开发机器是 Windows 系统，为了方便，我在用户目录建一个 <code>.fabric.yml</code> 文件，内容如下：</p>\n<div><pre><code><span># filename:.fabric.yml</span>\n\nuser: root\nconnect_kwargs:\n  password: xxxx\n<span># 若用密钥，则如下</span>\n<span>#  key_filename:</span>\n<span>#    - your_key_file</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>我们把用户名和密码抽离出来了，所以脚本中就可以删掉这些内容：</p>\n<div><pre><code><span># 文件名：fabfile.py</span>\n<span>from</span> fabric <span>import</span> Connection\n<span>from</span> fabric <span>import</span> task\n\nhost_ip <span>=</span> <span>'47.xx.xx.xx'</span>  <span># 服务器地址</span>\ncmd <span>=</span> <span>'date'</span>             <span># Shell 命令，查询服务器上的时间</span>\n\n<span>@task</span>\n<span>def</span> <span>test</span><span>(</span>c<span>)</span><span>:</span>\n    <span>\"\"\"\n    Get date from remote host.\n    \"\"\"</span>\n    con <span>=</span> Connection<span>(</span>host_ip<span>)</span>\n    result <span>=</span> con<span>.</span>run<span>(</span>cmd<span>,</span> hide<span>=</span><span>True</span><span>)</span>\n    <span>print</span><span>(</span>result<span>.</span>stdout<span>)</span> \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>然后，在命令行中执行：</p>\n<div><pre><code><span>>></span><span>></span> fab <span>test</span>\nTue Feb <span>18</span> <span>10</span>:33:38 CST <span>2021</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>配置文件中还可以设置很多参数，详细可<a href=\"https://docs.fabfile.org/en/2.5/concepts/configuration.html\" target=\"_blank\" rel=\"noopener noreferrer\">查看文档</a>。</p>\n<h2 id=\"网络网关\"> 网络网关</h2>\n<p>如果远程服务是网络隔离的，无法直接被访问到（处在不同局域网），这时候需要有网关/代理/隧道，这个中间层的机器通常被称为跳板机或堡垒机。</p>\n<p>Fabric 中有两种网关解决方案，对应到 OpenSSH 客户端的两种选项：</p>\n<ul>\n<li>ProxyJump：简单，开销少，可嵌套</li>\n<li>ProxyCommand：开销大，不可嵌套，更灵活</li>\n</ul>\n<p>在创建 Fabric 的 Connection 对象时，可通过指定 gateway 参数来应用这两种方案。</p>\n<p>ProxyJump 方式就是在一个 Connection 中嵌套一个 Connection  作为前者的网关，后者使用 SSH 协议的 <code>direct-tcpip</code> 为前者打开与实际远程主机的连接，而且后者还可以继续嵌套使用自己的网关。</p>\n<div><pre><code><span>from</span> fabric <span>import</span> Connection\n\nc <span>=</span> Connection<span>(</span><span>'internalhost'</span><span>,</span> gateway<span>=</span>Connection<span>(</span><span>'gatewayhost'</span><span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>ProxyCommand 方式是客户端在本地用 ssh 命令（类似 <code>ssh -W %h:%p gatewayhost</code>），创建一个子进程，该子进程与服务端进行通信，同时它能读取标准输入和输出。</p>\n<p>这部分的实现细节分别在 <code>paramiko.channel.Channel</code> 和 <code>paramiko.proxy.ProxyCommand</code>，除了在参数中指定，也可以在 Fabric 支持的配置文件中定义。更多细节，请<a href=\"https://docs.fabfile.org/en/2.5/concepts/networking.html\" target=\"_blank\" rel=\"noopener noreferrer\">查阅文档</a>。</p>\n<h2 id=\"总结\"> 总结</h2>\n<p>本文把 Fabric 常见的几种用法都整理了一下，原因是 Fabric 之前对 Python3 的不兼容，导致出现了不同的分支。而网上关于 Fabric 的文章，甚至是最近两年出版的书籍，都是基于 Fabric3（非官方版）的，显然已经过时了。本文针对最新的官方文档，梳理出了较为全面的知识点。更详细的用法，还是得仔细研读官方的英文文档。</p>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://www.fabfile.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Fabric</a></li>\n<li>《Python自动化运维：技术与最佳实践》</li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2021-11-19T03:27:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "语法规范",
      "url": "https://www.fedbook.cn/backend-knowledge/python/grammar/",
      "id": "https://www.fedbook.cn/backend-knowledge/python/grammar/",
      "content_html": "<h1 id=\"语法规范\"> 语法规范</h1>\n<h2 id=\"标识符\"> 标识符</h2>\n<p>所谓的标识符就是对变量、常量、函数、类等对象起的名字。</p>\n<p>Python 对于标识符的命名有如下规定：</p>\n<h4 id=\"_1-第一个字符必须是字母表中的字母或下划线\"> 1）第一个字符必须是字母表中的字母或下划线 <code>_</code></h4>\n<p>值得注意的是，在 Python 中以下划线开头的标识符通常都有特殊意义：</p>\n<ul>\n<li>以单下划线开头的变量，例如 <code>_foo</code> 代表禁止外部访问的类成员，需通过类提供的接口进行访问，不能用 <code>from xxx import *</code> 导入。</li>\n<li>以双下划线开头的，例如 <code>__foo</code> 代表类的私有成员。</li>\n<li>以双下划线开头和结尾的是 Python 里特殊方法专用的标识，如 <code>__init__()</code> 代表类的构造函数。</li>\n</ul>\n<h4 id=\"_2-标识符的其他的部分由字母、数字和下划线组成\"> 2）标识符的其他的部分由字母、数字和下划线组成</h4>\n<h4 id=\"_3-标识符对大小写敏感\"> 3）标识符对大小写敏感</h4>\n<p>事实上 Python 语言在任何场景都严格区分大小写。</p>\n<h4 id=\"_4-变量名全部小写-常量名全部大写\"> 4）变量名全部小写，常量名全部大写</h4>\n<p>这条不能算语法层面的要求，而是代码规范的要求。</p>\n<h4 id=\"_5-函数和方法名用小写加下划线\"> 5）函数和方法名用小写加下划线</h4>\n<p>也不是语法强制，而是代码规范，我们在定义一个函数或者方法的名字的时候，应尽量用类似 <code>get_students</code>、<code>add_student</code>、<code>update_student</code> 之类的命名方式。</p>\n<h4 id=\"_6-类名用大写驼峰\"> 6）类名用大写驼峰</h4>\n<p>同样也不是语法强制，而是代码规范。所谓的大写驼峰指的是每个单词的首字母大写。例如 <code>Student</code>、<code>StudentConfig</code> 等等。</p>\n<h4 id=\"_7-模块和包的名字用小写\"> 7）模块和包的名字用小写</h4>\n<p>模块和包的名字尽量用小写，并且不能和标准库以及著名的第三方库同名。</p>\n<h2 id=\"保留字\"> 保留字</h2>\n<p>Python 保留字，也叫关键字，是 Python 语言官方确定的用作语法功能的专用标识符，不能把它们用作任何自定义标识符名称。关键字只包含小写字母。</p>\n<p>Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字：</p>\n<div><pre><code><span>import</span> keyword\n\n<span>print</span><span>(</span>keyword<span>.</span>kwlist<span>)</span>\n<span># ['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"注释\"> 注释</h2>\n<h4 id=\"单行注释\"> 单行注释</h4>\n<p>以符号 <code>#</code> 为单行注释的开始，从它往后到本行的末尾，都是注释内容。</p>\n<h4 id=\"多行注释\"> 多行注释</h4>\n<p>Python 没有真正意义上的多行注释（块注释）语法。你只能在每行的开头打上 <code>#</code> 号，然后在有多行注释内容时，使用多个单行注释。</p>\n<div><pre><code><span># 第一行注释</span>\n<span># 第二行注释</span>\n<span># 第三行注释</span>\n<span>def</span> <span>func</span><span>(</span><span>)</span><span>:</span>\n    <span>print</span><span>(</span><span>'hello!'</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id=\"文件注释\"> 文件注释</h4>\n<p>在某些特定的位置，用三引号包括起来的部分，也被当做注释。但是，这种注释有专门的作用，用于为 <code>__doc__</code> 提供文档内容，这些内容可以通过现成的工具，自动收集起来，形成帮助文档。</p>\n<p>例如，函数和类的说明文档：</p>\n<div><pre><code><span>def</span> <span>func</span><span>(</span>a<span>,</span> b<span>)</span><span>:</span>\n    <span>\"\"\"\n    这个是函数的说明文档。\n    :param a: 加数\n    :param b: 加数\n    :return: 和\n    \"\"\"</span>\n    <span>return</span> a <span>+</span> b\n\n\n<span>class</span> <span>Foo</span><span>:</span>\n    <span>\"\"\"\n    这个类初始化了一个age变量\n    \"\"\"</span>\n    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> age<span>)</span><span>:</span>\n        self<span>.</span>age <span>=</span> age\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p><strong>需要强调的是这类注释必须紧跟在定义体下面，不能在任意位置</strong>。</p>\n<h2 id=\"代码头两行\"> 代码头两行</h2>\n<p>很多时候，我们在一些 Python 脚本文件的开头都能看到类似的以 <code>#</code> 开头的这样两行代码，它们不是注释，是一些设定。</p>\n<div><pre><code><span>#!/usr/bin/env python</span>\n<span># -*- coding: utf-8 -*-</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p><strong>第一行</strong>：用于指定运行该脚本的 Python 解释器，Linux 专用，Windows 不需要。env 方式下，系统会自动使用环境变量里指向的 Python。</p>\n<p>在 Linux 下使用形如 <code>./test.py</code> 的方式执行脚本时，该行设置生效；在使用类似 <code>python test.py</code> 或者 <code>python3 test.py</code>的执行方式时，这一行不起作用。</p>\n<p><strong>第二行</strong>：代码的编码方式。不是程序要处理的数据的编码方式，而是程序自己本身的字符编码。在 Python3 中，已经全面支持 Unicode，默认以 UTF-8 编码，我们不用再纠结中文和乱码的问题，所以本行其实可以不需要。</p>\n<p>PS：这里的 <code>-*-</code> 没有特别的作用，仅是为了美观好看的装饰。</p>\n<p>（完）</p>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2021-11-19T03:27:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "类和实例",
      "url": "https://www.fedbook.cn/backend-knowledge/python/class-and-instance/",
      "id": "https://www.fedbook.cn/backend-knowledge/python/class-and-instance/",
      "content_html": "<h1 id=\"类和实例\"> 类和实例</h1>\n<h2 id=\"类和实例-2\"> 类和实例</h2>\n<p>类是抽象的模板，用来描述具有相同属性和方法的对象的集合；实例是根据类创建出来的一个个具体的「对象」，每个对象都拥有相同的方法，但各自的数据可能不同。</p>\n<p>Python 使用 <code>class</code> 关键字来定义类，类名通常采用大驼峰式命名方式。</p>\n<p>Python 采用多继承机制，一个类可以同时继承多个父类（也叫基类、超类），继承的基类有先后顺序，写在类名后的圆括号里。继承的父类列表可以为空，此时的圆括号可以省略。但在 Python3 中，即使没有显式继承任何父类，也会默认继承 <code>object</code> 类。</p>\n<p>因为，<code>object</code> 是 Python3 中所有类的基类。</p>\n<p>下面是一个学生类：</p>\n<div><pre><code><span>class</span> <span>Student</span><span>:</span>\n    classroom <span>=</span> <span>'101'</span>\n    address <span>=</span> <span>'beijing'</span> \n\n    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>,</span> age<span>)</span><span>:</span>\n        self<span>.</span>name <span>=</span> name\n        self<span>.</span>age <span>=</span> age\n\n    <span>def</span> <span>print_age</span><span>(</span>self<span>)</span><span>:</span>\n        <span>print</span><span>(</span><span>'%s: %s'</span> <span>%</span> <span>(</span>self<span>.</span>name<span>,</span> self<span>.</span>age<span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>可以通过调用类的实例化方法（构造函数）来创建一个类的实例。</p>\n<p>默认情况下，使用类似 <code>obj = Student()</code> 的方式就可以生成一个类的实例。但是，通常每个类的实例都会有自己的实例变量，例如这里的 <code>name</code> 和 <code>age</code>，为了在实例化的时候体现实例的不同，Python 提供了一个实例化机制，任何一个类中，名字为 <code>__init__</code> 的方法就是类的实例化方法，该方法会在类实例化的时候，自动调用，并传递对应的参数。</p>\n<p>比如：</p>\n<div><pre><code>p1 <span>=</span> Student<span>(</span><span>\"张三\"</span><span>,</span> <span>13</span><span>)</span>\np2 <span>=</span> Student<span>(</span><span>\"李四\"</span><span>,</span> <span>14</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"类变量和实例变量\"> 类变量和实例变量</h2>\n<h3 id=\"类变量\"> 类变量</h3>\n<p>定义在类中，方法之外的变量，称作类变量。类变量是所有实例公有的变量，每一个实例都可以访问、修改类变量。</p>\n<p>在上述 <code>Student</code> 类中，<code>classroom</code> 和 <code>address</code> 两个变量就是类变量。可以通过类名或者实例名加圆点的方式访问类变量，比如：</p>\n<div><pre><code>Student<span>.</span>classroom\nStudent<span>.</span>address\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>也可以使用实例变量去访问类变量，此时实例会先在自己的实例变量列表里查找是否有这个实例变量，如果没有，那么它就会去类变量列表里找，如果还没有，弹出异常。</p>\n<p>不过，为了防止发生一些混淆情况，<strong>对于类变量，最好只使用 <code>类名.类变量</code> 的访问方式，不要用实例去访问类变量</strong>。</p>\n<p>Python 动态语言的特点，让我们也可以给实例添加新的实例变量，给类添加新的类变量和方法，或给已有的变量或方法重新赋值。</p>\n<h3 id=\"实例变量\"> 实例变量</h3>\n<p>实例变量指的是实例本身拥有的变量。每个实例的变量在内存中都不一样。<code>Student</code> 类中 <code>__init__</code> 方法里的 <code>name</code> 和 <code>age</code> 就是两个实例变量。通过实例名加圆点的方式调用实例变量。</p>\n<h2 id=\"类的方法\"> 类的方法</h2>\n<p>Python 的类中包含实例方法、静态方法和类方法三种方法。这些方法无论是在代码编排中还是内存中都归属于类，区别在于传入的参数和调用方式不同。</p>\n<h3 id=\"实例方法\"> 实例方法</h3>\n<p>类的实例方法由实例调用，至少包含一个 <code>self</code> 参数，且为第一个参数。执行实例方法时，会自动将调用该方法的实例赋值给 <code>self</code>。<code>self</code> 代表的是类的实例，而非类本身。</p>\n<p><code>self</code> 不是关键字，而是 Python 约定成俗的命名，可以取别的名字，但一般不建议这么做。</p>\n<p>例如，前面 <code>Student</code> 类中的 <code>print_age()</code> 就是实例方法：</p>\n<div><pre><code><span>def</span> <span>print_age</span><span>(</span>self<span>)</span><span>:</span>\n        <span>print</span><span>(</span><span>'%s: %s'</span> <span>%</span> <span>(</span>self<span>.</span>name<span>,</span> self<span>.</span>age<span>)</span><span>)</span>\n\n<span># 调用方法</span>\np1<span>.</span>print_age<span>(</span><span>)</span>\np2<span>.</span>print_age<span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"静态方法\"> 静态方法</h3>\n<p>静态方法由类调用，无默认参数。将实例方法参数中的 <code>self</code> 去掉，然后在方法定义上方加上 <code>@staticmethod</code>，就成为静态方法。它属于类，和实例无关。<strong>建议只使用 <code>类名.静态方法</code> 的调用方式</strong>。（虽然也可以使用 <code>实例名.静态方法</code> 的方式调用）</p>\n<div><pre><code><span>class</span> <span>Foo</span><span>:</span>\n    <span>@staticmethod</span>\n    <span>def</span> <span>static_method</span><span>(</span><span>)</span><span>:</span>\n        <span>pass</span>\n\n<span># 调用方法</span>\nFoo<span>.</span>static_method<span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"类方法\"> 类方法</h3>\n<p>类方法由类调用，采用 <code>@classmethod</code> 装饰，至少传入一个 <code>cls</code>（代指类本身，类似 <code>self</code>）参数。执行类方法时，自动将调用该方法的类赋值给 <code>cls</code>。<strong>建议只使用 <code>类名.类方法</code> 的调用方式</strong>。（虽然也可以使用 <code>实例名.类方法</code> 的方式调用）</p>\n<div><pre><code><span>class</span> <span>Foo</span><span>:</span>\n    <span>@classmethod</span>\n    <span>def</span> <span>class_method</span><span>(</span>cls<span>)</span><span>:</span>\n        <span>pass</span>\n\nFoo<span>.</span>class_method<span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>下面是一个综合例子：</p>\n<div><pre><code><span>class</span> <span>Foo</span><span>:</span> \n\n    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>)</span><span>:</span>\n        self<span>.</span>name <span>=</span> name \n\n    <span>def</span> <span>ord_func</span><span>(</span>self<span>)</span><span>:</span>\n        <span>\"\"\"定义实例方法，至少有一个 self 参数 \"\"\"</span>\n        <span>print</span><span>(</span><span>'实例方法'</span><span>)</span>\n\n    <span>@classmethod</span>\n    <span>def</span> <span>class_func</span><span>(</span>cls<span>)</span><span>:</span>\n        <span>\"\"\" 定义类方法，至少有一个 cls 参数 \"\"\"</span>\n        <span>print</span><span>(</span><span>'类方法'</span><span>)</span>\n\n    <span>@staticmethod</span>\n    <span>def</span> <span>static_func</span><span>(</span><span>)</span><span>:</span>\n        <span>\"\"\" 定义静态方法 ，无默认参数\"\"\"</span>\n        <span>print</span><span>(</span><span>'静态方法'</span><span>)</span> \n\n<span># 调用实例方法</span>\nf <span>=</span> Foo<span>(</span><span>\"zhangsan\"</span><span>)</span>\nf<span>.</span>ord_func<span>(</span><span>)</span>\n\n<span># 调用类方法</span>\nFoo<span>.</span>class_func<span>(</span><span>)</span>\n\n<span># 调用静态方法</span>\nFoo<span>.</span>static_func<span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>（完）</p>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2021-11-19T03:27:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "使用 openpyxl 处理新版本 Excel",
      "url": "https://www.fedbook.cn/backend-knowledge/python/python-lib-openpyxl/",
      "id": "https://www.fedbook.cn/backend-knowledge/python/python-lib-openpyxl/",
      "content_html": "<h1 id=\"使用-openpyxl-处理新版本-excel\"> 使用 openpyxl 处理新版本 Excel</h1>\n<h2 id=\"关于-openpyxl\"> 关于 openpyxl</h2>\n<p>openpyxl 是读写新版本 Excel（<code>.xlsx</code>） 的第三方库，是一个比较综合的工具，能够同时读取和修改 Excel 文档。支持的格式有 <code>.xlsx</code>、<code>.xlsm</code>、<code>.xltx</code> 和 <code>.xltm</code>。</p>\n<p>安装比较简单，直接用 pip 工具即可，安装命令如下：</p>\n<div><pre><code><span>sudo</span> pip <span>install</span> openpyxl\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"写入-excel\"> 写入 Excel</h2>\n<p>下面是一个使用 openpyxl 写入数据到 Excel 的代码示例，大致逻辑是：遍历源数据，通过指定行号和列号，依次插入 Excel 表格的每个单元格中。</p>\n<div><p>注意</p>\n<ul>\n<li>Python 中数组的索引是从 0 开始的，</li>\n<li>而 openpyxl 在指定单元格时索引是从 1 开始的（<code>sheet.cell(row, column, value)</code>），</li>\n<li>因此，openpyxl 的首行、首列是 (1, 1) 而不是 (0, 0)。</li>\n</ul>\n</div>\n<div><pre><code><span>#!/usr/bin/env python</span>\n<span># -*- coding: utf-8 -*-</span>\n\n<span>\"\"\"\n使用第三方库：pip install openpyxl\n一般用于处理新版本 Excel(.xlsx)\n\"\"\"</span>\n\n<span>import</span> openpyxl\n\n\n<span># 数据形如：[['张三', '信息与通信工程', '数值分析', 88]]</span>\n<span>def</span> <span>write_excel</span><span>(</span>sheet_name<span>,</span> head<span>,</span> data<span>,</span> path<span>)</span><span>:</span>\n    <span># 实例化一个工作薄对象</span>\n    workbook <span>=</span> openpyxl<span>.</span>Workbook<span>(</span><span>)</span>\n    <span># 激活一个 Sheet 表（工作表），并为它设置一个 title</span>\n    sheet <span>=</span> workbook<span>.</span>active\n    sheet<span>.</span>title <span>=</span> sheet_name\n\n    <span># data 中添加表头（不需要表头可以不用加）</span>\n    data<span>.</span>insert<span>(</span><span>0</span><span>,</span> <span>list</span><span>(</span>head<span>)</span><span>)</span>\n\n    <span># 开始遍历并插入数据</span>\n    <span># row: 行  col: 列</span>\n    <span>for</span> row_index<span>,</span> row_item <span>in</span> <span>enumerate</span><span>(</span>data<span>)</span><span>:</span>\n        <span>for</span> col_index<span>,</span> col_item <span>in</span> <span>enumerate</span><span>(</span>row_item<span>)</span><span>:</span>\n            <span># 写入单元格</span>\n            sheet<span>.</span>cell<span>(</span>row<span>=</span>row_index <span>+</span> <span>1</span><span>,</span> column<span>=</span>col_index <span>+</span> <span>1</span><span>,</span> value<span>=</span>col_item<span>)</span>\n\n    workbook<span>.</span>save<span>(</span>path<span>)</span>\n\n\n<span>if</span> __name__ <span>==</span> <span>\"__main__\"</span><span>:</span>\n    <span># mock 数据</span>\n    sheet_name <span>=</span> <span>'成绩'</span>\n    head <span>=</span> <span>[</span><span>'姓名'</span><span>,</span> <span>'专业'</span><span>,</span> <span>'科目'</span><span>,</span> <span>'成绩'</span><span>]</span>\n    data <span>=</span> <span>[</span>\n        <span>[</span><span>'张三'</span><span>,</span> <span>'信息与通信工程'</span><span>,</span> <span>'数值分析'</span><span>,</span> <span>88</span><span>]</span><span>,</span>\n        <span>[</span><span>'李四'</span><span>,</span> <span>'物联网工程'</span><span>,</span> <span>'数字信号处理分析'</span><span>,</span> <span>95</span><span>]</span><span>,</span>\n        <span>[</span><span>'王华'</span><span>,</span> <span>'电子与通信工程'</span><span>,</span> <span>'模糊数学'</span><span>,</span> <span>90</span><span>]</span><span>,</span>\n        <span>[</span><span>'王欢'</span><span>,</span> <span>'通信工程'</span><span>,</span> <span>'机器学习'</span><span>,</span> <span>89</span><span>]</span>\n    <span>]</span>\n    path <span>=</span> <span>'student.xlsx'</span>\n\n    <span># 执行方法</span>\n    write_excel<span>(</span>sheet_name， head<span>,</span> data<span>,</span> path<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><p>运行代码，结果会看到生成名为 student.xlsx 的 Excel 文件，打开文件查看如下图所示：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/write-xlsx.png\" height=\"200\" alt=\"使用 openpyxl 写入数据到 Excel\">\n  <p style=\"text-align: center; color: #888;\">（使用 openpyxl 写入数据到 Excel）</p>\n</div>\n<p>拓展：</p>\n<ul>\n<li>在实例化一个工作薄对象时，默认会产生一个 Sheet，默认名字是：<code>&quot;Sheet&quot;</code>，激活它后就可使用。</li>\n</ul>\n<div><pre><code>workbook <span>=</span> openpyxl<span>.</span>Workbook<span>(</span><span>)</span>\nsheet <span>=</span> workbook<span>.</span>active\nsheet<span>.</span>title <span>=</span> sheet_name\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>\n<li>新增第二个 Sheet 并使用。</li>\n</ul>\n<div><pre><code>sheet_2 <span>=</span> workbook<span>.</span>create_sheet<span>(</span>title<span>=</span><span>\"Sheet名\"</span><span>)</span>\nsheet_2<span>[</span><span>'F5'</span><span>]</span> <span>=</span> <span>3.14</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><ul>\n<li>遍历 Sheet 对象。</li>\n</ul>\n<div><pre><code><span>for</span> sheet <span>in</span> workbook<span>:</span>\n    <span>print</span><span>(</span><span>'sheet:'</span><span>,</span> sheet<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><ul>\n<li>遍历 Sheet 名然后通过名字获取 Sheet 对象。</li>\n</ul>\n<div><pre><code>sheet_names <span>=</span> workbook<span>.</span>sheet_names\n<span>for</span> sheet_name <span>in</span> sheet_names<span>:</span>\n    sheet <span>=</span> workbook<span>[</span>sheet_name<span>]</span>\n    <span>print</span><span>(</span><span>'sheet:'</span><span>,</span> sheet<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"读取-excel\"> 读取 Excel</h2>\n<p>下面是一个使用 openpyxl 读取 Excel 数据的代码示例，逻辑比较简单：先执行要读取的 Sheet 表，然后逐行遍历，每一行中依次读取每一列（即每个单元格的数据）。</p>\n<div><pre><code><span>#!/usr/bin/env python</span>\n<span># -*- coding: utf-8 -*-</span>\n\n<span>\"\"\"\n使用第三方库：pip install openpyxl\n一般用于处理新版本 Excel(.xlsx)\n\"\"\"</span>\n\n<span>import</span> openpyxl\n\n\n<span>def</span> <span>read_excel</span><span>(</span>path<span>,</span> sheet_name<span>)</span><span>:</span>\n    <span># 实例化一个工作薄对象</span>\n    workbook <span>=</span> openpyxl<span>.</span>load_workbook<span>(</span>path<span>)</span>\n    <span># 获取指定名字的 Sheet 表</span>\n    sheet <span>=</span> workbook<span>[</span>sheet_name<span>]</span>\n\n    <span># 定义一个数组，存放要输出的数据</span>\n    result <span>=</span> <span>[</span><span>]</span>\n\n    <span># sheet.rows 为表格内的每一行数据</span>\n    <span># 循环获取表格内的每一行数据</span>\n    <span>for</span> row_index<span>,</span> row_item <span>in</span> <span>enumerate</span><span>(</span>sheet<span>.</span>rows<span>)</span><span>:</span>\n        <span># 定义一个空的数组用来存放每一行数据单元格的数据</span>\n        current_row <span>=</span> <span>[</span><span>]</span>\n        <span>for</span> col_index<span>,</span> col_item <span>in</span> <span>enumerate</span><span>(</span>row_item<span>)</span><span>:</span>\n            <span># 获取单元格数据 追加到 return_row</span>\n            current_row<span>.</span>append<span>(</span>col_item<span>.</span>value<span>)</span>\n        <span># 把每一行数据追加到结果 return_data 中，最后输出</span>\n        result<span>.</span>append<span>(</span>current_row<span>)</span>\n\n    <span>return</span> result\n\n\n<span>if</span> __name__ <span>==</span> <span>\"__main__\"</span><span>:</span>\n    <span># mock 数据</span>\n    sheet_name <span>=</span> <span>'成绩'</span>\n    path <span>=</span> <span>'student.xlsx'</span>\n\n    <span># 执行方法</span>\n    result <span>=</span> read_excel<span>(</span>path<span>,</span> sheet_name<span>)</span>\n    <span>print</span><span>(</span>result<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><p>输出如下结果：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/read-xlsx.png\" height=\"133\" alt=\"使用 openpyxl 从 Excel 读取数据\">\n  <p style=\"text-align: center; color: #888;\">（使用 openpyxl 从 Excel 读取数据）</p>\n</div>\n<h2 id=\"常用读取-api\"> 常用读取 API</h2>\n<p>接下来列举通过 openpyxl 读写 Excel 时常用的 API。</p>\n<blockquote>\n<p>如无特别标注，以下所有代码中的 <code>workbook</code> 为工作薄的实例对象，<code>sheet</code> 为工作表的实力对象。</p>\n</blockquote>\n<h3 id=\"打开-excel-表格并获取表格名称\"> 打开 Excel 表格并获取表格名称</h3>\n<div><pre><code><span>from</span> openpyxl <span>import</span> load_workbook\nworkbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\nworkbook<span>.</span>sheetnames\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"通过-sheet-名称获取表格\"> 通过 Sheet 名称获取表格</h3>\n<div><pre><code><span>from</span> openpyxl <span>import</span> load_workbook\nworkbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\nworkbook<span>.</span>sheetnames\nsheet <span>=</span> workbook<span>[</span><span>\"Sheet1\"</span><span>]</span>\n<span>print</span><span>(</span>sheet<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"获取表格的尺寸大小\"> 获取表格的尺寸大小</h3>\n<p>这里所说的尺寸大小，指的是 Excel 表格中的数据有几行几列，针对的是不同的 Sheet 而言。</p>\n<div><pre><code>sheet<span>.</span>dimensions\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"获取最大行、最大列\"> 获取最大行、最大列</h3>\n<p>注意：获取到的最大行与最大列都是基于起始索引 1 计算的。</p>\n<div><pre><code>sheet<span>.</span>max_row     <span># 最大行</span>\nsheet<span>.</span>max_column  <span># 最大列</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"获取表格内某个格子的数据\"> 获取表格内某个格子的数据</h3>\n<ul>\n<li><code>sheet[&quot;A1&quot;]</code> 方式</li>\n</ul>\n<div><pre><code><span>\"\"\"\nworkbook.active 打开激活的表格；\nsheet[\"A1\"] 获取A1格子的数据；\ncell.value 获取格子中的值；\n\"\"\"</span>\n\nworkbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\nsheet <span>=</span> workbook<span>.</span>active\n\ncell1 <span>=</span> sheet<span>[</span><span>\"A1\"</span><span>]</span>\ncell2 <span>=</span> sheet<span>[</span><span>\"C11\"</span><span>]</span>\n<span>print</span><span>(</span>cell1<span>.</span>value<span>,</span> cell2<span>.</span>value<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><ul>\n<li><code>sheet.cell(row=, column=)</code> 方式，这种方式更简单</li>\n</ul>\n<div><pre><code>workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\nsheet <span>=</span> workbook<span>.</span>active\n\ncell1 <span>=</span> sheet<span>.</span>cell<span>(</span>row<span>=</span><span>1</span><span>,</span>column<span>=</span><span>1</span><span>)</span>\ncell2 <span>=</span> sheet<span>.</span>cell<span>(</span>row<span>=</span><span>11</span><span>,</span>column<span>=</span><span>3</span><span>)</span>\n<span>print</span><span>(</span>cell1<span>.</span>value<span>,</span> cell2<span>.</span>value<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"获取某个单元格的行数、列数、坐标\"> 获取某个单元格的行数、列数、坐标</h3>\n<div><pre><code><span>\"\"\"\n.row 获取某个格子的行数；\n.columns 获取某个格子的列数；\n.corordinate 获取某个格子的坐标；\n\"\"\"</span>\n\nworkbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\nsheet <span>=</span> workbook<span>.</span>active\n\ncell1 <span>=</span> sheet<span>[</span><span>\"A1\"</span><span>]</span>\ncell2 <span>=</span> sheet<span>[</span><span>\"C11\"</span><span>]</span>\n<span>print</span><span>(</span>cell1<span>.</span>value<span>,</span> cell1<span>.</span>row<span>,</span> cell1<span>.</span>column<span>,</span> cell1<span>.</span>coordinate<span>)</span>\n<span>print</span><span>(</span>cell2<span>.</span>value<span>,</span> cell2<span>.</span>row<span>,</span> cell2<span>.</span>column<span>,</span> cell2<span>.</span>coordinate<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id=\"获取一系列单元格\"> 获取一系列单元格</h3>\n<ul>\n<li><code>sheet[]</code> 方式</li>\n</ul>\n<div><pre><code>workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\nsheet <span>=</span> workbook<span>.</span>active\n\n<span># 获取 A1:C2 区域的值</span>\ncells <span>=</span> sheet<span>[</span><span>\"A1:C2\"</span><span>]</span>\n<span>print</span><span>(</span>cells<span>)</span>\n<span>for</span> row <span>in</span> cells<span>:</span>\n    <span>for</span> col <span>in</span> row<span>:</span>\n        <span>print</span><span>(</span>col<span>.</span>value<span>)</span>\n\n<span># 如果我们只想获取\"A列\"，或者获取\"A-C列\"，可以采取如下方式：</span>\n<span># sheet[\"A\"]    --- 获取 A 列的数据</span>\n<span># sheet[\"A:C\"]  --- 获取 A,B,C 三列的数据</span>\n<span># sheet[5]      --- 获取第 5 行的数据</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><ul>\n<li><code>.iter_rows()</code> 和 <code>.iter_cols()</code> 方式</li>\n</ul>\n<div><pre><code>workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\nsheet <span>=</span> workbook<span>.</span>active\n\n<span># 按行获取值</span>\n<span>for</span> row_item <span>in</span> sheet<span>.</span>iter_rows<span>(</span>min_row<span>=</span><span>2</span><span>,</span> max_row<span>=</span><span>5</span><span>,</span> min_col<span>=</span><span>1</span><span>,</span> max_col<span>=</span><span>2</span><span>)</span><span>:</span>\n    <span>for</span> col_item <span>in</span> row_item<span>:</span>\n        <span>print</span><span>(</span>col_item<span>.</span>value<span>)</span>\n\n<span># 按列获取值</span>\n<span>for</span> col_item <span>in</span> sheet<span>.</span>iter_cols<span>(</span>min_row<span>=</span><span>2</span><span>,</span> max_row<span>=</span><span>5</span><span>,</span> min_col<span>=</span><span>1</span><span>,</span> max_col<span>=</span><span>2</span><span>)</span><span>:</span>\n    <span>for</span> row_item <span>in</span> col_item<span>:</span>\n        <span>print</span><span>(</span>row_item<span>.</span>value<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><ul>\n<li><code>sheet.rows</code> 获取所有行</li>\n</ul>\n<div><pre><code>workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\nsheet <span>=</span> workbook<span>.</span>active\n\n<span>for</span> row_item <span>in</span> sheet<span>.</span>rows<span>:</span>\n    <span>print</span><span>(</span>row_item<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"常用写入-api\"> 常用写入 API</h2>\n<h3 id=\"向指定单元格写入数据并保存\"> 向指定单元格写入数据并保存</h3>\n<div><pre><code><span>\"\"\"\n注意：下方代码将\"A1\"单元格的数据改为了\"哈喽\"，并另存为\"哈喽.xlsx\"文件。\n如果我们保存的时候，不修改表名，相当于直接修改源文件。\n\"\"\"</span>\n\nworkbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\nsheet <span>=</span> workbook<span>.</span>active\n\nsheet<span>[</span><span>\"A1\"</span><span>]</span> <span>=</span> <span>\"哈喽\"</span>  <span># 这句代码也可以改为 cell = sheet[\"A1\"] cell.value = \"哈喽\"</span>\nworkbook<span>.</span>save<span>(</span>filename<span>=</span><span>\"哈喽.xlsx\"</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"向表格中插入行数据\"> 向表格中插入行数据</h3>\n<ul>\n<li>使用 <code>.append()</code> 方法：会在表格已有的数据后面，追加新数据（按行插入）；</li>\n<li>这个操作很有用，爬虫得到的数据，可以使用该方式保存成 Excel 文件。</li>\n</ul>\n<div><pre><code><span>\"\"\"\n下方代码会将 data 中的数据逐行追加到原表格数据后面\n\"\"\"</span>\n\nworkbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\nsheet <span>=</span> workbook<span>.</span>active\n\ndata <span>=</span> <span>[</span>\n    <span>[</span><span>\"唐僧\"</span><span>,</span> <span>\"男\"</span><span>,</span> <span>\"180cm\"</span><span>]</span><span>,</span>\n    <span>[</span><span>\"孙悟空\"</span><span>,</span> <span>\"男\"</span><span>,</span> <span>\"188cm\"</span><span>]</span><span>,</span>\n    <span>[</span><span>\"猪八戒\"</span><span>,</span> <span>\"男\"</span><span>,</span> <span>\"175cm\"</span><span>]</span><span>,</span>\n    <span>[</span><span>\"沙僧\"</span><span>,</span> <span>\"男\"</span><span>,</span> <span>\"176cm\"</span><span>]</span>\n<span>]</span>\n<span>for</span> row <span>in</span> data<span>:</span>\n    sheet<span>.</span>append<span>(</span>row<span>)</span>\nworkbook<span>.</span>save<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id=\"使用-excel-函数公式-很有用\"> 使用 Excel 函数公式(很有用)</h3>\n<div><pre><code><span>\"\"\"\n这是在 Excel 中输入的公式：\n=IF(RIGHT(C2,2)=\"cm\",C2,SUBSTITUTE(C2,\"m\",\"\")*100&amp;\"cm\")\n\"\"\"</span>\n\nworkbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\nsheet <span>=</span> workbook<span>.</span>active\n\nsheet<span>[</span><span>\"D1\"</span><span>]</span> <span>=</span> <span>\"标准身高\"</span>\n<span>for</span> i <span>in</span> <span>range</span><span>(</span><span>2</span><span>,</span> <span>16</span><span>)</span><span>:</span>\n    sheet<span>[</span><span>\"D{}\"</span><span>.</span><span>format</span><span>(</span>i<span>)</span><span>]</span> <span>=</span> <span>'=IF(RIGHT(C{},2)=\"cm\",C{},SUBSTITUTE(C{},\"m\",\"\")*100&amp;\"cm\")'</span><span>.</span><span>format</span><span>(</span>i<span>,</span> i<span>,</span> i<span>)</span>\nworkbook<span>.</span>save<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id=\"插入空行和空列\"> 插入空行和空列</h3>\n<p>使用 <code>.insert_cols()</code> 和 <code>.insert_rows()</code> 方法：</p>\n<ul>\n<li><code>.insert_cols(idx=数字编号, amount=要插入的列数)</code>，插入的位置是在 idx 列数的左侧插入；</li>\n<li><code>.insert_rows(idx=数字编号, amount=要插入的行数)</code>，插入的位置是在 idx 行数的下方插入。</li>\n</ul>\n<div><pre><code>workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\nsheet <span>=</span> workbook<span>.</span>active\n\nsheet<span>.</span>insert_cols<span>(</span>idx<span>=</span><span>4</span><span>,</span>amount<span>=</span><span>2</span><span>)</span>\nsheet<span>.</span>insert_rows<span>(</span>idx<span>=</span><span>5</span><span>,</span>amount<span>=</span><span>4</span><span>)</span>\nworkbook<span>.</span>save<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"删除指定行和列\"> 删除指定行和列</h3>\n<p>使用 <code>.delete_rows()</code> 和 <code>.delete_cols()</code> 方法：</p>\n<ul>\n<li><code>.delete_rows(idx=数字编号, amount=要删除的行数)</code></li>\n<li><code>.delete_cols(idx=数字编号, amount=要删除的列数)</code></li>\n</ul>\n<div><pre><code>workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\nsheet <span>=</span> workbook<span>.</span>active\n\n<span># 删除第一列，第一行</span>\nsheet<span>.</span>delete_cols<span>(</span>idx<span>=</span><span>1</span><span>)</span>\nsheet<span>.</span>delete_rows<span>(</span>idx<span>=</span><span>1</span><span>)</span>\nworkbook<span>.</span>save<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"移动指定单元格\"> 移动指定单元格</h3>\n<p>使用 <code>.move_range(&quot;数据区域&quot;,rows=,cols=)</code> 方法：正整数为向下或向右、负整数为向左或向上。</p>\n<div><pre><code><span># 向左移动两列，向下移动两行</span>\nsheet<span>.</span>move_range<span>(</span><span>\"C1:D4\"</span><span>,</span> rows<span>=</span><span>2</span><span>,</span> cols<span>=</span><span>-</span><span>1</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"创建新的-sheet-表\"> 创建新的 Sheet 表</h3>\n<p>使用 <code>.create_sheet(&quot;新的Sheet名&quot;)</code> 方法。</p>\n<div><pre><code>workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\nsheet <span>=</span> workbook<span>.</span>active\n\nworkbook<span>.</span>create_sheet<span>(</span><span>\"一个新的Sheet\"</span><span>)</span>\n<span>print</span><span>(</span>workbook<span>.</span>sheetnames<span>)</span>\nworkbook<span>.</span>save<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"删除指定-sheet-表\"> 删除指定 Sheet 表</h3>\n<p>使用 <code>.remove(&quot;Sheet名&quot;)</code> 方法。</p>\n<div><pre><code>workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\nsheet <span>=</span> workbook<span>.</span>active\n<span>print</span><span>(</span>workbook<span>.</span>sheetnames<span>)</span>\n\n<span># 这个相当于通过名字来激活指定 Sheet 表，激活状态下，才可以操作</span>\nsheet <span>=</span> workbook<span>[</span><span>'一个新的Sheet'</span><span>]</span>\nworkbook<span>.</span>remove<span>(</span>sheet<span>)</span>\n\n<span>print</span><span>(</span>workbook<span>.</span>sheetnames<span>)</span>\nworkbook<span>.</span>save<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"复制一个-sheet-表到另外一份-excel\"> 复制一个 Sheet 表到另外一份 Excel</h3>\n<p>使用 <code>.copy_worksheet()</code> 方法：复制某个 Excel 表中的 Sheet 表，然后将文件存储到另外一个 Excel 中（追加到最后）。</p>\n<div><pre><code>workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>\"test_src.xlsx\"</span><span>)</span>\nsheet <span>=</span> workbook<span>.</span>active\n<span>print</span><span>(</span><span>\"test_src.xlsx 中有这几个 Sheet 表：\"</span><span>,</span> workbook<span>.</span>sheetnames<span>)</span>\n\nsheet <span>=</span> workbook<span>[</span><span>'姓名'</span><span>]</span>  \nworkbook<span>.</span>copy_worksheet<span>(</span>sheet<span>)</span>\nworkbook<span>.</span>save<span>(</span>filename<span>=</span><span>\"test_dst.xlsx\"</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"修改-sheet-表的名称\"> 修改 Sheet 表的名称</h3>\n<p>使用 <code>.title = &quot;新的sheet表名&quot;</code>。</p>\n<div><pre><code>workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\nsheet <span>=</span> workbook<span>.</span>active\n<span>print</span><span>(</span>sheet<span>)</span>\n\nsheet<span>.</span>title <span>=</span> <span>\"我是修改后的sheet名\"</span>\n<span>print</span><span>(</span>sheet<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"创建新的-excel-文件\"> 创建新的 Excel 文件</h3>\n<div><pre><code><span>from</span> openpyxl <span>import</span> Workbook\n\nworkbook <span>=</span> Workbook<span>(</span><span>)</span>\nsheet <span>=</span> workbook<span>.</span>active\nsheet<span>.</span>title <span>=</span> <span>\"表格1\"</span>\nworkbook<span>.</span>save<span>(</span>filename<span>=</span><span>\"新建的Excel\"</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"冻结窗口\"> 冻结窗口</h3>\n<blockquote>\n<p>冻结窗口以后，滑动垂直/水平滚动条，该单元格的位置不会改变。</p>\n</blockquote>\n<p>使用 <code>.freeze_panes = &quot;单元格&quot;</code> 方法：需要确保指定的单元格不在第一行，因为 <code>freeze_panes</code> 将冻结给定单元格上方的行和左侧的列。</p>\n<div><pre><code><span>\"\"\"\nsheet.freeze_panes = \"B1\"  # 冻结第一列\nsheet.freeze_panes = \"A2\"  # 冻结第一行\nsheet.freeze_panes = \"B2\"  # 同时冻结第一行和第一列\n\"\"\"</span>\n\nworkbook<span>=</span>load_workbook<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\nsheet <span>=</span> workbook<span>.</span>active\n\nsheet<span>.</span>freeze_panes <span>=</span> <span>\"A2\"</span>  <span># 冻结第一行</span>\nworkbook<span>.</span>save<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"给表格添加筛选器\"> 给表格添加筛选器</h3>\n<p>使用 <code>sheet.auto_filter.ref</code> 方法。</p>\n<ul>\n<li><code>.auto_filter.ref = sheet.dimension</code>：给所有字段添加筛选器；</li>\n<li><code>.auto_filter.ref = &quot;A1&quot;</code>：给 A1 这个格子添加筛选器，就是给第一列添加筛选器。</li>\n</ul>\n<div><pre><code>workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\nsheet <span>=</span> workbook<span>.</span>active\n\nsheet<span>.</span>auto_filter<span>.</span>ref <span>=</span> sheet<span>[</span><span>\"A1\"</span><span>]</span>\nworkbook<span>.</span>save<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"常用格式化-api\"> 常用格式化 API</h2>\n<h3 id=\"修改字体样式\"> 修改字体样式</h3>\n<ul>\n<li><code>Font(name=字体名称, size=字体大小, bold=是否加粗, italic=是否斜体, color=字体颜色)</code></li>\n</ul>\n<p>其中，color 是 RGB 的 16 进制表示。</p>\n<div><pre><code><span>from</span> openpyxl<span>.</span>styles <span>import</span> Font\n<span>from</span> openpyxl <span>import</span> load_workbook\n\n\nworkbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\nsheet <span>=</span> workbook<span>.</span>active\ncell <span>=</span> sheet<span>[</span><span>\"A1\"</span><span>]</span>\nfont <span>=</span> Font<span>(</span>name<span>=</span><span>\"微软雅黑\"</span><span>,</span>size<span>=</span><span>20</span><span>,</span>bold<span>=</span><span>True</span><span>,</span>italic<span>=</span><span>True</span><span>,</span>color<span>=</span><span>\"FF0000\"</span><span>)</span>\ncell<span>.</span>font <span>=</span> font\nworkbook<span>.</span>save<span>(</span>filename <span>=</span> <span>\"花园.xlsx\"</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"获取单元格的字体样式\"> 获取单元格的字体样式</h3>\n<div><pre><code><span>from</span> openpyxl<span>.</span>styles <span>import</span> Font\n<span>from</span> openpyxl <span>import</span> load_workbook\n\n\nworkbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\nsheet <span>=</span> workbook<span>.</span>active\ncell <span>=</span> sheet<span>[</span><span>\"A2\"</span><span>]</span>\nfont <span>=</span> cell<span>.</span>font\n<span>print</span><span>(</span>font<span>.</span>name<span>,</span> font<span>.</span>size<span>,</span> font<span>.</span>bold<span>,</span> font<span>.</span>italic<span>,</span> font<span>.</span>color<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"设置对齐样式\"> 设置对齐样式</h3>\n<ul>\n<li><code>Alignment(horizontal=水平对齐模式, vertical=垂直对齐模式, text_rotation=旋转角度, wrap_text=是否自动换行)</code>\n<ul>\n<li>水平对齐模式：'distributed'，'justify'，'center'，'leftfill'， 'centerContinuous'，'right'，'general'。</li>\n<li>垂直对齐模式：'bottom'，'distributed'，'justify'，'center'，'top'。</li>\n</ul>\n</li>\n</ul>\n<div><pre><code><span>from</span> openpyxl<span>.</span>styles <span>import</span> Alignment\n<span>from</span> openpyxl <span>import</span> load_workbook\n\n\nworkbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\nsheet <span>=</span> workbook<span>.</span>active\ncell <span>=</span> sheet<span>[</span><span>\"A1\"</span><span>]</span>\nalignment <span>=</span> Alignment<span>(</span>horizontal<span>=</span><span>\"center\"</span><span>,</span> vertical<span>=</span><span>\"center\"</span><span>,</span> text_rotation<span>=</span><span>45</span><span>,</span> wrap_text<span>=</span><span>True</span><span>)</span>\ncell<span>.</span>alignment <span>=</span> alignment\nworkbook<span>.</span>save<span>(</span>filename <span>=</span><span>\"test.xlsx\"</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"设置边框样式\"> 设置边框样式</h3>\n<ul>\n<li><code>Side(style=边线样式, color=边线颜色)</code> 和 <code>Border(left=左边线样式, right=右边线样式, top=上边线样式, bottom=下边线样式)</code>\n<ul>\n<li>style 参数：'double', 'mediumDashDotDot', 'slantDashDot', 'dashDotDot', 'dotted', 'hair', 'mediumDashed, 'dashed', 'dashDot', 'thin', 'mediumDashDot', 'medium', 'thick'</li>\n</ul>\n</li>\n</ul>\n<div><pre><code><span>from</span> openpyxl<span>.</span>styles <span>import</span> Side<span>,</span> Border\n<span>from</span> openpyxl <span>import</span> load_workbook\n\n\nworkbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\nsheet <span>=</span> workbook<span>.</span>active\ncell <span>=</span> sheet<span>[</span><span>\"D6\"</span><span>]</span>\nside1 <span>=</span> Side<span>(</span>style<span>=</span><span>\"thin\"</span><span>,</span> color<span>=</span><span>\"FF0000\"</span><span>)</span>\nside2 <span>=</span> Side<span>(</span>style<span>=</span><span>\"thick\"</span><span>,</span> color<span>=</span><span>\"FFFF00\"</span><span>)</span>\nborder <span>=</span> Border<span>(</span>left<span>=</span>side1<span>,</span> right<span>=</span>side1<span>,</span> top<span>=</span>side2<span>,</span> bottom<span>=</span>side2<span>)</span>\ncell<span>.</span>border <span>=</span> border\nworkbook<span>.</span>save<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id=\"设置填充样式\"> 设置填充样式</h3>\n<ul>\n<li><code>PatternFill(fill_type=填充样式，fgColor=填充颜色）</code></li>\n<li><code>GradientFill(stop=(渐变颜色1，渐变颜色2……))</code></li>\n</ul>\n<div><pre><code><span>from</span> openpyxl<span>.</span>styles <span>import</span> PatternFill<span>,</span>GradientFill\n<span>from</span> openpyxl <span>import</span> load_workbook\n\n\nworkbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\nsheet <span>=</span> workbook<span>.</span>active\ncell_b9 <span>=</span> sheet<span>[</span><span>\"B9\"</span><span>]</span>\npattern_fill <span>=</span> PatternFill<span>(</span>fill_type<span>=</span><span>\"solid\"</span><span>,</span>fgColor<span>=</span><span>\"99ccff\"</span><span>)</span>\ncell_b9<span>.</span>fill <span>=</span> pattern_fill\ncell_b10 <span>=</span> sheet<span>[</span><span>\"B10\"</span><span>]</span>\ngradient_fill <span>=</span> GradientFill<span>(</span>stop<span>=</span><span>(</span><span>\"FFFFFF\"</span><span>,</span><span>\"99ccff\"</span><span>,</span><span>\"000000\"</span><span>)</span><span>)</span>\ncell_b10<span>.</span>fill <span>=</span> gradient_fill\nworkbook<span>.</span>save<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id=\"设置行高和列宽\"> 设置行高和列宽</h3>\n<ul>\n<li><code>.row_dimensions[行编号].height = 行高</code></li>\n<li><code>.column_dimensions[列编号].width = 列宽</code></li>\n</ul>\n<div><pre><code>workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\nsheet <span>=</span> workbook<span>.</span>active\n<span># 设置第1行的高度</span>\nsheet<span>.</span>row_dimensions<span>[</span><span>1</span><span>]</span><span>.</span>height <span>=</span> <span>50</span>\n<span># 设置B列的宽度</span>\nsheet<span>.</span>column_dimensions<span>[</span><span>\"B\"</span><span>]</span><span>.</span>width <span>=</span> <span>20</span>\nworkbook<span>.</span>save<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\n\n<span>\"\"\"\n也可以设置整个 Sheet 表的行高和列宽：\nsheet.row_dimensions.height = 50\nsheet.column_dimensions.width = 30\n\"\"\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id=\"合并单元格\"> 合并单元格</h3>\n<ul>\n<li><code>.merge_cells(待合并的格子编号)</code></li>\n<li><code>.merge_cells(start_row=起始行号，start_column=起始列号，end_row=结束行号，end_column=结束列号)</code></li>\n</ul>\n<div><pre><code>workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\nsheet <span>=</span> workbook<span>.</span>active\nsheet<span>.</span>merge_cells<span>(</span><span>\"C1:D2\"</span><span>)</span>\nsheet<span>.</span>merge_cells<span>(</span>start_row<span>=</span><span>7</span><span>,</span> start_column<span>=</span><span>1</span><span>,</span> end_row<span>=</span><span>8</span><span>,</span> end_column<span>=</span><span>3</span><span>)</span>\nworkbook<span>.</span>save<span>(</span>filename<span>=</span><span>\"test.xlsx\"</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>也可以取消合并单元格，用法一致。</p>\n<ul>\n<li><code>.unmerge_cells(待合并的格子编号)</code></li>\n<li><code>.unmerge_cells(start_row=起始行号，start_column=起始列号，end_row=结束行号，end_column=结束列号)</code></li>\n</ul>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://openpyxl.readthedocs.io/en/stable/\" target=\"_blank\" rel=\"noopener noreferrer\">openpyxl</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2021-11-19T03:27:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "使用 smtplib 发送电子邮件",
      "url": "https://www.fedbook.cn/backend-knowledge/python/python-lib-smtplib/",
      "id": "https://www.fedbook.cn/backend-knowledge/python/python-lib-smtplib/",
      "content_html": "<h1 id=\"使用-smtplib-发送电子邮件\"> 使用 smtplib 发送电子邮件</h1>\n<h2 id=\"准备\"> 准备</h2>\n<h3 id=\"_1-开启邮箱的-smtp-服务\"> 1. 开启邮箱的 SMTP 服务</h3>\n<p>这里使用第三方 SMTP 服务发送邮件，可以使用 QQ 邮箱，163，Gmail 等的 SMTP 服务，但需要做以下配置，以 QQ 邮箱为例。</p>\n<p>登录 QQ 邮箱，依次点击最上方的<strong>设置</strong> =&gt; <strong>账户</strong>，</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/qq-smtp-setting-1.png\" alt=\"QQ 邮箱设置\">\n  <p style=\"text-align: center; color: #888;\">（QQ 邮箱设置，未来界面可能会变化）</p>\n</div>\n<p>往下翻页，找到 <strong>POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV</strong> 这一版块，开启 <strong>POP3/SMTP 服务</strong>。（不同版本的 QQ 可能会不一样，总之就是找到 QQ 邮箱的「POP3/SMTP服务」开启按钮）</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/qq-smtp-setting-2.png\" alt=\"开启 POP3/SMTP 服务\">\n  <p style=\"text-align: center; color: #888;\">（开启 POP3/SMTP 服务，未来界面可能会变化）</p>\n</div>\n<p>成功开启 QQ 邮箱的 SMTP 服务后，我们会得到一串授权码，在后面的代码里，这串授权码就是我们邮箱的登录密码。开启 SMTP 服务可能需要进行手机验证，根据提示来就好。</p>\n<h3 id=\"_2-常用的邮件服务器配置\"> 2. 常用的邮件服务器配置</h3>\n<p>下面整理了常用的邮件服务器名称、地址及 SSL/非SSL 协议端口号。</p>\n<p><strong>网易 163 免费邮箱相关服务器信息：</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">服务器名称</th>\n<th style=\"text-align:center\">服务器地址</th>\n<th style=\"text-align:center\">SSL协议端口号</th>\n<th style=\"text-align:center\">非SSL协议端口号</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">IMAP</td>\n<td style=\"text-align:center\">imap.163.com</td>\n<td style=\"text-align:center\">993</td>\n<td style=\"text-align:center\">143</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SMTP</td>\n<td style=\"text-align:center\">smtp.163.com</td>\n<td style=\"text-align:center\">454/994</td>\n<td style=\"text-align:center\">25</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">POP3</td>\n<td style=\"text-align:center\">pop.163.com</td>\n<td style=\"text-align:center\">995</td>\n<td style=\"text-align:center\">110</td>\n</tr>\n</tbody>\n</table>\n<p><strong>网易 163 企业邮箱相关服务器信息：</strong>（免费企业邮箱的 smtp 服务器名及端口号为：smtp.ym.163.com / 25）</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">服务器名称</th>\n<th style=\"text-align:center\">服务器地址</th>\n<th style=\"text-align:center\">SSL协议端口号</th>\n<th style=\"text-align:center\">非SSL协议端口号</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">IMAP</td>\n<td style=\"text-align:center\">imap.qiye.163.com</td>\n<td style=\"text-align:center\">993</td>\n<td style=\"text-align:center\">143</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SMTP</td>\n<td style=\"text-align:center\">smtp.qiye.163.com</td>\n<td style=\"text-align:center\">994</td>\n<td style=\"text-align:center\">25</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">POP3</td>\n<td style=\"text-align:center\">pop.qiye.163.com</td>\n<td style=\"text-align:center\">995</td>\n<td style=\"text-align:center\">110</td>\n</tr>\n</tbody>\n</table>\n<p><strong>网易 126 免费邮箱相关服务器信息：</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">服务器名称</th>\n<th style=\"text-align:center\">服务器地址</th>\n<th style=\"text-align:center\">SSL协议端口号</th>\n<th style=\"text-align:center\">非SSL协议端口号</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">IMAP</td>\n<td style=\"text-align:center\">imap.126.com</td>\n<td style=\"text-align:center\">993</td>\n<td style=\"text-align:center\">143</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SMTP</td>\n<td style=\"text-align:center\">smtp.126.com</td>\n<td style=\"text-align:center\">465/994</td>\n<td style=\"text-align:center\">25</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">POP3</td>\n<td style=\"text-align:center\">pop.126.com</td>\n<td style=\"text-align:center\">995</td>\n<td style=\"text-align:center\">110</td>\n</tr>\n</tbody>\n</table>\n<p><strong>腾讯 QQ 免费邮箱相关服务器信息：</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">服务器名称</th>\n<th style=\"text-align:center\">服务器地址</th>\n<th style=\"text-align:center\">SSL协议端口号</th>\n<th style=\"text-align:center\">非SSL协议端口号</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">IMAP</td>\n<td style=\"text-align:center\">imap.qq.com</td>\n<td style=\"text-align:center\">993</td>\n<td style=\"text-align:center\">143</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SMTP</td>\n<td style=\"text-align:center\">smtp.qq.com</td>\n<td style=\"text-align:center\">465/587</td>\n<td style=\"text-align:center\">25</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">POP3</td>\n<td style=\"text-align:center\">pop.qq.com</td>\n<td style=\"text-align:center\">995</td>\n<td style=\"text-align:center\">110</td>\n</tr>\n</tbody>\n</table>\n<p><strong>腾讯 QQ 企业邮箱相关服务器信息：</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">服务器名称</th>\n<th style=\"text-align:center\">服务器地址</th>\n<th style=\"text-align:center\">SSL协议端口号</th>\n<th style=\"text-align:center\">非SSL协议端口号</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">IMAP</td>\n<td style=\"text-align:center\">imap.exmail.qq.com</td>\n<td style=\"text-align:center\">993</td>\n<td style=\"text-align:center\">143</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SMTP</td>\n<td style=\"text-align:center\">smtp.exmail.qq.com</td>\n<td style=\"text-align:center\">465/587</td>\n<td style=\"text-align:center\">25</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">POP3</td>\n<td style=\"text-align:center\">pop.exmail.qq.com</td>\n<td style=\"text-align:center\">995</td>\n<td style=\"text-align:center\">110</td>\n</tr>\n</tbody>\n</table>\n<p><strong>谷歌 Gmail 邮箱相关服务器信息：</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">服务器名称</th>\n<th style=\"text-align:center\">服务器地址</th>\n<th style=\"text-align:center\">SSL协议端口号</th>\n<th style=\"text-align:center\">非SSL协议端口号</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">IMAP</td>\n<td style=\"text-align:center\">imap.gmail.com</td>\n<td style=\"text-align:center\">993</td>\n<td style=\"text-align:center\">143</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SMTP</td>\n<td style=\"text-align:center\">smtp.gmail.com</td>\n<td style=\"text-align:center\">465</td>\n<td style=\"text-align:center\">25</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">POP3</td>\n<td style=\"text-align:center\">pop.gmail.com</td>\n<td style=\"text-align:center\">995</td>\n<td style=\"text-align:center\">110</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"发送纯文本邮件\"> 发送纯文本邮件</h2>\n<blockquote>\n<p>下面所有示例使用 QQ 邮箱，注意 QQ 邮箱 SMTP 服务器地址：smtp.qq.com，ssl，端口：465。</p>\n</blockquote>\n<p>以下实例你需要修改：发件人邮箱（你的 QQ 邮箱），密码，收件人邮箱（可发给自己）。</p>\n<div><pre><code><span>#!/usr/bin/env python</span>\n<span># -*- coding: utf-8 -*-</span>\n\n<span>import</span> time\n<span>import</span> smtplib\n<span>from</span> email<span>.</span>header <span>import</span> Header\n<span>from</span> email<span>.</span>mime<span>.</span>text <span>import</span> MIMEText\n\n<span># ----- 需要修改的参数 -----</span>\n<span># email相关</span>\nsender <span>=</span> <span>'fedbook@qq.com'</span>\npassword <span>=</span> <span>'******'</span>\nsmtp_server <span>=</span> <span>'smtp.qq.com'</span>\nsmtp_port <span>=</span> <span>465</span>\nreceivers <span>=</span> <span>[</span><span>'recever1@163.com'</span><span>,</span> <span>'recever2@qq.com'</span><span>]</span>\n<span># ------------------------</span>\n\n\n<span>def</span> <span>send_email</span><span>(</span>subject<span>,</span> detail<span>)</span><span>:</span>\n    now_time <span>=</span> time<span>.</span>strftime<span>(</span><span>'%Y-%m-%d %H:%M:%S'</span><span>)</span>\n    mail_msg <span>=</span> <span>\"\"\"\n    时间：{now_time}\n    详情：{detail}\n    \"\"\"</span><span>.</span><span>format</span><span>(</span>subject<span>=</span>subject<span>,</span> now_time<span>=</span>now_time<span>,</span> detail<span>=</span>detail<span>)</span>\n\n    msg <span>=</span> MIMEText<span>(</span>mail_msg<span>,</span> <span>'plain'</span><span>,</span> <span>'utf-8'</span><span>)</span>\n    msg<span>[</span><span>'From'</span><span>]</span> <span>=</span> Header<span>(</span><span>'fedbook汇报人 &lt;%s>'</span> <span>%</span> sender<span>,</span> <span>'utf-8'</span><span>)</span>\n    msg<span>[</span><span>'To'</span><span>]</span> <span>=</span> Header<span>(</span><span>'fedbook订阅者'</span><span>,</span> <span>'utf-8'</span><span>)</span>\n    msg<span>[</span><span>'Subject'</span><span>]</span> <span>=</span> Header<span>(</span>subject<span>,</span> <span>'utf-8'</span><span>)</span>\n\n    <span>try</span><span>:</span>\n        smtp <span>=</span> smtplib<span>.</span>SMTP_SSL<span>(</span>smtp_server<span>,</span> smtp_port<span>)</span>\n        <span># smtp.set_debuglevel(1)    # 打印和SMTP服务器交互的所有信息</span>\n        smtp<span>.</span>login<span>(</span>sender<span>,</span> password<span>)</span>\n        smtp<span>.</span>sendmail<span>(</span>sender<span>,</span> receivers<span>,</span> msg<span>.</span>as_string<span>(</span><span>)</span><span>)</span>\n        smtp<span>.</span>quit<span>(</span><span>)</span>\n        <span>print</span><span>(</span><span>'邮件发送成功'</span><span>)</span>\n    <span>except</span> smtplib<span>.</span>SMTPException <span>as</span> e<span>:</span>\n        <span>print</span><span>(</span><span>'Error: 无法发送邮件'</span><span>)</span>\n        <span>print</span><span>(</span>e<span>)</span>\n\n\n<span>if</span> __name__ <span>==</span> <span>\"__main__\"</span><span>:</span>\n    email_title <span>=</span> <span>'Python SMTP 纯文本邮件测试'</span>\n    detail <span>=</span> <span>\"\"\"\n    欢迎访问：www.fedbook.cn\n    这里是 WENYUAN 的学习小册，记录前端学习的知识体系\n    包含 HTML, CSS, JavaScript, Vue, React, 数据结构与算法, 设计模式, etc.\n    \"\"\"</span>\n    send_email<span>(</span>email_title<span>,</span> detail<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div><h2 id=\"发送-html-格式的邮件\"> 发送 HTML 格式的邮件</h2>\n<p>以下实例你需要修改：发件人邮箱（你的 QQ 邮箱），密码，收件人邮箱（可发给自己）。</p>\n<div><pre><code><span>#!/usr/bin/env python</span>\n<span># -*- coding: utf-8 -*-</span>\n\n<span>import</span> time\n<span>import</span> smtplib\n<span>from</span> email<span>.</span>header <span>import</span> Header\n<span>from</span> email<span>.</span>mime<span>.</span>text <span>import</span> MIMEText\n\n<span># ----- 需要修改的参数 -----</span>\n<span># email相关</span>\nsender <span>=</span> <span>'fedbook@qq.com'</span>\npassword <span>=</span> <span>'******'</span>\nsmtp_server <span>=</span> <span>'smtp.qq.com'</span>\nsmtp_port <span>=</span> <span>465</span>\nreceivers <span>=</span> <span>[</span><span>'recever1@163.com'</span><span>,</span> <span>'recever2@qq.com'</span><span>]</span>\n<span># ------------------------</span>\n\n\n<span>def</span> <span>send_email</span><span>(</span>subject<span>,</span> detail<span>)</span><span>:</span>\n    now_time <span>=</span> time<span>.</span>strftime<span>(</span><span>'%Y-%m-%d %H:%M:%S'</span><span>)</span>\n    mail_msg <span>=</span> <span>\"\"\"\n    &lt;h1 style='margin-top:10px;margin-bottom:10px;text-align:center'>{subject}&lt;/h1>\n    &lt;hr>\n    &lt;h2 style='margin-top:0;margin-bottom:10px'>时间&lt;/h2>\n    &lt;div style='margin-left: 40px'>{now_time}&lt;/div>\n    &lt;hr>\n    &lt;h2 style='margin-top:0;margin-bottom:10px'>详情&lt;/h2>\n    &lt;div style='margin-left: 40px'>{detail}&lt;/div>\n    &lt;hr>\n    \"\"\"</span><span>.</span><span>format</span><span>(</span>subject<span>=</span>subject<span>,</span> now_time<span>=</span>now_time<span>,</span> detail<span>=</span>detail<span>)</span>\n\n    msg <span>=</span> MIMEText<span>(</span>mail_msg<span>,</span> <span>'html'</span><span>,</span> <span>'utf-8'</span><span>)</span>\n    msg<span>[</span><span>'From'</span><span>]</span> <span>=</span> Header<span>(</span><span>'fedbook汇报人 &lt;%s>'</span> <span>%</span> sender<span>,</span> <span>'utf-8'</span><span>)</span>\n    msg<span>[</span><span>'To'</span><span>]</span> <span>=</span> Header<span>(</span><span>'fedbook订阅者'</span><span>,</span> <span>'utf-8'</span><span>)</span>\n    msg<span>[</span><span>'Subject'</span><span>]</span> <span>=</span> Header<span>(</span>subject<span>,</span> <span>'utf-8'</span><span>)</span>\n\n    <span>try</span><span>:</span>\n        smtp <span>=</span> smtplib<span>.</span>SMTP_SSL<span>(</span>smtp_server<span>,</span> smtp_port<span>)</span>\n        <span># smtp.set_debuglevel(1)    # 打印和SMTP服务器交互的所有信息</span>\n        smtp<span>.</span>login<span>(</span>sender<span>,</span> password<span>)</span>\n        smtp<span>.</span>sendmail<span>(</span>sender<span>,</span> receivers<span>,</span> msg<span>.</span>as_string<span>(</span><span>)</span><span>)</span>\n        smtp<span>.</span>quit<span>(</span><span>)</span>\n        <span>print</span><span>(</span><span>'邮件发送成功'</span><span>)</span>\n    <span>except</span> smtplib<span>.</span>SMTPException <span>as</span> e<span>:</span>\n        <span>print</span><span>(</span><span>'Error: 无法发送邮件'</span><span>)</span>\n        <span>print</span><span>(</span>e<span>)</span>\n\n\n<span>if</span> __name__ <span>==</span> <span>\"__main__\"</span><span>:</span>\n    email_title <span>=</span> <span>'Python SMTP HTML格式邮件测试'</span>\n    detail <span>=</span> <span>\"\"\"\n    &lt;div>欢迎访问：&lt;a href=\"http://www.fedbook.cn\" target=\"_blank\">www.fedbook.cn&lt;/a>&lt;/div>\n    &lt;div style='margin-bottom:5px'>这里是 WENYUAN 的学习小册，记录前端学习的知识体系。&lt;/div>\n    \"\"\"</span>\n    send_email<span>(</span>email_title<span>,</span> detail<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div><h2 id=\"发送带附件的邮件\"> 发送带附件的邮件</h2>\n<p>以下实例你需要修改：发件人邮箱（你的 QQ 邮箱），密码，收件人邮箱（可发给自己）。</p>\n<div><pre><code><span>#!/usr/bin/env python</span>\n<span># -*- coding: utf-8 -*-</span>\n\n<span>import</span> time\n<span>import</span> smtplib\n<span>from</span> email<span>.</span>header <span>import</span> Header\n<span>from</span> email<span>.</span>mime<span>.</span>text <span>import</span> MIMEText\n<span>from</span> email<span>.</span>mime<span>.</span>multipart <span>import</span> MIMEMultipart\n\n<span># ----- 需要修改的参数 -----</span>\n<span># email相关</span>\nsender <span>=</span> <span>'fedbook@qq.com'</span>\npassword <span>=</span> <span>'******'</span>\nsmtp_server <span>=</span> <span>'smtp.qq.com'</span>\nsmtp_port <span>=</span> <span>465</span>\nreceivers <span>=</span> <span>[</span><span>'recever1@163.com'</span><span>,</span> <span>'recever2@qq.com'</span><span>]</span>\n<span># ------------------------</span>\n\n\n<span>def</span> <span>send_email</span><span>(</span>subject<span>,</span> detail<span>,</span> attach_list<span>)</span><span>:</span>\n    now_time <span>=</span> time<span>.</span>strftime<span>(</span><span>'%Y-%m-%d %H:%M:%S'</span><span>)</span>\n    mail_msg <span>=</span> <span>\"\"\"\n    时间：{now_time}\n    详情：{detail}\n    \"\"\"</span><span>.</span><span>format</span><span>(</span>subject<span>=</span>subject<span>,</span> now_time<span>=</span>now_time<span>,</span> detail<span>=</span>detail<span>)</span>\n\n    <span># 创建一个带附件的实例</span>\n    msg <span>=</span> MIMEMultipart<span>(</span><span>)</span>\n    <span># msg = MIMEText(mail_msg, 'plain', 'utf-8')</span>\n    msg<span>[</span><span>'From'</span><span>]</span> <span>=</span> Header<span>(</span><span>'fedbook汇报人 &lt;%s>'</span> <span>%</span> sender<span>,</span> <span>'utf-8'</span><span>)</span>\n    msg<span>[</span><span>'To'</span><span>]</span> <span>=</span> Header<span>(</span><span>'fedbook订阅者'</span><span>,</span> <span>'utf-8'</span><span>)</span>\n    msg<span>[</span><span>'Subject'</span><span>]</span> <span>=</span> Header<span>(</span>subject<span>,</span> <span>'utf-8'</span><span>)</span>\n\n    <span># 邮件正文内容</span>\n    msg<span>.</span>attach<span>(</span>MIMEText<span>(</span>mail_msg<span>,</span> <span>'plain'</span><span>,</span> <span>'utf-8'</span><span>)</span><span>)</span>\n    <span># 构造附件，传送指定目录下的文件</span>\n    <span>for</span> att_path <span>in</span> attach_list<span>:</span>\n        att <span>=</span> MIMEText<span>(</span><span>open</span><span>(</span>att_path<span>,</span> <span>'rb'</span><span>)</span><span>.</span>read<span>(</span><span>)</span><span>,</span> <span>'base64'</span><span>,</span> <span>'utf-8'</span><span>)</span>\n        att<span>[</span><span>\"Content-Type\"</span><span>]</span> <span>=</span> <span>'application/octet-stream'</span>\n        <span># 这里的filename可以任意写，写什么名字，邮件中显示什么名字</span>\n        att<span>[</span><span>\"Content-Disposition\"</span><span>]</span> <span>=</span> <span>'attachment; filename={filename}'</span><span>.</span><span>format</span><span>(</span>filename<span>=</span>att_path<span>)</span>\n        msg<span>.</span>attach<span>(</span>att<span>)</span>\n\n    <span>try</span><span>:</span>\n        smtp <span>=</span> smtplib<span>.</span>SMTP_SSL<span>(</span>smtp_server<span>,</span> smtp_port<span>)</span>\n        <span># smtp.set_debuglevel(1)    # 打印和SMTP服务器交互的所有信息</span>\n        smtp<span>.</span>login<span>(</span>sender<span>,</span> password<span>)</span>\n        smtp<span>.</span>sendmail<span>(</span>sender<span>,</span> receivers<span>,</span> msg<span>.</span>as_string<span>(</span><span>)</span><span>)</span>\n        smtp<span>.</span>quit<span>(</span><span>)</span>\n        <span>print</span><span>(</span><span>'邮件发送成功'</span><span>)</span>\n    <span>except</span> smtplib<span>.</span>SMTPException <span>as</span> e<span>:</span>\n        <span>print</span><span>(</span><span>'Error: 无法发送邮件'</span><span>)</span>\n        <span>print</span><span>(</span>e<span>)</span>\n\n\n<span>if</span> __name__ <span>==</span> <span>\"__main__\"</span><span>:</span>\n    email_title <span>=</span> <span>'Python SMTP 带附件邮件测试'</span>\n    detail <span>=</span> <span>\"\"\"\n    欢迎访问：www.fedbook.cn\n    这里是 WENYUAN 的学习小册，记录前端学习的知识体系。\n    附件是网站源码，请查收。\n    \"\"\"</span>\n    attach_list <span>=</span> <span>[</span><span>'send_email.py'</span><span>,</span> <span>'README.md'</span><span>]</span>\n    send_email<span>(</span>email_title<span>,</span> detail<span>,</span> attach_list<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br></div></div><h2 id=\"总结\"> 总结</h2>\n<p>以上就是通过 Python SMTP 发送邮件的代码示例，一般情况下是够用了。还有一些图片 email 等特殊邮件，因为需要考虑到兼容性问题，有些邮箱默认不显示图片，个人感觉不太常用，就不整理了。</p>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://docs.python.org/3/library/smtplib.html\" title=\"smtplib -- SMTP protocol client\" target=\"_blank\" rel=\"noopener noreferrer\">smtplib</a></li>\n<li><a href=\"https://docs.python.org/zh-cn/3/library/email.html\" title=\"email -- 电子邮件与 MIME 处理包\" target=\"_blank\" rel=\"noopener noreferrer\">email</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2021-11-19T03:27:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "使用 Paramiko 执行 SSH",
      "url": "https://www.fedbook.cn/backend-knowledge/python/python-lib-paramiko/",
      "id": "https://www.fedbook.cn/backend-knowledge/python/python-lib-paramiko/",
      "content_html": "<h1 id=\"使用-paramiko-执行-ssh\"> 使用 Paramiko 执行 SSH</h1>\n<h2 id=\"关于-ssh\"> 关于 SSH</h2>\n<p>SSH 是一种网络协议，用于远程访问，并管理一个或多个设备。SSH 使用公钥加密来实现安全性。Telnet 和 SSH 之间的重要区别在于 SSH 使用加密，这意味着通过网络传输的所有 SSH 数据都可以防止未经授权的实施拦截。</p>\n<p>SSH 基于 TCP，默认端口号为 22。在终端运行 ssh 命令以连接远程服务器命令如下：</p>\n<div><pre><code><span>ssh</span> host_name@host_ip_address\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"关于-paramiko\"> 关于 Paramiko</h2>\n<p>Paramiko 是一个基于 Python 编写的、使用 SSH 协议的模块，跟 Xshell 和 Xftp 功能类似，支持加密与认证，可以上传下载和访问服务器的文件。</p>\n<p>可以利用 Paramiko 模块写服务器脚本，在本地执行，比如持续更新代码，查看日志，批量配置集群等。</p>\n<p>Paramiko 主要包含 SSHClient 和 SFTPClient 两个组件，分别用来执行命令和实现远程文件操作。</p>\n<p>由于 Paramiko 是 Python 的一个第三方库，首先需要安装它：</p>\n<div><pre><code><span>sudo</span> pip <span>install</span> paramiko\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"paramiko-用法示例\"> Paramiko 用法示例</h2>\n<p>下面是一个使用 Paramiko 连接远程设备的示例程序（<a href=\"https://github.com/wenyuan/practice-in-python/blob/main/devops-case/paramiko_example.py\" target=\"_blank\" rel=\"noopener noreferrer\"><code>paramiko_example.py</code></a>）：</p>\n<div><pre><code><span>#!/usr/bin/env python</span>\n<span># -*- coding: utf-8 -*-</span>\n\n<span>\"\"\"\n使用第三方库：paramiko\n\"\"\"</span>\n\n<span>import</span> paramiko\n<span>from</span> paramiko<span>.</span>ssh_exception <span>import</span> NoValidConnectionsError\n<span>from</span> paramiko<span>.</span>ssh_exception <span>import</span> AuthenticationException\n\n\n<span>def</span> <span>do_ssh</span><span>(</span>host<span>,</span> username<span>,</span> password<span>,</span> commands<span>)</span><span>:</span>\n    client <span>=</span> paramiko<span>.</span>SSHClient<span>(</span><span>)</span>\n    <span># 如果是之前没有连接过的 ip，会出现选择 yes 或者 no 的操作</span>\n    <span># 自动选择 yes</span>\n    client<span>.</span>set_missing_host_key_policy<span>(</span>paramiko<span>.</span>AutoAddPolicy<span>(</span><span>)</span><span>)</span>\n    <span>try</span><span>:</span>\n        client<span>.</span>connect<span>(</span>hostname<span>=</span>host<span>,</span> port<span>=</span><span>22</span><span>,</span> username<span>=</span>username<span>,</span> password<span>=</span>password<span>)</span>\n    <span>except</span> NoValidConnectionsError<span>:</span>\n        <span>print</span><span>(</span><span>'{host} 无法连接'</span><span>.</span><span>format</span><span>(</span>host<span>=</span>host<span>)</span><span>)</span>\n    <span>except</span> AuthenticationException<span>:</span>\n        <span>print</span><span>(</span><span>'{host} 密码错误'</span><span>.</span><span>format</span><span>(</span>host<span>=</span>host<span>)</span><span>)</span>\n    <span>except</span> Exception <span>as</span> e<span>:</span>\n        <span>print</span><span>(</span><span>repr</span><span>(</span>e<span>)</span><span>)</span>\n    <span>else</span><span>:</span>\n        <span># 执行操作</span>\n        <span>for</span> command <span>in</span> commands<span>:</span>\n            stdin<span>,</span> stdout<span>,</span> stderr <span>=</span> client<span>.</span>exec_command<span>(</span>command<span>)</span>\n            <span># 获取命令执行的结果</span>\n            <span>for</span> line <span>in</span> stdout<span>:</span>\n                <span>print</span><span>(</span>line<span>.</span>strip<span>(</span><span>'\\n'</span><span>)</span><span>)</span>\n    <span>finally</span><span>:</span>\n        <span># 关闭连接</span>\n        client<span>.</span>close<span>(</span><span>)</span>\n\n\n<span>if</span> __name__ <span>==</span> <span>\"__main__\"</span><span>:</span>\n    host <span>=</span> <span>'192.168.10.x'</span>\n    username <span>=</span> <span>'admin'</span>\n    password <span>=</span> <span>'******'</span>\n    commands <span>=</span> <span>[</span><span>'hostname'</span><span>,</span> <span>'ls'</span><span>]</span>\n    do_ssh<span>(</span>host<span>,</span> username<span>,</span> password<span>,</span> commands<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><p>Paramiko 模块里上面代码中用到的方法介绍：</p>\n<ul>\n<li><code>set_missing_host_key_policy(policy)</code>：设置连接的远程主机没有本地主机密钥时的策略。目前支持三种：RejectPolicy（the default），AutoAddPolicy，WarningPolicy</li>\n<li><code>exec_command()</code>：该函数是将服务器执行完的结果一次性返回给你。</li>\n<li><code>invoke_shell()</code>：也可以使用该函数来执行命令，它类似 shell 终端，可以将执行结果分批次返回，看到任务的执行情况，不会因为执行一个很长的脚本而不知道是否执行成功。</li>\n</ul>\n<h2 id=\"总结\"> 总结</h2>\n<p>上面的示例程序我们通过 paramiko 模块连接了一台远程服务器，执行命令后打印了输出结果。实际环境中在建立 SSH 连接后，我们可以在远程设备上执行所需的任何配置或操作。</p>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"http://www.paramiko.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Paramiko</a></li>\n<li><a href=\"https://github.com/paramiko/paramiko/tree/master/demos\" target=\"_blank\" rel=\"noopener noreferrer\">Paramiko Demos</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2021-11-19T03:27:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "使用 telnetlib 执行 Telnet",
      "url": "https://www.fedbook.cn/backend-knowledge/python/python-lib-telnetlib/",
      "id": "https://www.fedbook.cn/backend-knowledge/python/python-lib-telnetlib/",
      "content_html": "<h1 id=\"使用-telnetlib-执行-telnet\"> 使用 telnetlib 执行 Telnet</h1>\n<h2 id=\"关于-telnet\"> 关于 Telnet</h2>\n<p>Telnet 是一种允许用户与远程服务器通信的网络协议，它经常被网络管理员用来远程访问和管理设备。在终端中运行 Telnet 命令，并给出远程服务器的 IP 地址或主机名，即可访问远程设备。</p>\n<p>Telnet 基于 TCP，默认端口号为 23。首先需要确保它已安装在我们的系统上，如果没有安装，运行以下命令进行安装：</p>\n<div><pre><code><span>sudo</span> <span>apt-get</span> <span>install</span> telnetd\n</code></pre>\n<div><span>1</span><br></div></div><p>要使用简单的终端运行 Telnet，只需要输入以下命令：</p>\n<div><pre><code>telnet ip_address_your_remote_server\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"python-实现-telnet-功能\"> Python 实现 Telnet 功能</h2>\n<p>首先需要用到 Python 的 telnetlib 模块，它是一个标准库，无需另外安装。</p>\n<p>下面是一个使用 Telnet 连接远程设备的示例程序（<a href=\"https://github.com/wenyuan/practice-in-python/blob/main/devops-case/telnet_example.py\" target=\"_blank\" rel=\"noopener noreferrer\"><code>telnet_example.py</code></a>）：</p>\n<div><pre><code><span>#!/usr/bin/env python</span>\n<span># -*- coding: utf-8 -*-</span>\n\n<span>import</span> telnetlib\n<span>import</span> time\n\n\n<span>def</span> <span>do_telnet</span><span>(</span>host<span>,</span> username<span>,</span> password<span>,</span> commands<span>)</span><span>:</span>\n    <span>try</span><span>:</span>\n        tn <span>=</span> telnetlib<span>.</span>Telnet<span>(</span>host<span>,</span> port<span>=</span><span>23</span><span>,</span> timeout<span>=</span><span>10</span><span>)</span>\n    <span>except</span><span>:</span>\n        <span>print</span><span>(</span><span>'{host} 网络连接失败'</span><span>.</span><span>format</span><span>(</span>host<span>=</span>host<span>)</span><span>)</span>\n        <span>return</span> <span>False</span>\n\n    <span># 输入登录用户名</span>\n    <span># 这里要设置下 timeout，否则会一直在等待关键字符出现，直至默认的超时时间（很久）</span>\n    tn<span>.</span>read_until<span>(</span><span>'Username:'</span><span>,</span> timeout<span>=</span><span>2</span><span>)</span>\n    tn<span>.</span>write<span>(</span>username <span>+</span> <span>'\\n'</span><span>)</span>\n\n    <span># 输入登录密码</span>\n    tn<span>.</span>read_until<span>(</span><span>'Password:'</span><span>,</span> timeout<span>=</span><span>2</span><span>)</span>\n    tn<span>.</span>write<span>(</span>password <span>+</span> <span>'\\n'</span><span>)</span>\n\n    time<span>.</span>sleep<span>(</span><span>2</span><span>)</span>\n    res <span>=</span> tn<span>.</span>read_very_eager<span>(</span><span>)</span>\n    <span>if</span> <span>'Local authentication is rejected'</span> <span>in</span> res<span>:</span>\n        <span>print</span><span>(</span><span>'{host} 登录失败，用户名或密码错误'</span><span>.</span><span>format</span><span>(</span>host<span>=</span>host<span>)</span><span>)</span>\n        <span>return</span> <span>False</span>\n\n    <span># 登录完毕后执行命令</span>\n    <span>for</span> command <span>in</span> commands<span>:</span>\n        tn<span>.</span>write<span>(</span>command <span>+</span> <span>'\\n'</span><span>)</span>\n        time<span>.</span>sleep<span>(</span><span>2</span><span>)</span>\n        res <span>=</span> tn<span>.</span>read_very_eager<span>(</span><span>)</span>\n        <span>print</span><span>(</span>res<span>)</span>\n\n    <span># 执行完毕后，终止 Telnet 连接（或输入 exit 退出）</span>\n    tn<span>.</span>close<span>(</span><span>)</span>\n\n\n<span>if</span> __name__ <span>==</span> <span>\"__main__\"</span><span>:</span>\n    host <span>=</span> <span>'192.168.10.x'</span>\n    username <span>=</span> <span>'admin'</span>\n    password <span>=</span> <span>'******'</span>\n    commands <span>=</span> <span>[</span><span>'display version'</span><span>,</span> <span>'display interface description Vlanif'</span><span>]</span>\n    do_telnet<span>(</span>host<span>,</span> username<span>,</span> password<span>,</span> commands<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><p>telnetlib 模块里上面代码中用到的方法介绍：</p>\n<ul>\n<li><code>write()</code>：使用该方法向服务端发送命令，注意每个命令后要跟上换行符（<code>\\n</code>）。</li>\n<li><code>read_until()</code>：当结果中存在想要的信息时返回。</li>\n<li><code>read_very_eager()</code>：返回缓冲区中所有可用的数据（上次获取之后本次获取之前的所有输入输出），这里要设置延时 <code>time.sleep(2)</code>，才能保证数据读取完毕。</li>\n</ul>\n<p>telnetlib 采用缓冲的处理方式，因此数据并不是一下子就返回的，而是先放在了缓冲区中，许多的读取处理都是围绕着这个缓冲区来的。而缓冲区的信息何时到达是不固定的，也许很快，也许很慢，也许分别到达，也许一下子就收到了。因此，对于数据不一定到齐的这种情况，就采用了 <code>read_until()</code> 来判断缓冲区中的数据是否有想要的内容，如果没有就等待，除非到达了超时时间。</p>\n<h2 id=\"总结\"> 总结</h2>\n<p>上面的示例程序使用 telnetlib 模块访问了 Huawei 交换机。首先从用户那里获取用户名和密码，以初始化与远程设备的 Telnet 连接。建立连接后，在远程设备上进行了进一步配置。远程登陆后，用户将能够访问远程服务器或设备。</p>\n<p>如果远程连接其它厂家的设备，在连接时可能会有二次验证，以及连接验证失败时给出的错误提示会不同，需要具体问题具体分析。</p>\n<p>但是这个 Telnet 协议有一个非常严重的缺点，即所有数据，包括用户名和密码都是以明文方式通过网络发送的，这会有安全风险。因此，现在我们很少使用 Telnet，并且它被一个非常安全的协议 Secure Shell 所取代，简称 SSH。</p>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://docs.python.org/zh-cn/3/library/telnetlib.html\" title=\"telnetlib -- Telnet 客户端\" target=\"_blank\" rel=\"noopener noreferrer\">telnetlib</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2021-11-19T03:27:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "使用 subprocess 执行 cmd",
      "url": "https://www.fedbook.cn/backend-knowledge/python/python-lib-subprocess/",
      "id": "https://www.fedbook.cn/backend-knowledge/python/python-lib-subprocess/",
      "content_html": "<h1 id=\"使用-subprocess-执行-cmd\"> 使用 subprocess 执行 cmd</h1>\n<h2 id=\"关于-subprocess\"> 关于 subprocess</h2>\n<p>subprocess 这个模块可以用来产生子进程，并连接到子进程的标准输入/输出/错误中去，还可以得到子进程的返回值。</p>\n<p>它是一个标准库，无需另外安装。</p>\n<blockquote>\n<p>subprocess 意在替代其他几个老的模块或者函数，将它们的功能集中到一起：</p>\n<ul>\n<li>os.system</li>\n<li>os.spawn*</li>\n<li>os.popen* –废弃</li>\n<li>popen2.* –废弃</li>\n<li>commands.* –废弃，3.x中被移除</li>\n</ul>\n</blockquote>\n<h2 id=\"subprocess-popen\"> subprocess.Popen()</h2>\n<p>Popen 类用于创建和管理进程，子程序将在新进程中被执行完成。在 UNIX/Linux 中执行子程序，该类会使用 <code>os.execvp()</code> 函数。而在 Windows 中执行子程序，该类将使用 <code>CreateProcess()</code> 函数。</p>\n<p>首先看一下 <code>subprocess.Popen()</code> 的常用参数：</p>\n<div><pre><code><span>class</span> <span>subprocess</span><span>.</span>Popen<span>(</span>args<span>,</span> bufsize<span>=</span><span>0</span><span>,</span> executable<span>=</span><span>None</span><span>,</span> stdin<span>=</span><span>None</span><span>,</span>\nstdout<span>=</span><span>None</span><span>,</span> close_fds<span>=</span><span>False</span><span>,</span> shell<span>=</span><span>False</span><span>,</span> universal_newlines<span>=</span><span>False</span><span>,</span>\nstderr<span>=</span><span>None</span><span>,</span> preexec_fn<span>=</span><span>None</span><span>,</span> cwd<span>=</span><span>None</span><span>,</span> env<span>=</span><span>None</span><span>,</span> startupinfo<span>=</span><span>None</span><span>,</span> creationflags<span>=</span><span>0</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>\n<li>args：它可以是一系列程序参数或单个字符串。如果 args 是一个序列，则 args 中的第一项将作为程序被执行。如果 args 是一个字符串，则会将 args 作为序列传递。</li>\n<li>bufsize：如果 bufsize 为 0（默认值是 0），则表示无缓冲。如果 bufsize 为 1，则表示行缓冲。如果 bufsize 是任何其他正值，则使用给定大小的缓冲区。如果 bufsize 是任何其他负值，则表示完全缓冲。</li>\n<li>executable：指定替换程序。</li>\n<li>stdin、stdout 和 stderr：这些参数分别定义标准输入、标准输出和标准错误。</li>\n<li>close_fds：在 Linux 中，如果 close_fds 为 True，则程序在执行子进程之前将关闭除 0、1 和 2 之外的所有文件描述符。在 Windows 中，如果 close_fds 为 True，则子进程将不继承句柄。</li>\n<li>shell：它表示是否使用 Shell 执行程序，默认为 False。如果 shell 为 True，则会将 args 作为字符串传递。在 Linux 中，如果 shell 为 True，则 Shell 程序默认为 <code>/bin/sh</code>。如果 args 是一个字符串，则该字符串指定要通过 Shell 执行的命令。</li>\n<li>preexec_fn：设置可调用对象，将在执行子进程之前调用。</li>\n<li>env：如果值不是 None，则映射将为新进程定义环境变量。</li>\n<li>universal_newlines：如果值为 True，则 stdout 和 stderr 将以自动换行模式打开文本文件。</li>\n</ul>\n<p>下面是几个<a href=\"https://github.com/wenyuan/practice-in-python/blob/main/devops-case/subprocess_example.py\" target=\"_blank\" rel=\"noopener noreferrer\">示例程序</a>。</p>\n<h3 id=\"执行命令-不等待子进程\"> 执行命令，不等待子进程</h3>\n<div><pre><code><span>import</span> subprocess\n\n<span>def</span> <span>exec_without_block</span><span>(</span><span>)</span><span>:</span>\n    <span># 或者：child = subprocess.Popen(['ping', '-c', '4', 'www.baidu.com'])</span>\n    child <span>=</span> subprocess<span>.</span>Popen<span>(</span><span>[</span><span>'ping -c 4 www.baidu.com'</span><span>]</span><span>,</span> shell<span>=</span><span>True</span><span>)</span>\n    <span>print</span><span>(</span>child<span>)</span>\n    <span>print</span><span>(</span><span>'hello world'</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>从执行结果可以看到 Python 并没有等到 child 子进程执行的 Popen 操作完成就执行了 print 操作。</p>\n<h3 id=\"执行命令-添加子进程等待\"> 执行命令，添加子进程等待</h3>\n<p>为了让主程序等待子进程完成后再继续往下执行，我们必须调用 Popen 对象的 <code>wait()</code> 方法，这样父进程才会等待（也就是阻塞 block）。</p>\n<div><pre><code><span>import</span> subprocess\n\n<span>def</span> <span>exec_with_block</span><span>(</span><span>)</span><span>:</span>\n    child <span>=</span> subprocess<span>.</span>Popen<span>(</span><span>[</span><span>'ping -c 4 www.baidu.com'</span><span>]</span><span>,</span> shell<span>=</span><span>True</span><span>)</span>\n    child<span>.</span>wait<span>(</span><span>)</span>\n    <span>print</span><span>(</span>child<span>)</span>\n    <span>print</span><span>(</span><span>'hello world'</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"执行命令-获取返回结果\"> 执行命令，获取返回结果</h3>\n<p>我们可以在 Popen() 建立子进程的时候改变标准输入、标准输出和标准错误，从而获取执行结果，如下例子。</p>\n<div><pre><code><span>import</span> subprocess\n\n<span># 获取命令执行结果</span>\n<span>def</span> <span>get_exec_result</span><span>(</span><span>)</span><span>:</span>\n    child <span>=</span> subprocess<span>.</span>Popen<span>(</span><span>[</span><span>'cat /etc/issue'</span><span>]</span><span>,</span>\n                             shell<span>=</span><span>True</span><span>,</span>\n                             stdout<span>=</span>subprocess<span>.</span>PIPE<span>,</span>\n                             stderr<span>=</span>subprocess<span>.</span>PIPE<span>)</span>\n    child<span>.</span>wait<span>(</span><span>)</span>\n    result <span>=</span> child<span>.</span>stdout<span>.</span>read<span>(</span><span>)</span>\n    <span>if</span> <span>not</span> result<span>:</span>\n        err <span>=</span> child<span>.</span>stderr<span>.</span>read<span>(</span><span>)</span>\n        <span>print</span><span>(</span>sys<span>.</span>stderr<span>,</span> <span>'ERROR: %s'</span> <span>%</span> err<span>)</span>\n    <span>else</span><span>:</span>\n        <span>print</span><span>(</span>result<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://docs.python.org/zh-cn/3/library/subprocess.html\" title=\"subprocess -- 子进程管理\" target=\"_blank\" rel=\"noopener noreferrer\">subprocess</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2021-11-19T03:27:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Git",
      "url": "https://www.fedbook.cn/basic-skills/git/",
      "id": "https://www.fedbook.cn/basic-skills/git/",
      "content_html": "<h1 id=\"git\"> Git</h1>\n<p>在实际开发中，我们会使用 Git（GitLab/GitHub）作为版本控制工具来完成团队协作。因此，熟悉 Git 的日常操作也是一名开发者的基本功。这个系列对一些术语或者理论基础不作赘述，可以参考<a href=\"https://www.liaoxuefeng.com/wiki/896043488029600\" target=\"_blank\" rel=\"noopener noreferrer\">廖雪峰老师的博文</a>。我主要对常用操作及命令做归纳总结，并就实际工作中遇到的一些问题点作记录，方便日后查询。</p>\n<hr>\n<p>必备知识点：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/git.png\" alt=\"Git 通用操作流程图\">\n  <p style=\"text-align: center; color: #888;\">（Git 通用操作流程图，图来源于网络）</p>\n</div>\n<p>最常用的就是图中的 6 个命令，但在使用之前首先要弄清楚几个名词概念：</p>\n<ul>\n<li><strong>Remote</strong>：远程仓库；</li>\n<li><strong>Repository</strong>：本地仓库；</li>\n<li><strong>Index/Stage</strong>：Git 追踪树，暂存区；</li>\n<li><strong>workspace</strong>：本地工作区（即你编辑器的代码）</li>\n</ul>\n<hr>\n<p>在实际开发过程中，经常会借助一些图形化 Git 客户端来完成一些操作，比如 TortoiseGit，Sourcetree 和 IDE 中集成的插件。但也有需要命令行操作的时候，比如一些复杂的回滚操作、线上出问题、Linux 服务器上没有图形化客户端等。所以命令行操作是一项不可或缺的基本技能。</p>\n<hr>\n<p>关于 Git 的知识点，主要参考：</p>\n<ul>\n<li><a href=\"https://git-scm.com/book\" target=\"_blank\" rel=\"noopener noreferrer\">官方文档</a></li>\n<li>《Git权威指南第二版》</li>\n<li>工作生产实践</li>\n</ul>\n<div style=\"text-align: right\">\n  <svg t=\"1637141435644\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"1168\" width=\"64\" height=\"64\"><path d=\"M63.49884471 444.72482676L339.27934283 168.4672005l80.63478137 81.1119106c-11.45109332 40.55595587 7.15693331 84.92894248 44.3729866 106.39974246v264.32940369c-28.62773329 16.22238256-47.7128892 47.23575993-47.71288806 82.54329842a95.42577726 95.42577726 0 0 0 95.42577726 95.42577726 95.42577726 95.42577726 0 0 0 95.42577726-95.42577726c0-35.30753736-19.08515589-66.32091583-47.71288806-82.54329842V388.42361757l98.76567986 99.7199384c-3.33990259 7.15693331-3.33990259 15.26812405-3.33990261 23.85644403a95.42577726 95.42577726 0 0 0 95.42577728 95.42577726 95.42577726 95.42577726 0 0 0 95.42577839-95.42577726 95.42577726 95.42577726 0 0 0-95.42577839-95.42577726c-8.58831998 0-16.69951071 0-23.85644403 3.33990146L604.0858758 297.2920003a94.47151987 94.47151987 0 0 0-54.86982251-111.64815985c-20.51654257-7.63406259-41.98734253-9.54257739-61.07249732-4.29415998L407.03164421 100.71489799l37.69318255-37.21605328c37.21605328-37.69318254 97.3342932-37.69318254 134.55034648 0l381.22598205 381.22598205c37.69318254 37.21605328 37.69318254 97.3342932 0 134.55034648l-381.22598205 381.22598205c-37.21605328 37.69318254-97.3342932 37.69318254-134.55034648 0L63.49884471 579.27517324c-37.69318254-37.21605328-37.69318254-97.3342932 0-134.55034648z\" fill=\"#E64A19\" p-id=\"1169\"></path></svg>\n</div>\n",
      "date_published": "2021-11-17T10:07:09.000Z",
      "date_modified": "2021-12-26T08:41:15.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "使用 xlrd 处理旧版本 Excel",
      "url": "https://www.fedbook.cn/backend-knowledge/python/python-lib-xlrd/",
      "id": "https://www.fedbook.cn/backend-knowledge/python/python-lib-xlrd/",
      "content_html": "<h1 id=\"使用-xlrd-处理旧版本-excel\"> 使用 xlrd 处理旧版本 Excel</h1>\n<h2 id=\"关于-xlrd\"> 关于 xlrd</h2>\n<p>xlrd 用于读取旧版本 Excel（<code>.xls</code>） 中的数据，配合 xlwt 和 xlutils 也可以对 Excel 进行写入和编辑。</p>\n<p>这三个库的职责分工如下：</p>\n<ul>\n<li>xlrd：用于读取 Excel 文件；</li>\n<li>xlwt：用于写入 Excel 文件；</li>\n<li>xlutils：用于操作 Excel 文件的实用工具，比如复制、分割、筛选等。</li>\n</ul>\n<p>安装比较简单，直接用 pip 工具安装三个库即可，安装命令如下：</p>\n<div><pre><code><span>sudo</span> pip <span>install</span> xlrd xlwt xlutils\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"写入-excel\"> 写入 Excel</h2>\n<p>下面是一个使用 xlwt 写入数据到 Excel 的代码示例：</p>\n<div><pre><code><span>#!/usr/bin/env python</span>\n<span># -*- coding: utf-8 -*-</span>\n\n<span>\"\"\"\n使用第三方库：pip install xlwt\n一般用于处理老版本 Excel(.xls)\n\"\"\"</span>\n\n<span>import</span> xlwt\n\n\n<span>def</span> <span>write_excel</span><span>(</span><span>)</span><span>:</span>\n    <span># 创建 xls 文件对象</span>\n    workbook <span>=</span> xlwt<span>.</span>Workbook<span>(</span><span>)</span>\n\n    <span># 新增两个表单页</span>\n    sheet_1 <span>=</span> workbook<span>.</span>add_sheet<span>(</span><span>'成绩'</span><span>)</span>\n    sheet_2 <span>=</span> workbook<span>.</span>add_sheet<span>(</span><span>'汇总'</span><span>)</span>\n\n    <span># 然后按照位置来添加数据,第一个参数是行，第二个参数是列</span>\n    <span># 写入第一个 sheet</span>\n    sheet_1<span>.</span>write<span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>'姓名'</span><span>)</span>\n    sheet_1<span>.</span>write<span>(</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>'专业'</span><span>)</span>\n    sheet_1<span>.</span>write<span>(</span><span>0</span><span>,</span> <span>2</span><span>,</span> <span>'科目'</span><span>)</span>\n    sheet_1<span>.</span>write<span>(</span><span>0</span><span>,</span> <span>3</span><span>,</span> <span>'成绩'</span><span>)</span>\n\n    sheet_1<span>.</span>write<span>(</span><span>1</span><span>,</span> <span>0</span><span>,</span> <span>'张三'</span><span>)</span>\n    sheet_1<span>.</span>write<span>(</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>'信息与通信工程'</span><span>)</span>\n    sheet_1<span>.</span>write<span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>'数值分析'</span><span>)</span>\n    sheet_1<span>.</span>write<span>(</span><span>1</span><span>,</span> <span>3</span><span>,</span> <span>88</span><span>)</span>\n\n    sheet_1<span>.</span>write<span>(</span><span>2</span><span>,</span> <span>0</span><span>,</span> <span>'李四'</span><span>)</span>\n    sheet_1<span>.</span>write<span>(</span><span>2</span><span>,</span> <span>1</span><span>,</span> <span>'物联网工程'</span><span>)</span>\n    sheet_1<span>.</span>write<span>(</span><span>2</span><span>,</span> <span>2</span><span>,</span> <span>'数字信号处理分析'</span><span>)</span>\n    sheet_1<span>.</span>write<span>(</span><span>2</span><span>,</span> <span>3</span><span>,</span> <span>95</span><span>)</span>\n\n    sheet_1<span>.</span>write<span>(</span><span>3</span><span>,</span> <span>0</span><span>,</span> <span>'王华'</span><span>)</span>\n    sheet_1<span>.</span>write<span>(</span><span>3</span><span>,</span> <span>1</span><span>,</span> <span>'电子与通信工程'</span><span>)</span>\n    sheet_1<span>.</span>write<span>(</span><span>3</span><span>,</span> <span>2</span><span>,</span> <span>'模糊数学'</span><span>)</span>\n    sheet_1<span>.</span>write<span>(</span><span>3</span><span>,</span> <span>3</span><span>,</span> <span>90</span><span>)</span>\n\n    <span># 写入第二个 sheet</span>\n    sheet_2<span>.</span>write<span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>'总分'</span><span>)</span>\n    sheet_2<span>.</span>write<span>(</span><span>1</span><span>,</span> <span>0</span><span>,</span> <span>273</span><span>)</span>\n\n    <span># 最后保存文件即可</span>\n    workbook<span>.</span>save<span>(</span><span>'student.xls'</span><span>)</span>\n\n\n<span>if</span> __name__ <span>==</span> <span>\"__main__\"</span><span>:</span>\n    write_excel<span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br></div></div><p>运行代码，结果会看到生成名为 student.xls 的 Excel 文件，打开文件查看如下图所示：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/write-xls-1.png\" height=\"200\" alt=\"使用 xlwt 写入数据到 sheet1\">\n  <p style=\"text-align: center; color: #888;\">（使用 xlwt 写入数据到 sheet1）</p>\n</div>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/write-xls-2.png\" height=\"200\" alt=\"使用 xlwt 写入数据到 sheet2\">\n  <p style=\"text-align: center; color: #888;\">（使用 xlwt 写入数据到 sheet2）</p>\n</div>\n<h2 id=\"读取-excel\"> 读取 Excel</h2>\n<p>下面是一个使用 xlrd 读取 Excel 数据的代码示例：</p>\n<div><pre><code><span>#!/usr/bin/env python</span>\n<span># -*- coding: utf-8 -*-</span>\n\n<span>\"\"\"\n使用第三方库：pip install xlrd\n一般用于处理老版本 Excel(.xls)\n\"\"\"</span>\n\n<span>import</span> xlrd\n\n\n<span>def</span> <span>read_excel</span><span>(</span><span>)</span><span>:</span>\n    <span># 打开刚才我们写入的 student.xls 文件</span>\n    workbook <span>=</span> xlrd<span>.</span>open_workbook<span>(</span><span>\"student.xls\"</span><span>)</span>\n\n    <span># 获取并打印 sheet 数量</span>\n    <span>print</span><span>(</span><span>\"sheet 数量:\"</span><span>,</span> workbook<span>.</span>nsheets<span>)</span>\n\n    <span># 获取并打印 sheet 名称</span>\n    <span>print</span><span>(</span><span>\"sheet 名称:\"</span><span>,</span> workbook<span>.</span>sheet_names<span>(</span><span>)</span><span>)</span>\n\n    <span># 根据 sheet 索引获取内容</span>\n    sheet_1 <span>=</span> workbook<span>.</span>sheet_by_index<span>(</span><span>0</span><span>)</span>\n    <span># 或者</span>\n    <span># 也可根据 sheet 名称获取内容</span>\n    <span># sh = workbook.sheet_by_name('成绩')</span>\n\n    <span># 获取并打印该 sheet 行数和列数</span>\n    <span>print</span><span>(</span><span>\"sheet %s 共 %d 行 %d 列\"</span> <span>%</span> <span>(</span>sheet_1<span>.</span>name<span>,</span> sheet_1<span>.</span>nrows<span>,</span> sheet_1<span>.</span>ncols<span>)</span><span>)</span>\n\n    <span># 获取并打印某个单元格的值</span>\n    <span>print</span><span>(</span><span>\"第一行第二列的值为:\"</span><span>,</span> sheet_1<span>.</span>cell_value<span>(</span><span>0</span><span>,</span> <span>1</span><span>)</span><span>)</span>\n\n    <span># 获取整行或整列的值</span>\n    rows <span>=</span> sheet_1<span>.</span>row_values<span>(</span><span>0</span><span>)</span>  <span># 获取第一行内容</span>\n    cols <span>=</span> sheet_1<span>.</span>col_values<span>(</span><span>1</span><span>)</span>  <span># 获取第二列内容</span>\n\n    <span># 打印获取的行列值</span>\n    <span>print</span><span>(</span><span>\"第一行的值为:\"</span><span>,</span> rows<span>)</span>\n    <span>print</span><span>(</span><span>\"第二列的值为:\"</span><span>,</span> cols<span>)</span>\n\n    <span># 获取单元格内容的数据类型</span>\n    <span>print</span><span>(</span><span>\"第二行第一列的值类型为:\"</span><span>,</span> sheet_1<span>.</span>cell<span>(</span><span>1</span><span>,</span> <span>0</span><span>)</span><span>.</span>ctype<span>)</span>\n\n    <span># 遍历所有表单内容</span>\n    <span>for</span> sh <span>in</span> workbook<span>.</span>sheets<span>(</span><span>)</span><span>:</span>\n        <span>for</span> r <span>in</span> <span>range</span><span>(</span>sh<span>.</span>nrows<span>)</span><span>:</span>\n            <span># 输出指定行</span>\n            <span>print</span><span>(</span>sh<span>.</span>row<span>(</span>r<span>)</span><span>)</span>\n\n\n<span>if</span> __name__ <span>==</span> <span>\"__main__\"</span><span>:</span>\n    read_excel<span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><p>输出如下结果：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/read-xls.png\" height=\"300\" alt=\"使用 xlrd 从 Excel 读取数据\">\n  <p style=\"text-align: center; color: #888;\">（使用 xlrd 从 Excel 读取数据）</p>\n</div>\n<p>从输出结果我们看到：<code>第二行第一列的值类型为: 1</code>，这里返回的<strong>单元格的类型</strong>是个数字，它的实际对应关系如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">数值</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">empty</td>\n<td style=\"text-align:left\">空</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">string</td>\n<td style=\"text-align:left\">字符串</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">number</td>\n<td style=\"text-align:left\">数字</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">date</td>\n<td style=\"text-align:left\">日期</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">boolean</td>\n<td style=\"text-align:left\">布尔值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:left\">error</td>\n<td style=\"text-align:left\">错误</td>\n</tr>\n</tbody>\n</table>\n<p>通过上面表格，我们可以知道刚才获取单元格类型返回的数字 <code>1</code> 对应的就是字符串类型。</p>\n<h2 id=\"修改-excel\"> 修改 Excel</h2>\n<p>上面介绍了写入和读取 Excel 数据，如果要修改 Excel，就需要用到 xlutils 中的方法了。直接上代码，来看下最简单的修改操作：</p>\n<div><pre><code><span>#!/usr/bin/env python</span>\n<span># -*- coding: utf-8 -*-</span>\n\n<span>\"\"\"\n使用第三方库：pip install xlrd xlutils\n一般用于处理老版本 Excel(.xls)\n\"\"\"</span>\n\n<span>import</span> xlrd\n<span>from</span> xlutils<span>.</span>copy <span>import</span> copy\n\n\n<span># 修改 Excel</span>\n<span>def</span> <span>edit_excel</span><span>(</span><span>)</span><span>:</span>\n    <span># 打开刚才我们写入的 student.xls 文件</span>\n    workbook <span>=</span> xlrd<span>.</span>open_workbook<span>(</span><span>\"student.xls\"</span><span>)</span>\n\n    <span># 复制一份</span>\n    new_workbook <span>=</span> copy<span>(</span>workbook<span>)</span>\n\n    <span># 选取第一个表单</span>\n    sheet_1 <span>=</span> new_workbook<span>.</span>get_sheet<span>(</span><span>0</span><span>)</span>\n\n    <span># 在第五行新增写入数据</span>\n    sheet_1<span>.</span>write<span>(</span><span>4</span><span>,</span> <span>0</span><span>,</span> <span>'王欢'</span><span>)</span>\n    sheet_1<span>.</span>write<span>(</span><span>4</span><span>,</span> <span>1</span><span>,</span> <span>'通信工程'</span><span>)</span>\n    sheet_1<span>.</span>write<span>(</span><span>4</span><span>,</span> <span>2</span><span>,</span> <span>'机器学习'</span><span>)</span>\n    sheet_1<span>.</span>write<span>(</span><span>4</span><span>,</span> <span>3</span><span>,</span> <span>89</span><span>)</span>\n\n    <span># 选取第二个表单</span>\n    sheet_2 <span>=</span> new_workbook<span>.</span>get_sheet<span>(</span><span>1</span><span>)</span>\n\n    <span># 替换总成绩数据</span>\n    sheet_2<span>.</span>write<span>(</span><span>1</span><span>,</span> <span>0</span><span>,</span> <span>362</span><span>)</span>\n\n    <span># 保存</span>\n    new_workbook<span>.</span>save<span>(</span><span>'new_student.xls'</span><span>)</span>\n\n\n<span>if</span> __name__ <span>==</span> <span>\"__main__\"</span><span>:</span>\n    edit_excel<span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><p>从上面代码可以看出，这里的修改 Excel 是通过 xlutils 库的 copy 方法将原来的 Excel 整个复制一份，然后再做修改操作，最后再保存。看下修改结果如下：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/edit-xls-1.png\" height=\"200\" alt=\"使用 xlutils 修改 sheet1 的数据\">\n  <p style=\"text-align: center; color: #888;\">（使用 xlutils 修改 sheet1 的数据）</p>\n</div>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/edit-xls-2.png\" height=\"200\" alt=\"使用 xlutils 修改 sheet2 的数据\">\n  <p style=\"text-align: center; color: #888;\">（使用 xlutils 修改 sheet2 的数据）</p>\n</div>\n<h2 id=\"格式化-excel\"> 格式化 Excel</h2>\n<p>在平时我们使用 Excel 时会对数据进行格式化，或者样式设置，接下来还是使用上面的数据，但在写入时对 Excel 进行格式化，使输出的格式稍微美观一点，代码如下：</p>\n<div><pre><code><span>#!/usr/bin/env python</span>\n<span># -*- coding: utf-8 -*-</span>\n\n<span>\"\"\"\n使用第三方库：pip install xlwt\n一般用于处理老版本 Excel(.xls)\n\"\"\"</span>\n\n<span>import</span> xlwt\n\n\n<span>def</span> <span>format_excel</span><span>(</span><span>)</span><span>:</span>\n    <span># 设置写出格式字体红色加粗</span>\n    style_head <span>=</span> xlwt<span>.</span>easyxf<span>(</span><span>'font: name Times New Roman, color-index red, bold on'</span><span>)</span>\n\n    <span># 设置数字型格式为小数点后保留两位</span>\n    style_num <span>=</span> xlwt<span>.</span>easyxf<span>(</span>num_format_str<span>=</span><span>'#,##0.00'</span><span>)</span>\n\n    <span># 设置日期型格式显示为YYYY-MM-DD</span>\n    style_date <span>=</span> xlwt<span>.</span>easyxf<span>(</span>num_format_str<span>=</span><span>'YYYY-MM-DD'</span><span>)</span>\n\n    <span># 创建 xls 文件对象</span>\n    workbook <span>=</span> xlwt<span>.</span>Workbook<span>(</span><span>)</span>\n\n    <span># 新增两个表单页</span>\n    sheet_1 <span>=</span> workbook<span>.</span>add_sheet<span>(</span><span>'成绩'</span><span>)</span>\n    sheet_2 <span>=</span> workbook<span>.</span>add_sheet<span>(</span><span>'汇总'</span><span>)</span>\n\n    <span># 然后按照位置来添加数据，第一个参数是行，第二个参数是列</span>\n    sheet_1<span>.</span>write<span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>'姓名'</span><span>,</span> style_head<span>)</span>  <span># 设置表头字体为红色加粗</span>\n    sheet_1<span>.</span>write<span>(</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>'日期'</span><span>,</span> style_head<span>)</span>  <span># 设置表头字体为红色加粗</span>\n    sheet_1<span>.</span>write<span>(</span><span>0</span><span>,</span> <span>2</span><span>,</span> <span>'成绩'</span><span>,</span> style_head<span>)</span>  <span># 设置表头字体为红色加粗</span>\n\n    <span># 插入数据</span>\n    sheet_1<span>.</span>write<span>(</span><span>1</span><span>,</span> <span>0</span><span>,</span> <span>'张三'</span><span>,</span> <span>)</span>\n    sheet_1<span>.</span>write<span>(</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>'2021-07-01'</span><span>,</span> style_date<span>)</span>\n    sheet_1<span>.</span>write<span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>90</span><span>,</span> style_num<span>)</span>\n    sheet_1<span>.</span>write<span>(</span><span>2</span><span>,</span> <span>0</span><span>,</span> <span>'李四'</span><span>)</span>\n    sheet_1<span>.</span>write<span>(</span><span>2</span><span>,</span> <span>1</span><span>,</span> <span>'2021-08-02'</span><span>)</span>\n    sheet_1<span>.</span>write<span>(</span><span>2</span><span>,</span> <span>2</span><span>,</span> <span>95</span><span>,</span> style_num<span>)</span>\n\n    <span># 设置单元格内容居中的格式</span>\n    alignment <span>=</span> xlwt<span>.</span>Alignment<span>(</span><span>)</span>\n    alignment<span>.</span>horz <span>=</span> xlwt<span>.</span>Alignment<span>.</span>HORZ_CENTER\n    style <span>=</span> xlwt<span>.</span>XFStyle<span>(</span><span>)</span>\n    style<span>.</span>alignment <span>=</span> alignment\n\n    <span># 合并 A4，B4 单元格，并将内容设置为居中</span>\n    sheet_1<span>.</span>write_merge<span>(</span><span>3</span><span>,</span> <span>3</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>,</span> <span>'总分'</span><span>,</span> style<span>)</span>\n\n    <span># 通过公式，计算 C2+C3 单元格的和</span>\n    sheet_1<span>.</span>write<span>(</span><span>3</span><span>,</span> <span>2</span><span>,</span> xlwt<span>.</span>Formula<span>(</span><span>\"C2+C3\"</span><span>)</span><span>)</span>\n\n    <span># 对 sheet2 写入数据</span>\n    sheet_2<span>.</span>write<span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>'总分'</span><span>,</span> style_head<span>)</span>\n    sheet_2<span>.</span>write<span>(</span><span>1</span><span>,</span> <span>0</span><span>,</span> <span>185</span><span>)</span>\n\n    <span># 最后保存文件即可</span>\n    workbook<span>.</span>save<span>(</span><span>'student.xls'</span><span>)</span>\n\n\n<span>if</span> __name__ <span>==</span> <span>\"__main__\"</span><span>:</span>\n    format_excel<span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br></div></div><p>输出结果：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/format-xls.png\" height=\"200\" alt=\"使用 xlwt 格式化 Excel 的数据\">\n  <p style=\"text-align: center; color: #888;\">（使用 xlwt 格式化 Excel 的数据）</p>\n</div>\n<p>我们可以对字体、颜色、对齐、合并等平时 Excel 的操作进行设置，也可以格式化日期和数字类型的数据。</p>\n<p>当然了这里只是介绍了部分功能，想了解更多功能操作可以参考官网。</p>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://pypi.org/project/xlrd/\" target=\"_blank\" rel=\"noopener noreferrer\">xlrd</a></li>\n<li><a href=\"https://pypi.org/project/xlwt/\" target=\"_blank\" rel=\"noopener noreferrer\">xlwt</a></li>\n<li><a href=\"http://www.python-excel.org/\" target=\"_blank\" rel=\"noopener noreferrer\">python-excel</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2021-11-19T03:27:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "变量与常量",
      "url": "https://www.fedbook.cn/backend-knowledge/python/variables-and-constants/",
      "id": "https://www.fedbook.cn/backend-knowledge/python/variables-and-constants/",
      "content_html": "<h1 id=\"变量与常量\"> 变量与常量</h1>\n<p><strong>变量</strong>：在程序运行过程中，值会发生变化的量。</p>\n<p><strong>常量</strong>：在程序运行过程中，值不会发生变化的量。</p>\n<p>无论是变量还是常量，在创建时都会在内存中开辟一块空间，用于保存它的值。</p>\n<h2 id=\"变量\"> 变量</h2>\n<p>在 Python 中，变量需要下面几点特性：</p>\n<ul>\n<li>Python 中的变量不需要声明类型。</li>\n<li>每个变量在使用前都必须赋值，变量赋值以后才会被创建。</li>\n<li>Python 中，一切事物都是对象，变量引用的是对象或者说是对象在内存中的地址。</li>\n<li>Python 中，变量本身没有数据类型的概念，通常所说的「变量类型」是变量所引用的对象的类型，或者说是变量的值的类型。</li>\n</ul>\n<p>上面第二条很重要：<strong>Python 中的一切都是对象，变量是对象的引用</strong>。</p>\n<p>举个例子：</p>\n<ul>\n<li>执行 <code>p1 = 'zhangsan'</code> ，解释器创建字符串 <code>'zhangsan'</code> 对象和变量 <code>a</code>，并把 <code>a</code> 指向 <code>'zhangsan'</code> 对象；</li>\n<li>执行 <code>p2 = p1</code>，解释器创建变量 <code>p2</code>，并且将其指向变量 <code>p1</code> 指向的字符串 <code>'zhangsan'</code> 对象；</li>\n<li>执行 <code>p1 = 'lisi'</code>，解释器创建字符串 <code>lisi</code> 对象，并把 <code>p1</code> 改为指向 <code>lisi</code> 对象，与 <code>p2</code> 无关。</li>\n</ul>\n<div style=\"text-align: center;\">\n  <svg id=\"SvgjsSvg1492\" width=\"779.515625\" height=\"239.90625\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><defs id=\"SvgjsDefs1493\"><marker id=\"SvgjsMarker1528\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1529\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1564\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1565\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1574\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1575\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1616\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1617\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1630\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1631\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker></defs><g id=\"SvgjsG1494\" transform=\"translate(48.11955661124307,73.57581573896354)\"><path id=\"SvgjsPath1495\" d=\"M 0 0L 40.84455001319609 0L 40.84455001319609 90.40499040307103L 0 90.40499040307103Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1496\"><text id=\"SvgjsText1497\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"21px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"34.10249520153551\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1498\" transform=\"translate(58.812351543942995,72.22648752399232)\"><path id=\"SvgjsPath1499\" d=\"M 0 0L 19.45896014779625 0L 19.45896014779625 26.986564299424185L 0 26.986564299424185Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1500\"><text id=\"SvgjsText1501\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"20px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"2.393282149712092\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1502\" dy=\"17\" x=\"10\"><tspan id=\"SvgjsTspan1503\" style=\"text-decoration:;\">p1</tspan></tspan></text></g></g><g id=\"SvgjsG1504\" transform=\"translate(25,41.866602687140116)\"><path id=\"SvgjsPath1505\" d=\"M 0 0L 92.47822644497226 0L 92.47822644497226 26.986564299424185L 0 26.986564299424185Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1506\"><text id=\"SvgjsText1507\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"93px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"2.393282149712092\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1508\" dy=\"17\" x=\"46.5\"><tspan id=\"SvgjsTspan1509\" style=\"text-decoration:;\">内存中的变量</tspan></tspan></text></g></g><g id=\"SvgjsG1510\" transform=\"translate(143.29506466086036,73.57581573896354)\"><path id=\"SvgjsPath1511\" d=\"M 0 0L 87.46898917920295 0L 87.46898917920295 24.287907869481767L 0 24.287907869481767Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1512\"><text id=\"SvgjsText1513\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"68px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"1.0439539347408835\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1514\" transform=\"translate(140.7904460279757,72.22648752399232)\"><path id=\"SvgjsPath1515\" d=\"M 0 0L 92.47822644497226 0L 92.47822644497226 26.986564299424185L 0 26.986564299424185Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1516\"><text id=\"SvgjsText1517\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"93px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"2.393282149712092\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1518\" dy=\"17\" x=\"46.5\"><tspan id=\"SvgjsTspan1519\" style=\"text-decoration:;\">\"zhangsan\"</tspan></tspan></text></g></g><g id=\"SvgjsG1520\" transform=\"translate(140.7904460279757,41.866602687140116)\"><path id=\"SvgjsPath1521\" d=\"M 0 0L 92.47822644497226 0L 92.47822644497226 26.986564299424185L 0 26.986564299424185Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1522\"><text id=\"SvgjsText1523\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"93px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"2.393282149712092\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1524\" dy=\"17\" x=\"46.5\"><tspan id=\"SvgjsTspan1525\" style=\"text-decoration:;\">内存中的对象</tspan></tspan></text></g></g><g id=\"SvgjsG1526\"><path id=\"SvgjsPath1527\" d=\"M78.27131169173924 85.7197696737044L109.53087885985747 85.7197696737044L109.53087885985747 85.7197696737044L140.7904460279757 85.7197696737044\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1528)\"></path></g><g id=\"SvgjsG1530\" transform=\"translate(307.05859065716544,73.57581573896354)\"><path id=\"SvgjsPath1531\" d=\"M 0 0L 40.84455001319609 0L 40.84455001319609 90.40499040307103L 0 90.40499040307103Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1532\"><text id=\"SvgjsText1533\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"21px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"34.10249520153551\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1534\" transform=\"translate(317.7513855898653,72.22648752399232)\"><path id=\"SvgjsPath1535\" d=\"M 0 0L 19.45896014779625 0L 19.45896014779625 26.986564299424185L 0 26.986564299424185Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1536\"><text id=\"SvgjsText1537\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"20px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"2.393282149712092\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1538\" dy=\"17\" x=\"10\"><tspan id=\"SvgjsTspan1539\" style=\"text-decoration:;\">p1</tspan></tspan></text></g></g><g id=\"SvgjsG1540\" transform=\"translate(283.9390340459224,41.866602687140116)\"><path id=\"SvgjsPath1541\" d=\"M 0 0L 92.47822644497226 0L 92.47822644497226 26.986564299424185L 0 26.986564299424185Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1542\"><text id=\"SvgjsText1543\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"93px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"2.393282149712092\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1544\" dy=\"17\" x=\"46.5\"><tspan id=\"SvgjsTspan1545\" style=\"text-decoration:;\">内存中的变量</tspan></tspan></text></g></g><g id=\"SvgjsG1546\" transform=\"translate(402.2340987067828,73.57581573896354)\"><path id=\"SvgjsPath1547\" d=\"M 0 0L 87.46898917920295 0L 87.46898917920295 24.287907869481767L 0 24.287907869481767Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1548\"><text id=\"SvgjsText1549\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"68px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"1.0439539347408835\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1550\" transform=\"translate(399.72948007389806,72.22648752399232)\"><path id=\"SvgjsPath1551\" d=\"M 0 0L 92.47822644497226 0L 92.47822644497226 26.986564299424185L 0 26.986564299424185Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1552\"><text id=\"SvgjsText1553\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"93px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"2.393282149712092\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1554\" dy=\"17\" x=\"46.5\"><tspan id=\"SvgjsTspan1555\" style=\"text-decoration:;\">\"zhangsan\"</tspan></tspan></text></g></g><g id=\"SvgjsG1556\" transform=\"translate(399.72948007389806,41.866602687140116)\"><path id=\"SvgjsPath1557\" d=\"M 0 0L 92.47822644497226 0L 92.47822644497226 26.986564299424185L 0 26.986564299424185Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1558\"><text id=\"SvgjsText1559\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"93px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"2.393282149712092\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1560\" dy=\"17\" x=\"46.5\"><tspan id=\"SvgjsTspan1561\" style=\"text-decoration:;\">内存中的对象</tspan></tspan></text></g></g><g id=\"SvgjsG1562\"><path id=\"SvgjsPath1563\" d=\"M337.21034573766156 85.7197696737044L368.4699129057798 85.7197696737044L368.4699129057798 85.7197696737044L399.72948007389806 85.7197696737044\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1564)\"></path></g><g id=\"SvgjsG1566\" transform=\"translate(317.7513855898653,117.42898272552782)\"><path id=\"SvgjsPath1567\" d=\"M 0 0L 19.45896014779625 0L 19.45896014779625 26.986564299424185L 0 26.986564299424185Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1568\"><text id=\"SvgjsText1569\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"20px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"2.393282149712092\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1570\" dy=\"17\" x=\"10\"><tspan id=\"SvgjsTspan1571\" style=\"text-decoration:;\">p2</tspan></tspan></text></g></g><g id=\"SvgjsG1572\"><path id=\"SvgjsPath1573\" d=\"M337.21034573766156 130.9222648752399L445.96859329638414 130.9222648752399L445.96859329638414 99.21305182341652\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1574)\"></path></g><g id=\"SvgjsG1576\" transform=\"translate(569.850884138295,73.57581573896354)\"><path id=\"SvgjsPath1577\" d=\"M 0 0L 40.84455001319609 0L 40.84455001319609 90.40499040307103L 0 90.40499040307103Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1578\"><text id=\"SvgjsText1579\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"21px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"34.10249520153551\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1580\" transform=\"translate(580.5436790709949,72.22648752399232)\"><path id=\"SvgjsPath1581\" d=\"M 0 0L 19.45896014779625 0L 19.45896014779625 26.986564299424185L 0 26.986564299424185Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1582\"><text id=\"SvgjsText1583\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"20px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"2.393282149712092\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1584\" dy=\"17\" x=\"10\"><tspan id=\"SvgjsTspan1585\" style=\"text-decoration:;\">p1</tspan></tspan></text></g></g><g id=\"SvgjsG1586\" transform=\"translate(546.731327527052,41.866602687140116)\"><path id=\"SvgjsPath1587\" d=\"M 0 0L 92.47822644497226 0L 92.47822644497226 26.986564299424185L 0 26.986564299424185Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1588\"><text id=\"SvgjsText1589\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"93px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"2.393282149712092\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1590\" dy=\"17\" x=\"46.5\"><tspan id=\"SvgjsTspan1591\" style=\"text-decoration:;\">内存中的变量</tspan></tspan></text></g></g><g id=\"SvgjsG1592\" transform=\"translate(665.0263921879122,73.57581573896354)\"><path id=\"SvgjsPath1593\" d=\"M 0 0L 87.46898917920295 0L 87.46898917920295 24.287907869481767L 0 24.287907869481767Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1594\"><text id=\"SvgjsText1595\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"68px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"1.0439539347408835\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1596\" transform=\"translate(662.5217735550278,72.22648752399232)\"><path id=\"SvgjsPath1597\" d=\"M 0 0L 92.47822644497226 0L 92.47822644497226 26.986564299424185L 0 26.986564299424185Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1598\"><text id=\"SvgjsText1599\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"93px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"2.393282149712092\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1600\" dy=\"17\" x=\"46.5\"><tspan id=\"SvgjsTspan1601\" style=\"text-decoration:;\">\"zhangsan\"</tspan></tspan></text></g></g><g id=\"SvgjsG1602\" transform=\"translate(662.5217735550278,41.866602687140116)\"><path id=\"SvgjsPath1603\" d=\"M 0 0L 92.47822644497226 0L 92.47822644497226 26.986564299424185L 0 26.986564299424185Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1604\"><text id=\"SvgjsText1605\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"93px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"2.393282149712092\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1606\" dy=\"17\" x=\"46.5\"><tspan id=\"SvgjsTspan1607\" style=\"text-decoration:;\">内存中的对象</tspan></tspan></text></g></g><g id=\"SvgjsG1608\" transform=\"translate(580.5436790709949,117.42898272552782)\"><path id=\"SvgjsPath1609\" d=\"M 0 0L 19.45896014779625 0L 19.45896014779625 26.986564299424185L 0 26.986564299424185Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1610\"><text id=\"SvgjsText1611\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"20px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"2.393282149712092\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1612\" dy=\"17\" x=\"10\"><tspan id=\"SvgjsTspan1613\" style=\"text-decoration:;\">p2</tspan></tspan></text></g></g><g id=\"SvgjsG1614\"><path id=\"SvgjsPath1615\" d=\"M600.0026392187912 130.9222648752399L708.7608867775139 130.9222648752399L708.7608867775139 99.21305182341652\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1616)\"></path></g><g id=\"SvgjsG1618\" transform=\"translate(665.0263921879122,143.06621880998082)\"><path id=\"SvgjsPath1619\" d=\"M 0 0L 87.46898917920295 0L 87.46898917920295 24.287907869481767L 0 24.287907869481767Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1620\"><text id=\"SvgjsText1621\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"68px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"1.0439539347408835\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1622\" transform=\"translate(662.5217735550278,141.7168905950096)\"><path id=\"SvgjsPath1623\" d=\"M 0 0L 92.47822644497226 0L 92.47822644497226 26.986564299424185L 0 26.986564299424185Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1624\"><text id=\"SvgjsText1625\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"93px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"2.393282149712092\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1626\" dy=\"17\" x=\"46.5\"><tspan id=\"SvgjsTspan1627\" style=\"text-decoration:;\">\"lisi\"</tspan></tspan></text></g></g><g id=\"SvgjsG1628\"><path id=\"SvgjsPath1629\" d=\"M600.0026392187912 85.7197696737044L631.2622063869095 85.7197696737044L631.2622063869095 155.2101727447217L662.5217735550278 155.2101727447217\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1630)\"></path></g><g id=\"SvgjsG1632\"><path id=\"SvgjsPath1633\" d=\"M264.67273686988653 25L264.67273686988653 104.61036468330133L264.67273686988653 104.61036468330133L264.67273686988653 184.22072936660268\" stroke=\"#0066cc\" stroke-width=\"2\" fill=\"none\"></path></g><g id=\"SvgjsG1634\"><path id=\"SvgjsPath1635\" d=\"M522.0704671417261 25L522.0704671417261 104.61036468330133L522.0704671417261 104.61036468330133L522.0704671417261 184.22072936660268\" stroke=\"#0066cc\" stroke-width=\"2\" fill=\"none\"></path></g><g id=\"SvgjsG1636\" transform=\"translate(143.29506466086036,186.9193857965451)\"><path id=\"SvgjsPath1637\" d=\"M 16.954341514911583 0L 0 10.951439539347412L 6.10356294536817 28.0806142034549L 27.805120084454995 28.0806142034549L 33.908683029823166 10.951439539347412Z\" stroke=\"rgba(0,102,204,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#0066cc\"></path><g id=\"SvgjsG1638\"><text id=\"SvgjsText1639\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"14px\" fill=\"#ffffff\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"5.046353166986567\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1640\" dy=\"17\" x=\"17\"><tspan id=\"SvgjsTspan1641\" style=\"text-decoration:;\">1</tspan></tspan></text></g></g><g id=\"SvgjsG1642\" transform=\"translate(382.1971496437054,186.9193857965451)\"><path id=\"SvgjsPath1643\" d=\"M 16.954341514911583 0L 0 10.951439539347412L 6.10356294536817 28.0806142034549L 27.805120084454995 28.0806142034549L 33.908683029823166 10.951439539347412Z\" stroke=\"rgba(0,102,204,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#0066cc\"></path><g id=\"SvgjsG1644\"><text id=\"SvgjsText1645\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"14px\" fill=\"#ffffff\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"5.046353166986567\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1646\" dy=\"17\" x=\"17\"><tspan id=\"SvgjsTspan1647\" style=\"text-decoration:;\">2</tspan></tspan></text></g></g><g id=\"SvgjsG1648\" transform=\"translate(634.9709685932962,186.9193857965451)\"><path id=\"SvgjsPath1649\" d=\"M 16.954341514911583 0L 0 10.951439539347412L 6.10356294536817 28.0806142034549L 27.805120084454995 28.0806142034549L 33.908683029823166 10.951439539347412Z\" stroke=\"rgba(0,102,204,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#0066cc\"></path><g id=\"SvgjsG1650\"><text id=\"SvgjsText1651\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"14px\" fill=\"#ffffff\" font-weight=\"700\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"5.046353166986567\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1652\" dy=\"17\" x=\"17\"><tspan id=\"SvgjsTspan1653\" style=\"text-decoration:;\">3</tspan></tspan></text></g></g></svg>\n  <p style=\"text-align:center; color: #888;\">（一切都是对象，变量是对象的引用）</p>\n</div>\n<h2 id=\"常量\"> 常量</h2>\n<p>常量就是不变的变量，比如常用的数学常数圆周率就是一个常量。在 Python 中，通常用全部大写的变量名表示常量：</p>\n<div><pre><code>PI <span>=</span> <span>3.14159265359</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>但事实上，从 Python 语法角度看，PI 仍然是一个变量，因为 Python 根本没有任何机制保证 PI 不会被改变。你完全可以给 PI 赋值为 10，不会弹出任何错误。所以，用全部大写的变量名表示常量只是一个习惯上的用法。</p>\n<p>常量通常放置在代码的最上部，并作为全局使用。</p>\n<p>（完）</p>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2021-11-19T03:27:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "常用命令清单",
      "url": "https://www.fedbook.cn/basic-skills/git/common-command-manual/",
      "id": "https://www.fedbook.cn/basic-skills/git/common-command-manual/",
      "content_html": "<h1 id=\"常用命令清单\"> 常用命令清单</h1>\n<h2 id=\"本地配置\"> 本地配置</h2>\n<p>Git 的配置文件为 <code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>\n<p>下面只整理常用的 Git 配置操作：</p>\n<div><pre><code><span># 查看全局配置列表</span>\n<span>git</span> config --global -l\n<span># 查看局部配置列表</span>\n<span>git</span> config --local -l\n\n<span># 查看已设置的全局用户名/邮箱</span>\n<span>git</span> config --global --get user.name\n<span>git</span> config --global --get user.email\n\n<span># 设置全局用户名/邮箱</span>\n<span>git</span> config --global user.name <span>\"输入你的用户名\"</span>\n<span>git</span> config --global user.email <span>\"输入你的邮箱\"</span>\n\n<span># 设置本地当前工作区仓库用户名/邮箱</span>\n<span>git</span> config --local user.name <span>\"输入你的用户名\"</span>\n<span>git</span> config --local user.email <span>\"输入你的邮箱\"</span>\n\n<span># 删除配置</span>\n<span>git</span> config --unset --global user.name\n<span>git</span> config --unset --global user.email\n\n<span># 文件权限的变动也会视为改动, 可通过以下配置忽略文件权限变动</span>\n<span>git</span> config core.fileMode <span>false</span>\n\n<span># 文件大小写设为敏感, git 默认是忽略大小写</span>\n<span>git</span> config --global core.ignorecase <span>false</span>\n\n<span># 提交时转换成 unix 风格的换行符, 检出时不转换(看各人习惯设置)</span>\n<span>git</span> config --global core.autocrlf input\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h2 id=\"初始化仓库\"> 初始化仓库</h2>\n<p>在 GitHub 上手动创建一个仓库，一般创建完的仓库会包括一个 <code>README.md</code> 文件。</p>\n<p>将远程仓库克隆到本地：</p>\n<div><pre><code><span># https 协议</span>\n<span>git</span> clone https://github.com/<span>[</span>your-github-id<span>]</span>/<span>[</span>repo-name<span>]</span>.git\n\n<span># 或 SSH 协议(一般不用)</span>\n<span>git</span> clone git@github.com:<span>[</span>your-github-id<span>]</span>/<span>[</span>repo-name<span>]</span>.git\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"增加-删除文件\"> 增加/删除文件</h2>\n<p>以下命令默认在本地克隆下来的仓库目录下执行：</p>\n<div><pre><code><span># 添加指定文件到暂存区</span>\n<span>git</span> <span>add</span> <span>[</span>file1<span>]</span> <span>[</span>file2<span>]</span> <span>..</span>.\n\n<span># 添加指定目录到暂存区, 包括子目录</span>\n<span>git</span> <span>add</span> <span>[</span>dir<span>]</span>\n\n<span># 添加当前目录的所有文件到暂存区</span>\n<span>git</span> <span>add</span> <span>.</span>\n\n<span># 添加每个变化前, 都会要求确认</span>\n<span># 对于同一个文件的多处变化, 可以实现分次提交</span>\n<span>git</span> <span>add</span> -p\n\n<span># 删除工作区文件，并且将这次删除放入暂存区</span>\n<span>git</span> <span>rm</span> <span>[</span>file1<span>]</span> <span>[</span>file2<span>]</span> <span>..</span>.\n\n<span># 停止追踪指定文件，但该文件会保留在工作区</span>\n<span>git</span> <span>rm</span> --cached <span>[</span>file<span>]</span>\n\n<span># 改名文件，并且将这个改名放入暂存区</span>\n<span># 实际上是新建一个相同的文件, 删除旧文件, 然后将新旧文件都放入暂存区</span>\n<span>git</span> <span>mv</span> <span>[</span>file-original<span>]</span> <span>[</span>file-renamed<span>]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h2 id=\"代码提交\"> 代码提交</h2>\n<p>这个过程一般用可视化工具进行，因为可以很方便的核对每个文件的改动，不过命令行操作也要了解，如需要修改上一次的 commit 信息，就可以通过命令行快速搞定。</p>\n<div><pre><code><span># 提交暂存区到仓库区</span>\n<span>git</span> commit -m <span>[</span>message<span>]</span>\n\n<span># 提交暂存区的指定文件到仓库区</span>\n<span>git</span> commit <span>[</span>file1<span>]</span> <span>[</span>file2<span>]</span> <span>..</span>. -m <span>[</span>message<span>]</span>\n\n<span># 提交工作区自上次 commit 之后的变化, 直接到仓库区</span>\n<span>git</span> commit -a\n\n<span># 提交时显示所有 diff 信息</span>\n<span>git</span> commit -v\n\n<span># 使用一次新的 commit, 替代上一次提交</span>\n<span># 如果代码没有任何新变化, 则用来改写上一次 commit 的提交信息</span>\n<span>git</span> commit --amend -m <span>[</span>message<span>]</span>\n\n<span># 重做上一次 commit, 并包括指定文件的新变化</span>\n<span>git</span> commit --amend <span>[</span>file1<span>]</span> <span>[</span>file2<span>]</span> <span>..</span>.\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id=\"分支操作\"> 分支操作</h2>\n<div><pre><code><span># 列出所有本地分支</span>\n<span>git</span> branch\n\n<span># 列出所有远程分支</span>\n<span>git</span> branch -r\n\n<span># 列出所有本地分支和远程分支</span>\n<span>git</span> branch -a\n\n<span># 新建一个分支, 但依然停留在当前分支</span>\n<span>git</span> branch <span>[</span>branch-name<span>]</span>\n\n<span># 新建一个分支, 并切换到该分支</span>\n<span>git</span> checkout -b <span>[</span>branch-name<span>]</span>\n\n<span># 新建一个分支, 指向指定 commit</span>\n<span>git</span> branch <span>[</span>branch-name<span>]</span> <span>[</span>commit-id<span>]</span>\n\n<span># 新建一个分支, 与指定的远程分支建立追踪关系</span>\n<span>git</span> branch --track <span>[</span>branch-name<span>]</span> <span>[</span>remote-branch-name<span>]</span>\n\n<span># 切换到指定分支, 并更新工作区</span>\n<span>git</span> checkout <span>[</span>branch-name<span>]</span>\n\n<span># 切换到上一个分支</span>\n<span>git</span> checkout -\n\n<span># 建立追踪关系, 在现有分支与指定的远程分支之间</span>\n<span>git</span> branch --set-upstream <span>[</span>branch-name<span>]</span> <span>[</span>remote-branch-name<span>]</span>\n\n<span># 合并指定分支到当前分支</span>\n<span>git</span> merge <span>[</span>branch-name<span>]</span>\n\n<span># 从其它分支上挑选一个指定 commit, 合并进当前分支</span>\n<span>git</span> cherry-pick <span>[</span>commit-id<span>]</span>\n\n<span># 保留原有作者信息进行合并</span>\n<span>git</span> cherry-pick -x <span>[</span>commit-id<span>]</span>\n\n<span># 删除分支</span>\n<span>git</span> branch -d <span>[</span>branch-name<span>]</span>\n\n<span># 删除远程分支</span>\n<span>git</span> push origin --delete <span>[</span>branch-name<span>]</span>\n<span>git</span> branch -dr <span>[</span>remote/branch<span>]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><h2 id=\"标签操作\"> 标签操作</h2>\n<div><pre><code><span># 列出所有 tag</span>\n<span>git</span> tag\n\n<span># 新建一个 tag 在当前 commit</span>\n<span>git</span> tag <span>[</span>tag-name<span>]</span>\n\n<span># 新建一个 tag 在指定 commit</span>\n<span>git</span> tag <span>[</span>tag-name<span>]</span> <span>[</span>commit-id<span>]</span>\n\n<span># 删除本地 tag</span>\n<span>git</span> tag -d <span>[</span>tag-name<span>]</span>\n\n<span># 删除远程 tag</span>\n<span>git</span> push origin :refs/tags/<span>[</span>tag-name<span>]</span>\n\n<span># 查看 tag 信息</span>\n<span>git</span> show <span>[</span>tag-name<span>]</span>\n\n<span># 提交指定 tag</span>\n<span>git</span> push <span>[</span>remote-repo-name, 默认是 origin<span>]</span> <span>[</span>tag-name<span>]</span>\n\n<span># 提交所有 tag</span>\n<span>git</span> push <span>[</span>remote-repo-name, 默认是 origin<span>]</span> --tags\n\n<span># 新建一个分支, 指向某个 tag</span>\n<span>git</span> checkout -b <span>[</span>branch-name<span>]</span> <span>[</span>tag-name<span>]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h2 id=\"查看信息\"> 查看信息</h2>\n<p>查看日志是经常用的命令，而查看文件 diff 的功能我更倾向于用可视化工具，因为比对起来更加直观。</p>\n<div><pre><code><span># 显示有变更的文件</span>\n<span>git</span> status\n\n<span># 显示当前分支的版本历史</span>\n<span>git</span> log\n\n<span># 查看指定作者历史记录</span>\n<span>git</span> log --author<span>=</span><span>[</span>author-name<span>]</span>\n\n<span># 只显示合并日志</span>\n<span>git</span> log --merges\n\n<span># 以图形查看日志记录, --oneline 可选, 表示输出概要日志</span>\n<span>git</span> log --graph --oneline\n\n<span># 显示 commit 历史, 以及每次 commit 发生变更的文件</span>\n<span>git</span> log --stat\n\n<span># 搜索提交历史, 根据关键词</span>\n<span>git</span> log -S <span>[</span>keyword<span>]</span>\n\n<span># 显示某个 commit 之后的所有变动, 每个 commit 占据一行</span>\n<span>git</span> log <span>[</span>tag<span>]</span> HEAD --pretty<span>=</span>format:%s\n\n<span># 显示某个 commit 之后的所有变动, 其\"提交说明\"必须符合搜索条件</span>\n<span>git</span> log <span>[</span>tag<span>]</span> HEAD --grep feature\n\n<span># 显示某个文件的版本历史, 包括文件改名</span>\n<span>git</span> log --follow <span>[</span>file<span>]</span>\n<span>git</span> whatchanged <span>[</span>file<span>]</span>\n\n<span># 显示指定文件相关的每一次 diff</span>\n<span>git</span> log -p <span>[</span>file<span>]</span>\n\n<span># 显示过去 5 次提交</span>\n<span>git</span> log -5 --pretty --oneline\n\n<span># 显示所有提交过的用户, 按提交次数排序</span>\n<span>git</span> shortlog -sn\n\n<span># 显示指定文件是什么人在什么时间修改过</span>\n<span>git</span> blame <span>[</span>file<span>]</span>\n\n<span># 显示暂存区和工作区的差异</span>\n<span>git</span> <span>diff</span>\n\n<span># 显示暂存区和上一个 commit 的差异</span>\n<span>git</span> <span>diff</span> --cached <span>[</span>file<span>]</span>\n\n<span># 显示工作区与当前分支最新 commit 之间的差异</span>\n<span>git</span> <span>diff</span> HEAD\n\n<span># 显示两次提交之间的差异</span>\n<span>git</span> <span>diff</span> <span>[</span>first-branch<span>]</span><span>..</span>.<span>[</span>second-branch<span>]</span>\n\n<span># 显示今天你写了多少行代码</span>\n<span>git</span> <span>diff</span> --shortstat <span>\"@{0 day ago}\"</span>\n\n<span># 显示某次提交的元数据和内容变化</span>\n<span>git</span> show <span>[</span>commit<span>]</span>\n\n<span># 显示某次提交发生变化的文件</span>\n<span>git</span> show --name-only <span>[</span>commit<span>]</span>\n\n<span># 显示某次提交时, 某个文件的内容</span>\n<span>git</span> show <span>[</span>commit<span>]</span>:<span>[</span>filename<span>]</span>\n\n<span># 显示当前分支的最近几次提交</span>\n<span>git</span> reflog\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br></div></div><h2 id=\"远程同步\"> 远程同步</h2>\n<div><pre><code><span># 下载远程仓库的所有变动</span>\n<span>git</span> fetch <span>[</span>remote<span>]</span>\n\n<span># 显示所有远程仓库</span>\n<span>git</span> remote -v\n\n<span># 显示某个远程仓库的信息</span>\n<span>git</span> remote show <span>[</span>remote<span>]</span>\n\n<span># 增加一个新的远程仓库, 并命名</span>\n<span>git</span> remote <span>add</span> <span>[</span>shortname<span>]</span> <span>[</span>url<span>]</span>\n\n<span># 取回远程仓库的变化, 并与本地分支合并</span>\n<span>git</span> pull <span>[</span>remote<span>]</span> <span>[</span>branch<span>]</span>\n\n<span># 上传本地指定分支到远程仓库</span>\n<span>git</span> push <span>[</span>remote<span>]</span> <span>[</span>branch<span>]</span>\n\n<span># 强行推送当前分支到远程仓库, 即使有冲突</span>\n<span>git</span> push <span>[</span>remote<span>]</span> --force\n\n<span># 推送所有分支到远程仓库</span>\n<span>git</span> push <span>[</span>remote<span>]</span> --all\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id=\"文件临存\"> 文件临存</h2>\n<p>有一种场景，在当前分支开发时，临时需要切换到其他分支修改 Bug，但此时又不想提交当前分支上开发到一半的代码（切换分支必须把当前工作内容提交，否则无法切换），这个时候就可以用到 <code>git stash</code> 将代码临时储藏起来。</p>\n<p>强烈建议给每个 stash 添加描述信息！！！</p>\n<div><pre><code><span># 暂存当前工作区内容</span>\n<span>git</span> stash\n\n<span># 暂存时添加描述信息, 推荐使用此命令</span>\n<span>git</span> stash push -m <span>\"更改了 xx\"</span>\n\n<span># 暂存包含没有被 Git 追踪的文件</span>\n<span>git</span> stash -u\n\n<span># 查看当前暂存列表</span>\n<span>git</span> stash list\n\n<span># 恢复修改工作区内容, 会从 git stash list 移除掉</span>\n<span>git</span> stash pop           <span># 恢复最近一次保存内容到工作区, 默认会把暂存区的改动恢复到工作区</span>\n<span>git</span> stash pop stash@<span>{</span><span>1</span><span>}</span> <span># 恢复指定 id, 通过 git stash list 可查到</span>\n\n<span># 与 pop 命令一致, 唯一不同的是不会从 git stash list 移除掉</span>\n<span>git</span> stash apply\n\n<span># 清空所有保存(慎用)</span>\n<span>git</span> stash <span>clear</span>\n\n<span># 清空指定 stash id, 如果 drop 后面不指定 id 则清除最近的一次</span>\n<span>git</span> stash drop stash@<span>{</span><span>0</span><span>}</span>\n<span>git</span> stash drop  <span># 清除最近一次</span>\n\n<span># 想看 stash 做了什么改动, 类似简化版的 git diff</span>\n<span>git</span> stash show stash@<span>{</span><span>0</span><span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>关于 stash 的补充：</p>\n<div><p>git stash 信息存储到哪了？</p>\n<p>项目路径下的 <code>.git</code> 文件中存储着版本管理的所有信息，在文件 <code>.git/log/refs/stash</code> 中可以看到全部的 stash 记录信息</p>\n</div>\n<div><p>在有新增文件（不是新增代码）时，git stash 并不会储藏新增的文件?</p>\n<p>也就是说，没有在 Git 版本控制中的文件，是不能被 <code>git stash</code> 存起来的，此时需要先执行下 <code>git add</code> 将新增文件加到 Git 版本控制中，然后再 <code>git stash</code> 就可以了。</p>\n</div>\n<h2 id=\"撤销操作\"> 撤销操作</h2>\n<div><pre><code><span># 恢复暂存区的指定文件到工作区</span>\n<span>git</span> checkout <span>[</span>file<span>]</span>\n\n<span># 恢复某个 commit 的指定文件到暂存区和工作区</span>\n<span>git</span> checkout <span>[</span>commit<span>]</span> <span>[</span>file<span>]</span>\n\n<span># 恢复暂存区的所有文件到工作区</span>\n<span>git</span> checkout <span>.</span>\n\n<span># 重置暂存区的指定文件, 与上一次 commit 保持一致, 但工作区不变</span>\n<span>git</span> reset <span>[</span>file<span>]</span>\n\n<span># 重置暂存区与工作区, 与上一次 commit 保持一致</span>\n<span>git</span> reset --hard\n\n<span># 重置当前分支的指针为指定 commit, 同时重置暂存区, 但工作区不变</span>\n<span>git</span> reset <span>[</span>commit<span>]</span>\n\n<span># 重置当前分支的 HEAD 为指定 commit, 同时重置暂存区和工作区, 与指定 commit 一致</span>\n<span>git</span> reset --hard <span>[</span>commit<span>]</span>\n\n<span># 重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变</span>\n<span>git</span> reset --keep <span>[</span>commit<span>]</span>\n\n<span># 新建一个 commit, 用来撤销指定 commit</span>\n<span># 后者的所有变化都将被前者抵消, 并且应用到当前分支</span>\n<span>git</span> revert <span>[</span>commit<span>]</span>\n\n<span># 暂时将未提交的变化移除, 稍后再移入</span>\n<span>git</span> stash\n<span>git</span> stash pop\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>（完）</p>\n",
      "date_published": "2021-11-17T15:58:41.000Z",
      "date_modified": "2021-12-11T07:45:49.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "git rebase 的两种用法",
      "url": "https://www.fedbook.cn/basic-skills/git/git-rebase/",
      "id": "https://www.fedbook.cn/basic-skills/git/git-rebase/",
      "content_html": "<h1 id=\"git-rebase-的两种用法\"> git rebase 的两种用法</h1>\n<h2 id=\"前言\"> 前言</h2>\n<p>rebase 在 Git 中是一个非常有魅力的命令，使用得当会极大提高自己的工作效率；相反，如果乱用会给团队中其他人带来麻烦。</p>\n<p>它的作用简要概括为：可以对某一段线性提交历史进行编辑、删除、复制、粘贴；因此，合理使用 rebase 命令可以使我们的提交历史干净、简洁。</p>\n<h2 id=\"用法一-合并当前分支的多个-commit-记录\"> 用法一: 合并当前分支的多个 commit 记录</h2>\n<p>有时候会遇到对同一处代码进行多次处理的场景。这会导致如下提交记录：</p>\n<div><pre><code>$ <span>git</span> log --pretty<span>=</span>format:<span>'%h: %s'</span>\nad3593c: feat: modify c\n21511a4: feat: modify b\na7b8f93: feat: modify b\n89ab26f: feat: modify b\n5f5d89a: feat: modify a\n7092a92: Initial commit\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>其实，中间的对 b 的 3 次提交 完全可以合并成一次 commit，这个时候 rebase 就很有用了。</p>\n<h3 id=\"_1-执行-rebase-i-命令\"> 1. 执行 rebase -i 命令</h3>\n<p>找到想要合并的 commit，使用 rebase -i：</p>\n<div><pre><code><span>git</span> rebase -i 5f5d89a\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>注意</strong>：</p>\n<ul>\n<li><code>git rebase -i [startPoint] [endPoint]</code></li>\n<li>前开后闭区间，这里的 <code>[startPoint]</code> 指目标 commit 的前一个 commit（即上述示例中的 <code>5f5d89a: feat: modify a</code>)。 因为三个 commit 肯定要基于上一个 commit 来合并成新的 commit。</li>\n<li><strong>谨慎使用 <code>[endPoint]</code></strong>，省略即默认表示从起始 commit 一直到最后一个，但是一旦填写了，则表示 <code>[endPoint]</code> 后面的 commit 全部不要了。</li>\n</ul>\n<h3 id=\"_2-进入-interact-交互界面\"> 2. 进入 Interact 交互界面</h3>\n<p>终端会进入选择交互界面，让你进行变基选择操作：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/git-rebase-interact.png\" alt=\"git rebase 交互界面\">\n  <p style=\"text-align:center; color: #888;\">（git rebase 交互界面）</p>\n</div>\n<p><strong>说明</strong>：</p>\n<ul>\n<li>最上面三行，就是刚刚选中的三个 commit，按时间先后顺序依次往下排序(<strong>和 git log 的展示顺序是反的</strong>，查看的时候需要注意)</li>\n<li>前面的三个 pick 就是下面 Commands 展示的一系列命令中的第一个 p，也就是使用 commit。\n<ul>\n<li>pick：保留该 commit（缩写：p）</li>\n<li>reword：保留该 commit，但我需要修改该 commit 的注释（缩写：r）</li>\n<li>edit：保留该 commit，但我要停下来修改该提交（不仅仅修改注释）（缩写：e）</li>\n<li>squash：将该 commit 和前一个 commit 合并（缩写：s）</li>\n<li>fixup：将该 commit 和前一个 commit 合并，但我不要保留该提交的注释信息（缩写：f）</li>\n<li>exec：执行 shell 命令（缩写：x）</li>\n<li>drop：丢弃该 commit（缩写：d）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"_3-使用-s-命令合并-commit\"> 3. 使用 s 命令合并 commit</h3>\n<p>使用 s 命令，合并到上一个commit（编辑时就跟操作 vim 一样）：</p>\n<ul>\n<li>按 <code>i</code> 进入操作，将<strong>第二、三个 commit 的 pick 改成 s</strong>。</li>\n<li>按 <code>Esc</code> 退出操作。</li>\n<li>输入 <code>:wq</code> 保存并退出。</li>\n</ul>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/git-rebase-interact-squash.png\" alt=\"使用 s 命令合并 commit\">\n  <p style=\"text-align:center; color: #888;\">（使用 s 命令合并 commit）</p>\n</div>\n<h3 id=\"_4-修改-commit-记录\"> 4. 修改 commit 记录</h3>\n<p>接下来会弹出第二个页面，分别展示三个 commit 的提交信息：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/git-rebase-interact-commit-list.png\" alt=\"相关的 commit 信息列表\">\n  <p style=\"text-align:center; color: #888;\">（相关的 commit 信息列表）</p>\n</div>\n<p>在这次的示例中，三个 commit 信息都是一样的。选用第一个的提交信息（也可以编辑下），将其余的全部注释掉，重复上述步骤，保存退出即可。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/git-rebase-interact-modify-commit-info.png\" alt=\"编辑提交信息\">\n  <p style=\"text-align:center; color: #888;\">（编辑提交信息）</p>\n</div>\n<h3 id=\"_5-查看最新合并情况\"> 5. 查看最新合并情况</h3>\n<p>查看最新合并情况，会发现原来三个一样的提交现在合并成了一个新的 commit。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/git-rebase-result.png\" alt=\"commit 合并前后对比\">\n  <p style=\"text-align:center; color: #888;\">（commit 合并前后对比）</p>\n</div>\n<h2 id=\"用法二-避免出现分叉合并\"> 用法二: 避免出现分叉合并</h2>\n<p>接下来，将通过实际示例和场景，来分析 rebase 是如何解决分叉合并的。在此之前，我先做如下规定：</p>\n<ul>\n<li>有两个分支: develop（主分支），feature（feature 分支）</li>\n<li>新需求按时间顺序叫 <code>a</code> 、<code>b</code>……等(a 需求最早，b 其次，以此类推)</li>\n<li>原 commit <code>a</code> 变基之后（hashId 改变）叫 <code>a'</code></li>\n</ul>\n<h3 id=\"场景-1-合并时-最舒服的情况\"> 场景 1：合并时，最舒服的情况</h3>\n<p>这种场景是基于 develop 分支没有新的提交，feature 分支有新的提交后，把 feature 分支的改动合并到 develop 分支。</p>\n<div style=\"text-align: center;\">\n  <svg id=\"SvgjsSvg1006\" width=\"298\" height=\"146.75\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><defs id=\"SvgjsDefs1007\"><marker id=\"SvgjsMarker1030\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1031\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#f44336\" stroke=\"#f44336\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1040\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1041\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#f44336\" stroke=\"#f44336\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1044\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1045\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#f44336\" stroke=\"#f44336\" stroke-width=\"1\"></path></marker></defs><g id=\"SvgjsG1008\" transform=\"translate(25,26.25)\"><path id=\"SvgjsPath1009\" d=\"M 0 0L 82 0L 82 27.5L 0 27.5Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1010\"><text id=\"SvgjsText1011\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"82px\" fill=\"#f44336\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"1.75\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1012\" dy=\"20\" x=\"41\"><tspan id=\"SvgjsTspan1013\" style=\"text-decoration:;\">develop</tspan></tspan></text></g></g><g id=\"SvgjsG1014\" transform=\"translate(25,92.75)\"><path id=\"SvgjsPath1015\" d=\"M 0 0L 82 0L 82 28.75L 0 28.75Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1016\"><text id=\"SvgjsText1017\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"82px\" fill=\"#f44336\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"2.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1018\" dy=\"20\" x=\"41\"><tspan id=\"SvgjsTspan1019\" style=\"text-decoration:;\">feature</tspan></tspan></text></g></g><g id=\"SvgjsG1020\"><path id=\"SvgjsPath1021\" d=\"M66 54.75L66 73.25L66 73.25L66 91.75\" stroke=\"#f44336\" stroke-width=\"2\" fill=\"none\"></path></g><g id=\"SvgjsG1022\" transform=\"translate(180,25)\"><path id=\"SvgjsPath1023\" d=\"M 0 0L 35 0L 35 30L 0 30Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1024\"><text id=\"SvgjsText1025\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"35px\" fill=\"#f44336\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"3\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1026\" dy=\"20\" x=\"17.5\"><tspan id=\"SvgjsTspan1027\" style=\"text-decoration:;\">a</tspan></tspan></text></g></g><g id=\"SvgjsG1028\"><path id=\"SvgjsPath1029\" d=\"M108 40L143.5 40L143.5 40L176.39999999999998 40\" stroke=\"#f44336\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1030)\"></path></g><g id=\"SvgjsG1032\" transform=\"translate(160,94.875)\"><path id=\"SvgjsPath1033\" d=\"M 0 0L 32 0L 32 24.5L 0 24.5Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1034\"><text id=\"SvgjsText1035\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"32px\" fill=\"#f44336\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"0.25\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1036\" dy=\"20\" x=\"16\"><tspan id=\"SvgjsTspan1037\" style=\"text-decoration:;\">a</tspan></tspan></text></g></g><g id=\"SvgjsG1038\"><path id=\"SvgjsPath1039\" d=\"M108 107.125L133.5 107.125L133.5 107.125L156.39999999999998 107.125\" stroke=\"#f44336\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1040)\"></path></g><g id=\"SvgjsG1042\"><path id=\"SvgjsPath1043\" d=\"M176.4745933782927 93.99479483909673L195.7914638381464 58.168738579251766\" stroke=\"#f44336\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1044)\"></path></g><g id=\"SvgjsG1046\" transform=\"translate(153,60.5)\"><path id=\"SvgjsPath1047\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1048\"><text id=\"SvgjsText1049\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"120px\" fill=\"#f44336\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1050\" dy=\"20\" x=\"60\"><tspan id=\"SvgjsTspan1051\" style=\"text-decoration:;\">合并</tspan></tspan></text></g></g></svg>\n  <p style=\"text-align:center; color: #888;\">（最理想的合并情况）</p>\n</div>\n<p>此时的合并有两点好处：</p>\n<ul>\n<li>没有冲突</li>\n<li>没有多余的 commit 提交</li>\n</ul>\n<p>其实这种情况下，rebase 和 merge 的效果是一样的。而后面所有的 rebase 都是奔着这个目标来的。</p>\n<h3 id=\"场景-2-各分支都有自己新的-commit\"> 场景 2：各分支都有自己新的 commit</h3>\n<p>develop 新增需求 a: &quot;feat: a&quot;</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/develop-branch-feat-a.png\" alt=\"develop 分支的 log\">\n  <p style=\"text-align:center; color: #888;\">（develop 分支的 log）</p>\n</div>\n<p>feature  新增需求 b: &quot;feat: b&quot;</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/feature-branch-feat-b.png\" alt=\"feature 分支的 log\">\n  <p style=\"text-align:center; color: #888;\">（feature 分支的 log）</p>\n</div>\n<h4 id=\"_1-develop-merge-feature\"> 1）develop merge feature</h4>\n<p>develop 直接 merge feature：切换到 develop 分支执行命令 <code>git merge feature</code>。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/develop-merge-feature-directly.png\" alt=\"develop 直接 merge feature\">\n  <p style=\"text-align:center; color: #888;\">（develop 直接 merge feature）</p>\n</div>\n<p>会出现以下结果：</p>\n<ul>\n<li>会保留所有的 commit（hashId 不变）</li>\n<li>按提交顺序排序</li>\n<li>产生新的 commit 点（Merge branch 'xxx' into develop）</li>\n</ul>\n<div style=\"text-align: center;\">\n  <svg id=\"SvgjsSvg1052\" width=\"611\" height=\"146.75\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><defs id=\"SvgjsDefs1053\"><marker id=\"SvgjsMarker1076\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1077\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#f44336\" stroke=\"#f44336\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1086\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1087\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#f44336\" stroke=\"#f44336\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1096\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1097\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#f44336\" stroke=\"#f44336\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1100\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1101\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#f44336\" stroke=\"#f44336\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1110\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1111\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#f44336\" stroke=\"#f44336\" stroke-width=\"1\"></path></marker></defs><g id=\"SvgjsG1054\" transform=\"translate(25,26.25)\"><path id=\"SvgjsPath1055\" d=\"M 0 0L 82 0L 82 27.5L 0 27.5Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1056\"><text id=\"SvgjsText1057\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"82px\" fill=\"#f44336\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"1.75\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1058\" dy=\"20\" x=\"41\"><tspan id=\"SvgjsTspan1059\" style=\"text-decoration:;\">develop</tspan></tspan></text></g></g><g id=\"SvgjsG1060\" transform=\"translate(25,92.75)\"><path id=\"SvgjsPath1061\" d=\"M 0 0L 82 0L 82 28.75L 0 28.75Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1062\"><text id=\"SvgjsText1063\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"82px\" fill=\"#f44336\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"2.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1064\" dy=\"20\" x=\"41\"><tspan id=\"SvgjsTspan1065\" style=\"text-decoration:;\">feature</tspan></tspan></text></g></g><g id=\"SvgjsG1066\"><path id=\"SvgjsPath1067\" d=\"M66 54.75L66 73.25L66 73.25L66 91.75\" stroke=\"#f44336\" stroke-width=\"2\" fill=\"none\"></path></g><g id=\"SvgjsG1068\" transform=\"translate(160,25)\"><path id=\"SvgjsPath1069\" d=\"M 0 0L 35 0L 35 30L 0 30Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1070\"><text id=\"SvgjsText1071\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"35px\" fill=\"#f44336\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"3\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1072\" dy=\"20\" x=\"17.5\"><tspan id=\"SvgjsTspan1073\" style=\"text-decoration:;\">a</tspan></tspan></text></g></g><g id=\"SvgjsG1074\"><path id=\"SvgjsPath1075\" d=\"M108 40L133.5 40L133.5 40L156.39999999999998 40\" stroke=\"#f44336\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1076)\"></path></g><g id=\"SvgjsG1078\" transform=\"translate(160,94.875)\"><path id=\"SvgjsPath1079\" d=\"M 0 0L 32 0L 32 24.5L 0 24.5Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1080\"><text id=\"SvgjsText1081\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"32px\" fill=\"#f44336\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"0.25\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1082\" dy=\"20\" x=\"16\"><tspan id=\"SvgjsTspan1083\" style=\"text-decoration:;\">b</tspan></tspan></text></g></g><g id=\"SvgjsG1084\"><path id=\"SvgjsPath1085\" d=\"M108 107.125L133.5 107.125L133.5 107.125L156.39999999999998 107.125\" stroke=\"#f44336\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1086)\"></path></g><g id=\"SvgjsG1088\" transform=\"translate(240,25)\"><path id=\"SvgjsPath1089\" d=\"M 0 0L 35 0L 35 30L 0 30Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1090\"><text id=\"SvgjsText1091\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"35px\" fill=\"#f44336\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"3\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1092\" dy=\"20\" x=\"17.5\"><tspan id=\"SvgjsTspan1093\" style=\"text-decoration:;\">b</tspan></tspan></text></g></g><g id=\"SvgjsG1094\"><path id=\"SvgjsPath1095\" d=\"M196 40L236.39999999999998 40\" stroke=\"#f44336\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1096)\"></path></g><g id=\"SvgjsG1098\"><path id=\"SvgjsPath1099\" d=\"M192.7824687641022 106.50231016291866L254.68311244923206 57.24168341349278\" stroke=\"#f44336\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1100)\"></path></g><g id=\"SvgjsG1102\" transform=\"translate(325,26.25)\"><path id=\"SvgjsPath1103\" d=\"M 0 0L 261 0L 261 27.5L 0 27.5Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1104\"><text id=\"SvgjsText1105\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"261px\" fill=\"#f44336\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"1.75\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1106\" dy=\"20\" x=\"130.5\"><tspan id=\"SvgjsTspan1107\" style=\"text-decoration:;\">Merge branch 'xxx' into develop</tspan></tspan></text></g></g><g id=\"SvgjsG1108\"><path id=\"SvgjsPath1109\" d=\"M276 40L321.4 40\" stroke=\"#f44336\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1110)\"></path></g></svg>\n  <p style=\"text-align:center; color: #888;\">（develop 直接 merge feature）</p>\n</div>\n<h4 id=\"_2-develop-rebase-feature\"> 2）develop rebase feature</h4>\n<p>如果在 develop 分支没有直接执行 merge 命令，而是执行的 rebase 命令 <code>git rebase -i feature</code>。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/develop-rebase-feature.png\" alt=\"develop rebase feature\">\n  <p style=\"text-align:center; color: #888;\">（develop rebase feature）</p>\n</div>\n<p>会出现以下结果：</p>\n<ul>\n<li>develop 分支的 a 会被排在合进来的 feature 分支 b 的上面（尽管 a 是先完成的）</li>\n<li>develop 的原 commit a 被移除，产生了新的 commit a'（hashId 已变）</li>\n<li>从 feature 合进来的 b 不变（不会对合进来的 commit 进行变基）</li>\n</ul>\n<div style=\"text-align: center;\">\n  <svg id=\"SvgjsSvg1112\" width=\"385\" height=\"176.75\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><defs id=\"SvgjsDefs1113\"><marker id=\"SvgjsMarker1140\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1141\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#f44336\" stroke=\"#f44336\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1150\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1151\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#f44336\" stroke=\"#f44336\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1160\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1161\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#f44336\" stroke=\"#f44336\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1170\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1171\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#f44336\" stroke=\"#f44336\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1174\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1175\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#f44336\" stroke=\"#f44336\" stroke-width=\"1\"></path></marker></defs><g id=\"SvgjsG1114\" transform=\"translate(165,56.5)\"><path id=\"SvgjsPath1115\" d=\"M 0 13.5C 0 -4.5 27 -4.5 27 13.5C 27 31.5 0 31.5 0 13.5Z\" stroke=\"rgba(244,67,54,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1116\"><text id=\"SvgjsText1117\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"7px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"3.875\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1118\" transform=\"translate(158.5,55)\"><path id=\"SvgjsPath1119\" d=\"M 0 0L 35 0L 35 30L 0 30Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1120\"><text id=\"SvgjsText1121\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"35px\" fill=\"#f44336\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"3\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1122\" dy=\"20\" x=\"17.5\"><tspan id=\"SvgjsTspan1123\" style=\"text-decoration:;\">a</tspan></tspan></text></g></g><g id=\"SvgjsG1124\" transform=\"translate(25,56.25)\"><path id=\"SvgjsPath1125\" d=\"M 0 0L 82 0L 82 27.5L 0 27.5Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1126\"><text id=\"SvgjsText1127\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"82px\" fill=\"#f44336\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"1.75\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1128\" dy=\"20\" x=\"41\"><tspan id=\"SvgjsTspan1129\" style=\"text-decoration:;\">develop</tspan></tspan></text></g></g><g id=\"SvgjsG1130\" transform=\"translate(25,122.75)\"><path id=\"SvgjsPath1131\" d=\"M 0 0L 82 0L 82 28.75L 0 28.75Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1132\"><text id=\"SvgjsText1133\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"82px\" fill=\"#f44336\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"2.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1134\" dy=\"20\" x=\"41\"><tspan id=\"SvgjsTspan1135\" style=\"text-decoration:;\">feature</tspan></tspan></text></g></g><g id=\"SvgjsG1136\"><path id=\"SvgjsPath1137\" d=\"M66 84.75L66 103.25L66 103.25L66 121.75\" stroke=\"#f44336\" stroke-width=\"2\" fill=\"none\"></path></g><g id=\"SvgjsG1138\"><path id=\"SvgjsPath1139\" d=\"M108 70L132.75 70L132.75 70L154.89999999999998 70\" stroke=\"#f44336\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1140)\"></path></g><g id=\"SvgjsG1142\" transform=\"translate(160,124.875)\"><path id=\"SvgjsPath1143\" d=\"M 0 0L 32 0L 32 24.5L 0 24.5Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1144\"><text id=\"SvgjsText1145\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"32px\" fill=\"#f44336\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"0.25\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1146\" dy=\"20\" x=\"16\"><tspan id=\"SvgjsTspan1147\" style=\"text-decoration:;\">b</tspan></tspan></text></g></g><g id=\"SvgjsG1148\"><path id=\"SvgjsPath1149\" d=\"M108 137.125L133.5 137.125L133.5 137.125L156.39999999999998 137.125\" stroke=\"#f44336\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1150)\"></path></g><g id=\"SvgjsG1152\" transform=\"translate(240,55)\"><path id=\"SvgjsPath1153\" d=\"M 0 0L 35 0L 35 30L 0 30Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1154\"><text id=\"SvgjsText1155\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"35px\" fill=\"#f44336\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"3\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1156\" dy=\"20\" x=\"17.5\"><tspan id=\"SvgjsTspan1157\" style=\"text-decoration:;\">b</tspan></tspan></text></g></g><g id=\"SvgjsG1158\"><path id=\"SvgjsPath1159\" d=\"M276 70L325 70\" stroke=\"#f44336\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1160)\"></path></g><g id=\"SvgjsG1162\" transform=\"translate(325,55)\"><path id=\"SvgjsPath1163\" d=\"M 0 0L 35 0L 35 30L 0 30Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1164\"><text id=\"SvgjsText1165\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"35px\" fill=\"#f44336\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"3\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1166\" dy=\"20\" x=\"17.5\"><tspan id=\"SvgjsTspan1167\" style=\"text-decoration:;\">a'</tspan></tspan></text></g></g><g id=\"SvgjsG1168\"><path id=\"SvgjsPath1169\" d=\"M176 54L176 25L342.5 25L342.5 51.400000000000006\" stroke=\"#f44336\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1170)\"></path></g><g id=\"SvgjsG1172\"><path id=\"SvgjsPath1173\" d=\"M193 137.125L257.5 137.125L257.5 88.6\" stroke=\"#f44336\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1174)\"></path></g></svg>\n  <p style=\"text-align:center; color: #888;\">（develop rebase feature）</p>\n</div>\n<h4 id=\"_3-rebase-两步走-正确姿势\"> 3）rebase 两步走 - 正确姿势</h4>\n<ul>\n<li>Step 1：切换到 feature 分支，去 rebase develop，即 <code>git rebase -i develop</code>\n<ul>\n<li>feature 的 commit b 会重新生成一个 b'，排在 develop 的新需求 a 的后面。</li>\n<li>这一步相当于回到场景 1 的模式，我在当前 feature 先把自己的 b 拎出来，同步完最新的 develop，再把需求 b 放在最后面。</li>\n<li>接下来回到 develop 进行 merge 的时候就很舒服了。</li>\n</ul>\n</li>\n<li>Step 2：切换到 develop 分支，去 merge feature，即 <code>git merge feature</code>\n<ul>\n<li>合并后查看 log，可以发现 develop 分支作为主分支，本次合并没有影响自己原来的 commit 历史，只在后面新增了 feature 的新内容，并没有多余的 commit。</li>\n</ul>\n</li>\n</ul>\n<div style=\"text-align: center;\">\n  <svg id=\"SvgjsSvg1176\" width=\"457.25\" height=\"226.5\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><defs id=\"SvgjsDefs1177\"><marker id=\"SvgjsMarker1224\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1225\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#f44336\" stroke=\"#f44336\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1228\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1229\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#f44336\" stroke=\"#f44336\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1232\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1233\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#f44336\" stroke=\"#f44336\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1254\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1255\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#f44336\" stroke=\"#f44336\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1258\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1259\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#f44336\" stroke=\"#f44336\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1262\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1263\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#f44336\" stroke=\"#f44336\" stroke-width=\"1\"></path></marker></defs><g id=\"SvgjsG1178\" transform=\"translate(245,53.5)\"><path id=\"SvgjsPath1179\" d=\"M 0 0L 152 0L 152 148L 0 148Z\" stroke=\"rgba(186,104,200,1)\" stroke-width=\"1\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1180\"><text id=\"SvgjsText1181\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"132px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"64.375\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1182\" transform=\"translate(25,53.5)\"><path id=\"SvgjsPath1183\" d=\"M 0 0L 216 0L 216 148L 0 148Z\" stroke=\"rgba(251,192,45,1)\" stroke-width=\"1\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1184\"><text id=\"SvgjsText1185\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"196px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"64.375\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1186\" transform=\"translate(176.5,126.625)\"><path id=\"SvgjsPath1187\" d=\"M 0 13.5C 0 -4.5 27 -4.5 27 13.5C 27 31.5 0 31.5 0 13.5Z\" stroke=\"rgba(158,158,158,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1188\"><text id=\"SvgjsText1189\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"7px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"3.875\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1190\" transform=\"translate(141.75,79.578125)\"><path id=\"SvgjsPath1191\" d=\"M 0 0L 96.5 0L 96.5 115.921875L 0 115.921875Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1192\"><text id=\"SvgjsText1193\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"35px\" width=\"97px\" fill=\"#9e9e9e\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"35px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"29.5859375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1194\" dy=\"43\" x=\"48.5\"><tspan id=\"SvgjsTspan1195\" style=\"text-decoration:;\">×</tspan></tspan></text></g></g><g id=\"SvgjsG1196\" transform=\"translate(174,127.875)\"><path id=\"SvgjsPath1197\" d=\"M 0 0L 32 0L 32 24.5L 0 24.5Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1198\"><text id=\"SvgjsText1199\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"32px\" fill=\"#f44336\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"0.25\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1200\" dy=\"20\" x=\"16\"><tspan id=\"SvgjsTspan1201\" style=\"text-decoration:;\">b</tspan></tspan></text></g></g><g id=\"SvgjsG1202\" transform=\"translate(172.5,58)\"><path id=\"SvgjsPath1203\" d=\"M 0 0L 35 0L 35 30L 0 30Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1204\"><text id=\"SvgjsText1205\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"35px\" fill=\"#f44336\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"3\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1206\" dy=\"20\" x=\"17.5\"><tspan id=\"SvgjsTspan1207\" style=\"text-decoration:;\">a</tspan></tspan></text></g></g><g id=\"SvgjsG1208\" transform=\"translate(39,59.25)\"><path id=\"SvgjsPath1209\" d=\"M 0 0L 82 0L 82 27.5L 0 27.5Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1210\"><text id=\"SvgjsText1211\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"82px\" fill=\"#f44336\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"1.75\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1212\" dy=\"20\" x=\"41\"><tspan id=\"SvgjsTspan1213\" style=\"text-decoration:;\">develop</tspan></tspan></text></g></g><g id=\"SvgjsG1214\" transform=\"translate(39,125.75)\"><path id=\"SvgjsPath1215\" d=\"M 0 0L 82 0L 82 28.75L 0 28.75Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1216\"><text id=\"SvgjsText1217\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"82px\" fill=\"#f44336\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"2.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1218\" dy=\"20\" x=\"41\"><tspan id=\"SvgjsTspan1219\" style=\"text-decoration:;\">feature</tspan></tspan></text></g></g><g id=\"SvgjsG1220\"><path id=\"SvgjsPath1221\" d=\"M80 87.75L80 106.25L80 106.25L80 124.75\" stroke=\"#f44336\" stroke-width=\"2\" fill=\"none\"></path></g><g id=\"SvgjsG1222\"><path id=\"SvgjsPath1223\" d=\"M122 73L146.75 73L146.75 73L168.89999999999998 73\" stroke=\"#f44336\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1224)\"></path></g><g id=\"SvgjsG1226\"><path id=\"SvgjsPath1227\" d=\"M122 140.125L147.5 140.125L147.5 140.125L170.39999999999998 140.125\" stroke=\"#f44336\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1228)\"></path></g><g id=\"SvgjsG1230\"><path id=\"SvgjsPath1231\" d=\"M254 73L339 73\" stroke=\"#f44336\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1232)\"></path></g><g id=\"SvgjsG1234\" transform=\"translate(339,58)\"><path id=\"SvgjsPath1235\" d=\"M 0 0L 35 0L 35 30L 0 30Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1236\"><text id=\"SvgjsText1237\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"35px\" fill=\"#f44336\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"3\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1238\" dy=\"20\" x=\"17.5\"><tspan id=\"SvgjsTspan1239\" style=\"text-decoration:;\">b'</tspan></tspan></text></g></g><g id=\"SvgjsG1240\" transform=\"translate(254,125.125)\"><path id=\"SvgjsPath1241\" d=\"M 0 0L 35 0L 35 30L 0 30Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1242\"><text id=\"SvgjsText1243\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"35px\" fill=\"#f44336\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"3\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1244\" dy=\"20\" x=\"17.5\"><tspan id=\"SvgjsTspan1245\" style=\"text-decoration:;\">b'</tspan></tspan></text></g></g><g id=\"SvgjsG1246\" transform=\"translate(212.5,125.125)\"><path id=\"SvgjsPath1247\" d=\"M 0 0L 35 0L 35 30L 0 30Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1248\"><text id=\"SvgjsText1249\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"35px\" fill=\"#f44336\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"3\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1250\" dy=\"20\" x=\"17.5\"><tspan id=\"SvgjsTspan1251\" style=\"text-decoration:;\">a</tspan></tspan></text></g></g><g id=\"SvgjsG1252\"><path id=\"SvgjsPath1253\" d=\"M208.5 73L230 73L230 121.525\" stroke=\"#f44336\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1254)\"></path></g><g id=\"SvgjsG1256\"><path id=\"SvgjsPath1257\" d=\"M190 153.375L190 185.125L271.5 185.125L271.5 158.725\" stroke=\"#f44336\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1258)\"></path></g><g id=\"SvgjsG1260\"><path id=\"SvgjsPath1261\" d=\"M289.7914783660376 139.51380281733762L353.65067788226463 90.20030985758456\" stroke=\"#f44336\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1262)\"></path></g><g id=\"SvgjsG1264\" transform=\"translate(28.5,25)\"><path id=\"SvgjsPath1265\" d=\"M 0 0L 193.5 0L 193.5 28.5L 0 28.5Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1266\"><text id=\"SvgjsText1267\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"194px\" fill=\"#fbc02d\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"2.25\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1268\" dy=\"20\" x=\"97\"><tspan id=\"SvgjsTspan1269\" style=\"text-decoration:;\">feature rebase develop</tspan></tspan></text></g></g><g id=\"SvgjsG1270\" transform=\"translate(238.25,25)\"><path id=\"SvgjsPath1271\" d=\"M 0 0L 193.5 0L 193.5 28.5L 0 28.5Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1272\"><text id=\"SvgjsText1273\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"194px\" fill=\"#ba68c8\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"2.25\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1274\" dy=\"20\" x=\"97\"><tspan id=\"SvgjsTspan1275\" style=\"text-decoration:;\">develop merge feature </tspan></tspan></text></g></g></svg>\n  <p style=\"text-align:center; color: #888;\">（rebase 两步走）</p>\n</div>\n<p>以上就是 rebase 为什么不会产生多余 commit 记录的原因了。</p>\n<h3 id=\"rebase-时如何解决冲突\"> rebase 时如何解决冲突</h3>\n<p>如果两个分支修改了同一文件的同一位置，在 rebase 的时候会提示发生冲突，较为优雅的解决方案：</p>\n<ul>\n<li>先解决冲突，再保存。</li>\n<li><code>git add .</code></li>\n<li><code>git rebase --continue</code></li>\n</ul>\n<h2 id=\"使用-rebase-的注意点\"> 使用 rebase 的注意点</h2>\n<div><p>注意</p>\n<p>如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。<br>\n如果你遵循这条金科玉律，就不会出差错。否则，<strong>人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你</strong>。\n—— 引用自<a href=\"https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA\" target=\"_blank\" rel=\"noopener noreferrer\">官网</a></p>\n</div>\n<h3 id=\"不要基于即将-rebase-的分支去切新分支\"> 不要基于即将 rebase 的分支去切新分支</h3>\n<div style=\"text-align: center;\">\n  <svg id=\"SvgjsSvg1440\" width=\"500.328125\" height=\"228\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><defs id=\"SvgjsDefs1441\"><marker id=\"SvgjsMarker1474\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1475\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#f44336\" stroke=\"#f44336\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1478\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1479\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#1976d2\" stroke=\"#1976d2\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1494\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1495\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#1976d2\" stroke=\"#1976d2\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1504\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1505\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#1976d2\" stroke=\"#1976d2\" stroke-width=\"1\"></path></marker></defs><g id=\"SvgjsG1442\" transform=\"translate(163.5,93)\"><path id=\"SvgjsPath1443\" d=\"M 0 14.5C 0 -4.833333333333333 27 -4.833333333333333 27 14.5C 27 33.833333333333336 0 33.833333333333336 0 14.5Z\" stroke=\"rgba(25,118,210,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1444\"><text id=\"SvgjsText1445\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"7px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"4.875\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1446\" transform=\"translate(159.5,93)\"><path id=\"SvgjsPath1447\" d=\"M 0 0L 35 0L 35 29L 0 29Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1448\"><text id=\"SvgjsText1449\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"35px\" fill=\"#1976d2\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"2.5\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1450\" dy=\"20\" x=\"17.5\"><tspan id=\"SvgjsTspan1451\" style=\"text-decoration:;\">b</tspan></tspan></text></g></g><g id=\"SvgjsG1452\" transform=\"translate(159.5,25)\"><path id=\"SvgjsPath1453\" d=\"M 0 0L 35 0L 35 29L 0 29Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1454\"><text id=\"SvgjsText1455\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"35px\" fill=\"#f44336\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"2.5\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1456\" dy=\"20\" x=\"17.5\"><tspan id=\"SvgjsTspan1457\" style=\"text-decoration:;\">a</tspan></tspan></text></g></g><g id=\"SvgjsG1458\" transform=\"translate(25,25)\"><path id=\"SvgjsPath1459\" d=\"M 0 0L 82 0L 82 29L 0 29Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1460\"><text id=\"SvgjsText1461\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"82px\" fill=\"#f44336\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"2.5\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1462\" dy=\"20\" x=\"41\"><tspan id=\"SvgjsTspan1463\" style=\"text-decoration:;\">develop</tspan></tspan></text></g></g><g id=\"SvgjsG1464\" transform=\"translate(25,93)\"><path id=\"SvgjsPath1465\" d=\"M 0 0L 82 0L 82 29L 0 29Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1466\"><text id=\"SvgjsText1467\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"82px\" fill=\"#1976d2\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"2.5\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1468\" dy=\"20\" x=\"41\"><tspan id=\"SvgjsTspan1469\" style=\"text-decoration:;\">feature</tspan></tspan></text></g></g><g id=\"SvgjsG1470\"><path id=\"SvgjsPath1471\" d=\"M66 55L66 72.25L66 72.25L66 92\" stroke=\"#1976d2\" stroke-width=\"2\" fill=\"none\"></path></g><g id=\"SvgjsG1472\"><path id=\"SvgjsPath1473\" d=\"M108 39.5L132.75 39.5L132.75 39.5L155.89999999999998 39.5\" stroke=\"#f44336\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1474)\"></path></g><g id=\"SvgjsG1476\"><path id=\"SvgjsPath1477\" d=\"M108 107.5L133.5 107.5L133.5 107.5L155.89999999999998 107.5\" stroke=\"#1976d2\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1478)\"></path></g><g id=\"SvgjsG1480\" transform=\"translate(291.5,96.47916666666666)\"><path id=\"SvgjsPath1481\" d=\"M 0 0L 35 0L 35 22.041666666666686L 0 22.041666666666686Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1482\"><text id=\"SvgjsText1483\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"35px\" fill=\"#1976d2\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"-0.9791666666666572\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1484\" dy=\"20\" x=\"17.5\"><tspan id=\"SvgjsTspan1485\" style=\"text-decoration:;\">b'</tspan></tspan></text></g></g><g id=\"SvgjsG1486\" transform=\"translate(228.5,93)\"><path id=\"SvgjsPath1487\" d=\"M 0 0L 35 0L 35 29L 0 29Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1488\"><text id=\"SvgjsText1489\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"35px\" fill=\"#f44336\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"2.5\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1490\" dy=\"20\" x=\"17.5\"><tspan id=\"SvgjsTspan1491\" style=\"text-decoration:;\">a</tspan></tspan></text></g></g><g id=\"SvgjsG1492\"><path id=\"SvgjsPath1493\" d=\"M195.5 39.5L246 39.5L246 89.4\" stroke=\"#1976d2\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1494)\"></path></g><g id=\"SvgjsG1496\" transform=\"translate(136,167.00000000000003)\"><path id=\"SvgjsPath1497\" d=\"M 0 0L 82 0L 82 29L 0 29Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1498\"><text id=\"SvgjsText1499\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"82px\" fill=\"#388e3c\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"2.5\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1500\" dy=\"20\" x=\"41\"><tspan id=\"SvgjsTspan1501\" style=\"text-decoration:;\">feature_b</tspan></tspan></text></g></g><g id=\"SvgjsG1502\"><path id=\"SvgjsPath1503\" d=\"M184.5 123L184.5 141.9583333333333L309 141.9583333333333L309 122.12083333333334\" stroke=\"#1976d2\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1504)\"></path></g><g id=\"SvgjsG1506\"><path id=\"SvgjsPath1507\" d=\"M177 123L177 142.08333333333334L177 142.08333333333334L177 166.00000000000003\" stroke=\"#388e3c\" stroke-width=\"2\" fill=\"none\"></path></g><g id=\"SvgjsG1508\" transform=\"translate(257,68.16666666666663)\"><path id=\"SvgjsPath1509\" d=\"M 0 0L 120 0L 120 43L 0 43Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1510\"><text id=\"SvgjsText1511\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"120px\" fill=\"#1976d2\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"11.875\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1512\" dy=\"16\" x=\"60\"><tspan id=\"SvgjsTspan1513\" style=\"text-decoration:;\">rebase develop</tspan></tspan></text></g></g><g id=\"SvgjsG1514\" transform=\"translate(224.33333333333337,159.99999999999997)\"><path id=\"SvgjsPath1515\" d=\"M 0 0L 250.83333333333337 0L 250.83333333333337 43L 0 43Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1516\"><text id=\"SvgjsText1517\" font-family=\"微软雅黑\" text-anchor=\"start\" font-size=\"13px\" width=\"251px\" fill=\"#388e3c\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"start\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"3.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1518\" dy=\"16\" x=\"0\"><tspan id=\"SvgjsTspan1519\" style=\"text-decoration:;\">此时 feature_b 还在 b 节点</tspan></tspan><tspan id=\"SvgjsTspan1520\" dy=\"16\" x=\"0\"><tspan id=\"SvgjsTspan1521\" style=\"text-decoration:;\">然而 feature rebase 完，已经没有 b 了</tspan></tspan></text></g></g></svg>\n  <p style=\"text-align:center; color: #888;\">（不要基于 rebase 的分支，切新分支）</p>\n</div>\n<p>如上图所示：</p>\n<ul>\n<li>feature 通过场景 2 中的 rebase 两步走之后，与 develop 实现了同步。</li>\n<li>但是原先基于 feature 切出去的新分支 feature_b 还是原来的 commit b。</li>\n<li>此时无论 develop 还是 feature，再合并 feature_b 的时候，都会产生冲突，形成两个相同的提交记录（其实就是 b 和 b'）。</li>\n</ul>\n<p>所以，首先要确保你的分支已经完成新需求，然后在 rebase 操作结束之后，再去切新分支，这时他们才是同步的。</p>\n<h3 id=\"不要对已经合并到主分支的本地修改进行变基\"> 不要对已经合并到主分支的本地修改进行变基</h3>\n<p>首先，自己的分支，如果想对已经推送的 commit 进行修改，可以在修改完后，使用 <code>git push -f</code> 强行 push 并覆盖远程对应分支。</p>\n<p>但是如果这些修改已经被合到了其他分支（比如主分支），那又会出现冲突，因为其他分支保存的是你 rebase 之前合进去的 commit。</p>\n<p>典型操作（应避免）：</p>\n<ul>\n<li>feature 分支有三个新需求（a，b，c）。</li>\n<li>develop 合并 feature 后，保持同步完成。</li>\n<li>这个时候 feature 分支使用 <code>rebase -i</code>，对中间 b 进行修改，导致 b 和 c 的 commit-id 都发生了改变。</li>\n<li>develop 再合并 feature 时，就会产生冲突，解决后，会多出两次重复的提交记录（以前就有 b，c，现在又多了 b'，c'）。</li>\n</ul>\n<h3 id=\"不要在预发布-正式分支上使用-rebase-i\"> 不要在预发布/正式分支上使用 rebase -i</h3>\n<p>从变基的那个节点开始往后的所有节点的 commit-id 都会发生变化，这个就不再赘述了。</p>\n<p>所以可以想象一下，master 上有 100 个 commit，你悄悄改了第 50 个 commit，那从 50—100 的所有 commit 全部改变了。这时别人的分支合进来，就会有 51 个冲突，解决完冲突之后，就会产生 51*2 个相同的提交记录，恐怖如斯！</p>\n<h2 id=\"总结\"> 总结</h2>\n<p>总的原则是，<strong>只对尚未推送或未分享给别人的本地修改执行变基操作清理历史，永远不要对已推送至别处的提交执行变基操作</strong>。这样，你才能享受到两种方式（rebase 和 merge）带来的便利。</p>\n<p>（完）</p>\n",
      "date_published": "2021-12-10T10:03:33.000Z",
      "date_modified": "2022-04-11T08:33:36.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "配置密钥实现免密操作",
      "url": "https://www.fedbook.cn/basic-skills/git/add-ssh-key/",
      "id": "https://www.fedbook.cn/basic-skills/git/add-ssh-key/",
      "content_html": "<h1 id=\"配置密钥实现免密操作\"> 配置密钥实现免密操作</h1>\n<blockquote>\n<p>本文介绍如何在本地电脑上生成 ssh 秘钥并配置到 GitHub，实现免密 pull、push 代码。</p>\n</blockquote>\n<p>Git 支持 https 和 git 两种传输协议，例如在 GitHub 在 clone 代码时会有两种协议可选：</p>\n<ul>\n<li>Clone with HTTPS：<code>https://github.com/[your-github-id]/[repo-name].git</code></li>\n<li>Clone with SSH：<code>git@github.com:[your-github-id]/[repo-name].git</code></li>\n</ul>\n<p>若使用 https 协议，每次 pull、push 代码均提示要输入密码；若使用 git 协议，然后通过 ssh 密钥对认证，即可实现免密操作。</p>\n<p><strong>本文面向使用 git 协议的情况</strong>，我平时不是通过该协议操作的，因此仅是验证了一下操作步骤。</p>\n<p>配置 Git 通过 ssh 协议免密需要三个步骤：</p>\n<ul>\n<li>生成密钥对</li>\n<li>配置远程仓库（这里使用 GitHub）上的公钥</li>\n<li>把 Git 的 remote url 修改为 git 协议\n<ul>\n<li>上面两个步骤初次设置过以后，以后使用都不需要再次设置；此步骤视以后项目的 remote url 而定，如果以后其他项目的协议为 https 则需要此步骤。</li>\n</ul>\n</li>\n</ul>\n<p>下面具体介绍每一步骤：</p>\n<h3 id=\"本地生成-ssh-秘钥\"> 本地生成 ssh 秘钥</h3>\n<p>打开终端，执行 <code>ssh-keygen -t rsa -C &quot;你在GitHub上使用的邮箱地址&quot;</code>，如果执行成功，切换到 <code>~/.ssh</code> 目录下，此时目录应该如下所示。</p>\n<div><pre><code>├── id_rsa       <span># 私钥</span>\n├── id_rsa.pub   <span># 公钥</span>\n└── known_hosts  <span># 记录每个你访问过的计算机的公钥(public key), 防止 DNS 攻击</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"添加公钥到自己的远程仓库-github\"> 添加公钥到自己的远程仓库（GitHub）</h3>\n<p>复制公钥（<code>id_rsa.pub</code>）的内容，访问 GitHub，依次进入：<code>Settings --&gt; SSH and GPG keys --&gt; New SSH key</code>。</p>\n<p><code>Title</code> 随便填写（有意义方便区分即可），公钥粘贴到的 <code>Key</code> 文本域内，点击 <code>Add SSH key</code> 按钮，这一步就完成了将你的公钥放到了 Github 上进行托管。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/github-add-ssh-key.png\" alt=\"Add SSH key\">\n  <p style=\"text-align: center; color: #888;\">（Add SSH key）</p>\n</div>\n<h3 id=\"修改-git-的-remote-url\"> 修改 git 的 remote url</h3>\n<p>在本地的某个仓库目录内使用命令 <code>git remote -v</code> 查看你当前的 remote url：</p>\n<div><pre><code>origin  https://github.com/<span>[</span>your-github-id<span>]</span>/<span>[</span>repo-name<span>]</span>.git <span>(</span>fetch<span>)</span>\norigin  https://github.com/<span>[</span>your-github-id<span>]</span>/<span>[</span>repo-name<span>]</span>.git <span>(</span>push<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>如果是以上的结果那么说明此项目是使用 https 协议进行访问的（如果地址是 git 开头则表示是 git 协议）。</p>\n<p>登陆你的 GitHub，在上面可以看到仓库的 ssh 协议相应的 url，复制查询到的 ssh 链接，然后使用命令 <code>git remote set-url</code> 来调整 url：</p>\n<div><pre><code><span>git</span> remote set-url origin git@github.com:<span>[</span>your-github-id<span>]</span>/<span>[</span>repo-name<span>]</span>.git\n</code></pre>\n<div><span>1</span><br></div></div><p>再次使用命令 <code>git remote -v</code> 查看一下，url 是否已经变成了 ssh 地址：</p>\n<div><pre><code>origin git@github.com:<span>[</span>your-github-id<span>]</span>/<span>[</span>repo-name<span>]</span>.git <span>(</span>fetch<span>)</span>\norigin git@github.com:<span>[</span>your-github-id<span>]</span>/<span>[</span>repo-name<span>]</span>.git <span>(</span>push<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>接下来就可以愉快地使用 git fetch，git pull，git push，不用再输入密码。</p>\n<h3 id=\"后记\"> 后记</h3>\n<p>和 https 拉取方式不同的是，https 方式需要每次提交前都手动输入用户名和密码，ssh 的方式配置完毕后 Git 都会使用你本地的私钥和远程仓库的公钥进行验证是否是一对秘钥，从而简化了操作流程。</p>\n<p>但是如果使用的是 Windows 电脑，在使用 ssh 的方式登录过一次后，Windows 操作系统的凭据管理器会记录我们的登录信息，下次操作就不用频繁输入账号密码了。这很方便，所以我一般还是采用 ssh 的方式来操作 Git。</p>\n<p>（完）</p>\n",
      "date_published": "2021-11-18T08:49:39.000Z",
      "date_modified": "2021-11-18T08:49:39.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "clone 速度过慢",
      "url": "https://www.fedbook.cn/basic-skills/git/solution-to-clone-too-slow/",
      "id": "https://www.fedbook.cn/basic-skills/git/solution-to-clone-too-slow/",
      "content_html": "<h1 id=\"clone-速度过慢\"> clone 速度过慢</h1>\n<h2 id=\"问题描述\"> 问题描述</h2>\n<p>想从 GitHub 上面 clone 项目，很多情况下会慢的离谱，等待好久后报错：</p>\n<div style=\"color: #FF6827;\">\nfatal: early EOF  <br>\nfatal: the remote end hung up unexpectedly  <br>\nfatal: index-pack failed  <br>\nerror: RPC failed; curl 18 transfer closed with outstanding read data remaining\n</div>\n<p>网上有一些方法：复制项目到码云（比较麻烦），修改 hosts 文件（以前有用），调整 Git 的传输缓存（仅用于解决文件过大导致的下载慢问题，不能解决网络本身带来的问题）。</p>\n<p>最终方案还得是给 Git 设置代理模式。</p>\n<h2 id=\"解决方案\"> 解决方案</h2>\n<p>需要用到几个命令，注意下面的端口 <code>1080</code> 和 <code>1081</code> 都是我自行配置的，每个人情况可能不一样。</p>\n<ul>\n<li>1080：SOCKS 端口</li>\n<li>1081：HTTP 端口（某些软件默认的 SOCKS + 1）</li>\n</ul>\n<h3 id=\"设置代理\"> 设置代理</h3>\n<div><p>小贴士</p>\n<p>我推荐使用专用代理里中 http 代理，这是不容易有负面影响且切实有效的，因为 GitHub 在某次更新后，socks 代理有时候会被拒绝。<br>\n但其它代理模式的命令还是要整理一下的，万一需要用到呢~</p>\n</div>\n<p>全局代理：使用后作用于全局环境，太极端，一般不推荐。</p>\n<div><pre><code><span># 使用 http 协议(推荐)</span>\n<span>git</span> config --global http.proxy <span>127.0</span>.0.1:1081\n<span># 或使用 socks 协议(不推荐, 忘记会有什么坑了)</span>\n<span>git</span> config --global http.proxy socks5://127.0.0.1:1080\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>局部代理：在 github clone 的仓库内执行，不是很方便，一般不推荐。</p>\n<div><pre><code><span># 使用 http 协议(推荐)</span>\n<span>git</span> config --local http.proxy <span>127.0</span>.0.1:1081\n<span># 或使用 socks 协议(不推荐, 忘记会有什么坑了)</span>\n<span>git</span> config --local http.proxy socks5://127.0.0.1:1080\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>专用代理：只对 github 进行代理，对国内的仓库不影响，推荐！</p>\n<div><pre><code><span># 使用 http 协议(推荐)</span>\n<span>git</span> config --global http.https://github.com.proxy <span>127.0</span>.0.1:1081\n<span># 或使用 socks 协议(不推荐, 忘记会有什么坑了)</span>\n<span>git</span> config --global http.https://github.com.proxy socks5://127.0.0.1:1080\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"查询目前是否使用了代理\"> 查询目前是否使用了代理</h3>\n<p>查询当前的 Git 环境是否使用了代理。</p>\n<p>查询全局代理：</p>\n<div><pre><code><span>git</span> config --global http.proxy\n</code></pre>\n<div><span>1</span><br></div></div><p>查询局部代理：</p>\n<div><pre><code><span>git</span> config --local http.proxy\n</code></pre>\n<div><span>1</span><br></div></div><p>查询专用代理（对 github 进行的代理）：</p>\n<div><pre><code><span>git</span> config --global http.https://github.com.proxy\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"取消代理\"> 取消代理</h3>\n<p>取消当前 Git 环境使用的代理，恢复直连模式。</p>\n<p>取消全局代理：</p>\n<div><pre><code><span>git</span> config --global --unset http.proxy\n</code></pre>\n<div><span>1</span><br></div></div><p>取消局部代理：</p>\n<div><pre><code><span>git</span> config --local --unset http.proxy\n</code></pre>\n<div><span>1</span><br></div></div><p>取消专用代理（对 github 进行的代理）：</p>\n<div><pre><code><span>git</span> config --global --unset http.https://github.com.proxy\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"补充-关于调整-git-的传输缓存\"> 补充：关于调整 Git 的传输缓存</h2>\n<p>网上很多文章多 clone 过慢或 push 时因为文件过大导致报错时，可以调整 Git 的传输缓存：</p>\n<div><pre><code><span># Git 默认设置 http post 的缓存为 1M, 很多文章建议调大一点, 例如 500M。</span>\n<span>git</span> config --global http.postBuffer <span>524288000</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>但我发现这非但解决不了本文提到的问题，而且即使真遇到大文件的情况，官方也并不推荐这么做，详见：</p>\n<p>《<a href=\"https://docs.microsoft.com/en-us/azure/devops/repos/git/rpc-failures-http-postbuffer?view=azure-devops\" target=\"_blank\" rel=\"noopener noreferrer\">Git: Stop changing http.postBuffer...</a>》</p>\n<p>（完）</p>\n",
      "date_published": "2021-11-18T09:53:02.000Z",
      "date_modified": "2022-03-12T14:44:32.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "pull 时发现代码冲突，如何解决",
      "url": "https://www.fedbook.cn/basic-skills/git/solution-to-code-conflict/",
      "id": "https://www.fedbook.cn/basic-skills/git/solution-to-code-conflict/",
      "content_html": "<h1 id=\"pull-时发现代码冲突-如何解决\"> pull 时发现代码冲突，如何解决</h1>\n<h2 id=\"冲突产生的原因\"> 冲突产生的原因</h2>\n<p>多人协作的开发模式，在代码合并/更新代码时经常会遇到冲突的情况，最常见的是在 <code>push</code> 时，Git 发现本地修改的某个文件在远端也做了修改，那么就会提示需要先进行 <code>pull</code>。</p>\n<p><code>pull</code> 后会有两种情况：</p>\n<ul>\n<li>Git 自动做了合并（无需理会）</li>\n<li>提示有文件存在冲突 - CONFLICT</li>\n</ul>\n<p>还有一种情况就是同一个文件，在合并分支的时候，如果同一行被多个分支或者不同人都修改了，合并的时候也会出现冲突。</p>\n<h2 id=\"解决冲突的步骤\"> 解决冲突的步骤</h2>\n<p>解决冲突需要自己去判断到底要保留远端代码还是本地代码或者两端都保留。</p>\n<p>这个操作一般借助可视化工具进行比较方便，具体步骤如下：</p>\n<ul>\n<li>查看冲突文件内容</li>\n<li>确定冲突内容保留哪些部分，修改文件</li>\n<li>重新提交，done</li>\n</ul>\n<h2 id=\"冲突标记介绍\"> 冲突标记介绍</h2>\n<p>Git 提示冲突后，我们切换到对应文件，可以看到冲突内容被标记出来了。</p>\n<div><pre><code><span>&lt;&lt;&lt;</span><span>&lt;&lt;&lt;</span><span>&lt;</span> HEAD:file.txt\n\nHello world\n\n<span>==</span><span>==</span><span>==</span><span>=</span>\n\nGoodbye\n\n<span>>></span><span>>></span><span>>></span><span>></span> 77976da35a11db4580b80ae27e8d65caf5208086:file.txt\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>可以看到Git用 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 将代码分成了三个区域。</p>\n<ul>\n<li><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code> 和 <code>=======</code> 之间的内容表示你本地的分支。</li>\n<li><code>=======</code> 和 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 之间的表示本次 <code>pull</code> 下来或 <code>merge</code> 过来的内容。</li>\n</ul>\n<h2 id=\"两种方式解决冲突\"> 两种方式解决冲突</h2>\n<h3 id=\"方案一-用-merge-来解决冲突\"> 方案一：用 merge 来解决冲突</h3>\n<p>假设小甲和小乙是同事，两个人一起维护一个项目。某天小甲修改了一份文件（<code>conflict-resolve.md</code>）的第一行代码，提交并推送到了远程分支。</p>\n<p>此时小乙并不知情，在没有事先 pull 最新代码的前提下，他也修改了同一份文件的同一行代码。那么在小乙操作的时候，必然会遇到代码冲突的情况了。</p>\n<p>此时对小乙来说，他的操作顺序如下：</p>\n<ul>\n<li>本地开发完，提交代码：<code>git commit</code>。</li>\n<li>将代码推送到远程分支：<code>git push</code>（但由于小甲先一步往远程分支提交了代码，此时本地代码不是最新的，这步 push 操作会提示和远端版本不一致而中断）。</li>\n<li>拉取最新远程分支代码：<code>git pull</code>（执行完命令，会提示有代码冲突，需要先解决冲突）。</li>\n<li>解决代码冲突，然后使用 <code>git add conflict-resolve.md</code> 标注冲突已解决。</li>\n<li>重新提交代码：<code>git commit</code>（解决冲突的过程其实存在一个 merge 操作）。</li>\n<li>将代码推送到远程分支：<code>git push</code>。</li>\n</ul>\n<p>通过在当前仓库目录下输入 <code>gitk</code> 或 <code>git log --oneline --graph --decorate --all</code> 命令查看节点树，也可以通过其它一些可视化工具获取更好的展示效果。</p>\n<p>这里我在 GitHub 上查看到的 commit 记录和使用 Sourcetree 获得到的节点树界面如下：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/conflict-resolve-commits.png\" alt=\"解决代码冲突产生的 commit 记录\">\n  <p style=\"text-align:center; color: #888;\">（解决代码冲突产生的 commit 记录）</p>\n</div>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/conflict-resolve-tree.png\" alt=\"解决代码冲突产生的节点树\">\n  <p style=\"text-align:center; color: #888;\">（解决代码冲突产生的节点树）</p>\n</div>\n<p>观察上述两张图的最新 3 条记录（小甲 1 条，小乙 2 条），可以发现解决代码冲突的过程其实也是一次 merge 操作。</p>\n<p>小乙将代码推送到 Git 服务器后，整个过程他的操作一共产生了 2 个 commit 记录（一个是对第一行代码修改的提交：<code>8ee4fbe</code>，一个是刚才的 merge 动作）。同时在节点树可以看到提交历史产生了分叉，这种分叉再汇合的结构会让有些人觉得混乱而难以管理。</p>\n<h3 id=\"方案二-用-git-rebase-消除分叉\"> 方案二：用 git rebase 消除分叉</h3>\n<p>如果你不希望 commit 历史出现分叉，可以借助 rebase 命令来消除分叉。</p>\n<p>此时小乙的操作操作流程如下：</p>\n<ul>\n<li>本地开发完，提交代码：<code>git commit</code>。</li>\n<li>将代码推送到远程分支：<code>git push</code>（但由于小甲先一步往远程分支提交了代码，此时本地代码不是最新的，这步 push 操作会提示和远端版本不一致而中断）。</li>\n<li>拉取最新远程分支代码：<code>git pull --rebase</code>（执行完命令，可以看到冲突，并且进入了 rebase 状态）。</li>\n<li>解决代码冲突，然后使用 <code>git add conflict-resolve.md</code> 标注冲突已解决。</li>\n<li>合并冲突，执行命令：<code>git rebase --continue</code>（执行这步操作会先进入 commit 信息确认界面，通过输入 <code>:wq</code> 退出信息确认界面完成命令的执行）。</li>\n<li>将代码推送到远程分支：<code>git push</code>。</li>\n</ul>\n<p>这时再登录 GitHub 查看到的 commit 记录和使用 Sourcetree 获得到的节点树界面如下：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/conflict-resolve-using-rebase-commits.png\" alt=\"使用 rebase 命令解决代码冲突产生的 commit 记录\">\n  <p style=\"text-align:center; color: #888;\">（使用 rebase 命令解决代码冲突产生的 commit 记录）</p>\n</div>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/conflict-resolve-using-rebase-tree.png\" alt=\"使用 rebase 命令解决代码冲突产生的节点树\">\n  <p style=\"text-align:center; color: #888;\">（使用 rebase 命令解决代码冲突产生的节点树）</p>\n</div>\n<p>观察上述两张图的最新 2 条记录（小甲 1 条，小乙 1 条），可以发现此时小乙解决代码冲突的过程只产生了一个 commit 记录，而且节点树中的提交历史也没有产生分叉。</p>\n<p>事实上，小乙在第一次 <code>git commit</code> 的时候，他的 commit 编号是 <code>37dc33a</code>，经过解决冲突后这个编号被新的编号 <code>e93c9c6</code> 所取代，commit 的内容不变。</p>\n<h3 id=\"rebase-的优点和缺点\"> rebase 的优点和缺点</h3>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>rebase 最大的好处是你的项目历史会非常整洁。</li>\n<li>rebase 导致最后的项目历史呈现出完美的线性 —— 你可以从项目终点到起点浏览而不需要任何的 fork。这让你更容易使用 git log、git bisect 和 gitk 来查看项目历史。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>安全性，如果你违反了 rebase 黄金法则，重写项目历史可能会给你的协作工作流带来灾难性的影响。</li>\n<li>可跟踪性，rebase 不会有合并提交中附带的信息 —— 你看不到 feature 分支中并入了上游的哪些更改。</li>\n</ul>\n<h2 id=\"推荐操作\"> 推荐操作</h2>\n<p>在多人协作的开发模式中，为了避免一些麻烦，我一般会有两个习惯：</p>\n<ul>\n<li>准备开始编写代码了，先看看版本库里有没有别人提交的记录，不管怎样先在本地 <code>pull</code> 一下。</li>\n<li>代码编写完成了，本地环境先 <code>commit</code>，然后 <code>pull</code>，再 <code>push</code>。</li>\n</ul>\n<div><p>为什么要先 commit，然后 pull，再 push？</p>\n<p><code>commit</code> 是告诉 Git，这次提交改了哪些东西，不然只是自己改了，Git 不知道你改了，无从判断比较。<br>\n<code>pull</code> 是为了本地 <code>commit</code> 和远程 <code>commit</code> 的对比记录，Git 按照文件的行数操作进行对比，如果同时操作了某文件的同一行那么就会产生冲突，这时候需要手动解决，保留本地分支代码还是保留远程分支代码。</p>\n<p>本地代码进行 <code>commit</code> 后，仓库不会将本地代码与远程仓库代码进行比较，不会识别是否存在代码冲突，必须进行 <code>pull</code> 命令后，才会将本地代码与仓库远程代码进行比较，如果存在冲突，必须要解决冲突后重新 <code>commit</code> 和 <code>push</code>。不存在冲突，会在 <code>pull</code> 时直接合并代码，不会将本地代码覆盖掉。</p>\n</div>\n<p>（完）</p>\n",
      "date_published": "2021-11-19T09:40:19.000Z",
      "date_modified": "2022-01-13T07:56:16.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "修改 commit 信息",
      "url": "https://www.fedbook.cn/basic-skills/git/solution-to-commit-info-mistake/",
      "id": "https://www.fedbook.cn/basic-skills/git/solution-to-commit-info-mistake/",
      "content_html": "<h1 id=\"修改-commit-信息\"> 修改 commit 信息</h1>\n<h2 id=\"问题描述\"> 问题描述</h2>\n<p>刚刚做了一次提交，发现 <code>commit info</code> 填写错了，想要修改。</p>\n<h2 id=\"解决方案\"> 解决方案</h2>\n<p>分为两种情况，未推送到远程仓库和已推送到远程仓库。</p>\n<h3 id=\"情况一-已-commit-未-push\"> 情况一：已 commit 未 push</h3>\n<p>已经执行 <code>commit</code>，但还没有 <code>push</code>，要想更改 commit 信息（修改最近一次提交）。</p>\n<div><pre><code><span>git</span> commit --amend\n</code></pre>\n<div><span>1</span><br></div></div><p>执行上述命令后，进入注释页面进行修改，修改后保存退出。</p>\n<p>然后使用 <code>git log --pretty=oneline</code> 查看内容，可以发现已经成功修改了。</p>\n<p><strong>需要注意的是此项命令会修改提交时的 <code>commit-id</code>，即会覆盖原本的提交，需要谨慎操作</strong>。</p>\n<h3 id=\"情况二-已-commit-已-push\"> 情况二：已 commit 已 push</h3>\n<p>已经执行 <code>commit</code>，且已经 <code>push</code> 的提交（修改最近一次提交）。</p>\n<div><pre><code><span>git</span> commit --amend\n</code></pre>\n<div><span>1</span><br></div></div><p>执行上述命令后，进入注释页面进行修改，修改后保存退出。</p>\n<p>然后执行强制推送命令：</p>\n<div><pre><code><span>git</span> push --force-with-lease origin master\n</code></pre>\n<div><span>1</span><br></div></div><p>（完）</p>\n",
      "date_published": "2021-11-19T06:36:38.000Z",
      "date_modified": "2022-04-11T08:33:36.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "如何修改历史 commits 中的用户名和邮箱",
      "url": "https://www.fedbook.cn/basic-skills/git/solution-to-change-name-and-email-in-history-commits/",
      "id": "https://www.fedbook.cn/basic-skills/git/solution-to-change-name-and-email-in-history-commits/",
      "content_html": "<h1 id=\"如何修改历史-commits-中的用户名和邮箱\"> 如何修改历史 commits 中的用户名和邮箱</h1>\n<h2 id=\"问题描述\"> 问题描述</h2>\n<p>出于某些需求，想要：</p>\n<ul>\n<li>修改某个仓库历史 commit 的用户 name 和 email 信息。</li>\n<li>将历史提交记录中的指定 name/email 修改为新的 name/email。</li>\n</ul>\n<h2 id=\"解决方案\"> 解决方案</h2>\n<p>主要分为四个步骤：</p>\n<ul>\n<li>确认本地全局邮箱/用户名</li>\n<li>查看仓库的历史提交信息</li>\n<li>批量修改历史记录中的信息</li>\n<li>将修改结果推送到远程</li>\n</ul>\n<h3 id=\"确认本地全局邮箱-用户名\"> 确认本地全局邮箱/用户名</h3>\n<p>使用下面两个命令查看 Git 在本地的全局邮箱和用户名：</p>\n<div><pre><code><span>git</span> config user.name\n<span>git</span> config user.email\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>如果需要修改 Git 在本地的全局邮箱和用户名，执行下面的命令：</p>\n<div><pre><code><span>git</span> config --global user.name <span>\"输入你的用户名\"</span>\n<span>git</span> config --global user.email <span>\"输入你的邮箱\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>现在我们已经设置好了本地 Git 的 <code>user.name</code> 和 <code>user.email</code> 信息。</p>\n<h3 id=\"查看仓库的历史提交信息\"> 查看仓库的历史提交信息</h3>\n<p>进入目标仓库目录，打开 git bash 界面，执行以下命令查看历史提交信息（重点关注 Author）：</p>\n<div><pre><code><span>git</span> log\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"批量修改历史记录中的信息\"> 批量修改历史记录中的信息</h3>\n<p>打开一个文本编辑器，粘贴下面代码。</p>\n<p>主要需要把 <code>OLD_EMAIL</code>，<code>CORRECT_NAME</code>，<code>CORRECT_EMAIL</code> 改成自己的新旧邮箱和新用户名。</p>\n<div><pre><code><span>git</span> filter-branch -f --env-filter <span>'\nOLD_EMAIL=\"原来的邮箱\"\nCORRECT_NAME=\"现在的名字\"\nCORRECT_EMAIL=\"现在的邮箱\"\nif [ \"$GIT_COMMITTER_EMAIL\" = \"$OLD_EMAIL\" ]\nthen\n    export GIT_COMMITTER_NAME=\"$CORRECT_NAME\"\n    export GIT_COMMITTER_EMAIL=\"$CORRECT_EMAIL\"\nfi\nif [ \"$GIT_AUTHOR_EMAIL\" = \"$OLD_EMAIL\" ]\nthen\n    export GIT_AUTHOR_NAME=\"$CORRECT_NAME\"\n    export GIT_AUTHOR_EMAIL=\"$CORRECT_EMAIL\"\nfi\n'</span> --tag-name-filter <span>cat</span> -- --branches --tags\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>回到 git bash 界面，复制粘贴上面的代码并按回车执行。</p>\n<p>如果 commit 记录比较多的话执行的时间会比较长。</p>\n<p>等待执行完成后，再查看 <code>git log</code> 可以看到已经修改成功。</p>\n<div><p>注意</p>\n<p>如果上面的批量修改命令执行失败的话，执行一下这段命令：</p>\n<div><pre><code><span>git</span> filter-branch -f --index-filter <span>'git rm --cached --ignore-unmatch Rakefile'</span> HEAD\n</code></pre>\n<div><span>1</span><br></div></div><p>再次复制粘贴批量修改的代码并按回车执行。</p>\n</div>\n<h3 id=\"将修改结果推送到远程\"> 将修改结果推送到远程</h3>\n<p>这时候虽然本地修改成功了，但是你还没有推送到远程。</p>\n<p>所以再执行一下命令：</p>\n<div><pre><code><span>git</span> push origin --force --all\n</code></pre>\n<div><span>1</span><br></div></div><p>去看一下 Github 你就会发现之前的提交记录中，name 和 email 信息都更新了。</p>\n<h2 id=\"linux-mac下可以写个脚本\"> Linux/Mac下可以写个脚本</h2>\n<p>在项目根目录下创建 <code>git-email.sh</code>，写入下面这段代码：</p>\n<div><pre><code><span>#!/bin/sh</span>\n\n<span>git</span> filter-branch --env-filter <span>'\n\nOLD_EMAIL=\"原来的邮箱\"\nCORRECT_NAME=\"现在的名字\"\nCORRECT_EMAIL=\"现在的邮箱\"\n\nif [ \"$GIT_COMMITTER_EMAIL\" = \"$OLD_EMAIL\" ]\nthen\n    export GIT_COMMITTER_NAME=\"$CORRECT_NAME\"\n    export GIT_COMMITTER_EMAIL=\"$CORRECT_EMAIL\"\nfi\nif [ \"$GIT_AUTHOR_EMAIL\" = \"$OLD_EMAIL\" ]\nthen\n    export GIT_AUTHOR_NAME=\"$CORRECT_NAME\"\n    export GIT_AUTHOR_EMAIL=\"$CORRECT_EMAIL\"\nfi\n'</span> --tag-name-filter <span>cat</span> -- --branches --tags\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>然后需要赋予执行权限：</p>\n<div><pre><code><span>chmod</span> +x git-email.sh\n</code></pre>\n<div><span>1</span><br></div></div><p>执行一下这个 <code>.sh</code> 文件：</p>\n<div><pre><code>./git-email.sh\n</code></pre>\n<div><span>1</span><br></div></div><p><code>git log</code> 检查修改成功后，就可以推送到远程仓库了。</p>\n<p>（完）</p>\n",
      "date_published": "2021-11-22T06:38:40.000Z",
      "date_modified": "2021-12-10T02:38:51.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "已 commit 未 push，漏提交文件",
      "url": "https://www.fedbook.cn/basic-skills/git/solution-to-missed-file-in-last-commit/",
      "id": "https://www.fedbook.cn/basic-skills/git/solution-to-missed-file-in-last-commit/",
      "content_html": "<h1 id=\"已-commit-未-push-漏提交文件\"> 已 commit 未 push，漏提交文件</h1>\n<h2 id=\"问题描述\"> 问题描述</h2>\n<p>已经 <code>commit</code> 但还未 <code>push</code> 时，发现遗漏了部分文件没有提交。</p>\n<h2 id=\"解决方案\"> 解决方案</h2>\n<p>有两种解决方案：</p>\n<h3 id=\"方案一-再次-commit\"> 方案一：再次 commit</h3>\n<div><pre><code><span>git</span> commit -m <span>\"commit info\"</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>此时，Git 上会出现两次 <code>commit</code>。</p>\n<h3 id=\"方案二-将遗漏文件提交到之前-commit-上\"> 方案二：将遗漏文件提交到之前 commit 上</h3>\n<div><pre><code><span>git</span> <span>add</span> <span>[</span>missed-file<span>]</span>  <span># missed-file 为遗漏提交的文件</span>\n<span>git</span> commit --amend --no-edit\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p><code>--no-edit</code> 表示提交消息不会更改，该操作会修改上一次提交的内容，但不会要求你编辑提交信息，仍保持上一次 <code>commit</code> 的 message。</p>\n<p>（完）</p>\n",
      "date_published": "2021-11-19T07:23:11.000Z",
      "date_modified": "2022-04-11T08:33:36.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "已 commit 未 push，想修改代码",
      "url": "https://www.fedbook.cn/basic-skills/git/solution-to-last-commit-code-mistake/",
      "id": "https://www.fedbook.cn/basic-skills/git/solution-to-last-commit-code-mistake/",
      "content_html": "<h1 id=\"已-commit-未-push-想修改代码\"> 已 commit 未 push，想修改代码</h1>\n<h2 id=\"问题描述\"> 问题描述</h2>\n<p>刚刚 <code>commit</code> 了一个代码文件（<code>test.js</code>），发现有几个字写错了，此时还未 <code>push</code>。</p>\n<p>比较粗糙的处理方式是再做一个专门修复这几个错别字的 commit。可以是可以，不过还有一个更加优雅和简单的解决方法。</p>\n<h2 id=\"解决方案\"> 解决方案</h2>\n<p>使用 <code>commit -—amend</code> 命令。</p>\n<div><p>命令解释</p>\n<p>&quot;amend&quot; 是「修正」的意思。在提交时，如果加上 <code>--amend</code> 参数，Git 不会在当前 <code>commit</code> 上增加 <code>commit</code>，而是会把当前 <code>commit</code> 里的内容和暂存区（stageing area）里的内容合并起来后创建一个新的 <code>commit</code>，<strong>用这个新的 <code>commit</code> 把当前 <code>commit</code> 替换掉</strong>。所以 <code>commit --amend</code> 做的事就是它的字面意思：对最新一条 <code>commit</code> 进行修正。</p>\n</div>\n<p>具体地，对于上面提到的这种小错误，你就可以把文件（<code>test.js</code>）中的错别字修改好之后，输入：</p>\n<div><pre><code><span>git</span> <span>add</span> test.js\n<span>git</span> commit --amend\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>Git 会把你带到提交信息编辑界面。可以看到，提交信息默认是当前提交的提交信息。你可以修改或者保留它，然后保存退出。最后，你的最近一次 commit 就被更新了。</p>\n<p>（完）</p>\n",
      "date_published": "2021-11-19T06:59:34.000Z",
      "date_modified": "2022-04-11T08:33:36.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "如何使用 GitFlow 工作流进行团队协作",
      "url": "https://www.fedbook.cn/basic-skills/git/solution-to-gitflow/",
      "id": "https://www.fedbook.cn/basic-skills/git/solution-to-gitflow/",
      "content_html": "<h1 id=\"如何使用-gitflow-工作流进行团队协作\"> 如何使用 GitFlow 工作流进行团队协作</h1>\n<blockquote>\n<p>以博客项目为例，记录一下应用 GitFlow 工作流进行团队协作的主要步骤和命令。</p>\n</blockquote>\n<h2 id=\"初始化项目\"> 初始化项目</h2>\n<p>首先创建项目，并创建一个 <code>develop</code> 分支，以后更多操作是在 <code>develop</code> 分支上进行的：</p>\n<div><pre><code><span># 创建项目</span>\n<span>mkdir</span> blog <span>&amp;&amp;</span> <span>cd</span> blog\n<span># 初始化 Git 版本库</span>\n<span>git</span> init\n<span># 添加远程版本库</span>\n<span>git</span> remote <span>add</span> origin https://github.com/<span>[</span>your-github-id<span>]</span>/blog.git\n<span># 新建 develop 分支并切换</span>\n<span>git</span> checkout -b develop\n\n<span># 初始化项目</span>\n<span>echo</span> <span>'# 个人博客'</span> <span>></span> README.md\n<span># 创建 .gitignore 文件, 用于忽略一些临时文件或自动编译生成文件</span>\n<span>touch</span> .gitignore\n<span># ...</span>\n<span>git</span> <span>add</span> <span>.</span>\n<span>git</span> commit -m <span>\"init repo\"</span>\n<span># 推送到远程开发分支</span>\n<span>git</span> push -u origin develop\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id=\"功能开发\"> 功能开发</h2>\n<p>我和小明开始独立开发自己的功能。比如，我开发<code>角色模块</code>，小明开发<code>文章模块</code>。我们都新建自己的功能分支，独立开发、独立测试，互不干扰。</p>\n<div><pre><code><span># (我)克隆版本库</span>\n<span>git</span> clone https://github.com/<span>[</span>your-github-id<span>]</span>/blog.git\n\n<span># (我)切换到 develop 分支</span>\n<span>git</span> checkout develop\n\n<span># (我)创建功能分支, 功能分支是从开发分支分叉出去的</span>\n<span>git</span> checkout -b feature/role\n\n<span># (我)现在可以愉快地开发新功能了</span>\n<span>..</span><span>..</span>\n<span># (我)将分支推送到远程版本库</span>\n<span>git</span> push origin feature/role\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id=\"代码-review-和合并\"> 代码 Review 和合并</h2>\n<p>现在，我已经完成角色模块，而且基本功能也通过了测试，是时候合并到开发分支了。我发起了 Pull Request，接受群众 Review。项目负责人可以接收 Pull Request 并将分支合并到开发分支。</p>\n<p>当然 Pull Request 只是一个可选的步骤，你可以直接将分支合并到开发分支。</p>\n<h2 id=\"发布分支\"> 发布分支</h2>\n<p>现在角色模块和文章模块都开发完毕了，项目负责人小甲掐指一算，发布新版本吉时已到，假设是 v0.1.0，从开发分支中拉取出一个发布分支：</p>\n<div><pre><code><span># 保持是最新代码</span>\n<span>git</span> pull\n<span>git</span> checkout develop\n<span>git</span> checkout -b release/v0.1.0\n<span>git</span> push -u origin release/v0.1.0\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>我们已经开始新的功能了，突然间测试报了个 bug, 我得优先处理这个 bug：</p>\n<div><pre><code><span># 但是(我)在切换分支时报了个错:</span>\n<span>git</span> checkout release/v0.1.0\nerror: Your <span>local</span> changes to the following files would be overwritten by checkout:\n  xxx.js\nPlease commit your changes or stash them before you switch branches.\nAborting\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>意思是，你的本地已经修改了一些文件，如果就这样 <code>checkout</code> 过去，将会被覆盖。你可以提交（<code>commit</code>）你的变更，或者暂存（<code>stash</code>）起来。因为我的代码写到一半，不能将没有意义的代码提交到版本库，所以只能使用后者：</p>\n<div><pre><code><span># 推荐在暂存时添加描述信息,</span>\n<span>git</span> stash push -m <span>\"更改了 xx\"</span>\n<span>git</span> checkout release/v0.1.0\n\n<span># 修复完 bug 回到原来的功能分支</span>\n<span># 恢复暂存</span>\n<span>git</span> stash pop\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"合并发布分支\"> 合并发布分支</h2>\n<p>发布分支在经过几次迭代之后，稳定性已经足以合并到 master 了：</p>\n<div><pre><code><span># 切换到 master 分支</span>\n<span>git</span> checkout master\n\n<span># 合并分支</span>\n<span>git</span> merge release/v0.1.0\n<span># 打个 tag</span>\n<span>git</span> tag -a v0.1.0 -m <span>\"v0.1.0: 包含了角色模块和文章模块等功能更新\"</span>\n<span># 推送版本库</span>\n<span>git</span> push\n<span># 推送 tags</span>\n<span>git</span> push --tags\n\n<span># 切换到开发分支</span>\n<span>git</span> checkout develop\n<span>git</span> merge release/v0.1.0\n<span>git</span> push\n\n<span># 删除发布分支</span>\n<span>git</span> branch -d release/v0.1.0\n<span># 删除远程发布分支</span>\n<span>git</span> push -d release/v0.1.0\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h2 id=\"修复-bug\"> 修复 bug</h2>\n<p>客户报了一个生产版本的 bug，这 bug 影响使用，我们必须马上修复这个 bug 并发个版：</p>\n<div><pre><code><span># 切换到 master 分支</span>\n<span>git</span> checkout master\n<span># 创建 bug 修复分支</span>\n<span>git</span> checkout -b bug/B20220212\n<span># 修复 bug 并提交</span>\n<span>git</span> commit -m <span>\"紧急修复xxxbug\"</span>\n\n<span># 合并到 master</span>\n<span>git</span> checkout master\n<span>git</span> merge bug/B20220212\n<span>git</span> tag -a v0.1.1 -m <span>\"紧急修复xxxbug\"</span>\n<span>git</span> push\n\n<span># 合并到开发分支, 因为开发分支同样有这个 bug</span>\n<span>git</span> checkout develop\n<span>git</span> merge bug/B20220212\n<span>git</span> push\n\n<span># 删除 bug 分支</span>\n<span>git</span> branch -d bug/B20220212\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>（完）</p>\n",
      "date_published": "2022-02-11T09:59:09.000Z",
      "date_modified": "2022-04-12T03:04:37.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "如何参与开源项目 - 提交 PR 与更新 Fork 分支",
      "url": "https://www.fedbook.cn/basic-skills/git/solution-to-participate-in-open-source-projects/",
      "id": "https://www.fedbook.cn/basic-skills/git/solution-to-participate-in-open-source-projects/",
      "content_html": "<h1 id=\"如何参与开源项目-提交-pr-与更新-fork-分支\"> 如何参与开源项目 - 提交 PR 与更新 Fork 分支</h1>\n<blockquote>\n<p>总结一下如何参加一个开源项目，包括 Fork 代码，提出 PR，更新 Fork 分支等主要步骤。</p>\n</blockquote>\n<h2 id=\"fork-代码\"> Fork 代码</h2>\n<p>以 vue 代码举例，首先需要将 vue 官方仓库通过 GitHub 的 Fork 功能复制一份到自己的 GitHub。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/fork-vue.png\" alt=\"Fork vuejs/vue\">\n  <p style=\"text-align:center; color: #888;\">（Fork vuejs/vue）</p>\n</div>\n<p>复制后的结果：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/forked-vue.png\" alt=\"Forked [your-github-id]/vue\">\n  <p style=\"text-align:center; color: #888;\">（Fork [your-github-id]/vue）</p>\n</div>\n<ul>\n<li>原仓库路径：<code>https://github.com/vuejs/vue</code></li>\n<li>Fork 后的仓库路径：<code>https://github.com/[your-github-id]/vue</code>（注意该代码仓库是挂在自己的用户名下的）</li>\n</ul>\n<h2 id=\"clone-到本地\"> Clone 到本地</h2>\n<p>下载刚才 Fork 的代码（我比较喜欢 SSH 方式，即 Clone with SSH）：</p>\n<div><pre><code><span>git</span> clone https://github.com/<span>[</span>your-github-id<span>]</span>/vue.git\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"开发前同步官方最新代码\"> 开发前同步官方最新代码</h2>\n<p>Fork 的代码需要随时拉取官方最新的代码更新，保持同步。</p>\n<h3 id=\"添加原作者远程分支\"> 添加原作者远程分支</h3>\n<p>这个操作只需要做一次，目的是添加原作者 remote-repo（远程库）。</p>\n<div><pre><code><span>git</span> remote <span>add</span> upstream https://github.com/vuejs/vue\n</code></pre>\n<div><span>1</span><br></div></div><p>这个时候输入 <code>git remote -v</code>，会得到结果：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/add-remote-repo.png\" alt=\"Add Remote Repo\">\n  <p style=\"text-align:center; color: #888;\">（Add Remote Repo）</p>\n</div>\n<h3 id=\"拉取合并远程分支到-master-分支\"> 拉取合并远程分支到 master 分支</h3>\n<p>这个需要随时做，保持你的 master 分支永远跟官方最新代码保持一致。</p>\n<div><pre><code><span># fetch 源仓库最新的 master 分支到本地的 upstream/master</span>\n<span>git</span> fetch upstream master\n\n<span># 切换到本地的 master 分支</span>\n<span>git</span> checkout master\n\n<span># 将来自 upstream/master 的更改合并到本地 master 分支中</span>\n<span>git</span> merge upstream/master\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"提交-pr-pull-request\"> 提交 PR（Pull Request）</h2>\n<p>在本地修改完代码后，接下来就是最后一步 Pull Request，即 PR。</p>\n<h3 id=\"推送本地分支到-github\"> 推送本地分支到 GitHub</h3>\n<p>先 commit，后 push。</p>\n<h3 id=\"pull-request\"> Pull Request</h3>\n<p>当你在上一步 push 代码后，再访问你自己的 GitHub 主页时，会有 pull request 提示：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/pull-request.png\" alt=\"Compare & pull request 提示\">\n  <p style=\"text-align:center; color: #888;\">（Compare & pull request 提示）</p>\n</div>\n<p>点击 <strong>Compare &amp; pull request</strong> 后，就会到下面这个页面，文本框中的内容要遵循统一的规定（一般符和该项目作者的规范即可），然后点击 <strong>Create pull request</strong>。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/create-pull-request.png\" alt=\"Create pull request\">\n  <p style=\"text-align:center; color: #888;\">（Create pull request）</p>\n</div>\n<p>最后就可以等待源仓库作者的处理结果了。</p>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://docs.github.com/cn/free-pro-team@latest/github/collaborating-with-issues-and-pull-requests/syncing-a-fork\" target=\"_blank\" rel=\"noopener noreferrer\">GitHub Docs</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-11-22T07:43:06.000Z",
      "date_modified": "2021-12-10T02:38:51.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "如何迁移仓库并保留 commits 记录",
      "url": "https://www.fedbook.cn/basic-skills/git/solution-to-migrate-repository-without-losing-history-commits/",
      "id": "https://www.fedbook.cn/basic-skills/git/solution-to-migrate-repository-without-losing-history-commits/",
      "content_html": "<h1 id=\"如何迁移仓库并保留-commits-记录\"> 如何迁移仓库并保留 commits 记录</h1>\n<h2 id=\"问题描述\"> 问题描述</h2>\n<p>假设我们需要在支持 Git 的代码托管平台间进行仓库的迁移，并保留历史 commit 记录。</p>\n<p>例如：</p>\n<p>将 Gitlab 上的仓库迁移到 GitHub，将 Coding 上的仓库迁移到 GitHub，将 Gitee 上的仓库迁移到 GitHub……</p>\n<p>迁移前后保留历史 commit 记录，可以确保在迁移后的新仓库中能查询历史提交信息，便于将来出现问题时追溯过去的代码变更记录。</p>\n<h2 id=\"解决方案\"> 解决方案</h2>\n<p>主要分为三个步骤：</p>\n<ul>\n<li>建立新仓库</li>\n<li>克隆旧仓库</li>\n<li>推送新仓库</li>\n</ul>\n<p>下面以 Coding 迁移到 GitHub 为例，介绍两种迁移方式（命令行和可视化工具）的操作步骤。</p>\n<h2 id=\"使用-git-bash-操作\"> 使用 Git Bash 操作</h2>\n<h3 id=\"在-github-建立新仓库\"> 在 GitHub 建立新仓库</h3>\n<p>在 GitHub 中新建一个同名项目（不同名也可以），不要添加 <code>README.md</code>，以及任何 <code>License</code> 和 <code>.gitignore</code> 文件，只需要新建一个空的仓库。</p>\n<h3 id=\"克隆-coding-上的项目\"> 克隆 Coding 上的项目</h3>\n<p>将 Coding 上想要迁移的项目完整克隆到本地，执行命令：</p>\n<div><pre><code><span>git</span> clone https://git.coding.net/<span>[</span>your-coding-id<span>]</span>/<span>[</span>repo-name<span>]</span>.git  --bare\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"将克隆下来的仓库推送到-github\"> 将克隆下来的仓库推送到 GitHub</h3>\n<p>进入刚才克隆下来的文件目录，使用新仓库页面提供的仓库地址（web URL），推送所有的分支和对象：</p>\n<div><pre><code><span>cd</span> <span>[</span>repo-name<span>]</span>.git\n<span>git</span> push https://github.com/<span>[</span>your-github-id<span>]</span>/<span>[</span>repo-name<span>]</span>.git --all\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"完成后-再执行推送所有的-tags\"> 完成后，再执行推送所有的 Tags</h3>\n<div><pre><code><span>git</span> push https://github.com/<span>[</span>your-github-id<span>]</span>/<span>[</span>repo-name<span>]</span>.git --tags\n</code></pre>\n<div><span>1</span><br></div></div><p>这样，整个仓库就全部迁移到 GitHub 了，如果这些 commit 关联的邮箱也同时在 GitHub 的配置中，可以看到小绿点也一起迁移过来了。</p>\n<h2 id=\"使用-tortoisegit-操作\"> 使用 TortoiseGit 操作</h2>\n<p>这种简单的操作我不是很喜欢用可视化工具，不过这里也记录下怎么用「小乌龟」来完成仓库的迁移。</p>\n<h3 id=\"在-github-建立新仓库-2\"> 在 GitHub 建立新仓库</h3>\n<p>同上，不赘述了。</p>\n<h3 id=\"克隆-coding-上的项目-2\"> 克隆 Coding 上的项目</h3>\n<p>同上，不赘述了。</p>\n<h3 id=\"将克隆下来的仓库推送到-github-2\"> 将克隆下来的仓库推送到 GitHub</h3>\n<p>进入项目文件夹，鼠标右键 -&gt; Git Sync...</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/tortoisegit-sync.png\" alt=\"TortoiseGit 同步\">\n  <p style=\"text-align: center; color: #888;\">（TortoiseGit 同步）</p>\n</div>\n<p>点击 Manage。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/tortoisegit-sync-manage.png\" alt=\"TortoiseGit 同步-管理\">\n  <p style=\"text-align: center; color: #888;\">（TortoiseGit 同步-管理）</p>\n</div>\n<p>填写 GitHub 远程仓库的信息，并 Add New/Save，应用，确认。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/tortoisegit-sync-manage_remote.png\" alt=\"TortoiseGit 同步-管理-远程信息\">\n  <p style=\"text-align: center; color: #888;\">（TortoiseGit 同步-管理-远程信息）</p>\n</div>\n<p>Remote URL 选择刚刚添加的 GitHub，然后 Push。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/tortoisegit-sync-manage-push.png\" alt=\"TortoiseGit 同步-管理-推送\">\n  <p style=\"text-align: center; color: #888;\">（TortoiseGit 同步-管理-推送）</p>\n</div>\n<p>最后再提交 Tags。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/tortoisegit-sync-manage-push-tags.png\" alt=\"TortoiseGit 同步-管理-推送标签\">\n  <p style=\"text-align: center; color: #888;\">（TortoiseGit 同步-管理-推送标签）</p>\n</div>\n<h2 id=\"all-和-mirror-区别\"> --all 和 --mirror 区别</h2>\n<p>上面在推送代码至 GitHub（新仓库）时，我们用到了下面这个命令：</p>\n<p><code>git push https://github.com/[your-github-id]/[repo-name].git --all</code></p>\n<p>其实还有另外一个命令：</p>\n<p><code>git push https://github.com/[your-github-id]/[repo-name].git --mirror</code></p>\n<p>关于这两个命令的区别，可以参见 <a href=\"https://stackoverflow.com/questions/49343025/git-push-all-vs-mirror\" title=\"Git push --all vs --mirror\" target=\"_blank\" rel=\"noopener noreferrer\">Git push --all vs --mirror</a>。</p>\n<p>（完）</p>\n",
      "date_published": "2021-11-22T07:11:20.000Z",
      "date_modified": "2021-12-10T02:38:51.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "刚刚的 commit 有误，想要撤回",
      "url": "https://www.fedbook.cn/basic-skills/git/solution-to-withdraw-last-commit/",
      "id": "https://www.fedbook.cn/basic-skills/git/solution-to-withdraw-last-commit/",
      "content_html": "<h1 id=\"刚刚的-commit-有误-想要撤回\"> 刚刚的 commit 有误，想要撤回</h1>\n<h2 id=\"问题描述\"> 问题描述</h2>\n<p>出于某种原因，发现刚才的一次 <code>commit</code> 是错的，需要回退到上一个 <code>commit</code> 版本，进行修复后再重新 <code>commit</code>。</p>\n<p>这里可以用到的有两个命令：<code>git reset</code> 和 <code>git revert</code>，它们的区别还挺大的。</p>\n<h2 id=\"解决方案\"> 解决方案</h2>\n<h3 id=\"方案一-git-reset\"> 方案一：git reset</h3>\n<p>直接删除指定的 commit。</p>\n<p>代码回滚中这个命令用的很多，而且是 <code>--hard</code> 用的比较多：</p>\n<p><code>--hard</code>：硬性回滚，简单粗暴，直接抛弃上次提交后的所有本次修改，回滚到之前的样子。<br>\n<code>--soft</code>：软性回滚，可以理解为撤销指定的 commit 记录。</p>\n<div><pre><code><span># 修改版本库, 保留暂存区, 保留工作区</span>\n<span># 软回退表示将本地版本库的头指针全部重置到指定版本, 且将这次提交之后的所有变更都移动到暂存区</span>\n<span># 将版本库软回退一个版本</span>\n<span>git</span> reset --soft HEAD~1 <span># 或 git reset --soft HEAD^</span>\n<span># 将版本库软回退 N 个版本</span>\n<span>git</span> reset --soft HEAD~N\n\n<span># 修改版本库, 修改暂存区, 修改工作区</span>\n<span># 不仅仅是将本地版本库的头指针全部重置到指定版本, 也会重置暂存区, 并且会将工作区代码也回退到这个版本</span>\n<span># 将版本库回退一个版本</span>\n<span>git</span> reset --hard HEAD^\n<span># 将版本库回退两个版本</span>\n<span>git</span> reset --hard HEAD^^\n<span># 将版本库回退到特定的 commit-id 版本, 可以通过 git log 查看每次 commit 对应的 ID</span>\n<span>git</span> reset --hard <span>[</span>commit-id<span>]</span> \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>如果需要撤销已经 <code>push</code> 到远端的 <code>commit</code>，使远端的仓库也回退到相应的版本，需要在 <code>push</code> 时加上参数 <code>--force</code>：</p>\n<div><pre><code><span>git</span> push origin <span>[</span>branch-name<span>]</span> --force\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"方案二-git-revert\"> 方案二：git revert</h3>\n<p>撤销某次操作，此次操作之前和之后的 commit 和 history 都会保留，并且把这次撤销作为一次最新的提交。</p>\n<div><pre><code><span># 撤销前一次 commit</span>\n<span>git</span> revert HEAD\n\n<span>#  撤销前前一次 commit</span>\n<span>git</span> revert HEAD^\n\n<span># 撤销指定的版本，撤销动作本身也会作为一次提交进行保存</span>\n<span>git</span> revert <span>[</span>commit-id<span>]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><code>git revert</code> 是提交一个新的版本，将需要 revert 的版本的内容作为一次新的 <code>commit</code> 再反向修改回去，版本会递增，不影响之前提交的内容。</p>\n<h2 id=\"区别-revert-和-reset\"> 区别：revert 和 reset</h2>\n<ul>\n<li><code>git revert</code> 是用一次新的 commit 来回滚之前的 commit，<code>git reset</code> 是直接删除指定的 commit。</li>\n<li>在回滚这一操作上看，效果差不多。但是在日后继续 merge 以前的老版本时有区别。因为 <code>git revert</code> 是用一次逆向的 commit「中和」之前的提交，因此日后合并老的 branch 时，导致这部分改变不会再次出现，但是 <code>git reset</code> 是直接把某些 commit 在某个 branch 上删除，因而和老的 branch 再次 merge 时，这些被回滚的 commit 应该还会被引入。</li>\n<li><code>git reset</code> 是把 HEAD 向后移动了一下，而 <code>git revert</code> 是 HEAD 继续前进，只是新的 commit 的内容和要 revert 的内容正好相反，能够抵消要被 revert 的内容。</li>\n</ul>\n<h2 id=\"总结\"> 总结</h2>\n<ul>\n<li>使用 reset 回退版本后，需要其他所有人手动用远程 master 分支覆盖本地 master 分支。显然，这不是优雅的回退方法。</li>\n<li>使用 revert 撤销某次提交后，它会产生一个新的提交，虽然代码回退了，但是版本依然是向前的。所以当你用这种方式回退之后，其他人 pull 完，他们的代码也自动的回退了。</li>\n</ul>\n<p>相对之下，<code>git revert</code> 更加优雅。但是，要注意以下几点：</p>\n<ul>\n<li>revert 是撤销一次提交，所以后面的 commit-id 是你想要抵达的版本的后一次提交。</li>\n<li>使用 <code>revert HEAD</code> 是撤销最近的一次提交，如果你最近一次提交是用 revert 命令产生的，那么你再执行一次，就相当于撤销了上次的撤销操作，换句话说，你连续执行两次 <code>revert HEAD</code> 命令，就跟没执行是一样的。</li>\n<li>使用 <code>revert HEAD~1</code> 表示撤销最近 2 次提交，这个数字是从 0 开始的，如果你之前撤销过产生了 commit-id，那么也会计算在内的；</li>\n<li>如果使用 revert 撤销的不是最近一次提交，那么一定会有代码冲突，需要你合并代码，合并代码只需要把当前的代码全部去掉，保留之前版本的代码就可以了。</li>\n</ul>\n<p><code>git revert</code> 命令的好处就是不会丢掉别人的提交，即使你撤销后覆盖了别人的提交，他更新代码后，可以在本地用 reset 向前回滚，找到自己的代码，然后拉一下分支，再回来合并上去就可以找回被你覆盖的提交了。</p>\n<p>（完）</p>\n",
      "date_published": "2021-11-19T08:23:09.000Z",
      "date_modified": "2021-12-11T11:49:33.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "刚刚的 push 有误，想要撤回",
      "url": "https://www.fedbook.cn/basic-skills/git/solution-to-withdraw-last-push/",
      "id": "https://www.fedbook.cn/basic-skills/git/solution-to-withdraw-last-push/",
      "content_html": "<h1 id=\"刚刚的-push-有误-想要撤回\"> 刚刚的 push 有误，想要撤回</h1>\n<h2 id=\"问题描述\"> 问题描述</h2>\n<p>出于某种原因，不小心把错误的或者不完整的代码 commit 并且 push 到了远程，可能会影响到远程上代码的正确性。</p>\n<p>Git 提供了撤回远程代码的方法。</p>\n<h2 id=\"解决方案\"> 解决方案</h2>\n<p>按下面的步骤进行：</p>\n<ul>\n<li><code>git log</code> 查看提交记录，找到<strong>需要撤回到的提交 id</strong>（即有问题的那次提交的上一个 commit）。</li>\n<li><code>git reset --soft [commit-id]</code> 或者 <code>git reset --hard [commit-id]</code>，id 为需要回退到的 commit-id。</li>\n<li><code>git push origin [本地当前分支名] --force</code>，强制提交当前版本号</li>\n</ul>\n<p>这个时候查看本地和远程的 log，发现有错误的那次记录已经查不到了，表示撤销成功了。</p>\n<div><p>注意</p>\n<p>--hard 会丢弃本地修改，请谨慎使用。</p>\n<ul>\n<li>--soft 撤销 commit，保留工作区的代码变更，不会撤销 git add</li>\n<li>--mixed 撤销 commit，保留工作区的代码变更，撤销 git add</li>\n<li>--hard 撤销 commit，删除工作区的代码变更，撤销 git add</li>\n</ul>\n</div>\n<p>（完）</p>\n",
      "date_published": "2021-12-11T11:49:33.000Z",
      "date_modified": "2021-12-11T11:49:33.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "MySQL",
      "url": "https://www.fedbook.cn/basic-skills/mysql/",
      "id": "https://www.fedbook.cn/basic-skills/mysql/",
      "content_html": "<h1 id=\"mysql\"> MySQL</h1>\n<blockquote>\n<p>本系列以 MySQL 8.0 作为安装版本进行知识点梳理，但考虑到目前在生产环境中用的比较多的是 5.7，故优先使用向前兼容的 5.7 版本功能，对于 8.0 特有的新功能和特性，仅是学习一下。</p>\n</blockquote>\n<p>在日常工作与学习中，无论是开发、运维、还是测试，对于数据库的学习是不可避免的，同时也是日常工作的必备技术之一。而目前业内所用的关系型数据库中，占比较多的还是 MySQL。</p>\n<hr>\n<p><strong>哪个版本的 MySQL 可以用于生产环境</strong>：</p>\n<p>MySQL 有很多版本，支持在生产环境中使用的有 8.0、5.7 和 5.6：</p>\n<ul>\n<li>MySQL 8.0(GA)，MySQL 8.0.11 于2018年4月19日发布。</li>\n<li>MySQL 5.7(GA)，MySQL 5.7.9 于2015年10月21日发布。</li>\n<li>MySQL 5.6(GA)，MySQL 5.6.10 于2013年2月5日发布。</li>\n<li>MySQL 5.5(GA)，MySQL 5.5.8 于2010年12月3日发布。</li>\n</ul>\n<hr>\n<p><strong>为什么这三个版本可以用于生产环境</strong>：</p>\n<p>MySQL 的产品生命周期分为三个阶段，首要阶段、延伸阶段和维持阶段（MySQL 版本号的前两位为主版本号，例如 8.0、5.7、5.6，后面的为维护版本号码。MySQL 的生命周期计算依据主版本号）。</p>\n<ul>\n<li>首要阶段的时间为产品 GA 开始 5 年。处于首要阶段的产品会定期发布维护版本、更新、修正错误及修补安全漏洞。</li>\n<li>延伸阶段为产品 GA 后 6-8 年。延伸阶段的产品会对特定的错误及安全漏洞发布维护版本和更新。</li>\n<li>产品从 GA 的第 9 年起进入维持阶段。进入维持阶段后，MySQL 将不会对其进行维护版本的发布、更新和修正错误。</li>\n</ul>\n<p>因此对应 MySQL 各个版本的 GA 日期，目前生产系统上支持 8.0、5.7 及 5.6 版本的 MySQL。</p>\n<hr>\n<p><strong>为什么 MySQL 的版本号没有 6.x 和 7.x</strong>：</p>\n<p>早在 2008 年，Sun 收购 MySQL AB 以前，公司内部已经在进行着版本号 6 的开发工作了（5.0 在 2005 年发布）。然而，版本 6 的 MySQL 制定的目标和计划过于激进，步子迈得有点儿大，随着收购的顺利完成，项目也被砍掉了。</p>\n<p>至于版本号 7，则是用在了 MySQL Cluster 上。由于新版的 MySQL 带来了许多的重大更新，开发者们决定是时候把版本号往前滚动一下了，于是便有了 8。</p>\n<p>参考：<a href=\"https://opensource.com/article/17/2/mysql-8-coming\" target=\"_blank\" rel=\"noopener noreferrer\">MySQL 8 is coming</a></p>\n<hr>\n<p><strong>为什么选择 MySQL 8.0 做安装版本</strong>：</p>\n<p>5.7 版本虽然还在其生命周期，但已经进入了维持阶段，不出意外，将于2023年的10月份结束对它的维护，进入到与 5.6 同样的状态。</p>\n<p>8.0 版本发布于2018年的4月份，除了在功能和性能上进行了大幅的增强和改进，它的发布方式（持续发布）使得用户可以在第一时间获得最新的功能和改进，而不像以往一定要等到大版本升级才能获得新的功能。</p>\n<p>但现实中，数据库系统升级影响很大，以前的 5.6 和 5.7 版本目前也足够稳定，如果不是新开的项目，需要慎重考虑是否升级（毕竟像 Facebook 这样的公司，将 MySQL 从 5.6 升级至 8.0 也花了几年时间，覆盖率还没达到 100%）。</p>\n<p>因此，考虑到实际情况，本系列采用 MySQL 8.0 做安装版本，但会优先使用向前兼容的 5.7 版本功能，对于 8.0 特有的新功能和特性，仅是学习一下。</p>\n<hr>\n<p><strong>MySQL 5.7 和 8.0 性能对比</strong>：</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/YangJiaXin/p/11234591.html\" target=\"_blank\" rel=\"noopener noreferrer\">MySQL 5.7和8.0性能测试</a></li>\n</ul>\n<p>该性能测试结果未经考验，仅供参考。</p>\n<div style=\"text-align: right\">\n  <svg t=\"1646148855959\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"5290\" width=\"64\" height=\"64\"><path d=\"M715.8 312.4l-5.6-11.7c-2.4-3.4-5.9-6-7.9-10h-0.6v-0.6c3.3-0.8 6.7-1.2 10.1-1.1 2 1.9 5.1 3.3 6.7 5.6 1.2 1.7 1.4 3.6 2.8 5 0 5.9-1.6 9.8-5.1 12.3 0.2-0.1-0.4 0.5-0.4 0.5z m251.9 251.1c-9.3-5.9-20.1-9.2-29.8-15.1-5.4-3.3-10.7-7.4-15.7-11.2-4.7-3.5-9.9-10.1-12.9-15.1-1.6-2.6-1.9-5.7-3.9-7.8 0.6-4.6 6.4-4.6 10.1-6.1 12.9-5.4 28-7.2 47.8-6.7-0.6-5-12.9-11.2-16.9-13.9-8-5.6-16.2-11.6-24.7-16.8-4.5-2.7-12.2-4.7-16.9-6.7-6.7-2.8-21.5-5.5-25.3-10.6-7.3-9.6-12.3-21.3-17.4-32.9-5.2-11.6-11.7-23.8-16.9-35.7-2.6-5.9-3.8-11.2-6.7-16.7-18.1-34.5-44.6-63.4-77-83.7-10.6-6.7-22.4-12.8-35.4-16.7-7.4-2.2-16.3-1-24.2-2.8h-5.1c-4.4-1.3-8.1-6-11.8-8.4-7.6-5-15.2-8.6-24.2-12.3-3.4-1.4-12.5-4.7-15.7-2.2-1.9 0.6-2.8 1.4-3.4 3.3-1.9 2.9-0.2 7.3 1.1 10 3.6 7.8 8.8 12.5 13.5 19 4.2 5.8 9.3 12.4 12.4 19 6.3 13.7 9.2 28.9 15.2 42.4 2.3 5.2 5.7 11.1 9 15.6 2.7 3.6 7.5 6.4 9 11.2 3.1 4.8-4.5 21.1-6.2 26.2-6.5 20-5.1 47.9 2.2 65.3 2.9 6.9 5.7 14.9 13.5 16.7 0.6-0.4 0.1-0.2 1.1-0.5 1.7-13.4 2.2-26.3 6.7-36.8 2.8-6.6 8.2-11.1 11.8-16.7 2.7 1.5 2.6 6 3.9 8.9 3.3 7.6 6.8 15.9 10.7 23.4 8.3 15.7 17.3 30.8 27.6 44.6 3.6 4.9 8.5 10.2 12.9 14.5 1.9 1.8 4.2 2.8 5.6 5h0.6v0.6c-7.6-2.6-12.1-10.1-18-14.5-11.3-8.4-24.6-21-32-32.9l-10.1-20.1v-0.6c-1.4 1.9-1 3.9-1.7 6.7-3.2 12.3-0.7 26.2-11.8 30.7-12.7 5.1-21.9-8.3-25.9-14.5-12.8-20.3-16.1-54.5-7.3-82 1.9-6.1 2.1-13.6 5.6-18.4-0.6-4.3-4.1-5.6-6.2-8.4-3.4-4.6-6.3-10-9-15.1-5.3-10.1-8.8-22-12.9-32.9-1.7-4.4-2-8.6-3.9-12.8-2.9-6.4-8.2-12.7-12.4-18.4-5.9-8.1-22.3-23.7-15.7-39.6 10.4-25.3 46.6-6.1 60.7 2.8 3.5 2.2 7.5 6.8 11.2 8.4l18.6 1.1c11.5 2.7 22.4 4.8 31.5 10 42.6 24.7 70 49.9 95.6 91.5 5.3 8.7 8.1 18.2 12.4 27.9 6.3 14.4 13 28.5 20.3 42.4 3.4 6.4 5.8 13.5 10.1 19 1.8 2.3 6.8 3.1 9.6 4.5 8.3 4.2 18 7.3 25.9 12.3 14.2 8.9 27.9 19.5 40.5 30.1 4.8 4.1 8 10 12.4 14.5v2.2c-3.9 1.1-7.9 2.2-11.8 3.3-8.7 2.2-16.3 1.7-24.7 3.9-5 1.3-11.4 3.3-16.9 3.9l0.6 0.5c3.2 8.9 20.4 16.3 28.1 21.8 9.6 6.9 18.7 15.1 25.9 24.5l7.3 7.3c1.7 2.4 2.1 5.5 3.9 7.8v0.5c-3.4-1.2-5.2-4.2-7.9-6.1-5.7-3.8-11.1-8.1-16.6-11.6zM373 728.9H271.4v-21.5h101.7c20.7-2.2 18.3-12.4 18.3-15.8v-8.4h-68.3c-31.8-0.3-52.1-14.1-52.3-29.9 0-1.5 0.7-71 0-71.6H303v69.5c-0.3 3.8 1.2 12.6 18.8 12.9 9 0.1 69.4 0 69.9 0v-82.7h32.2c0.2 0 0 112.8 0 113.3 0.2 27.7-34.8 33.7-50.9 34.2zM211.8 558.2L162 668.1c-5.9 13.3-13.6 18-29.4 18-15.8 0-23.8-4.7-29.7-18L53.2 558.2v126.1H21V558.4c0-12.3 4.9-18.2 15.2-21.3 24.4-7.6 41.1-1 48.2 15.3l47.3 108.5 48.9-108.5c7.4-16.4 23.8-22.9 48.3-15.3 10.2 3.1 15.2 9 15.2 21.3v125.9h-32.2l-0.1-126.1z\" fill=\"#00758F\" p-id=\"5291\"></path><path d=\"M659.8 536.6h61.1c3.1 0 5.9 0.2 9 0.6 27 3.7 40.6 15.4 40.6 34.7v75.9c0 15.6-5.8 24-19.1 29.5l31.7 28.4h-37.3l-25.6-23-25.8 1.6H660c-6.4 0-12.8-0.9-18.9-2.7-20.5-5.5-30.4-16.2-30.4-33.8v-75.9c0-19.3 13.6-31 40.6-34.7 2.6-0.4 5.7-0.6 8.5-0.6z m-14.6 109.3c0 1 0.3 2.1 0.6 3.3 1.9 8.8 10.2 13.7 22.9 13.7H698l-26.8-24.1h37.3l23.4 21c4.3-2.3 7.2-5.8 8.2-10.3 0.3-1 0.3-2.1 0.3-3.1v-72.8c0-0.8 0-1.9-0.3-2.9-1.9-8.2-10.2-12.9-22.6-12.9h-48.7c-14.3 0-23.6 6.2-23.6 15.8v72.3z m-148.9-88.1c-11.5 1-14.9 2.9-16.4 9.4-0.3 1-0.3 1.9-0.3 2.7v14.5c0 1 0 1.8 0.3 2.9 1.5 8.6 7.7 12.5 20.7 12.5h39c9.6 0 19.5 1.6 27.5 4.7 15.2 5.7 22.9 14.3 22.9 23.5v23.3c0 11.3-6.8 19.9-20.7 26.2-8.3 3.9-18.9 6.1-29.7 6.1h-92.5v-21.3h88.8c1.2 0 2.2-0.2 3.4-0.2 6.2-0.4 10.8-2.1 13.6-4.5 3.1-2.5 4.6-5.3 4.6-7.6v-18.6c0-2.2-0.9-4.3-2.5-5.7-3.1-3.7-7.4-5.5-17.6-6.3-0.9-0.2-2.2-0.2-3.4-0.2h-33.4c-3.1 0-6.2-0.2-9.3-0.4-27.5-2.9-43.9-15.1-43.9-29.5v-18.6c0-16.4 8.4-25.8 27.5-31.7 6.2-1.8 13-2.7 26-2.7h90.3v21.3h-91.9c-0.9 0-2.1 0.2-3 0.2z m326.5 88.6c0 11.3 7.1 16 26 16h84.4v21.3h-83.8c-3.1 0-6.2-0.2-9.3-0.4-33.1-2.4-49.5-14.7-49.5-36.6V536.3h32.2v110.1z m149.2-8.2c12.5 0 23.7 9.5 23.7 23.5 0 14.1-11.2 23.5-23.7 23.5s-23.7-9.5-23.7-23.5 11.2-23.5 23.7-23.5z m0 42.2c10.2 0 18.4-8 18.4-18.6 0-10.7-8.2-18.6-18.4-18.6-10.3 0-18.4 8-18.4 18.6 0.1 10.6 8.1 18.6 18.4 18.6z m11.3-24.3c0 4.9-3.2 6.9-7.3 7.3l7.8 11.8h-5.3l-7.1-11.6h-4.2v11.6h-4.5v-26.9h10.6c6.5 0 10 2.3 10 7.8z m-16.2-4v7.7h4.9c3.4 0 6.4-0.3 6.4-4.1 0-3.1-3.3-3.6-6-3.6h-5.3z\" fill=\"#F2A72F\" p-id=\"5292\"></path></svg>\n</div>\n",
      "date_published": "2022-03-01T15:44:23.000Z",
      "date_modified": "2022-03-02T03:13:05.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Nginx",
      "url": "https://www.fedbook.cn/basic-skills/nginx/",
      "id": "https://www.fedbook.cn/basic-skills/nginx/",
      "content_html": "<h1 id=\"nginx\"> Nginx</h1>\n<blockquote>\n<p>本系列以 Nginx 1.18.0 作为安装版本进行知识点梳理，该版本目前属于 Legacy versions（老版本的稳定版）。</p>\n</blockquote>\n<p>Nginx（engine x）是一个高性能的 HTTP 和反向代理 web 服务器，同时也提供了 IMAP/POP3/SMTP 服务。其特点是占有内存少，并发能力强。</p>\n<p>Nginx 是一个安装非常的简单、配置文件非常简洁（还能够支持 perl 语法）、Bug 非常少的服务。Nginx 启动特别容易，并且几乎可以做到 7*24 不间断运行，即使运行数个月也不需要重新启动。你还能够不间断服务的情况下进行软件版本的升级。</p>\n<p>Nginx 代码完全用C语言从头写成。官方数据测试表明能够支持高达 50,000 个并发连接数的响应。</p>\n<hr>\n<p>Nginx 的主要作用：</p>\n<ul>\n<li>正向代理和反向代理</li>\n<li>负载均衡</li>\n<li>HTTP 服务器（动静分离）</li>\n</ul>\n<hr>\n<p>Nginx 处理访问请求的原理：</p>\n<ol>\n<li>浏览器输入域名：<code>www.baidu.com</code></li>\n<li>浏览器将请求添加协议</li>\n<li>针对访问的域名进行解析（DNS 解析：把域名解析成对应 IP 的过程）</li>\n<li>发起 TCP 连接请求，发送 http 请求报文</li>\n<li>服务端中 Nginx 通过端口接收到 http 报文请求之后，通过报文中请求域名与自己配置文件中的 server 模块中的 <code>server_name</code> 进行匹配</li>\n<li>交由 location 模块匹配所请求的 uri 信息，根据响应规则进行处理</li>\n<li>通过调用内核，由内核调用磁盘，取得相应资源，封装后返回给用户</li>\n</ol>\n<hr>\n<p>关于 Nginx 的知识点，主要参考：</p>\n<ul>\n<li>网上各种资料</li>\n<li>工作生产实践</li>\n</ul>\n<div style=\"text-align: right\">\n  <svg t=\"1624981822388\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"1252\" width=\"64\" height=\"64\"><path d=\"M512 0L68.48 256v512L512 1024l443.52-256V256z m256 707.84c0 30.08-27.552 55.04-65.248 55.04-26.912 0-57.632-10.88-76.832-34.56l-256-304.672v284.16c0 30.752-24.32 55.04-54.368 55.04H312.32c-30.752 0-55.04-25.6-55.04-55.04V316.16c0-30.08 26.88-55.04 64-55.04 27.552 0 58.88 10.88 78.08 34.56l254.72 304.672V316.16c0-30.752 25.6-55.04 55.04-55.04h3.2c30.72 0 55.04 25.6 55.04 55.04v391.68z\" fill=\"#269539\" p-id=\"1253\"></path></svg>\n</div>\n",
      "date_published": "2021-06-29T15:52:48.000Z",
      "date_modified": "2021-12-26T08:41:15.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "常用命令",
      "url": "https://www.fedbook.cn/basic-skills/linux/common-commands/",
      "id": "https://www.fedbook.cn/basic-skills/linux/common-commands/",
      "content_html": "<h1 id=\"常用命令\"> 常用命令</h1>\n<h2 id=\"文件管理\"> 文件管理</h2>\n<h3 id=\"查看与检索文件内容\"> 查看与检索文件内容</h3>\n<h4 id=\"_1-cat-命令\"> 1）cat 命令</h4>\n<p>用于连接文件并打印到标准输出设备上。</p>\n<div><pre><code><span># 把 text1 的文档内容加上行号后输入 text2 这个文档里</span>\n<span>cat</span> -n text1 <span>></span> text2\n\n<span># 把 text1 和 text2 的文档内容加上行号（空白行不加）之后将内容附加到 text3 文档里</span>\n<span>cat</span> -b text1 text2 <span>>></span> text3\n\n<span># 清空 /etc/test.txt 文档内容</span>\n<span>cat</span> /dev/null <span>></span> /etc/test.txt\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>\n<p>语法格式：<code>cat [-nbs] [--help] [--version] fileName</code></p>\n<p>参数说明：</p>\n<ul>\n<li>-n 或 --number：由 1 开始对所有输出的行数编号。</li>\n<li>-b 或 --number-nonblank：和 -n 相似，只不过对于空白行不编号。</li>\n<li>-s 或 --squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行。</li>\n</ul>\n</blockquote>\n<h4 id=\"_2-wc-命令\"> 2）wc 命令</h4>\n<div><pre><code><span># 查看文件里有多少行</span>\n<span>wc</span> -l filename\n \n<span># 看文件里有多少个word</span>\n<span>wc</span> -w filename\n\n<span># 文件里最长的那一行是多少个字</span>\n<span>wc</span> -L filename\n\n<span># 统计字节数</span>\n<span>wc</span> -c\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h4 id=\"_3-grep-命令\"> 3）grep 命令</h4>\n<div><pre><code><span># 在当前目录下查找含有指定字符串的文件，并标出行号</span>\n<span>grep</span> -rn <span>\"hello\"</span>\n\n<span># 反向匹配，查找不包含指定字符串的内容</span>\n<span>grep</span> -v <span>\"hello\"</span>\n\n<span># 查询指定文件中以 abc 开头的行</span>\n<span>grep</span> -n <span>\"^abc\"</span> access.log\n\n<span># 计算一下该字串出现的次数</span>\n<span>grep</span> <span>\"hello\"</span> -c access.log\n\n<span># 比对的时候，不计较大小写的不同</span>\n<span>grep</span> <span>\"hello\"</span> -i access.log\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h4 id=\"_4-vim-操作\"> 4）vim 操作</h4>\n<div><pre><code><span># normal模式下</span>\n<span>0</span>         <span># 光标移到行首（数字0）</span>\n$         <span># 光标移至行尾</span>\n<span>shift</span> + g <span># 跳到文件最后</span>\ngg        <span># 跳到文件头</span>\n\t\n<span># 显示行号</span>\n:set number\n\t\n<span># 去除行号</span>\n:set nonumber\n\t\n<span># 检索</span>\n/xxx<span>(</span>检索内容<span>)</span>  <span># 从头检索，按 n 查找下一个</span>\n?xxx<span>(</span>检索内容<span>)</span>  <span># 从尾部检索</span>\n\n<span># 检索的关键字会高亮，取消高亮显示</span>\n:noh\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id=\"查找文件的四个命令\"> 查找文件的四个命令</h3>\n<h4 id=\"_1-which-命令\"> 1）which 命令</h4>\n<p>用于在环境变量 $PATH 指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。</p>\n<p>也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p>\n<div><pre><code><span>which</span> <span>grep</span>\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"_2-whereis-命令\"> 2）whereis 命令</h4>\n<p>用于程序名的搜索，而且只搜索二进制文件（参数 -b）、man 说明文件（参数 -m）和源代码文件（参数 -s）。如果省略参数，则返回所有信息。</p>\n<div><pre><code><span>whereis</span> <span>bash</span> \n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"_3-find-命令\"> 3）find 命令</h4>\n<p>这才是用于查找一般文件所在位置的命令。</p>\n<p>如果不设置任何参数，则将在当前目录下查找子目录与文件，并且将查找到的子目录和文件全部进行显示。</p>\n<div><pre><code><span># 将当前目录及其子目录下所有文件后缀为 .c 的文件列出来</span>\n<span>find</span> <span>.</span> -name <span>\"*.c\"</span>\n\n<span># 同上，但需要显示它们的详细信息</span>\n<span>find</span> <span>.</span> -name <span>\"*.c\"</span> -ls\n\n<span># 将当前目录及其子目录中的所有文件列出</span>\n<span>find</span> <span>.</span> -type f\n\n<span># 将当前目录及其子目录下所有最近 20 天内更新过的文件列出</span>\n<span>find</span> <span>.</span> -ctime  <span>20</span>\n\n<span># 查找 /var/log 目录中更改时间在 7 日以前的普通文件，并在删除之前询问它们</span>\n<span>find</span> /var/log -type f -mtime +7 -ok <span>rm</span> <span>{</span><span>}</span> <span>\\</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><blockquote>\n<p>语法格式：<code>find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt;</code></p>\n<ul>\n<li>&lt;指定目录&gt;：所要搜索的目录及其所有子目录，默认为当前目录。</li>\n<li>&lt;指定条件&gt;：所要搜索的文件的特征。</li>\n<li>&lt;指定动作&gt;：对搜索结果进行特定的处理。</li>\n</ul>\n<p>&lt;指定条件&gt; 有很多，常用的有：</p>\n<ul>\n<li>-amin n：在过去 n 分钟内被读取过</li>\n<li>-atime n：在过去n天内被读取过的文件</li>\n<li>-cmin n：在过去 n 分钟内被修改过</li>\n<li>-ctime n：在过去n天内被修改过的文件</li>\n<li>-name name，-iname name：文件名称符合 name 的文件，iname 会忽略大小写</li>\n<li>-type &lt;文件类型&gt;：指定类型的文件，文件类型可选：\n<ul>\n<li>d：目录</li>\n<li>f：一般文件</li>\n<li>s：socket</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"_4-locate-命令\"> 4）locate 命令</h4>\n<p>这也是用于查找一般文件所在位置的命令。它其实是 <code>find -name</code> 的另一种写法，但速度要快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/mlocate/mlocate.db），这个数据库中含有本地所有文件信息。</p>\n<p>Linux 系统自动创建这个数据库，并且每天自动更新一次，所以使用 <code>locate</code> 命令查不到最新变动过的文件。为了避免这种情况，可以在使用 <code>locate</code> 之前，先使用 <code>updatedb</code> 命令，手动更新数据库。</p>\n<div><pre><code><span># 查找 passwd 文件</span>\n<span>locate</span> <span>passwd</span>\n\n<span># 搜索 etc 目录下所有以 sh 开头的文件</span>\n<span>locate</span> /etc/sh\n\n<span># 搜索用户主目录下，所有以 m 开头的文件</span>\n<span>locate</span> ~/m\n\n<span># 搜索用户主目录下，所有以 m 开头的文件，并且忽略大小写</span>\n<span>locate</span> -i ~/m\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"常用压缩-解压缩命令\"> 常用压缩，解压缩命令</h3>\n<p>压缩命令：</p>\n<div><pre><code><span># 压缩成后缀 .tar 格式的文件</span>\n<span>tar</span> -zcvf test.tar <span>test</span>\n\n<span># 压缩成后缀 .tar.gz 格式的文件</span>\n<span>tar</span> -zcvf test.tar.gz <span>test</span>\n\n<span># 压缩成后缀 .zip 格式的文件</span>\n<span>zip</span> -r test.zip <span>test</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>解压命令：</p>\n<div><pre><code><span># 解压后缀为 .tar 格式的压缩包</span>\n<span>tar</span> zxvf test.tar\n\n<span># 解压后缀为 .tar.gz 格式的压缩包</span>\n<span>tar</span> zxvf test.tar.gz\n\n<span># 解压后缀为 .zip 格式的压缩包</span>\n<span>unzip</span> test.zip\n<span># 解压到指定目录</span>\n<span>unzip</span> test.zip -d /opt/\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"机器间的文件传输\"> 机器间的文件传输</h3>\n<h4 id=\"_1-scp-命令\"> 1）scp 命令</h4>\n<p>用于向另一台机器发送文件。</p>\n<div><pre><code><span># 将 /home/hello.py 发送到 192.168.10.50 机器的 /opt/ 目录下</span>\n<span>scp</span> /home/hello.py root@192.168.10.50:/opt/\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h4 id=\"_2-rz-sz-命令\"> 2）rz/sz 命令</h4>\n<p>用于 PC 和服务器之间传输文件，这组命令需要安装包：<code>lrzsz</code>。</p>\n<div><pre><code><span># Linux 向 Windows 发送文件</span>\nsz filename\n\n<span># Windows 向 Linux 发送文件</span>\nrz -be\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><blockquote>\n<p>-be 参数是为了防止文件较大时可能长传出错的情况，如果执行命令有弹框，记得取消弹出对话框中 &quot;Upload files as ASCII&quot; 前的勾选。</p>\n<ul>\n<li>-a 或 --ascii：以文本方式传输</li>\n<li>-b 或 --binary：以二进制方式传输，推荐使用</li>\n<li>-e 或 --escape：对所有控制字符转义，建议使用</li>\n</ul>\n</blockquote>\n<h2 id=\"磁盘管理\"> 磁盘管理</h2>\n<h3 id=\"创建与查询目录\"> 创建与查询目录</h3>\n<h4 id=\"_1-mkdir-命令\"> 1）mkdir 命令</h4>\n<p>用于创建目录。</p>\n<div><pre><code><span># 在工作目录下，建立一个名为 www 的子目录</span>\n<span>mkdir</span> www\n\n<span># 在工作目录下的 www 目录中，建立一个名为 fedbook 的子目录。若 www 目录原本不存在，则建立一个。</span>\n<span>mkdir</span> -p www/fedbook\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id=\"_2-ls-命令\"> 2）ls 命令</h4>\n<p>用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录）。</p>\n<div><pre><code><span># 列出根目录下的所有目录</span>\n<span>ls</span> /\n\n<span># 列出目前工作目录下所有名称是 s 开头的文件，越新的排越后面</span>\n<span>ls</span> -ltr s*\n\n<span># 将 /bin 目录以下所有目录及文件详细资料列出</span>\n<span>ls</span> -lR /bin\n\n<span># 列出目前工作目录下所有文件及目录；目录于名称后加 \"/\", 可执行档于名称后加 \"*\"</span>\n<span>ls</span> -AF\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><blockquote>\n<p>语法格式：<code>ls [-alrtAFR] [name...]</code></p>\n<p>参数说明：</p>\n<ul>\n<li>-a：显示所有文件及目录（<code>.</code> 开头的隐藏文件也会列出）</li>\n<li>-l：除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出</li>\n<li>-r：将文件以相反次序显示（原定依英文字母次序）</li>\n<li>-t：将文件依建立时间之先后次序列出</li>\n<li>-A：同 -a ，但不列出 &quot;.&quot;（目前目录）及 &quot;..&quot;（父目录）</li>\n<li>-F：在列出的文件名称后加一符号；例如可执行档则加 &quot;*&quot;，目录则加 &quot;/&quot;</li>\n<li>-R：若目录下有文件，则以下之文件亦皆依序列出</li>\n</ul>\n</blockquote>\n<h3 id=\"统计磁盘使用情况\"> 统计磁盘使用情况</h3>\n<div><pre><code><span># 以可读性较高的方式显示全部的文件系统</span>\n<span>df</span> -ah\n\n<span># 以可读性较高的方式显示文件大小</span>\n<span>ls</span> -alh\n\n<span># 查看当前目录磁盘总占用大小</span>\n<span>du</span> -hs\n\n<span># 查看当前目录下各个文件，文件夹占了多少空间，不会递归</span>\n<span>du</span> -hs *\n\n<span># 查看目录及子目录大小</span>\n<span>du</span> -Hh\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id=\"打印树状目录结构\"> 打印树状目录结构</h3>\n<div><pre><code><span># Ubuntu 安装 tree</span>\n<span>apt</span> <span>install</span> tree\n<span># CentOS 安装 tree</span>\nyum <span>install</span> tree\n\n<span># 打印当前目录下的树形结构</span>\ntree\n\n<span># 最多显示两级深度</span>\ntree -L <span>2</span>\n\n<span># 打印指定目录下的树形结构，并输出到文件</span>\ntree /home <span>></span> tree.txt\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><blockquote>\n<p>语法格式：<code>tree [-aACdDfFgilnNpqstux][-I &lt;范本样式&gt;][-P &lt;范本样式&gt;][目录...]</code></p>\n<p>参数说明（有很多，仅列举常用的）：</p>\n<ul>\n<li>-a：显示所有文件和目录，包括隐藏文件、目录。</li>\n<li>-C：在文件和目录清单加上色彩，便于区分各种类型。</li>\n<li>-L：目录树的最大显示深度。</li>\n<li>-F：在执行文件，目录，Socket，符号连接，管道名称名称，各自加上&quot;*&quot;,&quot;/&quot;,&quot;=&quot;,&quot;@&quot;,&quot;|&quot;号。</li>\n</ul>\n</blockquote>\n<h2 id=\"网络通讯\"> 网络通讯</h2>\n<h3 id=\"ifconfig-命令\"> ifconfig 命令</h3>\n<p>用于显示或设置网络设备。</p>\n<p>显示内容详解：</p>\n<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ifconfig</span>\neth0      Link encap:Ethernet  HWaddr 00:50:56:BF:26:20  \n          inet addr:192.168.120.204  Bcast:192.168.120.255  Mask:255.255.255.0\n          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\n          RX packets:8700857 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:31533 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:1000 \n          RX bytes:596390239 <span>(</span><span>568.7</span> MiB<span>)</span>  TX bytes:2886956 <span>(</span><span>2.7</span> MiB<span>)</span>\n\nlo        Link encap:Local Loopback  \n          inet addr:127.0.0.1  Mask:255.0.0.0\n          UP LOOPBACK RUNNING  MTU:16436  Metric:1\n          RX packets:68 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:68 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:0 \n          RX bytes:2856 <span>(</span><span>2.7</span> KiB<span>)</span>  TX bytes:2856 <span>(</span><span>2.7</span> KiB<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><ul>\n<li>第一行\n<ul>\n<li>eth0 表示第一块网卡</li>\n<li>Link encap 表示该网卡位于 OSI 物理层的名称（Ethernet：以太网，Local Loopback：本地环回）</li>\n<li>HWaddr 表示网卡的物理地址，即MAC 地址</li>\n</ul>\n</li>\n<li>第二行\n<ul>\n<li>inet addr 表示该网卡在 TCP/IP 网络中的IP 地址</li>\n<li>Bcast 表示广播地址</li>\n<li>Mask 表示子网掩码</li>\n</ul>\n</li>\n<li>第三行\n<ul>\n<li>UP（代表网卡开启状态），RUNNING（代表网卡的网线被接上），MULTICAST（支持组播）</li>\n<li>MTU 表示最大传送单元，不同局域网类型的 MTU 值不一定相同，对以太网来说，MTU 的默认设置是 1500 个字节</li>\n<li>Metric 表示度量值，通常用于计算路由成本</li>\n</ul>\n</li>\n<li>第四行\n<ul>\n<li>RX 表示接收的数据包情况统计</li>\n<li>RX packets: errors:0 dropped:0 overruns:0 frame:0 接受包数量/出错数量/丢失数量/过载数量/帧数</li>\n</ul>\n</li>\n<li>第五行\n<ul>\n<li>TX 表示发送的数据包情况统计</li>\n<li>TX packets: errors:0 dropped:0 overruns:0 carrier:0 发送包数量/出错数量/丢失数量/过载数量/载波</li>\n</ul>\n</li>\n<li>第六行\n<ul>\n<li>collisions 表示数据包冲突的次数</li>\n<li>txqueuelen 表示传送列队（Transfer Queue）长度</li>\n</ul>\n</li>\n<li>第七行\n<ul>\n<li>RX 表示接收字节</li>\n<li>TX 表示发送字节</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"检测主机和端口连接情况\"> 检测主机和端口连接情况</h3>\n<p>检测主机通不通：</p>\n<div><pre><code><span># 检测是否与主机连通，需要手动终止：Ctrl+C</span>\n<span>ping</span> www.baidu.com\n\n<span># 指定收到两次包后，自动退出</span>\n<span>ping</span> -c <span>2</span> www.baidu.com\n\n<span># 发送周期为 3 秒，设置发送包的大小为 1024 字节，设置 TTL 值为 255</span>\n<span>ping</span> -i <span>3</span> -s <span>1024</span> -t <span>255</span> www.baidu.com\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>检测端口通不通：</p>\n<div><pre><code><span># 监听 TCP 端口是否通</span>\ntelnet <span>192.168</span>.10.50 <span>80</span>\n\n<span># 监听 UDP 端口是否通</span>\n<span>nc</span> -vuz <span>192.168</span>.10.50 <span>514</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"netstat-命令\"> netstat 命令</h3>\n<p>用于显示网络状态。</p>\n<div><pre><code><span># 显示所有连线中的端口</span>\n<span>netstat</span> -anp\n\n<span># 列出监听中的 TCP 端口</span>\n<span>netstat</span> -lntp\n\n<span># 列出监听中的 UDP 端口</span>\n<span>netstat</span> -lnup\n\n<span># 查询端口占用情况</span>\n<span>lsof</span> -i:port\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><blockquote>\n<p>语法格式：<code>netstat [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][--ip]</code></p>\n<p>参数说明（太多了，仅列举常用的）：</p>\n<ul>\n<li>-a 或 --all：显示所有连线中的 Socket。</li>\n<li>-l 或 --listening：显示监控中的服务器的 Socket。</li>\n<li>-n 或 --numeric：直接使用 IP 地址，而不通过域名服务器。</li>\n<li>-p 或 --programs：显示正在使用Socket的程序识别码和程序名称。</li>\n<li>-t 或 --tcp：显示 TCP 传输协议的连线状况。</li>\n<li>-u 或 --udp：显示 UDP 传输协议的连线状况。</li>\n</ul>\n</blockquote>\n<p>输出每个 IP 的连接数，以及总的各个状态的连接数：</p>\n<div><pre><code><span>netstat</span> -n <span>|</span> <span>awk</span> <span>'/^tcp/ {n=split($(NF-1),array,\":\");if(n&lt;=2)++S[array[(1)]];else++S[array[(4)]];++s[$NF];++N} END {for(a in S){printf(\"%-20s %s\\n\", a, S[a]);++I}printf(\"%-20s %s\\n\",\"TOTAL_IP\",I);for(a in s) printf(\"%-20s %s\\n\",a, s[a]);printf(\"%-20s %s\\n\",\"TOTAL_LINK\",N);}'</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>统计所有连接状态：</p>\n<div><pre><code><span>netstat</span> -n <span>|</span> <span>awk</span> <span>'/^tcp/ {++state[$NF]} END {for(key in state) print key,\"\\t\",state[key]}'</span>\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li>CLOSED：无连接是活动的或正在进行</li>\n<li>LISTEN：服务器在等待进入呼叫</li>\n<li>SYN_RECV：一个连接请求已经到达，等待确认</li>\n<li>SYN_SENT：应用已经开始，打开一个连接</li>\n<li>ESTABLISHED：正常数据传输状态</li>\n<li>FIN_WAIT1：应用说它已经完成</li>\n<li>FIN_WAIT2：另一边已同意释放</li>\n<li>ITMED_WAIT：等待所有分组死掉</li>\n<li>CLOSING：两边同时尝试关闭</li>\n<li>TIME_WAIT：主动关闭连接一端还没有等到另一端反馈期间的状态</li>\n<li>LAST_ACK：等待所有分组死掉</li>\n</ul>\n<p>查找较多 time_wait 连接：</p>\n<div><pre><code><span>netstat</span> -n<span>|</span><span>grep</span> TIME_WAIT<span>|</span><span>awk</span> <span>'{print $5}'</span><span>|</span><span>sort</span><span>|</span><span>uniq</span> -c<span>|</span><span>sort</span> -rn<span>|</span><span>head</span> -n20\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"tcpdump-命令\"> tcpdump 命令</h3>\n<p>用于抓包。</p>\n<div><pre><code><span># 抓取经过 eth0 网卡的包，过滤条件为端口号 80</span>\ntcpdump -i eth0 port <span>80</span>\n\n<span># 抓本地环回的包</span>\ntcpdump -i lo port <span>80</span>\n\n<span># 将抓到的包导出为 test.pcap 文件</span>\ntcpdump -i lo port <span>80</span> -w test.pcap\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"系统管理\"> 系统管理</h2>\n<h3 id=\"添加、修改、删除用户\"> 添加、修改、删除用户</h3>\n<p>创建常规用户：</p>\n<div><pre><code><span># 创建用户，会自动创建 home 目录</span>\nadduser 用户名\n<span># 设置、修改密码</span>\n<span>passwd</span> 用户密码\n\n<span># 增加 sudo 权限</span>\n<span>vim</span> /etc/sudoers\n<span># 修改文件里面的</span>\n<span># root    ALL=(ALL) ALL</span>\n<span># 用户名    ALL=(ALL) ALL</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>删除用户：</p>\n<div><pre><code><span># 删除用户、密码、用户组，保留用户的家目录和用户的邮件目录</span>\n<span>userdel</span> testuser\n\n<span># 删除用户与其 home 目录和用户的邮件通知目录</span>\n<span>userdel</span> -r testuser\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>创建一个不能 ssh 登录的帐号（这类账号专门用于启动服务，只是让服务启动起来，但是不能登录系统 —— 提升安全性）：</p>\n<div><pre><code><span>useradd</span> 用户名 -s /sbin/nologin -M\n</code></pre>\n<div><span>1</span><br></div></div><blockquote>\n<p>在 useradd 命令后跟了两个参数，它们分别表示：</p>\n<ul>\n<li>-s：表示指定用户所用的 shell，此处为 <code>/sbin/nologin</code>，表示不登录</li>\n<li>-M：表示不创建用户主目录</li>\n</ul>\n</blockquote>\n<h3 id=\"date-命令\"> date 命令</h3>\n<p>用来显示或设定系统的日期与时间。</p>\n<div><pre><code><span># 直接显示日期与时间：Thu Mar 24 13:35:25 CST 2022</span>\n<span>date</span>\n\n<span># 自定义输出格式</span>\n<span>date</span> <span>\"+%Y_%m_%d %H-%M-%S\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"最近登录信息列表\"> 最近登录信息列表</h3>\n<div><pre><code><span># 最近登录的 5 个账号</span>\nlast -n <span>5</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"查找进程-ps-命令\"> 查找进程：ps 命令</h3>\n<p>用于显示当前进程的状态，类似于 Windows 的任务管理器。</p>\n<div><pre><code><span># 查找指定进程</span>\n<span>ps</span> -ef <span>|</span> <span>grep</span> 进程关键字\n\n<span># 显示进程信息</span>\n<span>ps</span> -A\n\n<span># 显示指定用户信息</span>\n<span>ps</span> -u 用户名\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>\n<p>语法格式：<code>ps [options] [--help]</code></p>\n<p>参数说明（ps 的参数非常多，在此仅列出几个常用的参数）：</p>\n<ul>\n<li>-A：列出所有的进程</li>\n<li>-w：显示加宽可以显示较多的资讯</li>\n<li>-au：显示较详细的资讯</li>\n<li>-aux：显示所有包含其他使用者的行程</li>\n</ul>\n</blockquote>\n<p>显示内容详解（以 <code>ps -aux</code> 为例）：</p>\n<div><pre><code><span>USER</span>       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li>USER：进程拥有者</li>\n<li>PID：pid</li>\n<li>%CPU：占用的 CPU 使用率</li>\n<li>%MEM：占用的内存使用率</li>\n<li>VSZ：占用的虚拟内存大小</li>\n<li>RSS：占用的内存大小</li>\n<li>TTY：终端的次要装置号码（minor device number of tty）</li>\n<li>STAT：该进程的状态\n<ul>\n<li>D：无法中断的休眠状态（通常表示该进程正在进行 I/O 动作）</li>\n<li>R：正在运行或者在运行队列中等待</li>\n<li>S：休眠，在等待某个事件、信号</li>\n<li>T：暂停执行，进程接收到信息 SIGSTOP，SIGSTP，SIGTIN，SIGTOU 信号</li>\n<li>Z：不存在但暂时无法消除（僵死进程）</li>\n<li>W：没有足够的内存分页可分配</li>\n<li>&lt;：高优先级的行程</li>\n<li>N：低优先级的行程</li>\n<li>L：有内存分页分配并锁在内存内（即时系统或定制 I/O）</li>\n</ul>\n</li>\n<li>START：进程开始时间</li>\n<li>TIME：执行的时间</li>\n<li>COMMAND：所执行的指令</li>\n</ul>\n<h3 id=\"监控服务器性能\"> 监控服务器性能</h3>\n<h4 id=\"_1-top-命令\"> 1）top 命令</h4>\n<p>用于实时显示 process 的动态。</p>\n<div><pre><code><span># 显示进程信息</span>\n<span>top</span>\n\n<span># 显示完整命令</span>\n<span>top</span> -c\n\n<span># 显示指定的进程信息</span>\n<span>top</span> -p 进程号\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>显示内容详解（以 <code>top -c</code> 为例）：</p>\n<div><pre><code>PID <span>USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li>PID：进程 id</li>\n<li>PPID：父进程 id</li>\n<li>RUSER：Real user name</li>\n<li>UID：进程所有者的用户 id</li>\n<li>USER：进程所有者的用户名</li>\n<li>GROUP：进程所有者的组名</li>\n<li>TTY：启动进程的终端名。不是从终端启动的进程则显示为 ?</li>\n<li>PR：优先级</li>\n<li>NI：nice 值。负值表示高优先级，正值表示低优先级</li>\n<li>P：最后使用的 CPU，仅在多 CPU 环境下有意义</li>\n<li>%CPU：上次更新到现在的 CPU 时间占用百分比</li>\n<li>TIME：进程使用的 CPU 时间总计，单位秒</li>\n<li>TIME+：进程使用的 CPU 时间总计，单位 1/100 秒</li>\n<li>%MEM：进程使用的物理内存百分比</li>\n<li>VIRT：进程使用的虚拟内存总量，单位 kb。VIRT=SWAP+RES</li>\n<li>SWAP：进程使用的虚拟内存中，被换出的大小，单位 kb</li>\n<li>RES：进程使用的、未被换出的物理内存大小，单位 kb，RES=CODE+DATA</li>\n<li>CODE：可执行代码占用的物理内存大小，单位 kb</li>\n<li>DATA：可执行代码以外的部分（数据段+栈）占用的物理内存大小，单位 kb</li>\n<li>SHR：共享内存大小，单位 kb</li>\n<li>nFLT：页面错误次数</li>\n<li>nDRT：最后一次写入到现在，被修改过的页面数</li>\n<li>S：进程状态。D=不可中断的睡眠状态，R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程</li>\n<li>COMMAND：命令名/命令行</li>\n<li>WCHAN：若该进程在睡眠，则显示睡眠中的系统函数名</li>\n<li>Flags：任务标志，参考 sched.h</li>\n</ul>\n<h4 id=\"_2-free-命令\"> 2）free 命令</h4>\n<p>用于显示内存状态（包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等）。</p>\n<div><pre><code><span># 显示内存使用信息</span>\n<span>free</span>\n\n<span># 以总和的形式查询内存的使用信息</span>\n<span>free</span> -t\n\n<span># 每 10s 执行一次命令</span>\n<span>free</span> -s <span>10</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>\n<p>语法格式：<code>free [-bkmotV][-s &lt;间隔秒数&gt;]</code></p>\n<p>参数说明：</p>\n<ul>\n<li>-b：以 Byte 为单位显示内存使用情况。</li>\n<li>-k：以 KB 为单位显示内存使用情况。</li>\n<li>-m：以 MB 为单位显示内存使用情况。</li>\n<li>-h：以合适的单位显示内存使用情况，最大为三位数，自动计算对应的单位值。单位有：\n<ul>\n<li>B = bytes</li>\n<li>K = kilos</li>\n<li>M = megas</li>\n<li>G = gigas</li>\n<li>T = teras</li>\n</ul>\n</li>\n<li>-o：不显示缓冲区调节列。</li>\n<li>-s&lt;间隔秒数&gt;：持续观察内存使用状况。</li>\n<li>-t：显示内存总和列。</li>\n<li>-V：显示版本信息。</li>\n</ul>\n</blockquote>\n<p>显示内容详解（以 <code>free -m</code> 为例）：</p>\n<div><pre><code>              total        used        <span>free</span>      shared  buff/cache   available\nMem:          <span>48257</span>       <span>26204</span>         <span>625</span>         <span>190</span>       <span>21427</span>       <span>21335</span>\nSwap:         <span>49105</span>        <span>1652</span>       <span>47453</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>\n<li>行\n<ul>\n<li>Mem：内存的使用情况。</li>\n<li>Swap：交换空间的使用情况。</li>\n</ul>\n</li>\n<li>列\n<ul>\n<li>total：总的内存量</li>\n<li>used：被当前运行中的进程使用的内存量</li>\n<li>free：未被使用的内存量</li>\n<li>shared：在两个或多个进程之间共享的内存量</li>\n<li>buffers：内存中保留用于内核记录进程队列请求的内存量</li>\n<li>cache：在 RAM 中存储最近使用过的文件的页缓冲大小</li>\n<li>buff/cache 缓冲区和缓存总的使用内存量（被 buffer 和 cache 使用的物理内存大小）</li>\n<li>available 可用于启动新应用的可用内存量（不含交换分区）</li>\n</ul>\n</li>\n</ul>\n<p>关系：total(48257M) = used(26204M) + free(625M) + buff/cache(21427M)，少许偏差是由于单位转换为 M 后造成的。</p>\n<p>更多的参考<a href=\"https://www.cnblogs.com/ultranms/p/9254160.html\" target=\"_blank\" rel=\"noopener noreferrer\">linux下free命令详解</a>。</p>\n<h3 id=\"shutdown-命令\"> shutdown 命令</h3>\n<p>用来进行开关机。</p>\n<div><pre><code><span># 立即关机</span>\n<span>shutdown</span> -h now\n\n<span># 重新启动计算机</span>\n<span>shutdown</span> -r now\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"系统设置\"> 系统设置</h2>\n<h3 id=\"alias-和-unalias-命令\"> alias 和 unalias 命令</h3>\n<p>alias 命令用于设置指令的别名，unalias 命令用于删除别名。</p>\n<blockquote>\n<p>alias 的效力仅作用于本次登入的操作。</p>\n</blockquote>\n<div><pre><code><span># 列出目前所有的别名设置</span>\n<span>alias</span>\n\n<span># 给命令设置别名</span>\n<span>alias</span> <span>ll</span><span>=</span><span>'ls -alF'</span>\n\n<span># 显示别名</span>\n<span>alias</span> ll\n\n<span># 删除别名</span>\n<span>unalias</span> ll\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"清除历史命令记录\"> 清除历史命令记录</h3>\n<div><pre><code>echo &gt; /root/.bash_history\nhistory -c\n\n# 清空指定用户的记录\nsu - xxx\necho &gt; ./.bash_history\nhistory -c\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"日常操作\"> 日常操作</h2>\n<h3 id=\"后台运行命令\"> 后台运行命令</h3>\n<p>用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行。</p>\n<div><pre><code><span># 后台运行，并且有 nohup.out 输出</span>\n<span>nohup</span> xxx <span>&amp;</span>\n\n<span># 后台运行，不输出任何日志</span>\n<span>nohup</span> xxx <span>></span> /dev/null <span>&amp;</span>\n\n<span># 后台运行，并将错误信息做标准输出到日志中 </span>\n<span>nohup</span> xxx <span>></span>out.log <span><span>2</span>></span><span>&amp;1</span> <span>&amp;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"同步服务器时间\"> 同步服务器时间</h3>\n<p>Linux 服务器运行久时，系统时间就会存在一定的误差，此时可以使用 ntpdate 进行时间同步。</p>\n<div><pre><code><span># 与中国国家授时中心的官方服务器同步</span>\nntpdate -u <span>210.72</span>.145.44\n\n<span># 与 NTP 服务器（上海）同步</span>\nntpdate -u ntp.api.bz\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"linux-命令大全\"> Linux 命令大全</h2>\n<ul>\n<li><a href=\"https://www.runoob.com/linux/linux-command-manual.html\" target=\"_blank\" rel=\"noopener noreferrer\">Linux 命令大全</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-03-23T09:50:30.000Z",
      "date_modified": "2022-04-05T08:50:46.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "MySQL 数据库设计规范",
      "url": "https://www.fedbook.cn/basic-skills/mysql/db-design-spec/",
      "id": "https://www.fedbook.cn/basic-skills/mysql/db-design-spec/",
      "content_html": "<h1 id=\"mysql-数据库设计规范\"> MySQL 数据库设计规范</h1>\n<p>一个平台或系统随着时间的推移和用户量的增多，数据库操作往往会变慢。而在服务端开发中数据库更是尤为重要，绝大多数情况下数据库的性能决定了程序的性能，如若前期埋下的坑越多到后期数据库就会成为整个系统的瓶颈。因此，更规范化地使用 MySQL 在开发中是不可或缺的。</p>\n<h2 id=\"数据库命名规范\"> 数据库命名规范</h2>\n<ul>\n<li>数据库所有表前缀均使用系统或模块的英文名称缩写。</li>\n<li>库名、表名、字段名必须使用小写字母并采用下划线分割。</li>\n<li>库名、表名、字段名禁止超过 32 个字符，须见名知意。</li>\n<li>库名、表名、字段名支持最多 64 个字符，统一规范、易于辨识以及减少传输量不要超过 32。</li>\n<li>库名、表名、字段名禁止使用 MySQL 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）。</li>\n<li>临时库、临时表名必须以系统或模块的英文名称缩写 + <code>_tmp_</code> 为前缀并以日期为后缀，例如（<code>pro_tmp_20220302</code>）。</li>\n<li>备份库、备份表名必须以系统或模块的英文名称缩写 + <code>_bak_</code> 为前缀并以日期为后缀，例如（<code>pro_bak_20220302</code>）。</li>\n<li>所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）。</li>\n</ul>\n<h2 id=\"基本设计规范\"> 基本设计规范</h2>\n<h4 id=\"_1-若无特殊说明-建表时一律采用-innodb-存储引擎\"> 1）若无特殊说明，建表时一律采用 InnoDB 存储引擎</h4>\n<p>选择合适的引擎可以提高数据库性能，如 InnoDB 和 MyISAM，InnoDB 和 MyISAM 是许多人在使用 MySQL 时最常用的两个表类型，这两个表类型各有优劣，视具体应用而定；基本的差别为：MyISAM 类型不支持事务处理等高级处理，而 InnoDB 类型支持；MyISAM 类型的表强调的是性能，其执行数度比 InnoDB 类型更快，但是不提供事务支持，而 InnoDB 提供事务支持以及外部键等高级数据库功能；因此，其支持事务处理、支持外键、支持崩溃修复能力和并发控制是我们建表时首选的存储引擎。</p>\n<h4 id=\"_2-数据库和表的字符集统一使用-utf8mb4-5-5-3-版本以上支持\"> 2）数据库和表的字符集统一使用 <code>utf8mb4</code>（5.5.3 版本以上支持）</h4>\n<p>数据库和表的字符集统一使用 utf8，若是有字段需要存储 emoji 表情之类的，则将表或字段设置成 <code>utf8mb4</code>；因为，utf8 号称万国码，其无需转码、无乱码风险且节省空间，而 utf8mb4 又向下兼容 utf8。</p>\n<h4 id=\"_3-设计数据库时所有表和字段必须添加注释\"> 3）设计数据库时所有表和字段必须添加注释</h4>\n<p>使用 comment 从句添加表和列的备注，或直接在数据库连接工具的注释栏添加注释，从项目开始就进行数据字典的维护。</p>\n<p>使用 comment 从句添加注释如：</p>\n<div><pre><code><span># 创建表</span>\nCREATE TABLE t1<span>(</span>id varchar2<span>(</span><span>32</span><span>)</span> primary key,name VARCHAR2<span>(</span><span>8</span><span>)</span> NOT NULL,age number<span>)</span><span>;</span>\n<span># 添加表注释</span>\ncomment on table t1 is <span>'个人信息'</span><span>;</span>\n<span># 添加字段注释：</span>\ncomment on <span>column</span> t1.id is <span>'id'</span><span>;</span>\ncomment on <span>column</span> t1.nameis <span>'姓名'</span><span>;</span>\ncomment on <span>column</span> t1.age is <span>'年龄'</span><span>;</span> \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>也可以使用可视化的数据库连接工具添加注释。</p>\n<h4 id=\"_4-单个表的数据量大小控制在500万以内\"> 4）单个表的数据量大小控制在500万以内</h4>\n<p>尽量控制单表数据量的大小，建议控制在500万以内。500万并不是 MySQL 数据库的极限，但数据量太多不利于对表结构进行修改、备份和恢复数据。</p>\n<p>可以适当采用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制单表数据量的大小。</p>\n<h4 id=\"_5-谨慎使用-mysql-分区表\"> 5）谨慎使用 MySQL 分区表</h4>\n<p>业务生命周期内，评估单表数据量是否在500万以内，超出此范围需考虑分库分表可扩展性。</p>\n<p>分区是将一个表的数据按照某种方式，比如按照时间上的月份，分成多个较小的，更容易管理的部分，但是逻辑上仍是一个表。分区表在物理上表现为多个文件，在逻辑上仍表现为同一个表，需要谨慎选择分区键。跨分区查询效率可能会更低，建议使用物理分区表等方式管理大数据。</p>\n<h4 id=\"_6-尽量做到冷热数据分离-减小表的宽度\"> 6）尽量做到冷热数据分离，减小表的宽度</h4>\n<p>MySQL 限制每个表最多存储 4096 列，并且每一行数据的大小不超过 65535 字节，为了减少磁盘 IO 线程的开销，就要适当控制表的宽度，因为表越宽，把表装载进内存缓冲池时所占用的内存也就越大，就会消耗更多的 IO 线程。除此之外，为了保证热数据的内存缓存命中率，更有效的利用缓存，避免读入无用的冷数据，尽量把经常使用到的列放到同一个表中，避免不必要的关联操作。</p>\n<h4 id=\"_7-建立预留字段需谨慎\"> 7）建立预留字段需谨慎</h4>\n<p>部分开发者在设计数据库表时，不仅设计了当前所需要的字段，而且还在其中留出几个字段作为备用。比方说，我设计了一个人员表（person），其中已经添加了各种必要的字段，包括姓名（Name）、性别（Sex）、出生年月日（birthday）等等；为了以防万一，比如之后可能 Person 表会涉及到毕业院校、工作单位、是否婚配和相片等信息，于是就加入 5 个 varchar2 型的字段，分别叫做 text1、text2……text5。</p>\n<p>这一手操作看似防范于未然，其实也并不见得，因为大量预留字段会浪费空间、预留字段不能做到见名知意、预留字段无法确认存储的数据类型且修改其字段类型还可能会造成锁表等问题。</p>\n<p>针对此等情况可以参考以下两点解决方案：</p>\n<ul>\n<li>如果数量很少，而且信息的性质与原表密切相关，那么就可以直接在原表上增加字段，并将相关的数据更新进去。</li>\n<li>如果数量较大，或者并非是原表对象至关重要的属性，那么就可以新增一个表，然后通过键值连接起来。</li>\n</ul>\n<h4 id=\"_8-数据库中禁止存储图片、文件等大的二进制数据\"> 8）数据库中禁止存储图片、文件等大的二进制数据</h4>\n<p>若往数据库表中存储文件，而文件通常很大，当数据库进行读取操作时，会进行大量的随机 IO 操作，大文件使得 IO 操作很耗时耗性能，造成短时间内数据量快速增长。所以，通常将图片、文件存储在文件服务器中，数据库只用于存储文件地址信息。</p>\n<h4 id=\"_9-禁止在线上做数据库压力测试\"> 9）禁止在线上做数据库压力测试</h4>\n<h4 id=\"_10-禁止从开发环境-测试环境直接连接生成环境数据库\"> 10）禁止从开发环境，测试环境直接连接生成环境数据库</h4>\n<h2 id=\"数据库字段设计规范\"> 数据库字段设计规范</h2>\n<h4 id=\"_1-优先选择符合存储需要的最小的数据类型\"> 1）优先选择符合存储需要的最小的数据类型</h4>\n<p>主要是考虑索引的性能，因为列的字段越大，建立索引时所需要的空间也越大，这样一页中能存储的索引节点的数量也就越少，在遍历时需要的 IO 次数也就越多，索引的性能也就越差。</p>\n<p>建议：</p>\n<ul>\n<li>将字符串转换成数字类型存储，如：将 IP 地址转换成整形数据。</li>\n<li>对于非负型的数据（如自增 ID、整型 IP）来说，要优先使用无符号整型来存储。因为，无符号相对于有符号可以多出一倍的存储空间，VARCHAR(N) 中的 N 代表的是字符数，而不是字节数。使用 UTF8 存储 255 个汉字，Varchar(255)=765 个字节。过大的长度会消耗更多的内存。</li>\n</ul>\n<h4 id=\"_2-避免使用-text、blob-数据类型\"> 2）避免使用 TEXT、BLOB 数据类型</h4>\n<p>最常见的 TEXT 类型可以存储 64K 数据，MySQL 内存临时表不支持 TEXT、BLOB 这样的大数据类型，若查询中包含这样的数据，在执行排序等操作时就不能使用内存临时表，必须使用磁盘临时表执行操作。</p>\n<p>但是不是说一定不能使用这样的数据类型，如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，查询时一定不要使用 <code>select *</code> 而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询。</p>\n<p>注意：出于内存和性能考虑，MySQL 对索引字段长度是有限制的。所以 TEXT 或 BLOB 类型只能使用前缀索引，并且 TEXT 列上是不能有默认值的。</p>\n<h4 id=\"_3-避免使用-enum-枚举类型\"> 3）避免使用 ENUM 枚举类型</h4>\n<ul>\n<li>修改 ENUM 值需要使用 <code>ALTER</code> 语句。</li>\n<li>ENUM 类型的 <code>ORDER BY</code>操作效率低。</li>\n<li>禁止使用数值作为 <code>ENUM</code> 的枚举值。</li>\n</ul>\n<h4 id=\"_4-尽可能把所有列定义为-not-null\"> 4）尽可能把所有列定义为 NOT NULL</h4>\n<ul>\n<li>如果查询中包含可为 NULL 的列，对 MySQL 来说更难优化，因为可为 NULL 的列使得索引，索引统计和值比较都更复杂（在 where 子句中对字段进行 null 值判断，将导致引擎放弃使用索引而进行全表扫描）。</li>\n<li>含 NULL 复合索引无效。</li>\n<li>可为 NULL 的列会使用更多的存储空间，在 MySQL 中也需要特殊处理。</li>\n<li>当可为 NULL 的列被索引时，每个索引记录需要一个额外的字节，在 MyISAM 里甚至还可能导致固定大小的索引（例如只有一个整数列的索引）变成可变大小的索引。</li>\n</ul>\n<p>通常把可为 NULL 的列改为 NOT NULL 带来的性能提升比较小，所以（调优时）没有必要首先在现有 schema 中查找并修改掉这种情况，除非确定这会导致问题。但是，如果计划在列上建索引，就应该尽量避免设计成可为 NULL 的列。</p>\n<h4 id=\"_5-使用-timestamp-4-字节-或-datetime-8-字节-类型存储时间\"> 5）使用 TIMESTAMP（4 字节）或 DATETIME（8 字节）类型存储时间</h4>\n<p>TIMESTAMP 存储的时间范围为：1970-01-01 00:00:01 ~ 2038-01-19-03:14:07。</p>\n<p>TIMESTAMP 占用 4 字节和 INT 相同，但可读性比 INT 类型的高，同时 TIMESTAMP 具有自动赋值以及自动更新的特性。若是超出 TIMESTAMP 取值范围的则使用 DATETIME 类型存储。</p>\n<p>用字符串类型存储时间的缺点：无法使用日期函数进行比较计算、字符串存储占有更多的空间。</p>\n<h4 id=\"_6-财务相关的金额类数据必须使用-decimal-类型\"> 6）财务相关的金额类数据必须使用 DECIMAL 类型</h4>\n<ul>\n<li>精准浮点：DECIMAL</li>\n<li>非精准浮点：FLOAT、DOUBLE</li>\n</ul>\n<p>DECIMAL 类型为精准浮点数，在计算时不会丢失精度。占有空间大小由定义的宽度决定，每 4 个字节可以存储 9 位数字，且小数点也要占有一个字节。另外，DECIMAL 类型可用于存储比 BIGINT 更大的数据类型。</p>\n<h4 id=\"_7-建议使用-unsigned-存储非负数值\"> 7）建议使用 UNSIGNED 存储非负数值</h4>\n<p>同样的字节数，非负存储的数值范围更大。如 TINYINT 有符号为 -128-127，无符号为 0-255。</p>\n<h4 id=\"_8-建议使用-int-unsigned-存储-ipv4\"> 8）建议使用 INT UNSIGNED 存储 IPV4</h4>\n<p>用 UNSINGED INT 存储 IP 地址占用 4 字节，CHAR(15) 则占用 15 字节。另外，计算机处理整数类型比字符串类型快。使用 INT UNSIGNED 而不是 CHAR(15) 来存储 IPV4 地址，通过 MySQL 函数 <code>inet_ntoa</code> 和 <code>inet_aton</code> 来进行转化。IPv6 地址目前没有转化函数，需要使用 DECIMAL 或两个 BIGINT 来存储。</p>\n<p>例如：</p>\n<div><pre><code>SELECT INET_ATON<span>(</span><span>'209.207.224.40'</span><span>)</span><span>;</span> <span># 3520061480</span>\nSELECT INET_NTOA<span>(</span><span>3520061480</span><span>)</span><span>;</span>       <span># 209.207.224.40</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h4 id=\"_9-建议使用-tinyint-来代替-enum-类型\"> 9）建议使用 TINYINT 来代替 ENUM 类型</h4>\n<p>ENUM 类型在需要修改或增加枚举值时，需要在线 DDL，成本较高。且 ENUM 列值如果含有数字类型，可能会引起默认值混淆。</p>\n<h4 id=\"_10-使用-varbinary-存储大小写敏感的变长字符串或二进制内容\"> 10）使用 VARBINARY 存储大小写敏感的变长字符串或二进制内容</h4>\n<p>VARBINARY 默认区分大小写，没有字符集概念，速度快。</p>\n<h4 id=\"_11-禁止在数据库中存储明文密码\"> 11）禁止在数据库中存储明文密码</h4>\n<h2 id=\"索引设计规范\"> 索引设计规范</h2>\n<p>建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。</p>\n<p>索引是一把双刃剑，可提高查询效率，但也会降低插入和更新的速度并占用磁盘空间。</p>\n<h4 id=\"_1-每张表的索引数量不超过-5-个\"> 1）每张表的索引数量不超过 5 个</h4>\n<p>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会增加 MySQL 优化器生成执行计划时间，降低查询性能。</p>\n<h4 id=\"_2-禁止给表中的每一列都建立单独的索引\"> 2）禁止给表中的每一列都建立单独的索引</h4>\n<p>5.6 版本之前，一个 SQL 只能使用到一个表中的一个索引；5.6 以后，虽然有了合并索引的优化方式，但远没有使用联合索引的查询方式效率高。</p>\n<h4 id=\"_3-每个-innodb-表必须有一个主键\"> 3）每个 InnoDB 表必须有一个主键</h4>\n<p>InnoDB 是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。</p>\n<p>每个表都可以有多个索引，但是表的存储顺序只能有一种，InnoDB 是按照主键索引的顺序来组织表的，因此不要使用更新频繁的列、UUID、MD5、HASH 和字符串列作为主键，这些列无法保证数据的顺序增长，主键建议使用自增 ID 值。</p>\n<h4 id=\"_4-使用短索引\"> 4）使用短索引</h4>\n<p>对字符串使用前缀索引，前缀索引长度不超过 10 个字符。</p>\n<p>举例：如有一个 CHAR(200) 列，在前 10 个字符内，多数值是惟一的，就可不要对整个列进行索引。只对前 10 个字符进行索引能够节省大量索引空间，也可能会使查询更快。</p>\n<h4 id=\"_5-避免冗余或重复索引\"> 5）避免冗余或重复索引</h4>\n<p>合理创建联合索引（避免冗余），index(a,b,c) 相当于 index(a)、index(a,b)、index(a,b,c)。</p>\n<ul>\n<li>索引不是越多越好，按实际需要进行创建，每个额外的索引都要占用额外的磁盘空间，并降低写操作的性能。</li>\n<li>不在低基数列上建立索引，例如「性别」。</li>\n<li>不在索引列进行数学运算和函数运算。</li>\n</ul>\n<h4 id=\"_6-尽量避免使用外键约束\"> 6）尽量避免使用外键约束</h4>\n<ul>\n<li>不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引。</li>\n<li>外键虽然可以保证数据的参照完整性，但外键也会影响父表和子表的写操作从而降低性能，还会使得表更耦合，建议在业务端实现。</li>\n</ul>\n<h4 id=\"_7-不使用-前导的查询-如-like-xxx\"> 7）不使用 <code>%</code> 前导的查询，如 <code>like &quot;%xxx&quot;</code></h4>\n<p>无法使用索引。</p>\n<h4 id=\"_8-不使用反向查询-如-not-in-not-like\"> 8）不使用反向查询，如 <code>not in</code> / <code>not like</code></h4>\n<p>无法使用索引，导致全表扫描，全表扫描导致 bufferpool 利用降低。</p>\n<h4 id=\"_9-索引列建议\"> 9）索引列建议</h4>\n<p>① 出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列</p>\n<p>② 包含在 ORDER BY、GROUP BY、DISTINCT 中的字段。</p>\n<p>③ 多表 join 的关联列。</p>\n<p>注意：并不要将符合 ① 和 ② 中的字段的列都建立一个索引，通常将 ①、② 中的字段建立联合索引效果更好。</p>\n<h4 id=\"_10-如何选择索引列的顺序\"> 10）如何选择索引列的顺序</h4>\n<ul>\n<li>区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）。</li>\n<li>尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）。</li>\n<li>使用最频繁的列放到联合索引的左侧（这样可较少的建立一些索引）。</li>\n</ul>\n<h4 id=\"_11-避免建立冗余索引和重复索引\"> 11）避免建立冗余索引和重复索引</h4>\n<p>冗余/重复索引会增加查询优化器生成执行计划的时间。</p>\n<ul>\n<li>重复索引示例：primary key(id)、index(id)、unique index(id)</li>\n<li>冗余索引示例：index(a,b,c)、index(a,b)、index(a)</li>\n</ul>\n<h4 id=\"_12-优先考虑覆盖索引\"> 12）优先考虑覆盖索引</h4>\n<p>对于频繁的查询优先考虑使用覆盖索引。</p>\n<p>覆盖索引：即包含了所有查询字段（where，select，order by，group by 包含的字段）的索引。</p>\n<p>覆盖索引的好处：</p>\n<ul>\n<li>避免 InnoDB 表进行索引的二次查询\n<ul>\n<li>InnoDB 是以聚集索引的顺序来存储的，对于 InnoDB 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据，在查找到相应的键值后，还需通过主键进行二次查询才能获取我们真实所需要的数据。</li>\n<li>而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询，减少了 IO 操作，提升了查询效率。</li>\n</ul>\n</li>\n<li>可以把随机 IO 变成顺序 IO 加快查询效率\n<ul>\n<li>由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"数据库-sql-开发规范\"> 数据库 SQL 开发规范</h2>\n<h4 id=\"_1-建议使用预编译语句进行数据库操作\"> 1）建议使用预编译语句进行数据库操作</h4>\n<p>预编译语句可以重复使用，相同的 SQL 语句可以一次解析，多次使用，减少 SQL 编译所需要的时间，提高处理效率；此外，还可以有效解决动态 SQL 带来的 SQL 注入问题。</p>\n<h4 id=\"_2-避免数据类型的隐式转换\"> 2）避免数据类型的隐式转换</h4>\n<p>隐式转换如：<code>SELECT 1 + &quot;1&quot;</code>。数值型 + 字符型 的隐式转换有可能会导致索引失效，以及一些意想不到的结果等。</p>\n<h4 id=\"_3-充分利用表中存在的索引\"> 3）充分利用表中存在的索引</h4>\n<ul>\n<li>避免使用双 <code>%</code> 号的查询条件\n<ul>\n<li>如 <code>WHERE first_name like '%James%'</code>，若无前置 <code>%</code>，只有后置 <code>%</code>，则执行 SQL 语句时会用到列上的索引，双 <code>%</code> 号则不会使用列上的索引。</li>\n</ul>\n</li>\n<li>一条 SQL 语句只能使用复合索引中的一列进行范围查询\n<ul>\n<li>例如有 weight、age、sex 三列的联合索引，在查询条件中有 weight 列的范围查询，则在 age 和 sex 列上的索引将不会被使用。因此，在定义联合索引时，若某列需要用到范围查询，则将该列放到联合索引的右侧。</li>\n</ul>\n</li>\n<li>使用 <code>not exists</code> 代替 <code>not in</code>\n<ul>\n<li>因为 <code>not in</code> 在 SQL 语句中执行时会导致索引失效。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"_4-杜绝使用-select-必须使用-select-字段列表-查询\"> 4）杜绝使用 <code>SELECT *</code> ，必须使用 <code>SELECT &lt;字段列表&gt;</code> 查询</h4>\n<p>因为使用 <code>SELECT *</code> 查询会消耗更多的 CPU、IO 和网络宽带资源，并且查询时无法使用覆盖索引。</p>\n<h4 id=\"_5-禁止使用不含字段列表的-insert-语句\"> 5）禁止使用不含字段列表的 <code>INSERT</code> 语句</h4>\n<p>如：<code>INSERT into table_name values ('1','2','3');</code></p>\n<p>改为带字段列表的 INSERT 语句：<code>INSERT into table_name('c1','c2','c3') values ('1','2','3');</code></p>\n<h4 id=\"_6-避免使用子查询-可以把子查询优化为-join-关联操作\"> 6）避免使用子查询，可以把子查询优化为 <code>join</code> 关联操作</h4>\n<p>但是，通常子查询在 <code>in</code> 子句中，且子查询中为简单 SQL（即不包含 <code>union</code>、<code>group by</code>、<code>order by</code>、<code>limit</code> 从句）时，才可以把子查询转化为 <code>join</code> 关联查询进行优化。</p>\n<p>子查询性能差的原因：</p>\n<ul>\n<li>子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。</li>\n<li>由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。</li>\n</ul>\n<h4 id=\"_7-避免使用-join-关联太多表\"> 7）避免使用 <code>JOIN</code> 关联太多表</h4>\n<ul>\n<li>在 MySQL 中，对于同一个 SQL 关联（join）多个表，每个 <code>join</code> 就会多分配一个关联缓存，如果在一个 SQL 中关联的表越多，所占用的内存也就越大。</li>\n<li>如果程序中大量的使用了多表关联的操作，同时 join_buffer_size（MySQL 允许关联缓存的个数）设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响服务器数据库性能的稳定性。</li>\n<li>此外，对于关联操作来说，会产生临时表影响查询效率，而 MySQL 最多允许关联 61 个表，建议不超过 5 个。</li>\n</ul>\n<h4 id=\"_8-对同一列对象进行-or-判断时-使用-in-替代-or\"> 8）对同一列对象进行 <code>or</code> 判断时，使用 <code>in</code> 替代 <code>or</code></h4>\n<p><code>in</code> 的值只要涉及不超过 500 个，则 <code>in</code> 操作可以更有效的利用索引，<code>or</code> 大多数情况下很少能利用到索引。</p>\n<h4 id=\"_9-禁止使用-order-by-rand-进行随机排序\"> 9）禁止使用 <code>order by rand()</code> 进行随机排序</h4>\n<p>随机排序会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的 CPU 和 IO 及内存资源。</p>\n<p>简单来说：<code>order by rand()</code> 会将数据从磁盘中读取，进行排序，会消耗大量的 IO 和 CPU。</p>\n<p>推荐在程序中获取一个随机值，然后从数据库中获取对应的数据。</p>\n<h4 id=\"_10-禁止在-where-从句中对列进行函数转换和计算\"> 10）禁止在 <code>WHERE</code> 从句中对列进行函数转换和计算</h4>\n<p>因为在 <code>WHERE</code> 从句中对列进行函数转换或计算时会导致索引无法使用。</p>\n<div><pre><code><span># 不推荐</span>\nwhere date<span>(</span>end_time<span>)</span><span>=</span><span>'20190101'</span>\n\n<span># 推荐</span>\nwhere end_time <span>>=</span> <span>'20190101'</span> and end_time <span>&lt;</span> <span>'20190102'</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id=\"_11-在明显不会有重复值时使用-union-all-而不是-union\"> 11）在明显不会有重复值时使用 <code>UNION ALL</code> 而不是 <code>UNION</code></h4>\n<ul>\n<li><code>UNION</code> 会把两个结果集的所有数据放到临时表中后再进行去重操作。</li>\n<li><code>UNION ALL</code> 不会再对结果集进行去重操作。</li>\n</ul>\n<h4 id=\"_12-把复杂、较长的-sql-拆分为多个小-sql-执行\"> 12）把复杂、较长的 SQL 拆分为多个小 SQL 执行</h4>\n<ul>\n<li>大 SQL 在逻辑上比较复杂，是需要占用大量 CPU 进行计算一条 SQL 语句。</li>\n<li>在 MySQL 中，一条 SQL 语句只能使用一个 CPU 进行计算。</li>\n<li>SQL 拆分后可以通过并行执行来提高处理效率。</li>\n</ul>\n<h4 id=\"_13-避免在数据库中进行数学运算\"> 13）避免在数据库中进行数学运算</h4>\n<ul>\n<li>容易将业务逻辑和 DB 耦合在一起</li>\n<li>MySQL 不擅长数学运算和逻辑判断</li>\n<li>无法使用索引</li>\n</ul>\n<h2 id=\"数据库行为规范\"> 数据库行为规范</h2>\n<h4 id=\"_1-超过100万行数据的批量操作-update-delete-insert-分多次进行\"> 1）超过100万行数据的批量操作（update delete insert），分多次进行</h4>\n<ul>\n<li>大批量操作可能回造成严重的主从延迟。\n<ul>\n<li>主从环境中，大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，只有当主库上执行完成后，才会在其他从库上执行，会造成主库与从库长时间的延迟情况。</li>\n</ul>\n</li>\n<li>binlog 日志为 row 格式时会产生大量的日志。\n<ul>\n<li>大批量写操作会产生大量日志，特别是对于 row 格式二进制数据而言，由于在 row 格式中会记录每一行数据的修改，一次修改的数据越多，产生的日志量也会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因。</li>\n</ul>\n</li>\n<li>避免产生大事务操作。\n<ul>\n<li>大批量修改数据，一定是在一个事务中进行的，这会造成表中大批量数据进行锁定，导致大量的阻塞，阻塞会对 MySQL 的性能影响很大。尤其是长时间的阻塞会占满所有数据库的可用连接，会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"_2-对于大表使用-pt-online-schema-change-修改表结构\"> 2）对于大表使用 pt-online-schema-change 修改表结构</h4>\n<ul>\n<li>可避免大表修改产生的主从延迟。</li>\n<li>可避免在对表字段进行修改时进行锁表</li>\n</ul>\n<p>生产环境中，对大表数据结构的修改一定要谨慎，会造成严重的锁表操作。</p>\n<blockquote>\n<p>pt-online-schema-change 它首先会建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。</p>\n<p>接着，把原表中新增的数据也复制到新表中，在将所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉，其实是把原来一个 DDL 操作，分解成多个小的批次执行。</p>\n<p>这也是对表进行碎片整理/重组的一个常用方式。</p>\n</blockquote>\n<h4 id=\"_3-禁止给程序使用的账号授予-super-权限\"> 3）禁止给程序使用的账号授予 super 权限</h4>\n<p>原因：当 MySQL 达到最大连接数限制时，此刻还运行 1 个有super权限的用户连接，super 权限只能留给 DBA 处理问题的账号使用。</p>\n<h4 id=\"_4-对于程序连接数据库账号-遵循权限最小原则\"> 4）对于程序连接数据库账号，遵循权限最小原则</h4>\n<p>程序使用数据库账号只能在一个数据库下使用，不准跨库，且程序使用的账号原则上不授予 drop 权限。</p>\n<h4 id=\"其他一些操作规范\"> 其他一些操作规范</h4>\n<ul>\n<li>任何数据库的线上操作，必须走工单。</li>\n<li>禁止在主库上执行统计类的功能查询。</li>\n<li>有大规模市场推广、运营活动必须提前通知 DBA 进行流量评估。</li>\n<li>对单表的多次 alter 操作必须合并为一次操作。</li>\n<li>不在 MySQ L数据库中存放业务逻辑，即可创建存储过程。</li>\n<li>重大项目的数据库方案选型和设计必须提前通知 DBA 参与。</li>\n<li>数据必须有备份机制和定期的恢复演练。</li>\n<li>不在业务高峰期批量更新、查询数据库。</li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-03-02T09:58:44.000Z",
      "date_modified": "2022-03-02T15:34:51.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "MySQL 常用命令",
      "url": "https://www.fedbook.cn/basic-skills/mysql/common-commands/",
      "id": "https://www.fedbook.cn/basic-skills/mysql/common-commands/",
      "content_html": "<h1 id=\"mysql-常用命令\"> MySQL 常用命令</h1>\n<p>有时候不能使用可视化工具，就需要通过一些命令快速查看和操作数据库数据。</p>\n<div><pre><code><span># 连接mysql（注：-h、-P、-u、-p后面可以不用加空格）</span>\nmysql -h主机地址 -P端口 -u用户名 -p用户密码\n\n<span># 显示数据库</span>\nmysql<span>></span> show databases<span>;</span>\n\n<span># 使用某个数据库</span>\nmysql<span>></span> use xxx<span>;</span>\n\n<span># 查看该数据库中的表</span>\nmysql<span>></span> show tables<span>;</span>\n\n<span># 显示数据表的结构</span>\nmysql<span>></span> describe 表名<span>;</span>\n\n<span># 显示表中的记录（注意表名大小写）</span>\nmysql<span>></span> <span>select</span> * from 表名<span>;</span>\n\n<span># 创建数据库</span>\nmysql<span>></span> create database 数据库名<span>;</span>\n\n<span># 建表  </span>\nuse 库名<span>;</span>\ncreate table 表名 （跟上字段列表）<span>;</span>\n<span># 例如：创建表user,表中有id（序号，自增），name（姓名）,gender（性别）,birthday（出身年月）四个字段  </span>\nmysql<span>></span> use blog<span>;</span>  \nmysql<span>></span> create table user <span>(</span>id int<span>(</span><span>3</span><span>)</span> auto_increment not null primary key, name char<span>(</span><span>8</span><span>)</span>,gender char<span>(</span><span>2</span><span>)</span>,birthday <span>date</span><span>)</span><span>;</span>\nmysql<span>></span> describe name<span>;</span>\n\n<span># 往表中增加数据</span>\n<span># 例如：增加几条相关纪录。  </span>\nmysql<span>></span> insert into user values<span>(</span><span>''</span>,<span>'张三'</span>,<span>'男'</span>,<span>'2019-01-01'</span><span>)</span><span>;</span>  \nmysql<span>></span> insert into user values<span>(</span><span>''</span>,<span>'李四'</span>,<span>'女'</span>,<span>'2020-06-01'</span><span>)</span><span>;</span>\nmysql<span>></span> <span>select</span> * from name<span>;</span>\n\n<span># 修改表中数据</span>\n<span># 例如：将张三的出生年月改为2019-06-01</span>\nmysql<span>></span> update user <span>set</span> <span>birthday</span><span>=</span><span>'2019-01-01'</span> where <span>name</span><span>=</span><span>'张三'</span><span>;</span>  \n\n<span># 删除某表中的数据  </span>\n<span># 例如：删除名字是张三的数据。  </span>\nmysql<span>></span> delete from user where <span>name</span><span>=</span><span>'张三'</span><span>;</span>  \n\n<span># 删库和删表  </span>\nmysql<span>></span> drop database 库名<span>;</span>\nmysql<span>></span> drop table 表名<span>;</span>\n\n<span># 退出mysql</span>\nmysql<span>></span> <span>exit</span> <span>(</span>回车<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><p>（完）</p>\n",
      "date_published": "2022-03-01T15:44:23.000Z",
      "date_modified": "2022-03-02T09:21:49.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Nginx 常用命令",
      "url": "https://www.fedbook.cn/basic-skills/nginx/common-commands/",
      "id": "https://www.fedbook.cn/basic-skills/nginx/common-commands/",
      "content_html": "<h1 id=\"nginx-常用命令\"> Nginx 常用命令</h1>\n<h2 id=\"nginx-操作的命令\"> Nginx 操作的命令</h2>\n<div><pre><code><span># 查看 Nginx 版本</span>\n/usr/local/nginx/sbin/nginx -v\n\n<span># 检查配置文件 ngnix.conf 的正确性</span>\n/usr/local/nginx/sbin/nginx -t\n\n<span># 启动 Nginx 服务</span>\n/usr/local/nginx/sbin/nginx\n\n<span># 启动 Nginx 服务，-c 指定配置文件的路径</span>\n/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\n\n<span># 重新加载配置</span>\n/usr/local/nginx/sbin/nginx -s reload\n\n<span># 停止 Nginx 服务（快速关闭，不管有没有正在处理的请求）</span>\n/usr/local/nginx/sbin/nginx -s stop\n\n<span># 安全退出 Nginx 服务（在退出前会完成已经接受的连接请求，比较优雅）</span>\n/usr/local/nginx/sbin/nginx -s quit\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h2 id=\"linux-检查的命令\"> Linux 检查的命令</h2>\n<div><pre><code><span># 查看 Nginx 进程</span>\n<span>ps</span> -ef <span>|</span> <span>grep</span> nginx\n\n<span># 检查 Nginx 启动的端口</span>\n<span>netstat</span> -lntup <span>|</span> <span>grep</span> nginx\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"服务器防火墙相关命令\"> 服务器防火墙相关命令</h2>\n<p>如果 Nginx 启动成功后，从浏览器访问还是连接不上，按如下步骤排查：</p>\n<ul>\n<li>检查阿里云安全组是否开放端口（通过阿里云后台）</li>\n<li>服务器防火墙是否开放端口</li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-07-02T13:26:41.000Z",
      "date_modified": "2021-07-02T13:26:41.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "MySQL 的安装与卸载",
      "url": "https://www.fedbook.cn/basic-skills/mysql/installation-of-mysql/",
      "id": "https://www.fedbook.cn/basic-skills/mysql/installation-of-mysql/",
      "content_html": "<h1 id=\"mysql-的安装与卸载\"> MySQL 的安装与卸载</h1>\n<h2 id=\"windows-下安装\"> Windows 下安装</h2>\n<blockquote>\n<p>Windows 下的 MySQL 不能用于生产，一般用于开发目的或者尝鲜体验。</p>\n</blockquote>\n<h3 id=\"安装-mysql\"> 安装 MySQL</h3>\n<p>我比较喜欢免安装版本的，轻便干净，删起来方便。</p>\n<p>到官网的开发者专区下载 MySQL（Community版）免安装软件包：</p>\n<ul>\n<li><a href=\"https://dev.mysql.com/downloads/mysql/\" target=\"_blank\" rel=\"noopener noreferrer\">下载地址</a>。</li>\n<li>安装包名字：mysql-8.0.28-winx64.zip</li>\n</ul>\n<blockquote>\n<p>当前最新版本是 8.0，如果需要下载其它版本，可以点击页面中的 <strong>Looking for previous GA versions?</strong>（网站可能会更新，未来入口也许会变化）</p>\n</blockquote>\n<h3 id=\"解压压缩包\"> 解压压缩包</h3>\n<p>将下载的软件包解压并重命名到 <code>D:\\mysql-8.0</code> 目录下。</p>\n<div><pre><code>├── mysql-8.0\n    │── bin\n    │── docs\n    │── include\n    │── lib\n    │── share\n    │── LICENSE\n    └── README\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"进入命令行终端\"> 进入命令行终端</h3>\n<p>以 Window10 为例，有两种方法能以管理员身份运行 CMD 命令提示符：</p>\n<ul>\n<li>在<strong>开始菜单</strong>上，单击<strong>鼠标右键</strong>，在出现的菜单中，选择**命令提示符（管理员）**点击打开这样即可。</li>\n<li>点击开始菜单，在 <strong>Windows 系统</strong>中找到<strong>命令提示符</strong>，然后这时候在命令提示符上单击鼠标右键，选择<strong>以管理员身份打开命令提示符</strong>。</li>\n</ul>\n<p>进入终端后，在终端中依次输入如下指令：</p>\n<div><pre><code>d:\n<span>cd</span> D:<span>\\</span>mysql-8.0<span>\\</span>bin\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"初始化-mysql\"> 初始化 MySQL</h3>\n<p>初始化可以选择带有随机密码或无密码，建议采用无密码初始化（可以设置密码），以免随机密码丢失。</p>\n<div><pre><code><span># 随机密码</span>\n.<span>\\</span>mysqld --initialize\n\n<span># 无密码</span>\n.<span>\\</span>mysqld --initialize-insecure\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>执行完初始化命令后，可以发现解压路径下多了一个 <code>data</code> 的文件夹，在里面找到 <code>计算机名.err</code> 的文件，并打开。如果你设置了随机密码，在里面就能找到初始密码：<code>root@localhost: (这个位置的字符串就是临时密码)</code>。</p>\n<h3 id=\"安装-mysqld\"> 安装 mysqld</h3>\n<p>继续在当前路径下执行下列命令，安装 Windows 服务：</p>\n<div><pre><code>.<span>\\</span>mysqld -install\n</code></pre>\n<div><span>1</span><br></div></div><p>PS：<code>mysql</code> 用于执行 SQL 命令，<code>mysqld</code> 用于执行数据库命令：</p>\n<h3 id=\"启动-mysql-服务\"> 启动 MySQL 服务</h3>\n<p>安装提示 success 后，可以准备启动数据库并连接了。</p>\n<div><pre><code><span># 启动数据库</span>\nnet start mysql\n\n<span># 使用 root 连接数据库, 没有密码的话直接回车即可</span>\n.<span>\\</span>mysql -u root -p\n\n<span># 关闭数据库</span>\nnet stop mysql\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"添加-修改-root-账号登录密码\"> 添加/修改 root 账号登录密码</h3>\n<p>启动数据库并登录 MySQL：</p>\n<div><pre><code>net start mysql\n.<span>\\</span>mysql -u root -p\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>查询用户密码，可以看到，root 用户的密码是空的：</p>\n<div><pre><code><span>select</span> host,user,authentication_string from mysql.user<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>修改 root 用户的密码，执行命令：</p>\n<div><pre><code>ALTER <span>USER</span> <span>'root'</span>@<span>'localhost'</span> IDENTIFIED WITH mysql_native_password BY <span>'123456'</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>这里的密码就随意填写，生产环境不建议使用过于简单的 <code>123456</code>、<code>root</code>、<code>admin</code> 之类的密码。该命令执行完毕会得到结果：<code>Query OK, 0 rows affected (0.01 sec)</code>。</p>\n<p>接着需要继续执行命令：</p>\n<div><pre><code>flush privileges<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>该命令作用是刷新 MySQL 的系统权限相关表，这样才能使刚刚的密码修改成功。</p>\n<p>每次 MySQL 新设置用户或更改密码后都需要用 <code>flush privileges;</code> 来刷新 MySQL 的系统权限相关表，否则会出现拒绝访问。还有一种方法，就是重新启动 MySQL 服务，来使新设置生效。</p>\n<p>退出登录，并重新登录，此时必须使用刚才添加的密码才能登录 MySQL：</p>\n<div><pre><code><span># 退出登录</span>\nquit\n\n<span># 重新登录</span>\n.<span>\\</span>mysql -u root -p\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"卸载-mysql\"> 卸载 MySQL</h3>\n<p>同样是以管理员身份运行命名提示符，先停止服务，然后执行卸载命令卸载：</p>\n<div><pre><code>net stop mysql\n.<span>\\</span>mysqld --remove mysql\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"centos-7-6-下安装\"> CentOS 7.6 下安装</h2>\n<h3 id=\"安装对比\"> 安装对比</h3>\n<p>MySQL 有两种安装方式：</p>\n<ul>\n<li>yum 安装：安装过程人为无法干预，不能按需安装。rpm 包里面有什么就安装什么，安装的版本也比较低。</li>\n<li>源码包安装：分为编译安装和免编译安装：可以设定参数，按照需求进行安装，并且安装的版本，可以自己选择，灵活性比较大。</li>\n</ul>\n<p>这里我们采用源码包 - 免编译的方式安装 MySQL。</p>\n<h3 id=\"下载并解压安装包\"> 下载并解压安装包</h3>\n<p>MySQL 源码包下载地址：<a href=\"https://dev.mysql.com/downloads/mysql/\" target=\"_blank\" rel=\"noopener noreferrer\">https://dev.mysql.com/downloads/mysql/</a></p>\n<p>CentOS 是基于红帽的，因此操作系统选择 Red Hat，OS 版本选择 Linux 7 (x86, 64-bit)。</p>\n<p>选择 <strong>Compressed TAR Archive</strong> 点击 Download，获取到下载链接如下：</p>\n<div><pre><code>https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.28-el7-x86_64.tar.gz\n</code></pre>\n<div><span>1</span><br></div></div><p>登录服务器，切换到 <code>/opt</code> 目录并新建一个 <code>mysql</code> 文件夹，下载 MySQL 安装包（如果下载慢的话，可以在本地下载后传到服务器）：</p>\n<div><pre><code><span># 切换目录</span>\n<span>cd</span> /opt\n<span># 新建一个文件夹用于放 mysql</span>\n<span>mkdir</span> mysql\n<span># 切换目录</span>\n<span>cd</span> mysql/\n<span># 下载安装包</span>\n<span>wget</span> https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.28-el7-x86_64.tar.gz\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>解压并重命名：</p>\n<div><pre><code><span># 解压</span>\n<span>tar</span> -zxvf mysql-8.0.28-el7-x86_64.tar.gz\n<span># 重命名, 原来的名字太长了</span>\n<span>mv</span> ./mysql-8.0.28-el7-x86_64 mysql-8.0\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"创建数据文件夹以及用户并赋予权限\"> 创建数据文件夹以及用户并赋予权限</h3>\n<p>以下步骤需要在 <code>/opt/mysql/</code> 目录下执行。</p>\n<p>创建数据文件夹：</p>\n<div><pre><code><span># 创建 data 目录(用于放置 mysql 数据文件)</span>\n<span>mkdir</span> data\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>创建用户组，并授权操作：</p>\n<div><pre><code><span># 为 MySQL 创建一个不能 ssh 登陆的用户, 且不创建用户主目录</span>\n<span>useradd</span> mysql -s /sbin/nologin -M\n<span># 修改文件所有者</span>\n<span>chown</span> -R mysql:mysql /opt/mysql/\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>\n<p>在 useradd 命令后跟了两个参数，它们分别表示：</p>\n<ul>\n<li>-s：表示指定用户所用的 shell，此处为 <code>/sbin/nologin</code>，表示不登录</li>\n<li>-M：表示不创建用户主目录</li>\n</ul>\n</blockquote>\n<h3 id=\"初始化数据库\"> 初始化数据库</h3>\n<p>以下步骤需要在 <code>/opt/mysql/</code> 目录下执行。</p>\n<p>初始化数据库：</p>\n<div><pre><code>/opt/mysql/mysql-8.0/bin/mysqld --initialize --user<span>=</span>mysql --basedir<span>=</span>/opt/mysql/mysql-8.0/ --datadir<span>=</span>/opt/mysql/data/ --lower_case_table_names<span>=</span><span>1</span>\n</code></pre>\n<div><span>1</span><br></div></div><blockquote>\n<p>MySQL 8.0 后，在 Linux 端，对于 lower_case_table_names 参数，只又在初始化的时候设置才有效，若初始化的时候没设置，后面修改配置文件后再启动服务就会报错了。</p>\n</blockquote>\n<p>在这行命令的输出中，这里我们会看到初始密码（应该实在最后一行），记下来：</p>\n<div><pre><code>A temporary password is generated <span>for</span> root@localhost: <span>(</span>这个位置的字符串就是临时密码<span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"创建-mysql-配置文件-my-cnf\"> 创建 MySQL 配置文件 my.cnf</h3>\n<p>通过阅读 <code>support-files/mysql.server</code> 这个脚本知道，如果我们的 MySQL 不是安装在默认的 <code>/usr/local/mysql</code> 里，就需要新建一个 <code>/etc/my.cnf</code> 文件，在 <code>[mysqld]</code> 段中设置 <code>basedir</code> 参数。</p>\n<p>新建文本文档 <code>my.cnf</code>：</p>\n<div><pre><code><span># 该配置文件必须建立在该目录下</span>\n<span>vim</span> /etc/my.cnf\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>将下面的内容添加到该配置文件中（此处是学习用的配置示例，生产环境需要根据实际情况定制，详细参数<a href=\"https://dev.mysql.com/doc/refman/8.0/en/server-configuration-defaults.html\" target=\"_blank\" rel=\"noopener noreferrer\">见官网</a>）：</p>\n<div><pre><code>[mysqld]\n# mysql 服务的唯一编号, 每个 mysql 服务 id 需唯一\nserver-id=1\n\n# mysql 服务端口号, 默认3306\nport=3306\n\n# mysql 安装目录, 默认 /usr\nbasedir=/opt/mysql/mysql-8.0\n\n# mysql 数据文件放置位置\ndatadir=/opt/mysql/data\n\n# 记录的是当前 mysqld 进程的 pid\npid-file=/opt/mysql/mysql-8.0/mysql.pid\n\n# 设置 socket 文件所在目录\nsocket=/opt/mysql/mysql-8.0/mysql.sock\n\n# 设置用来保存临时文件的目录\ntmpdir=/opt/mysql/mysql-8.0/tmp\n\n# 用户\nuser=mysql\n\n# 允许访问的 IP 网段(系统默认配置监听所有网卡, 即允许所有 IP 访问)\n# 生产环境下建议设置为: 127.0.0.1(只允许本机访问) 或某个网卡的 IP\nbind-address=0.0.0.0\n\n# 数据库默认字符集为 utf8, 并支持一些特殊表情符号(占用 4 个字节)\ncharacter-set-server=utf8mb4\n\n# 数据库字符集对应一些排序等规则, 注意要和 character-set-server 对应\ncollation-server=utf8mb4_general_ci\n\n# 是否对 sql 语句大小写敏感, 1 表示不敏感\nlower_case_table_names=1\n\n# 允许最大连接进程数\nmax_connections=400\n\n# 最大错误连接数, 这是为了防止有人从该主机试图攻击数据库系统\n# 如果某个用户发起的连接 error 超过该数值, 则该用户的下次连接将被阻塞, 直到管理员执行 flush hosts\nmax_connect_errors=100\n\n# TIMESTAMP 如果没有显示声明 NOT NULL, 允许 NULL 值\nexplicit_defaults_for_timestamp=true\n\n# SQL 数据包发送的大小, 如果有 BLOB 对象建议修改成 1G\nmax_allowed_packet=128M\n\n# MySQL连接闲置超过一定时间后(秒)将会被强行关闭\n# MySQL 默认的 wait_timeout 值为 8 个小时, interactive_timeout 参数需要同时配置才能生效\ninteractive_timeout=1800\nwait_timeout=1800\n\n# 内部内存临时表的最大值, 设置成 128M\n# 比如大数据量的 group by, order by 时可能用到临时表\n# 超过了这个值将写入磁盘, 系统 IO 压力增大\ntmp_table_size=128M\nmax_heap_table_size=128M\n\n# 数据库错误日志文件\nlog-error=/opt/mysql/mysql-8.0/err/mysqld.err\n\n# 数据库日志文件存放的位置(一般不会开启该功能, 因为 log 的量会非常庞大)\ngeneral_log_file=/opt/mysql/mysql-8.0/log/mysql.log\n# 日志文件是否开启(0 是关闭、1 是开启)\ngeneral_log=0\n\n[client]\n# 默认路径是在 /tmp/mysql.sock\n# 因为我们修改了默认的路径, 所以需要在 [client] 段再指定一下\n# 如果不指定, 虽然数据库能正常启动, 但使用 mysql 命令时还是会报找不到 mysql.sock 错误\nsocket=/opt/mysql/mysql-8.0/mysql.sock\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br></div></div><p>创建配置文件中所需的目录：</p>\n<div><pre><code><span>mkdir</span> /opt/mysql/mysql-8.0/err /opt/mysql/mysql-8.0/tmp\n<span>echo</span> <span>\"\"</span> <span>></span> /opt/mysql/mysql-8.0/err/mysqld.err\n<span># 新建了文件, 需要再次修改文件所有者</span>\n<span>chown</span> -R mysql:mysql /opt/mysql/\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"配置全局环境变量\"> 配置全局环境变量</h3>\n<p>MySQL 命令默认读取的是 <code>/usr/local/bin</code> 目录，由于我们修改了 MySQL 的默认安装路径。为了可直接使用 <code>mysql</code> 命令，而不用 <code>/opt/mysql/mysql-8.0/bin/mysql</code> 这样一大串，可以添加环境变量：</p>\n<div><pre><code><span>vim</span> /etc/profile\n</code></pre>\n<div><span>1</span><br></div></div><p>在最下面添加这两行代码：</p>\n<div><pre><code># MySQL\nexport PATH=$PATH:/opt/mysql/mysql-8.0/bin\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>保存文件后，执行刷新操作：</p>\n<div><pre><code><span>source</span> /etc/profile\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"启动-mysql-服务并修改密码\"> 启动 MySQL 服务并修改密码</h3>\n<div><pre><code><span># 启动 MySQL 服务</span>\n/opt/mysql/mysql-8.0/support-files/mysql.server start\n\n<span># 登录 root 用户, 记得输入之前默认生成的密码</span>\nmysql -uroot -p\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>通过下面这句代码就可直接修改密码，不用像之前的老版本一样那么复杂：</p>\n<div><pre><code><span># 两种改密方式二选一, 跟 5.7 版本的改密命令不同</span>\nALTER <span>USER</span> <span>'root'</span>@<span>'localhost'</span> IDENTIFIED WITH mysql_native_password BY <span>'新密码'</span><span>;</span>\n\n<span>set</span> password <span>for</span> root@localhost <span>=</span> <span>'新密码'</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>接着需要继续执行命令：</p>\n<div><pre><code>// 刷新权限\nflush privileges<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"开机自启配置\"> 开机自启配置</h3>\n<p>下面的命令是将服务文件拷贝到 <code>/etc/init.d/</code> 下，并重命名为 <code>mysqld</code>：</p>\n<div><pre><code><span>cp</span> /opt/mysql/mysql-8.0/support-files/mysql.server /etc/init.d/mysqld\n</code></pre>\n<div><span>1</span><br></div></div><p>赋予可执行权限：</p>\n<div><pre><code><span>chmod</span> +x /etc/init.d/mysqld\n</code></pre>\n<div><span>1</span><br></div></div><p>添加服务：</p>\n<div><pre><code><span>chkconfig</span> --add mysqld\n</code></pre>\n<div><span>1</span><br></div></div><p>显示服务列表：</p>\n<div><pre><code><span>chkconfig</span> --list\n</code></pre>\n<div><span>1</span><br></div></div><p>注：如果看到 mysqld 的服务，并且 3，4，5 都是 <code>on</code> 的话则成功，如果是 <code>off</code>，则：</p>\n<div><pre><code><span>chkconfig</span> --level <span>345</span> mysqld on\n</code></pre>\n<div><span>1</span><br></div></div><p>测试开机自启，重启电脑：</p>\n<div><pre><code><span>reboot</span>\n<span># 重启后查看 mysql 服务是否开机自启。</span>\n<span>ps</span> -ef <span>|</span> <span>grep</span> mysql\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>接下来可以通过一些命令操作 MySQL 服务：</p>\n<ul>\n<li>启动 MySQL 服务：<code>service mysql start</code></li>\n<li>停止 MySQL 服务：<code>service mysql stop</code></li>\n<li>查看错误日志（如果上面两个命令执行后没效果）：<code>systemctl status mysqld</code></li>\n</ul>\n<h3 id=\"开放远程连接\"> 开放远程连接</h3>\n<p>先通过 <code>mysql -uroot -p</code> 命令连接 MySQL，然后在 MySQL 窗口下执行如下命令：</p>\n<div><pre><code><span># 选择 mysql 这个数据库</span>\nuse mysql<span>;</span>\n<span># 查看原来数据, 方便修改以后重置回来</span>\n<span>select</span> host, user, authentication_string, plugin from user<span>;</span>\n<span># 修改值</span>\nupdate user <span>set</span> <span>host</span><span>=</span><span>'%'</span> where <span>user</span><span>=</span><span>'root'</span> limit <span>1</span><span>;</span>\n<span># 刷新权限</span>\nflush privileges<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>\n<ul>\n<li><code>root</code> 可以改为你自己定义的用户名。</li>\n<li><code>localhost</code> 指的是该用户开放的 IP，可以是 <code>localhost</code> 或 <code>127.0.0.1</code>（仅本机访问），可以是具体的某一 IP，也可以是 <code>%</code> （所有 IP 均可访问)。</li>\n<li><code>password</code> 是你想使用的验证密码。</li>\n</ul>\n</blockquote>\n<p>如果使用 Navicat 连接时报 <code>2003 - Can't connect to MySQL server on ...</code> 错误，就要先看下服务器是不是开启了防火墙但又没开放端口（你可以选择不开防火墙，或者开完防火墙后记得开放 MySQL 监听的端口号）。</p>\n<div><pre><code><span># 查看状态, 发现当前是 dead 状态, 即防火墙未开启</span>\nsystemctl status firewalld\n\n<span># 开启防火墙, 没有任何提示即开启成功</span>\n<span># 再次查看状态, 显示 running 即已开启了</span>\nsystemctl start firewalld\n\n<span># 开放默认端口号 3306, 提示 success, 表示设置成功</span>\nfirewall-cmd --permanent --zone<span>=</span>public --add-port<span>=</span><span>3306</span>/tcp\n\n<span># 修改后需要重新加载配置才生效</span>\nfirewall-cmd --reload<span>;</span>\n\n<span># 查看已经开放的端口</span>\nfirewall-cmd --permanent --list-port\n\n<span># 关闭默认的端口号 3306(如果需要的话, 执行这个命令就行了)</span>\nfirewall-cmd --permanent --zone<span>=</span>public --remove-port<span>=</span><span>3306</span>/tcp\n\n<span># 关闭防火墙(如果需要的话, 执行这个命令就行了)</span>\nsystemctl stop firewalld\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>另外，如果使用的是阿里云等云厂家的服务器，无法连接的原因可能是需要去云管理平台进行一些设置。大致的入口是：</p>\n<p>进入云服务管理控制平台 ——&gt; 进入云服务器 ——&gt; 选择实例 ——&gt; 管理。</p>\n<ul>\n<li>阿里云就找到：本实例安全组 --&gt; 配置规则 --&gt; 添加安全组规则，端口范围写 <code>3306/3306</code>，授权对象写 <code>0.0.0.0/0</code>。</li>\n<li>腾讯云就找到：防火墙 --&gt; 管理规则 --&gt; 添加规则，应用类型下拉框选择 MySQL(3306) 就可以了。</li>\n<li>如果改了 MySQL 的默认端口，或者想进行更多限制，或者是别的云服务商，稍微摸索下即可，这个没多少坑。</li>\n</ul>\n<h3 id=\"卸载-mysql-2\"> 卸载 MySQL</h3>\n<p>首先输入命令 <code>ps -ef | grep mysql</code> 检查一下 MySQL 服务是否在运行，在卸载之前需要先停止服务：</p>\n<div><pre><code><span>service</span> mysql stop\n</code></pre>\n<div><span>1</span><br></div></div><p>关闭并删除自启动脚本：</p>\n<div><pre><code><span>cd</span> /etc/init.d\n<span># 查看该服务进程状态</span>\n<span>chkconfig</span> --list mysqld\n<span># 删除 chkconfig 管理的 MySQL 启动服务</span>\n<span>chkconfig</span> --del /etc/init.d/mysqld\n<span># 删除自启动脚本</span>\n<span>rm</span> -rf /etc/init.d/mysqld\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>删除 MySQL 安装目录（如果是按照我上文的步骤安装， 删除安装目录的命令如下）：</p>\n<div><pre><code><span>rm</span> -rf /opt/mysql/\n</code></pre>\n<div><span>1</span><br></div></div><p>删除 MySQL 配置文件：</p>\n<div><pre><code><span>rm</span> /etc/my.cnf\n</code></pre>\n<div><span>1</span><br></div></div><p>删除环境变量：</p>\n<div><pre><code><span>vim</span> /etc/profile\n</code></pre>\n<div><span>1</span><br></div></div><p>删掉之前添加的 MySQL 相关的代码后，保存文件后，执行刷新操作：</p>\n<div><pre><code><span>source</span> /etc/profile\n</code></pre>\n<div><span>1</span><br></div></div><p>find 查找相关文件并删除：</p>\n<div><pre><code><span># 查找相关文件</span>\n<span>find</span> / -name mysql\n\n<span># 判断是否能删除后, 执行删除命令</span>\n<span>..</span>.\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>删除 mysql 用户和用户组：</p>\n<div><pre><code><span>id</span> mysql\n<span>userdel</span> -rf mysql\n<span>groupdel</span> mysql\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><blockquote>\n<p>注意：<code>-rf</code> 参数表示删除当前已登陆的用户，并删除与其相关的所有文件。</p>\n<p>慎用 <code>-r</code> 选项，如果用户目录下有重要文件，删除前请备份。</p>\n</blockquote>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://blog.51cto.com/luecsc/1953842\" target=\"_blank\" rel=\"noopener noreferrer\">那些你不知道的MySQL配置文件的坑</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-03-01T15:44:23.000Z",
      "date_modified": "2022-03-04T09:47:23.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Ngixn 配置文件详解",
      "url": "https://www.fedbook.cn/basic-skills/nginx/config-file-params-explanation/",
      "id": "https://www.fedbook.cn/basic-skills/nginx/config-file-params-explanation/",
      "content_html": "<h1 id=\"ngixn-配置文件详解\"> Ngixn 配置文件详解</h1>\n<p>本文基于 Nginx 1.18.0，介绍其配置文件 <code>nginx.conf</code> 的主要配置参数。</p>\n<h2 id=\"核心参数详解\"> 核心参数详解</h2>\n<div><pre><code>user  nginx nginx<span>;</span>                 <span># 指定 Nginx 服务运行的用户和用户组</span>\nworker_processes  <span>1</span><span>;</span>               <span># 定义 Nginx 的 worker 进程数，建议等于 CPU 总核心数</span>\n\n<span># 全局指定 Nginx 错误日志，定义类型，[ debug | info | notice | warn | error | crit ]</span>\n<span># 如果要关闭 error log，需要写成 error_log /dev/null;</span>\n<span># 而不是 error_log off; 否则错误日志会写到一个叫做 off 的文件中</span>\nerror_log  /var/log/nginx/error.log warn<span>;</span>\n\npid        /var/run/nginx.pid<span>;</span>     <span># 指定 Nginx PID 进程号文件</span>\n\n<span># 一个 Nginx 进程打开的最多文件描述符数目</span>\n<span># 理论值应该是最多打开文件数（系统的值 ulimit -n）与 Nginx 进程数相除</span>\n<span># 但是 Nginx 分配请求并不均匀，所以建议与 ulimit -n 的值保持一致</span>\nworker_rlimit_nofile <span>65535</span><span>;</span>\n\n<span># 工作模式与连接数上限</span>\nevents <span>{</span>\n    <span># 参考事件模型</span>\n    <span># use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]</span>\n    <span># epoll 模型是 Linux 2.6 以上版本内核中的高性能网络 I/O 模型</span>\n    <span># 如果跑在 FreeBSD 上面，就用 kqueue 模型</span>\n    use epoll<span>;</span>\n    <span># 单个进程最大连接数（最大连接数=连接数*进程数），默认值为 1024</span>\n    worker_connections  <span>65535</span><span>;</span>\n<span>}</span>\n\n<span># 设定 http 服务器</span>\nhttp <span>{</span>\n    <span># 文件扩展名与文件类型映射表</span>\n    <span># Nginx 会根据 mime.type 定义的对应关系来告诉浏览器如何处理当前返回的文件（打开或下载）</span>\n    include       mime.types<span>;</span>\n\n    <span># 当 Nginx 无法识别当前访问页面内容时（未定义的扩展名），默认触发下载动作</span>\n    <span># 浏览器访问到未定义的扩展名的时候，就默认为下载该文件</span>\n    <span># 如果将这个设置改成 default_type text/html; 即把所有未设置的扩展名当 HTML 文件打开</span>\n    default_type  application/octet-stream<span>;</span>\n\n    charset utf-8<span>;</span>                         <span># 默认编码</span>\n\n    <span># 服务器名字的 hash 表大小（看不懂的参数默认即可）</span>\n    server_names_hash_bucket_size <span>128</span><span>;</span>\n    <span># 客户端请求头部的缓冲区大小</span>\n    client_header_buffer_size 32k<span>;</span>\n    <span># 客户请求头缓冲大小</span>\n    <span># Nginx 默认会用 client_header_buffer_size 这个 buffer 来读取 header 值</span>\n    <span># 如果 header 过大，它会使用 large_client_header_buffers 来读取</span>\n    large_client_header_buffers <span>4</span> 64k<span>;</span>\n    <span># 设定通过 Nginx 上传文件的大小</span>\n    client_max_body_size 8m<span>;</span>\n\n    <span># 开启高效文件传输模式</span>\n    <span># sendfile 指令指定 Nginx 是否调用 sendfile 函数来输出文件</span>\n    <span># 对于普通应用设为 on，如果用来进行下载等应用磁盘 IO 重负载应用，可设置为 off，以平衡磁盘与网络 I/O 处理速度，降低系统的负载</span>\n    <span># 注意：如果图片显示不正常把这个改成 off</span>\n    sendfile on<span>;</span>\n    <span># 开启目录列表访问，适合下载服务器，默认关闭</span>\n    autoindex on<span>;</span>\n    <span># 防止网络阻塞：数据包会先累积到最大后一次性传输，可以最大化利用网络资源，但会有一点点延迟（默认开启）</span>\n    tcp_nopush on<span>;</span>\n    <span># 防止网络阻塞：小的数据包不等待直接传输（与 tcp_nopush 互斥，但两者可同为 on ，Nginx 会平衡这两个功能，默认开启）</span>\n    tcp_nodelay on<span>;</span>\n\n    keepalive_timeout <span>65</span><span>;</span>                  <span># 长连接超时时间，单位是秒</span>\n\n    <span># FastCGI 相关参数是为了改善网站的性能：减少资源占用，提高访问速度。</span>\n    <span># 参考1：https://blog.csdn.net/luozhonghua2014/article/details/37737823</span>\n    <span># 参考2：https://blog.51cto.com/blief/1739655</span>\n    fastcgi_connect_timeout <span>300</span><span>;</span>        <span># 连接到后端 fastcgi 超时时间（秒）</span>\n    fastcgi_send_timeout <span>300</span><span>;</span>           <span># 指 Nginx 进程向 fastcgi 进程发送 request 的整个过程的超时时间（秒）</span>\n    fastcgi_read_timeout <span>300</span><span>;</span>           <span># 指 fastcgi 进程向 Nginx 进程发送 response 的整个过程的超时时间（秒）</span>\n    fastcgi_buffer_size 64k<span>;</span>            <span># 读取 fastcgi 应答第一部分需要多大缓冲区</span>\n    fastcgi_buffers <span>4</span> 64k<span>;</span>              <span># 指定本地需要多少和多大的缓冲区来缓冲 fastcgi 应答请求</span>\n    fastcgi_busy_buffers_size 128k<span>;</span>     <span># 默认值是 fastcgi_buffer 的 2 倍</span>\n    fastcgi_temp_file_write_size 128k<span>;</span>  <span># 写入缓存文件使用多大的数据块，默认值是 fastcgi_buffer 的 2 倍</span>\n\n    <span># gzip 模块设置</span>\n    <span>gzip</span> on<span>;</span>                               <span># 开启 gzip 压缩输出</span>\n    gzip_min_length 1k<span>;</span>                    <span># 最小压缩文件大小</span>\n    gzip_buffers <span>4</span> 16k<span>;</span>                    <span># 压缩缓冲区</span>\n    gzip_http_version <span>1.0</span><span>;</span>                 <span># 压缩版本（默认 1.1，前端如果是 squid2.5 请使用 1.0）</span>\n    gzip_comp_level <span>2</span><span>;</span>                     <span># 压缩等级</span>\n    <span># 压缩类型，默认就已经包含 text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个 warn</span>\n    <span># 图片压缩：建议不对 gif、jpge 等图片进行压缩，因为其压缩比例极低，反而耗费 CPU，但 bmp 可以压缩，因为 bmp 压缩比例较大</span>\n    <span># 字体压缩：只需要为 ttf、otf 和 svg 字体启用 gzip，对其他字体格式进行 gzip 压缩时效果不明显</span>\n    <span># 参考：https://blog.csdn.net/liupeifeng3514/article/details/79018334</span>\n    gzip_types text/plain application/x-javascript text/css application/xml<span>;</span>\n    gzip_vary on<span>;</span>                          <span># 是否在 http header 中添加 Vary: Accept-Encoding，建议开启</span>\n    <span># limit_zone crawler $binary_remote_addr 10m;    # 开启限制 IP 连接数的时候需要使用</span>\n\n    <span># upstream 的负载均衡，weight 是权重，可以根据机器配置定义权重</span>\n    <span># weigth 参数表示权值，权值越高被分配到的几率越大</span>\n    <span># Nginx 的 upstream 目前支持 4 种方式的分配，这里演示一种，后面章节会分别演示</span>\n    upstream www.baidu.com <span>{</span>\n        server <span>192.168</span>.80.121:80 <span>weight</span><span>=</span><span>3</span><span>;</span>\n        server <span>192.168</span>.80.122:80 <span>weight</span><span>=</span><span>2</span><span>;</span>\n        server <span>192.168</span>.80.123:80 <span>weight</span><span>=</span><span>3</span><span>;</span>\n    <span>}</span>\n\n    <span># 全局指定 Nginx 访问日志的格式</span>\n    log_format  main  <span>'$remote_addr - $remote_user [$time_local] \"$request\" '</span>\n                      <span>'$status $body_bytes_sent \"$http_referer\" '</span>\n                      <span>'\"$http_user_agent\" \"$http_x_forwarded_for\"'</span><span>;</span>\n    <span># 全局定义 Nginx 访问日志的位置</span>\n    access_log  logs/access.log  main<span>;</span>\n    <span># 一般上面两个不配置，只设置 access_log off; 然后在需要的 server 下配置日志</span>\n    <span># 这么做可以避免日志产生过大（如果 http 和 server 都不配置，默认会写入 logs/access.log）</span>\n    access_log  off<span>;</span>\n\n    <span># 虚拟主机的配置，一个 server 配置段一般对应一个域名</span>\n    <span># 在实际生产中一般会将这部分拆出来形成子配置文件，后面的章节会讲</span>\n    server <span>{</span>\n        listen       <span>80</span><span>;</span>                     <span># 指定监听端口</span>\n        server_name  www.baidu.com<span>;</span>          <span># 指定当前网站的访问域名</span>\n\n        location / <span>{</span>\n            root   html<span>;</span>                     <span># 指定代码位置</span>\n            index  index.html index.htm<span>;</span>     <span># 指定首页文件</span>\n        <span>}</span>\n\n        <span>#  定义 404 错误页面，如果是 404 错误，则把站点根目录下的 404.html 返回给用户 </span>\n        error_page  <span>404</span>                    /404.html<span>;</span>\n        <span>#  定义 50x 错误页面，可以配合 location 使用，用 location 调用实际的错误页面</span>\n        error_page      <span>500</span> <span>502</span> <span>503</span> <span>504</span>    /50x.html<span>;</span>\n        location <span>=</span> /50x.html <span>{</span> \n            root  /usr/share/nginx/html<span>;</span> \n        <span>}</span> \n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br></div></div><h2 id=\"全局日志的关闭\"> 全局日志的关闭</h2>\n<p>为了避免日志产生过大，也是处于模块化的思想，我们一般不在全局中（http 中）指定日志格式和输出位置，而是在子配置文件中（每个 server 中）单独配置。</p>\n<p>但是如果 http 和 server 都不配置，默认会写入 <code>logs/access.log</code>，即全局的形式。所以需要关闭全局日志。</p>\n<p>网上很多博客中展示的都是错误示例，这里演示正确的关闭方式，包括 <code>error_log</code> 和 <code>access_log</code>：</p>\n<div><pre><code><span># 错误示例，会产生名字为 off/on 的日志文件</span>\nerror_log off<span>;</span>\naccess_log on<span>;</span>\n\n正确关闭方式\nerror_log /dev/null<span>;</span>\naccess_log off<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"日志-log-format-可选项\"> 日志 log_format 可选项</h2>\n<p>默认格式：</p>\n<div><pre><code>log_format  main  <span>'$remote_addr - $remote_user [$time_local] \"$request\" '</span>\n                  <span>'$status $body_bytes_sent \"$http_referer\" '</span>\n                  <span>'\"$http_user_agent\" \"$http_x_forwarded_for\"'</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>参数释义表：</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$remote_addr</td>\n<td>客户端地址</td>\n</tr>\n<tr>\n<td>$remote_user</td>\n<td>客户端用户名称</td>\n</tr>\n<tr>\n<td>$time_local</td>\n<td>访问时间和时区</td>\n</tr>\n<tr>\n<td>$request</td>\n<td>请求的 URI 和 HTTP 协议</td>\n</tr>\n<tr>\n<td>$http_host</td>\n<td>请求地址，即浏览器中你输入的地址（IP 或域名）</td>\n</tr>\n<tr>\n<td>$status</td>\n<td>HTTP 请求状态</td>\n</tr>\n<tr>\n<td>$upstream_status</td>\n<td>upstream 状态</td>\n</tr>\n<tr>\n<td>$body_bytes_sent</td>\n<td>发送给客户端文件内容大小</td>\n</tr>\n<tr>\n<td>$http_referer</td>\n<td>url 跳转来源</td>\n</tr>\n<tr>\n<td>$http_user_agent</td>\n<td>用户终端浏览器等信息</td>\n</tr>\n<tr>\n<td>$ssl_protocol</td>\n<td>SSL协议版本</td>\n</tr>\n<tr>\n<td>$ssl_cipher</td>\n<td>交换数据中的算法</td>\n</tr>\n<tr>\n<td>$upstream_addr</td>\n<td>后台 upstream 的地址，即真正提供服务的主机地址</td>\n</tr>\n<tr>\n<td>$request_time</td>\n<td>整个请求的总时间</td>\n</tr>\n<tr>\n<td>$upstream_response_time</td>\n<td>请求过程中，upstream 响应时间</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"http、server、location-之间的关系\"> http、server、location 之间的关系</h2>\n<ul>\n<li>http：主要用于解决用户请求中的报文信息</li>\n<li>server：用于配置一个具体的网站响应操作</li>\n<li>location：用于匹配 uri</li>\n</ul>\n<p>由上至下是包含关系。</p>\n<h2 id=\"更多其它参数\"> 更多其它参数</h2>\n<p>server 中的参数配置项其实有很多，它们可以实现一些丰富的功能。上面只列举了最基础的几个参数，后面的章节会单独讲解如何配置来实现各种功能。</p>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://www.nginx.com/resources/wiki/start/topics/examples/full/\" title=\"Full Example Configuration\" target=\"_blank\" rel=\"noopener noreferrer\">Full Example Configuration</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-07-03T09:53:33.000Z",
      "date_modified": "2021-07-06T15:53:47.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Ngixn 配置文件模板",
      "url": "https://www.fedbook.cn/basic-skills/nginx/config-file-generic-template/",
      "id": "https://www.fedbook.cn/basic-skills/nginx/config-file-generic-template/",
      "content_html": "<h1 id=\"ngixn-配置文件模板\"> Ngixn 配置文件模板</h1>\n<p>本文基于 Nginx 1.18.0，整理一份配置文件 nginx.conf 的通用模板。</p>\n<h2 id=\"模块拆分\"> 模块拆分</h2>\n<p>当项目或业务越来越多的时候，Nginx 的配置文件 nginx.conf 会越来越大和复杂，不便于管理，所以需要拆分出多个子配置文件。</p>\n<p>以下命令，如果你是 root 账户，直接执行即可，不是的话前面加 <code>sudo</code> 获取权限。</p>\n<p>首先建立子配置文件目录：</p>\n<div><pre><code><span>cd</span> /usr/local/nginx/conf\n<span>mkdir</span> vhosts\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>然后在 nginx.conf 中使用 <code>include</code> 引入文件：</p>\n<div><pre><code>http <span>{</span>\n    <span>..</span>.\n\n    include /usr/local/nginx/conf/vhosts/*.conf<span>;</span>   <span># *.conf 代表所有 server 配置文件</span>\n    include /usr/local/nginx/conf/vhosts/*.proxy<span>;</span>  <span># *.proxy 代表所有做反向代理的 server（看情况可选）</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>最后把 server 模块移入子配置文件中：</p>\n<div><pre><code><span># web.conf</span>\nserver<span>{</span>   \n    listen <span>80</span><span>;</span>\n    server_name localhost<span>;</span>\n    <span>..</span>.\n<span>}</span>\n\n<span># api.conf</span>\nserver<span>{</span>   \n    listen <span>81</span><span>;</span>\n    server_name localhost<span>;</span>\n    <span>..</span>.\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>此时的 Nginx 文件目录结构：</p>\n<div><pre><code>├── nginx\n    │── html\n    │── logs\n    │── sbin\n    │── <span>..</span>.\n    └── conf\n        ├── <span>..</span>.\n        ├── nginx.conf         <span># 主配置文件</span>\n        └── vhosts             <span># 子配置文件的目录</span>\n            ├── web.conf       <span># 子配置文件 1</span>\n            └── api.conf       <span># 子配置文件 2</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>思路就是上面介绍的这样，下面是实际生产环境中的通用模板。</p>\n<h2 id=\"主配置文件\"> 主配置文件</h2>\n<p>我在这份主配置文件中仅设置了几个核心参数，如果有特定需求可自行定制，如下所示：</p>\n<div><pre><code>user  nginx nginx<span>;</span>\nworker_processes  <span>1</span><span>;</span>\n\nerror_log  /var/log/nginx/error.log crit<span>;</span>\n\npid        /var/run/nginx.pid<span>;</span>\n\nevents <span>{</span>\n    worker_connections  <span>1024</span><span>;</span>\n<span>}</span>\n\nhttp <span>{</span>\n    include       mime.types<span>;</span>\n    default_type  application/octet-stream<span>;</span>\n\n    charset utf-8<span>;</span>\n\n    access_log  off<span>;</span>\n\n    sendfile        on<span>;</span>\n    tcp_nopush     on<span>;</span>\n    tcp_nodelay on<span>;</span>\n\n    keepalive_timeout  <span>65</span><span>;</span>\n\n    fastcgi_connect_timeout <span>300</span><span>;</span>\n    fastcgi_send_timeout <span>300</span><span>;</span>\n    fastcgi_read_timeout <span>300</span><span>;</span>\n    fastcgi_buffer_size 64k<span>;</span>\n    fastcgi_buffers <span>4</span> 64k<span>;</span>\n    fastcgi_busy_buffers_size 128k<span>;</span>\n    fastcgi_temp_file_write_size 128k<span>;</span>\n\n    <span>gzip</span> on<span>;</span>\n    gzip_min_length 1k<span>;</span>\n    gzip_buffers <span>4</span> 16k<span>;</span>\n    gzip_http_version <span>1.0</span><span>;</span>\n    gzip_comp_level <span>2</span><span>;</span>\n    gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/bmp application/x-bmp image/x-ms-bmp application/vnd.ms-fontobject font/ttf font/opentype font/x-woff<span>;</span>\n    gzip_vary on<span>;</span>\n    <span># limit_zone crawler $binary_remote_addr 10m;    # 开启限制 IP 连接数的时候需要使用</span>\n\n    log_format  main  <span>'$remote_addr - $remote_user [$time_local] \"$request\" '</span>\n                      <span>'$status $body_bytes_sent \"$http_referer\" '</span>\n                      <span>'\"$http_user_agent\" \"$http_x_forwarded_for\"'</span><span>;</span>\n\n    include /usr/local/nginx/conf/vhosts/*.conf<span>;</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><h2 id=\"子配置文件\"> 子配置文件</h2>\n<p>首先别忘了创建文件夹：</p>\n<div><pre><code><span>cd</span> /usr/local/nginx/conf\n<span>mkdir</span> vhosts\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>在该文件夹下所有以 <code>.conf</code> 结尾的文件都是子配置文件，在主配置文件的末尾被 <code>include</code> 引入了。</p>\n<p>这里只做一份最基础的子配置文件（server 部分）模板，实现一个静态网站的部署配置。</p>\n<div><pre><code>server <span>{</span>\n    listen <span>80</span><span>;</span>\n    server_name  www.fedbook.cn fedbook.cn<span>;</span>\n\n    root /sites/fedbook<span>;</span>\n    index index.html<span>;</span>\n\n    location / <span>{</span>\n        try_files <span>$uri</span> <span>$uri</span>/ /index.html<span>;</span>\n    <span>}</span>\n\n    location ~* <span>\\</span>.<span>(</span>html<span>|</span>htm<span>)</span>$ <span>{</span>\n        expires 24h<span>;</span>\n        add_header Cache-Control <span>\"public\"</span><span>;</span>\n    <span>}</span>\n    \n    location ~* <span>\\</span>.<span>(</span>css<span>|</span>js<span>|</span>jpg<span>|</span>jpeg<span>|</span>gif<span>|</span>png<span>|</span>ico<span>|</span>cur<span>|</span>gz<span>|</span>svg<span>|</span>svgz<span>|</span>map<span>|</span>mp4<span>|</span>ogg<span>|</span>ogv<span>|</span>webm<span>|</span>htc<span>)</span>$ <span>{</span>\n        expires 24h<span>;</span>\n        access_log off<span>;</span>\n        add_header Cache-Control <span>\"public\"</span><span>;</span>\n    <span>}</span>\n\n    access_log  /var/log/nginx/access/fedbook.log<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>上面配置文件我们指定了这个子模块的日志输出路径，所以需要创建该路径的文件夹，否则在写入日志时会因文件夹不存在而报错：</p>\n<div><pre><code><span>mkdir</span> -p /var/log/nginx/access/\n</code></pre>\n<div><span>1</span><br></div></div><p>检查 Nginx 配置文件的正确性：</p>\n<div><pre><code>/usr/local/nginx/sbin/nginx -t\n</code></pre>\n<div><span>1</span><br></div></div><p>最后重新加载 Nginx 配置即可上线该静态网站：</p>\n<div><pre><code><span># 如果已将 Nginx 加入开机自启（有 Nginx 开机自启脚本）</span>\n/etc/init.d/nginx reload\n\n<span># 如果未将 Nginx 加入开机自启</span>\n/usr/local/nginx/sbin/nginx -s reload\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>对于如何配置来实现更多强大的功能，会在后面章节一一展开介绍。</p>\n<p>（完）</p>\n",
      "date_published": "2021-07-06T15:54:35.000Z",
      "date_modified": "2021-12-03T07:01:56.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "解决 vim 中文乱码问题",
      "url": "https://www.fedbook.cn/basic-skills/linux/solution-to-vim-encoding/",
      "id": "https://www.fedbook.cn/basic-skills/linux/solution-to-vim-encoding/",
      "content_html": "<h1 id=\"解决-vim-中文乱码问题\"> 解决 vim 中文乱码问题</h1>\n<h2 id=\"问题描述\"> 问题描述</h2>\n<p>Windows 下中文字符显示正常、且是 utf-8 编码的文本，上传到 Linux 环境后用 vim 打开发现中文字符都是乱码。</p>\n<h2 id=\"解决方案\"> 解决方案</h2>\n<p>打开 vim 配置文件：<code>/etc/vim/vimrc</code>（Ubuntu）或 <code>/etc/vimrc</code>（CentOS），末尾添加：</p>\n<div><pre><code><span>set</span> <span>fileencodings</span><span>=</span>utf-8,gb2312,gb18030,gbk,ucs-bom,cp936,latin1\n<span>set</span> <span>termencoding</span><span>=</span>utf-8\n<span>set</span> <span>fileformats</span><span>=</span>unix\n<span>set</span> <span>encoding</span><span>=</span>utf-8\n<span>set</span> <span>fileencoding</span><span>=</span>utf-8\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>说明：</p>\n<ul>\n<li><strong>set fileencodings</strong>：设置 vim 支持的文件编码类项\n<ul>\n<li>vim 启动时会按照它所列出的字符编码逐一探测即将打开的文件的字符编码方式，并且将 fileencoding 设置为最终探测到的字符编码方式</li>\n<li>因此最好将 Unicode 编码方式放到这个列表的最前面，将拉丁语系编码方式 latin1 放到最后面</li>\n</ul>\n</li>\n<li><strong>set termencoding</strong>：设置 vim 所工作的终端（或者 Windows 的 Console 窗口）的字符编码方式</li>\n<li><strong>set fileformats</strong>：设置文件格式为 unix 格式（主要是解决 dos 与 unix 换行符不同的问题）</li>\n<li><strong>set encoding</strong>：设置 vim 内部使用的字符编码方式（包括 vim 的 buffer-缓冲区、菜单文本、消息文本等）</li>\n<li><strong>set fileencoding</strong>：设置用 vim 编辑的文件保存时的编码方式（不管是否新文件都如此）</li>\n</ul>\n<h2 id=\"自定义-vimrc\"> 自定义 vimrc</h2>\n<p>vim 配置文件一般有两份，属于 root 的 <code>/etc/vim/vimrc</code> 和属于当前用户的 <code>~/.vimrc</code>，两者都可以配置 vim，而当两者配置信息有冲突时，以后者为准。</p>\n<p>也就是我们可以在不影响全局配置的情况下，做一份自己习惯的 vim 个性化设置。</p>\n<p>当前用户自身的 vim 配置文件预设不存在，需要手动建立，操作如下：</p>\n<div><pre><code><span>vim</span> ~/.vimrc\n</code></pre>\n<div><span>1</span><br></div></div><p>参考配置如下（注意双引号 <code>&quot;</code> 是注释符号，不要用错注释符号了）：</p>\n<div><pre><code><span>\" vimrc配置文件内容如下:\n \n\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\" \n\"</span> 一般设定 \n<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\" \n<span>\" 设定默认解码 \nset fenc=utf-8 \nset fencs=utf-8,usc-bom,euc-jp,gb18030,gbk,gb2312,cp936 \n \n\"</span> 不要使用vi的键盘模式，而是vim自己的 \n<span>set</span> nocompatible \n \n<span>\" history文件中需要记录的行数 \nset history=100 \n \n\"</span> 在处理未保存或只读文件的时候，弹出确认 \n<span>set</span> confirm \n \n<span>\" 与windows共享剪贴板 \nset clipboard+=unnamed \n \n\"</span> 侦测文件类型 \nfiletype on \n \n<span>\" 智能补全\nset completeopt=longest,menu\n \n\"</span> 载入文件类型插件 \nfiletype plugin on \n \n<span>\" 为特定文件类型载入相关缩进文件 \nfiletype indent on \n \n\"</span> 保存全局变量 \n<span>set</span> <span>viminfo</span><span>+=</span><span>!</span> \n \n<span>\" 带有如下符号的单词不要被换行分割 \nset iskeyword+=_,$,@,%,#,- \n \n\"</span> 语法高亮 \nsyntax <span>enable</span>\nsyntax on \n \n<span>\" 高亮字符，让其不受100列限制 \n:highlight OverLength ctermbg=red ctermfg=white guibg=red guifg=white \n:match OverLength '\\%101v.*' \n \n\"</span> 状态行颜色 \nhighlight StatusLine <span>guifg</span><span>=</span>SlateBlue <span>guibg</span><span>=</span>Yellow \nhighlight StatusLineNC <span>guifg</span><span>=</span>Gray <span>guibg</span><span>=</span>White \n \n<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\" \n<span>\" 文件设置 \n\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\" \n\"</span> 不要备份文件（根据自己需要取舍） \n<span>set</span> nobackup \n \n<span>\" 不要生成swap文件，当buffer被丢弃的时候隐藏它 \nsetlocal noswapfile \nset bufhidden=hide \n \n\"</span> 字符间插入的像素行数目 \n<span>set</span> <span>linespace</span><span>=</span><span>0</span> \n \n<span>\" 增强模式中的命令行自动完成操作 \nset wildmenu \n \n\"</span> 在状态行上显示光标所在位置的行号和列号 \n<span>set</span> ruler \n<span>set</span> <span>rulerformat</span><span>=</span>%20<span>(</span>%2*%<span>&lt;</span>%f%<span>=</span><span>\\</span> %m%r<span>\\</span> %3l<span>\\</span> %c<span>\\</span> %p%%%<span>)</span> \n \n<span>\" 命令行（在状态行下）的高度，默认为1，这里是2 \nset cmdheight=2 \n \n\"</span> 使回格键（backspace）正常处理indent, eol, start等 \n<span>set</span> <span>backspace</span><span>=</span><span>2</span> \n \n<span>\" 允许backspace和光标键跨越行边界 \nset whichwrap+=&lt;,>,h,l \n \n\"</span> 可以在buffer的任何地方使用鼠标（类似office中在工作区双击鼠标定位） \n<span>set</span> <span>mouse</span><span>=</span>a \n<span>set</span> <span>selection</span><span>=</span>exclusive \n<span>set</span> <span>selectmode</span><span>=</span>mouse,key \n \n<span>\" 启动的时候不显示那个援助索马里儿童的提示 \nset shortmess=atI \n \n\"</span> 通过使用: commands命令，告诉我们文件的哪一行被改变过 \n<span>set</span> <span>report</span><span>=</span><span>0</span> \n \n<span>\" 不让vim发出讨厌的滴滴声 \nset noerrorbells \n \n\"</span> 在被分割的窗口间显示空白，便于阅读 \n<span>set</span> <span>fillchars</span><span>=</span>vert:<span>\\</span> ,stl:<span>\\</span> ,stlnc:<span>\\</span> \n \n<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\" \n<span>\" 搜索和匹配 \n\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\" \n\"</span> 高亮显示匹配的括号 \n<span>set</span> showmatch \n \n<span>\" 匹配括号高亮的时间（单位是十分之一秒） \nset matchtime=5 \n \n\"</span> 在搜索的时候忽略大小写 \n<span>set</span> ignorecase \n \n<span>\" 不要高亮被搜索的句子（phrases） \nset nohlsearch \n \n\"</span> 在搜索时，输入的词句的逐字符高亮（类似firefox的搜索） \n<span>set</span> incsearch \n \n<span>\" 输入:set list命令是应该显示些啥？ \nset listchars=tab:\\|\\ ,trail:.,extends:>,precedes:&lt;,eol:$ \n \n\"</span> 光标移动到buffer的顶部和底部时保持3行距离 \n<span>set</span> <span>scrolloff</span><span>=</span><span>3</span> \n \n<span>\" 不要闪烁 \nset novisualbell \n \n\"</span> 我的状态行显示的内容（包括文件类型和解码） \n<span>set</span> <span>statusline</span><span>=</span>%F%m%r%h%w<span>\\</span><span>[</span>POS<span>=</span>%l,%v<span>]</span><span>[</span>%p%%<span>]</span><span>\\</span>%<span>{</span>strftime<span>(</span><span>\\</span>\"%d/%m/%y<span>\\</span> -<span>\\</span> %H:%M<span>\\</span>\"<span>)</span><span>}</span> \n \n<span>\" 总是显示状态行 \nset laststatus=2 \n \n\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\" \n\"</span> 文本格式和排版 \n<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\" \n<span>\" 自动格式化 \nset formatoptions=tcrqn \n \n\"</span> 继承前一行的缩进方式，特别适用于多行注释 \n<span>set</span> autoindent \n \n<span>\" 为C程序提供自动缩进 \nset smartindent \n \n\"</span> 使用C样式的缩进 \n<span>set</span> cindent \n \n<span>\" 制表符为4 \nset tabstop=4 \n \n\"</span> 统一缩进为4 \n<span>set</span> <span>softtabstop</span><span>=</span><span>4</span> \n<span>set</span> <span>shiftwidth</span><span>=</span><span>4</span> \n \n<span>\" 不要用空格代替制表符 \nset noexpandtab \n \n\"</span> 不要换行 \n<span>set</span> nowrap \n \n<span>\" 在行和段开始处使用制表符 \nset smarttab \n \n\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\" \n\"</span> CTags的设定 \n<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\" \n<span>\" 按照名称排序 \nlet Tlist_Sort_Type = \"</span>name<span>\" \n \n\"</span> 在右侧显示窗口 \n<span>let</span> Tlist_Use_Right_Window <span>=</span> <span>1</span> \n \n<span>\" 压缩方式 \nlet Tlist_Compart_Format = 1 \n \n\"</span> 如果只有一个buffer，kill窗口也kill掉buffer \n<span>let</span> Tlist_Exist_OnlyWindow <span>=</span> <span>1</span> \n \n<span>\" 不要关闭其他文件的tags \nlet Tlist_File_Fold_Auto_Close = 0 \n \n\"</span> 不要显示折叠树 \n<span>let</span> Tlist_Enable_Fold_Column <span>=</span> <span>0</span> \n<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"\n<span>\" 新文件标题\n\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\n\"</span> 定义函数SetTitle，自动插入文件头 \nfunc SetTitle<span>(</span><span>)</span> \n\t<span>\" 如果文件类型为.sh文件 \n\tif &amp;filetype == 'sh' \n\t\tcall setline(1, \"</span>#<span>#########################################################################\") </span>\n\t\tcall append<span>(</span>line<span>(</span><span>\".\"</span><span>)</span>, <span>\"# File Name: \"</span>.expand<span>(</span><span>\"%\"</span><span>))</span> \n\t\tcall append<span>(</span>line<span>(</span><span>\".\"</span><span>)</span>+1, <span>\"# Author: kadoop\"</span><span>)</span> \n\t\tcall append<span>(</span>line<span>(</span><span>\".\"</span><span>)</span>+2, <span>\"# mail: kadoop@163.com\"</span><span>)</span> \n\t\tcall append<span>(</span>line<span>(</span><span>\".\"</span><span>)</span>+3, <span>\"# Created Time: \"</span>.strftime<span>(</span><span>\"%c\"</span><span>))</span> \n\t\tcall append<span>(</span>line<span>(</span><span>\".\"</span><span>)</span>+4, <span>\"#########################################################################\"</span><span>)</span> \n\t\tcall append<span>(</span>line<span>(</span><span>\".\"</span><span>)</span>+5, <span>\"#!/bin/zsh\"</span><span>)</span>\n\t\tcall append<span>(</span>line<span>(</span><span>\".\"</span><span>)</span>+6, <span>\"PATH=/home/edison/bin:/home/edison/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/work/tools/gcc-3.4.5-glibc-2.3.6/bin\"</span><span>)</span>\n\t\tcall append<span>(</span>line<span>(</span><span>\".\"</span><span>)</span>+7, <span>\"export PATH\"</span><span>)</span>\n\t\tcall append<span>(</span>line<span>(</span><span>\".\"</span><span>)</span>+8, <span>\"\"</span><span>)</span>\n\t<span>else</span> \n\t\tcall setline<span>(</span><span>1</span>, <span>\"/*************************************************************************\"</span><span>)</span> \n\t\tcall append<span>(</span>line<span>(</span><span>\".\"</span><span>)</span>, <span>\"\t> File Name: \"</span>.expand<span>(</span><span>\"%\"</span><span>))</span> \n\t\tcall append<span>(</span>line<span>(</span><span>\".\"</span><span>)</span>+1, <span>\"\t> Author: kadoop\"</span><span>)</span> \n\t\tcall append<span>(</span>line<span>(</span><span>\".\"</span><span>)</span>+2, <span>\"\t> Mail: kadoop@163.com\"</span><span>)</span> \n\t\tcall append<span>(</span>line<span>(</span><span>\".\"</span><span>)</span>+3, <span>\"\t> Created Time: \"</span>.strftime<span>(</span><span>\"%c\"</span><span>))</span> \n\t\tcall append<span>(</span>line<span>(</span><span>\".\"</span><span>)</span>+4, <span>\" ************************************************************************/\"</span><span>)</span> \n\t\tcall append<span>(</span>line<span>(</span><span>\".\"</span><span>)</span>+5, <span>\"\"</span><span>)</span>\n\tendif\n\t<span>if</span> <span>&amp;</span>filetype <span>==</span> <span>'cpp'</span>\n\t\tcall append<span>(</span>line<span>(</span><span>\".\"</span><span>)</span>+6, <span>\"#include&lt;iostream>\"</span><span>)</span>\n    \tcall append<span>(</span>line<span>(</span><span>\".\"</span><span>)</span>+7, <span>\"using namespace std;\"</span><span>)</span>\n\t\tcall append<span>(</span>line<span>(</span><span>\".\"</span><span>)</span>+8, <span>\"\"</span><span>)</span>\n\tendif\n\t<span>if</span> <span>&amp;</span>filetype <span>==</span> <span>'c'</span>\n\t\tcall append<span>(</span>line<span>(</span><span>\".\"</span><span>)</span>+6, <span>\"#include&lt;stdio.h>\"</span><span>)</span>\n\t\tcall append<span>(</span>line<span>(</span><span>\".\"</span><span>)</span>+7, <span>\"\"</span><span>)</span>\n\tendif\n\t<span>\"\tif &amp;filetype == 'java'\n\t\"</span>\t\tcall append<span>(</span>line<span>(</span><span>\".\"</span><span>)</span>+6,<span>\"public class \"</span>.expand<span>(</span><span>\"%\"</span><span>))</span>\n\t<span>\"\t\tcall append(line(\"</span><span>.</span><span>\")+7,\"</span>\"<span>)</span>\n\t<span>\"\tendif\n\t\"</span> 新建文件后，自动定位到文件末尾\n\tautocmd BufNewFile * normal G\nendfunc\n \n<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\" \n<span>\" Autocommands \n\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\"\"</span>\"<span>\" \n\"</span> 只在下列文件类型被侦测到的时候显示行号，普通文本文件不显示 \n \n<span>if</span> has<span>(</span><span>\"autocmd\"</span><span>)</span> \nautocmd FileType xml,html,c,cs,java,perl,shell,bash,cpp,python,vim,php,ruby <span>set</span> number \nautocmd FileType xml,html vmap <span>&lt;</span>C-o<span>></span> <span>&lt;</span>ESC<span>></span><span>'&lt;i&lt;!--&lt;ESC>o&lt;ESC>'</span><span>></span>o--<span>></span> \nautocmd FileType java,c,cpp,cs vmap <span>&lt;</span>C-o<span>></span> <span>&lt;</span>ESC<span>></span><span>'&lt;o \nautocmd FileType html,text,php,vim,c,java,xml,bash,shell,perl,python setlocal textwidth=100 \n\" autocmd Filetype html,xml,xsl source $VIMRUNTIME/plugin/closetag.vim \nautocmd BufReadPost * \n\\ if line(\"'</span><span>\\</span>\"<span>\") > 0 &amp;&amp; line(\"</span><span>'\\\"\") &lt;= line(\"$\") | \n\\ exe \" normal g`\\\"\" | \n\\ endif \nendif \"has(\"autocmd\") \n \n\" F5编译和运行C程序，F6编译和运行C++程序 \n\" 请注意，下述代码在windows下使用会报错 \n\" 需要去掉./这两个字符 \n \n\" C的编译和运行 \nmap &lt;F5> :call CompileRunGcc()&lt;CR> \nfunc! CompileRunGcc() \nexec \"w\" \nexec \"!gcc % -o %&lt;\" \nexec \"! ./%&lt;\" \nendfunc \n \n\" C++的编译和运行 \nmap &lt;F6> :call CompileRunGpp()&lt;CR> \nfunc! CompileRunGpp() \nexec \"w\" \nexec \"!g++ % -o %&lt;\" \nexec \"! ./%&lt;\" \nendfunc \n \n\" 能够漂亮地显示.NFO文件 \nset encoding=utf-8 \nfunction! SetFileEncodings(encodings) \nlet b:myfileencodingsbak=&amp;fileencodings \nlet &amp;fileencodings=a:encodings \nendfunction \nfunction! RestoreFileEncodings() \nlet &amp;fileencodings=b:myfileencodingsbak \nunlet b:myfileencodingsbak \nendfunction \n \nau BufReadPre *.nfo call SetFileEncodings('</span>cp437<span>')|set ambiwidth=single au BufReadPost *.nfo call RestoreFileEncodings() \n \n\" 高亮显示普通txt文件（需要txt.vim脚本） \nau BufRead,BufNewFile * setfiletype txt \n \n\" 用空格键来开关折叠 \n\" set foldenable \n\" set foldmethod=manual \n\" nnoremap &lt;space> @=((foldclosed(line('</span><span>.</span><span>')) &lt; 0) ? '</span>zc<span>':'</span>zo<span>')&lt;CR> \n \n\" minibufexpl插件的一般设置 \nlet g:miniBufExplMapWindowNavVim = 1 \nlet g:miniBufExplMapWindowNavArrows = 1 \nlet g:miniBufExplMapCTabSwitchBufs = 1 \nlet g:miniBufExplModSelTarget = 1\n\" 配色方案\ncolorscheme desert\n\" Taglist 配置\nlet Tlist_Show_One_File=1\nlet Tlist_Exit_OnlyWindow=1\n\" winmanager 配置\nmap wm :WMToggle&lt;cr>\nlet g:winManagerWindowLayout='</span>FileExplorer<span>|</span>TagList'\n<span>\" cscope 配置\nif has(\"</span>cscope<span>\")\n   set csprg=/usr/bin/cscope\n   set csto=0\n   set cst\n   set nocsverb\n   \"</span> <span>add</span> any database <span>in</span> current directory\n   <span>if</span> filereadable<span>(</span><span>\"cscope.out\"</span><span>)</span>\n       cs <span>add</span> cscope.out\n        <span>\" else add database pointed to by environment\n   elseif <span>$CSCOPE_DB</span> != \"</span>\"\n       cs <span>add</span> <span>$CSCOPE_DB</span>\n   endif\n   <span>set</span> csverb\nendif\n \n<span>\" cscope  快捷键\nnmap&lt;leader>sa :csadd cscope.out&lt;cr>\nnmap&lt;leader>ss :cs find s&lt;C-R>=expand(\"</span><span>&lt;</span>cword<span>></span><span>\")&lt;cr>&lt;cr>\nnmap&lt;leader>sg :cs find g &lt;C-R>=expand(\"</span><span>&lt;</span>cword<span>></span><span>\")&lt;cr>&lt;cr>\nnmap&lt;leader>sc :cs find c &lt;C-R>=expand(\"</span><span>&lt;</span>cword<span>></span><span>\")&lt;cr>&lt;cr>\nnmap&lt;leader>st :cs find t &lt;C-R>=expand(\"</span><span>&lt;</span>cword<span>></span><span>\")&lt;cr>&lt;cr>\nnmap&lt;leader>se :cs find e &lt;C-R>=expand(\"</span><span>&lt;</span>cword<span>></span><span>\")&lt;cr>&lt;cr>\nnmap&lt;leader>sf :cs find f&lt;C-R>=expand(\"</span><span>&lt;</span>cfile<span>></span><span>\")&lt;cr>&lt;cr>\nnmap&lt;leader>si :cs find i&lt;C-R>=expand(\"</span><span>&lt;</span>cfile<span>></span><span>\")&lt;cr>&lt;cr>\nnmap&lt;leader>sd :cs find d &lt;C-R>=expand(\"</span><span>&lt;</span>cword<span>></span><span>\")&lt;cr>&lt;cr>\n\"</span> MiniBufExplorer  配置\n<span>let</span> g:miniBufExplMapWindowNavVim <span>=</span> <span>1</span>\n<span>let</span> g:miniBufExplMapWindowNavArrows <span>=</span> <span>1</span>\n<span>let</span> g:miniBufExplMapCTabSwitchBufs <span>=</span> <span>1</span>\n<span>let</span> g:miniBufExplModSelTarget <span>=</span> <span>1</span> \n<span>\" grep 配置\nnnoremap&lt;F4>  /&lt;C-R>=expand(\"</span><span>&lt;</span>cword<span>></span><span>\")&lt;cr>&lt;cr>\nnnoremap&lt;F3>  ?&lt;C-R>=expand(\"</span><span>&lt;</span>cword<span>></span><span>\")&lt;cr>&lt;cr>\nnnoremap &lt;silent> &lt;leader>&lt;F3> :Grep&lt;CR> \nnnoremap &lt;silent> &lt;leader>&lt;F4> :Rgrep&lt;CR> \n\"</span> SuperTab\n<span>let</span> g:SuperTabRetainCompletionType<span>=</span><span>2</span>\n<span>let</span> g:SuperTabDefaultCompletionType<span>=</span><span>\"&lt;C-X>&lt;C-O>\"</span>\n<span>\" gvim字体\n\"</span> <span>set</span> <span>guifont</span><span>=</span>Courier<span>\\</span> Regular<span>\\</span> <span>20</span>\n<span>\" line\nse nu\n \n\"</span>\"\nnnoremap <span>&lt;</span>silent<span>></span> <span>&lt;</span>F1<span><span>2</span>></span> :A<span>&lt;</span>cr<span>></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br><span>175</span><br><span>176</span><br><span>177</span><br><span>178</span><br><span>179</span><br><span>180</span><br><span>181</span><br><span>182</span><br><span>183</span><br><span>184</span><br><span>185</span><br><span>186</span><br><span>187</span><br><span>188</span><br><span>189</span><br><span>190</span><br><span>191</span><br><span>192</span><br><span>193</span><br><span>194</span><br><span>195</span><br><span>196</span><br><span>197</span><br><span>198</span><br><span>199</span><br><span>200</span><br><span>201</span><br><span>202</span><br><span>203</span><br><span>204</span><br><span>205</span><br><span>206</span><br><span>207</span><br><span>208</span><br><span>209</span><br><span>210</span><br><span>211</span><br><span>212</span><br><span>213</span><br><span>214</span><br><span>215</span><br><span>216</span><br><span>217</span><br><span>218</span><br><span>219</span><br><span>220</span><br><span>221</span><br><span>222</span><br><span>223</span><br><span>224</span><br><span>225</span><br><span>226</span><br><span>227</span><br><span>228</span><br><span>229</span><br><span>230</span><br><span>231</span><br><span>232</span><br><span>233</span><br><span>234</span><br><span>235</span><br><span>236</span><br><span>237</span><br><span>238</span><br><span>239</span><br><span>240</span><br><span>241</span><br><span>242</span><br><span>243</span><br><span>244</span><br><span>245</span><br><span>246</span><br><span>247</span><br><span>248</span><br><span>249</span><br><span>250</span><br><span>251</span><br><span>252</span><br><span>253</span><br><span>254</span><br><span>255</span><br><span>256</span><br><span>257</span><br><span>258</span><br><span>259</span><br><span>260</span><br><span>261</span><br><span>262</span><br><span>263</span><br><span>264</span><br><span>265</span><br><span>266</span><br><span>267</span><br><span>268</span><br><span>269</span><br><span>270</span><br><span>271</span><br><span>272</span><br><span>273</span><br><span>274</span><br><span>275</span><br><span>276</span><br><span>277</span><br><span>278</span><br><span>279</span><br><span>280</span><br><span>281</span><br><span>282</span><br><span>283</span><br><span>284</span><br><span>285</span><br><span>286</span><br><span>287</span><br><span>288</span><br><span>289</span><br><span>290</span><br><span>291</span><br><span>292</span><br><span>293</span><br><span>294</span><br><span>295</span><br><span>296</span><br><span>297</span><br><span>298</span><br><span>299</span><br><span>300</span><br><span>301</span><br><span>302</span><br><span>303</span><br><span>304</span><br><span>305</span><br><span>306</span><br><span>307</span><br><span>308</span><br><span>309</span><br><span>310</span><br><span>311</span><br><span>312</span><br><span>313</span><br><span>314</span><br><span>315</span><br><span>316</span><br><span>317</span><br><span>318</span><br><span>319</span><br><span>320</span><br><span>321</span><br><span>322</span><br><span>323</span><br><span>324</span><br><span>325</span><br><span>326</span><br><span>327</span><br><span>328</span><br><span>329</span><br><span>330</span><br><span>331</span><br><span>332</span><br><span>333</span><br><span>334</span><br><span>335</span><br><span>336</span><br><span>337</span><br><span>338</span><br><span>339</span><br><span>340</span><br><span>341</span><br></div></div><h2 id=\"临时调整-vim-配置\"> 临时调整 vim 配置</h2>\n<p>如果我们只是想临时的调整，可以直接在 vim 编辑的文件中，直接输入指令，当这个文件关闭，设置不会保存。</p>\n<div><pre><code><span># 设定显示行号</span>\n:set nu\n\n<span># 取消显示行号</span>\n:set nonu\n\n<span># 就是 high light search（高亮度搜寻）</span>\n<span># 这个就是设定是否将搜寻的字符串反白的设定值，默认值是 hlsearch</span>\n:set hlsearch\n\n<span># 对应的就是取消设置 hlsearch </span>\n:set nohlsearch\n\n<span># 就是自动缩排。取消缩排与同上，以下就不再写取消命令</span>\n:set autoindent\n\n<span># 是否自动储存备份档，一般是 nobackup 的</span>\n<span># 如果设定 backup 的话，那么当你更动任何一个文件时，则源文件会被另存成一个档名为 filename~ 的文件</span>\n:set backup\n\n<span># 右下角的一些状态栏说明</span>\n:set ruler\n\n<span># 是否要显示 --INSERT-- 之类的字眼在左下角的状态栏</span>\n:set showmode\n\n<span># 一般来说，如果我们按下 i 进入编辑模式后，可以利用退格键（backspace）来删除任意字符</span>\n<span># 但是某些发行版则不许如此，此时我们就可以通过该参数来设置</span>\n<span># 当 backspace 为 2 时，就是可以删除任意值；0 或 1 时，仅可删除刚刚输入的字符，而无法删除原本就已经存在的文字。</span>\n:set <span>backspace</span><span>=</span><span>2</span>\n\n<span># 显示目前所有的环境参数设定值</span>\n:set all\n\n<span># 显示与系统默认值不同的设定参数，一般来说就是你有自行变动过的设定参数</span>\n:set\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://blog.zengrong.net/post/vim-encoding/\" target=\"_blank\" rel=\"noopener noreferrer\">VIM中与编码有关的选项</a></li>\n<li><a href=\"https://www.cnblogs.com/littlesuns/p/9845386.html\" target=\"_blank\" rel=\"noopener noreferrer\">vimrc 常用配置项</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-04-05T05:51:07.000Z",
      "date_modified": "2022-04-05T05:51:07.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Nginx 部署 Https 安全认证",
      "url": "https://www.fedbook.cn/basic-skills/nginx/deploy-https-security-auth/",
      "id": "https://www.fedbook.cn/basic-skills/nginx/deploy-https-security-auth/",
      "content_html": "<h1 id=\"nginx-部署-https-安全认证\"> Nginx 部署 Https 安全认证</h1>\n<blockquote>\n<p>本文不介绍 https 相关知识，仅分享 Nginx 配置 https 服务的步骤。并且假设你已经购买了服务器、域名和 SSL 证书。</p>\n</blockquote>\n<h2 id=\"模块介绍\"> 模块介绍</h2>\n<p>网站启用 https 以后会在 SEO 和安全性方面都有一定的好处，这里不展开讲。已经启用 https 的网站，一个比较直观的变化就是浏览器的域名前面有一把小锁的图标，如下所示：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/web-sites-with-https-enabled.png\" height=\"200\" alt=\"Web sites with HTTPS enabled\">\n  <p style=\"text-align: center; color: #888;\">（启用 https 的网站）</p>\n</div>\n<p>该功能用到了 <code>http_ssl_module</code> 这个模块，默认情况下 ssl 模块并未被安装，如果要使用该模块则需要在编译 Nginx 时指定 <code>--with-http_ssl_module</code> 参数，详见《<a href=\"/basic-skills/nginx/installation-of-nginx/#编译安装\" title=\"Nginx 编译安装\">Nginx 编译安装</a>》。</p>\n<h2 id=\"购买并下载-ca-证书\"> 购买并下载 CA 证书</h2>\n<p>配置 SSL 模块首先需要 CA 证书，CA 证书可以自己手动颁发也可以在阿里云申请（<a href=\"https://help.aliyun.com/document_detail/28542.html\" title=\"阿里云购买 CA 证书\" target=\"_blank\" rel=\"noopener noreferrer\">阿里云购买 CA 证书</a>），普通用户可以在阿里云申请免费的 <code>Symantec</code> 的 <code>DV SSL</code>。</p>\n<p>购买成功后，通过阿里云后台依次进入 控制台 =&gt; 产品与服务 =&gt; 安全（云盾）=&gt; SSL 证书（应用安全），找到自己将要使用的证书，点击下载，然后选择对应 Nginx 服务器的证书，如下图所示：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/download-ssl-for-nginx.png\" height=\"350\" alt=\"下载用于 Nginx 服务器的证书\">\n  <p style=\"text-align: center; color: #888;\">（下载用于 Nginx 服务器的证书，未来界面可能会变化）</p>\n</div>\n<p>证书下载下来后解压，有两份文件：</p>\n<ul>\n<li>证书名称.key：存储的是私钥 base64 加密</li>\n<li>证书名称.pem：存储的是证书 base64 加密</li>\n</ul>\n<h2 id=\"上传证书到服务器\"> 上传证书到服务器</h2>\n<p>在 Nginx 的配置文件所在的目录下创建 cert 文件夹，并且将下载的全部文件拷贝到 cert 目录中：</p>\n<div><pre><code><span>cd</span> /usr/local/nginx/\n<span>mkdir</span> cert\n<span>cd</span> cert/\nrz -be  <span># 上传文件</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>此时的 Nginx 文件目录结构：</p>\n<div><pre><code>├── nginx\n    │── html\n    │── logs\n    │── sbin\n    │── <span>..</span>.\n    │── cert\n    │   ├── 证书名称.key        <span># 存储私钥</span>\n    │   └── 证书名称.pem        <span># 存储证书</span>\n    └── conf\n        ├── <span>..</span>.\n        ├── nginx.conf         <span># 主配置文件</span>\n        └── vhosts             <span># 子配置文件的目录</span>\n            ├── web.conf       <span># 子配置文件 1</span>\n            └── api.conf       <span># 子配置文件 2</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id=\"配置案例\"> 配置案例</h2>\n<p>前端我们已经下载并上传了 SSL 证书，接下来在 Nginx 配置文件中进行配置。</p>\n<div><div><br><div>&nbsp;</div><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br></div><pre><code>server <span>{</span>\n    listen <span>443</span> ssl<span>;</span>\n    server_name  www.fedbook.cn fedbook.cn<span>;</span>\n\n    root /sites/fedbook<span>;</span>\n    index index.html<span>;</span>\n\n    ssl_certificate  /usr/local/nginx/cert/证书名称.pem<span>;</span>\n    ssl_certificate_key  /usr/local/nginx/cert/证书名称.key<span>;</span>\n    ssl_session_timeout 5m<span>;</span>\n    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:<span>!</span>NULL:<span>!</span>aNULL:<span>!</span>MD5:<span>!</span>ADH:<span>!</span>RC4<span>;</span>\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2<span>;</span>\n    ssl_prefer_server_ciphers on<span>;</span>\n\n    location / <span>{</span>\n        <span>..</span><span>..</span><span>..</span>\n    <span>}</span>\n<span>}</span>\n\nserver <span>{</span>\n    listen <span>80</span><span>;</span>\n    server_name  www.fedbook.cn fedbook.cn<span>;</span>\n    <span>return</span> <span>301</span> https://<span>$host</span><span>$request_uri</span><span>;</span>\n<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>（完）</p>\n",
      "date_published": "2021-07-10T15:12:27.000Z",
      "date_modified": "2021-07-11T03:16:12.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "正向代理与反向代理",
      "url": "https://www.fedbook.cn/basic-skills/nginx/forward-proxy-and-reverse-proxy/",
      "id": "https://www.fedbook.cn/basic-skills/nginx/forward-proxy-and-reverse-proxy/",
      "content_html": "<h1 id=\"正向代理与反向代理\"> 正向代理与反向代理</h1>\n<h2 id=\"正向代理\"> 正向代理</h2>\n<p>正向代理其实相当于请求的中继，比如说，如果某个网站国内无法访问，也就是被墙了，这时我们可以通过一台可以访问到这个网站的服务器，也就是代理服务器，来进行访问。这台代理服务器，分析我们请求的信息，然后去对应的要去的网站上将内容取回来发给我，这样我就能读到想要访问的网站上的内容了。</p>\n<p>基于这种技术原理，VPN 就是这样产生的。通过 VPN，我们可以在家里访问公司的内网，也可以在电信宽带的环境下更好地玩网通区地 LOL（游戏加速器）。</p>\n<p>通过以下图片，可以很清晰的看出正向代理的原理：</p>\n<div style=\"text-align: center;\">\n  <svg id=\"SvgjsSvg1006\" width=\"603.0124816894531\" height=\"278\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><defs id=\"SvgjsDefs1007\"><pattern id=\"SvgjsPattern1014\" x=\"0\" y=\"0\" width=\"63\" height=\"63\" patternUnits=\"userSpaceOnUse\"><image id=\"SvgjsImage1015\" xlink:href=\"https://iconsapi.com/5ee27816e4b0b788a934aa1e.svg\" width=\"63\" height=\"63\" preserveAspectRatio=\"none\" crossOrigin=\"anonymous\" x=\"0\" y=\"0\"></image></pattern><pattern id=\"SvgjsPattern1018\" x=\"0\" y=\"0\" width=\"90\" height=\"90\" patternUnits=\"userSpaceOnUse\"><image id=\"SvgjsImage1019\" xlink:href=\"https://iconsapi.com/5ee268b1e4b0b788a9338b53.svg\" width=\"90\" height=\"90\" preserveAspectRatio=\"none\" crossOrigin=\"anonymous\" x=\"0\" y=\"0\"></image></pattern><pattern id=\"SvgjsPattern1034\" x=\"0\" y=\"0\" width=\"63\" height=\"63\" patternUnits=\"userSpaceOnUse\"><image id=\"SvgjsImage1035\" xlink:href=\"https://iconsapi.com/5ee27816e4b0b788a934aa1e.svg\" width=\"63\" height=\"63\" preserveAspectRatio=\"none\" crossOrigin=\"anonymous\" x=\"0\" y=\"0\"></image></pattern></defs><g id=\"SvgjsG1008\" transform=\"translate(25.012481689453125,25)\"><path id=\"SvgjsPath1009\" d=\"M 0 0L 331 0L 331 228L 0 228Z\" stroke=\"rgba(100,181,246,1)\" stroke-width=\"2\" fill=\"none\"></path><g id=\"SvgjsG1010\"><text id=\"SvgjsText1011\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"311px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"104.375\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1012\" transform=\"translate(264.5124816894531,99)\"><path id=\"SvgjsPath1013\" d=\"M 0 0L 63 0L 63 63L 0 63Z\" stroke=\"none\" fill=\"url(#SvgjsPattern1014)\"></path></g><g id=\"SvgjsG1016\" transform=\"translate(59.012481689453125,88.5)\"><path id=\"SvgjsPath1017\" d=\"M 0 0L 90 0L 90 90L 0 90Z\" stroke=\"none\" fill=\"url(#SvgjsPattern1018)\"></path></g><g id=\"SvgjsG1020\" transform=\"translate(44.012481689453125,156.5)\"><path id=\"SvgjsPath1021\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1022\"><text id=\"SvgjsText1023\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"120px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1024\" dy=\"20\" x=\"60\"><tspan id=\"SvgjsTspan1025\" style=\"text-decoration:;\">客户端</tspan></tspan></text></g></g><g id=\"SvgjsG1026\" transform=\"translate(236.01248168945312,156.5)\"><path id=\"SvgjsPath1027\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1028\"><text id=\"SvgjsText1029\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"120px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1030\" dy=\"20\" x=\"60\"><tspan id=\"SvgjsTspan1031\" style=\"text-decoration:;\">正向代理</tspan></tspan></text></g></g><g id=\"SvgjsG1032\" transform=\"translate(486.5124816894531,99)\"><path id=\"SvgjsPath1033\" d=\"M 0 0L 63 0L 63 63L 0 63Z\" stroke=\"none\" fill=\"url(#SvgjsPattern1034)\"></path></g><g id=\"SvgjsG1036\" transform=\"translate(458.0124816894531,156.5)\"><path id=\"SvgjsPath1037\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1038\"><text id=\"SvgjsText1039\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"120px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1040\" dy=\"20\" x=\"60\"><tspan id=\"SvgjsTspan1041\" style=\"text-decoration:;\">目标服务器</tspan></tspan></text></g></g><g id=\"SvgjsG1042\" transform=\"translate(164.01248168945312,116.89805825242718)\"><path id=\"SvgjsPath1043\" d=\"M 0 10.95728155339806L 78.39805825242718 10.95728155339806L 78.39805825242718 0L 95 16.601941747572816L 78.39805825242718 33.20388349514563L 78.39805825242718 22.246601941747574L 0 22.246601941747574L 0 10.95728155339806Z\" stroke=\"rgba(100,181,246,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1044\"><text id=\"SvgjsText1045\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"95px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"6.976941747572818\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1046\" transform=\"translate(377.0124816894531,116.89805825242718)\"><path id=\"SvgjsPath1047\" d=\"M 0 10.95728155339806L 78.39805825242718 10.95728155339806L 78.39805825242718 0L 95 16.601941747572816L 78.39805825242718 33.20388349514563L 78.39805825242718 22.246601941747574L 0 22.246601941747574L 0 10.95728155339806Z\" stroke=\"rgba(100,181,246,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1048\"><text id=\"SvgjsText1049\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"95px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"6.976941747572818\" transform=\"rotate(0)\"></text></g></g></svg>\n  <p style=\"text-align:center; color: #888;\">（正向代理）</p>\n</div>\n<h2 id=\"反向代理\"> 反向代理</h2>\n<p>反向代理，其实客户端对代理是无感知的，因为客户端并不知道访问的是代理服务器。当客户端请求一个网址的时候，由反向代理服务器去选择目标服务器并获取数据，再返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器 IP 地址。</p>\n<p>反向代理的原理如图：</p>\n<div style=\"text-align: center;\">\n  <svg id=\"SvgjsSvg1006\" width=\"602.0124816894531\" height=\"278\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><defs id=\"SvgjsDefs1007\"><pattern id=\"SvgjsPattern1014\" x=\"0\" y=\"0\" width=\"63\" height=\"63\" patternUnits=\"userSpaceOnUse\"><image id=\"SvgjsImage1015\" xlink:href=\"https://iconsapi.com/5ee27816e4b0b788a934aa1e.svg\" width=\"63\" height=\"63\" preserveAspectRatio=\"none\" crossOrigin=\"anonymous\" x=\"0\" y=\"0\"></image></pattern><pattern id=\"SvgjsPattern1018\" x=\"0\" y=\"0\" width=\"90\" height=\"90\" patternUnits=\"userSpaceOnUse\"><image id=\"SvgjsImage1019\" xlink:href=\"https://iconsapi.com/5ee268b1e4b0b788a9338b53.svg\" width=\"90\" height=\"90\" preserveAspectRatio=\"none\" crossOrigin=\"anonymous\" x=\"0\" y=\"0\"></image></pattern><pattern id=\"SvgjsPattern1034\" x=\"0\" y=\"0\" width=\"63\" height=\"63\" patternUnits=\"userSpaceOnUse\"><image id=\"SvgjsImage1035\" xlink:href=\"https://iconsapi.com/5ee27816e4b0b788a934aa1e.svg\" width=\"63\" height=\"63\" preserveAspectRatio=\"none\" crossOrigin=\"anonymous\" x=\"0\" y=\"0\"></image></pattern></defs><g id=\"SvgjsG1008\" transform=\"translate(257.0124816894531,25)\"><path id=\"SvgjsPath1009\" d=\"M 0 0L 320 0L 320 228L 0 228Z\" stroke=\"rgba(100,181,246,1)\" stroke-width=\"2\" fill=\"none\"></path><g id=\"SvgjsG1010\"><text id=\"SvgjsText1011\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"300px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"104.375\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1012\" transform=\"translate(285.5124816894531,99)\"><path id=\"SvgjsPath1013\" d=\"M 0 0L 63 0L 63 63L 0 63Z\" stroke=\"none\" fill=\"url(#SvgjsPattern1014)\"></path></g><g id=\"SvgjsG1016\" transform=\"translate(40.012481689453125,88.5)\"><path id=\"SvgjsPath1017\" d=\"M 0 0L 90 0L 90 90L 0 90Z\" stroke=\"none\" fill=\"url(#SvgjsPattern1018)\"></path></g><g id=\"SvgjsG1020\" transform=\"translate(25.012481689453125,156.5)\"><path id=\"SvgjsPath1021\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1022\"><text id=\"SvgjsText1023\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"120px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1024\" dy=\"20\" x=\"60\"><tspan id=\"SvgjsTspan1025\" style=\"text-decoration:;\">客户端</tspan></tspan></text></g></g><g id=\"SvgjsG1026\" transform=\"translate(257.0124816894531,156.5)\"><path id=\"SvgjsPath1027\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1028\"><text id=\"SvgjsText1029\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"120px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1030\" dy=\"20\" x=\"60\"><tspan id=\"SvgjsTspan1031\" style=\"text-decoration:;\">反向代理</tspan></tspan></text></g></g><g id=\"SvgjsG1032\" transform=\"translate(467.5124816894531,99)\"><path id=\"SvgjsPath1033\" d=\"M 0 0L 63 0L 63 63L 0 63Z\" stroke=\"none\" fill=\"url(#SvgjsPattern1034)\"></path></g><g id=\"SvgjsG1036\" transform=\"translate(439.0124816894531,156.5)\"><path id=\"SvgjsPath1037\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1038\"><text id=\"SvgjsText1039\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"120px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1040\" dy=\"20\" x=\"60\"><tspan id=\"SvgjsTspan1041\" style=\"text-decoration:;\">目标服务器</tspan></tspan></text></g></g><g id=\"SvgjsG1042\" transform=\"translate(145.01248168945312,116.89805825242718)\"><path id=\"SvgjsPath1043\" d=\"M 0 10.95728155339806L 78.39805825242718 10.95728155339806L 78.39805825242718 0L 95 16.601941747572816L 78.39805825242718 33.20388349514563L 78.39805825242718 22.246601941747574L 0 22.246601941747574L 0 10.95728155339806Z\" stroke=\"rgba(100,181,246,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1044\"><text id=\"SvgjsText1045\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"95px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"6.976941747572818\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1046\" transform=\"translate(364.0124816894531,116.89805825242718)\"><path id=\"SvgjsPath1047\" d=\"M 0 10.95728155339806L 78.39805825242718 10.95728155339806L 78.39805825242718 0L 95 16.601941747572816L 78.39805825242718 33.20388349514563L 78.39805825242718 22.246601941747574L 0 22.246601941747574L 0 10.95728155339806Z\" stroke=\"rgba(100,181,246,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1048\"><text id=\"SvgjsText1049\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"95px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"6.976941747572818\" transform=\"rotate(0)\"></text></g></g></svg>\n  <p style=\"text-align:center; color: #888;\">（反向代理）</p>\n</div>\n<p><strong>总的来说</strong>：</p>\n<p>正向代理代理的是客户端（如通过代理访问谷歌），我们需要在客户端进行一些代理的设置；反向代理代理的是服务器（如 Nginx 代理 Tomcat 服务器），作为客户端的我们是无法感知到服务器的真实存在的。</p>\n<p>（完）</p>\n",
      "date_published": "2021-06-30T10:08:58.000Z",
      "date_modified": "2021-06-30T14:49:06.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Nginx 页面安全认证",
      "url": "https://www.fedbook.cn/basic-skills/nginx/ngx-http-auth-basic-module/",
      "id": "https://www.fedbook.cn/basic-skills/nginx/ngx-http-auth-basic-module/",
      "content_html": "<h1 id=\"nginx-页面安全认证\"> Nginx 页面安全认证</h1>\n<h2 id=\"模块介绍\"> 模块介绍</h2>\n<p>有时候出于权限和安全考虑，我们希望某些页面不允许随便访问，必须通过用户认证才可以访问，如下所示：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/nginx-http-auth-basic.png\" height=\"200\" alt=\"Nginx Http Auth Basic\">\n  <p style=\"text-align: center; color: #888;\">（Nginx Http Auth Basic）</p>\n</div>\n<p>该功能用到了 <code>ngx_http_auth_basic_module</code> 这个模块，该模块默认是关闭的。</p>\n<p>语法：</p>\n<ul>\n<li>配置弹框提示：<code>auth_basic &quot;提示语&quot;;</code></li>\n<li>配置密码路径：<code>auth_basic_user_file 密码文件路径;</code></li>\n</ul>\n<p>可以将它配置在 <code>http</code>，<code>server</code>，<code>location</code>，<code>limit_except</code> 中的任一位置。</p>\n<h2 id=\"htpasswd-创建密码文件\"> htpasswd 创建密码文件</h2>\n<p>首先需要准备用户文件，用户名密码格式为：<code>用户名:密码</code>，其中密码不是明文。我们需要借助于 htpasswd 加密工具生成。</p>\n<p>查看服务器中是否已经安装了 htpasswd：</p>\n<div><pre><code><span>whereis</span> htpasswd\n</code></pre>\n<div><span>1</span><br></div></div><p>如果没有安装，需要先进行安装：</p>\n<div><pre><code><span># Ubuntu 系统下安装 htpasswd</span>\n<span>sudo</span> <span>apt-get</span> <span>install</span> apache2-utils\n\n<span># CentOS 系统下安装 htpasswd</span>\n<span>sudo</span> yum <span>install</span> -y httpd-tools\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>htpasswd 工具的语法为：</p>\n<ul>\n<li>htpasswd(选项)(参数)</li>\n</ul>\n<blockquote>\n<ul>\n<li><code>-c</code>：创建一个加密文件；</li>\n<li><code>-n</code>：不更新加密文件，只将加密后的用户名密码显示在屏幕上；</li>\n<li><code>-m</code>：默认采用 MD5 算法对密码进行加密；</li>\n<li><code>-d</code>：采用 CRYPT 算法对密码进行加密；</li>\n<li><code>-p</code>：不对密码进行进行加密，即明文密码；</li>\n<li><code>-s</code>：采用 SHA 算法对密码进行加密；</li>\n<li><code>-b</code>：在命令行中一并输入用户名和密码而不是根据提示输入密码；</li>\n<li><code>-D</code>：删除指定的用户。</li>\n</ul>\n</blockquote>\n<p>通过 htpasswd 工具生成用户名密码文件给 Nginx 使用：</p>\n<div><pre><code><span># 进入 Nginx 文件</span>\n<span>cd</span> /usr/local/nginx/\n\n<span># 如果是首次创建，通过 -c 选项可以在当前目录创建一个加密文件</span>\nhtpasswd -bc passwd.db admin <span>123456</span>\n\n<span># 去掉 -c 选项，即可在第一个用户之后添加第二个用户</span>\nhtpasswd -b passwd.db <span>test</span> <span>123456</span>\n\n<span># 利用 htpasswd 命令删除用户名和密码</span>\nhtpasswd -D passwd.db <span>test</span>\n\n<span># 如果要利用 htpasswd 命令修改密码</span>\n<span># 先删除指定用户，再创建用户即可实现修改密码的功能</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>出于安全考虑，我们最好修改一下用户文件 <code>passwd.db</code> 的权限：</p>\n<div><pre><code><span># 修改用户文件权限 </span>\n<span>chmod</span> <span>400</span> /usr/local/nginx/passwd.db\n\n<span># 修改用户文件属主和属组</span>\n<span>chown</span> root:root /usr/local/nginx/passwd.db\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>此时的 Nginx 文件目录结构：</p>\n<div><pre><code>├── nginx\n    │── html\n    │── logs\n    │── sbin\n    │── <span>..</span>.\n    │── passwd.db              <span># 用户文件，存储用户认证信息</span>\n    └── conf\n        ├── <span>..</span>.\n        ├── nginx.conf         <span># 主配置文件</span>\n        └── vhosts             <span># 子配置文件的目录</span>\n            ├── web.conf       <span># 子配置文件 1</span>\n            └── api.conf       <span># 子配置文件 2</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id=\"配置案例\"> 配置案例</h2>\n<p>前端我们已经通过使用 htpasswd 工具，在 <code>/usr/local/nginx/</code> 目录下生成了用户文件 <code>passwd.db</code>，接下来在 Nginx 配置文件中进行配置。</p>\n<p>假设我们有个网站，要限制外人不能访问管理页面（只允许指定 IP 访问 <code>/admin</code> 开始的 uri）。</p>\n<div><div><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><br><br><br></div><pre><code>server <span>{</span>\n    listen <span>80</span><span>;</span>\n    server_name  www.fedbook.cn<span>;</span>\n    root /sites/fedbook<span>;</span>\n    index index.html<span>;</span>\n\n    location /download <span>{</span>\n        autoindex on<span>;</span>\n        auth_basic           <span>\"请输入用户名及密码\"</span><span>;</span>\n        auth_basic_user_file /usr/local/nginx/passwd.db<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://nginx.org/en/docs/http/ngx_http_auth_basic_module.html\" title=\"Module ngx_http_auth_basic_module\" target=\"_blank\" rel=\"noopener noreferrer\">Module ngx_http_auth_basic_module</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-07-10T09:35:20.000Z",
      "date_modified": "2021-07-11T04:06:46.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Nginx 安全访问控制",
      "url": "https://www.fedbook.cn/basic-skills/nginx/ngx-http-access-module/",
      "id": "https://www.fedbook.cn/basic-skills/nginx/ngx-http-access-module/",
      "content_html": "<h1 id=\"nginx-安全访问控制\"> Nginx 安全访问控制</h1>\n<h2 id=\"模块介绍\"> 模块介绍</h2>\n<p>有时候我们需要根据客户端 IP 来限制访问，如果是不允许的 IP 则返回 403 Forbidden，如下所示：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/nginx-403-forbidden.png\" height=\"200\" alt=\"403 Forbidden\">\n  <p style=\"text-align: center; color: #888;\">（403 Forbidden）</p>\n</div>\n<p>该功能用到了 <code>ngx_http_access_module</code> 这个模块，该模块默认是关闭的。</p>\n<p>语法：</p>\n<ul>\n<li>配置允许访问：<code>allow 地址值;</code></li>\n<li>配置拒绝访问：<code>deny 地址值;</code></li>\n<li>地址值的形式支持：address | CIDR | unix: | all</li>\n</ul>\n<p>可以将它配置在 <code>http</code>，<code>server</code>，<code>location</code>，<code>limit_except</code> 中的任一位置。</p>\n<h2 id=\"配置案例\"> 配置案例</h2>\n<p>假设我们有个网站，要限制外人不能访问管理页面（只允许指定 IP 访问 <code>/admin</code> 开始的 uri）。</p>\n<div><div><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><br><br><br></div><pre><code>server <span>{</span>\n    listen <span>80</span><span>;</span>\n    server_name  www.fedbook.cn<span>;</span>\n    root /sites/fedbook<span>;</span>\n    index index.html<span>;</span>\n\n    location /admin <span>{</span>\n        allow <span>192.168</span>.10.50<span>;</span>\n        deny all<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"http://nginx.org/en/docs/http/ngx_http_access_module.html\" title=\"Module ngx_http_access_module\" target=\"_blank\" rel=\"noopener noreferrer\">Module ngx_http_access_module</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-07-10T07:09:18.000Z",
      "date_modified": "2021-07-10T09:35:20.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Nginx 的安装",
      "url": "https://www.fedbook.cn/basic-skills/nginx/installation-of-nginx/",
      "id": "https://www.fedbook.cn/basic-skills/nginx/installation-of-nginx/",
      "content_html": "<h1 id=\"nginx-的安装\"> Nginx 的安装</h1>\n<h2 id=\"windows-下安装\"> Windows 下安装</h2>\n<blockquote>\n<p>Windows 下的 Nginx 不能用于生产，一般用于开发目的或者尝鲜体验。</p>\n</blockquote>\n<h3 id=\"下载-nginx\"> 下载 Nginx</h3>\n<p>从 <a href=\"http://nginx.org/en/download.html\" target=\"_blank\" rel=\"noopener noreferrer\">官方网站</a> 下载稳定版本。</p>\n<p>以 nginx/Windows-1.18.0 为例，直接下载 nginx-1.18.0.zip。</p>\n<p>下载后解压，解压后如下：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/nginx-for-windows.png\" alt=\"Nginx for Windows\">\n  <p style=\"text-align: center; color: #888;\">（Nginx for Windows）</p>\n</div>\n<h3 id=\"启动-nginx\"> 启动 Nginx</h3>\n<p>有两种方法启动 Nginx：</p>\n<ul>\n<li>直接双击 nginx.exe，双击后一个黑色的弹窗一闪而过。（不建议用这种方式）</li>\n<li>打开 cmd 命令窗口，切换到 Nginx 解压目录下，输入命令 <code>nginx.exe</code>，回车即可。</li>\n</ul>\n<h3 id=\"检查-nginx-是否启动成功\"> 检查 Nginx 是否启动成功</h3>\n<p>直接在浏览器地址栏输入网址 <code>http://localhost:80</code> 回车，出现以下页面说明启动成功：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/welcome-to-nginx.png\" alt=\"Welcome to nginx\">\n  <p style=\"text-align: center; color: #888;\">（Welcome to nginx）</p>\n</div>\n<h3 id=\"配置监听\"> 配置监听</h3>\n<p>Nginx 的配置文件是 <code>conf/</code> 目录下的 <code>nginx.conf</code>，默认配置的 Nginx 监听的端口为 80，如果 80 端口被占用可以修改为未被占用的端口即可。</p>\n<div><pre><code>server {\n    listen       80;\n    server_name  localhost;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>当我们修改了 Nginx 的配置文件 <code>nginx.conf</code> 时，不需要关闭 Nginx 后重新启动 Nginx，只需要执行命令 <code>nginx -s reload</code> 即可让改动生效。</p>\n<h3 id=\"关闭-nginx\"> 关闭 Nginx</h3>\n<p>如果使用 cmd 命令窗口启动 Nginx，关闭 cmd 窗口是不能结束 Nginx 进程的，可使用两种方法关闭 Nginx：</p>\n<ul>\n<li>输入 Nginx 命令 <code>nginx -s stop</code>（快速停止 Nginx）或 <code>nginx -s quit</code>（完整有序的停止 Nginx）</li>\n<li>使用 taskkill：<code>taskkill /f /t /im nginx.exe</code></li>\n</ul>\n<blockquote>\n<p>taskkill 是用来终止进程的<br>\n/f 是强制终止<br>\n/t 终止指定的进程和任何由此启动的子进程<br>\n/im 根据名字指定要终止的进程</p>\n</blockquote>\n<h2 id=\"linux-下安装\"> Linux 下安装</h2>\n<p>有三种安装方式：</p>\n<ul>\n<li>编译安装：根据源码，根据实际业务需求，需要什么功能，编译时添加相应的模块。这种方式可以让 Nginx 最轻量化安装。</li>\n<li>自动化安装：配置好安装源，直接通过自动化安装工具安装。这种方式有可能会因为缺少相关依赖而安装失败。\n<ul>\n<li>CentOS：<code>yum install nginx</code></li>\n<li>Ubuntu：<code>apt-get install nginx</code></li>\n</ul>\n</li>\n<li>二进制安装：类似于绿色免安装版，把编译安装好的程序封装起来的一个包。</li>\n</ul>\n<p>一般采用第一种<strong>编译安装</strong>的方式。</p>\n<h3 id=\"准备依赖环境\"> 准备依赖环境</h3>\n<blockquote>\n<p>以下命令，如果你是 root 账户，直接执行即可，不是的话前面加 <code>sudo</code> 获取权限。</p>\n</blockquote>\n<p>Ubuntu（16.04、18.04、20.04）：</p>\n<div><pre><code><span># 建议先执行下 apt-get 的更新</span>\n<span>apt-get</span> update\n\n<span># 安装 gcc 和 g++ 依赖库</span>\n<span>apt-get</span> <span>install</span> build-essential\n<span>apt-get</span> <span>install</span> libtool\n\n<span># 安装 PCRE pcre-devel 依赖库</span>\n<span>apt-get</span> <span>install</span> libpcre3 libpcre3-dev\n\n<span># 安装 zlib 依赖库（注意 lib 后面是阿拉伯数字 1，不是字母 l）</span>\n<span>apt-get</span> <span>install</span> zlib1g-dev\n\n<span># 安装 OpenSSL 依赖库</span>\n<span>apt-get</span> <span>install</span> openssl\n<span>apt-get</span> <span>install</span> libssl-dev  <span># 未安装该库会报 SSL modules require the OpenSSL library.</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>CentOS（7.6）：</p>\n<div><pre><code><span># 安装 gcc 依赖库</span>\nyum <span>install</span> gcc-c++\n\n<span># 安装 PCRE pcre-devel 依赖库</span>\nyum <span>install</span> -y pcre pcre-devel\n\n<span># 安装 zlib 依赖库</span>\nyum <span>install</span> -y zlib zlib-devel\n\n<span># 安装 OpenSSL 依赖库</span>\nyum <span>install</span> -y openssl openssl-devel\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><blockquote>\n<p><strong>gcc 依赖库</strong>：安装 Nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装。<br>\n<strong>PCRE pcre-devel 依赖库</strong>：PCRE（Perl Compatible Regular Expressions）是一个 Perl 库，包括 perl 兼容的正则表达式库。Nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 Linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库，Nginx 也需要此库。<br>\n<strong>zlib 依赖库</strong>：lib 库提供了很多种压缩和解压缩的方式，Nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要安装 zlib 库。<br>\n<strong>OpenSSL 依赖库</strong>：OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。Nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要安装 OpenSSL 库。</p>\n</blockquote>\n<h3 id=\"准备源码包\"> 准备源码包</h3>\n<blockquote>\n<p>以下命令，如果你是 root 账户，直接执行即可，不是的话前面加 <code>sudo</code> 获取权限。</p>\n</blockquote>\n<p>从 <a href=\"http://nginx.org/en/download.html\" target=\"_blank\" rel=\"noopener noreferrer\">官方网站</a> 下载稳定版本到任意目录（例如我一般会把软件放到 <code>/opt</code>），并解压。</p>\n<div><pre><code><span># 下载</span>\n<span>wget</span> http://nginx.org/download/nginx-1.18.0.tar.gz\n\n<span># 解压</span>\n<span>tar</span> -zxvf nginx-1.18.0.tar.gz\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"编译安装\"> 编译安装</h3>\n<p>以下命令，如果你是 root 账户，直接执行即可，不是的话前面加 <code>sudo</code> 获取权限。</p>\n<p>首先进入 Nginx 安装包的解压目录：</p>\n<div><pre><code><span>cd</span> nginx-1.18.0/\n</code></pre>\n<div><span>1</span><br></div></div><p>下面开始安装 Nginx：</p>\n<div><pre><code><span># 预编译</span>\n./configure --prefix<span>=</span>/usr/local/nginx --sbin-path<span>=</span>/usr/local/nginx/sbin/nginx --user<span>=</span>nginx --group<span>=</span>nginx --with-http_ssl_module --with-http_stub_status_module --with-http_gzip_static_module\n\n<span># 检查是否编译正确</span>\n<span>echo</span> <span>$?</span>  <span># 如果返回值是 0，就是执行成功；如果是返回值是 0 以外的值，就是失败。</span>\n\n<span># 编译</span>\n<span>make</span>\n\n<span># 安装</span>\n<span>make</span> <span>install</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><blockquote>\n<p>在 ./configure 命令后跟了一堆参数，它们分别表示：</p>\n<ul>\n<li>--prefix：指定当前要安装的 Nginx 主程序目录</li>\n<li>--sbin-path：安装完成后，使用 Nginx 的命令放在该目录下</li>\n<li>--user：运行 Nginx 的用户</li>\n<li>--group：运行 Nginx 的用户组</li>\n<li>--with-(模块名)：为 Nginx 添加的模块</li>\n<li>比较完整的配置项的含义请参见<a href=\"http://nginx.org/en/docs/configure.html\" target=\"_blank\" rel=\"noopener noreferrer\">官方网站</a></li>\n</ul>\n</blockquote>\n<h3 id=\"添加-nginx-用户\"> 添加 Nginx 用户</h3>\n<p>一般我们会创建一个不能 ssh 登录的帐号，这类账号专门用于启动服务，只是让服务启动起来，但是不能登录系统（提升安全性）。</p>\n<div><pre><code><span># 为 Nginx 创建一个不能 ssh 登陆的用户（预编译命令中指定的用户和用户组）</span>\n<span>useradd</span> nginx -s /sbin/nologin -M\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><blockquote>\n<p>在 useradd 命令后跟了两个参数，它们分别表示：</p>\n<ul>\n<li>-s：表示指定用户所用的 shell，此处为 <code>/sbin/nologin</code>，表示不登录</li>\n<li>-M：表示不创建用户主目录</li>\n</ul>\n</blockquote>\n<h3 id=\"验证安装成功\"> 验证安装成功</h3>\n<p>主要通过 Nginx 能否启动来验证是否安装成功，一般我会运行以下这些命令来测试。</p>\n<div><pre><code><span># 查找安装路径</span>\n<span>whereis</span> nginx\n\n<span># 查看 Nginx 的安装目录</span>\n<span>cd</span> /usr/local/nginx  <span># 预编译命令中指定的路径</span>\n<span>ls</span>\n\n<span># 查看 Nginx 程序管理命令</span>\n<span>cd</span> /usr/local/nginx/sbin  <span># 预编译命令中指定的路径</span>\n<span>ls</span>\n\n<span># 查看 Nginx 版本</span>\n/usr/local/nginx/sbin/nginx -v\n\n<span># 启动 Nginx</span>\n/usr/local/nginx/sbin/nginx\n\n<span># 查看 Nginx 进程</span>\n<span>ps</span> -ef <span>|</span> <span>grep</span> nginx\n\n<span># 检查 Nginx 启动的端口（默认 0.0.0.0:80）</span>\n<span>netstat</span> -lntup <span>|</span> <span>grep</span> nginx\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>接下来通过浏览器访问 Nginx（服务器 IP:80），出现以下页面说明启动成功：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/welcome-to-nginx.png\" alt=\"Welcome to nginx\">\n  <p style=\"text-align: center; color: #888;\">（Welcome to nginx）</p>\n</div>\n<p>如果不能访问，就要先看下服务器是不是开启了防火墙但又没开放端口（你可以选择不开防火墙，或者开完防火墙后记得开需要的端口）。</p>\n<div><pre><code><span># 查看状态, 发现当前是 dead 状态, 即防火墙未开启</span>\nsystemctl status firewalld\n\n<span># 开启防火墙, 没有任何提示即开启成功</span>\n<span># 再次查看状态, 显示 running 即已开启了</span>\nsystemctl start firewalld\n\n<span># 开放默认端口号 80, 提示 success, 表示设置成功</span>\nfirewall-cmd --permanent --zone<span>=</span>public --add-port<span>=</span><span>80</span>/tcp\n\n<span># 修改后需要重新加载配置才生效</span>\nfirewall-cmd --reload<span>;</span>\n\n<span># 查看已经开放的端口</span>\nfirewall-cmd --permanent --list-port\n\n<span># 关闭默认的端口号 80(如果需要的话, 执行这个命令就行了)</span>\nfirewall-cmd --permanent --zone<span>=</span>public --remove-port<span>=</span><span>80</span>/tcp\n\n<span># 关闭防火墙(如果需要的话, 执行这个命令就行了)</span>\nsystemctl stop firewalld\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>如果使用的是阿里云等云厂家的服务器，<code>80</code> 端口是默认开启的，如果用了其它端口，则需要去云管理平台进行一些设置。大致的入口是：</p>\n<p>进入云服务管理控制平台 ——&gt; 进入云服务器 ——&gt; 选择实例 ——&gt; 管理。</p>\n<ul>\n<li>阿里云就找到：本实例安全组 --&gt; 配置规则 --&gt; 添加安全组规则。</li>\n<li>腾讯云就找到：防火墙 --&gt; 管理规则 --&gt; 添加规则。</li>\n<li>新增的规则就参考自带的 <code>80</code> 端口写就好了。</li>\n</ul>\n<p>这里就是测一下能不能启停，生产环境要把 Nginx 加到系统自启。现在先关闭 Nginx。</p>\n<div><pre><code><span># 关闭 Nginx</span>\n/usr/local/nginx/sbin/nginx -s stop\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>（完）</p>\n",
      "date_published": "2021-07-01T16:15:25.000Z",
      "date_modified": "2022-03-04T09:50:36.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "负载均衡",
      "url": "https://www.fedbook.cn/basic-skills/nginx/load-balancing/",
      "id": "https://www.fedbook.cn/basic-skills/nginx/load-balancing/",
      "content_html": "<h1 id=\"负载均衡\"> 负载均衡</h1>\n<h2 id=\"前言\"> 前言</h2>\n<p>当一台服务器的性能达到极限时，我们可以使用服务器集群来提高网站的整体性能。那么，在服务器集群中，需要有一台服务器充当调度者的角色，用户的所有请求都会首先由它接收，调度者再根据每台服务器的负载情况将请求分配给某一台后端服务器去处理。</p>\n<p>那么在这个过程中，调度者如何合理分配任务，保证所有后端服务器都将性能充分发挥，从而保持服务器集群的整体性能最优，这就是负载均衡问题。</p>\n<p>负载均衡的实现方式可以依托于多种调度算法，常见的有：</p>\n<ul>\n<li>轮循（Round Robin）</li>\n<li>加权轮循（Weighted Round Robin）</li>\n<li>最少连接数（Least Connection）</li>\n<li>最少连接数慢启动时间（Least Connection Slow Start Time）</li>\n<li>加权最少连接（Weighted Least Connection）</li>\n<li>基于代理的自适应负载均衡（Agent Based Adaptive Balancing）</li>\n<li>固定权重（Fixed Weighted）</li>\n<li>加权响应（Weighted Response）</li>\n<li>源IP哈希（Source IP Hash）</li>\n</ul>\n<h2 id=\"轮询\"> 轮询</h2>\n<p>这种方法会将收到的请求循环分配到服务器集群中的每台机器，即有效服务器。如果使用这种方式，所有的标记进入虚拟服务的服务器应该有相近的资源容量以及负载形同的应用程序。如果所有的服务器有相同或者相近的性能那么选择这种方式会使服务器负载形同。基于这个前提，轮循调度是一个简单而有效的分配请求的方式。然而对于服务器不同的情况，选择这种方式就意味着能力比较弱的服务器也会在下一轮循环中接受轮循，即使这个服务器已经不能再处理当前这个请求了。这可能导致能力较弱的服务器超载。</p>\n<h2 id=\"加权轮循\"> 加权轮循</h2>\n<p>这种算法解决了简单轮循调度算法的缺点：传入的请求按顺序被分配到集群中服务器，但是会考虑提前为每台服务器分配的权重。管理员只是简单的通过服务器的处理能力来定义各台服务器的权重。例如，能力最强的服务器A给的权重是100，同时能力最低的服务器给的权重是 50。这意味着在服务器 B 接收到第一个请求之前前，服务器 A 会连续的接受到 2 个请求，以此类推。</p>\n<h2 id=\"最少连接数\"> 最少连接数</h2>\n<p>以上两种方法都没有考虑的是系统不能识别在给定的时间里保持了多少连接。因此可能发生，服务器 B 服务器收到的连接比服务器 A 少但是它已经超载，因为服务器 B 上的用户打开连接持续的时间更长。这就是说连接数即服务器的负载是累加的。这种潜在的问题可以通过「最少连接数」算法来避免：传入的请求是根据每台服务器当前所打开的连接数来分配的。即活跃连接数最少的服务器会自动接收下一个传入的请求。接本上和简单轮询的原则相同：所有拥有虚拟服务的服务器资源容量应该相近。值得注意的是，在流量率低的配置环境中，各服务器的流量并不是相同的，会优先考虑第一台服务器。这是因为，如果所有的服务器是相同的，那么第一个服务器优先，直到第一台服务器有连续的活跃流量，否则总是会优先选择第一台服务器。</p>\n<h2 id=\"最少连接数慢启动时间\"> 最少连接数慢启动时间</h2>\n<p>对最少连接数和带权重的最小连接数调度方法来说，当一个服务器刚加入线上环境是，可以为其配置一个时间段，在这段时间内连接数是有限制的而且是缓慢增加的。这为服务器提供了一个「过渡时间」以保证这个服务器不会因为刚启动后因为分配的连接数过多而超载。这个值在 L7 配置界面设置。</p>\n<h2 id=\"加权最少连接\"> 加权最少连接</h2>\n<p>如果服务器的资源容量各不相同，那么「加权最少连接」方法更合适：由管理员根据服务器情况定制的权重所决定的活跃连接数一般提供了一种对服务器非常平衡的利用，因为他它借鉴了最少连接和权重两者的优势。通常，这是一个非常公平的分配方式，因为它使用了连接数和服务器权重比例；集群中比例最低的服务器自动接收下一个请求。但是请注意，在低流量情况中使用这种方法时，请参考「最小连接数」方法中的注意事项。</p>\n<h2 id=\"基于代理的自适应负载均衡\"> 基于代理的自适应负载均衡</h2>\n<p>除了上述方法之外，负载主机包含一个自适用逻辑用来定时监测服务器状态和该服务器的权重。对于非常强大的「基于代理的自适应负载均衡」方法来说，负载主机以这种方式来定时检测所有服务器负载情况：每台服务器都必须提供一个包含文件，这个文件包含一个 0~99 的数字用来标明改服务器的实际负载情况（0=空前，99=超载，101=失败，102=管理员禁用），而服务器同构 http get 方法来获取这个文件；同时对集群中服务器来说，以二进制文件形式提供自身负载情况也是该服务器工作之一，然而，并没有限制服务器如何计算自身的负载情况。根据服务器整体负载情况，有两种策略可以选择：在常规的操作中，调度算法通过收集的服务器负载值和分配给该服务器的连接数的比例计算出一个权重比例。因此，如果一个服务器负载过大，权重会通过系统透明的作重新调整。和加权轮循调度方法一样，不正确的分配可以被记录下来使得可以有效的为不同服务器分配不同的权重。然而，在流量非常低的环境下，服务器报上来的负载值将不能建立一个有代表性的样本；那么基于这些值来分配负载的话将导致失控以及指令震荡。因此，在这种情况下更合理的做法是基于静态的权重比来计算负载分配。当所有服务器的负载低于管理员定义的下限时，负载主机就会自动切换为加权轮循方式来分配请求；如果负载大于管理员定义的下限，那么负载主机又会切换回自适应方式。</p>\n<h2 id=\"固定权重\"> 固定权重</h2>\n<p>最高权重只有在其他服务器的权重值都很低时才使用。然而，如果最高权重的服务器下降，则下一个最高优先级的服务器将为客户端服务。这种方式中每个真实服务器的权重需要基于服务器优先级来配置。</p>\n<h2 id=\"加权响应\"> 加权响应</h2>\n<p>流量的调度是通过加权轮循方式。加权轮循中所使用的权重是根据服务器有效性检测的响应时间来计算。每个有效性检测都会被计时，用来标记它响应成功花了多长时间。但是需要注意的是，这种方式假定服务器心跳检测是基于机器的快慢，但是这种假设也许不总是能够成立。所有服务器在虚拟服务上的响应时间的总和加在一起，通过这个值来计算单个服务物理服务器的权重；这个权重值大约每 15 秒计算一次。</p>\n<h2 id=\"源ip哈希\"> 源IP哈希</h2>\n<p>这种方式通过生成请求源IP的哈希值，并通过这个哈希值来找到正确的真实服务器。这意味着对于同一主机来说他对应的服务器总是相同。使用这种方式，你不需要保存任何源IP。但是需要注意，这种方式可能导致服务器负载不平衡。</p>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://www.runoob.com/w3cnote/balanced-algorithm.html\" title=\"负载均衡调度算法大全\" target=\"_blank\" rel=\"noopener noreferrer\">负载均衡调度算法大全</a>（转载）</li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-07-01T04:55:32.000Z",
      "date_modified": "2021-07-01T16:15:25.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Nginx 文件列表功能",
      "url": "https://www.fedbook.cn/basic-skills/nginx/ngx-http-autoindex-module/",
      "id": "https://www.fedbook.cn/basic-skills/nginx/ngx-http-autoindex-module/",
      "content_html": "<h1 id=\"nginx-文件列表功能\"> Nginx 文件列表功能</h1>\n<h2 id=\"模块介绍\"> 模块介绍</h2>\n<p>有时候我们需要搭建一个文件下载平台，类似镜像站的内容列表，供用户下载，如下所示：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/mirrors-of-ustc.png\" height=\"200\" alt=\"中国科学技术大学开源镜像站\">\n  <p style=\"text-align: center; color: #888;\">（中国科学技术大学开源镜像站）</p>\n</div>\n<p>该功能用到了 <code>ngx_http_autoindex_module</code> 这个模块，该模块默认是关闭的。</p>\n<p>语法：</p>\n<ul>\n<li>开启文件列表功能：<code>autoindex on;</code></li>\n</ul>\n<p>可以将它配置在 <code>http</code>，<code>server</code>，<code>location</code> 中的任一位置。</p>\n<h2 id=\"配置案例\"> 配置案例</h2>\n<p>需要将 <code>/sites/fedbook/download/</code> 目录变成可下载的内容列表，只需配置如下 <code>location</code>：</p>\n<div><div><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br></div><pre><code>server <span>{</span>\n    listen <span>80</span><span>;</span>\n    server_name  www.fedbook.cn<span>;</span>\n    root /sites/fedbook<span>;</span>\n    index index.html<span>;</span>\n\n    location /download <span>{</span>\n        autoindex on<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://nginx.org/en/docs/http/ngx_http_autoindex_module.html\" title=\"Module ngx_http_autoindex_module\" target=\"_blank\" rel=\"noopener noreferrer\">Module ngx_http_autoindex_module</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-07-10T07:35:11.000Z",
      "date_modified": "2021-07-10T09:35:20.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Nginx 部署前后端分离项目",
      "url": "https://www.fedbook.cn/basic-skills/nginx/practice-in-front-end-separation-project/",
      "id": "https://www.fedbook.cn/basic-skills/nginx/practice-in-front-end-separation-project/",
      "content_html": "<h1 id=\"nginx-部署前后端分离项目\"> Nginx 部署前后端分离项目</h1>\n<h2 id=\"部署目标\"> 部署目标</h2>\n<ul>\n<li>解决前后端分离项目的跨域问题</li>\n<li>前端路由采用 HTML5 History 模式</li>\n<li>配置反向代理 Websocket</li>\n</ul>\n<h2 id=\"部署前准备\"> 部署前准备</h2>\n<ul>\n<li>将前端代码打包成为纯静态文件，上传至服务器</li>\n<li>后端代码启动在服务器，监听 <code>30000</code> 端口</li>\n</ul>\n<h2 id=\"nginx-配置\"> Nginx 配置</h2>\n<ul>\n<li><code>location</code> 为代理接口，可以转发代理后端的请求接口域名或者 ip，即可解决接口跨域问题</li>\n<li>升级 Http1.1 到 Websocket 协议</li>\n</ul>\n<div><pre><code>upstream http_proxy <span>{</span>\n    server <span>127.0</span>.0.1:30000<span>;</span>\n<span>}</span>\n\nupstream ws_proxy <span>{</span>\n    server <span>127.0</span>.0.1:30000<span>;</span>\n<span>}</span>\n\nserver <span>{</span>\n    listen       <span>80</span><span>;</span>\n    server_name  www.wenyuanblog.com wenyuanblog.com<span>;</span>\n\n    root /home/spa-project/wenyuanblog<span>;</span>\n    index index.html<span>;</span>\n\n    <span># 将 404 错误页面重定向到 index.html 可以解决 history 模式访问不到页面问题</span>\n    error_page    <span>404</span>         /index.html<span>;</span>\n\n    location / <span>{</span>\n        try_files <span>$uri</span> <span>$uri</span>/ /index.html<span>;</span>\n    <span>}</span>\n\n    location ^~ /api/ <span>{</span>\n        proxy_pass http://http_proxy<span>;</span>\n        <span># timeout</span>\n        proxy_connect_timeout <span>75</span><span>;</span>\n        proxy_read_timeout <span>150</span><span>;</span>\n        proxy_send_timeout <span>150</span><span>;</span>\n        client_max_body_size 50m<span>;</span>\n        <span># redefine request header to backend</span>\n        proxy_set_header  Host              <span>$http_host</span><span>;</span>\n        proxy_set_header  X-Real-IP         <span>$remote_addr</span><span>;</span>\n        proxy_set_header  X-Forwarded-For   <span>$proxy_add_x_forwarded_for</span><span>;</span>\n        proxy_set_header  X-Forwarded-Proto <span>$scheme</span><span>;</span>\n    <span>}</span>\n\n    location ^~ /ws/ <span>{</span>\n        proxy_pass http://ws_proxy<span>;</span>\n        <span># timeout</span>\n        proxy_connect_timeout <span>75</span><span>;</span>\n        proxy_read_timeout <span>600</span><span>;</span>  <span># Websocket 保持长连接</span>\n        proxy_send_timeout <span>150</span><span>;</span>\n        client_max_body_size 50m<span>;</span>\n        <span># http => websocket</span>\n        proxy_http_version <span>1.1</span><span>;</span>\n        proxy_set_header Upgrade <span>$http_upgrade</span><span>;</span>\n        proxy_set_header Connection <span>\"Upgrade\"</span><span>;</span>\n        <span># redefine request header to backend</span>\n        proxy_set_header  Host              <span>$host</span><span>;</span>\n        proxy_set_header  X-Real-IP         <span>$remote_addr</span><span>;</span>\n        proxy_set_header  X-Forwarded-For   <span>$proxy_add_x_forwarded_for</span><span>;</span>\n        proxy_set_header  X-Forwarded-Proto <span>$scheme</span><span>;</span>\n    <span>}</span>\n\n    location ~* <span>\\</span>.<span>(</span>html<span>|</span>htm<span>)</span>$ <span>{</span> \n        expires 1h<span>;</span>\n        add_header Cache-Control <span>\"public\"</span><span>;</span> \n    <span>}</span>\n    \n    location ~* <span>\\</span>.<span>(</span>css<span>|</span>js<span>|</span>jpg<span>|</span>jpeg<span>|</span>gif<span>|</span>png<span>|</span>ico<span>|</span>cur<span>|</span>gz<span>|</span>svg<span>|</span>svgz<span>|</span>map<span>|</span>mp4<span>|</span>ogg<span>|</span>ogv<span>|</span>webm<span>|</span>htc<span>)</span>$ <span>{</span> \n        expires 24h<span>;</span>\n        access_log off<span>;</span> \n        add_header Cache-Control <span>\"public\"</span><span>;</span> \n    <span>}</span> \n    \n    access_log  /var/log/nginx/access/wenyuanblog.log<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br></div></div><p>部分配置项解析：</p>\n<ul>\n<li><code>proxy_connect_timeout</code>：后端服务器连接的超时时间，发起握手等候响应超时时间（默认为 60 秒，官方推荐最长不要超过 75 秒）</li>\n<li><code>proxy_read_timeout</code>：连接成功后，Nginx 能够等待后端服务器响应的时间（默认 60 秒）</li>\n<li><code>proxy_send_timeout</code>：后端服务器数据回传时间，就是在规定时间之内后端服务器必须传完所有的数据（默认 60 秒）</li>\n<li><code>client_max_body_size</code>：Nginx 对上传文件大小的限制（默认是 1M）</li>\n<li><code>proxy_set_header</code>：用来重定义发往后端服务器的请求头\n<ul>\n<li><code>Host $http_host;</code>：将原 http 请求 Header 中的 Host 字段也放到转发的请求</li>\n<li><code>X-Real-IP $remote_addr;</code>：前一节点的 IP（并不一定是用户的真实 IP）</li>\n<li><code>X-Forwarded-For $proxy_add_x_forwarded_for;</code>：前一节点的 X-Forwarded-For 的值</li>\n</ul>\n<blockquote>\n<p>X-Real-IP 一般是最后一级代理将上游 IP 地址添加到该头中，X-Forwarded-For 是多个 IP 地址，而 X-Real-IP 是一个。</p>\n</blockquote>\n<ul>\n<li><code>X-Forwarded-Proto $scheme;</code>：拿到来源的传输协议（HTTP 或 HTTPS）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_set_header\" title=\"Module ngx_http_proxy_module：proxy_set_header\" target=\"_blank\" rel=\"noopener noreferrer\">Module ngx_http_proxy_module：proxy_set_header</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-07-11T09:14:43.000Z",
      "date_modified": "2021-07-22T10:17:43.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Nginx 限流常用模块",
      "url": "https://www.fedbook.cn/basic-skills/nginx/traffic-limiting-modules/",
      "id": "https://www.fedbook.cn/basic-skills/nginx/traffic-limiting-modules/",
      "content_html": "<h1 id=\"nginx-限流常用模块\"> Nginx 限流常用模块</h1>\n<p>限流是一个比较常见的需求，它可以限制某个用户在一定时间内产生的 HTTP 请求数。常用于安全方面，通过限制请求速度来防止外部暴力扫描，或者减慢暴力密码破解攻击，可以结合日志标记出目标 URL 来帮助防范 DDoS 攻击，也可以解决流量突发的问题（如整点活动）。</p>\n<h2 id=\"模块介绍\"> 模块介绍</h2>\n<p>Nginx 有两个限流常用模块：</p>\n<ul>\n<li><code>ngx_http_limit_conn_module</code>：该模块用于限制并发连接数\n<ul>\n<li>在配置文件中，使用 <code>limit_conn_zone</code> 和 <code>limit_conn</code> 指令</li>\n</ul>\n</li>\n<li><code>ngx_http_limit_req_module</code>：该模块用于限制一段时间内同一 IP 的访问频率\n<ul>\n<li>在配置文件中，使用 <code>limit_req_zone</code> 和 <code>limit_req</code> 指令</li>\n</ul>\n</li>\n</ul>\n<p>下面是配置案例。</p>\n<h2 id=\"限制并发\"> 限制并发</h2>\n<p>限制 IP 并发数，也是说限制同一个 IP 同时连接服务器的数量。可以防止一瞬间的并发访问过高导致服务器崩掉。</p>\n<h3 id=\"_1-添加-limit-conn-zone\"> 1. 添加 <code>limit_conn_zone</code></h3>\n<p>这个变量只能配置在 <code>http</code> 中。</p>\n<div><pre><code>http <span>{</span>\n    <span>..</span>.\n\n    <span># 定义一个名为 addr 的 limit_req_zone 用来存储 session，大小是 10M 内存</span>\n    <span># 以 $binary_remote_addr 为 key</span>\n    <span># nginx 1.18 以后用 limit_conn_zone 替换了 limit_conn</span>\n    <span># 且只能放在 http{} 代码段</span>\n    limit_conn_zone <span>$binary_remote_addr</span> <span>zone</span><span>=</span>addr:10m<span>;</span>\n\n    <span>..</span>.\n    include /usr/local/nginx/conf/vhosts/*.conf<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id=\"_2-添加-limit-conn\"> 2. 添加 <code>limit_conn</code></h3>\n<p>这个变量可以配置在 <code>http</code>，<code>server</code>，<code>location</code> 中的任一位置。因为我这里只限制一个站点，所以添加到 <code>server</code> 里面。</p>\n<div><pre><code>server<span>{</span>\n    <span>..</span>.\n\n    limit_conn addr <span>10</span><span>;</span>      <span># 连接数限制</span>\n    <span># 设置给定键值的共享内存区域和允许的最大连接数。超出此限制时，服务器将返回 503（服务临时不可用）错误.</span>\n    <span># 如果区域存储空间不足，服务器将返回503（服务临时不可用）错误</span>\n\n    <span>..</span>.\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面的配置能达到的效果就是，一瞬间访问的时候，只会有 10 个 IP 能得到响应，后面的 IP 直接就返回 503 状态。</p>\n<h2 id=\"限制-ip-访问频率\"> 限制 IP 访问频率</h2>\n<p>限制同一个 IP 在一段时间里连接服务器的次数，可以一定程度上防止类似 CC 这种快速频率请求的攻击。</p>\n<h3 id=\"_1-添加-limit-req-zone\"> 1. 添加 <code>limit_req_zone</code></h3>\n<p>这个变量只能配置在 <code>http</code> 中。</p>\n<div><pre><code>http <span>{</span>\n    <span>..</span>.\n\n    <span># 定义一个名为 allips 的 limit_req_zone 用来存储 session，大小是 10M 内存，</span>\n    <span># 以 $binary_remote_addr 为 key，限制平均每秒的请求为 20 个，</span>\n    <span># 1M 能存储 16000 个状态，rate 的值必须为整数，</span>\n    <span># 如果限制两秒钟一个请求，可以设置成 30r/m</span>\n    limit_req_zone <span>$binary_remote_addr</span> <span>zone</span><span>=</span>allips:10m <span>rate</span><span>=</span>20r/s<span>;</span>\n\n    <span>..</span>.\n    include /usr/local/nginx/conf/vhosts/*.conf<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id=\"_2-添加-limit-req\"> 2. 添加 <code>limit_req</code></h3>\n<p>这个变量可以配置在 <code>http</code>，<code>server</code>，<code>location</code> 中的任一位置。因为我这里只限制一个站点，所以添加到 <code>server</code> 里面。</p>\n<div><pre><code>server<span>{</span>\n    <span>..</span>.\n\n    <span># 限制每 IP 每秒不超过 20 个请求，漏桶数 burst 为 5</span>\n    <span># brust 的意思就是，如果第 1、2、3、4 秒请求为 19 个，</span>\n    <span># 第 5 秒的请求为 25 个是被允许的。</span>\n    <span># 但是如果第 1 秒就 25 个请求，第 2 秒超过 20 的请求返回 503 错误。</span>\n    <span># nodelay，如果不设置该选项，严格使用平均速率限制请求数，</span>\n    <span># 第 1 秒 25 个请求时，5 个请求放到第 2 秒执行，</span>\n    <span># 设置 nodelay，25 个请求将在第 1 秒执行。</span>\n    limit_req <span>zone</span><span>=</span>allips <span>burst</span><span>=</span><span>5</span> nodelay<span>;</span>\n\n    <span>..</span>.\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>此时能达到的效果，同一个 IP 在一秒钟只能获得 20 个访问，超过 20 个请求，后面的也是直接返回 503。</p>\n<h2 id=\"限制并发-限制-ip-访问频率\"> 限制并发 + 限制 IP 访问频率</h2>\n<p>上面的两个配置加在一起就可以做到：<strong>一秒只有 10 个连接，每个连接只能发送 20 个请求</strong>。</p>\n<p>注意：对 request 的访问限制，一定要注意数量的配置，否则一不小心就会 503（ERR_ABORTED 503 (Service Temporarily Unavailable)），这会导致很多静态资源类型被拦截，使得页面加载不完整。</p>\n<h2 id=\"总结\"> 总结</h2>\n<p>通过 Nginx 的这两个模块实现限流是挺好用的功能，但是这两个配置也不是绝对安全，只要有足够的耐心来尝试，摸索出间接等待的时长，一样可以绕过这些校验，所以最好的方式还是在服务端做校验，防止不法分子对后台端口进行疯狂调用。</p>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://nginx.org/en/docs/http/ngx_http_limit_conn_module.html\" title=\"Module ngx_http_limit_conn_module\" target=\"_blank\" rel=\"noopener noreferrer\">Module ngx_http_limit_conn_module</a></li>\n<li><a href=\"https://nginx.org/en/docs/http/ngx_http_limit_req_module.html\" title=\"Module ngx_http_limit_req_module\" target=\"_blank\" rel=\"noopener noreferrer\">Module ngx_http_limit_req_module</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-07-22T10:17:43.000Z",
      "date_modified": "2021-12-03T07:01:56.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Nginx 设置开机自启",
      "url": "https://www.fedbook.cn/basic-skills/nginx/set-auto-start-after-server-reboot/",
      "id": "https://www.fedbook.cn/basic-skills/nginx/set-auto-start-after-server-reboot/",
      "content_html": "<h1 id=\"nginx-设置开机自启\"> Nginx 设置开机自启</h1>\n<p>在生产环境中，如果我们的服务器意外重启，此时要是 Nginx 没有随服务器启动起来，我们的 Web 站点就会是无应答的状态，这会给我们带来不同程度损失。</p>\n<p>因此我们需要设置 Nginx 开机自启。</p>\n<h2 id=\"ubuntu-设置开机自启\"> Ubuntu 设置开机自启</h2>\n<blockquote>\n<p>以下所有命令，如果你是 root 账户，直接执行即可，不是的话前面加 <code>sudo</code> 获取权限。</p>\n</blockquote>\n<p>在 Ubuntu 和 Debian 下，我们通过 update-rc.d 设置 Nginx 的开机启动。</p>\n<p>经实验，以下步骤适用于 Ubuntu 16.04、18.04、20.04 版本的系统。</p>\n<h3 id=\"创建启动脚本\"> 创建启动脚本</h3>\n<p>在 Linux 系统的 <code>/etc/init.d/</code> 目录下创建 <code>nginx</code> 文件：</p>\n<div><pre><code><span>vim</span> /etc/init.d/nginx\n</code></pre>\n<div><span>1</span><br></div></div><p>往该文件内写入以下脚本内容（该脚本内容来自网络）：</p>\n<div><pre><code><span>#! /bin/sh</span>\n<span># chkconfig: 2345 55 25</span>\n<span># Description: Startup script for nginx webserver on Debian. Place in /etc/init.d and</span>\n<span># run 'update-rc.d -f nginx defaults', or use the appropriate command on your</span>\n<span># distro. For CentOS/Redhat run: 'chkconfig --add nginx'</span>\n\n<span>### BEGIN INIT INFO</span>\n<span># Provides:          nginx</span>\n<span># Required-Start:    $all</span>\n<span># Required-Stop:     $all</span>\n<span># Default-Start:     2 3 4 5</span>\n<span># Default-Stop:      0 1 6</span>\n<span># Short-Description: starts the nginx web server</span>\n<span># Description:       starts nginx using start-stop-daemon</span>\n<span>### END INIT INFO</span>\n\n<span># Author:   licess</span>\n<span># website:  http://lnmp.org</span>\n\n<span><span>PATH</span></span><span>=</span>/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin\n<span>NAME</span><span>=</span>nginx\n<span>NGINX_BIN</span><span>=</span>/usr/local/nginx/sbin/<span>$NAME</span>\n<span>CONFIGFILE</span><span>=</span>/usr/local/nginx/conf/<span>$NAME</span>.conf\n<span>PIDFILE</span><span>=</span>/usr/local/nginx/logs/<span>$NAME</span>.pid\n\n<span>case</span> <span>\"<span>$1</span>\"</span> <span>in</span>\n    start<span>)</span>\n        <span>echo</span> -n <span>\"Starting <span>$NAME</span>... \"</span>\n\n        <span>if</span> <span>netstat</span> -tnpl <span>|</span> <span>grep</span> -q nginx<span>;</span><span>then</span>\n            <span>echo</span> <span>\"<span>$NAME</span> (pid <span><span>`</span>pidof $NAME<span>`</span></span>) already running.\"</span>\n            <span>exit</span> <span>1</span>\n        <span>fi</span>\n\n        <span>$NGINX_BIN</span> -c <span>$CONFIGFILE</span>\n\n        <span>if</span> <span>[</span> <span>\"<span>$?</span>\"</span> <span>!=</span> <span>0</span> <span>]</span> <span>;</span> <span>then</span>\n            <span>echo</span> <span>\" failed\"</span>\n            <span>exit</span> <span>1</span>\n        <span>else</span>\n            <span>echo</span> <span>\" done\"</span>\n        <span>fi</span>\n        <span>;</span><span>;</span>\n\n    stop<span>)</span>\n        <span>echo</span> -n <span>\"Stoping <span>$NAME</span>... \"</span>\n\n        <span>if</span> <span>!</span> <span>netstat</span> -tnpl <span>|</span> <span>grep</span> -q nginx<span>;</span> <span>then</span>\n            <span>echo</span> <span>\"<span>$NAME</span> is not running.\"</span>\n            <span>exit</span> <span>1</span>\n        <span>fi</span>\n\n        <span>$NGINX_BIN</span> -s stop\n\n        <span>if</span> <span>[</span> <span>\"<span>$?</span>\"</span> <span>!=</span> <span>0</span> <span>]</span> <span>;</span> <span>then</span>\n            <span>echo</span> <span>\" failed. Use force-quit\"</span>\n            <span>exit</span> <span>1</span>\n        <span>else</span>\n            <span>echo</span> <span>\" done\"</span>\n        <span>fi</span>\n        <span>;</span><span>;</span>\n\n    status<span>)</span>\n        <span>if</span> <span>netstat</span> -tnpl <span>|</span> <span>grep</span> -q nginx<span>;</span> <span>then</span>\n            <span>PID</span><span>=</span><span><span>`</span>pidof nginx<span>`</span></span>\n            <span>echo</span> <span>\"<span>$NAME</span> (pid <span>$PID</span>) is running...\"</span>\n        <span>else</span>\n            <span>echo</span> <span>\"<span>$NAME</span> is stopped\"</span>\n            <span>exit</span> <span>0</span>\n        <span>fi</span>\n        <span>;</span><span>;</span>\n\n    force-quit<span>)</span>\n        <span>echo</span> -n <span>\"Terminating <span>$NAME</span>... \"</span>\n\n        <span>if</span> <span>!</span> <span>netstat</span> -tnpl <span>|</span> <span>grep</span> -q nginx<span>;</span> <span>then</span>\n            <span>echo</span> <span>\"<span>$NAME</span> is not running.\"</span>\n            <span>exit</span> <span>1</span>\n        <span>fi</span>\n\n        <span>kill</span> <span><span>`</span>pidof $NAME<span>`</span></span>\n\n        <span>if</span> <span>[</span> <span>\"<span>$?</span>\"</span> <span>!=</span> <span>0</span> <span>]</span> <span>;</span> <span>then</span>\n            <span>echo</span> <span>\" failed\"</span>\n            <span>exit</span> <span>1</span>\n        <span>else</span>\n            <span>echo</span> <span>\" done\"</span>\n        <span>fi</span>\n        <span>;</span><span>;</span>\n\n    restart<span>)</span>\n        <span>$0</span> stop\n        <span>sleep</span> <span>1</span>\n        <span>$0</span> start\n        <span>;</span><span>;</span>\n\n    reload<span>)</span>\n        <span>echo</span> -n <span>\"Reload service <span>$NAME</span>... \"</span>\n\n        <span>if</span> <span>netstat</span> -tnpl <span>|</span> <span>grep</span> -q nginx<span>;</span> <span>then</span>\n            <span>$NGINX_BIN</span> -s reload\n            <span>echo</span> <span>\" done\"</span>\n        <span>else</span>\n            <span>echo</span> <span>\"<span>$NAME</span> is not running, can't reload.\"</span>\n            <span>exit</span> <span>1</span>\n        <span>fi</span>\n        <span>;</span><span>;</span>\n\n    configtest<span>)</span>\n        <span>echo</span> -n <span>\"Test <span>$NAME</span> configure files... \"</span>\n\n        <span>$NGINX_BIN</span> -t\n        <span>;</span><span>;</span>\n\n    *<span>)</span>\n        <span>echo</span> <span>\"Usage: <span>$0</span> {start|stop|force-quit|restart|reload|status|configtest}\"</span>\n        <span>exit</span> <span>1</span>\n        <span>;</span><span>;</span>\n\n<span>esac</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br></div></div><h3 id=\"修改部分参数\"> 修改部分参数</h3>\n<p>如果你的 Nginx 是通过编译安装的，则需要根据实际安装时的设置，修改启动脚本中的几个参数（大约在第）：</p>\n<div><pre><code><span># 如果是按照我方式编译安装的，则不用修改，默认参数值就是我的实际安装位置</span>\n<span>NGINX_BIN</span><span>=</span>/usr/local/nginx/sbin/<span>$NAME</span>\n<span>CONFIGFILE</span><span>=</span>/usr/local/nginx/conf/<span>$NAME</span>.conf\n<span>PIDFILE</span><span>=</span>/usr/local/nginx/logs/<span>$NAME</span>.pid\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"添加执行权限\"> 添加执行权限</h3>\n<p>上述脚本保存为 <code>/etc/init.d/nginx</code>，然后设置文件的执行权限：</p>\n<div><pre><code><span># 给所有用户给予可执行权限</span>\n<span>chmod</span> a+x /etc/init.d/nginx\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>至此就可以通过下面指令控制 Nginx 的启动、停止和重新加载了：</p>\n<div><pre><code><span># 启动</span>\n/etc/init.d/nginx start\n\n<span># 停止</span>\n/etc/init.d/nginx stop\n\n<span># 重新加载配置</span>\n/etc/init.d/nginx reload\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"添加至开机自启动\"> 添加至开机自启动</h3>\n<p>现在将 Nginx 服务加入开机自启动：</p>\n<div><pre><code><span># 设置开机启动</span>\n<span>sudo</span> update-rc.d nginx defaults\n\n<span># 启动 Nginx</span>\n<span>sudo</span> /etc/init.d/nginx start\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>当然了，如果需要关闭开机启动的功能：</p>\n<div><pre><code><span># 取消开机启动</span>\n<span>sudo</span> update-rc.d -f nginx remove\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"centos-6-x-设置开机自启\"> CentOS 6.x 设置开机自启</h2>\n<blockquote>\n<p>以下所有命令，如果你是 root 账户，直接执行即可，不是的话前面加 <code>sudo</code> 获取权限。</p>\n</blockquote>\n<h3 id=\"创建启动脚本-2\"> 创建启动脚本</h3>\n<p>在 Linux 系统的 <code>/etc/init.d/</code> 目录下创建 <code>nginx</code> 文件：</p>\n<div><pre><code><span>vim</span> /etc/init.d/nginx\n</code></pre>\n<div><span>1</span><br></div></div><p>往该文件内写入以下脚本内容（该脚本内容来自<a href=\"https://www.nginx.com/resources/wiki/start/topics/examples/redhatnginxinit/\" target=\"_blank\" rel=\"noopener noreferrer\">官方网站 - Red Hat NGINX Init Script</a>）：</p>\n<div><pre><code><span>#!/bin/sh</span>\n<span>#</span>\n<span># nginx - this script starts and stops the nginx daemon</span>\n<span>#</span>\n<span># chkconfig:   - 85 15</span>\n<span># description:  NGINX is an HTTP(S) server, HTTP(S) reverse \\</span>\n<span>#               proxy and IMAP/POP3 proxy server</span>\n<span># processname: nginx</span>\n<span># config:      /etc/nginx/nginx.conf</span>\n<span># config:      /etc/sysconfig/nginx</span>\n<span># pidfile:     /var/run/nginx.pid</span>\n\n<span># Source function library.</span>\n<span>.</span> /etc/rc.d/init.d/functions\n\n<span># Source networking configuration.</span>\n<span>.</span> /etc/sysconfig/network\n\n<span># Check that networking is up.</span>\n<span>[</span> <span>\"<span>$NETWORKING</span>\"</span> <span>=</span> <span>\"no\"</span> <span>]</span> <span>&amp;&amp;</span> <span>exit</span> <span>0</span>\n\n<span>nginx</span><span>=</span><span>\"/usr/sbin/nginx\"</span>\n<span>prog</span><span>=</span><span><span>$(</span><span>basename</span> $nginx<span>)</span></span>\n\n<span>NGINX_CONF_FILE</span><span>=</span><span>\"/etc/nginx/nginx.conf\"</span>\n\n<span>[</span> -f /etc/sysconfig/nginx <span>]</span> <span>&amp;&amp;</span> <span>.</span> /etc/sysconfig/nginx\n\n<span>lockfile</span><span>=</span>/var/lock/subsys/nginx\n\n<span>make_dirs</span><span>(</span><span>)</span> <span>{</span>\n   <span># make required directories</span>\n   <span>user</span><span>=</span><span><span>`</span>$nginx -V <span><span>2</span>></span><span>&amp;1</span> <span>|</span> <span>grep</span> <span>\"configure arguments:.*--user=\"</span> <span>|</span> <span>sed</span> <span>'s/[^*]*--user=\\([^ ]*\\).*/\\1/g'</span> -<span>`</span></span>\n   <span>if</span> <span>[</span> -n <span>\"<span>$user</span>\"</span> <span>]</span><span>;</span> <span>then</span>\n      <span>if</span> <span>[</span> -z <span>\"<span><span>`</span><span>grep</span> $user /etc/passwd<span>`</span></span>\"</span> <span>]</span><span>;</span> <span>then</span>\n         <span>useradd</span> -M -s /bin/nologin <span>$user</span>\n      <span>fi</span>\n      <span>options</span><span>=</span><span><span>`</span>$nginx -V <span><span>2</span>></span><span>&amp;1</span> <span>|</span> <span>grep</span> <span>'configure arguments:'</span><span>`</span></span>\n      <span>for</span> <span>opt</span> <span>in</span> <span>$options</span><span>;</span> <span>do</span>\n          <span>if</span> <span>[</span> <span><span>`</span><span>echo</span> $opt <span>|</span> <span>grep</span> <span>'.*-temp-path'</span><span>`</span></span> <span>]</span><span>;</span> <span>then</span>\n              <span>value</span><span>=</span><span><span>`</span><span>echo</span> $opt <span>|</span> <span>cut</span> -d <span>\"=\"</span> -f <span>2</span><span>`</span></span>\n              <span>if</span> <span>[</span> <span>!</span> -d <span>\"<span>$value</span>\"</span> <span>]</span><span>;</span> <span>then</span>\n                  <span># echo \"creating\" $value</span>\n                  <span>mkdir</span> -p <span>$value</span> <span>&amp;&amp;</span> <span>chown</span> -R <span>$user</span> <span>$value</span>\n              <span>fi</span>\n          <span>fi</span>\n       <span>done</span>\n    <span>fi</span>\n<span>}</span>\n\n<span>start</span><span>(</span><span>)</span> <span>{</span>\n    <span>[</span> -x <span>$nginx</span> <span>]</span> <span>||</span> <span>exit</span> <span>5</span>\n    <span>[</span> -f <span>$NGINX_CONF_FILE</span> <span>]</span> <span>||</span> <span>exit</span> <span>6</span>\n    make_dirs\n    <span>echo</span> -n $<span>\"Starting <span>$prog</span>: \"</span>\n    daemon <span>$nginx</span> -c <span>$NGINX_CONF_FILE</span>\n    <span>retval</span><span>=</span><span>$?</span>\n    <span>echo</span>\n    <span>[</span> <span>$retval</span> -eq <span>0</span> <span>]</span> <span>&amp;&amp;</span> <span>touch</span> <span>$lockfile</span>\n    <span>return</span> <span>$retval</span>\n<span>}</span>\n\n<span>stop</span><span>(</span><span>)</span> <span>{</span>\n    <span>echo</span> -n $<span>\"Stopping <span>$prog</span>: \"</span>\n    killproc <span>$prog</span> -QUIT\n    <span>retval</span><span>=</span><span>$?</span>\n    <span>echo</span>\n    <span>[</span> <span>$retval</span> -eq <span>0</span> <span>]</span> <span>&amp;&amp;</span> <span>rm</span> -f <span>$lockfile</span>\n    <span>return</span> <span>$retval</span>\n<span>}</span>\n\n<span>restart</span><span>(</span><span>)</span> <span>{</span>\n    configtest <span>||</span> <span>return</span> <span>$?</span>\n    stop\n    <span>sleep</span> <span>1</span>\n    start\n<span>}</span>\n\n<span>reload</span><span>(</span><span>)</span> <span>{</span>\n    configtest <span>||</span> <span>return</span> <span>$?</span>\n    <span>echo</span> -n $<span>\"Reloading <span>$prog</span>: \"</span>\n    killproc <span>$prog</span> -HUP\n    <span>retval</span><span>=</span><span>$?</span>\n    <span>echo</span>\n<span>}</span>\n\n<span>force_reload</span><span>(</span><span>)</span> <span>{</span>\n    restart\n<span>}</span>\n\n<span>configtest</span><span>(</span><span>)</span> <span>{</span>\n  <span>$nginx</span> -t -c <span>$NGINX_CONF_FILE</span>\n<span>}</span>\n\n<span>rh_status</span><span>(</span><span>)</span> <span>{</span>\n    status <span>$prog</span>\n<span>}</span>\n\n<span>rh_status_q</span><span>(</span><span>)</span> <span>{</span>\n    rh_status <span>></span>/dev/null <span><span>2</span>></span><span>&amp;1</span>\n<span>}</span>\n\n<span>case</span> <span>\"<span>$1</span>\"</span> <span>in</span>\n    start<span>)</span>\n        rh_status_q <span>&amp;&amp;</span> <span>exit</span> <span>0</span>\n        <span>$1</span>\n        <span>;</span><span>;</span>\n    stop<span>)</span>\n        rh_status_q <span>||</span> <span>exit</span> <span>0</span>\n        <span>$1</span>\n        <span>;</span><span>;</span>\n    restart<span>|</span>configtest<span>)</span>\n        <span>$1</span>\n        <span>;</span><span>;</span>\n    reload<span>)</span>\n        rh_status_q <span>||</span> <span>exit</span> <span>7</span>\n        <span>$1</span>\n        <span>;</span><span>;</span>\n    force-reload<span>)</span>\n        force_reload\n        <span>;</span><span>;</span>\n    status<span>)</span>\n        rh_status\n        <span>;</span><span>;</span>\n    condrestart<span>|</span>try-restart<span>)</span>\n        rh_status_q <span>||</span> <span>exit</span> <span>0</span>\n            <span>;</span><span>;</span>\n    *<span>)</span>\n        <span>echo</span> $<span>\"Usage: <span>$0</span> {start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest}\"</span>\n        <span>exit</span> <span>2</span>\n<span>esac</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br></div></div><h3 id=\"修改部分参数-2\"> 修改部分参数</h3>\n<p>如果你的 Nginx 是通过编译安装的，则需要根据实际安装时的设置，修改启动脚本中的两个参数（大约在第 22 行和第 25 行）：</p>\n<div><pre><code><span># 修改成 Nginx 执行程序的路径，例如我的一般是：/usr/local/nginx/sbin/nginx</span>\n<span>nginx</span><span>=</span><span>\"/usr/sbin/nginx\"</span>\n\n<span># 修改成配置文件的路径，例如我的一般是：/usr/local/nginx/conf/nginx.conf</span>\n<span>NGINX_CONF_FILE</span><span>=</span><span>\"/etc/nginx/nginx.conf\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>还需要修改 PID 文件路径，大约在启动脚本中的第 11 行可以看到被注释的默认路径，在下面加一行，手动指定成和 nginx.conf 文件中的 PID 路径一致即可：</p>\n<div><pre><code>设置成和 nginx.conf 中一致。例如我的一般是：/usr/local/nginx/logs/nginx.pid\n<span># pidfile:     /var/run/nginx.pid</span>\npidfile:     /usr/local/nginx/logs/nginx.pid\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"添加执行权限-2\"> 添加执行权限</h3>\n<p>上述脚本保存为 <code>/etc/init.d/nginx</code>，然后设置文件的执行权限：</p>\n<div><pre><code><span># 给所有用户给予可执行权限</span>\n<span>chmod</span> a+x /etc/init.d/nginx\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>至此就可以通过下面指令控制 Nginx 的启动、停止和重新加载了：</p>\n<div><pre><code><span># 启动</span>\n/etc/init.d/nginx start\n\n<span># 停止</span>\n/etc/init.d/nginx stop\n\n<span># 重新加载配置</span>\n/etc/init.d/nginx reload\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"添加至开机自启动-2\"> 添加至开机自启动</h3>\n<p>现在将 Nginx 服务加入 chkconfig 管理列表：</p>\n<div><pre><code><span># 添加 Nginx 启动脚本为 chkconfig 管理的一个服务</span>\n<span>chkconfig</span> --add /etc/init.d/nginx\n\n<span># 将 Nginx 加入开机自启</span>\n<span>chkconfig</span> /etc/init.d/nginx on\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>当然了，如果需要关闭开机启动的功能：</p>\n<div><pre><code><span># 查看该服务进程状态</span>\n<span>chkconfig</span> --list nginx\n\n<span># 关闭 Nginx 开机自启</span>\n<span>chkconfig</span> /etc/init.d/nginx off\n\n<span># 删除 chkconfig 管理的的 Nginx 启动服务（如果确实不需要了）</span>\n<span>chkconfig</span> --del /etc/init.d/nginx\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"开机自启脚本提供的快捷命令\"> 开机自启脚本提供的快捷命令</h3>\n<p>通过 Nginx 开机自启脚本本身提供了一些 Nginx 常用操作的快捷命令，一旦我们通过这个脚本实现开机自启后，就可以通过这些快捷命令来操作 Nginx 了：</p>\n<div><pre><code><span># 启动 Nginx</span>\n/etc/init.d/nginx start\n\n<span># 重新加载 Nginx 配置</span>\n/etc/init.d/nginx reload\n\n<span># 停止 Nginx</span>\n/etc/init.d/nginx stop\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>这些命令通过看脚本代码就能找到。</p>\n<h2 id=\"centos-7-x-设置开机自启\"> CentOS 7.x 设置开机自启</h2>\n<blockquote>\n<p>以下所有命令，如果你是 root 账户，直接执行即可，不是的话前面加 <code>sudo</code> 获取权限。</p>\n</blockquote>\n<p>在 CentOS 7.x 版本的系统开始，就不太好通过 chkconfig + <a href=\"https://www.nginx.com/resources/wiki/start/topics/examples/redhatnginxinit/\" target=\"_blank\" rel=\"noopener noreferrer\">Red Hat NGINX Init Script</a> 的方式来设置 Nginx 的开机启动了。</p>\n<p>因为会留下了一个 bug：通过 <code>/etc/init.d/nginx</code> 脚本方式来控制 Nginx 的启动、停止时，start 一直卡着（实际端口是开启了，必须通过 Ctrl + C 强制关闭），stop 不生效（提示成功，但是端口没关闭）。</p>\n<p>那么对于 CentOS 7.x 系统，可以通过 systemd 来管理 Nginx。</p>\n<h3 id=\"建立服务文件\"> 建立服务文件</h3>\n<p>新建文件：</p>\n<div><pre><code><span>vim</span> /usr/lib/systemd/system/nginx.service\n</code></pre>\n<div><span>1</span><br></div></div><p>往该文件内写入以下内容（内容模版参考官网 <a href=\"https://www.nginx.com/resources/wiki/start/topics/examples/systemd/\" target=\"_blank\" rel=\"noopener noreferrer\">NGINX systemd service file</a>）：</p>\n<div><pre><code><span>[</span>Unit<span>]</span>\n<span>Description</span><span>=</span>The NGINX HTTP and reverse proxy server\n<span>After</span><span>=</span>syslog.target network-online.target remote-fs.target nss-lookup.target\n<span>Wants</span><span>=</span>network-online.target\n\n<span>[</span>Service<span>]</span>\n<span>Type</span><span>=</span>forking\n<span>PIDFile</span><span>=</span>/run/nginx.pid\n<span>ExecStartPre</span><span>=</span>/usr/sbin/nginx -t\n<span>ExecStart</span><span>=</span>/usr/sbin/nginx\n<span>ExecReload</span><span>=</span>/usr/sbin/nginx -s reload\n<span>ExecStop</span><span>=</span>/bin/kill -s QUIT <span>$MAINPID</span>\n<span>PrivateTmp</span><span>=</span>true\n\n<span>[</span>Install<span>]</span>\n<span>WantedBy</span><span>=</span>multi-user.target\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>文件内容解释：</p>\n<div><pre><code><span>[</span>Unit<span>]</span>:服务的说明\nDescription:描述服务\nAfter:描述服务类别\n\n<span>[</span>Service<span>]</span>服务运行参数的设置\n<span>Type</span><span>=</span>forking是后台运行的形式\nExecStart为服务的具体运行命令\nExecReload为重启命令\nExecStop为停止命令\n<span>PrivateTmp</span><span>=</span>True表示给服务分配独立的临时空间\n注意：启动、重启、停止命令全部要求使用绝对路径\n\n<span>[</span>Install<span>]</span>服务安装的相关设置，可设置为多用户\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id=\"修改部分参数-3\"> 修改部分参数</h3>\n<p>如果你的 Nginx 是通过编译安装的，则需要根据实际安装时的设置，修改文件中的部分参数，修改后的示例如下：</p>\n<div><pre><code><span>[</span>Unit<span>]</span>\n<span>Description</span><span>=</span>The NGINX HTTP and reverse proxy server\n<span>After</span><span>=</span>syslog.target network-online.target remote-fs.target nss-lookup.target\n<span>Wants</span><span>=</span>network-online.target\n\n<span>[</span>Service<span>]</span>\n<span>Type</span><span>=</span>forking\n<span>PIDFile</span><span>=</span>/usr/local/nginx/logs/nginx.pid\n<span>ExecStartPre</span><span>=</span>/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf\n<span>ExecStart</span><span>=</span>/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\n<span>ExecReload</span><span>=</span>/usr/local/nginx/sbin/nginx -s reload\n<span>ExecStop</span><span>=</span>/usr/local/nginx/sbin/nginx -s quit\n<span>PrivateTmp</span><span>=</span>true\n\n<span>[</span>Install<span>]</span>\n<span>WantedBy</span><span>=</span>multi-user.target\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id=\"添加执行权限-3\"> 添加执行权限</h3>\n<p>给上述文件添加执行权限：</p>\n<div><pre><code><span>chmod</span> +x /usr/lib/systemd/system/nginx.service\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"添加至开机自启动-3\"> 添加至开机自启动</h3>\n<p>设置开机自启动：</p>\n<div><pre><code>systemctl <span>enable</span> nginx.service\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"nginx-服务管理\"> Nginx 服务管理</h3>\n<p>此时可以使用一些快捷命令进行 Nginx 服务管理：</p>\n<div><pre><code><span># Nginx 启动</span>\nsystemctl start nginx.service\n\n<span># 查看 Nginx 服务当前状态</span>\nsystemctl status nginx.service\n\n<span># Nginx 重载</span>\nsystemctl reload nginx.service\n\n<span># Nginx 停止</span>\nsystemctl stop nginx.service\n\n<span># 重新启动 Nginx 服务</span>\nsystemctl restart nginx.service\n\n<span># 停止 Nginx 的开机自启动</span>\nsystemctl disable nginx.service\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>Nginx 启动日志查看：</p>\n<div><pre><code>journalctl -f -u nginx.service\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"systemd-提供的一些命令\"> systemd 提供的一些命令</h3>\n<p>查看所有已启动的服务：</p>\n<div><pre><code>systemctl list-units --type<span>=</span>service\n</code></pre>\n<div><span>1</span><br></div></div><p>命令集合：</p>\n<div><pre><code><span># 查看所有开机启动项</span>\nsystemctl list-unit-files --type<span>=</span>service <span>|</span> <span>grep</span> enabled\n\n<span># 查询服务是否开机启动</span>\nsystemctl is-enabled servicename.service\n\n<span># 开机运行服务</span>\nsystemctl <span>enable</span> *.service\n\n<span># 取消开机运行</span>\nsystemctl disable *.service\n\n<span># 启动服务</span>\nsystemctl start *.service\n\n<span># 停止服务</span>\nsystemctl stop *.service\n\n<span># 重启服务</span>\nsystemctl restart *.service\n\n<span># 重新加载服务配置文件</span>\nsystemctl reload *.service\n\n<span># 查询服务运行状态</span>\nsystemctl status *.service\n\n<span># 显示启动失败的服务</span>\nsystemctl --failed\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>注：<code>*</code> 代表某个服务的名字，如 http 的服务名为 httpd。</p>\n<h2 id=\"参考文档\"> 参考文档</h2>\n<ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html\" target=\"_blank\" rel=\"noopener noreferrer\">Systemd 入门教程：命令篇</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-07-04T05:20:50.000Z",
      "date_modified": "2022-03-04T09:58:34.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Nginx 的卸载",
      "url": "https://www.fedbook.cn/basic-skills/nginx/uninstallation-of-nginx/",
      "id": "https://www.fedbook.cn/basic-skills/nginx/uninstallation-of-nginx/",
      "content_html": "<h1 id=\"nginx-的卸载\"> Nginx 的卸载</h1>\n<p>我一般都是通过源码编译安装的方式，所以这里主要介绍如何卸载编译安装的 Nginx。</p>\n<p>编译安装的 Nginx 卸载非常方便，直接将 Nginx 的安装目录删除即可，同时可以把 Nginx 使用的日志目录和临时目录一并删除。</p>\n<h2 id=\"停止-nginx-服务\"> 停止 Nginx 服务</h2>\n<p>首先输入命令 <code>ps -ef | grep nginx</code> 检查一下 Nginx 服务是否在运行，在卸载之前需要先停止服务。</p>\n<h2 id=\"删除-nginx-安装目录\"> 删除 Nginx 安装目录</h2>\n<div><pre><code><span># 查找安装路径</span>\n<span>whereis</span> nginx\n\n<span># 如果是按照我上一篇介绍的步骤安装，删除安装目录的命令如下：</span>\n<span>rm</span> -rf /usr/local/nginx\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"ubuntu-删除-nginx-自启动\"> Ubuntu 删除 Nginx 自启动</h2>\n<p>如果安装了 Nginx 自启动（后面章节会讲），按照如下命令将自启动脚本删除。</p>\n<div><pre><code><span># 进入 /etc/init.d 查看哪些服务进程是开机自启动的</span>\n<span>cd</span> /etc/init.d\n<span>ls</span>\n\n<span># 取消 Nginx 开机启动</span>\nupdate-rc.d -f nginx remove\n\n<span># 删除 Nginx 自启动脚本</span>\n<span>rm</span> /etc/init.d/nginx\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id=\"centos-7-x-删除-nginx-自启动\"> CentOS 7.x 删除 Nginx 自启动</h2>\n<p>在 CentOS 7.x 中，如果你跟我一样是通过 systemd 实现 Nginx 自启动的（后面章节会讲），按照如下命令将自启动脚本删除。</p>\n<div><pre><code><span># 查看开机启动项里有没有 nginx.service</span>\nsystemctl list-unit-files --type<span>=</span>service <span>|</span> <span>grep</span> enabled\n\n<span># 停止 Nginx 服务进程</span>\nsystemctl stop nginx.service\n\n<span># 使 Nginx 开机不启动</span>\nsystemctl disable nginx.service\n\n<span># 删除 Nginx 服务文件</span>\n<span>rm</span> /usr/lib/systemd/system/nginx.service\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id=\"find-查找相关文件并删除\"> find 查找相关文件并删除</h2>\n<p>查找并删除 Nginx 相关文件，如日志目录和临时目录等。</p>\n<div><pre><code><span># 查找相关文件</span>\n<span>find</span> / -name nginx\n\n<span># 判断是否能删除后，执行删除命令</span>\n<span>..</span>.\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>（完）</p>\n",
      "date_published": "2021-07-02T13:02:41.000Z",
      "date_modified": "2022-03-04T09:58:34.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "课外学习",
      "url": "https://www.fedbook.cn/extracurricular/",
      "id": "https://www.fedbook.cn/extracurricular/",
      "content_html": "<h1 id=\"课外学习\"> 课外学习</h1>\n<p><strong>职业技能</strong>：</p>\n<p>合抱之木，生于毫末；九层之台，起于累土；千里之行，始于足下。专注于自己的本职领域，不断学习，夯实基础，寻求能力的突破。</p>\n<p><strong>多元思维</strong>：</p>\n<p>这个时代的高手，一定是具备跨界学习能力的人。大学四年学什么专业不重要，重要的是要有发现问题和解决问题的能力。正如查理芒格所提倡的那样：通过不断学习众多学科的知识来形成多元思维模型。</p>\n<div style=\"text-align: right\">\n  <svg t=\"1636363623817\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"2697\" width=\"64\" height=\"64\"><path d=\"M853.333333 853.333333c-147.2 0-341.333333 85.333333-341.333333 85.333334V469.333333s192-85.333333 384-85.333333l-42.666667 469.333333z\" fill=\"#5C6BC0\" p-id=\"2698\"></path><path d=\"M170.666667 853.333333c147.2 0 341.333333 85.333333 341.333333 85.333334V469.333333s-192-85.333333-384-85.333333l42.666667 469.333333z\" fill=\"#7986CB\" p-id=\"2699\"></path><path d=\"M512 256m-170.666667 0a170.666667 170.666667 0 1 0 341.333334 0 170.666667 170.666667 0 1 0-341.333334 0Z\" fill=\"#FFB74D\" p-id=\"2700\"></path><path d=\"M874.666667 682.666667h21.333333c12.8 0 21.333333-8.533333 21.333333-21.333334v-85.333333c0-12.8-8.533333-21.333333-21.333333-21.333333h-21.333333c-36.266667 0-64 27.733333-64 64s27.733333 64 64 64zM149.333333 554.666667H128c-12.8 0-21.333333 8.533333-21.333333 21.333333v85.333333c0 12.8 8.533333 21.333333 21.333333 21.333334h21.333333c36.266667 0 64-27.733333 64-64s-27.733333-64-64-64z\" fill=\"#FFB74D\" p-id=\"2701\"></path></svg>\n</div>\n",
      "date_published": "2021-11-08T09:59:13.000Z",
      "date_modified": "2021-11-09T07:30:10.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "产品与人性 | 28个心理学效应",
      "url": "https://www.fedbook.cn/extracurricular/product-and-humanity/",
      "id": "https://www.fedbook.cn/extracurricular/product-and-humanity/",
      "content_html": "<h1 id=\"产品与人性-28个心理学效应\"> 产品与人性 | 28个心理学效应</h1>\n<blockquote>\n<p>普通的产品解决问题，中等的产品服务用户，优秀的产品洞察人性。<br>\n心理学效应在产品中的应用，可以让产品经理向洞察人性更进一步。</p>\n</blockquote>\n<h2 id=\"前言\"> 前言</h2>\n<p>这是从数百个心理学效应中筛选出的产品设计中常用到的 28 个心理学效应，并且介绍了这些效应在产品中的一小部分应用场景。</p>\n<h2 id=\"产品经理必懂的-28-个心理学效应\"> 产品经理必懂的 28 个心理学效应</h2>\n<h3 id=\"_1-晕轮效应\"> 1. 晕轮效应</h3>\n<p><strong>定义</strong>：在生活中，我们一旦对某人的某种特征形成好或坏的印象后，在看待他的其他品质时，也会倾向于带上相似的态度。即「喜欢一个人就会喜欢他的一切」。</p>\n<p><strong>产品中的应用</strong>：这里有一个很好的例子就是小米。</p>\n<p>大家都知道小米手机的利润空间是很低的，而小米的核心策略就是通过手机聚集一批高忠诚度的「米粉」，米粉对小米的产品形成「价格厚道，质量上乘」的用户认知以后，小米再通过生态链产品及软件产品盈利。</p>\n<p>数据显示一个米粉购买小米商品（包括生态链）的件数是远远高于友商的，即做到了「薄利多销」。</p>\n<h3 id=\"_2-首因效应\"> 2. 首因效应</h3>\n<p><strong>定义</strong>：也称最初效应，在总体印象形成上，最初获得的信息比后来获得的信息影响更大的现象，也就是第一印象几乎决定了别人对你的总体印象。</p>\n<p><strong>产品中的应用</strong>：这里有一个很好的例子，就是拼多多。</p>\n<p>拼多多一开始给大家的印象就是假货居多，所以即便是现在已经花了很大的力度去打假，依然有很多人因为假货拒绝使用拼多多，即便拼多多的东西真的很便宜实惠。</p>\n<p>这是因为用户已经形成了初始认知，短期内难以改变，这也是为什么京东一直宣传正品行货的理念来不断强化用户认知的原因。</p>\n<h3 id=\"_3-登门槛效应\"> 3. 登门槛效应</h3>\n<p><strong>定义</strong>：又称得寸进尺效应，是指一个人一旦接受了他人的一个微不足道的要求，为了避免认知上的不协调，或想给他人以前后一致的印象，就有可能接受更大的要求。</p>\n<p>在一般情况下，人们都不愿接受较高较难的要求，因为它费时费力又难以成功。相反，人们却乐于接受较小的、较易完成的要求，在实现了较小的要求后，人们才慢慢地接受较大的要求。</p>\n<p><strong>产品中的应用</strong>：要设置合理的参与门槛，以方便目标用户参与，减少流失。当然也不是说参与门槛越低越好，比如一些优质的内容社区肯定不能谁想发文章就可以乱发，肯定是要经过审核以保证内容的优质性。</p>\n<p>所以各位PM要根据自己的目标人群设置合理的参与门槛，如果是普适性活动，建议最开始的参与门槛一定要足够低，甚至连登录都可以不要，采用一键获取微信OpenID等方式替代登录。</p>\n<h3 id=\"_4-巴纳姆效应\"> 4. 巴纳姆效应</h3>\n<p><strong>定义</strong>：巴纳姆效应认为人们总是特别容易相信一种对于自己的笼统描述。即使这种描述十分空洞，但人们还是确信这就是自己真正的人格面貌。</p>\n<p>比如白羊座的人渴望一种稳定的社交关系，白羊座的人一听就觉得和自己很符合。但是仔细一想，谁不渴望一种稳定的社交关系呢？所以这个笼统描述是普适的。</p>\n<p><strong>产品中的应用</strong>：笔者认为主要是存在于用户调研中，用户往往不知道自己的真实想法是什么。因此有经验的产品经理或者用研人员会客观给用户一些发散性的提示，防止出现主观的引导而让用户误认为自己有这样的需求。</p>\n<p>而一些小白产品经理和用研人员经常会犯这样的错误，比如自己想做一个信息流的产品，就问用户：你是否有时候会觉得无聊，想看一些好玩有趣的事情打发时间？</p>\n<p>得到了用户肯定的回答之后，就觉得信息流产品是用户的痛点。但实际上这里的痛点是「用户有时候会觉得无聊」——信息流产品只是解决这个痛点的一个方式，但不一定是最好的方式，因为用户自己也不知道自己的需求是什么。</p>\n<h3 id=\"_5-旁观者效应\"> 5. 旁观者效应</h3>\n<p><strong>定义</strong>：旁观者效应也叫「责任分散效应」，即他人的在场使得个体采取某种行动的可能性降低，也可以理解成「原本属于一个人的责任被主观分散到其它在场者身上了」。</p>\n<p><strong>产品中的应用</strong>：在裂变分享的时候，我们应该采取一些措施刺激和激励用户分享到个人，而不是分享到群里。因为如果不是非常亲密的群，群成员这个时候大多会出现「旁观者效应」，即大多处于观望状态，不会采取行动。</p>\n<h3 id=\"_6-二八法则\"> 6.  二八法则</h3>\n<p><strong>定义</strong>：二八定律又名 80/20 定律、是 19 世纪末 20 世纪初意大利经济学家帕累托发现的。他认为，在任何一组东西中，最重要的只占其中一小部分，约 20%，其余 80% 尽管是多数，却是次要的，因此又称二八定律。</p>\n<p><strong>产品中的应用</strong>：往往 20% 的用户会创造 80% 的价值。尤其是在电商领域中，基本上 80% 的 GMV 都是由 20% 的忠实用户贡献的。</p>\n<p>因此产品经理在设计产品逻辑的时候，要重点想以下两个问题：如何集中精力服务好 20% 的高价值用户，以保持粘性？如何将剩下 80% 的普通用户转化成高价值用户？</p>\n<h3 id=\"_7-搭便车效应\"> 7. 搭便车效应</h3>\n<p><strong>定义</strong>：搭便车效应指的是某个成员为集体所做出的努力使得全体成员都可能获利，但成本却由这个成员自己承担。</p>\n<p><strong>产品中的应用</strong>：不知道大家还记不记得去年的淘宝双 11 合伙组战队集能量的玩法，声势浩大，也取得了很好的效果。</p>\n<p>其中有一个玩法设计非常巧妙：最后的现金红包并不是均分的，而是按照成员对团队的贡献发放对应的奖励。事后有不少人吐糟自己的队友里面有浑水摸鱼的，组了战队却不付出努力。</p>\n<p>还好最后不是按照人头均分的奖励，不然那些真正付出努力的用户肯定会有负面情绪，不利于下一次活动的开展。</p>\n<h3 id=\"_8-结伴效应\"> 8. 结伴效应</h3>\n<p><strong>定义</strong>：个人活动由于有他人参加导致效率变化。有两个表现：由于有他人增加会导致效率提高，或者是由于有他人增加导致效率下降。</p>\n<p><strong>产品中的应用</strong>：组队、拼团等玩法就是利用了这个效应。</p>\n<p>拼团在一定程度上对用户有一定激励：因为可以和好朋友一起参与活动；而拼团本身也是一种限制：因为如果拼团成功，一个人的撤销、暂停等行为势必会对另一个人造成影响，用户的犯错成本变高。</p>\n<p>在设计产品的过程中，可以根据活动的玩法让用户适当结伴，增加用户的参与积极性或者是提高用户犯错成本。</p>\n<h3 id=\"_9-社会刻板效应\"> 9. 社会刻板效应</h3>\n<p><strong>定义</strong>：把一群人的特征加以总结，然后把这个特征强加到这个群体中的每一个人身上，忽略个别差异。比如「南方人都细腻，北方人都豪爽；男人都勇敢，女人都细腻」等观点。</p>\n<p><strong>产品中的应用</strong>：这一点常发生在产品经理对用户分层对待的时候，过分看重整体特征，而忽略了个体差异。</p>\n<p>比如认为三四线用户的消费能力一定比一二线城市低，对商品的偏好一定是低价优先，质量其次；而一二线的用户一定都注重品质，对价格不敏感等等。</p>\n<p>而实际上每个个体都是有差异的——虽然城市的线级分布一定程度上可以表现消费能力；但三四线依然存在一大批高收入高消费的人群，而一二线也存在一大批低收入低消费的人群。</p>\n<p>因此重点在于多维度对用户分层，而不是单一维度用固有印象对待所有用户。</p>\n<h3 id=\"_10-近因效应\"> 10. 近因效应</h3>\n<p><strong>定义</strong>：也称最近效应，在总体印象上，新近获得的信息比原来获得的信息影响更大的现象。</p>\n<p><strong>产品中的应用</strong>：虽然大家对京东的原有印象是正品行货，但是当年出现假酒事件也让很多用户瞬间对京东「粉转路」，这就是近因效应的体现。</p>\n<p>一旦出现这类问题，除了积极采取各项措施应对之外，还有一个非常有效的方法：时间。</p>\n<p>既然是「近」因效应，随着时间的流逝，「近」也早晚会变成「远」，当用户都快要忘记的时候，采取一些正向的措施再次引发「近因效应」，就可以最大程度将用户的认知带回到现在。</p>\n<p>也有很多出现负面新闻的明星用这个效应进行公关，即出了负面新闻就潜水一段时间，等到用户基本忘记了，再以正面的形象复出。</p>\n<h3 id=\"_11-霍桑效应\"> 11. 霍桑效应</h3>\n<p><strong>定义</strong>：又称霍索恩效应，是当观察者知道自己成为被观察对象，从而改变行为倾向的反应。</p>\n<p><strong>产品中的应用</strong>：在做用户调研的时候，除了调研员和用户口头交流之外，在单向玻璃的另外一面，还隐藏着几位专业的观察员，通过高清摄像头仔细观察着用户的眼神、动作、神态等细节，从而给出更加准确的判断。</p>\n<p>而用户往往不知道还有观察员的存在，因此作出的反应会更加客观可信。这样做的目的就是为了防止霍桑效应的出现，导致最后的结论不够正确。</p>\n<h3 id=\"_12-鸟笼逻辑\"> 12. 鸟笼逻辑</h3>\n<p><strong>定义</strong>：挂一个漂亮的鸟笼在房间里最显眼的地方，过不了几天，主人一定会做出下面两个选择之一：把鸟笼扔掉，或者买一只鸟回来放在鸟笼里。这就是惯性思维的体现。</p>\n<p><strong>产品中的应用</strong>：这个思路最好的例子是拍立得，大家都知道拍立得机身的价格并不贵，但是相纸却非常昂贵。而一旦买了某个拍立得，由于相纸只能使用该品牌的相纸，而产生巨大的后续消费。</p>\n<p>同样电商平台经常会给用户发一些优惠券、现金补贴，用户领取了之后觉得占到了便宜，就会下单。这也是利用了这个思维：给用户发一个鸟笼，用户肯定会想着如何利用这个鸟笼。</p>\n<h3 id=\"_13-破窗效应\"> 13. 破窗效应</h3>\n<p><strong>定义</strong>：心理学的研究上有个现象叫做「破窗效应」，就是说，一个房子如果窗户破了，没有人去修补，隔不久，其它的窗户也会莫名其妙被人打破。</p>\n<p><strong>产品中的应用</strong>：个人认为这个效应的应用范围非常广泛，比如在客诉的处理中。如果一个用户投诉没有得到及时的处理，或许还可以正常运作，但是当客诉积累到一个临界值，就会爆发，可能引起大面积用户投诉。</p>\n<p>所以临界值是破窗效应的关键，也是留给产品经理修改Bug或者作出运营调整的「安全时间」。</p>\n<h3 id=\"_14-凡勃伦效应\"> 14. 凡勃伦效应</h3>\n<p><strong>定义</strong>：指消费者对一种商品需求的程度因其标价较高而增加。它反映了人们进行挥霍性消费的心理愿望。</p>\n<p>商品价格定得越高，越能受到消费者的青睐，商品价格越高消费者反而越愿意购买的消费倾向。最早由美国经济学家凡勃伦注意到，因此被命名为「凡勃伦效应」。</p>\n<p><strong>产品中的应用</strong>：对于 GMV 导向的产品，这个原则或许能派上用处，很多奢侈品也是利用了这个效应。</p>\n<h3 id=\"_15-马斯洛需求层次理论\"> 15. 马斯洛需求层次理论</h3>\n<p><strong>定义</strong>：马洛斯需求层次理论中说明人的需求有五个层次。即：生理需求、安全需求、爱和归属的需求、尊重需求、自我实现的需求。这五层需求从低到高，而当低层的需求满足了以后才会继续去追逐高层的需求。</p>\n<p><strong>产品中的应用</strong>：这个理论的用途可以说是非常非常广泛，最根本的产品定位如何定也需要借鉴这个表格。</p>\n<p>比如 XX 同城交友软件可能就定位于生理需求，知乎可能定位为尊重 &amp; 自我实现需求。</p>\n<p>再比如一些好的游戏，可以将这些需求贯穿游戏主人翁的情节线路，让游戏获得更好的可沉浸感。用户可以在游戏里建立住所，获得安全的保障；还可以拜师交友恋爱，满足爱和归属的需求。</p>\n<p>同时各类游戏段位的称号如王者，可以让用户获得尊重。</p>\n<h3 id=\"_16-边际效应\"> 16. 边际效应</h3>\n<p><strong>定义</strong>：当用户获得 &amp; 购买 &amp; 消费某种物品的数量越多，则愿意为这件物品支付或者对其买账的成本及意愿也越低，此即所谓的边际效应。例如当人吃第一个包子时感觉是最好的，但当包子越吃越多，肚子越来越饱，包子所带来的满足感也就越小。</p>\n<p><strong>产品中的应用</strong>：给用户的激励要适当，过分的激励会导致用户愿意付出的成本更低，也就是把用户养「刁」了；且奖励的种类可以丰富一些，让用户不至于疲劳。</p>\n<h3 id=\"_17-超限效应\"> 17. 超限效应</h3>\n<p><strong>定义</strong>：美国著名作家马克吐温有次在教堂听牧师演讲。最初他觉得牧师讲得使人感动，就打算捐献自己所有的钱；之后由于牧师喋喋不休，他很不耐烦，就打算就捐一点钱；直到最后他的耐心终于耗尽，决定一分钱也不捐；甚至到后面由于过于气愤，不但不捐钱，还偷了牧师 2 块钱。后人通过此故事领悟出超限效应，这个效应说明，一旦刺激过多、过强、过久，不但不会产生效果，相反还会让人产生不耐烦等逆反心理。</p>\n<p><strong>产品中的应用</strong>：产品设计中有适当的阶梯制度和及时性奖励肯定是必要的，但是如果阶梯奖励差距太大，难度太高，一旦超过某个阀值，就会让用户产生焦躁、不耐烦等逆反心理。</p>\n<p>因此在设计产品的时候，一定要注意各项指标不要超过用户的阈值，否则可能适得其反。</p>\n<h3 id=\"_18-鲶鱼效应\"> 18. 鲶鱼效应</h3>\n<p><strong>定义</strong>：挪威渔民在海上捕捞沙丁鱼，由于沙丁鱼没有刺激和活动会导致缺氧而很快死去，于是渔民会在鱼群中放几条鲶鱼，而鲶鱼是沙丁鱼的天敌，沙丁鱼为了躲避鲶鱼不得不到处逃窜，这个结果导致沙丁鱼不会因为窒息而死亡。于是后人将其现象称为鲶鱼效应。</p>\n<p><strong>产品中的应用</strong>：这一效应是相对于上面的超限效应来说的，超限制效应说明长时间的紧张感带来的压力给用户的危害，而鲶鱼效应正好相反。</p>\n<p>这个效应主要说明在适当的竞争和紧张状态下，能更好发挥人的能力和主观能动性。</p>\n<h3 id=\"_19-暗示效应\"> 19. 暗示效应</h3>\n<p><strong>定义</strong>：暗示效应指利用含蓄、抽象、诱导、欺骗等间接方法影响人的心理、思想、以及行为，从而诱导他人按照自己想要的方法去行动，且该行动符合暗示者的期望目标的效应。例如三国时期曹操望梅止渴的故事，就是运用暗示效应的典型案例。</p>\n<p><strong>产品中的应用</strong>：最典型的就是各类页游宣传时候用的「露骨的美女照」，带有强烈的暗示效应。</p>\n<p>还有就是各类产品定价总喜欢定为 9.9 元、8.88 元等。虽然 9.9 元和 10 元只差了 0.1 元，但是这类暗示会让用户误以为很划算。</p>\n<p>电商的商详页面头部也经常会出现虚拟的「XXX 刚刚购买了此商品」轮播信息流，就是为了给用户暗示「这个商品很划算，很多人买」。</p>\n<h3 id=\"_20-留白效应\"> 20. 留白效应</h3>\n<p><strong>定义</strong>：在小说、绘画、漫画、电影、雕塑等艺术创作过程中，适当的留白，作品会留给读者想象和再创作的空间，在读者思考的过程中，会获得对作品更深层次的理解和把握，从而给作品取得良好效果，这就是留白效应（又称为空白效应）。</p>\n<p><strong>产品中的应用</strong>：世界上没有一样东西是完美无缺的，产品也一样，没有人可以做出完美无缺的产品。因此可以把小部分的主动权交给用户，根据用户的发挥来改进产品。</p>\n<p>我们经常看到有人吐槽某某产品的某个体验做的不好，但是又一直不改。我有时候会想：是不是产品经理设计的时候故意留下一下小瑕疵，让用户自己去发现？</p>\n<p>当你愿意去为了一个小细节吹毛求疵的时候，那说明你对这个产品已经像孩子一样，你希望它更好，这个时候用户对产品的忠诚度就极其高了。</p>\n<p>所以别总想着给用户最好的体验，很多时候要反过来想：是不是可以让用户为我们的产品做一点付出？</p>\n<h3 id=\"_21-紫格尼克记忆效应\"> 21. 紫格尼克记忆效应</h3>\n<p><strong>定义</strong>：心理学家布鲁玛·紫格尼克曾经给一群孩子布置了作业，她只让一部分孩子完成作业，另一部分则故意令其中途停顿。</p>\n<p>之后经过测试，中途没完成作业的孩子对本次作业的内容记忆犹新，而完成作业的孩子大多忘记了本次作业内容。这个试验的结论是：因为完成欲望得到满足，故此人们对已经完成的工作比较健忘；而尚未完成的工作因为完成欲望没有得到满足，导致心里面放不下，并会倾向于继续完成它，于是脑袋中时刻记忆着这些内容。此即为紫格尼克效应。</p>\n<p><strong>产品中的应用</strong>：你一定想不到，微信聊天列表页底部Tab右上角的未读消息红色数字的提示，其实就是利用了这个效应。用户发现自己还有未完成阅读的消息，会更加倾向于去完成。同时各类游戏中设计的「进度条」，也让用户更有动力去完成。</p>\n<h3 id=\"_22-色彩心理学\"> 22. 色彩心理学</h3>\n<p><strong>定义</strong>：色彩可以影响到人的方方面面，例如知觉、感情、视觉、记忆、象征、情绪等，应用也相当广泛，包括艺术、游戏、社会学等方面均有应用。色彩往往带有心理学的暗示作用，在应用上更可以用颜色区分重要的信息。</p>\n<p><strong>产品中的应用</strong>：娱乐类产品，可能红黄色等比较青春靓丽的颜色比较适合；教育类产品，那可能简约大气的白色、蓝色等比较适合；电商类产品，那可能大红大紫等热闹促销感很强的颜色比较适合。</p>\n<h3 id=\"_23-达维多定律\"> 23. 达维多定律</h3>\n<p><strong>定义</strong>：1992 年，曾任职于英特尔的副总裁威廉·达维多提出了一个观点，他认为：一家企业如果要在市场上占据主导地位，就必须第一个开发出新一代产品。如果被动的第二或者第三个推出新产品，那么获得的利益肯定就远不如第一家企业。此即为达维多定律。</p>\n<p><strong>产品中的应用</strong>：一款好的产品，一定要是某个领域的引领者，而不是追随者。当然这里并不是让你做出一款独一无二、前无古人后无来者的产品出来，这也不现实。</p>\n<p>最好的方式应该是站在巨人的肩膀上进行再次创新，找到自己的核心竞争力和创新点，并且是足够颠覆性的创新点。</p>\n<h3 id=\"_24-名人效应\"> 24. 名人效应</h3>\n<p><strong>定义</strong>：名人所引起的扩大影响和引起注意的效应，即为名人效应。</p>\n<p><strong>产品中的应用</strong>：找十个普通用户，不如找到一个 KOL（意见领袖）。</p>\n<h3 id=\"_25-狮羊效应\"> 25. 狮羊效应</h3>\n<p><strong>定义</strong>：狮羊效应源于拿破仑的一句名言：一只狮子带领九十九只绵羊，可以打败一只绵羊带领的九十九只狮子。这个效应说明了主帅的重要性。</p>\n<p><strong>产品中的应用</strong>：在产品开发中，外行领导内行，外行干预研发的现象可谓屡见不鲜。最常见的情况是，设计过程中老板或者不懂行的上级突然拍脑袋，想要加入某个创意；或者在开发中途更改开发方向，导致原有设计全部作废，必须重新开始设计，从而导致项目延期……类似这类情况可谓屡见不鲜。</p>\n<p>正所谓兵熊熊一个，将熊熊一窝，公司的老板不行，那么是很难做出成绩的，项目也很难保证成功。选公司先看老板，特别是小公司的老板尤其重要（与之相对的大公司，则是看项目的直属上级）。</p>\n<h3 id=\"_26-莫扎特效应\"> 26. 莫扎特效应</h3>\n<p><strong>定义</strong>：1993 年，美国戈登·肖教授进行了一项实验。他让他的学生在听完莫扎特的歌曲后，立即进行空间推理测验。试验结果表明，他的学生在听完莫扎特的歌曲后，空间推理能力获得了明显提高。此即为莫扎特效应。</p>\n<p>这个效应表明音乐具有很重要的魔力，可以有效的运用在人的大脑的潜力开发、影响人的情绪等方面。</p>\n<p><strong>产品中的应用</strong>：可以利用音效让用户获得更好的参与感，比如点击金币会有钱收入口袋的清脆响等。</p>\n<h3 id=\"_27-长尾效应\"> 27. 长尾效应</h3>\n<p><strong>定义</strong>：从人们需求的角度来看，大多数的需求会集中在头部，而这部分我们可以称之为流行；而分布在尾部的需求是个性化的，零散的小量的需求。而这部分差异化的、少量的需求会在需求曲线上面形成一条长长的「尾巴」。而所谓长尾效应就在于它的数量上，将所有非流行的市场累加起来就会形成一个比流行市场还大的市场。</p>\n<p><strong>产品中的应用</strong>：不要过分集中于头部的大需求，可以找到需求体量没有那么大，但是也足够支撑起一个伟大的产品的需求和人群进行设计。比如聚美优品，就是找到了一个巨头没有那么细致运营，但是也足够大的美妆电商需求，这类需求相对而言更容易成功。</p>\n<h3 id=\"_28-半途效应\"> 28. 半途效应</h3>\n<p><strong>定义</strong>：半途效应是指在激励过程中达到半途时，由于心理因素及环境因素的交互作用而导致的对于目标行为的一种负面影响。</p>\n<p>大量的事实表明，人的目标行为的中止期多发生在「半途」附近，在人的目标行为过程的中点附近是一个极其敏感和极其脆弱的活跃区域。导致半途效应的原因主要有两个，一是目标选择的合理性，目标选择的越不合理越容易出现半途效应；二是个人的意志力，意志力越弱的人越容易出现半途效应。</p>\n<p><strong>产品中的应用</strong>：所有的理论都有两面性，比如半途效应：一方面我们可以设置合理的目标，让更多的用户可以达到，但是另一方面也有的产品形态恰恰是利用了这个效应，让更多的人达不到。</p>\n<p>比如拼多多的领现金活动，拉 X 个好友助力可以获得 50 元红包，而游戏设计者恰恰是通过合理的难度设计，让绝大部分用户都在拉个几个用户之后发现难度较大就放弃；这样 50 元红包并未成功发出，在零成本的情况下用户已经为平台拉了几个人。</p>\n<h2 id=\"总结\"> 总结</h2>\n<p>心理学作为一门深奥的学科，虽然很多人没有经过系统地学习，但是多多少少都有所涉猎。</p>\n<p>本文所写的心理学效应都是常见的，已经被证实可以用到产品设计中的理论。那相对的，就依然存在很多不常见的，还没有深度用到产品设计中的理论，需要自己去探索。</p>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li>原文出处：《<a href=\"http://www.woshipm.com/pmd/2393716.html\" target=\"_blank\" rel=\"noopener noreferrer\">28个心理学效应，产品人的提升法则</a>》</li>\n</ul>\n",
      "date_published": "2021-12-09T09:44:22.000Z",
      "date_modified": "2021-12-09T09:44:22.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "React",
      "url": "https://www.fedbook.cn/frontend-engineering/react/",
      "id": "https://www.fedbook.cn/frontend-engineering/react/",
      "content_html": "<h1 id=\"react\"> React</h1>\n<p>React 是一个用于动态构建用户界面的 JavaScript 库（只关注于视图）。</p>\n<p>起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。</p>\n<hr>\n<p>React 特点：</p>\n<ul>\n<li><strong>声明式设计</strong>：React 采用声明式编码，可以轻松描述应用。</li>\n<li><strong>高效</strong>：React 使用虚拟 DOM，不总是直接操作页面真实 DOM；通过优秀的 Diffing 算法，最小化页面重绘。</li>\n<li><strong>灵活</strong>：React 可以与已知的库或框架很好地配合。</li>\n<li><strong>JSX</strong>：JSX 是 JavaScript 语法的扩展，React 开发不一定使用 JSX，但使用它能带来很大的便利。</li>\n<li><strong>组件</strong>：通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。</li>\n<li><strong>单向响应的数据流</strong>：React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。</li>\n</ul>\n<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>\"</span>example<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;</span>script</span> <span>type</span><span><span>=</span><span>\"</span>text/babel<span>\"</span></span><span>></span></span><span><span>\n  ReactDOM<span>.</span><span>render</span><span>(</span>\n    <span>&lt;</span>h1<span>></span>Hello<span>,</span> world<span>!</span><span>&lt;</span><span>/</span>h1<span>></span><span>,</span>\n    document<span>.</span><span>getElementById</span><span>(</span><span>'example'</span><span>)</span>\n  <span>)</span><span>;</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><hr>\n<p>声明式编码与命令式编码的区别：</p>\n<ul>\n<li>命令式编码：每一步都要自己亲自去定义、调用，每一步都会按照自己的命令依次执行。</li>\n<li>声明式编码：很多操作不用亲历亲为，只需要根据规定的语法进行声明，剩下的工作由框架或库内部完成。</li>\n</ul>\n<hr>\n<p>关于 React 的知识点，主要参考：</p>\n<ul>\n<li>各种网络资源</li>\n</ul>\n<div style=\"text-align: right\">\n  <svg t=\"1628346206220\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"10033\" width=\"64\" height=\"64\"><path d=\"M512 511.8m-80 0a80 80 0 1 0 160 0 80 80 0 1 0-160 0Z\" fill=\"#61DAFB\" p-id=\"10034\"></path><path d=\"M960.5 511.8c0-62.8-73.8-117.2-188.5-150.1 28.9-115.8 18.7-206.9-35.7-238.3-54.5-31.4-138.5 5.3-224.3 88.2-85.8-82.9-169.8-119.6-224.3-88.2-54.4 31.4-64.6 122.6-35.7 238.3C137.3 394.6 63.5 449 63.5 511.8S137.3 629 252 661.9c-28.9 115.7-18.7 206.9 35.7 238.3 13.4 7.8 28.6 11.6 45.2 11.6 39.7 0 87.8-21.8 140-64.2 13-10.6 26.1-22.6 39.1-35.2 13 12.6 26.1 24.6 39.1 35.2 52.2 42.4 100.2 64.2 140 64.2 16.6 0 31.8-3.8 45.2-11.6 54.4-31.4 64.6-122.5 35.7-238.3 114.7-32.9 188.5-87.3 188.5-150.1zM716.8 157.2c35.3 20.4 42.7 94.3 17.6 194.8-36.7-8.4-76.7-14.7-119.3-18.6-24.7-34.9-50.2-66.4-75.8-94 59.2-57.3 114.2-88.4 152-88.4 9.6-0.1 18.2 2 25.5 6.2zM637 584c-13.8 24-28.4 47-43.3 69-26.1 2-53.3 3.1-81.7 3.1-28.3 0-55.5-1.1-81.6-3.1-15-22-29.5-45.1-43.3-69-14.1-24.5-26.7-48.6-38.1-72.2 11.4-23.6 24-47.7 38.1-72.2 14.1-24.5 28.7-47.4 43.4-69.1 26.1-2 53.3-3.1 81.6-3.1 28.3 0 55.5 1.1 81.6 3.1 14.7 21.6 29.3 44.6 43.4 69 14.1 24.5 26.7 48.6 38.1 72.2-11.5 23.7-24.1 47.8-38.2 72.3z m58.8-26.4c11.2 26.6 20.4 52.1 28 76.5-24.9 5.6-51.7 10.4-80.3 14 9.3-14.5 18.4-29.3 27.3-44.6 8.8-15.4 17.1-30.7 25-45.9zM512 756.5c-17.7-19.2-35.1-40.1-52.2-62.6 17.1 0.8 34.5 1.3 52.2 1.3 17.7 0 35.1-0.5 52.2-1.3-17.1 22.5-34.5 43.4-52.2 62.6zM380.5 648.1c-28.6-3.6-55.3-8.4-80.3-14 7.6-24.4 16.8-49.9 28-76.5 7.9 15.2 16.1 30.5 25 45.9 8.9 15.2 18 30 27.3 44.6zM328.2 466c-11.2-26.6-20.4-52.1-28-76.5 24.9-5.6 51.6-10.4 80.2-14-9.2 14.4-18.4 29.2-27.2 44.6-8.8 15.4-17.1 30.7-25 45.9zM512 267.1c17.3 18.7 34.8 39.8 52.1 62.7-17.1-0.8-34.4-1.3-52.1-1.3-17.7 0-35 0.5-52.1 1.3 17.3-22.9 34.8-44 52.1-62.7z m158.7 153c-8.9-15.3-18-30.1-27.2-44.6 28.6 3.6 55.3 8.4 80.2 14-7.6 24.4-16.8 49.9-28 76.5-7.8-15.2-16.1-30.5-25-45.9zM307.2 157.2c7.2-4.2 15.8-6.2 25.6-6.2 37.8 0 92.7 31.1 151.9 88.4-25.6 27.6-51.1 59.2-75.8 94-42.5 3.9-82.6 10.2-119.3 18.6-25.1-100.6-17.6-174.5 17.6-194.8zM102.5 511.8c0-40.8 60.3-84.2 160-112.6 11.1 36 25.6 73.8 43.5 112.6-17.8 38.8-32.4 76.6-43.5 112.6-99.7-28.4-160-71.9-160-112.6z m345.8 305.5c-59.7 48.5-111.1 66.4-141.1 49.2-35.3-20.4-42.7-94.3-17.6-194.8 36.7 8.4 76.7 14.7 119.3 18.6 24.4 34.5 49.9 66.1 75.8 94.2-12.1 11.7-24.2 22.9-36.4 32.8z m268.5 49.2c-29.9 17.3-81.4-0.6-141.1-49.2-12.1-9.9-24.3-21.1-36.5-32.8 26-28.1 51.4-59.7 75.8-94.2 42.5-3.9 82.6-10.2 119.3-18.7 25.2 100.6 17.7 174.5-17.5 194.9z m44.8-242.1c-11.1-36-25.6-73.8-43.5-112.6 17.8-38.8 32.4-76.6 43.5-112.6 99.7 28.5 160 71.9 160 112.6-0.1 40.7-60.4 84.2-160 112.6z\" fill=\"#61DAFB\" p-id=\"10035\"></path></svg>\n</div>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2022-04-13T08:52:02.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "React JSX",
      "url": "https://www.fedbook.cn/frontend-engineering/react/react-jsx/",
      "id": "https://www.fedbook.cn/frontend-engineering/react/react-jsx/",
      "content_html": "<h1 id=\"react-jsx\"> React JSX</h1>\n<h2 id=\"jsx-简介\"> JSX 简介</h2>\n<p>JSX 的全称是 JavaScript XML，它是 React 定义的一种类似于 XML 的 JS 扩展语法。</p>\n<p>JS + XML 本质是 <code>React.createElement(component, props, ...children)</code> 方法的语法糖。</p>\n<p>JSX 作用：用来简化创建虚拟 DOM：</p>\n<ul>\n<li>写法：<code>var ele = &lt;h1&gt;Hello,React&lt;/h1&gt;</code></li>\n<li>注意 1：它不是字符串, 也不是 HTML/XML 标签</li>\n<li>注意 2：它最终产生的就是一个 JavaScript 对象</li>\n</ul>\n<p>我们不需要一定使用 JSX，但它有以下优点：</p>\n<ul>\n<li>JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化。</li>\n<li>它是类型安全的，在编译过程中就能发现错误。</li>\n<li>使用 JSX 编写模板更加简单快速。</li>\n</ul>\n<h2 id=\"jsx-语法规则\"> JSX 语法规则</h2>\n<p>JSX 可以总结出下列语法规则。</p>\n<h3 id=\"创建虚拟-dom-时-不要写引号\"> 创建虚拟 DOM 时，不要写引号</h3>\n<p>创建虚拟 DOM 时，不要写引号。</p>\n<div><div><br><br><div>&nbsp;</div><br><br><br><br></div><pre><code><span><span><span>&lt;</span>script</span> <span>type</span><span><span>=</span><span>\"</span>text/babel<span>\"</span></span> <span>></span></span><span><span>\n  <span>// 1. 创建虚拟 DOM</span>\n  <span>const</span> <span>VDOM</span> <span>=</span> <span>&lt;</span>h1<span>></span>Hello<span>,</span>React<span>&lt;</span><span>/</span>h1<span>></span>\n  <span>// 2. 渲染虚拟 DOM 到页面</span>\n  ReactDOM<span>.</span><span>render</span><span>(</span><span>VDOM</span><span>,</span> document<span>.</span><span>getElementById</span><span>(</span><span>'example'</span><span>)</span><span>)</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"标签中混入-js-表达式的写法\"> 标签中混入 JS 表达式的写法</h3>\n<p>标签中要混入 JS 表达式，要用花括号 <code>{}</code>。</p>\n<div><div><br><br><br><br><div>&nbsp;</div><br><br><br><br></div><pre><code><span><span><span>&lt;</span>script</span> <span>type</span><span><span>=</span><span>\"</span>text/babel<span>\"</span></span> <span>></span></span><span><span>\n  <span>const</span> data <span>=</span> <span>'Hello,React'</span>\n\n  <span>// 1. 创建虚拟 DOM</span>\n  <span>const</span> <span>VDOM</span> <span>=</span> <span>&lt;</span>h1<span>></span><span>{</span>data<span>}</span><span>&lt;</span><span>/</span>h1<span>></span>\n  <span>// 2. 渲染虚拟 DOM 到页面</span>\n  ReactDOM<span>.</span><span>render</span><span>(</span><span>VDOM</span><span>,</span> document<span>.</span><span>getElementById</span><span>(</span><span>'example'</span><span>)</span><span>)</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>\n<p>注意这里的花括号不是对象的意思，仅是分隔符。</p>\n</blockquote>\n<h3 id=\"标签中类名的写法\"> 标签中类名的写法</h3>\n<p>标签中样式的类名要用 <code>className</code> 指定而不是 <code>class</code>。</p>\n<div><div><br><br><br><br><div>&nbsp;</div><br><br><br><br></div><pre><code><span><span><span>&lt;</span>script</span> <span>type</span><span><span>=</span><span>\"</span>text/babel<span>\"</span></span> <span>></span></span><span><span>\n  <span>const</span> data <span>=</span> <span>'Hello,React'</span>\n\n  <span>// 1. 创建虚拟 DOM</span>\n  <span>const</span> <span>VDOM</span> <span>=</span> <span>&lt;</span>h1 className<span>=</span><span>\"title\"</span><span>></span><span>{</span>data<span>}</span><span>&lt;</span><span>/</span>h1<span>></span>\n  <span>// 2. 渲染虚拟 DOM 到页面</span>\n  ReactDOM<span>.</span><span>render</span><span>(</span><span>VDOM</span><span>,</span> document<span>.</span><span>getElementById</span><span>(</span><span>'example'</span><span>)</span><span>)</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>\n<p>如果跟平时写 HTML 一样用 <code>class</code>，会报错：<code>Warning: Invalid DOM property 'class'. Did you mean 'className'?</code></p>\n</blockquote>\n<h3 id=\"标签中内联样式的写法\"> 标签中内联样式的写法</h3>\n<p>标签中的内联样式要用双花括号 <code>{{}}</code> 包裹，并<strong>注意属性名转为小驼峰</strong>（<code>font-size</code> =&gt; <code>fontSize</code>）。</p>\n<p>本质上，外层花括号表示它里面是 JS 表达式，内层花括号表示一个对象（因为 style 属性本身就是一个 <code>{key: value}</code> 组合），所以内层花括号里的属性值 value 需要转为字符串形式，否则它将作为 JS 变量去读取。</p>\n<div><div><br><br><br><br><div>&nbsp;</div><br><br><br><br></div><pre><code><span><span><span>&lt;</span>script</span> <span>type</span><span><span>=</span><span>\"</span>text/babel<span>\"</span></span> <span>></span></span><span><span>\n  <span>const</span> data <span>=</span> <span>'Hello,React'</span>\n\n  <span>// 1. 创建虚拟 DOM</span>\n  <span>const</span> <span>VDOM</span> <span>=</span> <span>&lt;</span>h1 style<span>=</span><span>{</span><span>{</span>color<span>:</span><span>'white'</span><span>,</span>fontSize<span>:</span><span>'60px'</span><span>}</span><span>}</span><span>></span><span>{</span>data<span>}</span><span>&lt;</span><span>/</span>h1<span>></span>\n  <span>// 2. 渲染虚拟 DOM 到页面</span>\n  ReactDOM<span>.</span><span>render</span><span>(</span><span>VDOM</span><span>,</span> document<span>.</span><span>getElementById</span><span>(</span><span>'example'</span><span>)</span><span>)</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>\n<p>如果跟平时 HTML 中的一样写 <code>style=&quot;color:white;&quot;</code>，会报错：<code>Uncaught Invariant Violation: The 'style' prop expects a mapping from style properties to values, not a string.</code></p>\n</blockquote>\n<h3 id=\"多级结构使用小括号包裹\"> 多级结构使用小括号包裹</h3>\n<p>使用小括号 <code>()</code> 包裹后，代表一个整体，并且可以缩进结构，让代码像 HTML 模板一样美观可读。</p>\n<div><div><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br></div><pre><code><span><span><span>&lt;</span>script</span> <span>type</span><span><span>=</span><span>\"</span>text/babel<span>\"</span></span> <span>></span></span><span><span>\n  <span>// 1. 创建虚拟 DOM</span>\n  <span>const</span> <span>VDOM</span> <span>=</span> <span>(</span>\n    <span>&lt;</span>div<span>></span>\n      <span>&lt;</span>h1<span>></span>Hello<span>,</span>React<span>&lt;</span><span>/</span>h1<span>></span>\n    <span>&lt;</span><span>/</span>div<span>></span>\n  <span>)</span>\n  <span>// 2. 渲染虚拟 DOM 到页面</span>\n  ReactDOM<span>.</span><span>render</span><span>(</span><span>VDOM</span><span>,</span> document<span>.</span><span>getElementById</span><span>(</span><span>'example'</span><span>)</span><span>)</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"只能有一个根标签\"> 只能有一个根标签</h3>\n<p>只能有一个根标签，如果有多级并列结构，需要用一对 div 标签包裹。</p>\n<div><div><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br></div><pre><code><span><span><span>&lt;</span>script</span> <span>type</span><span><span>=</span><span>\"</span>text/babel<span>\"</span></span> <span>></span></span><span><span>\n  <span>// 1. 创建虚拟 DOM</span>\n  <span>const</span> <span>VDOM</span> <span>=</span> <span>(</span>\n    <span>&lt;</span>div<span>></span>\n      <span>&lt;</span>h1<span>></span>Hello<span>,</span>React<span>&lt;</span><span>/</span>h1<span>></span>\n      <span>&lt;</span>h2<span>></span><span>2021</span><span>-</span><span>08</span><span>-</span><span>08</span><span>&lt;</span><span>/</span>h2<span>></span>\n    <span>&lt;</span><span>/</span>div<span>></span>\n  <span>)</span>\n  <span>// 2. 渲染虚拟 DOM 到页面</span>\n  ReactDOM<span>.</span><span>render</span><span>(</span><span>VDOM</span><span>,</span> document<span>.</span><span>getElementById</span><span>(</span><span>'example'</span><span>)</span><span>)</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><blockquote>\n<p>如果不用 div 标签包裹，会报错：<code>Uncaught SyntaxError: Inline Babel script: Adjacent JSX elements must be wrapped in an enclosing tag</code>（Babel 编译错误）</p>\n</blockquote>\n<h3 id=\"标签必须闭合\"> 标签必须闭合</h3>\n<p>标签必须闭合，可以是自闭合（没有标签体内容的标签），也可以是一对开始标签和结束标签。</p>\n<h3 id=\"关于标签首字母\"> 关于标签首字母</h3>\n<ul>\n<li>如果首字母小写，那么 React 就会去寻找与之同名的 HTML 标签：\n<ul>\n<li>找到，直接转为 HTML 同名元素</li>\n<li>未找到，报错（<code>Warning: The tag xxx is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.</code>）</li>\n</ul>\n</li>\n<li>如果首字母大写，那么 React 就会去寻找与之同名的组件\n<ul>\n<li>找到，就会用该组件</li>\n<li>未找到，报错（<code>Uncaught ReferenceError: xxx is not defined</code>）</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>因为在 HTML 的标签中，除了文档声明（<code>&lt;!DOCTYPE html&gt;</code>）其它都是小写，所以在 JSX 的逻辑中，一旦标签首字母大写，就不去 HTML 中找有没有同名标签了，而是直接找同名组件，没找到就报错了。</p>\n</blockquote>\n<h3 id=\"注释需要写在花括号中\"> 注释需要写在花括号中</h3>\n<p>本质是通过花括号 <code>{}</code> 包裹后，将那行标签变成了 JS 表达式，然后就可以采用 JS 的多行注释语法。</p>\n<div><pre><code><span><span><span>&lt;</span>script</span> <span>type</span><span><span>=</span><span>\"</span>text/babel<span>\"</span></span> <span>></span></span><span><span>\n  <span>// 1. 创建虚拟 DOM</span>\n  <span>const</span> <span>VDOM</span> <span>=</span> <span>(</span>\n    <span>&lt;</span>div<span>></span>\n      <span>&lt;</span>h1<span>></span>Hello<span>,</span>React<span>&lt;</span><span>/</span>h1<span>></span>\n      <span>{</span><span>/* &lt;p>这是一行注释&lt;/p> */</span><span>}</span>\n    <span>&lt;</span><span>/</span>div<span>></span>\n  <span>)</span>\n  <span>// 2. 渲染虚拟 DOM 到页面</span>\n  ReactDOM<span>.</span><span>render</span><span>(</span><span>VDOM</span><span>,</span> document<span>.</span><span>getElementById</span><span>(</span><span>'example'</span><span>)</span><span>)</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>（完）</p>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2021-11-19T03:27:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Vue.js",
      "url": "https://www.fedbook.cn/frontend-engineering/vuejs/",
      "id": "https://www.fedbook.cn/frontend-engineering/vuejs/",
      "content_html": "<h1 id=\"vue-js\"> Vue.js</h1>\n<p>Vue.js 是一款渐进式 JavaScript 框架。</p>\n<p>虽然没有完全遵循 MVVM 模型，但是 Vue 的设计也受到了它的启发。因此经常会使用 vm（ViewModel 的缩写）这个变量名表示 Vue 实例。</p>\n<div><pre><code><span>var</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>\n  <span>// 选项</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><hr>\n<p>对 MVVM 的理解：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/mvvm.png\" alt=\"MVVM 图示\">\n  <p style=\"text-align:center; color: #888;\">（MVVM 图示，图来源于官网文档）</p>\n</div>\n<p>MVVM 分为 Model、View、ViewModel 三者。</p>\n<ul>\n<li>Model：代表数据模型，数据和业务逻辑都在 Model 层中定义；</li>\n<li>View：代表 UI 视图，负责数据的展示；</li>\n<li>ViewModel：就是与界面（View）对应的 Model。因为数据库结构往往是不能直接跟界面控件一一对应上的，所以需要再定义一个数据对象专门对应 View 上的控件。而 ViewModel 的职责就是把 Model 对象封装成可以显示和接受输入的界面数据对象。</li>\n</ul>\n<p>比如 UI 中有一个 li 列表，它是怎么与我们的数据对应的，就是通过 ViewModel。</p>\n<p>Model 和 View 并无直接关联，而是通过 ViewModel 来进行联系的，Model 和 ViewModel 之间有着双向数据绑定的联系。因此当 Model 中的数据改变时会触发 View 层的刷新，View 中由于用户交互操作而改变的数据也会在 Model 中同步。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/mvvm-demo.png\" alt=\"MVVM 例子\">\n  <p style=\"text-align:center; color: #888;\">（MVVM 例子）</p>\n</div>\n<hr>\n<p>关于 Vue.js 的知识点，主要参考：</p>\n<ul>\n<li>官方文档</li>\n</ul>\n<div style=\"text-align: right\">\n  <svg t=\"1599208046527\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"1194\" width=\"64\" height=\"64\"><path d=\"M627.85285817 77.66360895h185.07382266L512 598.88964363 211.07331917 77.66360895H10.45553197L512 946.33639105l501.54446803-868.78460919z\" fill=\"#41B883\" p-id=\"1195\"></path><path d=\"M812.92668083 77.66360895H627.85285817L512 278.28139617 396.14714183 77.66360895H211.07331917L512 598.88964363z\" fill=\"#34495E\" p-id=\"1196\"></path></svg>\n</div>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2021-12-26T08:41:15.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "高级用法特性",
      "url": "https://www.fedbook.cn/frontend-engineering/vuejs/advanced-use/",
      "id": "https://www.fedbook.cn/frontend-engineering/vuejs/advanced-use/",
      "content_html": "<h1 id=\"高级用法特性\"> 高级用法特性</h1>\n<h2 id=\"自定义-v-model\"> 自定义 v-model</h2>\n<p>使用场景：在自定义的组件中，<code>v-model</code> 默认会利用名为 <code>value</code> 的 prop 和名为 <code>input</code> 的事件。但是像单选框、复选框等类型的输入控件，它们的 <code>value</code> 属性有其它用途。此时 <code>model</code> 选项可以用来避免这样的冲突。</p>\n<p>下面演示一个例子（改自<a href=\"https://cn.vuejs.org/v2/guide/components-custom-events.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84-v-model\" target=\"_blank\" rel=\"noopener noreferrer\">官方文档</a>）：</p>\n<p>编写一个自定义的复选框组件 <code>BaseCheckbox.vue</code>：</p>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>\"</span>checkbox<span>\"</span></span> <span>:checked</span><span><span>=</span><span>\"</span>checked<span>\"</span></span> <span>@change</span><span><span>=</span><span>\"</span>$emit(<span>'</span>change<span>'</span>, $event.target.checked)<span>\"</span></span><span>></span></span>\n  <span>&lt;!--\n      1. 上面的 input 使用了 v-bind 而不是 v-model\n      2. \"checked\" 对应上 props 里的 checked\n      3. @change 时间里的 'change' 和 model.event 里的 'change' 要对应起来，名字可以自定义\n  --></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>export</span> <span>default</span> <span>{</span>\n  model<span>:</span> <span>{</span>\n    prop<span>:</span> <span>'checked'</span><span>,</span> <span>// 对应 props 中的 checked（名字两者可以自定义，但要前后一致）</span>\n    event<span>:</span> <span>'change'</span>\n  <span>}</span><span>,</span>\n  props<span>:</span> <span>{</span>\n    checked<span>:</span> Boolean<span>,</span>\n    <span>default</span><span>(</span><span>)</span> <span>{</span>\n      <span>return</span> <span>false</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>在父组件上使用 <code>v-model</code> 的时候：</p>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>h1</span><span>></span></span>我是父组件<span><span><span>&lt;/</span>h1</span><span>></span></span>\n  <span><span><span>&lt;</span>base-checkbox</span> <span>v-model</span><span><span>=</span><span>\"</span>lovingVue<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>base-checkbox</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>import</span> BaseCheckbox <span>from</span> <span>'./BaseCheckbox'</span>\n\n<span>export</span> <span>default</span> <span>{</span>\n  components<span>:</span> <span>{</span>\n    BaseCheckbox\n  <span>}</span><span>,</span>\n  <span>data</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>{</span>\n      lovingVue<span>:</span> <span>false</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>这里的 <code>lovingVue</code> 的值将会传入这个名为 <code>checked</code> 的 prop。同时当 <code>&lt;base-checkbox&gt;</code> 触发一个 <code>change</code> 事件并附带一个新的值的时候，这个 <code>lovingVue</code> 的值将会被更新。</p>\n<h2 id=\"nexttick\"> $nextTick</h2>\n<p>Vue 是异步渲染，data 改变之后，DOM 不会立刻渲染。<code>$nextTick</code> 会在 DOM 渲染之后被触发，以获取最新 DOM 节点。</p>\n<p>如下代码所示，如果不使用 <code>$nextTick</code>，那每次打印出来的数组长度是上一次渲染后的数组长度，而不是执行添加后的最新结果。</p>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>\"</span>app<span>\"</span></span><span>></span></span>\n    <span><span><span>&lt;</span>ul</span> <span>ref</span><span><span>=</span><span>\"</span>itemList<span>\"</span></span><span>></span></span>\n      <span><span><span>&lt;</span>li</span> <span>v-for</span><span><span>=</span><span>\"</span>(item, index) in list<span>\"</span></span> <span>:key</span><span><span>=</span><span>\"</span>index<span>\"</span></span><span>></span></span>\n        {{ item }}\n      <span><span><span>&lt;/</span>li</span><span>></span></span>\n    <span><span><span>&lt;/</span>ul</span><span>></span></span>\n    <span><span><span>&lt;</span>button</span> <span>@click</span><span><span>=</span><span>\"</span>addItem<span>\"</span></span><span>></span></span>添加一项<span><span><span>&lt;/</span>button</span><span>></span></span>\n  <span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>export</span> <span>default</span> <span>{</span>\n  name<span>:</span> <span>'app'</span><span>,</span>\n  <span>data</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>{</span>\n      list<span>:</span> <span>[</span><span>'a'</span><span>,</span> <span>'b'</span><span>,</span> <span>'c'</span><span>]</span>\n    <span>}</span>\n  <span>}</span><span>,</span>\n  methods<span>:</span> <span>{</span>\n    <span>addItem</span><span>(</span><span>)</span> <span>{</span>\n      <span>this</span><span>.</span>list<span>.</span><span>push</span><span>(</span><span><span>`</span><span><span>${</span>Date<span>.</span><span>now</span><span>(</span><span>)</span><span>}</span></span><span>`</span></span><span>)</span>\n      <span>this</span><span>.</span>list<span>.</span><span>push</span><span>(</span><span><span>`</span><span><span>${</span>Date<span>.</span><span>now</span><span>(</span><span>)</span><span>}</span></span><span>`</span></span><span>)</span>\n      <span>this</span><span>.</span>list<span>.</span><span>push</span><span>(</span><span><span>`</span><span><span>${</span>Date<span>.</span><span>now</span><span>(</span><span>)</span><span>}</span></span><span>`</span></span><span>)</span>\n\n      <span>// 1. 异步渲染，$nextTick 待 DOM 渲染完再回调</span>\n      <span>// 2. 页面渲染时会将 data 的修改做整合，多次 data 修改只会渲染一次</span>\n      <span>this</span><span>.</span><span>$nextTick</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n        <span>// 获取 DOM 元素</span>\n        <span>const</span> ulElem <span>=</span> <span>this</span><span>.</span>$refs<span>.</span>itemList\n        console<span>.</span><span>log</span><span>(</span>ulElem<span>.</span>childNodes<span>.</span>length<span>)</span>\n      <span>}</span><span>)</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><p>总结一下 <code>$nextTick</code> 的特点：</p>\n<ul>\n<li>汇总 data 的修改，一次性更新视图</li>\n<li>能够减少 DOM 操作次数，提高性能</li>\n</ul>\n<h2 id=\"slot-插槽\"> slot 插槽</h2>\n<h3 id=\"基本使用\"> 基本使用</h3>\n<p>slot 的基本用法是在父组件中往子组件插入一段内容（不一定只是字符串），示例如下：</p>\n<p>父组件引入了一个名为 <code>SlotDemo.vue</code> 的子组件，向其传入一个动态属性 <code>url</code> 以及一个类似子节点的 <code>website.title</code>。</p>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span><span>></span></span>\n    <span><span><span>&lt;</span>h1</span><span>></span></span>我是父组件<span><span><span>&lt;/</span>h1</span><span>></span></span>\n    <span><span><span>&lt;</span>slot-demo</span> <span>:url</span><span><span>=</span><span>\"</span>website.url<span>\"</span></span><span>></span></span>\n      {{ website.title }}\n    <span><span><span>&lt;/</span>slot-demo</span><span>></span></span>\n  <span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>import</span> SlotDemo <span>from</span> <span>'./SlotDemo'</span>\n\n<span>export</span> <span>default</span> <span>{</span>\n  components<span>:</span> <span>{</span>\n    SlotDemo<span>,</span>\n  <span>}</span><span>,</span>\n  <span>data</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>{</span>\n      website<span>:</span> <span>{</span>\n        url<span>:</span> <span>'https://fedbook.cn/'</span><span>,</span>\n        title<span>:</span> <span>'前端修炼小册'</span>\n      <span>}</span><span>,</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>子组件除了在 <code>props</code> 中接收父组件传进来的 <code>url</code>，还多了一个 <code>&lt;slot&gt;&lt;/slot&gt;</code> 标签，它接收父组件中写的子节点 <code>website.title</code> 中的内容。</p>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>a</span> <span>:href</span><span><span>=</span><span>\"</span>url<span>\"</span></span><span>></span></span>\n    <span><span><span>&lt;</span>slot</span><span>></span></span>\n      默认内容，即父组件没设置内容时，显示这句话\n    <span><span><span>&lt;/</span>slot</span><span>></span></span>\n  <span><span><span>&lt;/</span>a</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>export</span> <span>default</span> <span>{</span>\n  props<span>:</span> <span>[</span><span>'url'</span><span>]</span><span>,</span>\n  <span>data</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>{</span><span>}</span>\n  <span>}</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id=\"作用域插槽\"> 作用域插槽</h3>\n<p>有时我们需要让插槽内容能够访问子组件中才有的数据，即在父组件中获取子组件 <code>data</code> 里的值，就需要用到作用域插槽，示例如下：</p>\n<p>首先在子组件的 <code>data</code> 中定义一个 <code>website</code> 对象，再给 <code>&lt;slot&gt;&lt;/slot&gt;</code> 标签定义一个动态属性 <code>slotData</code> （名字可自定义）并赋值为 <code>website</code>。</p>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>a</span> <span>:href</span><span><span>=</span><span>\"</span>url<span>\"</span></span><span>></span></span>\n    <span><span><span>&lt;</span>slot</span> <span>:slotData</span><span><span>=</span><span>\"</span>website<span>\"</span></span><span>></span></span>\n      {{ website.subTitle }} <span>&lt;!-- 默认值显示 subTitle ，即父组件不传内容时 --></span>\n    <span><span><span>&lt;/</span>slot</span><span>></span></span>\n  <span><span><span>&lt;/</span>a</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>export</span> <span>default</span> <span>{</span>\n    props<span>:</span> <span>[</span><span>'url'</span><span>]</span><span>,</span>\n    <span>data</span><span>(</span><span>)</span> <span>{</span>\n      <span>return</span> <span>{</span>\n        website<span>:</span> <span>{</span>\n          url<span>:</span> <span>'https://cn.vuejs.org/'</span><span>,</span>\n          title<span>:</span> <span>'Vue.js'</span>\n        <span>}</span>\n      <span>}</span>\n    <span>}</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>父组件调用子组件时，现在增加了一个 <code>&lt;template&gt;</code> 标签，给它设置一个 <code>v-slot</code> 属性且值为 <code>slotProps</code>（名字可自定义）。</p>\n<p>在新增的 <code>&lt;template&gt;</code> 标签中进行插值，例如需要获取子组件 <code>data</code> 中的 <code>website.title</code>，写法就是 <code>slotProps.slotData.title</code>（<code>slotData</code> 对应的就是子组件的 <code>website</code>）。</p>\n<p>此时页面显示的就是子组件中的 <code>title</code> 值：</p>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span><span>></span></span>\n    <span><span><span>&lt;</span>h1</span><span>></span></span>我是父组件<span><span><span>&lt;/</span>h1</span><span>></span></span>\n    <span><span><span>&lt;</span>scoped-slot-demo</span> <span>:url</span><span><span>=</span><span>\"</span>website.url<span>\"</span></span><span>></span></span>\n      <span><span><span>&lt;</span>template</span> <span>v-slot</span><span><span>=</span><span>\"</span>slotProps<span>\"</span></span><span>></span></span>\n        {{ slotProps.slotData.title }}\n      <span><span><span>&lt;/</span>template</span><span>></span></span>\n    <span><span><span>&lt;/</span>scoped-slot-demo</span><span>></span></span>\n  <span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>import</span> ScopedSlotDemo <span>from</span> <span>'./ScopedSlotDemo'</span>\n\n<span>export</span> <span>default</span> <span>{</span>\n  components<span>:</span> <span>{</span>\n    ScopedSlotDemo<span>,</span>\n  <span>}</span><span>,</span>\n  <span>data</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>{</span>\n      website<span>:</span> <span>{</span>\n        url<span>:</span> <span>'https://fedbook.cn/'</span><span>,</span>\n        title<span>:</span> <span>'前端修炼小册'</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h3 id=\"具名插槽\"> 具名插槽</h3>\n<p>具名插槽用于子组件中有多个 slot 的场景，父组件往子组件传值时需要对应上名字，示例如下：</p>\n<p>子组件中每个 <code>&lt;slot&gt;</code> 元素有一个特殊的 <code>name</code> 属性，如果不指定 <code>name</code> 属性则默认是 &quot;default&quot;：</p>\n<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>container<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>header</span><span>></span></span>\n    <span><span><span>&lt;</span>slot</span> <span>name</span><span><span>=</span><span>\"</span>header<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>slot</span><span>></span></span>\n  <span><span><span>&lt;/</span>header</span><span>></span></span>\n  <span><span><span>&lt;</span>main</span><span>></span></span>\n    <span><span><span>&lt;</span>slot</span><span>></span></span><span><span><span>&lt;/</span>slot</span><span>></span></span>\n  <span><span><span>&lt;/</span>main</span><span>></span></span>\n  <span><span><span>&lt;</span>footer</span><span>></span></span>\n    <span><span><span>&lt;</span>slot</span> <span>name</span><span><span>=</span><span>\"</span>footer<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>slot</span><span>></span></span>\n  <span><span><span>&lt;/</span>footer</span><span>></span></span>\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>父组件中，在向具名插槽提供内容的时候，我们可以在一个 <code>&lt;template&gt;</code> 元素上使用 <code>v-slot</code> 指令，该指令的值就要对应上子组件中 <code>&lt;slot&gt;</code> 元素的 <code>name</code>。</p>\n<p>任何没有被包裹在带有 <code>v-slot</code> 的 <code>&lt;template&gt;</code> 中的内容都会被视为默认插槽的内容。</p>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span><span>></span></span>\n    <span><span><span>&lt;</span>h1</span><span>></span></span>我是父组件<span><span><span>&lt;/</span>h1</span><span>></span></span>\n    <span><span><span>&lt;</span>named-slot-demo</span><span>></span></span>\n      <span><span><span>&lt;</span>template</span> <span><span>v-slot:</span>header</span><span>></span></span>\n        <span><span><span>&lt;</span>h1</span><span>></span></span>将插入 header slot 中<span><span><span>&lt;/</span>h1</span><span>></span></span>\n      <span><span><span>&lt;/</span>template</span><span>></span></span>\n        \n      <span><span><span>&lt;</span>p</span><span>></span></span>将插入 main slot 中，即未命名的 slot<span><span><span>&lt;/</span>p</span><span>></span></span>\n      <span><span><span>&lt;</span>p</span><span>></span></span>也将插入 main slot 中<span><span><span>&lt;/</span>p</span><span>></span></span>\n        \n      <span><span><span>&lt;</span>template</span> <span><span>v-slot:</span>footer</span><span>></span></span>\n        <span><span><span>&lt;</span>p</span><span>></span></span>将插入 footer slot 中<span><span><span>&lt;/</span>p</span><span>></span></span>\n      <span><span><span>&lt;/</span>template</span><span>></span></span>\n    <span><span><span>&lt;/</span>named-slot-demo</span><span>></span></span>\n  <span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>import</span> NamedSlotDemo <span>from</span> <span>'./NamedSlotDemo'</span>\n\n<span>export</span> <span>default</span> <span>{</span>\n  components<span>:</span> <span>{</span>\n    NamedSlotDemo<span>,</span>\n  <span>}</span><span>,</span>\n  <span>data</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>{</span><span>}</span>\n  <span>}</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><h2 id=\"动态组件\"> 动态组件</h2>\n<p>动态组件用于在某个区域切换显示不同组件的场景，可以通过 Vue 的 <code>&lt;component&gt;</code> 元素加一个特殊的 <code>is</code> 属性来实现。</p>\n<p>代码示例：</p>\n<div><pre><code><span><span><span>&lt;</span>component</span> <span>:is</span><span><span>=</span><span>\"</span>componentName<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>component</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br></div></div><p>其中，<code>componentName</code> 传入需要显示的组件名。</p>\n<h2 id=\"异步组件\"> 异步组件</h2>\n<p>同步加载的组件在打包的时候只会打成一个包，如果体积过大，会导致每次进入页面初始化的时候需要加载很大的一个文件：</p>\n<div><pre><code><span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>import</span> FormDemo1 <span>from</span> <span>'./FormDemo1'</span>\n<span>import</span> FormDemo2 <span>from</span> <span>'./FormDemo2'</span>\n\n<span>export</span> <span>default</span> <span>{</span>\n  component<span>:</span> <span>{</span>\n    FormDemo1<span>,</span>\n    FormDemo2\n  <span>}</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>异步加载组件是通过 <code>import()</code> 函数来引入组件，可以实现按需加载/异步加载大组件，从而提升网页加载性能。</p>\n<div><pre><code><span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>export</span> <span>default</span> <span>{</span>\n  component<span>:</span> <span>{</span>\n    <span>FormDemo</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>import</span><span>(</span><span>'./FormDemo'</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"缓存组件\"> 缓存组件</h2>\n<p>缓存组件的意思是在频繁切换页面时（例如 Tab 切换），不需要重复渲染，常用于 Vue 的性能优化。</p>\n<p>通过 keep-alive 来实现缓存组件，示例如下：</p>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span><span>></span></span>\n    <span><span><span>&lt;</span>button</span> <span>@click</span><span><span>=</span><span>\"</span>changeState(<span>'</span>A<span>'</span>)<span>\"</span></span><span>></span></span>A<span><span><span>&lt;/</span>button</span><span>></span></span>\n    <span><span><span>&lt;</span>button</span> <span>@click</span><span><span>=</span><span>\"</span>changeState(<span>'</span>B<span>'</span>)<span>\"</span></span><span>></span></span>B<span><span><span>&lt;/</span>button</span><span>></span></span>\n    <span><span><span>&lt;</span>button</span> <span>@click</span><span><span>=</span><span>\"</span>changeState(<span>'</span>C<span>'</span>)<span>\"</span></span><span>></span></span>C<span><span><span>&lt;/</span>button</span><span>></span></span>\n\n    <span><span><span>&lt;</span>keep-alive</span><span>></span></span> <span>&lt;!-- 模拟 tab 切换 --></span>\n      <span><span><span>&lt;</span>KeepAliveStageA</span> <span>v-if</span><span><span>=</span><span>\"</span>state === <span>'</span>A<span>'</span><span>\"</span></span><span>/></span></span>\n      <span><span><span>&lt;</span>KeepAliveStageB</span> <span>v-if</span><span><span>=</span><span>\"</span>state === <span>'</span>B<span>'</span><span>\"</span></span><span>/></span></span>\n      <span><span><span>&lt;</span>KeepAliveStageC</span> <span>v-if</span><span><span>=</span><span>\"</span>state === <span>'</span>C<span>'</span><span>\"</span></span><span>/></span></span>\n    <span><span><span>&lt;/</span>keep-alive</span><span>></span></span>\n  <span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>import</span> KeepAliveStageA <span>from</span> <span>'./KeepAliveStateA'</span>\n<span>import</span> KeepAliveStageB <span>from</span> <span>'./KeepAliveStateB'</span>\n<span>import</span> KeepAliveStageC <span>from</span> <span>'./KeepAliveStateC'</span>\n\n<span>export</span> <span>default</span> <span>{</span>\n  components<span>:</span> <span>{</span>\n    KeepAliveStageA<span>,</span>\n    KeepAliveStageB<span>,</span>\n    KeepAliveStageC\n  <span>}</span><span>,</span>\n  <span>data</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>{</span>\n      state<span>:</span> <span>'A'</span>\n    <span>}</span>\n  <span>}</span><span>,</span>\n  methods<span>:</span> <span>{</span>\n    <span>changeState</span><span>(</span><span>state</span><span>)</span> <span>{</span>\n      <span>this</span><span>.</span>state <span>=</span> state\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><p><strong>keep-alive 和 v-show 的区别</strong>：</p>\n<ul>\n<li>控制层级不同，v-show 是通过原生的 CSS（display）；keep-alive 是在 Vue 层级进行的 JS 对象的渲染</li>\n<li>实际使用中，简单的标签可以使用 v-show，复杂的组件结构（例如 Tab 切换）使用 keep-alive。</li>\n</ul>\n<p><strong>keep-alive 和 v-if 的区别</strong>：</p>\n<ul>\n<li>v-if 也是 Vue 本身机制控制的，但会销毁和重新渲染组件，也就是会频繁触发组件的 mounted 和 destroyed；而 keep-alive 的方式，Vue 会把组件缓存，不需要走渲染流程。</li>\n</ul>\n<h2 id=\"mixin\"> mixin</h2>\n<p>mixin 用于将多个组件的相同逻辑抽离出来，可以避免重复编写相同代码。</p>\n<p>但 mixin 并不是完美的解决方案，会有一些问题：</p>\n<ul>\n<li>变量来源不明确，不利于阅读</li>\n<li>多 mixin 可能会造成命名冲突</li>\n<li>mixin 和组件可能出现多对多的关系，复杂度较高</li>\n</ul>\n<p>Vue3 提出的 Composition API 旨在解决这些问题。</p>\n<p>（完）</p>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2021-11-19T03:27:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "基础用法要点",
      "url": "https://www.fedbook.cn/frontend-engineering/vuejs/basic-use/",
      "id": "https://www.fedbook.cn/frontend-engineering/vuejs/basic-use/",
      "content_html": "<h1 id=\"基础用法要点\"> 基础用法要点</h1>\n<h2 id=\"循环列表渲染\"> 循环列表渲染</h2>\n<p><code>v-for</code> 支持遍历数组和对象，其中 <code>key</code> 很重要，但不能乱写（如 random 或者 index），尽量要写和业务有关联的信息（比如 id）。</p>\n<p><code>v-for</code> 和 <code>v-if</code> 不能一起使用，否则 ESLint 会报错（因为 <code>v-for</code> 的计算优先级更高，会生成一系列带有 <code>v-if</code> 属性的标签，产生重复判断）。</p>\n<h2 id=\"事件参数-event\"> 事件参数 event</h2>\n<p>在 Vue 中，事件参数 <code>event</code> 就是原生的 event 对象，没有进行任何的装饰。<code>event.target</code> 是事件监听的对象，即挂载到哪个元素上的；<code>event.currentTarget</code> 是事件被触发的地方，</p>\n<p>用法：</p>\n<ul>\n<li>不传参数时，默认会传递一个 <code>event</code> 参数：</li>\n</ul>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>button</span> <span>@click</span><span><span>=</span><span>\"</span>increment<span>\"</span></span><span>></span></span>按钮一<span><span><span>&lt;/</span>button</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>export</span> <span>default</span> <span>{</span>\n  methods<span>:</span> <span>{</span>\n    <span>increment</span><span>(</span><span>event</span><span>)</span> <span>{</span><span>}</span>\n  <span>}</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><ul>\n<li>传递自定义参数时，如果还需要获取 <code>event</code> 参数，则需要手动传递 <code>$event</code> 参数：</li>\n</ul>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>button</span> <span>@click</span><span><span>=</span><span>\"</span>increment(1, $event)<span>\"</span></span><span>></span></span>按钮二<span><span><span>&lt;/</span>button</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>export</span> <span>default</span> <span>{</span>\n  methods<span>:</span> <span>{</span>\n    <span>increment</span><span>(</span><span>val<span>,</span> event</span><span>)</span> <span>{</span><span>}</span>\n  <span>}</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id=\"事件修饰符\"> 事件修饰符</h2>\n<div><pre><code><span>&lt;!-- 阻止单击事件继续传播 --></span>\n<span><span><span>&lt;</span>a</span> <span><span>v-on:</span>click.stop</span><span><span>=</span><span>\"</span>doThis<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>a</span><span>></span></span>\n<span>&lt;!-- 提交事件不再重载页面 --></span>\n<span><span><span>&lt;</span>form</span> <span><span>v-on:</span>submit.prevent</span><span><span>=</span><span>\"</span>onsubmit<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>form</span><span>></span></span>\n<span>&lt;!-- 修饰符可以串联 --></span>\n<span><span><span>&lt;</span>a</span> <span><span>v-on:</span>click.stop.prevent</span><span><span>=</span><span>\"</span>doThat<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>a</span><span>></span></span>\n<span>&lt;!-- 只有修饰符 --></span>\n<span><span><span>&lt;</span>form</span> <span><span>v-on:</span>submit.prevent</span><span>></span></span><span><span><span>&lt;/</span>form</span><span>></span></span>\n<span>&lt;!-- 添加事件监听器时使用事件捕获模式 --></span>\n<span>&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --></span>\n<span><span><span>&lt;</span>div</span> <span><span>v-on:</span>click.capture</span><span><span>=</span><span>\"</span>doThat<span>\"</span></span><span>></span></span>...<span><span><span>&lt;/</span>div</span><span>></span></span>\n<span>&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --></span>\n<span>&lt;!-- 即事件不是从内部元素触发的 --></span>\n<span><span><span>&lt;</span>div</span> <span><span>v-on:</span>click.self</span><span><span>=</span><span>\"</span>doThat<span>\"</span></span><span>></span></span>...<span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id=\"按键修饰符\"> 按键修饰符</h2>\n<div><pre><code><span>&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --></span>\n<span><span><span>&lt;</span>button</span> <span>@click.ctrl</span><span><span>=</span><span>\"</span>onClick<span>\"</span></span><span>></span></span>A<span><span><span>&lt;/</span>button</span><span>></span></span>\n\n<span>&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --></span>\n<span><span><span>&lt;</span>button</span> <span>@click.ctrl.exact</span><span><span>=</span><span>\"</span>onCtrlClick<span>\"</span></span><span>></span></span>B<span><span><span>&lt;/</span>button</span><span>></span></span>\n\n<span>&lt;!-- 没有任何系统修饰符被按下的时候才触发 --></span>\n<span><span><span>&lt;</span>button</span> <span>@click.exact</span><span><span>=</span><span>\"</span>onClick<span>\"</span></span><span>></span></span>C<span><span><span>&lt;/</span>button</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"表单绑定-v-model\"> 表单绑定 v-model</h2>\n<h3 id=\"作用范围\"> 作用范围</h3>\n<p><code>v-model</code> 指令可以作用的元素为表单元素，它会元素创建了双向数据绑定：</p>\n<ul>\n<li>input(type='text', type='radio', type='checkbox')</li>\n<li>textarea</li>\n<li>select</li>\n</ul>\n<p><code>v-model</code> 还可以用在自定义组件上，具体说明见官方文档。</p>\n<h3 id=\"使用特例\"> 使用特例</h3>\n<p>在 Vue 中，多行文本区域插值要使用 <code>v-model</code> 来代替：</p>\n<div><pre><code><span>&lt;!-- Vue 中应该使用 v-model 来插值 --></span>\n<span><span><span>&lt;</span>textarea</span> <span>v-model</span><span><span>=</span><span>\"</span>desc<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>textarea</span><span>></span></span>\n\n<span>&lt;!-- Vue 中这么用是不会生效的 --></span>\n<span><span><span>&lt;</span>textarea</span><span>></span></span>{{ desc }}<span><span><span>&lt;/</span>textarea</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"修饰符-lazy-number-trim\"> 修饰符 lazy number trim</h3>\n<div><pre><code><span>&lt;!-- 在 change 时而非 input 时更新 --></span>\n<span>&lt;!-- 在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 --></span>\n<span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>\"</span>text<span>\"</span></span> <span>v-model.lazy</span><span><span>=</span><span>\"</span>name<span>\"</span></span><span>></span></span>\n\n<span>&lt;!-- 自动过滤用户输入的首尾空白字符 --></span>\n<span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>\"</span>text<span>\"</span></span> <span>v-model.number</span><span><span>=</span><span>\"</span>name<span>\"</span></span><span>></span></span>\n\n<span>&lt;!-- 自动将用户的输入值转为数值类型 --></span>\n<span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>\"</span>number<span>\"</span></span> <span>v-model.trim</span><span><span>=</span><span>\"</span>age<span>\"</span></span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id=\"父子组件通信\"> 父子组件通信</h2>\n<h3 id=\"通过-prop-实现父传子\"> 通过 prop 实现父传子</h3>\n<p>子组件的 <code>props</code> 选项能够接收来自父组件数据，这是一种单向绑定，即只能父组件向子组件传递，不能反向。示例如下：</p>\n<p>父组件 <code>Parent.vue</code>：</p>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span><span>></span></span>\n    <span><span><span>&lt;</span>h1</span><span>></span></span>我是父组件<span><span><span>&lt;/</span>h1</span><span>></span></span>\n    <span><span><span>&lt;</span>child</span> <span>:message</span><span><span>=</span><span>\"</span>msg<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>child</span><span>></span></span>\n  <span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>import</span> Child <span>from</span> <span>'../components/Child.vue'</span>\n\n<span>export</span> <span>default</span> <span>{</span>\n  components<span>:</span> <span>{</span> Child <span>}</span><span>,</span>\n  <span>data</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>{</span>\n      msg<span>:</span> <span>'hello, child'</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>子组件 <code>Child.vue</code>：</p>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span><span>></span></span>\n    <span><span><span>&lt;</span>h1</span><span>></span></span>我是子组件<span><span><span>&lt;/</span>h1</span><span>></span></span>\n    <span><span><span>&lt;</span>p</span><span>></span></span>父组件对我说：{{ message }}<span><span><span>&lt;/</span>p</span><span>></span></span>\n  <span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>export</span> <span>default</span> <span>{</span>\n  <span>// 子组件通过 props 属性，接收父组件传过来的值</span>\n  props<span>:</span> <span>{</span>\n    message<span>:</span> <span>{</span>\n      type<span>:</span> String<span>,</span>\n      <span>default</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n        <span>return</span> <span>''</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span><span>,</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p><strong>注意事项（单向数据流）</strong>：</p>\n<ul>\n<li>每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。</li>\n<li>不允许在子组件内部改变 prop，避免这个参数被多个子组件引用时，无法找到数据不正常的原因。\n<ul>\n<li>如果子组件中 prop 是对象或数组，子组件对其修改后父组件相应的值也会修改（<strong>但不允许这么做</strong>）；如果是字符串等基本数据类型，则会报错。</li>\n<li>如果需要将父组件传递进来的值作为一个本地数据的初始值来使用，则推荐在子组件中额外定义一个<strong>本地的 data property</strong>，并将这个 prop 用作其初始值。</li>\n<li>如果这个 prop 以一种原始的值传入且需要进行转换（例如大小写、字符串拼接等），则最好使用这个 prop 的值来定义一个<strong>计算属性</strong>。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"通过-emit-实现子传父\"> 通过 $emit 实现子传父</h3>\n<p>子组件通过 <code>$emit</code> 触发事件给父组件发送消息，父组件通过 <code>v-on</code>（简写为 <code>@</code>） 监听子组件提交的事件。示例如下：</p>\n<p>父组件 <code>Parent.vue</code>：</p>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span><span>></span></span>\n    <span><span><span>&lt;</span>h1</span><span>></span></span>我是父组件<span><span><span>&lt;/</span>h1</span><span>></span></span>\n    <span><span><span>&lt;</span>child</span> <span>@get-message</span><span><span>=</span><span>\"</span>showMsg<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>child</span><span>></span></span>\n  <span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>import</span> Child <span>from</span> <span>'../components/Child.vue'</span>\n\n<span>export</span> <span>default</span> <span>{</span>\n  components<span>:</span> <span>{</span> Child <span>}</span><span>,</span>\n  methods<span>:</span> <span>{</span>\n    <span>// 参数就是子组件传递出来的数据</span>\n    <span>showMsg</span><span>(</span><span>msg</span><span>)</span> <span>{</span>\n      console<span>.</span><span>log</span><span>(</span>msg<span>)</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>子组件 <code>Child.vue</code>：</p>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span><span>></span></span>\n    <span><span><span>&lt;</span>h1</span><span>></span></span>我是子组件<span><span><span>&lt;/</span>h1</span><span>></span></span>\n    <span><span><span>&lt;</span>button</span> <span>@click</span><span><span>=</span><span>\"</span>sendMsg<span>\"</span></span><span>></span></span>发送<span><span><span>&lt;/</span>button</span><span>></span></span>\n  <span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>export</span> <span>default</span> <span>{</span>\n  <span>data</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>{</span>\n      childSay<span>:</span> <span>'hello, parent'</span>\n    <span>}</span>\n  <span>}</span><span>,</span>\n  methods<span>:</span> <span>{</span>\n    <span>// 子组件通过 emit 方法触发父组件中定义好的函数，从而将子组件中的数据传递给父组件</span>\n    <span>sendMsg</span><span>(</span><span>)</span> <span>{</span>\n      <span>this</span><span>.</span><span>$emit</span><span>(</span><span>'get-message'</span><span>,</span> <span>this</span><span>.</span>childSay<span>)</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h3 id=\"通过-ref-获取子组件实例\"> 通过 $ref 获取子组件实例</h3>\n<p>对于 <code>ref</code>：</p>\n<ul>\n<li>如果 <code>ref</code> 用在子组件上，指向的是组件实例，可以理解为对子组件的索引，通过 <code>$ref</code> 可以获取到在子组件里定义的属性和方法。</li>\n<li>如果 <code>ref</code> 在普通的 DOM 元素上使用，引用指向的就是 DOM 元素，通过 <code>$ref</code> 可能获取到该 DOM 的属性集合，轻松访问到 DOM 元素，作用与 jQuery 选择器类似。</li>\n</ul>\n<p>那么就好理解了，可以在父组件中通过 <code>$ref</code> 来直接获取子组件中的属性和方法。示例如下：</p>\n<p>父组件 <code>Parent.vue</code>：</p>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span><span>></span></span>\n    <span><span><span>&lt;</span>h1</span><span>></span></span>我是父组件<span><span><span>&lt;/</span>h1</span><span>></span></span>\n    <span><span><span>&lt;</span>child</span> <span>ref</span><span><span>=</span><span>\"</span>child<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>child</span><span>></span></span>\n  <span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>import</span> Child <span>from</span> <span>'../components/Child.vue'</span>\n\n<span>export</span> <span>default</span> <span>{</span>\n  components<span>:</span> <span>{</span> Child <span>}</span><span>,</span>\n  <span>mounted</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>$refs<span>.</span>child<span>)</span>\n    <span>this</span><span>.</span>$refs<span>.</span>child<span>.</span><span>getMessage</span><span>(</span><span>'hello'</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>子组件 <code>Child.vue</code>：</p>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span><span>></span></span>\n    <span><span><span>&lt;</span>h1</span><span>></span></span>我是子组件<span><span><span>&lt;/</span>h1</span><span>></span></span>\n    <span><span><span>&lt;</span>p</span><span>></span></span>{{ message }}<span><span><span>&lt;/</span>p</span><span>></span></span>\n  <span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>export</span> <span>default</span> <span>{</span>\n  <span>data</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>{</span>\n      message<span>:</span> <span>''</span>\n    <span>}</span>\n  <span>}</span><span>,</span>\n  methods<span>:</span> <span>{</span>\n    <span>// 由父组件通过 $ref 引用来调用子组件的该方法</span>\n    <span>getMessage</span><span>(</span><span>msg</span><span>)</span> <span>{</span>\n      <span>this</span><span>.</span>message <span>=</span> msg\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p><strong>对比（<code>prop</code> 和 <code>$ref</code> 之间的区别）</strong>：</p>\n<ul>\n<li><code>prop</code> 着重于数据的传递，它并不能调用子组件里的属性和方法。像创建文章组件时，自定义标题和内容这样的使用场景，最适合使用 <code>prop</code>。</li>\n<li><code>$ref</code> 着重于索引，主要用来调用子组件里的属性和方法，其实并不擅长数据传递。而且 <code>ref</code> 用在 DOM 元素的时候，能使到选择器的作用，这个功能比作为索引更常有用到。</li>\n</ul>\n<h2 id=\"兄弟组件通信\"> 兄弟组件通信</h2>\n<p>项目中，我们经常会遇到兄弟组件（或隔了很多层的组件、甚至是两个不相关的组件）之间通信的情况。在大型项目中我们可以通过引入 Vuex 轻松管理各组件之间通信问题，但在一些小型的项目中，可以通过自定义事件来实现，大体思路如下：</p>\n<ol>\n<li>创建一个 Vue 的实例作为媒介，让各个兄弟组件共用同一个事件机制。</li>\n<li>数据传递方，通过一个 EventBus 事件触发 <code>bus.$emit(方法名, 传递的数据)</code>。</li>\n<li>数据接收方，在 <code>mounted</code> 中绑定监听事件，在 <code>beforeDestroy</code> 中解绑监听事件。</li>\n</ol>\n<p>下面演示一个例子：</p>\n<p>首先编写一个 <code>event-bus.js</code>，它的作用就是返回一个 Vue 的实例。</p>\n<div><pre><code><span>// event-bus.js</span>\n<span>import</span> Vue <span>from</span> <span>'vue'</span>\n\n<span>export</span> <span>default</span> <span>new</span> <span>Vue</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>组件 A 和组件 B 里面分别引入 <code>event-bus.js</code> 返回的 Vue 实例（此处命名为 <code>bus</code>）。<code>bus</code> 本质上就是 Vue 的实例，而 Vue 的实例本身已经实现了 <code>$emit</code>、<code>$on</code>、<code>$off</code> 这些自定义事件的能力。</p>\n<p>在组件 A 中传递数据（触发自定义事件）。</p>\n<div><pre><code><span>&lt;!-- 组件A：ComponentA.vue --></span>\n<span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>comment-a<span>\"</span></span><span>></span></span>\n    <span><span><span>&lt;</span>button</span> <span>@click</span><span><span>=</span><span>\"</span>sendMsg<span>\"</span></span><span>></span></span>向组件B传值<span><span><span>&lt;/</span>button</span><span>></span></span>\n  <span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>import</span> bus <span>from</span> <span>'./event-bus'</span>\n\n<span>export</span> <span>default</span> <span>{</span>\n  <span>data</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>{</span>\n      msg<span>:</span> <span>''</span>\n    <span>}</span>\n  <span>}</span><span>,</span>\n  methods<span>:</span> <span>{</span>\n    <span>sendMsg</span><span>(</span><span>)</span> <span>{</span>\n      <span>// 调用自定义事件</span>\n      bus<span>.</span><span>$emit</span><span>(</span><span>'listenToA'</span><span>,</span> <span>this</span><span>.</span>msg<span>)</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>在组件 B 中接收数据（监听自定义事件），需要做两步操作，一是绑定自定义事件，二是在 <code>beforeDestroy</code> 中解绑自定义事件。</p>\n<div><pre><code><span>&lt;!-- 组件B：ComponentB.vue --></span>\n<span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>comment-b<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>import</span> bus <span>from</span> <span>'./event-bus'</span>\n\n<span>export</span> <span>default</span> <span>{</span>\n  <span>mounted</span><span>(</span><span>)</span> <span>{</span>\n    <span>// 绑定自定义事件</span>\n    bus<span>.</span><span>$on</span><span>(</span><span>'listenToA'</span><span>,</span> <span>this</span><span>.</span>getAData<span>)</span>\n  <span>}</span><span>,</span>\n  <span>beforeDestroy</span><span>(</span><span>)</span> <span>{</span>\n    <span>// 及时销毁自定义事件，否则可能造成内存泄露</span>\n    bus<span>.</span><span>$off</span><span>(</span><span>'listenToA'</span><span>,</span> <span>this</span><span>.</span>getAData<span>)</span>\n  <span>}</span><span>,</span>\n  methods<span>:</span> <span>{</span>\n    <span>getAData</span><span>(</span><span>val</span><span>)</span> <span>{</span>\n      console<span>.</span><span>log</span><span>(</span><span><span>`</span><span>组件 A 传递过来的数据: </span><span><span>${</span>val<span>}</span></span><span>`</span></span><span>)</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p><strong>注意事项（区别）</strong>：</p>\n<ul>\n<li><code>this.$emit(方法名, 传递的数据)</code> 是调用父组件的事件。</li>\n<li><code>bus.$emit(方法名, 传递的数据)</code> 是调用自定义事件。</li>\n</ul>\n<h2 id=\"组件生命周期-单个组件\"> 组件生命周期（单个组件）</h2>\n<ul>\n<li>挂载阶段\n<ul>\n<li>beforeCreate =&gt; created =&gt; beforeMount =&gt; mounted</li>\n</ul>\n</li>\n<li>更新阶段\n<ul>\n<li>beforeUpdate =&gt; updated</li>\n</ul>\n</li>\n<li>销毁阶段\n<ul>\n<li>beforeDestroy =&gt; destroyed</li>\n</ul>\n</li>\n</ul>\n<p>在 created 阶段，把 Vue 实例初始化，存在内存中；在 mounted 阶段，组件在网页中渲染完成，此时可以做一些 Ajax 请求等操作。</p>\n<p>在 beforeDestroy 阶段，需要解除自定义事件的绑定、销毁定时任务、解除之前定义的 window 和 document 事件等。</p>\n<h2 id=\"组件生命周期-父子组件\"> 组件生命周期（父子组件）</h2>\n<p><strong>1）加载渲染过程：创建 Vue 实例时从外到内，渲染时从内到外</strong></p>\n<p>父 beforeCreate =&gt; 父 created =&gt; 父 beforeMount =&gt; 子 beforeCreate =&gt; 子 created =&gt; 子 beforeMount =&gt; 子 mounted =&gt; 父 mounted</p>\n<p><strong>2）子组件更新过程</strong></p>\n<p>父 beforeUpdate =&gt; 子 beforeUpdate =&gt; 子 updated =&gt; 父 updated</p>\n<p><strong>3）父组件更新过程</strong></p>\n<p>父 beforeUpdate =&gt; 父 updated</p>\n<p><strong>4）销毁过程</strong></p>\n<p>父 beforeDestroy =&gt; 子 beforeDestroy =&gt; 子 destroyed =&gt; 父 destroyed</p>\n<p>（完）</p>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2021-11-19T03:27:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "组件渲染与更新",
      "url": "https://www.fedbook.cn/frontend-engineering/vuejs/component-render-and-update/",
      "id": "https://www.fedbook.cn/frontend-engineering/vuejs/component-render-and-update/",
      "content_html": "<h1 id=\"组件渲染与更新\"> 组件渲染与更新</h1>\n<blockquote>\n<p>Vue 原理的三大模块分别为响应式、vdom 和模板编译，前面已经分别学习过，现在通过总结渲染过程来将它们串起来回顾。</p>\n</blockquote>\n<h2 id=\"初次渲染过程\"> 初次渲染过程</h2>\n<ul>\n<li>Step1：解析模板为 render 函数（这步操作或在开发中通过 vue-loader 已完成）</li>\n<li>Step2：触发响应式，监听 data 属性 getter 和 setter（下一步执行 render 函数可能会用到 getter）</li>\n<li>Step3：执行 render 函数，生成 vnode，渲染节点 patch(elem, vnode)</li>\n</ul>\n<h2 id=\"更新过程\"> 更新过程</h2>\n<ul>\n<li>Step1：修改 data，触发 setter（前提是该 data 此前在 getter 中已被监听，即模板中被引用的 data）</li>\n<li>Step2：重新执行 render 函数，生成 newVnode</li>\n<li>Step3：更新节点 patch(vnode, newVnode)</li>\n</ul>\n<p>其中 vnode 和 newVnode 的最小差异由 patch 的 diff 算法计算。</p>\n<h2 id=\"完整流程图\"> 完整流程图</h2>\n<p>组件渲染与更新的完整流程图如下所示：</p>\n<ul>\n<li>黄色方框为 render 函数（此时模板已经编译完），它会生成 vnode（绿色 Virtual DOM Tree）。</li>\n<li>黄色方框在执行 render 时，会触发（Touch）紫色圆圈（Data）里面的 getter。</li>\n<li>紫色圆圈（Data）里的 getter 触发时，会收集依赖，模板里哪个变量的 getter 被触发了，就会将相应变量观察起来（蓝色圆圈 Watcher）</li>\n<li>一旦修改了 Data，就会通知 Watcher，如果修改的 data 是之前作为依赖被观察的，则重新触发渲染（re-render）。</li>\n</ul>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/component-render-and-update.png\" alt=\"组件渲染与更新\">\n  <p style=\"text-align: center; color: #888;\">（组件渲染与更新，图来源于官网文档）</p>\n</div>\n<p>（完）</p>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2021-11-19T03:27:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "认知偏差知识手册",
      "url": "https://www.fedbook.cn/extracurricular/cognitive-biases/",
      "id": "https://www.fedbook.cn/extracurricular/cognitive-biases/",
      "content_html": "<h1 id=\"认知偏差知识手册\"> 认知偏差知识手册</h1>\n<div><p>注意</p>\n<p>本手册仅作为心理学知识词条的普及，不具有产品设计指导意义。</p>\n</div>\n<h2 id=\"决策、信念与行为偏差\"> 决策、信念与行为偏差</h2>\n<blockquote>\n<p>💡<strong>决策、信念与行为偏差</strong></p>\n<p>这些偏差多半会影响信念的形成、商业与经济决策、以及其他一般的人类行为它们是可复制与再现的，面临特定情境时，一般可预期人们会有相应的偏差倾向。</p>\n</blockquote>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/a.png\" alt=\"决策、信念与行为偏差\">\n  <p style=\"text-align: center; color: #888\">（决策、信念与行为偏差）</p>\n</div>\n<h3 id=\"_1-不明确性效应-ambiguity-effect\"> 1. 不明确性效应 Ambiguity Effect</h3>\n<p>我们倾向于避免未知，决策时避开资讯不足的选项，通过添加明确的细节来最大程度地减少歧义，从而提高转化率。</p>\n<p><strong>🔺 示例</strong></p>\n<p>CTA 按钮（Call to Action，引导人们做出某些特定行为的按钮，例如购买，联系或订阅等）应在其旁边包含信息性标签，以清除不确定性。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/1.png\" alt=\"不明确性效应\" style=\"zoom:50%;\">\n  <p style=\"text-align: center; color: #888\">（不明确性效应）</p>\n</div>\n<h3 id=\"_2-锚定效应-anchoring-effect\"> 2. 锚定效应 Anchoring Effect</h3>\n<p>人类在进行决策时，会过度偏重先前取得的资讯（这称为锚点），即使这个资讯与这项决定无关。在进行决策时，人类倾向于利用此片段资讯（锚点），快速做出决定。</p>\n<p><strong>🔺 示例</strong></p>\n<p>通常被利用在消费场景中的认知偏差，通过前后对比来放大优惠感知，进而促进用户做出有利于我们的决策。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/2.png\" alt=\"锚定效应\" style=\"zoom:50%;\">\n  <p style=\"text-align: center; color: #888\">（锚定效应）</p>\n</div>\n<h3 id=\"_3-注意力偏差-attentional-bias\"> 3. 注意力偏差 Attentional Bias</h3>\n<p>在检查所有可能的结果时，我们倾向于关注一些看起来合理且熟悉的事物，从而忽略了其他结果。</p>\n<p><strong>🔺 示例</strong></p>\n<p>你是否发布过一项你认为会造成意外后果的功能，然后你就只盯着这个后果？</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/3.png\" alt=\"注意力偏差\" style=\"zoom:50%;\">\n  <p style=\"text-align: center; color: #888\">（注意力偏差）</p>\n</div>\n<h3 id=\"_4-获得性启发-availability-heuristic\"> 4. 获得性启发 Availability Heuristic</h3>\n<p>我们认为那些迅速跃入脑海的事情比那些不容易想起的事情更为常见和重要。因此，最近发生的、频繁发生的、极端的、被记住的事情比大多数信息更有影响力。</p>\n<p><strong>🔺 示例</strong></p>\n<p>通过创建一些与众不同的东西（在不影响一致性和熟悉度的情况下）让你的设计被记住。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/4.png\" alt=\"获得性启发\" style=\"zoom:50%;\">\n  <p style=\"text-align: center; color: #888\">（获得性启发）</p>\n</div>\n<h3 id=\"_5-可获性层叠-availability-heuristic\"> 5. 可获性层叠 Availability Heuristic</h3>\n<p>这个心理效应有一个更简单的描述，叫做三人成虎，也就是一件事越常被公开谈论，人们就越相信这件事。</p>\n<p><strong>🔺 示例</strong></p>\n<p>创建一个醒目的标语，并确保重复多次。如果可能，这个标语以押韵结尾会更好。</p>\n<h3 id=\"_6-逆火效应-backfire-effect\"> 6. 逆火效应 Backfire Effect</h3>\n<p>我们不能轻易改变人们的信念：与根深蒂固的信念相反的证据和论据无济于事，只会巩固信念的地位。</p>\n<p><strong>🔺 示例</strong></p>\n<p>通过情感辩论来影响他人的行为，不要尝试直接改变他们的信念。</p>\n<h3 id=\"_7-从众效应-bandwagon-effect\"> 7. 从众效应 Bandwagon Effect</h3>\n<p>我们经常会因为大多数人以同一种方式思考，而改变我们自己的想法。</p>\n<p><strong>🔺 示例</strong></p>\n<p>我们在设计中可以营造出一种群体选择的效果来吸引更多的用户，通过展示购买人数和滚动播放购买信息来体现出该商品的热门，让正在犹豫的用户「随大流」下单购买。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/7.png\" alt=\"从众效应\" style=\"zoom:50%;\">\n  <p style=\"text-align: center; color: #888\">（从众效应）</p>\n</div>\n<h3 id=\"_8-信念偏差-belief-bias\"> 8. 信念偏差 Belief Bias</h3>\n<p>我们更倾向于接受与我们的先验知识相符的论点，而拒绝对该论点的反驳。</p>\n<p><strong>🔺 示例</strong></p>\n<p>谈论产品的好处时，不要夸大其词。如果它好到让人无法相信，那么人们将不会相信它。</p>\n<h3 id=\"_9-选择支持偏差-choice-supportive-bias\"> 9. 选择支持偏差 Choice-Supportive Bias</h3>\n<p>做出决定后，我们倾向于称赞我们选择的选项，然后降级其他选项。</p>\n<p><strong>🔺 示例</strong></p>\n<p>在用户做出购买决定并成功达成交易之后，是用户分享产品（或添加评论）的绝佳时机；显示肯定的信息，并祝贺他们达成了这一步骤以激励用户。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/9.png\" alt=\"选择支持偏差\" style=\"zoom:50%;\">\n  <p style=\"text-align: center; color: #888\">（选择支持偏差）</p>\n</div>\n<h3 id=\"_10-确认偏差-confirmation-bias\"> 10. 确认偏差 Confirmation Bias</h3>\n<p>当人们本来就持有某种观点时，对这种观点的感知和注意度会被放大，会选择性地回忆或收集关于它的事例。人们对于自己原本就相信的观点会更容易接受，而把反面观点搁置在一旁。</p>\n<p><strong>🔺 示例</strong></p>\n<p>在用户研究中，当你的预设想法是用户对 A 设计的满意度比 B 设计更高时，在研究中你可能会更关注用户提到的 A 设计的优点、收集更多用户对于 A 设计的正面评价。当用户表示对 A 设计满意时，会觉得「果然是这样」。这种偏误会让你遗漏许多其它信息。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/10.png\" alt=\"确认偏差\" style=\"zoom:50%;\">\n  <p style=\"text-align: center; color: #888\">（确认偏差）</p>\n</div>\n<h3 id=\"_11-知识的诅咒-curse-of-knowledge\"> 11 知识的诅咒 Curse of Knowledge</h3>\n<p>当我们是某个领域的专家时，会不知不觉假设其他人和我们具有相同的理解能力，尤其是对于专业术语的使用。</p>\n<p><strong>🔺 示例</strong></p>\n<p>考虑一下大多数用户，他们的技术水平可能不如你想象的那样，并且对你熟悉的事物也不太熟悉。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/11.png\" alt=\"知识的诅咒\" style=\"zoom:50%;\">\n  <p style=\"text-align: center; color: #888\">（知识的诅咒）</p>\n</div>\n<h3 id=\"_12-诱饵效应-decoy-effect\"> 12. 诱饵效应 Decoy Effect</h3>\n<p>引入第三个选项來加强旧选项的吸引力。</p>\n<p><strong>🔺 示例</strong></p>\n<p>假设有产品 A 和 B，以下是顾客可以选择的选项：</p>\n<p>（1）¥100 - A<br>\n（2）¥300 - B<br>\n（3）¥300 - A + B</p>\n<p>在这个情景，（2）是「诱饵」，用来引导顾客选择「目标选项」（3）。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/12.png\" alt=\"诱饵效应\" style=\"zoom:50%;\">\n  <p style=\"text-align: center; color: #888\">（诱饵效应）</p>\n</div>\n<h3 id=\"_13-差异偏差-distinction-bias\"> 13. 差异偏差 Distinction Bias</h3>\n<p>在有比较项存在的时候，我们对微小的差异变得敏感，而实际上，这些差异并不是很大。</p>\n<p><strong>🔺 示例</strong></p>\n<p>在竞争对手旁边展示你的产品优势，以便用户注意到差异，即使是一个很小的差异。</p>\n<h3 id=\"_14-禀赋效应-endowment-effect\"> 14. 禀赋效应 Endowment Effect</h3>\n<p>和没有拥有的物品相比，用户更倾向于保留自己拥有的物品。他们倾向于高估自己拥有的东西，而忽略其客观的市场价值。</p>\n<p><strong>🔺 示例</strong></p>\n<p>禀赋效应是损失规避（loss aversion）的一种表现形式，免费试用是禀赋效应的最常见用法。 一旦用户开始使用某种产品并投入了一段时间，那么在试用期结束时，他们很难放手而停止使用。当用户准备离开时，他们会觉得自己即将失去很多美好的事物。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/14.png\" alt=\"禀赋效应\" style=\"zoom:50%;\">\n  <p style=\"text-align: center; color: #888\">（禀赋效应）</p>\n</div>\n<h3 id=\"_15-功能固着-functional-fixedness\"> 15. 功能固着 Functional Fixedness</h3>\n<p>指个体在解决问题时往往只看到某种事物的通常功能，而看不到它其他方面可能有的功能。这是人们长期以来形成的对某些事物的功能或用途的固定看法。</p>\n<p><strong>🔺 示例</strong></p>\n<p>当产品挑战到现有的使用传统时，可能会引起一些可用性挑战。 请确保进行可用性测试，并尝试提前解决这些潜在的问题。</p>\n<h3 id=\"_16-巴纳姆效应-barnum-effect\"> 16. 巴纳姆效应 Barnum Effect</h3>\n<p>也称佛瑞效应。人们会对于他们认为是为自己量身定做的一些人格描述给予高度准确的评价，而这些描述往往十分模糊及普遍，以致能够放诸四海皆准适用于很多人身上。</p>\n<p><strong>🔺 示例</strong></p>\n<p>在产品文案中，尽量避免使用「大家」，「用户」等描述，使用诸如「你」，「你的」之类的可以更贴近用户，人们理解规范性信息时，存在一种选择性代入感，这种代入感会让人无意识地专注于选择贴合自己认知和经验，从而产生一种「我也是这样」的归属感。</p>\n<h3 id=\"_17-框架效应-framing-effect\"> 17. 框架效应 Framing Effect</h3>\n<p>框架效应的意义是，面对同一个的问题，在使用不同的描述后，人们会选择乍听之下较有利或顺耳的描述作为方案。</p>\n<p><strong>🔺 示例</strong></p>\n<p>在大多数情况下，正向表达（例如玻璃杯已满一半）的转换率会更高。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/17.png\" alt=\"框架效应\" style=\"zoom:50%;\">\n  <p style=\"text-align: center; color: #888\">（框架效应）</p>\n</div>\n<h3 id=\"_18-频率错觉-frequency-illusion\"> 18. 频率错觉 Frequency Illusion</h3>\n<p>首次引起我们注意后，我们很快就会从很多地方注意到相关信息。 例如，如果某人想购买一辆新车，通常会突然发现到处都是这辆车。</p>\n<p><strong>🔺 示例</strong></p>\n<p>推动广告系列时，使访问者在不同的营销渠道中接触相同的内容，让别人觉得你的产品周围都是，加深这种新产品的印象。</p>\n<h3 id=\"_19-后见之明偏差-hindsight-bias\"> 19. 后见之明偏差 Hindsight Bias</h3>\n<p>后视偏见会让人沉迷于「我早就预料到了」这种感受当中，无法真正从事件中汲取到有用的经验，也难以用公平的眼光来评判客观事物和他人，主观上也很容易选择性地忽略许多客观事实。</p>\n<p><strong>🔺 示例</strong></p>\n<p>后视偏见会给人带来快感，但也会在工作中影响决策的正确性和公平性，从而带来潜在风险。纠正后视偏见的方法就是在知道事情结果之前，记录下自己的想法，事后做验证并统计相关数据。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/19.png\" alt=\"后见之明偏差\" style=\"zoom:50%;\">\n  <p style=\"text-align: center; color: #888\">（后见之明偏差）</p>\n</div>\n<h3 id=\"_20-当下偏差-current-moment-bias\"> 20. 当下偏差 Current Moment Bias</h3>\n<p>又称现时偏差，人们更倾向于获取即时收益，而非未来的更大收益。</p>\n<p><strong>🔺 示例</strong></p>\n<p>为用户的立即购买提供小折扣（或免费送货），而非承诺他们在将来购买时提供更大的折扣。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/20.png\" alt=\"当下偏差\" style=\"zoom:50%;\">\n  <p style=\"text-align: center; color: #888\">（当下偏差）</p>\n</div>\n<h3 id=\"_21-可辨识受害者效应-identifiable-victim-effect\"> 21. 可辨识受害者效应 Identifiable Victim Effect</h3>\n<p>我们倾向于同情一个特定的人而不是匿名的某一个人。</p>\n<p><strong>🔺 示例</strong></p>\n<p>在讲产品故事时，请使用个体案例，而非一般性陈述。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/21.png\" alt=\"可辨识受害者效应\" style=\"zoom:50%;\">\n  <p style=\"text-align: center; color: #888\">（可辨识受害者效应）</p>\n</div>\n<h3 id=\"_22-宜家效应-ikea-effect\"> 22. 宜家效应 IKEA Effect</h3>\n<p>宜家效应是指人们倾向于高度评价他们参与创造的产品，消费者对于一个物品付出的劳动（情感）越多，就越容易高估该物品的价值。</p>\n<p><strong>🔺 示例</strong></p>\n<p>利用宜家效应提高用户粘性的核心是创造低投入、高回报、高贡献价值的任务，保证用户能够完成任务的基础上贡献自己的价值。在学习场景中我们可以利用宜家效应提高用户粘性，将用户留下来坚持学习。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/22.png\" alt=\"宜家效应\" style=\"zoom:50%;\">\n  <p style=\"text-align: center; color: #888\">（宜家效应）</p>\n</div>\n<h3 id=\"_23-影响力偏差-impact-bias\"> 23. 影响力偏差 Impact Bias</h3>\n<p>我们倾向于高估未来情绪状态的持续时间或强度。</p>\n<p><strong>🔺 示例</strong></p>\n<p>描绘在没有你的产品或服务下用户会遭遇的问题，然后，介绍你的产品会如何解决这些问题。</p>\n<h3 id=\"_24-资讯偏差-information-bias\"> 24. 资讯偏差 Information Bias</h3>\n<p>因测量误差所导致的一种偏误现象，有时亦称为观察偏误或分组错误。</p>\n<p><strong>🔺 示例</strong></p>\n<p>在展示产品或服务时（在网站上或 App 内），请确保附有详细说明的照片。 在产品说明中获得的信息越多，用户获得的保证就越大。</p>\n<h3 id=\"_25-沉没成本谬误-sunk-cost-fallacy\"> 25. 沉没成本谬误 Sunk Cost Fallacy</h3>\n<p>我们在某件事上投入越多就越难放弃它。因此，我们往往会继续执行这个走向失败的行动，仅仅是因为我们过去已经在此投入了过多的时间、金钱或精力。</p>\n<p><strong>🔺 示例</strong></p>\n<p>当游戏玩家支付了每月 30 元的会员费时，很多人会强迫自己继续玩游戏，因为他们已经在虚拟游戏中投入了大量时间和金钱。</p>\n<h3 id=\"_26-损失趋避-loss-aversion\"> 26. 损失趋避 Loss Aversion</h3>\n<p>指人们面对同样数量的收益和损失时，认为损失更加令他们难以忍受。损失带来的负效用为收益正效用的 2 至 2.5 倍。损失厌恶反映了人们的风险偏好并不是一致的，当涉及的是收益时，人们表现为风险厌恶；当涉及的是损失时，人们则表现为风险寻求。</p>\n<p><strong>🔺 示例</strong></p>\n<p>限制特价交易的时间以产生紧迫感：“此优惠在x小时内结束”。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/26.png\" alt=\"损失趋避\" style=\"zoom:50%;\">\n  <p style=\"text-align: center; color: #888\">（损失趋避）</p>\n</div>\n<h3 id=\"_27-单纯接触效应-mere-exposure-effect\"> 27. 单纯接触效应 Mere Exposure Effect</h3>\n<p>人们会单纯因为自己熟悉某个事物而产生好感。它表明某一外在刺激，仅仅因为呈现的次数越频繁（使个体能够接触到该刺激的机会越多），个体对该刺激将越喜欢。</p>\n<p><strong>🔺 示例</strong></p>\n<p>坚持使用用户熟悉的 UI 概念、行为、术语、符号和图标。在营销材料、网站和产品上保持一致来优化漏斗，用词保持和行业术语一致，确保你的用户感到舒适。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/27.png\" alt=\"单纯接触效应\" style=\"zoom:50%;\">\n  <p style=\"text-align: center; color: #888\">（单纯接触效应）</p>\n</div>\n<h3 id=\"_28-负面偏差-negativity-bias\"> 28. 负面偏差 Negativity Bias</h3>\n<p>相比于中性或者积极的事物，具有负面影响的事物对人们的心理影响更大。</p>\n<p><strong>🔺 示例</strong></p>\n<p>通过解决负面体验来说明你的产品价值，如果希望自己的故事能够产生更大的影响,就要尝试多展现情感上负面的内容。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/28.png\" alt=\"负面偏差\" style=\"zoom:50%;\">\n  <p style=\"text-align: center; color: #888\">（负面偏差）</p>\n</div>\n<h3 id=\"_29-忽略可能性-neglect-of-probability\"> 29. 忽略可能性 Neglect of Probability</h3>\n<p>当我们承受压力时，我们没有想到风险发生的可能性。结果，较小的风险可能会被高估或被忽略。</p>\n<p><strong>🔺 示例</strong></p>\n<p>在转换漏斗中，最小的不确定性可能导致用户对产品的不信任并停止使用。 需要确保所有细节均清晰明了并预先显示，尤其是涉及金钱的事物，例如总成本，折扣（如果存在），附加成本等。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/29.png\" alt=\"忽略可能性\" style=\"zoom:50%;\">\n  <p style=\"text-align: center; color: #888\">（忽略可能性）</p>\n</div>\n<h3 id=\"_30-乐观偏差-optimism-bias\"> 30. 乐观偏差 Optimism Bias</h3>\n<p>与别人相比，我们经常高估自己成功的几率。</p>\n<p><strong>🔺 示例</strong></p>\n<p>请确保产品没有隐藏任何可能破坏乐观偏见的令人不愉快的功能（例如额外的费用，可能的延误等）。</p>\n<h3 id=\"_31-鸵鸟效应-ostrich-effect\"> 31. 鸵鸟效应 Ostrich Effect</h3>\n<p>我们故意避免负面信息（或与我们的期望不一致的反馈），认为如果我们把头埋在沙子里，它们就会消失。</p>\n<p><strong>🔺 示例</strong></p>\n<p>与客户支持一起并肩工作，主动去看什么让用户困惑，从处理用户投诉中可以学到很多东西。</p>\n<h3 id=\"_32-规划谬误-planning-fallacy\"> 32. 规划谬误 Planning Fallacy</h3>\n<p>我们倾向于低估完成一项任务所需的时间，通常规划谬误会导致时间超支，成本超支或收益不足。将大型任务分解为较小的部分有助于解决这些问题。</p>\n<p><strong>🔺 示例</strong></p>\n<p>将你的初始估算值乘以 2，不，实际上是 3。这样做不是因为你懒惰，而是因为你的估计可能是错误的。</p>\n<h3 id=\"_33-对抗心理-reactance\"> 33. 对抗心理 Reactance</h3>\n<p>当我们感到某人（或某物）试图剥夺或限制我们的选择时，对抗心理就会发生。当它发生时，我们有一种抵制它并采取相反行动的冲动。</p>\n<p><strong>🔺 示例</strong></p>\n<p>当你与用户「争论」他的选择时要小心，说服对方时必须循循善诱，永远不要与用户直接对抗。</p>\n<h3 id=\"_34-自制偏差-restraint-bias\"> 34. 自制偏差 Restraint Bias</h3>\n<p>人们经常会高估自己控制冲动行为的能力。</p>\n<p><strong>🔺 示例</strong></p>\n<p>我们都认为“标题党”属于旁门左道，但我们还是陷入其中，不是吗？</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/34.png\" alt=\"自制偏差\" style=\"zoom:50%;\">\n  <p style=\"text-align: center; color: #888\">（自制偏差）</p>\n</div>\n<h3 id=\"_35-韵律当理由效应-rhyme-as-reason-effect\"> 35. 韵律当理由效应 Rhyme as Reason Effect</h3>\n<p>人们会更容易把有韵律的、押韵的句子，当作是真实和准确的。一句话只要变得有韵律了，那么就更有说服力了。</p>\n<p><strong>🔺 示例</strong></p>\n<p>大部分广告语都朗朗上口，非常洗脑。</p>\n<p>所以，尽可能的把你的产品文案变得有韵律感，这样更容易说服用户。</p>\n<h3 id=\"_36-风险补偿-risk-compensation\"> 36. 风险补偿 Risk Compensation</h3>\n<p>也称佩尔兹曼效应。当我们感觉到更大的风险时，我们会变得更加谨慎，而当我们受到更多保护时，我们就会没那么谨慎。</p>\n<p>所以当我们知道在已经采取了很多安全措施以后，我们更有可能采取冒险的方式行事。</p>\n<p><strong>🔺 示例</strong></p>\n<p>在购买或注册前让用户对产品产生尽可能的安全感，让他们获得信心和信任。</p>\n<h3 id=\"_37-选择性知觉-selective-perception\"> 37. 选择性知觉 Selective Perception</h3>\n<p>我们对事物的看法在很大程度上受到期望的影响，当人们集中注意力时，人们会从环境中过滤掉事物。</p>\n<p><strong>🔺 示例</strong></p>\n<p>产品的转化漏斗并没有在用户登录时开始，而是在用户首次看到你的广告时就开始了。营销信息与产品提供内容之间的不一致会让你的用户大失所望，从而导致转化率的下降。在所有媒介上（漏斗的各个阶段）的消息一致将为用户带来正确的期望，从而提高转化率。</p>\n<h3 id=\"_38-幸存者偏差-survivorship-bias\"> 38. 幸存者偏差 Survivorship Bias</h3>\n<p>过度关注幸存下来的人或事物，忽略那些被筛选掉的人或事物（可能因为无法观察到），从而得出错误的结论。</p>\n<p><strong>🔺 示例</strong></p>\n<p>在需求分析和调研过程中，如果忽视了幸存者偏差，很有可能搜集到的数据，体现的仅仅只是少部分用户的需求和想法，最终将伪需求和小众需求当作主要需求来作为设计，从而让产品从一开始就走向万劫不复。</p>\n<h3 id=\"_39-零风险偏差-zero-risk-bias\"> 39. 零风险偏差 Zero-Risk Bias</h3>\n<p>我们喜欢确定性，即使它适得其反。在有其他方案可以降低整个风险的情形下，仍倾向于完全消除某一项风险的偏见。一个例子是刻意降低个人负责领域的风险，可是代价是整个组织风险的上升。</p>\n<p><strong>🔺 示例</strong></p>\n<p>提供退款保证和无风险试用，以降低风险水平，使你的用户感到安全。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/39.png\" alt=\"零风险偏差\" style=\"zoom:50%;\">\n  <p style=\"text-align: center; color: #888\">（零风险偏差）</p>\n</div>\n<h3 id=\"_40-感知价值偏差-perceived-value-bias\"> 40. 感知价值偏差 Perceived Value Bias</h3>\n<p>我们根据产品的外观或服务方式来感知其价值。正如人们所说：全部在包装中！</p>\n<p><strong>🔺 示例</strong></p>\n<p>设计对于产品的成功比你想象的更为重要，多余的空间，错误的边框颜色和未对齐的文字，都会影响转化率，确保 UI 设计的优先程度。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/40.png\" alt=\"感知价值偏差\" style=\"zoom:50%;\">\n  <p style=\"text-align: center; color: #888\">（感知价值偏差）</p>\n</div>\n<h3 id=\"_41-分析瘫痪-analysis-paralysis\"> 41. 分析瘫痪 Analysis Paralysis</h3>\n<p>又称选择超载。当出现太多选择时，我们的大脑就会瘫痪，很难进行选择。</p>\n<p><strong>🔺 示例</strong></p>\n<p>选择太多 = 转换率低</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/41.png\" alt=\"分析瘫痪\" style=\"zoom:50%;\">\n  <p style=\"text-align: center; color: #888\">（分析瘫痪）</p>\n</div>\n<h3 id=\"_42-稀缺效应-scarcity-effect\"> 42. 稀缺效应 Scarcity Effect</h3>\n<p>我们将稀缺物品的价值提高，将高可用性物品的价值降低。</p>\n<p>害怕错过（FOMO: fear of missing out）使我们更容易受到诱惑和冲动，并促使我们做出轻率的决定。</p>\n<p><strong>🔺 示例</strong></p>\n<p>使用「限时优惠」，「有限数量」等修辞来形容你的产品或服务。给人的印象是许多人正观看此项目，并随时可以抢走最后的几件物品。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/42.png\" alt=\"稀缺效应\" style=\"zoom:50%;\">\n  <p style=\"text-align: center; color: #888\">（稀缺效应）</p>\n</div>\n<h3 id=\"_43-流畅性启发-fluency-heuristic\"> 43. 流畅性启发 Fluency Heuristic</h3>\n<p>我们认为那些处理速度更快、更流畅、更顺利的事物具有更高的价值。有时不合逻辑的论点在沟通良好的情况下（由有权威和经验的人提出）也可能会赢得胜利。</p>\n<p><strong>🔺 示例</strong></p>\n<ul>\n<li>\n<p>为用户提供便利（快捷、简单和易于理解的导航）</p>\n</li>\n<li>\n<p>使内容易于浏览（图像，易读的字体）</p>\n</li>\n<li>\n<p>创建「心理捷径」，它将吸引用户，促使他们把你的产品作为首选</p>\n</li>\n<li>\n<p>提供有意义的默认选项，因为用户会认为你考虑了他们的最大利益，并将尽可能选择默认选项</p>\n</li>\n<li>\n<p>添加功能强大的跨产品搜索，以简化特定主题的查找</p>\n</li>\n</ul>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/43.png\" alt=\"流畅性启发\" style=\"zoom:50%;\">\n  <p style=\"text-align: center; color: #888\">（流畅性启发）</p>\n</div>\n<h2 id=\"社会偏差\"> 社会偏差</h2>\n<blockquote>\n<p>👫<strong>社会偏差</strong></p>\n<p>这些偏差大多是由归因偏差导致。</p>\n</blockquote>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/b.png\" alt=\"社会偏差\">\n  <p style=\"text-align: center; color: #888\">（社会偏差）</p>\n</div>\n<h3 id=\"_44-行动者-观察者偏差-actor-observer-bias\"> 44. 行动者-观察者偏差 Actor-Observer Bias</h3>\n<p>行动者喜欢将他们自己的行为归因于情境性因素，而观察者喜欢将同样的行为归因于行动者稳定的人格素质。</p>\n<p><strong>🔺 示例</strong></p>\n<p>我们会用外在、不可控的情境性原因来解释自己的行为，比如上班迟到是因为路上出了意外。但是当我们作为观察者，试图对别人的行为进行解释时，我们会用内在的、稳定的人格原因来解释，比如上班迟到是因为他懒、没有时间观念。</p>\n<h3 id=\"_45-达克效应-dunning-kruger-effect\"> 45. 达克效应 Dunning–Kruger Effect</h3>\n<p>我们无法认识到我们缺乏能力，并且由于无法分辨能力好与能力差的不同，因而认为大家都一样。</p>\n<p><strong>🔺 示例</strong></p>\n<ul>\n<li>\n<p>能力差的人通常会高估自己的技能水平；</p>\n</li>\n<li>\n<p>能力差的人不能正确认识到其他真正有此技能的人的水平</p>\n</li>\n<li>\n<p>能力差的人无法认知且正视自身的不足，及其不足之极端程度；</p>\n</li>\n<li>\n<p>如果能力差的人能够经过恰当训练大幅度提高能力水平，他们最终会认知到且能承认他们之前的无能程度。</p>\n</li>\n</ul>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/45.png\" alt=\"达克效应\" style=\"zoom:50%;\">\n  <p style=\"text-align: center; color: #888\">（达克效应）</p>\n</div>\n<h3 id=\"_46-错误共识效应-false-consensus-effect\"> 46. 错误共识效应 False Consensus Effect</h3>\n<p>人们倾向于高估别人对自己的认同程度，想象其他人像我们一样，并分享我们的观点，信念，偏好，价值观和习惯，认为所有人以同样的方式思考。</p>\n<p><strong>🔺 示例</strong></p>\n<p>在没有涉足政坛（或特定国家）的情况下，你最近对你所在国家的选举结果是否感到惊讶？</p>\n<h3 id=\"_47-基本归因谬误-fundamental-attribution-error\"> 47. 基本归因谬误 Fundamental Attribution Error</h3>\n<p>解释他人行为时，归因于内在特质（一定是他有这样的人格，才做出这样的行为），而非外在情境（也许是情势所迫，或这个场所有特殊的潜规则）。基本归因谬误是矛盾和问题的常见来源，而且这种认知偏差存在于用户也同样存在于设计师本身。</p>\n<p><strong>🔺 示例</strong></p>\n<p>需要设计师能够清楚地分辨「我的观点」和「我的行为」，能够真正将自己从自己所处的立场、角色、职能上抽离出来，复盘整个局面。首先接纳全部的现实，包括他人的想法、观点，先不去判断对错，明白事物的动态变化过程。不要再单一地去判断，因为任何一个视角必然会存在一个立场，它们是当前事物诸多层面中的一方面而已。</p>\n<h3 id=\"_48-晕轮效应-halo-effect\"> 48. 晕轮效应 Halo Effect</h3>\n<p>晕轮效应是指使用一个人（或事物）的一种品质来对该人或事物进行整体判断，换句话说，我们对一个人、一个产品、一家公司或一个品牌的最初印象会影响我们对其整体特征的解读。</p>\n<p><strong>🔺 示例</strong></p>\n<p>通过使用权威照片和可建立信任关系的视觉效果来充分利用这种具有启发式的方法。</p>\n<h3 id=\"_49-群内偏差-ingroup-bias\"> 49. 群内偏差 Ingroup Bias</h3>\n<p>群内偏差常被用来引导用户决策，它是指人们会在认知上倾向于自己所属的群体。在体验设计中利用群内偏差的关键点在于打造群体归属感，借由小群体的力量影响用户的决策。</p>\n<p><strong>🔺 示例</strong></p>\n<p>比如 Booking 在查看评论的区域加入了筛选评论语言这一按钮，虽然设计的本意可能是为了方便用户更好地理解评论内容，但是在真实的使用过程中可以发现，用户更加信任自己所选标签内的评论内容，因为同语言往往意味着来自相同的国家或者相近的文化背景，用户通过这种方式找到一个小群体，然后被影响进而做出与群体内人们更为相似的决策。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/49.png\" alt=\"群内偏差\" style=\"zoom:50%;\">\n  <p style=\"text-align: center; color: #888\">（群内偏差）</p>\n</div>\n<h3 id=\"_50-权威偏见-authority-bias\"> 50. 权威偏见 Authority Bias</h3>\n<p>我们认为权威人士给出的建议准确性更高，并且更容易受到该建议的影响（即使事物主体与该人物的权威性无关）</p>\n<p><strong>🔺 示例</strong></p>\n<p>通过宣传产品的知名推荐来建立权威:</p>\n<ul>\n<li>\n<p>联系有影响力的人，让他们免费使用你的产品或服务</p>\n</li>\n<li>\n<p>突出显示知名客户或品牌</p>\n</li>\n<li>\n<p>展示来自社会名流的推荐语</p>\n</li>\n<li>\n<p>在产品展示和陈述中使用权威人物（例如医生、教授等）</p>\n</li>\n</ul>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/50.png\" alt=\"权威偏见\" style=\"zoom:50%;\">\n  <p style=\"text-align: center; color: #888\">（权威偏见）</p>\n</div>\n<h3 id=\"_51-得寸进尺法-foot-in-the-door-technique\"> 51. 得寸进尺法 Foot-in-the-Door Technique</h3>\n<p>得寸进尺法又译登门坎效应，是一种通过先提出一个简单的小请求来说服用户同意一个较大请求的劝说方法。</p>\n<p><strong>🔺 示例</strong></p>\n<ul>\n<li>\n<p>通过提供免费试用与用户建立联系。</p>\n</li>\n<li>\n<p>不要用过于复杂的引导流程让用户感到不耐烦。</p>\n</li>\n<li>\n<p>把大块的内容分解成小块或容易解决的内容，让用户保持开心和参与度。</p>\n</li>\n</ul>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/51.png\" alt=\"得寸进尺法\" style=\"zoom:50%;\">\n  <p style=\"text-align: center; color: #888\">（得寸进尺法）</p>\n</div>\n<h2 id=\"记忆错误与偏差\"> 记忆错误与偏差</h2>\n<blockquote>\n<p>🏹<strong>记忆错误与偏差</strong></p>\n<p>在心理学和认知科学中，记忆偏差是一种认知偏差，导致记忆的强化、弱化（包括能否想起的机会、想起所需的时间，或两者皆有），或者记忆内容的改变。</p>\n</blockquote>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/c.png\" alt=\"记忆错误与偏差\">\n  <p style=\"text-align: center; color: #888\">（记忆错误与偏差）</p>\n</div>\n<h3 id=\"_52-谷歌效应-google-effect\"> 52. 谷歌效应 Google Effect</h3>\n<p>我们会容易忘记可以在网上轻松找到的信息。</p>\n<p><strong>🔺 示例</strong></p>\n<p>你还记得你最好的朋友或孩子的电话号码吗？</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/52.png\" alt=\"谷歌效应\" style=\"zoom:50%;\">\n  <p style=\"text-align: center; color: #888\">（谷歌效应）</p>\n</div>\n<h3 id=\"_53-幽默效应-humor-effect\"> 53. 幽默效应 Humor Effect</h3>\n<p>当信息被认为是有趣或幽默时，我们会更好地记住信息。这可以帮助提高产品的转化率，并有助于整体业务的提升。</p>\n<p><strong>🔺 示例</strong></p>\n<p>在用户可能感到沮丧的情况下不要幽默。例如，如果你的应用与旧设备不兼容，请不要用有趣的方式说出来，因为此时用户可能很沮丧，无法感知幽默。</p>\n<h3 id=\"_54-真相错觉效应-illusion-of-truth-effect\"> 54. 真相错觉效应 Illusion of Truth Effect</h3>\n<p>重复的事情越多，我们就越相信。</p>\n<p><strong>🔺 示例</strong></p>\n<p>在广告，网站，App Store页面，登录页，新闻通讯等一次又一次地重复你的消息（主要好处，主要区别）</p>\n<h3 id=\"_55-峰终法则-peak-end-rule\"> 55. 峰终法则 Peak-End Rule</h3>\n<p>用户不仅仅根据平均或所有体验的总和来评估体验，取而代之的是，他们的大脑会严重地偏向峰值（高或低）和体验的终点，峰值如果是愉悦的话，通常对应了用户旅程中令人难忘的愉悦感。</p>\n<p><strong>🔺 示例</strong></p>\n<p>通过使产品的最佳功能变得更好，保持产品的竞争优势并提高产品高峰。另外也不要忽视产品的“购买后”体验，确保以精湛的品味结束体验。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/55.png\" alt=\"峰终法则\" style=\"zoom:50%;\">\n  <p style=\"text-align: center; color: #888\">（峰终法则）</p>\n</div>\n<h3 id=\"_56-图片优势效应-picture-superiority-effect\"> 56. 图片优势效应  Picture Superiority Effect</h3>\n<p>图片和图像比一千个单词更容易被记住。</p>\n<p><strong>🔺 示例</strong></p>\n<p>始终在内容中包含图像，出色的视觉效果将提高转化率。</p>\n<h3 id=\"_57-首因效应-primacy-effect\"> 57. 首因效应 Primacy Effect</h3>\n<p>又称近时效应、序位效应。列表开头和结尾的项目比中间的项目更容易被用户记住。</p>\n<p><strong>🔺 示例</strong></p>\n<p>如果你打算展示一长串信息，请确保第一个是最重要的内容。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/57.png\" alt=\"首因效应\" style=\"zoom:50%;\">\n  <p style=\"text-align: center; color: #888\">（首因效应）</p>\n</div>\n<h3 id=\"_58-雷斯多夫效应-von-restorff-effect\"> 58. 雷斯多夫效应 Von Restorff Effect</h3>\n<p>当很多信息一起呈现时，醒目的信息和被特别强调的信息会比其他信息更容易被人们记住。</p>\n<p><strong>🔺 示例</strong></p>\n<p>确保CTA按钮以不同的样式，大小，颜色和位置显示出来，以达到不同的目的。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/58.png\" alt=\"雷斯多夫效应\" style=\"zoom:50%;\">\n  <p style=\"text-align: center; color: #888\">（雷斯多夫效应）</p>\n</div>\n<h3 id=\"_59-蔡格尼效应-zeigarnik-effect\"> 59. 蔡格尼效应 Zeigarnik Effect</h3>\n<p>进行中的任务会产生特定于任务的张力。当任务完成时，这种压力可以缓解，但如果任务被中断，它将保持不变。这种张力使相关信息更易于访问和记忆。</p>\n<p><strong>🔺 示例</strong></p>\n<p>显示一个不完整的进度栏，以鼓励用户实现自己的目标。</p>\n<h2 id=\"统计与几率偏差\"> 统计与几率偏差</h2>\n<blockquote>\n<p>📚<strong>统计与几率偏差</strong></p>\n<p>几率性推论是指根据有关几率的资讯推论事情的可能性，而几率的估算通常来自统计资料，因此两者密不可分。</p>\n</blockquote>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/d.png\" alt=\"统计与几率偏差\">\n  <p style=\"text-align: center; color: #888\">（统计与几率偏差）</p>\n</div>\n<h3 id=\"_60-基本比率谬误-base-rate-fallacy\"> 60. 基本比率谬误 Base Rate fallacy</h3>\n<p>我们倾向于忽略一般信息，而只关注特定案例。</p>\n<p><strong>🔺 示例</strong></p>\n<p>不要只分享那些冷冰冰的产品信息。相反地，展示其他相关用户或公司的评价、用例。如果你想更具有说服力 —— 把你的量化数据和一些个人故事相结合。用量化数据合理地支持你的观点。具体的例子会在情感上传递你想表达的信息。</p>\n<h3 id=\"_61-赌徒谬误-gambler-s-fallacy\"> 61. 赌徒谬误 Gambler's Fallacy</h3>\n<p>我们错误地认为，如果在给定时期内某件事情频繁发生，那么这件事情在将来发生的几率就会很小。</p>\n<p><strong>🔺 示例</strong></p>\n<p>坚持事实，少依靠直觉，更多的依靠数据。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/61.png\" alt=\"赌徒谬误\" style=\"zoom:50%;\">\n  <p style=\"text-align: center; color: #888\">（赌徒谬误）</p>\n</div>\n<h3 id=\"_62-热手谬误-hot-hand-fallacy\"> 62. 热手谬误 Hot-Hand Fallacy</h3>\n<p>错误地认为经历过成功的人更有可能在其他尝试中进一步获得成功。一般是在某人近来做某事很成功时，认为他未来做同一件事也会很成功，而忽略其成功可能只是随机与巧合导致。</p>\n<p><strong>🔺 示例</strong></p>\n<p>通过强调一系列成功案例来建立自己的强大品牌。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/62.png\" alt=\"热手谬误\" style=\"zoom:50%;\">\n  <p style=\"text-align: center; color: #888\">（热手谬误）</p>\n</div>\n<h3 id=\"_63-对样本数不敏锐-insensitivity-to-sample-size\"> 63. 对样本数不敏锐 Insensitivity to Sample Size</h3>\n<p>我们经常忽略样本大小并贸然下结论，即使样本数量还未达到足够的统计量。</p>\n<p><strong>🔺 示例</strong></p>\n<p>与客户沟通很重要，但不要把产品设想建立在几次面谈的基础上。使用大量数据，并根据实际数据而非假设来做出产品决策。</p>\n<h2 id=\"实验与研究偏差\"> 实验与研究偏差</h2>\n<blockquote>\n<p>🔬<strong>实验与研究偏差</strong></p>\n<p>这是一些科学实验或统计研究容易发生的偏差。</p>\n</blockquote>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cognitive-biases/e.png\" alt=\"实验与研究偏差\">\n  <p style=\"text-align: center; color: #888\">（实验与研究偏差）</p>\n</div>\n<h3 id=\"_64-取样偏差-sampling-bias\"> 64. 取样偏差 Sampling Bias</h3>\n<p>某些类型的用户被无意中从研究参与者池中剔除了。亦可理解为以偏概全，即以局部事例解释整体原因。</p>\n<p><strong>🔺 示例</strong></p>\n<p>你正在设计自行车跟踪应用，需要对骑行者进行研究。你决定采访并观察北京市的自行车骑行者，但你没有意识到他们的骑行行为习惯可能与居住在山丘多的郊区的骑行者有很大不同。因此你的研究成果可能有不适用于所有目标受众的风险。</p>\n<h3 id=\"_65-观察者期望效应-observer-expectancy-effect\"> 65. 观察者期望效应  Observer-Expectancy Effect</h3>\n<p>研究者有时可能会期望出现某种结果，他们无意识地操纵了试验过程，或者错误地解释实验结果，导致研究结果严重歪曲。</p>\n<p><strong>🔺 示例</strong></p>\n<p>在用户研究中，研究者的表情、肢体语言等都可能会反映出自己所期待的结果，如果用户察觉到了这些，就可能做一些迎合研究者期望的反应。</p>\n<h3 id=\"_66-社会期许偏差-social-desirability-bias\"> 66. 社会期许偏差 Social Desirability Bias</h3>\n<p>我们倾向于多表达符合社会期许的事情，而隐瞒那些不符合社会预期的事情。例如在询问是否有不良嗜好、性伴侣数量时，大家会有意无意地隐瞒或淡化实情。</p>\n<p><strong>🔺 示例</strong></p>\n<p>社会证明是建立信任的好方法。以下是可在产品页面上使用的一些示例：</p>\n<ul>\n<li>\n<p>知名的客户logo</p>\n</li>\n<li>\n<p>知名的合作伙伴logo</p>\n</li>\n<li>\n<p>客户的好评和真实推荐（来自目标受众）</p>\n</li>\n<li>\n<p>累计数据（客户数量，交易次数等任何有价值的数字）</p>\n</li>\n<li>\n<p>媒体的提及和引用</p>\n</li>\n<li>\n<p>由知名组织颁发的奖项认证</p>\n</li>\n<li>\n<p>证书</p>\n</li>\n<li>\n<p>真实数据支撑案例的链接</p>\n</li>\n</ul>\n<p>不要说「我们很棒，因为……」，而是通过其他人来证实。</p>\n<h3 id=\"_67-遗漏变数偏差-omitted-variable-bias\"> 67. 遗漏变数偏差 Omitted-Variable Bias</h3>\n<p>当获得的奖励出乎意料之外，我们获得奖励的喜悦感就会增加。</p>\n<p><strong>🔺 示例</strong></p>\n<p>为用户提供每日优惠，免费奖金，奖章，奖品等。每天创建的「动作」越多，用户就越会感受到与产品的联系。</p>\n<h2 id=\"认知偏差学习资料\"> 认知偏差学习资料</h2>\n<ul>\n<li>《穷查理宝典》</li>\n<li>得到 APP：余剑锋老师的《行为经济学》课程</li>\n<li>原文出处：《<a href=\"https://s75w5y7vut.feishu.cn/docs/doccn3BatnScBJe7wD7K3S5poFf\" target=\"_blank\" rel=\"noopener noreferrer\">飞书 - 认知偏差知识手册</a>》</li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-11-08T09:59:13.000Z",
      "date_modified": "2021-12-09T08:58:55.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "响应式原理",
      "url": "https://www.fedbook.cn/frontend-engineering/vuejs/reactive-data/",
      "id": "https://www.fedbook.cn/frontend-engineering/vuejs/reactive-data/",
      "content_html": "<h1 id=\"响应式原理\"> 响应式原理</h1>\n<h2 id=\"定义\"> 定义</h2>\n<p>响应式指的是组件 data 的数据一旦变化，立刻触发视图的更新。它是实现数据驱动视图的第一步。</p>\n<h2 id=\"监听-data-变化的核心-api\"> 监听 data 变化的核心 API</h2>\n<p>Vue 实现响应式的一个核心 API 是 <code>Object.defineProperty</code>。该方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p>\n<p>基本用法：</p>\n<div><pre><code><span>const</span> data <span>=</span> <span>{</span><span>}</span>\n<span>const</span> name <span>=</span> <span>'zhangsan'</span>\nObject<span>.</span><span>defineProperty</span><span>(</span>data<span>,</span> <span>'name'</span><span>,</span> <span>{</span>\n  <span>get</span><span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span> \n    console<span>.</span><span>log</span><span>(</span><span>'get'</span><span>)</span>\n    <span>return</span> name\n  <span>}</span><span>,</span>\n  <span>set</span><span>:</span> <span>function</span><span>(</span><span>newVal</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'set'</span><span>)</span>\n    name <span>=</span> newVal\n  <span>}</span>\n<span>}</span><span>)</span>\n\n\n<span>// 测试</span>\nconsole<span>.</span><span>log</span><span>(</span>data<span>.</span>name<span>)</span> <span>// get zhangsan</span>\ndata<span>.</span>name <span>=</span> <span>'lisi'</span>     <span>// set</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>利用 <code>Object.defineProperty</code> 重写 <code>get</code> 和 <code>set</code>，将对象属性的赋值和获取变成函数，我们可以实现一个简单的双向绑定。</p>\n<h2 id=\"如何监听-data-变化\"> 如何监听 data 变化</h2>\n<p>共定义了三个函数：</p>\n<ul>\n<li>updateView：模拟 Vue 更新视图的入口函数。</li>\n<li>defineReactive：对数据进行监听的具体实现。</li>\n<li>observer：调用该函数后，可对目标对象进行监听，将目标对象编程响应式的。</li>\n</ul>\n<p>执行逻辑为：<br>\n定义一个对象 <code>data</code> =&gt; 调用 <code>observer(data)</code> 将对象变成响应式的 =&gt; 修改对象内的属性 =&gt; 更新视图</p>\n<div><pre><code><span>// 触发更新视图</span>\n<span>function</span> <span>updateView</span><span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'视图更新'</span><span>)</span>\n<span>}</span>\n\n<span>// 重新定义属性，监听起来</span>\n<span>function</span> <span>defineReactive</span><span>(</span><span>target<span>,</span> key<span>,</span> value</span><span>)</span> <span>{</span>\n  <span>// 核心 API</span>\n  Object<span>.</span><span>defineProperty</span><span>(</span>target<span>,</span> key<span>,</span> <span>{</span>\n    <span>get</span><span>(</span><span>)</span> <span>{</span>\n      <span>return</span> value\n    <span>}</span><span>,</span>\n    <span>set</span><span>(</span>newValue<span>)</span> <span>{</span>\n      <span>if</span> <span>(</span>newValue <span>!==</span> value<span>)</span> <span>{</span>\n        <span>// 设置新值</span>\n        <span>// 注意，value 一直在闭包中，此处设置完之后，再 get 时也是会获取最新的值</span>\n        value <span>=</span> newValue\n\n        <span>// 触发更新视图</span>\n        <span>updateView</span><span>(</span><span>)</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span><span>)</span>\n<span>}</span>\n\n<span>// 监听对象属性</span>\n<span>function</span> <span>observer</span><span>(</span><span>target</span><span>)</span> <span>{</span>\n  <span>if</span> <span>(</span><span>typeof</span> target <span>!==</span> <span>'object'</span> <span>||</span> target <span>===</span> <span>null</span><span>)</span> <span>{</span>\n    <span>// 监听的不是对象或数组时，直接返回</span>\n    <span>return</span> target\n  <span>}</span>\n\n  <span>// 重新定义各个属性（for in 也可以遍历数组）</span>\n  <span>for</span> <span>(</span><span>let</span> key <span>in</span> target<span>)</span> <span>{</span>\n    <span>defineReactive</span><span>(</span>target<span>,</span> key<span>,</span> target<span>[</span>key<span>]</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><p>测试一下，会打印出两个 <code>&quot;视图更新&quot;</code> 字符串。</p>\n<div><pre><code><span>// 准备数据</span>\n<span>const</span> data <span>=</span> <span>{</span>\n  name<span>:</span> <span>'zhangsan'</span><span>,</span>\n  age<span>:</span> <span>20</span>\n<span>}</span>\n\n<span>// 监听数据</span>\n<span>observer</span><span>(</span>data<span>)</span>\n\n<span>// 测试</span>\ndata<span>.</span>name <span>=</span> <span>'lisi'</span>\ndata<span>.</span>age <span>=</span> <span>21</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id=\"如何深度监听-data-变化\"> 如何深度监听 data 变化</h2>\n<p>对于有嵌套属性的数据，例如：</p>\n<div><pre><code><span>// 准备数据</span>\n<span>const</span> data <span>=</span> <span>{</span>\n  name<span>:</span> <span>'zhangsan'</span><span>,</span>\n  age<span>:</span> <span>20</span><span>,</span>\n  info<span>:</span> <span>{</span>\n    address<span>:</span> <span>'北京'</span> <span>// 需要深度监听</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>要想监听到 <code>info.address</code> 的变化，则需要深度监听，修改 defineReactive 方法即可：</p>\n<ul>\n<li>在刚进入 <code>defineReactive</code> 函数的时候，先调用 <code>observer</code> 对传进来的值进行判断，由于 <code>info</code> 是个对象，所以会对 <code>info</code> 遍历后再执行 <code>defineReactive</code>；而其它基本类型的值在 <code>observer</code> 中被直接返回。</li>\n<li>在设置新值时也要对新值进行深度监听，原因是新值也可能是个对象，需要监听到它里面的属性。</li>\n</ul>\n<div><div><br><br><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code><span>// 重新定义属性，监听起来</span>\n<span>function</span> <span>defineReactive</span><span>(</span><span>target<span>,</span> key<span>,</span> value</span><span>)</span> <span>{</span>\n  <span>// 深度监听</span>\n  <span>observer</span><span>(</span>value<span>)</span>\n\n  <span>// 核心 API</span>\n  Object<span>.</span><span>defineProperty</span><span>(</span>target<span>,</span> key<span>,</span> <span>{</span>\n    <span>get</span><span>(</span><span>)</span> <span>{</span>\n      <span>return</span> value\n    <span>}</span><span>,</span>\n    <span>set</span><span>(</span>newValue<span>)</span> <span>{</span>\n      <span>if</span> <span>(</span>newValue <span>!==</span> value<span>)</span> <span>{</span>\n        <span>// 深度监听</span>\n        <span>observer</span><span>(</span>newValue<span>)</span>\n\n        <span>// 设置新值</span>\n        <span>// 注意，value 一直在闭包中，此处设置完之后，再 get 时也是会获取最新的值</span>\n        value <span>=</span> newValue\n\n        <span>// 触发更新视图</span>\n        <span>updateView</span><span>(</span><span>)</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span><span>)</span>\n<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h2 id=\"object-defineproperty-缺点\"> Object.defineProperty 缺点</h2>\n<ul>\n<li>深度监听时，需要递归到底，一次性计算量大</li>\n<li>无法监听新增属性/删除属性（所以开发中需要使用 Vue.set 和 Vue.delete 这两个 API 来增删 data 的属性）</li>\n<li>无法原生监听数组，需要特殊处理</li>\n</ul>\n<h2 id=\"如何监听数组变化\"> 如何监听数组变化</h2>\n<p><a href=\"https://segmentfault.com/a/1190000015783546\" target=\"_blank\" rel=\"noopener noreferrer\">由于性能原因</a>，Vue 不是通过 <code>Object.defineProperty</code> 来监听数组的。</p>\n<p>对于数组，是通过重写数组方法来实现，共修改了两处：</p>\n<ul>\n<li>对原生数组原型做一个备份（防止后续的操作污染原生数组原型），基于这个备份创建一个新的数组，并扩展（在执行原方法前触发一次视图更新）它的方法。</li>\n<li>observer 方法中，增加对数组的处理。</li>\n</ul>\n<p>执行逻辑为：<br>\n定义一个对象 <code>data</code> =&gt; 调用 <code>observer(data)</code>，在内部判断 <code>data</code> 是对象，则遍历该对象的每个属性并依次执行 <code>defineReactive</code> =&gt; <code>defineReactive</code> 内部的 <code>observer(value)</code> 碰到数组 <code>nums</code>，则将该数组的隐式原型赋值成我们重写之后的原型；除 <code>nums</code> 外的其它类型属性，走之前的逻辑 =&gt; 更新视图</p>\n<div><div><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br></div><pre><code><span>// 触发更新视图</span>\n<span>function</span> <span>updateView</span><span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'视图更新'</span><span>)</span>\n<span>}</span>\n\n<span>// 重新定义数组原型</span>\n<span>const</span> oldArrayProperty <span>=</span> <span>Array</span><span>.</span>prototype\n<span>// 创建新对象，原型指向 oldArrayProperty ，再扩展新的方法不会影响原型</span>\n<span>const</span> arrProto <span>=</span> Object<span>.</span><span>create</span><span>(</span>oldArrayProperty<span>)</span><span>;</span>\n<span>[</span><span>'push'</span><span>,</span> <span>'pop'</span><span>,</span> <span>'shift'</span><span>,</span> <span>'unshift'</span><span>,</span> <span>'splice'</span><span>]</span><span>.</span><span>forEach</span><span>(</span><span>methodName</span> <span>=></span> <span>{</span>\n  arrProto<span>[</span>methodName<span>]</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n    <span>updateView</span><span>(</span><span>)</span> <span>// 触发视图更新</span>\n    oldArrayProperty<span>[</span>methodName<span>]</span><span>.</span><span>call</span><span>(</span><span>this</span><span>,</span> <span>...</span>arguments<span>)</span>\n  <span>}</span>\n<span>}</span><span>)</span>\n\n<span>// 重新定义属性，监听起来</span>\n<span>function</span> <span>defineReactive</span><span>(</span><span>target<span>,</span> key<span>,</span> value</span><span>)</span> <span>{</span>\n  <span>// 深度监听</span>\n  <span>observer</span><span>(</span>value<span>)</span>\n\n  <span>// Object.defineProperty 部分的代码省略</span>\n  ……\n<span>}</span>\n\n<span>// 监听对象属性</span>\n<span>function</span> <span>observer</span><span>(</span><span>target</span><span>)</span> <span>{</span>\n  <span>if</span> <span>(</span><span>typeof</span> target <span>!==</span> <span>'object'</span> <span>||</span> target <span>===</span> <span>null</span><span>)</span> <span>{</span>\n    <span>// 监听的不是对象或数组时，直接返回</span>\n    <span>return</span> target\n  <span>}</span>\n\n  <span>if</span> <span>(</span>Array<span>.</span><span>isArray</span><span>(</span>target<span>)</span><span>)</span> <span>{</span>\n    target<span>.</span>__proto__ <span>=</span> arrProto\n  <span>}</span>\n\n  <span>// 重新定义各个属性（for in 也可以遍历数组）</span>\n  <span>for</span> <span>(</span><span>let</span> key <span>in</span> target<span>)</span> <span>{</span>\n    <span>defineReactive</span><span>(</span>target<span>,</span> key<span>,</span> target<span>[</span>key<span>]</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><p>测试一下，执行 <code>data.nums.push(4)</code> 时会打印出 <code>&quot;视图更新&quot;</code> 字符串并在数组末尾添加进元素。</p>\n<div><pre><code><span>// 准备数据</span>\n<span>const</span> data <span>=</span> <span>{</span>\n  name<span>:</span> <span>'zhangsan'</span><span>,</span>\n  age<span>:</span> <span>20</span><span>,</span>\n  info<span>:</span> <span>{</span>\n    address<span>:</span> <span>'北京'</span>\n  <span>}</span><span>,</span>\n  nums<span>:</span> <span>[</span><span>10</span><span>,</span> <span>20</span><span>,</span> <span>30</span><span>]</span> <span>// 需要监听的数组</span>\n<span>}</span>\n\n<span>// 监听数据</span>\n<span>observer</span><span>(</span>data<span>)</span>\n\n<span>// 测试</span>\ndata<span>.</span>nums<span>.</span><span>push</span><span>(</span><span>4</span><span>)</span> <span>// 监听数组</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>（完）</p>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2021-11-19T03:27:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "模板编译",
      "url": "https://www.fedbook.cn/frontend-engineering/vuejs/template-compile/",
      "id": "https://www.fedbook.cn/frontend-engineering/vuejs/template-compile/",
      "content_html": "<h1 id=\"模板编译\"> 模板编译</h1>\n<h2 id=\"前置知识点-with-语法\"> 前置知识点：with 语法</h2>\n<p>首先复习一个 JS 的冷门知识点：<code>with</code> 语法。</p>\n<p>常规作用域查找变量方式：</p>\n<div><pre><code><span>const</span> obj <span>=</span> <span>{</span>a<span>:</span> <span>100</span><span>,</span> b<span>:</span> <span>200</span><span>}</span>\n\nconsole<span>.</span><span>log</span><span>(</span>obj<span>.</span>a<span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>obj<span>.</span>b<span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>obj<span>.</span>c<span>)</span> <span>// undefined</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>使用 <code>with</code> 后，能改变 <code>{}</code> 内自由变量的查找方式：将 <code>{}</code> 内自由变量当作 <code>obj</code> 的属性来查找：</p>\n<div><pre><code><span>with</span><span>(</span>obj<span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>obj<span>.</span>a<span>)</span>\n  console<span>.</span><span>log</span><span>(</span>obj<span>.</span>b<span>)</span>\n  console<span>.</span><span>log</span><span>(</span>obj<span>.</span>c<span>)</span> <span>// 会报错</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>在平时开发中，一般慎用 <code>with</code> 语法，这是因为它打破了作用域规则，使代码易读性变差了。但这里把它作为前置知识点是因为模板编译中用到了。</p>\n<h2 id=\"vue-模板被编译成什么\"> Vue 模板被编译成什么</h2>\n<ul>\n<li>Vue 的模板不是 html，因为它有指令、插值、JS 表达式，能实现判断、循环；</li>\n<li>html 是标签语言，只有 JS 才能实现判断、循环。</li>\n</ul>\n<p>因此，模板一定是转换为某种 JS 代码，即编译模板。</p>\n<h2 id=\"vue-模板编译过程\"> Vue 模板编译过程</h2>\n<ul>\n<li>模板编译为 render 函数，执行 render 函数返回 vnode；</li>\n<li>基于 vnode 再执行 patch 和 diff；</li>\n<li>使用 Webpack 时，vue-loader 会在开发环境下编译模板（目前业内主流）；否则会在浏览器运行时中编译（单独在页面中引入 vue.js 使用）。</li>\n</ul>\n<p>用代码来解释编译过程：</p>\n<div><pre><code><span>// Step1: 一个 template，使用了插值语法</span>\n<span>const</span> template <span>=</span> <span><span>`</span><span>&lt;p>{{message}}&lt;/p></span><span>`</span></span>\n\n<span>// Step2: 上述 template 被编译后，得到 JS 代码如下</span>\n<span>// with 语法，后面的自由变量的查找都会变成 this 的查找</span>\n<span>// this 指向 vm 实例: vm = new vue({...})</span>\n<span>with</span><span>(</span><span>this</span><span>)</span><span>{</span><span>return</span> <span>createElement</span><span>(</span><span>'p'</span><span>,</span><span>[</span><span>createTextVNode</span><span>(</span><span>toString</span><span>(</span>message<span>)</span><span>)</span><span>]</span><span>)</span><span>}</span>\n\n<span>// Step3: 执行上述函数后，返回 vnode</span>\n<span>// 类似 snabbdom 的 h 函数: h('p', {}, [...]) => vnode</span>\n\n<span>// Step4: 渲染和更新</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id=\"vue-组件中使用-render-代替-template\"> vue 组件中使用 render 代替 template</h2>\n<p>通过 <code>template</code> 来定义 Vue 组件：</p>\n<div><pre><code>Vue<span>.</span><span>component</span><span>(</span><span>'heading'</span><span>,</span> <span>{</span>\n  template<span>:</span> <span><span>`</span><span>&lt;h3>&lt;a name=\"headerId\" href=\"#headerId\">this is a tag&lt;/a>&lt;/h3></span><span>`</span></span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>通过 <code>render</code> 属性来定义 Vue 组件，需要定义一个函数，参数为 <code>createElement</code>。</p>\n<p><code>createElement</code> 类似于前面介绍的编译后的函数体，它的第一个参数是标签，第二个参数是属性（可不写），第三个参数是子元素。</p>\n<div><pre><code>Vue<span>.</span><span>component</span><span>(</span><span>'heading'</span><span>,</span> <span>{</span>\n  <span>render</span><span>:</span> <span>function</span><span>(</span><span>createElement</span><span>)</span> <span>{</span>\n    <span>return</span> <span>createElement</span><span>(</span>\n      <span>'h'</span> <span>+</span> <span>this</span><span>.</span>level<span>,</span>\n      <span>[</span>\n        <span>createElement</span><span>(</span><span>'a'</span><span>,</span> <span>{</span>\n          attrs<span>:</span> <span>{</span>\n            name<span>:</span> <span>'headerId'</span><span>,</span>\n            href<span>:</span> <span>'#'</span> <span>+</span> <span>'headerId'</span>\n          <span>}</span>\n        <span>}</span><span>,</span> <span>'this is a tag'</span><span>)</span>\n      <span>]</span>\n    <span>)</span>\n  <span>}</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>在有些复杂情况中，不能用 <code>template</code>，可以考虑用 <code>render</code>。</p>\n<p>（完）</p>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2021-11-19T03:27:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "虚拟 DOM 与 diff 算法",
      "url": "https://www.fedbook.cn/frontend-engineering/vuejs/virtual-dom-and-diff/",
      "id": "https://www.fedbook.cn/frontend-engineering/vuejs/virtual-dom-and-diff/",
      "content_html": "<h1 id=\"虚拟-dom-与-diff-算法\"> 虚拟 DOM 与 diff 算法</h1>\n<h2 id=\"虚拟-dom\"> 虚拟 DOM</h2>\n<p>虚拟 DOM（Virtual DOM）的简写为 vdom，它是实现 Vue 和 React 的重要基石。</p>\n<p>在 jQuery 及更早的时代，我们需要手动调整 DOM，这是一个非常耗费性能的操作，因此需要自行控制 DOM 操作的时机来优化 jQuery 性能。</p>\n<p>DOM 更新非常耗时，但 JS 执行速度很快，因此现代前端框架（如 Vue 和 React）都引入了 vdom 的概念：用 JS 模拟 DOM 结构（vnode），新旧 vnode 对比，得出最小的更新范围，最后更新 DOM。</p>\n<p>在数据驱动视图的模式下，vdom 能有效控制 DOM 操作。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/dom-to-js.png\" alt=\"用 JS 模拟 DOM 结构\">\n  <p style=\"text-align:center; color: #888;\">（用 JS 模拟 DOM 结构）</p>\n</div>\n<h2 id=\"diff-算法\"> diff 算法</h2>\n<p>diff 算法是 vdom 中最核心、最关键的部分。</p>\n<p>为了将时间复杂度优化到 <code>O(n)</code>，大部分前端框架中实现 diff 算法的思路是：</p>\n<ul>\n<li>只比较同一层级，不跨级比较。</li>\n<li>tag 不相同，则直接删掉重建，不再深度比较。</li>\n<li>tag 和 key 两者都相同，则认为是相同节点，不再深度比较。</li>\n</ul>\n<h2 id=\"snabbdom\"> snabbdom</h2>\n<p><a href=\"https://github.com/snabbdom/snabbdom\" target=\"_blank\" rel=\"noopener noreferrer\">snabbdom</a> 是一个简洁强大的 vdom 库，源码简短，总体代码行数不超过 500 行。Vue 在实现 vdom 和 diff 时也或多或者参考了它，因此可以通过 snabbdom 学习 vdom。</p>\n<div><p>注意</p>\n<p>以下内容仅是学习大体思路，非细抠源代码。</p>\n</div>\n<h3 id=\"example-解读\"> Example 解读</h3>\n<p>参考 snabbdom 官方仓库中 README 里的 Example，下面列出几个比较关键的代码块，并附上注释：</p>\n<div><pre><code><span>// 引用和初始化一些列包</span>\n<span>import</span> <span>{</span> \n  <span>// 省略模块名</span>\n<span>}</span> <span>from</span> <span>\"snabbdom\"</span><span>;</span>\n<span>const</span> patch <span>=</span> <span>init</span><span>(</span><span>[</span>\n  <span>// 省略模块名</span>\n<span>]</span><span>)</span><span>;</span>\n\n<span>// 空节点/DOM 元素，作为容器</span>\n<span>const</span> container <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>\"container\"</span><span>)</span><span>;</span>\n\n<span>// h 函数会返回一个 vdom，它是一个用 JS 模拟 DOM 元素</span>\n<span>const</span> vnode <span>=</span> <span>h</span><span>(</span>参数<span>1</span><span>,</span> 参数<span>2</span><span>,</span> 参数<span>3</span><span>)</span><span>;</span>\n<span>// 初次渲染：将 vnode 渲染到空元素中</span>\n<span>patch</span><span>(</span>container<span>,</span> vnode<span>)</span><span>;</span>\n\n<span>const</span> newVnode <span>=</span> <span>h</span><span>(</span>参数<span>1</span><span>,</span> 参数<span>2</span><span>,</span> 参数<span>3</span><span>)</span><span>;</span>\n<span>// DOM 更新：更新已有的元素</span>\n<span>patch</span><span>(</span>vnode<span>,</span> newVnode<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>关键的三要素：</p>\n<ul>\n<li><code>h</code> 函数：由 snabbdom 提供，有 3 个参数（标签，data，子元素）</li>\n<li>vnode 数据结构：由 h 函数返回，是一个用 JS 模拟 DOM 元素</li>\n<li><code>patch</code> 函数：由 snabbdom 提供，用于将 vdom（第二个参数） 渲染到容器（第一个参数）上</li>\n</ul>\n<h3 id=\"生成-vnode-的源码\"> 生成 vnode 的源码</h3>\n<p>vnode 是由 <code>h</code> 函数生成的，该函数的源码位于 <code>src/h.ts</code>。</p>\n<p>该文件内部主要定义了 <code>h</code> 函数可以接收的各种参数形式和参数类型，经过一系列处理后，最后返回了一个新的函数 <code>vnode</code> 函数，位于 <code>src/vnode.ts</code>。</p>\n<p>在 <code>src/vnode.ts</code> 文件中，一开始也是一堆定义，主要看最后一段，如下（官方仓库的最新源码可能会实时变动）：</p>\n<div><pre><code><span>export</span> <span>function</span> <span>vnode</span><span>(</span>\n  sel<span>:</span> <span>string</span> <span>|</span> <span>undefined</span><span>,</span>\n  data<span>:</span> <span>any</span> <span>|</span> <span>undefined</span><span>,</span>\n  children<span>:</span> <span>Array</span><span>&lt;</span>VNode <span>|</span> <span>string</span><span>></span> <span>|</span> <span>undefined</span><span>,</span>\n  text<span>:</span> <span>string</span> <span>|</span> <span>undefined</span><span>,</span>\n  elm<span>:</span> Element <span>|</span> Text <span>|</span> <span>undefined</span>\n<span>)</span><span>:</span> VNode <span>{</span>\n  <span>const</span> key <span>=</span> data <span>===</span> <span>undefined</span> <span>?</span> <span>undefined</span> <span>:</span> data<span>.</span>key<span>;</span>\n  <span>return</span> <span>{</span> sel<span>,</span> data<span>,</span> children<span>,</span> text<span>,</span> elm<span>,</span> key <span>}</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>该函数最终返回的是一个对象 <code>{ sel, data, children, text, elm, key }</code>：</p>\n<ul>\n<li><code>sel</code>，<code>data</code>，<code>children</code>，<code>text</code> 就是前面提到的，其中 <code>children</code>，<code>text</code> 不能共存（一个标签元素下要么是文本字符串，要么是子元素）。</li>\n<li><code>elm</code> 是 vnode 对应的 DOM 元素，即 <code>patch</code> 函数需要渲染的目标元素。</li>\n<li><code>key</code> 类似于 <code>v-for</code> 的 <code>key</code>。</li>\n</ul>\n<h3 id=\"patch-函数的源码\"> patch 函数的源码</h3>\n<p><code>patch</code> 函数位于 <code>src/init.ts</code> 中的最后（官方仓库的最新源码可能会实时变动）。</p>\n<div><pre><code><span>// patch 函数的第一个参数可以是 vnode 或 element，第二个参数是 vnode</span>\n<span>return</span> <span>function</span> <span>patch</span><span>(</span>oldVnode<span>:</span> VNode <span>|</span> Element<span>,</span> vnode<span>:</span> VNode<span>)</span><span>:</span> VNode <span>{</span>\n  <span>let</span> i<span>:</span> <span>number</span><span>,</span> elm<span>:</span> Node<span>,</span> parent<span>:</span> Node<span>;</span>\n  <span>const</span> insertedVnodeQueue<span>:</span> VNodeQueue <span>=</span> <span>[</span><span>]</span><span>;</span>\n  <span>// cbs 即 callbacks，pre 是一个 hook（生命周期）</span>\n  <span>for</span> <span>(</span>i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> cbs<span>.</span>pre<span>.</span>length<span>;</span> <span>++</span>i<span>)</span> cbs<span>.</span>pre<span>[</span>i<span>]</span><span>(</span><span>)</span><span>;</span>\n\n  <span>// 第一个参数不是 vnode</span>\n  <span>if</span> <span>(</span><span>!</span><span>isVnode</span><span>(</span>oldVnode<span>)</span><span>)</span> <span>{</span>\n    <span>// 创建一个空的 vnode，关联到这个 DOM 元素</span>\n    oldVnode <span>=</span> <span>emptyNodeAt</span><span>(</span>oldVnode<span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>// 相同的 vnode（key 和 sel 都相等视为相同的 vnode）</span>\n  <span>// 都为 undefined 也是相同</span>\n  <span>if</span> <span>(</span><span>sameVnode</span><span>(</span>oldVnode<span>,</span> vnode<span>)</span><span>)</span> <span>{</span>\n    <span>// 对比 vnode，渲染</span>\n    <span>patchVnode</span><span>(</span>oldVnode<span>,</span> vnode<span>,</span> insertedVnodeQueue<span>)</span><span>;</span>\n\n  <span>// 不同的 vnode，直接删掉重建</span>\n  <span>}</span> <span>else</span> <span>{</span>\n    elm <span>=</span> oldVnode<span>.</span>elm<span>!</span><span>;</span>\n    parent <span>=</span> api<span>.</span><span>parentNode</span><span>(</span>elm<span>)</span> <span>as</span> Node<span>;</span>\n\n    <span>// 重建</span>\n    <span>createElm</span><span>(</span>vnode<span>,</span> insertedVnodeQueue<span>)</span><span>;</span>\n\n    <span>if</span> <span>(</span>parent <span>!==</span> <span>null</span><span>)</span> <span>{</span>\n      api<span>.</span><span>insertBefore</span><span>(</span>parent<span>,</span> vnode<span>.</span>elm<span>!</span><span>,</span> api<span>.</span><span>nextSibling</span><span>(</span>elm<span>)</span><span>)</span><span>;</span>\n      <span>removeVnodes</span><span>(</span>parent<span>,</span> <span>[</span>oldVnode<span>]</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n\n  <span>for</span> <span>(</span>i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> insertedVnodeQueue<span>.</span>length<span>;</span> <span>++</span>i<span>)</span> <span>{</span>\n    insertedVnodeQueue<span>[</span>i<span>]</span><span>.</span>data<span>!</span><span>.</span>hook<span>!</span><span>.</span>insert<span>!</span><span>(</span>insertedVnodeQueue<span>[</span>i<span>]</span><span>)</span><span>;</span>\n  <span>}</span>\n  <span>for</span> <span>(</span>i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> cbs<span>.</span>post<span>.</span>length<span>;</span> <span>++</span>i<span>)</span> cbs<span>.</span>post<span>[</span>i<span>]</span><span>(</span><span>)</span><span>;</span>\n  <span>return</span> vnode<span>;</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><h3 id=\"patchvnode-函数的源码\"> patchVnode 函数的源码</h3>\n<p>上述 <code>patch</code> 函数中调用了一个 <code>patchVnode</code> 来对比新旧 vnode，该方法也是位于 <code>src/init.ts</code> 中（官方仓库的最新源码可能会实时变动）。</p>\n<div><pre><code><span>function</span> <span>patchVnode</span><span>(</span>oldVnode<span>:</span> VNode<span>,</span> vnode<span>:</span> VNode<span>,</span> insertedVnodeQueue<span>:</span> VNodeQueue<span>)</span> <span>{</span>\n  <span>// 执行 prepatch hook</span>\n  <span>const</span> hook <span>=</span> vnode<span>.</span>data<span>?.</span>hook<span>;</span>\n  hook<span>?.</span>prepatch<span>?.</span><span>(</span>oldVnode<span>,</span> vnode<span>)</span><span>;</span>\n\n  <span>// 设置 vnode.elm：新的 vnode 也需要知道自己的 elm</span>\n  <span>const</span> elm <span>=</span> <span>(</span>vnode<span>.</span>elm <span>=</span> oldVnode<span>.</span>elm<span>)</span><span>!</span><span>;</span>\n\n  <span>// 旧 vnode 的 children（以下简称旧 children）</span>\n  <span>const</span> oldCh <span>=</span> oldVnode<span>.</span>children <span>as</span> VNode<span>[</span><span>]</span><span>;</span>\n  <span>// 新 vnode 的 children（以下简称新 children）</span>\n  <span>const</span> ch <span>=</span> vnode<span>.</span>children <span>as</span> VNode<span>[</span><span>]</span><span>;</span>\n\n  <span>if</span> <span>(</span>oldVnode <span>===</span> vnode<span>)</span> <span>return</span><span>;</span>\n\n  <span>// hook 相关，先不管</span>\n  <span>if</span> <span>(</span>vnode<span>.</span>data <span>!==</span> <span>undefined</span><span>)</span> <span>{</span>\n    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> cbs<span>.</span>update<span>.</span>length<span>;</span> <span>++</span>i<span>)</span>\n      cbs<span>.</span>update<span>[</span>i<span>]</span><span>(</span>oldVnode<span>,</span> vnode<span>)</span><span>;</span>\n    vnode<span>.</span>data<span>.</span>hook<span>?.</span>update<span>?.</span><span>(</span>oldVnode<span>,</span> vnode<span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>// vnode.text === undefined（即此时 vnode.children 有值）</span>\n  <span>// 一般情况下，vnode 的子元素为 text 或 children，都为 undefined 的情况需要在下面做兼容处理</span>\n  <span>if</span> <span>(</span><span>isUndef</span><span>(</span>vnode<span>.</span>text<span>)</span><span>)</span> <span>{</span>\n    <span>// 新旧都有 children</span>\n    <span>if</span> <span>(</span><span>isDef</span><span>(</span>oldCh<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>ch<span>)</span><span>)</span> <span>{</span>\n      <span>if</span> <span>(</span>oldCh <span>!==</span> ch<span>)</span> <span>updateChildren</span><span>(</span>elm<span>,</span> oldCh<span>,</span> ch<span>,</span> insertedVnodeQueue<span>)</span><span>;</span>\n    <span>// 新 children 有，旧 children 无（旧 text 有）</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>isDef</span><span>(</span>ch<span>)</span><span>)</span> <span>{</span>\n      <span>// 清空旧 text</span>\n      <span>if</span> <span>(</span><span>isDef</span><span>(</span>oldVnode<span>.</span>text<span>)</span><span>)</span> api<span>.</span><span>setTextContent</span><span>(</span>elm<span>,</span> <span>\"\"</span><span>)</span><span>;</span>\n      <span>// 添加 children</span>\n      <span>addVnodes</span><span>(</span>elm<span>,</span> <span>null</span><span>,</span> ch<span>,</span> <span>0</span><span>,</span> ch<span>.</span>length <span>-</span> <span>1</span><span>,</span> insertedVnodeQueue<span>)</span><span>;</span>\n    <span>// 旧 children 有，新 children 无</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>isDef</span><span>(</span>oldCh<span>)</span><span>)</span> <span>{</span>\n      <span>// 移除旧 children</span>\n      <span>removeVnodes</span><span>(</span>elm<span>,</span> oldCh<span>,</span> <span>0</span><span>,</span> oldCh<span>.</span>length <span>-</span> <span>1</span><span>)</span><span>;</span>\n    <span>// 旧 text 有</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>isDef</span><span>(</span>oldVnode<span>.</span>text<span>)</span><span>)</span> <span>{</span>\n      <span>// 清空新 text</span>\n      api<span>.</span><span>setTextContent</span><span>(</span>elm<span>,</span> <span>\"\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n  <span>// else：vnode.text !== undefined（即此时 vnode.children 无值）</span>\n  <span>// 且新旧的 text 不一样</span>\n  <span>}</span> <span>else</span> <span>if</span> <span>(</span>oldVnode<span>.</span>text <span>!==</span> vnode<span>.</span>text<span>)</span> <span>{</span>\n    <span>// 移除旧 children</span>\n    <span>if</span> <span>(</span><span>isDef</span><span>(</span>oldCh<span>)</span><span>)</span> <span>{</span>\n      <span>removeVnodes</span><span>(</span>elm<span>,</span> oldCh<span>,</span> <span>0</span><span>,</span> oldCh<span>.</span>length <span>-</span> <span>1</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>// 设置新 text</span>\n    api<span>.</span><span>setTextContent</span><span>(</span>elm<span>,</span> vnode<span>.</span>text<span>!</span><span>)</span><span>;</span>\n  <span>}</span>\n  hook<span>?.</span>postpatch<span>?.</span><span>(</span>oldVnode<span>,</span> vnode<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br></div></div><h3 id=\"updatechildren-函数的源码\"> updateChildren 函数的源码</h3>\n<p>上述 <code>patchVnode</code> 函数中，当新旧 vnode 都有 <code>children</code> 时，需要将两者的 <code>children</code> 进行对比，调用了 <code>updateChildren</code>，该方法也是位于 <code>src/init.ts</code> 中（官方仓库的最新源码可能会实时变动）。</p>\n<p>snabbdom 中对比旧子节点数组（以下简称 oldCh）和新子节点数组（以下简称 newCh）的方式是，先将 oldCh 的第一个元素与 newCh 的第一个元素进行对比，如果不一样，就将两者最后一个元素进行对比，如果依然不一样，就将两者的首元素和末元素进行对比。如果上述四种情况的比对都不成功，就拿当前 newCh 中的这个节点去逐一比对 oldCh 中的每个节点。</p>\n<p>值得注意的是，在 Vue 和 React 中不是使用的这种对比方法，这里只是一种实现思路。</p>\n<div><pre><code><span>function</span> <span>updateChildren</span><span>(</span>\n  parentElm<span>:</span> Node<span>,</span>\n  oldCh<span>:</span> VNode<span>[</span><span>]</span><span>,</span>\n  newCh<span>:</span> VNode<span>[</span><span>]</span><span>,</span>\n  insertedVnodeQueue<span>:</span> VNodeQueue\n<span>)</span> <span>{</span>\n  <span>// oldCh 和 newCh 是两个数组，这里的 start 和 end 表示数组的起始和结束</span>\n  <span>let</span> oldStartIdx <span>=</span> <span>0</span><span>;</span>\n  <span>let</span> newStartIdx <span>=</span> <span>0</span><span>;</span>\n  <span>let</span> oldEndIdx <span>=</span> oldCh<span>.</span>length <span>-</span> <span>1</span><span>;</span>\n  <span>let</span> oldStartVnode <span>=</span> oldCh<span>[</span><span>0</span><span>]</span><span>;</span>\n  <span>let</span> oldEndVnode <span>=</span> oldCh<span>[</span>oldEndIdx<span>]</span><span>;</span>\n  <span>let</span> newEndIdx <span>=</span> newCh<span>.</span>length <span>-</span> <span>1</span><span>;</span>\n  <span>let</span> newStartVnode <span>=</span> newCh<span>[</span><span>0</span><span>]</span><span>;</span>\n  <span>let</span> newEndVnode <span>=</span> newCh<span>[</span>newEndIdx<span>]</span><span>;</span>\n  <span>let</span> oldKeyToIdx<span>:</span> KeyToIndexMap <span>|</span> <span>undefined</span><span>;</span>\n  <span>let</span> idxInOld<span>:</span> <span>number</span><span>;</span>\n  <span>let</span> elmToMove<span>:</span> VNode<span>;</span>\n  <span>let</span> before<span>:</span> <span>any</span><span>;</span>\n\n  <span>while</span> <span>(</span>oldStartIdx <span>&lt;=</span> oldEndIdx <span>&amp;&amp;</span> newStartIdx <span>&lt;=</span> newEndIdx<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>oldStartVnode <span>==</span> <span>null</span><span>)</span> <span>{</span>\n      oldStartVnode <span>=</span> oldCh<span>[</span><span>++</span>oldStartIdx<span>]</span><span>;</span> <span>// Vnode might have been moved left</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span>oldEndVnode <span>==</span> <span>null</span><span>)</span> <span>{</span>\n      oldEndVnode <span>=</span> oldCh<span>[</span><span>--</span>oldEndIdx<span>]</span><span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span>newStartVnode <span>==</span> <span>null</span><span>)</span> <span>{</span>\n      newStartVnode <span>=</span> newCh<span>[</span><span>++</span>newStartIdx<span>]</span><span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span>newEndVnode <span>==</span> <span>null</span><span>)</span> <span>{</span>\n      newEndVnode <span>=</span> newCh<span>[</span><span>--</span>newEndIdx<span>]</span><span>;</span>\n\n    <span>// 起始 oldCh 和起始 newCh 对比</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>sameVnode</span><span>(</span>oldStartVnode<span>,</span> newStartVnode<span>)</span><span>)</span> <span>{</span>\n      <span>patchVnode</span><span>(</span>oldStartVnode<span>,</span> newStartVnode<span>,</span> insertedVnodeQueue<span>)</span><span>;</span>\n      <span>// 每次对比完后，指针进行加减，直到 start 和 end 的 idx 相等</span>\n      oldStartVnode <span>=</span> oldCh<span>[</span><span>++</span>oldStartIdx<span>]</span><span>;</span>\n      newStartVnode <span>=</span> newCh<span>[</span><span>++</span>newStartIdx<span>]</span><span>;</span>\n\n    <span>// 结束 oldCh 和结束 newCh 对比</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>sameVnode</span><span>(</span>oldEndVnode<span>,</span> newEndVnode<span>)</span><span>)</span> <span>{</span>\n      <span>patchVnode</span><span>(</span>oldEndVnode<span>,</span> newEndVnode<span>,</span> insertedVnodeQueue<span>)</span><span>;</span>\n      oldEndVnode <span>=</span> oldCh<span>[</span><span>--</span>oldEndIdx<span>]</span><span>;</span>\n      newEndVnode <span>=</span> newCh<span>[</span><span>--</span>newEndIdx<span>]</span><span>;</span>\n\n    <span>// 开始 oldCh 和结束 newCh 对比</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>sameVnode</span><span>(</span>oldStartVnode<span>,</span> newEndVnode<span>)</span><span>)</span> <span>{</span>\n      <span>// Vnode moved right</span>\n      <span>patchVnode</span><span>(</span>oldStartVnode<span>,</span> newEndVnode<span>,</span> insertedVnodeQueue<span>)</span><span>;</span>\n      api<span>.</span><span>insertBefore</span><span>(</span>\n        parentElm<span>,</span>\n        oldStartVnode<span>.</span>elm<span>!</span><span>,</span>\n        api<span>.</span><span>nextSibling</span><span>(</span>oldEndVnode<span>.</span>elm<span>!</span><span>)</span>\n      <span>)</span><span>;</span>\n      oldStartVnode <span>=</span> oldCh<span>[</span><span>++</span>oldStartIdx<span>]</span><span>;</span>\n      newEndVnode <span>=</span> newCh<span>[</span><span>--</span>newEndIdx<span>]</span><span>;</span>\n\n    <span>// 结束 oldCh 和开始 newCh 对比</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>sameVnode</span><span>(</span>oldEndVnode<span>,</span> newStartVnode<span>)</span><span>)</span> <span>{</span>\n      <span>// Vnode moved left</span>\n      <span>patchVnode</span><span>(</span>oldEndVnode<span>,</span> newStartVnode<span>,</span> insertedVnodeQueue<span>)</span><span>;</span>\n      api<span>.</span><span>insertBefore</span><span>(</span>parentElm<span>,</span> oldEndVnode<span>.</span>elm<span>!</span><span>,</span> oldStartVnode<span>.</span>elm<span>!</span><span>)</span><span>;</span>\n      oldEndVnode <span>=</span> oldCh<span>[</span><span>--</span>oldEndIdx<span>]</span><span>;</span>\n      newStartVnode <span>=</span> newCh<span>[</span><span>++</span>newStartIdx<span>]</span><span>;</span>\n\n    <span>// 以上四个都未命中</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      <span>if</span> <span>(</span>oldKeyToIdx <span>===</span> <span>undefined</span><span>)</span> <span>{</span>\n        oldKeyToIdx <span>=</span> <span>createKeyToOldIdx</span><span>(</span>oldCh<span>,</span> oldStartIdx<span>,</span> oldEndIdx<span>)</span><span>;</span>\n      <span>}</span>\n      <span>// 拿当前新节点的 key，逐一对比 oldCh 中的每个元素，看能否对应上某个节点的 key</span>\n      idxInOld <span>=</span> oldKeyToIdx<span>[</span>newStartVnode<span>.</span>key <span>as</span> <span>string</span><span>]</span><span>;</span>\n      <span>// 没对应上</span>\n      <span>if</span> <span>(</span><span>isUndef</span><span>(</span>idxInOld<span>)</span><span>)</span> <span>{</span>\n        <span>// 当前 newCh 中的这个节点是个新节点，则直接创建</span>\n        api<span>.</span><span>insertBefore</span><span>(</span>\n          parentElm<span>,</span>\n          <span>createElm</span><span>(</span>newStartVnode<span>,</span> insertedVnodeQueue<span>)</span><span>,</span>\n          oldStartVnode<span>.</span>elm<span>!</span>\n        <span>)</span><span>;</span>\n      <span>// 对应上了</span>\n      <span>}</span> <span>else</span> <span>{</span>\n        <span>// 对应上 key 的节点</span>\n        elmToMove <span>=</span> oldCh<span>[</span>idxInOld<span>]</span><span>;</span>\n        <span>// 判断 sel 是否相等（sameNode 的条件是 key 和 sel 都相等）</span>\n        <span>if</span> <span>(</span>elmToMove<span>.</span>sel <span>!==</span> newStartVnode<span>.</span>sel<span>)</span> <span>{</span>\n          <span>// 是个新节点，直接直接创建</span>\n          api<span>.</span><span>insertBefore</span><span>(</span>\n            parentElm<span>,</span>\n            <span>createElm</span><span>(</span>newStartVnode<span>,</span> insertedVnodeQueue<span>)</span><span>,</span>\n            oldStartVnode<span>.</span>elm<span>!</span>\n          <span>)</span><span>;</span>\n        <span>// sel 相等，key 相等</span>\n        <span>}</span> <span>else</span> <span>{</span>\n          <span>patchVnode</span><span>(</span>elmToMove<span>,</span> newStartVnode<span>,</span> insertedVnodeQueue<span>)</span><span>;</span>\n          oldCh<span>[</span>idxInOld<span>]</span> <span>=</span> <span>undefined</span> <span>as</span> <span>any</span><span>;</span>\n          api<span>.</span><span>insertBefore</span><span>(</span>parentElm<span>,</span> elmToMove<span>.</span>elm<span>!</span><span>,</span> oldStartVnode<span>.</span>elm<span>!</span><span>)</span><span>;</span>\n        <span>}</span>\n      <span>}</span>\n      newStartVnode <span>=</span> newCh<span>[</span><span>++</span>newStartIdx<span>]</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n  <span>if</span> <span>(</span>oldStartIdx <span>&lt;=</span> oldEndIdx <span>||</span> newStartIdx <span>&lt;=</span> newEndIdx<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>oldStartIdx <span>></span> oldEndIdx<span>)</span> <span>{</span>\n      before <span>=</span> newCh<span>[</span>newEndIdx <span>+</span> <span>1</span><span>]</span> <span>==</span> <span>null</span> <span>?</span> <span>null</span> <span>:</span> newCh<span>[</span>newEndIdx <span>+</span> <span>1</span><span>]</span><span>.</span>elm<span>;</span>\n      <span>addVnodes</span><span>(</span>\n        parentElm<span>,</span>\n        before<span>,</span>\n        newCh<span>,</span>\n        newStartIdx<span>,</span>\n        newEndIdx<span>,</span>\n        insertedVnodeQueue\n      <span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      <span>removeVnodes</span><span>(</span>parentElm<span>,</span> oldCh<span>,</span> oldStartIdx<span>,</span> oldEndIdx<span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br></div></div><p>（完）</p>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2021-11-19T03:27:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "前端路由原理",
      "url": "https://www.fedbook.cn/frontend-engineering/vuejs/vue-router/",
      "id": "https://www.fedbook.cn/frontend-engineering/vuejs/vue-router/",
      "content_html": "<h1 id=\"前端路由原理\"> 前端路由原理</h1>\n<h2 id=\"两种路由模式\"> 两种路由模式</h2>\n<p>vue-router 有两种路由模式，分别是：</p>\n<ul>\n<li>hash</li>\n<li>H5 history</li>\n</ul>\n<p>其中，H5 history 模式需要后端的支持。</p>\n<h2 id=\"hash-模式\"> hash 模式</h2>\n<h3 id=\"网页-url-组成部分\"> 网页 url 组成部分</h3>\n<p>首先需要知道网页 url 组成部分，以及如何通过 JS 去获取各部分。</p>\n<div><pre><code><span>// http://127.0.0.1:7777/vue-router.html?a=100&amp;b=20#/aaa/bbb</span>\nlocation<span>.</span>protocol  <span>// 'http:'</span>\nlocation<span>.</span>hostname  <span>// '127.0.0.1'</span>\nlocation<span>.</span>host      <span>// '127.0.0.1:7777'</span>\nlocation<span>.</span>port      <span>// '7777'</span>\nlocation<span>.</span>pathname  <span>// '/vue-router.html'</span>\nlocation<span>.</span>search    <span>// '?a=100&amp;b=20'</span>\nlocation<span>.</span>hash      <span>// '#/aaa/bbb'</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"hash-模式的特点\"> hash 模式的特点</h3>\n<ul>\n<li>hash 变化会触发网页跳转，即浏览器的前进、后退</li>\n<li>hash 变化不会刷新页面，这是 SPA 必需的特点</li>\n<li>hash 永远不会提交到 server 端（前端自生自灭）</li>\n</ul>\n<h3 id=\"hash-模式的核心方法\"> hash 模式的核心方法</h3>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/WindowEventHandlers/onhashchange\" target=\"_blank\" rel=\"noopener noreferrer\">window.onhashchange</a></li>\n</ul>\n<h3 id=\"hash-模式的实现原理\"> hash 模式的实现原理</h3>\n<p>通过 hash 的变化触发路由的变化，从而触发视图的渲染。</p>\n<p>下面演示的代码核心是三部分：</p>\n<ul>\n<li>监听 hash 变化</li>\n<li>页面初次加载，获取当前 hash</li>\n<li>点击按钮，通过 JS 修改 url 的 hash</li>\n</ul>\n<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>\n<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>\"</span>en<span>\"</span></span><span>></span></span>\n<span><span><span>&lt;</span>head</span><span>></span></span>\n  <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>\"</span>UTF-8<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>\"</span>viewport<span>\"</span></span> <span>content</span><span><span>=</span><span>\"</span>width=device-width, initial-scale=1.0<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>meta</span> <span>http-equiv</span><span><span>=</span><span>\"</span>X-UA-Compatible<span>\"</span></span> <span>content</span><span><span>=</span><span>\"</span>ie=edge<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>title</span><span>></span></span>hash 模式<span><span><span>&lt;/</span>title</span><span>></span></span>\n<span><span><span>&lt;/</span>head</span><span>></span></span>\n<span><span><span>&lt;</span>body</span><span>></span></span>\n  <span><span><span>&lt;</span>p</span><span>></span></span>hash 模式<span><span><span>&lt;/</span>p</span><span>></span></span>\n  <span><span><span>&lt;</span>button</span> <span>id</span><span><span>=</span><span>\"</span>btn-hash<span>\"</span></span><span>></span></span>修改 hash<span><span><span>&lt;/</span>button</span><span>></span></span>\n<span><span><span>&lt;/</span>body</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n  <span>// 监听 hash 变化，有三种情况会触发：</span>\n  <span>// a. JS 修改 url</span>\n  <span>// b. 手动修改 url 的 hash（如果修改 url 的其它部分，可能会触发页面刷新）</span>\n  <span>// c. 浏览器前进、后退</span>\n  window<span>.</span><span>onhashchange</span> <span>=</span> <span>(</span><span>event</span><span>)</span> <span>=></span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'old url'</span><span>,</span> event<span>.</span>oldURL<span>)</span>\n    console<span>.</span><span>log</span><span>(</span><span>'new url'</span><span>,</span> event<span>.</span>newURL<span>)</span>\n\n    console<span>.</span><span>log</span><span>(</span><span>'hash:'</span><span>,</span> location<span>.</span>hash<span>)</span>\n  <span>}</span>\n\n  <span>// 页面初次加载，获取当前 hash</span>\n  document<span>.</span><span>addEventListener</span><span>(</span><span>'DOMContentLoaded'</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'hash:'</span><span>,</span> location<span>.</span>hash<span>)</span>\n  <span>}</span><span>)</span>\n\n  <span>// 点击按钮，通过 JS 修改 url 的 hash</span>\n  document<span>.</span><span>getElementById</span><span>(</span><span>'btn-hash'</span><span>)</span><span>.</span><span>addEventListener</span><span>(</span><span>'click'</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n    location<span>.</span>href <span>=</span> <span>'#/user'</span>\n  <span>}</span><span>)</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n<span><span><span>&lt;/</span>html</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><h2 id=\"h5-history-模式\"> H5 history 模式</h2>\n<h3 id=\"h5-history-模式的特点\"> H5 history 模式的特点</h3>\n<p>H5 history 模式是用 url 规范的路由，但跳转时不刷新页面。</p>\n<p>正常页面浏览：</p>\n<ul>\n<li><code>https://github.com/xxx</code>         刷新页面</li>\n<li><code>https://github.com/xxx/yyy</code>     刷新页面</li>\n<li><code>https://github.com/xxx/yyy/zzz</code> 刷新页面</li>\n</ul>\n<p>改造成 H5 history 模式：</p>\n<ul>\n<li><code>https://github.com/xxx</code>         刷新页面</li>\n<li><code>https://github.com/xxx/yyy</code>     前端跳转，不刷新页面</li>\n<li><code>https://github.com/xxx/yyy/zzz</code> 前端跳转，不刷新页面</li>\n</ul>\n<h3 id=\"h5-history-模式的核心方法\"> H5 history 模式的核心方法</h3>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/History/pushState\" target=\"_blank\" rel=\"noopener noreferrer\">history.pushState</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/WindowEventHandlers/onpopstate\" target=\"_blank\" rel=\"noopener noreferrer\">window.onpopstate</a></li>\n</ul>\n<h3 id=\"h5-history-模式的实现原理\"> H5 history 模式的实现原理</h3>\n<p>下面演示的代码核心是三部分：</p>\n<ul>\n<li>页面初次加载，获取当前 path</li>\n<li>点击按钮，通过 <code>history.pushState</code> 修改 url 的 hash\n<ul>\n<li>第一个参数：<code>state</code>，无论何时，当通过浏览器前进、后退到达第三个参数配置的路由时，对应的该值就会携带过来</li>\n<li>第二个参数：一般传递空字符串</li>\n<li>第三个参数：目标路由的 <code>path</code></li>\n</ul>\n</li>\n<li>监听浏览器前进、后退</li>\n</ul>\n<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>\n<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>\"</span>en<span>\"</span></span><span>></span></span>\n<span><span><span>&lt;</span>head</span><span>></span></span>\n  <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>\"</span>UTF-8<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>\"</span>viewport<span>\"</span></span> <span>content</span><span><span>=</span><span>\"</span>width=device-width, initial-scale=1.0<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>meta</span> <span>http-equiv</span><span><span>=</span><span>\"</span>X-UA-Compatible<span>\"</span></span> <span>content</span><span><span>=</span><span>\"</span>ie=edge<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>title</span><span>></span></span>H5 history 模式<span><span><span>&lt;/</span>title</span><span>></span></span>\n<span><span><span>&lt;/</span>head</span><span>></span></span>\n<span><span><span>&lt;</span>body</span><span>></span></span>\n  <span><span><span>&lt;</span>p</span><span>></span></span>H5 history 模式<span><span><span>&lt;/</span>p</span><span>></span></span>\n  <span><span><span>&lt;</span>button</span> <span>id</span><span><span>=</span><span>\"</span>btn-history<span>\"</span></span><span>></span></span>修改 url<span><span><span>&lt;/</span>button</span><span>></span></span>\n<span><span><span>&lt;/</span>body</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n  <span>// 页面初次加载，获取 path</span>\n  document<span>.</span><span>addEventListener</span><span>(</span><span>'DOMContentLoaded'</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'load'</span><span>,</span> location<span>.</span>pathname<span>)</span>\n  <span>}</span><span>)</span>\n\n  <span>// 打开一个新的路由</span>\n  <span>// 【注意】用 pushState 方式，浏览器不会刷新页面</span>\n  document<span>.</span><span>getElementById</span><span>(</span><span>'btn-history'</span><span>)</span><span>.</span><span>addEventListener</span><span>(</span><span>'click'</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n    <span>const</span> state <span>=</span> <span>{</span> name<span>:</span> <span>'page1'</span> <span>}</span>\n    console<span>.</span><span>log</span><span>(</span><span>'切换路由到'</span><span>,</span> <span>'page1'</span><span>)</span>\n    history<span>.</span><span>pushState</span><span>(</span>state<span>,</span> <span>''</span><span>,</span> <span>'page1'</span><span>)</span> <span>// 重要！！</span>\n  <span>}</span><span>)</span>\n\n  <span>// 监听浏览器前进、后退</span>\n  window<span>.</span><span>onpopstate</span> <span>=</span> <span>(</span><span>event</span><span>)</span> <span>=></span> <span>{</span> <span>// 重要！！</span>\n    console<span>.</span><span>log</span><span>(</span><span>'onpopstate'</span><span>,</span> event<span>.</span>state<span>,</span> location<span>.</span>pathname<span>)</span>\n  <span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n<span><span><span>&lt;/</span>html</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>H5 history 模式需要 server 端配合，可参考<a href=\"https://router.vuejs.org/zh/guide/essentials/history-mode.html#%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE%E4%BE%8B%E5%AD%90\" target=\"_blank\" rel=\"noopener noreferrer\">后端配置例子</a>。无论访问哪个路由，都返回 <code>index.html</code> 页面，再由前端通过 <code>history.pushState</code> 的方式触发路由的切换。</p>\n<p>（完）</p>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2021-11-19T03:27:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Webpack5",
      "url": "https://www.fedbook.cn/frontend-engineering/webpack/",
      "id": "https://www.fedbook.cn/frontend-engineering/webpack/",
      "content_html": "<h1 id=\"webpack5\"> Webpack5</h1>\n<blockquote>\n<p>本系列主要针对 Webpack5 进行知识点梳理，该版本目前（2021 年）是最新稳定版。</p>\n</blockquote>\n<div><p>TODO...</p>\n<p>有些内容还是使用了废弃的特性，这个系列计划在有时间的时候重新整理撰写。<br>\n由于接下来有其它学习安排，目前可以先参考 <a href=\"https://github.com/wenyuan/webpack-template\" target=\"_blank\" rel=\"noopener noreferrer\">webpack-template</a>，这个仓库是按照最新的官方文档搭建的 Webpack5 通用配置模板。</p>\n</div>\n<p><strong>Webpack 是什么？</strong></p>\n<p>简单的说，Webpack 用于编译 JavaScript 模块，它是一个模块打包工具。</p>\n<p>打包工具帮你获得一些准备用于部署的 js 和 css 等，把它们转化为适合浏览器的可用的格式。</p>\n<p>通过压缩、分离、懒加载等，来提升性能，提高开发效率。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/webpack.png\" alt=\"Webpack\">\n  <p style=\"text-align: center; color: #888;\">（Webpack，图来源于官网文档）</p>\n</div>\n<hr>\n<p><strong>Webpack 不是什么？</strong></p>\n<p>Webpack 不是任务执行的工具，它不能自动化的处理一些常见的开发任务，例如代码检测、构建、测试。这些都是一些重复性比较强的事情，一般偏重于上层的问题。</p>\n<p>任务执行工具：grunt、gulp。</p>\n<p><strong>为什么要学习 Webpack？</strong></p>\n<p>早期，在浏览器里运行 js，有二种方式：</p>\n<ol>\n<li>直接引用 js 脚本程序，有多少个 js，就引用多少个 .js 文件；</li>\n<li>直接一个大的 .js 文件，包含所有的 js 代码，但是文件大小体积就不可控。</li>\n</ol>\n<p>后来，出现了使用立即执行函数表达式（IIFE）的方式，这种方式主要是用来解决大型项目的作用域的问题。针对这种做法，有一些工具 grunt、gulp，它们都是任务执行器，更多做的是项目文件的拼接。这类工具优化代码的能力比较弱，很难判断某个 js 方法是否被重复的引用，或是否未被引用。</p>\n<p>Node.js 出来后，就出现了 JavaScript 的模块化开发。主要是引入了 require 机制，允许你在当前文件中加载和使用某个模块。</p>\n<p>Webpack 最出色的功能，是它还可以引入任何其它类型的文件，包括非 js 类型的文件，可以用来引用应用程序中的所有的非 js 的内容，例如图片、css 等。Webpack 把这些都视为模块，这样每个模块都可以通过相互的引用（依赖）来表明它们之间的关系，就可以避免打包未使用的模块（资源）。</p>\n<p>这就是 Webpack 存在的原因，也是学习 Webpack 的原因。</p>\n<hr>\n<p><strong>Webpack5 和 Webpack4 有什么区别?</strong></p>\n<p>Webpack5 主要是内部效率的优化，对比 Webpack4，没有太多使用上的改动。</p>\n<p>升级 Webpack5 以及周边插件后，代码需要做出的调整：</p>\n<ul>\n<li>package.json 的 dev-server 命令\n<ul>\n<li>老版本：<code>&quot;dev&quot;: &quot;webpack-dev-server --config build/webpack.dev.js&quot;,</code></li>\n<li>新版本：<code>&quot;dev&quot;: &quot;webpack serve --config build/webpack.dev.js&quot;</code></li>\n</ul>\n</li>\n<li>拆分配置文件后，引入 webpack-merge 的方法名\n<ul>\n<li>老版本：<code>const { smart } = require('webpack-merge')</code></li>\n<li>新版本：<code>const { merge } = require('webpack-merge')</code></li>\n</ul>\n</li>\n<li><code>webpack.prod.js</code> 中 CleanWebpackPlugin 方法的引入方式\n<ul>\n<li>老版本：<code>const CleanWebpackPlugin = require('clean-webpack-plugin')</code></li>\n<li>新版本：<code>const { CleanWebpackPlugin } = require('clean-webpack-plugin')</code></li>\n</ul>\n</li>\n<li><code>module.rules</code> 中 loader 的调用方式\n<ul>\n<li>老版本：<code>loader: ['xxx-loader']</code></li>\n<li>新版本：<code>use: ['xxx-loader']</code></li>\n</ul>\n</li>\n<li><code>webpack.prod.js</code> 的 <code>output</code> 中 hash 的写法\n<ul>\n<li>老版本：<code>filename: 'bundle.[contentHash:8].js'</code></li>\n<li>新版本：<code>filename: 'bundle.[contenthash:8].js'</code> 其中 <code>h</code> 小写，不能大写</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>关于 Webpack5 的知识点，主要参考：</p>\n<ul>\n<li><a href=\"https://webpack.js.org\" target=\"_blank\" rel=\"noopener noreferrer\">官方文档</a></li>\n</ul>\n<div style=\"text-align: right\">\n  <svg t=\"1622560522153\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"3671\" width=\"64\" height=\"64\"><path d=\"M882.23288889 749.45422222L526.90488889 950.38577778V793.94133333l221.41155556-121.856 133.91644444 77.36888889z m24.34844444-22.07288889V307.08622222l-129.93422222 75.09333333v270.22222223l129.93422222 74.97955555z m-766.17955555 22.07288889l355.328 201.04533333V793.94133333L274.20444445 672.08533333l-133.80266667 77.36888889zM116.05333333 727.38133333V307.08622222l129.93422222 75.09333333v270.22222223L116.05333333 727.38133333z m15.24622222-447.60177778l364.43022223-206.16533333v151.32444445L262.144 353.39377778l-1.82044445 1.024c0 0.11377778-129.024-74.63822222-129.024-74.63822223z m760.03555556 0L526.90488889 73.728v151.32444445l233.472 128.34133333 1.82044444 1.024 129.13777778-74.63822223z\" fill=\"#8ED6FB\" p-id=\"3672\"></path><path d=\"M495.72977778 758.21511111l-218.45333333-120.14933333V400.15644445l218.45333333 126.17955555v231.87911111z m31.17511111 0l218.45333333-120.03555556V400.15644445l-218.45333333 126.17955555v231.87911111zM291.95377778 372.62222222l219.24977777-120.49066667L730.45333333 372.62222222 511.31733333 499.25688889 291.95377778 372.62222222z\" fill=\"#1C78C0\" p-id=\"3673\"></path></svg>\n</div>\n",
      "date_published": "2022-04-13T08:52:02.000Z",
      "date_modified": "2022-04-13T08:52:02.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "高级配置",
      "url": "https://www.fedbook.cn/frontend-engineering/webpack/advanced-config/",
      "id": "https://www.fedbook.cn/frontend-engineering/webpack/advanced-config/",
      "content_html": "<h1 id=\"高级配置\"> 高级配置</h1>\n<p>基本配置主要确保项目能够在 demo 环境运行，而用于线上环境时往往需要进行一些高级配置。</p>\n<p>Webpack 的高级配置主要分为 6 个方面，根据需要进行选择：</p>\n<ul>\n<li>多入口</li>\n<li><strong>抽离压缩 CSS 文件</strong></li>\n<li><strong>抽离公共代码</strong></li>\n<li><strong>懒加载 - 异步加载 JS</strong></li>\n<li>处理 JSX</li>\n<li>处理 Vue</li>\n</ul>\n<h2 id=\"多入口\"> 多入口</h2>\n<p>通过基本配置，我们在打包编译后产生的页面只是一个文件 <code>index.html</code>。如果在一个项目中想产生两个页面 <code>index.html</code> 和 <code>other.html</code>（或多个页面），就需要进行多入口配置。</p>\n<p>首先在 <code>webpack.common.js</code> 中建入口（<code>entry</code>）的时候就需要建立两个（或多个），其次在插件（<code>plugins</code>）中针对每一个入口都要 <code>new</code> 一个 <code>HtmlWebpackPlugin</code> 的实例。配置代码如下：</p>\n<div><div><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br></div><pre><code><span>const</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span>\n<span>const</span> HtmlWebpackPlugin <span>=</span> <span>require</span><span>(</span><span>'html-webpack-plugin'</span><span>)</span>\n<span>const</span> <span>{</span> srcPath<span>,</span> distPath <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'./paths'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>{</span>\n  entry<span>:</span> <span>{</span>\n    index<span>:</span> path<span>.</span><span>join</span><span>(</span>srcPath<span>,</span> <span>'index.js'</span><span>)</span><span>,</span>\n    other<span>:</span> path<span>.</span><span>join</span><span>(</span>srcPath<span>,</span> <span>'other.js'</span><span>)</span>\n  <span>}</span><span>,</span>\n  module<span>:</span> <span>{</span>\n    rules<span>:</span> <span>[</span>\n      <span>// 此处省略处理 js、css、less 的配置</span>\n    <span>]</span>\n  <span>}</span><span>,</span>\n  plugins<span>:</span> <span>[</span>\n    <span>// 多入口 - 生成 index.html</span>\n    <span>new</span> <span>HtmlWebpackPlugin</span><span>(</span><span>{</span>\n      template<span>:</span> path<span>.</span><span>join</span><span>(</span>srcPath<span>,</span> <span>'index.html'</span><span>)</span><span>,</span> <span>// 对应到 index.html 这个模板文件</span>\n      filename<span>:</span> <span>'index.html'</span><span>,</span> <span>// 生成的文件，名字随便取</span>\n      <span>// chunks 表示该页面要引入哪些 JS 文件（即 entry 中配置的 JS 文件），默认全部引用</span>\n      chunks<span>:</span> <span>[</span><span>'index'</span><span>]</span>  <span>// 只引用 index.js</span>\n    <span>}</span><span>)</span><span>,</span>\n    <span>// 多入口 - 生成 other.html</span>\n    <span>new</span> <span>HtmlWebpackPlugin</span><span>(</span><span>{</span>\n      template<span>:</span> path<span>.</span><span>join</span><span>(</span>srcPath<span>,</span> <span>'other.html'</span><span>)</span><span>,</span> <span>// 对应到 other.html 这个模板文件</span>\n      filename<span>:</span> <span>'other.html'</span><span>,</span> <span>// 生成的文件，名字随便取</span>\n      chunks<span>:</span> <span>[</span><span>'other'</span><span>]</span>  <span>// 只引用 other.js</span>\n    <span>}</span><span>)</span>\n  <span>]</span>\n<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>其次修改 prod（生产环境配置）中的 <code>output</code>，将 <code>webpack.prod.js</code> 中 <code>output.filename</code> 的固定值 <code>bundle</code> 修改为变量 <code>[name]</code>。配置代码如下：</p>\n<div><div><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code><span>const</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span>\n<span>const</span> webpack <span>=</span> <span>require</span><span>(</span><span>'webpack'</span><span>)</span>\n<span>const</span> <span>{</span> CleanWebpackPlugin <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'clean-webpack-plugin'</span><span>)</span>\n<span>const</span> webpackCommonConf <span>=</span> <span>require</span><span>(</span><span>'./webpack.common.js'</span><span>)</span>\n<span>const</span> <span>{</span> merge <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'webpack-merge'</span><span>)</span>\n<span>const</span> <span>{</span> srcPath<span>,</span> distPath <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'./paths'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>merge</span><span>(</span>webpackCommonConf<span>,</span> <span>{</span>\n  mode<span>:</span> <span>'production'</span><span>,</span>\n  output<span>:</span> <span>{</span>\n    <span>// filename: 'bundle.[contenthash:8].js',  // 打包代码时，加上 hash 戳</span>\n    filename<span>:</span> <span>'[name].[contenthash:8].js'</span><span>,</span> <span>// name 即多入口时 entry 的 key</span>\n    path<span>:</span> distPath<span>,</span>\n  <span>}</span><span>,</span>\n  module<span>:</span> <span>{</span>\n    rules<span>:</span> <span>[</span>\n      <span>// 此处省略处理图片的配置</span>\n    <span>]</span>\n  <span>}</span><span>,</span>\n  plugins<span>:</span> <span>[</span>\n    <span>new</span> <span>CleanWebpackPlugin</span><span>(</span><span>)</span><span>,</span> <span>// 会默认清空 output.path 文件夹</span>\n    <span>new</span> <span>webpack<span>.</span>DefinePlugin</span><span>(</span><span>{</span>\n      <span>// window.ENV = 'production'</span>\n      <span>ENV</span><span>:</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>'production'</span><span>)</span>\n    <span>}</span><span>)</span>\n  <span>]</span>\n<span>}</span><span>)</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h2 id=\"抽离压缩-css-文件\"> 抽离压缩 CSS 文件</h2>\n<p>在基础配置中，是把所有 CSS 文件全部写到页面的 style 标签里，这种方式在开发模式中问题不大，但在生产环境中显然不科学，因此我们需要把 CSS 文件抽离压缩。</p>\n<p>首先在 <code>webpack.common.js</code> 中删除对 CSS 和 Less 的处理，只保留对 JS 文件的处理：</p>\n<div><div><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br><br></div><pre><code><span>const</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span>\n<span>const</span> HtmlWebpackPlugin <span>=</span> <span>require</span><span>(</span><span>'html-webpack-plugin'</span><span>)</span>\n<span>const</span> <span>{</span> srcPath<span>,</span> distPath <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'./paths'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>{</span>\n  entry<span>:</span> <span>{</span>\n    index<span>:</span> path<span>.</span><span>join</span><span>(</span>srcPath<span>,</span> <span>'index.js'</span><span>)</span>\n  <span>}</span><span>,</span>\n  module<span>:</span> <span>{</span>\n    rules<span>:</span> <span>[</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.js$</span><span>/</span></span><span>,</span>\n        use<span>:</span> <span>[</span><span>'babel-loader'</span><span>]</span><span>,</span>\n        include<span>:</span> srcPath<span>,</span>\n        exclude<span>:</span> <span><span>/</span><span>node_modules</span><span>/</span></span>\n      <span>}</span>\n    <span>]</span>\n  <span>}</span><span>,</span>\n  plugins<span>:</span> <span>[</span>\n    <span>new</span> <span>HtmlWebpackPlugin</span><span>(</span><span>{</span>\n      template<span>:</span> path<span>.</span><span>join</span><span>(</span>srcPath<span>,</span> <span>'index.html'</span><span>)</span><span>,</span>\n      filename<span>:</span> <span>'index.html'</span>\n    <span>}</span><span>)</span>\n  <span>]</span>\n<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>其次将原来 CSS 和 Less 的处理逻辑放到开发环境下，即 <code>webpack.dev.js</code> 中：</p>\n<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code><span>const</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span>\n<span>const</span> webpack <span>=</span> <span>require</span><span>(</span><span>'webpack'</span><span>)</span>\n<span>const</span> webpackCommonConf <span>=</span> <span>require</span><span>(</span><span>'./webpack.common.js'</span><span>)</span>\n<span>const</span> <span>{</span> merge <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'webpack-merge'</span><span>)</span>\n<span>const</span> <span>{</span> srcPath<span>,</span> distPath <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'./paths'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>merge</span><span>(</span>webpackCommonConf<span>,</span> <span>{</span>\n  mode<span>:</span> <span>'development'</span><span>,</span>\n  module<span>:</span> <span>{</span>\n    rules<span>:</span> <span>[</span>\n      <span>// 直接引入图片 url</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.(png|jpg|jpeg|gif)$</span><span>/</span></span><span>,</span>\n        use<span>:</span> <span>'file-loader'</span>\n      <span>}</span><span>,</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.css$</span><span>/</span></span><span>,</span>\n        <span>// loader 的执行顺序是：从后往前</span>\n        use<span>:</span> <span>[</span><span>'style-loader'</span><span>,</span> <span>'css-loader'</span><span>,</span> <span>'postcss-loader'</span><span>]</span> <span>// 加了 postcss</span>\n      <span>}</span><span>,</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.less$</span><span>/</span></span><span>,</span>\n        <span>// 增加 'less-loader' ，注意顺序</span>\n        use<span>:</span> <span>[</span><span>'style-loader'</span><span>,</span> <span>'css-loader'</span><span>,</span> <span>'less-loader'</span><span>]</span>\n      <span>}</span>\n    <span>]</span>\n  <span>}</span><span>,</span>\n  plugins<span>:</span> <span>[</span>\n    <span>new</span> <span>webpack<span>.</span>DefinePlugin</span><span>(</span><span>{</span>\n      <span>// window.ENV = 'development'</span>\n      <span>ENV</span><span>:</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>'development'</span><span>)</span>\n    <span>}</span><span>)</span>\n  <span>]</span><span>,</span>\n  devServer<span>:</span> <span>{</span>\n    <span>// 此处省略 devServer 的配置</span>\n  <span>}</span>\n<span>}</span><span>)</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><p>然后才是在 <code>webpack.prod.js</code> 中进行配置，这里对 CSS 和 Less 的处理逻辑与在开发环境中很不一样。需要安装三个插件 —— 用于抽离的 <code>mini-css-extract-plugin</code>，用于压缩的 <code>terser-webpack-plugin</code> 和 <code>optimize-css-assets-webpack-plugin</code>。配置代码如下：</p>\n<div><div><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br></div><pre><code><span>const</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span>\n<span>const</span> webpack <span>=</span> <span>require</span><span>(</span><span>'webpack'</span><span>)</span>\n<span>const</span> <span>{</span> merge <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'webpack-merge'</span><span>)</span>\n<span>const</span> <span>{</span> CleanWebpackPlugin <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'clean-webpack-plugin'</span><span>)</span>\n<span>const</span> MiniCssExtractPlugin <span>=</span> <span>require</span><span>(</span><span>'mini-css-extract-plugin'</span><span>)</span>\n<span>const</span> TerserJSPlugin <span>=</span> <span>require</span><span>(</span><span>'terser-webpack-plugin'</span><span>)</span>\n<span>const</span> OptimizeCSSAssetsPlugin <span>=</span> <span>require</span><span>(</span><span>'optimize-css-assets-webpack-plugin'</span><span>)</span>\n<span>const</span> webpackCommonConf <span>=</span> <span>require</span><span>(</span><span>'./webpack.common.js'</span><span>)</span>\n<span>const</span> <span>{</span> srcPath<span>,</span> distPath <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'./paths'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>merge</span><span>(</span>webpackCommonConf<span>,</span> <span>{</span>\n  mode<span>:</span> <span>'production'</span><span>,</span>\n  output<span>:</span> <span>{</span>\n    filename<span>:</span> <span>'[name].[contenthash:8].js'</span><span>,</span> <span>// name 即多入口时 entry 的 key</span>\n    path<span>:</span> distPath<span>,</span>\n  <span>}</span><span>,</span>\n  module<span>:</span> <span>{</span>\n    rules<span>:</span> <span>[</span>\n      <span>// 图片 - 考虑 base64 编码的情况</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.(png|jpg|jpeg|gif)$</span><span>/</span></span><span>,</span>\n        use<span>:</span> <span>{</span>\n          loader<span>:</span> <span>'url-loader'</span><span>,</span>\n          options<span>:</span> <span>{</span>\n            <span>// 小于 5kb 的图片用 base64 格式产出</span>\n            <span>// 否则，依然延用 file-loader 的形式，产出 url 格式</span>\n            limit<span>:</span> <span>5</span> <span>*</span> <span>1024</span><span>,</span>\n\n            <span>// 打包到 img 目录下</span>\n            outputPath<span>:</span> <span>'/img/'</span><span>,</span>\n\n            <span>// 设置图片的 cdn 地址（也可以统一在外面的 output 中设置，那将作用于所有静态资源）</span>\n            <span>// publicPath: 'http://cdn.abc.com'</span>\n          <span>}</span>\n        <span>}</span>\n      <span>}</span><span>,</span>\n      <span>// 抽离 css</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.css$</span><span>/</span></span><span>,</span>\n        use<span>:</span> <span>[</span>\n          MiniCssExtractPlugin<span>.</span>loader<span>,</span> <span>// 注意，这里不再用 style-loader</span>\n          <span>'css-loader'</span><span>,</span>\n          <span>'postcss-loader'</span>\n        <span>]</span>\n      <span>}</span><span>,</span>\n      <span>// 抽离 less</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.less$</span><span>/</span></span><span>,</span>\n        use<span>:</span> <span>[</span>\n          MiniCssExtractPlugin<span>.</span>loader<span>,</span> <span>// 注意，这里不再用 style-loader</span>\n          <span>'css-loader'</span><span>,</span>\n          <span>'less-loader'</span><span>,</span>\n          <span>'postcss-loader'</span>\n        <span>]</span>\n      <span>}</span>\n    <span>]</span>\n  <span>}</span><span>,</span>\n  plugins<span>:</span> <span>[</span>\n    <span>new</span> <span>CleanWebpackPlugin</span><span>(</span><span>)</span><span>,</span> <span>// 会默认清空 output.path 文件夹</span>\n    <span>new</span> <span>webpack<span>.</span>DefinePlugin</span><span>(</span><span>{</span>\n      <span>// window.ENV = 'production'</span>\n      <span>ENV</span><span>:</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>'production'</span><span>)</span>\n    <span>}</span><span>)</span><span>,</span>\n\n    <span>// 抽离 css 文件，命名为 main + hash值</span>\n    <span>new</span> <span>MiniCssExtractPlugin</span><span>(</span><span>{</span>\n      filename<span>:</span> <span>'css/main.[contenthash:8].css'</span>\n    <span>}</span><span>)</span>\n  <span>]</span><span>,</span>\n\n  optimization<span>:</span> <span>{</span>\n    <span>// 压缩 css</span>\n    minimizer<span>:</span> <span>[</span><span>new</span> <span>TerserJSPlugin</span><span>(</span><span>{</span><span>}</span><span>)</span><span>,</span> <span>new</span> <span>OptimizeCSSAssetsPlugin</span><span>(</span><span>{</span><span>}</span><span>)</span><span>]</span><span>,</span>\n  <span>}</span>\n<span>}</span><span>)</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br></div></div><h2 id=\"抽离公共代码\"> 抽离公共代码</h2>\n<p>为了提升性能，我们需要在打包时将<strong>第三方模块</strong>和<strong>公用引用的代码</strong>单独拆分出去。</p>\n<p>既然是在打包时进行的优化，就是修改首先在 <code>webpack.prod.js</code> 这份生产环境的配置文件。在 <code>optimization</code> 中添加分割代码块的逻辑，配置代码如下：</p>\n<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br></div><pre><code><span>const</span> webpack <span>=</span> <span>require</span><span>(</span><span>'webpack'</span><span>)</span>\n<span>const</span> <span>{</span> merge <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'webpack-merge'</span><span>)</span>\n<span>const</span> <span>{</span> CleanWebpackPlugin <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'clean-webpack-plugin'</span><span>)</span>\n<span>const</span> MiniCssExtractPlugin <span>=</span> <span>require</span><span>(</span><span>'mini-css-extract-plugin'</span><span>)</span>\n<span>const</span> TerserJSPlugin <span>=</span> <span>require</span><span>(</span><span>'terser-webpack-plugin'</span><span>)</span>\n<span>const</span> OptimizeCSSAssetsPlugin <span>=</span> <span>require</span><span>(</span><span>'optimize-css-assets-webpack-plugin'</span><span>)</span>\n<span>const</span> webpackCommonConf <span>=</span> <span>require</span><span>(</span><span>'./webpack.common.js'</span><span>)</span>\n<span>const</span> <span>{</span> srcPath<span>,</span> distPath <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'./paths'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>merge</span><span>(</span>webpackCommonConf<span>,</span> <span>{</span>\n  mode<span>:</span> <span>'production'</span><span>,</span>\n  output<span>:</span> <span>{</span>\n    filename<span>:</span> <span>'[name].[contenthash:8].js'</span><span>,</span> <span>// name 即多入口时 entry 的 key</span>\n    path<span>:</span> distPath<span>,</span>\n  <span>}</span><span>,</span>\n  module<span>:</span> <span>{</span>\n    rules<span>:</span> <span>[</span>\n      <span>// 图片 - 考虑 base64 编码的情况</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.(png|jpg|jpeg|gif)$</span><span>/</span></span><span>,</span>\n        use<span>:</span> <span>{</span>\n          loader<span>:</span> <span>'url-loader'</span><span>,</span>\n          options<span>:</span> <span>{</span>\n            <span>// 小于 5kb 的图片用 base64 格式产出</span>\n            <span>// 否则，依然延用 file-loader 的形式，产出 url 格式</span>\n            limit<span>:</span> <span>5</span> <span>*</span> <span>1024</span><span>,</span>\n\n            <span>// 打包到 img 目录下</span>\n            outputPath<span>:</span> <span>'/img/'</span><span>,</span>\n\n            <span>// 设置图片的 cdn 地址（也可以统一在外面的 output 中设置，那将作用于所有静态资源）</span>\n            <span>// publicPath: 'http://cdn.abc.com'</span>\n          <span>}</span>\n        <span>}</span>\n      <span>}</span><span>,</span>\n      <span>// 抽离 css</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.css$</span><span>/</span></span><span>,</span>\n        use<span>:</span> <span>[</span>\n          MiniCssExtractPlugin<span>.</span>loader<span>,</span>  <span>// 注意，这里不再用 style-loader</span>\n          <span>'css-loader'</span><span>,</span>\n          <span>'postcss-loader'</span>\n        <span>]</span>\n      <span>}</span><span>,</span>\n      <span>// 抽离 less</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.less$</span><span>/</span></span><span>,</span>\n        use<span>:</span> <span>[</span>\n          MiniCssExtractPlugin<span>.</span>loader<span>,</span>  <span>// 注意，这里不再用 style-loader</span>\n          <span>'css-loader'</span><span>,</span>\n          <span>'less-loader'</span><span>,</span>\n          <span>'postcss-loader'</span>\n        <span>]</span>\n      <span>}</span>\n    <span>]</span>\n  <span>}</span><span>,</span>\n  plugins<span>:</span> <span>[</span>\n    <span>new</span> <span>CleanWebpackPlugin</span><span>(</span><span>)</span><span>,</span> <span>// 会默认清空 output.path 文件夹</span>\n    <span>new</span> <span>webpack<span>.</span>DefinePlugin</span><span>(</span><span>{</span>\n      <span>// window.ENV = 'production'</span>\n      <span>ENV</span><span>:</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>'production'</span><span>)</span>\n    <span>}</span><span>)</span><span>,</span>\n\n    <span>// 抽离 css 文件</span>\n    <span>new</span> <span>MiniCssExtractPlugin</span><span>(</span><span>{</span>\n      filename<span>:</span> <span>'css/main.[contenthash:8].css'</span>\n    <span>}</span><span>)</span>\n  <span>]</span><span>,</span>\n\n  optimization<span>:</span> <span>{</span>\n    <span>// 压缩 css</span>\n    minimizer<span>:</span> <span>[</span><span>new</span> <span>TerserJSPlugin</span><span>(</span><span>{</span><span>}</span><span>)</span><span>,</span> <span>new</span> <span>OptimizeCSSAssetsPlugin</span><span>(</span><span>{</span><span>}</span><span>)</span><span>]</span><span>,</span>\n\n    <span>// 分割代码块</span>\n    splitChunks<span>:</span> <span>{</span>\n      chunks<span>:</span> <span>'all'</span><span>,</span>\n      <span>/**\n       * initial 入口 chunk，对于异步导入的文件不处理\n       * async 异步 chunk，只对异步导入的文件处理\n       * all 全部 chunk，一般选择 all 模式\n       */</span>\n\n      <span>// 缓存分组</span>\n      cacheGroups<span>:</span> <span>{</span>\n        <span>// 第三方模块</span>\n        vendor<span>:</span> <span>{</span>\n          name<span>:</span> <span>'vendor'</span><span>,</span>       <span>// chunk 名称</span>\n          priority<span>:</span> <span>1</span><span>,</span>          <span>// 权限更高，优先抽离（例如第三方模块同时也作为公共模块在多处引用时，按第三方模块的规则进行抽离）</span>\n          test<span>:</span> <span><span>/</span><span>node_modules</span><span>/</span></span><span>,</span> <span>// 检查模块是否位于 node_modules/ 目录下</span>\n          minSize<span>:</span> <span>30000</span><span>,</span>       <span>// 大小限制（Byte），太小的不用抽离</span>\n          minChunks<span>:</span> <span>1</span>          <span>// 最少复用过几次（第三方模块只要引用过一次就抽取出来）</span>\n        <span>}</span><span>,</span>\n\n        <span>// 公共的模块</span>\n        common<span>:</span> <span>{</span>\n          name<span>:</span> <span>'common'</span><span>,</span>       <span>// chunk 名称</span>\n          priority<span>:</span> <span>0</span><span>,</span>          <span>// 优先级</span>\n          minSize<span>:</span> <span>50000</span><span>,</span>       <span>// 公共模块的大小限制（此处设置 50KB）</span>\n          minChunks<span>:</span> <span>2</span>          <span>// 公共模块最少复用过几次</span>\n        <span>}</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span><span>)</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br></div></div><p>对于<strong>多入口的情况</strong>，为了防止多余的第三方模块被打包到没有引用它的页面里，需要在 <code>webpack.common.js</code> 中的 <code>plugins</code> 内选择所需的 chunk，代码如下：</p>\n<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><div>&nbsp;</div><br><br><br><br></div><pre><code><span>const</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span>\n<span>const</span> HtmlWebpackPlugin <span>=</span> <span>require</span><span>(</span><span>'html-webpack-plugin'</span><span>)</span>\n<span>const</span> <span>{</span> srcPath<span>,</span> distPath <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'./paths'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>{</span>\n  entry<span>:</span> <span>{</span>\n    index<span>:</span> path<span>.</span><span>join</span><span>(</span>srcPath<span>,</span> <span>'index.js'</span><span>)</span><span>,</span>\n    other<span>:</span> path<span>.</span><span>join</span><span>(</span>srcPath<span>,</span> <span>'other.js'</span><span>)</span>\n  <span>}</span><span>,</span>\n  module<span>:</span> <span>{</span>\n    rules<span>:</span> <span>[</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.js$</span><span>/</span></span><span>,</span>\n        use<span>:</span> <span>[</span><span>'babel-loader'</span><span>]</span><span>,</span>\n        include<span>:</span> srcPath<span>,</span>\n        exclude<span>:</span> <span><span>/</span><span>node_modules</span><span>/</span></span>\n      <span>}</span>\n    <span>]</span>\n  <span>}</span><span>,</span>\n  plugins<span>:</span> <span>[</span>\n    <span>// 多入口 - 生成 index.html</span>\n    <span>new</span> <span>HtmlWebpackPlugin</span><span>(</span><span>{</span>\n      template<span>:</span> path<span>.</span><span>join</span><span>(</span>srcPath<span>,</span> <span>'index.html'</span><span>)</span><span>,</span>\n      filename<span>:</span> <span>'index.html'</span><span>,</span>\n      <span>// chunks 表示该页面要引用哪些 chunk （即上面的 index 和 other），默认全部引用</span>\n      chunks<span>:</span> <span>[</span><span>'index'</span><span>,</span> <span>'vendor'</span><span>,</span> <span>'common'</span><span>]</span>  <span>// 要考虑代码分割</span>\n    <span>}</span><span>)</span><span>,</span>\n    <span>// 多入口 - 生成 other.html</span>\n    <span>new</span> <span>HtmlWebpackPlugin</span><span>(</span><span>{</span>\n      template<span>:</span> path<span>.</span><span>join</span><span>(</span>srcPath<span>,</span> <span>'other.html'</span><span>)</span><span>,</span>\n      filename<span>:</span> <span>'other.html'</span><span>,</span>\n      chunks<span>:</span> <span>[</span><span>'other'</span><span>,</span> <span>'common'</span><span>]</span>  <span>// 考虑代码分割</span>\n    <span>}</span><span>)</span>\n  <span>]</span>\n<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><p>目前 chunks 一共出现在了三个地方：</p>\n<ul>\n<li>common 里的 <code>entry</code> 定义了要生成哪些 chunk</li>\n<li>common 里的 <code>plugins</code> 中定义了某个页面要引用哪些 chunk</li>\n<li>prod 里的 <code>splitChunks</code> 中定义了代码分割成哪些 chunk</li>\n</ul>\n<h2 id=\"懒加载-异步加载-js\"> 懒加载 - 异步加载 JS</h2>\n<p>懒加载就是引入动态数据，webpack 本身支持这种机制，所以不需要额外配置，只需要借助 <code>import()</code> 语法来引入 JS 文件。这种语法和 Vue 和 React 中的异步组件是一样的。</p>\n<p>如下例子，这段代码写在某个 JS 文件中，将在 1.5s 之后加载出 <code>dynamic-data.js</code> 这个文件：</p>\n<div><pre><code><span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>// 定义 chunk</span>\n  <span>import</span><span>(</span><span>'./dynamic-data.js'</span><span>)</span><span>.</span><span>then</span><span>(</span><span>res</span> <span>=></span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span>res<span>.</span>default<span>.</span>message<span>)</span>\n  <span>}</span><span>)</span>\n<span>}</span><span>,</span> <span>1500</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>这种异步加载也会产出一个 chunk，文件名是随机的字符串。</p>\n<h2 id=\"处理-jsx\"> 处理 JSX</h2>\n<p>借助 babel 即可，<a href=\"https://www.babeljs.cn/docs/babel-preset-react\" target=\"_blank\" rel=\"noopener noreferrer\">参考官网</a>。</p>\n<p>需要先安装 <code>@babel/preset-react</code>：</p>\n<div><pre><code><span>npm</span> <span>install</span> --save-dev @babel/preset-react\n</code></pre>\n<div><span>1</span><br></div></div><p>然后在 <code>.babelrc</code> 中写上 <code>@babel/preset-react</code>：</p>\n<div><pre><code><span>{</span>\n  <span>\"presets\"</span><span>:</span> <span>[</span><span>\"@babel/preset-react\"</span><span>]</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"处理-vue\"> 处理 Vue</h2>\n<p>借助 vue-loader 即可，<a href=\"https://www.npmjs.com/package/vue-loader\" target=\"_blank\" rel=\"noopener noreferrer\">参考官网</a>。</p>\n<p>需要先安装依赖包：</p>\n<div><pre><code><span>npm</span> i vue-loader\n</code></pre>\n<div><span>1</span><br></div></div><p>然后在 <code>webpack.common.js</code> 中添加对应的规则：</p>\n<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br></div><pre><code><span>const</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span>\n<span>const</span> HtmlWebpackPlugin <span>=</span> <span>require</span><span>(</span><span>'html-webpack-plugin'</span><span>)</span>\n<span>const</span> <span>{</span> srcPath<span>,</span> distPath <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'./paths'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>{</span>\n  entry<span>:</span> path<span>.</span><span>join</span><span>(</span>srcPath<span>,</span> <span>'index'</span><span>)</span><span>,</span>\n  module<span>:</span> <span>{</span>\n    rules<span>:</span> <span>[</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.js$</span><span>/</span></span><span>,</span>\n        use<span>:</span> <span>[</span><span>'babel-loader'</span><span>]</span><span>,</span>\n        include<span>:</span> srcPath<span>,</span>\n        exclude<span>:</span> <span><span>/</span><span>node_modules</span><span>/</span></span>\n      <span>}</span><span>,</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.vue</span><span>/</span></span><span>,</span>\n        use<span>:</span> <span>[</span><span>'vue-loader'</span><span>]</span><span>,</span>\n        include<span>:</span> srcPath\n      <span>}</span>\n    <span>]</span>\n  <span>}</span><span>,</span>\n  plugins<span>:</span> <span>[</span>\n    <span>new</span> <span>HtmlWebpackPlugin</span><span>(</span><span>{</span>\n      template<span>:</span> path<span>.</span><span>join</span><span>(</span>srcPath<span>,</span> <span>'index.html'</span><span>)</span><span>,</span>\n      filename<span>:</span> <span>'index.html'</span>\n    <span>}</span><span>)</span>\n  <span>]</span>\n<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>（完）</p>\n",
      "date_published": "2022-04-13T08:52:02.000Z",
      "date_modified": "2022-04-13T08:52:02.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "基本配置",
      "url": "https://www.fedbook.cn/frontend-engineering/webpack/basic-config/",
      "id": "https://www.fedbook.cn/frontend-engineering/webpack/basic-config/",
      "content_html": "<h1 id=\"基本配置\"> 基本配置</h1>\n<p>Webpack 的基本配置主要分为 6 个方面：</p>\n<ul>\n<li>拆分配置和 merge</li>\n<li>启动本地服务</li>\n<li>处理 ES6</li>\n<li>处理样式</li>\n<li>处理图片</li>\n<li>模块化</li>\n</ul>\n<p>完成基本配置后，项目就能够在 demo 环境运行。</p>\n<h2 id=\"拆分配置和-merge\"> 拆分配置和 merge</h2>\n<p>传统方式，会在项目中新建一个 <code>webpack.config.js</code> 文件，将所有配置汇总在一起。</p>\n<p>而如果拆分配置，我们会将它分为三个文件：</p>\n<ul>\n<li>webpack.common.js</li>\n<li>webpack.dev.js</li>\n<li>webpack.prod.js</li>\n</ul>\n<p>与此同时修改 <code>package.json</code> 中的命令语句：</p>\n<div><div><br><br><br><div>&nbsp;</div><div>&nbsp;</div><br><br></div><pre><code><span>\"scripts\"</span><span>:</span> <span>{</span>\n  <span>\"test\"</span><span>:</span> <span>\"echo <span title=\"\\&quot;\">\\\"</span>Error: no test specified<span title=\"\\&quot;\">\\\"</span> &amp;&amp; exit 1\"</span>,\n  <span>\"dev-without-dev-server\"</span><span>:</span> <span>\"webpack --config build/webpack.dev.js\"</span>,\n  <span>\"dev\"</span><span>:</span> <span>\"webpack serve --config build/webpack.dev.js\"</span>,\n  <span>\"build\"</span><span>:</span> <span>\"webpack --config build/webpack.prod.js\"</span>\n<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><code>webpack.common.js</code> 基础配置代码：</p>\n<div><pre><code><span>const</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span>\n<span>const</span> HtmlWebpackPlugin <span>=</span> <span>require</span><span>(</span><span>'html-webpack-plugin'</span><span>)</span>\n<span>const</span> <span>{</span> srcPath<span>,</span> distPath <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'./paths'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>{</span>\n  entry<span>:</span> path<span>.</span><span>join</span><span>(</span>srcPath<span>,</span> <span>'index'</span><span>)</span><span>,</span>\n  plugins<span>:</span> <span>[</span>\n    <span>new</span> <span>HtmlWebpackPlugin</span><span>(</span><span>{</span>\n      template<span>:</span> path<span>.</span><span>join</span><span>(</span>srcPath<span>,</span> <span>'index.html'</span><span>)</span><span>,</span>\n      filename<span>:</span> <span>'index.html'</span>\n    <span>}</span><span>)</span>\n  <span>]</span><span>,</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>在 dev（开发环境配置）和 prod（生产环境配置）中分别都通过 <code>merge</code>（需要安装 <code>webpack-merge</code> 这个依赖） 将 common（公共配置）引进来。</p>\n<p><code>webpack.dev.js</code> 基础配置代码：</p>\n<div><pre><code><span>const</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span>\n<span>const</span> webpack <span>=</span> <span>require</span><span>(</span><span>'webpack'</span><span>)</span>\n<span>const</span> webpackCommonConf <span>=</span> <span>require</span><span>(</span><span>'./webpack.common.js'</span><span>)</span>\n<span>const</span> <span>{</span> merge <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'webpack-merge'</span><span>)</span>\n<span>const</span> <span>{</span> srcPath<span>,</span> distPath <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'./paths'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>merge</span><span>(</span>webpackCommonConf<span>,</span> <span>{</span>\n  mode<span>:</span> <span>'development'</span><span>,</span>\n  devServer<span>:</span> <span>{</span>\n    <span>// 这部分配置项省略，后面会单独详细讲……</span>\n  <span>}</span><span>,</span>\n  plugins<span>:</span> <span>[</span>\n    <span>new</span> <span>webpack<span>.</span>DefinePlugin</span><span>(</span><span>{</span>\n      <span>// window.ENV = 'development'</span>\n      <span>ENV</span><span>:</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>'development'</span><span>)</span>\n    <span>}</span><span>)</span>\n  <span>]</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p><code>webpack.prod.js</code> 基础配置代码：</p>\n<div><pre><code><span>const</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span>\n<span>const</span> webpack <span>=</span> <span>require</span><span>(</span><span>'webpack'</span><span>)</span>\n<span>const</span> <span>{</span> CleanWebpackPlugin <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'clean-webpack-plugin'</span><span>)</span>\n<span>const</span> webpackCommonConf <span>=</span> <span>require</span><span>(</span><span>'./webpack.common.js'</span><span>)</span>\n<span>const</span> <span>{</span> merge <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'webpack-merge'</span><span>)</span>\n<span>const</span> <span>{</span> srcPath<span>,</span> distPath <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'./paths'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>merge</span><span>(</span>webpackCommonConf<span>,</span> <span>{</span>\n  mode<span>:</span> <span>'production'</span><span>,</span>\n  output<span>:</span> <span>{</span>\n    filename<span>:</span> <span>'bundle.[contenthash:8].js'</span><span>,</span>  <span>// 打包代码时，加上 hash 戳</span>\n    path<span>:</span> distPath<span>,</span>\n    <span>// publicPath: 'http://cdn.abc.com'  // 修改所有静态文件 url 的前缀（如 cdn 域名），这里暂时用不到</span>\n  <span>}</span><span>,</span>\n  plugins<span>:</span> <span>[</span>\n    <span>new</span> <span>CleanWebpackPlugin</span><span>(</span><span>)</span><span>,</span> <span>// 会默认清空 output.path 文件夹</span>\n    <span>new</span> <span>webpack<span>.</span>DefinePlugin</span><span>(</span><span>{</span>\n      <span>// window.ENV = 'production'</span>\n      <span>ENV</span><span>:</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>'production'</span><span>)</span>\n    <span>}</span><span>)</span>\n  <span>]</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>可以看到三份配置文件都引入了 <code>paths.js</code>，这是一个通用的 JS 文件，它里面的完整代码是这样的：</p>\n<div><pre><code><span>/**\n * @description 常用文件夹路径\n * @author wenyuan\n */</span>\n\n<span>const</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span>\n\n<span>const</span> srcPath <span>=</span> path<span>.</span><span>join</span><span>(</span>__dirname<span>,</span> <span>'..'</span><span>,</span> <span>'src'</span><span>)</span>\n<span>const</span> distPath <span>=</span> path<span>.</span><span>join</span><span>(</span>__dirname<span>,</span> <span>'..'</span><span>,</span> <span>'dist'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>{</span>\n  srcPath<span>,</span>\n  distPath\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>下面是拆分配置后的目录结构。</p>\n<div><pre><code>├── src/                       <span># 项目源代码</span>\n├── paths.js                   <span># 常用文件夹路径，返回目录变量给其它文件用</span>\n├── webpack.common.js          <span># 公共配置</span>\n├── webpack.dev.js             <span># 开发环境配置</span>\n├── webpack.prod.js            <span># 生产环境配置</span>\n└── .babelrc                   <span># babel 配置（后面会讲到）</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id=\"启动本地服务\"> 启动本地服务</h2>\n<p>这个功能只在 dev 环境下使用，借助了 <code>webpack-dev-server</code> 这个依赖，配置写在 <code>webpack.dev.js</code> 中：</p>\n<div><div><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br></div><pre><code><span>const</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span>\n<span>const</span> webpack <span>=</span> <span>require</span><span>(</span><span>'webpack'</span><span>)</span>\n<span>const</span> webpackCommonConf <span>=</span> <span>require</span><span>(</span><span>'./webpack.common.js'</span><span>)</span>\n<span>const</span> <span>{</span> merge <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'webpack-merge'</span><span>)</span>\n<span>const</span> <span>{</span> srcPath<span>,</span> distPath <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'./paths'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>merge</span><span>(</span>webpackCommonConf<span>,</span> <span>{</span>\n  mode<span>:</span> <span>'development'</span><span>,</span>\n  devServer<span>:</span> <span>{</span>\n    historyApiFallback<span>:</span> <span>true</span><span>,</span> <span>// 前端路由配置为 history 模式时用</span>\n    contentBase<span>:</span> distPath<span>,</span>    <span>// 根目录</span>\n    open<span>:</span> <span>true</span><span>,</span>               <span>// 自动打开浏览器</span>\n    compress<span>:</span> <span>true</span><span>,</span>           <span>// 启动 gzip 压缩</span>\n    hot<span>:</span> <span>true</span><span>,</span>                <span>// 热更新</span>\n    port<span>:</span> <span>8080</span><span>,</span>               <span>// 启动端口</span>\n\n    <span>// 设置代理，解决跨域访问 —— 如果有需要的话</span>\n    proxy<span>:</span> <span>{</span>\n      <span>// 将本地 /api/xxx 代理到 localhost:3000/api/xxx</span>\n      <span>'/api'</span><span>:</span> <span>'http://localhost:3000'</span><span>,</span>\n\n      <span>// 将本地 /api2/xxx 代理到 localhost:3000/xxx</span>\n      <span>'/api2'</span><span>:</span> <span>{</span>\n        target<span>:</span> <span>'http://localhost:3000'</span><span>,</span>\n        pathRewrite<span>:</span> <span>{</span>\n          <span>'/api2'</span><span>:</span> <span>''</span>\n        <span>}</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span><span>)</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><h2 id=\"处理-es6\"> 处理 ES6</h2>\n<p>处理 ES6 是通用的功能，借助了 <code>babel-loader</code> 这个依赖，配置写在 <code>webpack.common.js</code> 中：</p>\n<div><div><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br></div><pre><code><span>const</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span>\n<span>const</span> <span>{</span> srcPath<span>,</span> distPath <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'./paths'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>{</span>\n  entry<span>:</span> path<span>.</span><span>join</span><span>(</span>srcPath<span>,</span> <span>'index'</span><span>)</span><span>,</span>\n  module<span>:</span> <span>{</span>\n    rules<span>:</span> <span>[</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.js$</span><span>/</span></span><span>,</span>\n        use<span>:</span> <span>[</span><span>'babel-loader'</span><span>]</span><span>,</span> \n        include<span>:</span> srcPath<span>,</span>\n        exclude<span>:</span> <span><span>/</span><span>node_modules</span><span>/</span></span>\n      <span>}</span>\n    <span>]</span>\n  <span>}</span>\n<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>由于 <code>babel-loader</code> 使用到了 babel，因此还需要配置 <code>.babelrc</code>。一般简单配置就已经包含了 ES6、7、8 常用语法，特殊情况再配置 plugins。所以常用配置如下：</p>\n<div><pre><code><span>{</span>\n  <span>\"presets\"</span><span>:</span> <span>[</span><span>\"@babel/preset-env\"</span><span>]</span><span>,</span>\n  <span>\"plugins\"</span><span>:</span> <span>[</span><span>]</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"处理样式\"> 处理样式</h2>\n<p>处理样式也是通用的功能，借助了 <code>css-loader</code>、<code>style-loader</code> 和 <code>postcss-loader</code> 这几个依赖，配置写在 <code>webpack.common.js</code> 中。</p>\n<ul>\n<li>postcss-loader：CSS 语法识别，处理浏览器兼容性</li>\n<li>css-loader：将 .css 结尾的文件解析为 CSS（webpack 中一切皆模块，它不认识 .css 文件和 .js 文件的区别）</li>\n<li>style-loader：将解析完的 CSS 插入到页面中（style 标签中）</li>\n</ul>\n<p>处理样式的配置如下：</p>\n<div><div><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br></div><pre><code><span>const</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span>\n<span>const</span> <span>{</span> srcPath<span>,</span> distPath <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'./paths'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>{</span>\n  entry<span>:</span> path<span>.</span><span>join</span><span>(</span>srcPath<span>,</span> <span>'index'</span><span>)</span><span>,</span>\n  module<span>:</span> <span>{</span>\n    rules<span>:</span> <span>[</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.css$</span><span>/</span></span><span>,</span>\n        <span>// loader 的执行顺序是：从后往前</span>\n        use<span>:</span> <span>[</span><span>'style-loader'</span><span>,</span> <span>'css-loader'</span><span>,</span> <span>'postcss-loader'</span><span>]</span>\n      <span>}</span><span>,</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.less$</span><span>/</span></span><span>,</span>\n        <span>// 增加 'less-loader'，注意顺序</span>\n        use<span>:</span> <span>[</span><span>'style-loader'</span><span>,</span> <span>'css-loader'</span><span>,</span> <span>'less-loader'</span><span>]</span>\n      <span>}</span>\n    <span>]</span>\n  <span>}</span>\n<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>其中 postcss-loader 需要配置一份 <code>postcss.config.js</code> 文件，在这个文件里可以选择一些插件，此处我们安装并引入 <code>autoprefixer</code> 这个依赖（为 CSS 语法添加浏览器兼容性的前缀）：</p>\n<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>\n  plugins<span>:</span> <span>[</span><span>require</span><span>(</span><span>'autoprefixer'</span><span>)</span><span>]</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>在处理样式的配置中，除了 CSS，同理还有 Less，Sass 等，都是差不多的思路（解析 Less 语法 =&gt; 解析 CSS 语法 =&gt; 转成 style），详见上面的配置示例。</p>\n<h2 id=\"处理图片\"> 处理图片</h2>\n<p>处理图片在 dev 环境和 prod 环境的思路不同。</p>\n<ul>\n<li>dev 环境：借助 <code>file-loader</code> 依赖，<strong>直接引入图片 url</strong>。在 <code>webpack.dev.js</code> 中的配置如下：</li>\n</ul>\n<div><div><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br></div><pre><code><span>const</span> webpackCommonConf <span>=</span> <span>require</span><span>(</span><span>'./webpack.common.js'</span><span>)</span>\n<span>const</span> <span>{</span> merge <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'webpack-merge'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>merge</span><span>(</span>webpackCommonConf<span>,</span> <span>{</span>\n  mode<span>:</span> <span>'development'</span><span>,</span>\n  module<span>:</span> <span>{</span>\n    rules<span>:</span> <span>[</span>\n      <span>// 直接引入图片 url</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.(png|jpg|jpeg|gif)$</span><span>/</span></span><span>,</span>\n        use<span>:</span> <span>'file-loader'</span>\n      <span>}</span>\n    <span>]</span>\n  <span>}</span>\n<span>}</span><span>)</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><ul>\n<li>prod 环境：从性能优化的角度考虑，大图片借助 <code>file-loader</code> 依赖，直接引入图片 url，并打包到指定目录下；小图片转成 base64 的形式，可以减少一次 http 请求。在 <code>webpack.prod.js</code> 中的配置如下：</li>\n</ul>\n<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br></div><pre><code><span>const</span> webpackCommonConf <span>=</span> <span>require</span><span>(</span><span>'./webpack.common.js'</span><span>)</span>\n<span>const</span> <span>{</span> merge <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'webpack-merge'</span><span>)</span>\n<span>const</span> <span>{</span> srcPath<span>,</span> distPath <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'./paths'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>merge</span><span>(</span>webpackCommonConf<span>,</span> <span>{</span>\n  mode<span>:</span> <span>'production'</span><span>,</span>\n  output<span>:</span> <span>{</span>\n    filename<span>:</span> <span>'bundle.[contenthash:8].js'</span><span>,</span>  <span>// 打包代码时，加上 hash 戳，主要针对 JS 文件</span>\n    path<span>:</span> distPath<span>,</span>\n    <span>// publicPath: 'http://cdn.abc.com'  // 修改所有静态文件 url 的前缀（如 cdn 域名），这里暂时用不到</span>\n  <span>}</span><span>,</span>\n  module<span>:</span> <span>{</span>\n    rules<span>:</span> <span>[</span>\n      <span>// 图片 - 考虑 base64 编码的情况</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.(png|jpg|jpeg|gif)$</span><span>/</span></span><span>,</span>\n        use<span>:</span> <span>{</span>\n          loader<span>:</span> <span>'url-loader'</span><span>,</span>\n          options<span>:</span> <span>{</span>\n            <span>// 小于 5kb 的图片用 base64 格式产出</span>\n            <span>// 否则，依然延用 file-loader 的形式，产出 url 格式</span>\n            limit<span>:</span> <span>5</span> <span>*</span> <span>1024</span><span>,</span>\n\n            <span>// 打包到 img 目录下</span>\n            outputPath<span>:</span> <span>'/img/'</span><span>,</span>\n\n            <span>// 设置图片的 cdn 地址（也可以统一在外面的 output 中设置，那将作用于所有静态资源）</span>\n            <span>// publicPath: 'http://cdn.abc.com'</span>\n          <span>}</span>\n        <span>}</span>\n      <span>}</span>\n    <span>]</span>\n  <span>}</span>\n<span>}</span><span>)</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><h2 id=\"模块化\"> 模块化</h2>\n<p>一个 Web 工程通常会包含一系列的静态资源，并且这些资源一般会存在某种相互依赖的关系。一般静态资源包含：</p>\n<ul>\n<li>HTML/CSS/JavaScript</li>\n<li>图片/音视频</li>\n<li>字体</li>\n<li>模板\n。。。</li>\n</ul>\n<p>对于 webpack 来说，这些静态资源都是模块，我们可以像加载一个 JS 模块一样去加载它们，如：</p>\n<div><pre><code><span>// 引入 CSS</span>\n<span>import</span> <span>'./style/style1.css'</span>\n<span>import</span> <span>'./style/style2.css'</span>\n\n<span>// 引入 JS 方法</span>\n<span>import</span> <span>{</span> sum <span>}</span> <span>from</span> <span>'./math'</span>\n\n<span>// 引入第三方模块</span>\n<span>import</span> _ <span>from</span> <span>'lodash'</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div style=\"text-align: center;\">\n  <img src=\"./assets/webpack.png\" alt=\"webpack\">\n  <p style=\"text-align: center; color: #888;\">（webpack，图来源于官网文档）</p>\n</div>\n<p>上图为 webpack 官网上的图片，一切文件：JavaScript、CSS、SCSS、图片、模板，在 webpack 眼中都是一个个模块，这样的好处是能清晰的描述出各个模块之间的依赖关系，以方便 webpack 对模块进行组合和打包。经过 webpack 的处理，最终会输出浏览器能使用的静态资源。</p>\n<p>这样做的好处是什么呢？</p>\n<p>举个场景：<strong>某页面模块需要用到按钮</strong>，于是我们加载它：</p>\n<div><pre><code><span>// src/page/index.js'</span>\n<span>import</span> Button <span>from</span> <span>'./components/button/button.js'</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>但是加载了 JS 文件之后发现需要各类样式，因此仍需要引入按钮组件的样式文件：</p>\n<div><pre><code><span>// src/page/style.scss  以 SCSS 为例</span>\n<span>@import</span> <span>'./components/button/style.scss'</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>当然，在 webpack 中实际构建时，可以采用更加简洁的写法来处理：</p>\n<div><pre><code><span>// src/page/index.js</span>\n<span>import</span> Button <span>from</span> <span>'./components/button/index.js'</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><div><pre><code><span>// ./components/button/index.js</span>\n<span>import</span> <span>'./style.scss'</span> <span>// 引用组件自身样式</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>从上例子可以看到，在 button 的 JS 中加载了组件自身的样式，但对于需要该组件的页面来说，只需要引入 button 的 JS 模块即可，不需要再这里引入 button 的样式了。这样在进行组件的引入与删除时，直接操作一次即可达成目的。</p>\n<p>在项目具有一定规模的情况下，可以更加清晰明了的看出 webpack 对我们项目工程优化之处：</p>\n<ul>\n<li>工程结构更简洁</li>\n<li>让依赖关系更直观</li>\n<li>代码可维护性更强</li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-04-13T08:52:02.000Z",
      "date_modified": "2022-04-13T08:52:02.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "性能优化 - 构建速度",
      "url": "https://www.fedbook.cn/frontend-engineering/webpack/performance-optimization-in-build/",
      "id": "https://www.fedbook.cn/frontend-engineering/webpack/performance-optimization-in-build/",
      "content_html": "<h1 id=\"性能优化-构建速度\"> 性能优化 - 构建速度</h1>\n<blockquote>\n<p>Webpack 性能优化主要有两个方向：优化打包构建速度 - 提高开发体验和效率，优化产出代码 - 提升产品性能，本文主要介绍如何优化构建速度。</p>\n</blockquote>\n<p>构建速度的优化措施有 8 点：</p>\n<ul>\n<li>优化 babel-loader</li>\n<li>IgnorePlugin</li>\n<li>noParse</li>\n<li>happyPack</li>\n<li>ParallelUglifyPlugin</li>\n<li>自动刷新</li>\n<li>热更新</li>\n<li>DllPlugin</li>\n</ul>\n<p>前 5 个可用于生产环境，后 3 个只用于开发环境。</p>\n<h2 id=\"优化-babel-loader\"> 优化 babel-loader</h2>\n<ul>\n<li>开启缓存：在原配置的基础上增加一个 <code>?cacheDirectory</code> 开启缓存，只要是 ES6 代码没有改动的部分，就不会重新编译。</li>\n<li>明确范围：通过 <code>include</code> 或 <code>exclude</code> 明确打包范围，两者选一个即可。</li>\n</ul>\n<div><pre><code><span>{</span>\n  test<span>:</span> <span><span>/</span><span>\\.js$</span><span>/</span></span><span>,</span>\n  use<span>:</span> <span>[</span><span>'babel-loader?cacheDirectory'</span><span>]</span><span>,</span>    <span>// 开启缓存 </span>\n  include<span>:</span> path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'src'</span><span>)</span>  <span>// 明确范围</span>\n  <span>// 排除范围，include 和 exclude 两者选一个即可</span>\n  <span>// exclude: path.resovle(__dirname, 'node_modules')</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"ignoreplugin-避免引入无用模块\"> IgnorePlugin 避免引入无用模块</h2>\n<p>例如我们在项目中引入了 Moment.js 这个日期处理类库 <code>import moment from 'moment'</code>，该库有多国语言支持，默认会引入所有语言的 JS 代码，导致体积庞大。</p>\n<p>如果我们只想打包进中文语言的代码，就需要启用 IgnorePlugin 插件。</p>\n<p>修改 <code>webpack.prod.js</code> 文件，在 <code>plugins</code> 中追加配置：</p>\n<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>\n  plugins<span>:</span> <span>[</span>\n    <span>// 忽略 moment 下的 /locale 目录</span>\n    <span>new</span> <span>webpack<span>.</span>IgnorePlugin</span><span>(</span><span><span>/</span><span>\\.\\/locale</span><span>/</span></span><span>,</span> <span><span>/</span><span>moment</span><span>/</span></span><span>)</span><span>,</span>\n  <span>]</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>通过上述配置后，在打包时 <code>moment</code> 库的 <code>locale</code> 这个文件夹就被跳过了。那么在使用时，为了能显示语言，就要动态引入：</p>\n<div><div><br><div>&nbsp;</div><br><br><br><br></div><pre><code><span>import</span> moment <span>from</span> <span>'moment'</span>\n<span>import</span> <span>'moment/locale/zh-cn'</span> <span>// 手动引入中文语言包</span>\nmoment<span>.</span><span>locale</span><span>(</span><span>'zh-cn'</span><span>)</span>\n\nconsole<span>.</span><span>log</span><span>(</span><span>moment</span><span>(</span><span>)</span><span>.</span><span>format</span><span>(</span><span>'ll'</span><span>)</span><span>)</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"noparse-避免重复打包\"> noParse 避免重复打包</h2>\n<p>代码中引入的第三方包，形如 <code>xxx.min.js</code>，往往已经采用模块化处理过了，我们不需要重新进行打包。这个时候就在 <code>module</code></p>\n<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>\n  module<span>:</span> <span>{</span>\n    <span>// 忽略对 react.min.js 文件的递归解析处理</span>\n    noParse<span>:</span> <span>[</span><span><span>/</span><span>react\\.min\\.js$</span><span>/</span></span><span>]</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id=\"happypack-多进程打包\"> happyPack 多进程打包</h2>\n<p>JS（Node.js/Webpack）是<strong>单线程</strong>的，因此如果开启<strong>多进程</strong>打包，可以提高构建速度（特别是多核 CPU）。</p>\n<p>由于 happyPack 需要改变 babel-loader 的配置，所以需要先将原先 <code>webpack.common.js</code> 里关于 babel-loader 的配置删掉，并将这块配置移到 <code>webpack.dev.js</code> 中：</p>\n<div><pre><code><span>// babel-loader</span>\n<span>{</span>\n  test<span>:</span> <span><span>/</span><span>\\.js$</span><span>/</span></span><span>,</span>\n  use<span>:</span> <span>[</span><span>'babel-loader?cacheDirectory'</span><span>]</span><span>,</span>\n  include<span>:</span> srcPath<span>,</span>\n  exclude<span>:</span> <span><span>/</span><span>node_modules</span><span>/</span></span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>接下来安装 happyPack：</p>\n<div><pre><code><span>npm</span> <span>install</span> happypack --save-dev\n</code></pre>\n<div><span>1</span><br></div></div><p>然后在 <code>webpack.prod.js</code> 文件中引入并配置：</p>\n<div><pre><code><span>const</span> HappyPack <span>=</span> <span>require</span><span>(</span><span>'happypack'</span><span>)</span>\n<span>const</span> <span>{</span> srcPath<span>,</span> distPath <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'./paths'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>{</span>\n  module<span>:</span> <span>{</span>\n    rules<span>:</span> <span>[</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.js$</span><span>/</span></span><span>,</span>\n        <span>// 用 happypack/loader 替换原来的 babel-loader</span>\n        <span>// 把对 .js 文件的处理转交给 id 为 babel 的 HappyPack 实例</span>\n        <span>// id=babel 对应下面 plugins 中 new HappyPack 中的 id</span>\n        use<span>:</span> <span>[</span><span>'happypack/loader?id=babel'</span><span>]</span><span>,</span>\n        include<span>:</span> srcPath<span>,</span>\n      <span>}</span><span>,</span>\n\n      <span>// 省略其它配置……</span>\n    <span>]</span>\n  <span>}</span><span>,</span>\n  plugins<span>:</span> <span>[</span>\n    <span>// 省略其它配置……</span>\n\n    <span>// happyPack 开启多进程打包</span>\n    <span>new</span> <span>HappyPack</span><span>(</span><span>{</span>\n      <span>// 用唯一的标识符 id 来代表当前的 HappyPack 是用来处理一类特定的文件</span>\n      id<span>:</span> <span>'babel'</span><span>,</span>\n      <span>// 如何处理 .js 文件，用法和 Loader 配置中一样</span>\n      loaders<span>:</span> <span>[</span><span>'babel-loader?cacheDirectory'</span><span>]</span>\n    <span>}</span><span>)</span>\n  <span>]</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><h2 id=\"paralleluglifyplugin-多进程压缩-js\"> ParallelUglifyPlugin 多进程压缩 JS</h2>\n<p>Webpack 内置了 Uglify 工具压缩 JS，但它是单进程的。开启多进程压缩会更快，和 happyPack 同理。</p>\n<p>首先需要安装 ParallelUglifyPlugin：</p>\n<div><pre><code><span>npm</span> <span>install</span> webpack-parallel-uglify-plugin --save-dev\n</code></pre>\n<div><span>1</span><br></div></div><p>然后在 <code>webpack.prod.js</code> 文件中引入并配置：</p>\n<div><pre><code><span>const</span> ParallelUglifyPlugin <span>=</span> <span>require</span><span>(</span><span>'webpack-parallel-uglify-plugin'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>{</span>\n  plugins<span>:</span> <span>[</span>\n    <span>// 省略其它配置……</span>\n\n    <span>// 使用 ParallelUglifyPlugin 并行压缩输出的 JS 代码</span>\n    <span>new</span> <span>ParallelUglifyPlugin</span><span>(</span><span>{</span>\n      <span>// 传递给 UglifyJS 的参数</span>\n      <span>// （还是使用 UglifyJS 压缩，只不过帮助开启了多进程）</span>\n      uglifyJS<span>:</span> <span>{</span>\n        output<span>:</span> <span>{</span>\n          beautify<span>:</span> <span>false</span><span>,</span> <span>// 最紧凑的输出</span>\n          comments<span>:</span> <span>false</span><span>,</span> <span>// 删除所有的注释</span>\n        <span>}</span><span>,</span>\n        compress<span>:</span> <span>{</span>\n          <span>// 删除所有的 `console` 语句，可以兼容 IE 浏览器</span>\n          drop_console<span>:</span> <span>true</span><span>,</span>\n          <span>// 内嵌定义了但是只用到一次的变量</span>\n          collapse_vars<span>:</span> <span>true</span><span>,</span>\n          <span>// 提取出出现多次但是没有定义成变量去引用的静态值</span>\n          reduce_vars<span>:</span> <span>true</span><span>,</span>\n        <span>}</span>\n      <span>}</span>\n    <span>}</span><span>)</span>\n  <span>]</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><div><p>关于开启多进程</p>\n<ul>\n<li>如果项目较大，打包较慢，开启多进程能提高速度</li>\n<li>如果项目较小，打包很快，开启多进程会较低速度（进程开销）</li>\n</ul>\n</div>\n<h2 id=\"自动刷新\"> 自动刷新</h2>\n<p>每次代码修改保存之后，会自动进行重新构建并刷新页面，不用再次输入命令，用于开发环境。但一般我们在开发环境中都会使用 <code>webpack-dev-server</code>，该插件自带自动刷新功能，所以不用特地开启该功能。</p>\n<p>下面代码演示怎么配置自动刷新的，<strong>实际工作中不用</strong>。</p>\n<div><pre><code>module<span>.</span>export <span>=</span> <span>{</span>\n  watch<span>:</span> <span>true</span><span>,</span> <span>// 开启监听，默认为 false</span>\n  \n  <span>// 监听配置</span>\n  watchOptions<span>:</span> <span>{</span>\n    ignored<span>:</span> <span><span>/</span><span>node_modules</span><span>/</span></span><span>,</span> <span>// 忽略哪些</span>\n    <span>// 监听到变化发生后会等 300ms 再去执行动作，防止文件更新太快导致重新编译频率太高</span>\n    aggregateTimeout<span>:</span> <span>300</span><span>,</span>   <span>// 默认为 300ms</span>\n    <span>// 判断文件是否发生变化是通过不停的去询问系统指定文件有没有变化实现的</span>\n    poll<span>:</span> <span>1000</span>               <span>// 默认每隔 1000ms 询问一次</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id=\"热更新\"> 热更新</h2>\n<p>热更新替换（HMR - Hot Module Replacement）。</p>\n<ul>\n<li>自动刷新：\n<ul>\n<li>整个网页全部刷新，速度较慢</li>\n<li>整个网页全部刷新，状态会丢失</li>\n</ul>\n</li>\n<li>热更新：\n<ul>\n<li>新代码生效，网页不刷新，状态不丢失</li>\n</ul>\n</li>\n</ul>\n<p>热更新插件是 Webpack 自带的，无需另外安装，在 <code>webpack.dev.js</code> 中配置如下：</p>\n<div><div><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br></div><pre><code><span>const</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span>\n<span>const</span> webpack <span>=</span> <span>require</span><span>(</span><span>'webpack'</span><span>)</span>\n<span>const</span> <span>{</span> srcPath<span>,</span> distPath <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'./paths'</span><span>)</span>\n<span>const</span> HotModuleReplacementPlugin <span>=</span> <span>require</span><span>(</span><span>'webpack/lib/HotModuleReplacementPlugin'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>{</span>\n  mode<span>:</span> <span>'development'</span><span>,</span>\n  entry<span>:</span> <span>{</span>\n    <span>// index: path.join(srcPath, 'index.js'),</span>\n    index<span>:</span> <span>[</span>\n      <span>'webpack-dev-server/client?http://localhost:8080/'</span><span>,</span>\n      <span>'webpack/hot/dev-server'</span><span>,</span>\n      path<span>.</span><span>join</span><span>(</span>srcPath<span>,</span> <span>'index.js'</span><span>)</span>\n    <span>]</span>\n  <span>}</span><span>,</span>\n  module<span>:</span> <span>{</span>\n   <span>// 省略……</span>\n  <span>}</span><span>,</span>\n  plugins<span>:</span> <span>[</span>\n    <span>// 省略其它……</span>\n\n    <span>new</span> <span>HotModuleReplacementPlugin</span><span>(</span><span>)</span>\n  <span>]</span><span>,</span>\n  devServer<span>:</span> <span>{</span>\n    port<span>:</span> <span>8080</span><span>,</span>\n    progress<span>:</span> <span>true</span><span>,</span>  <span>// 显示打包的进度条</span>\n    contentBase<span>:</span> distPath<span>,</span>  <span>// 根目录</span>\n    open<span>:</span> <span>true</span><span>,</span>  <span>// 自动打开浏览器</span>\n    compress<span>:</span> <span>true</span><span>,</span>  <span>// 启动 gzip 压缩</span>\n\n    hot<span>:</span> <span>true</span><span>,</span>\n\n    <span>// 设置代理</span>\n    proxy<span>:</span> <span>{</span>\n     <span>// 省略……</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><p>本质上要实现 HMR，都要写类似以下 <code>index.js</code> 中的代码（判断是否开启热更新，单独执行某代码块），否则不会热更新，还是走刷新的逻辑。</p>\n<div><pre><code><span>import</span> counter <span>from</span> <span>'./counter'</span><span>;</span>\n<span>import</span> number <span>from</span> <span>'./number'</span><span>;</span>\n<span>counter</span><span>(</span><span>)</span><span>;</span>\n<span>number</span><span>(</span><span>)</span><span>;</span>\n\n<span>// 这里需要判断下是否开启了热更新，如果开启了，就只让number函数再执行一次，否则不会热更新</span>\n<span>if</span><span>(</span>module<span>.</span>hot<span>)</span> <span>{</span>\n  module<span>.</span>hot<span>.</span><span>accept</span><span>(</span><span>'./number'</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n    document<span>.</span>body<span>.</span><span>removeChild</span><span>(</span>document<span>.</span><span>getElementById</span><span>(</span><span>'number'</span><span>)</span><span>)</span><span>;</span>\n    <span>number</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span><span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><code>index.js</code> 中引入两个模块，如果不开启热更新，那么当一个模块里的数据变化了，就会导致页面刷新，使另一个模块内的数据也恢复到初始值，如果我们想一个模块里的 JS 代码的变化，不影响另一个模块代码变更过的数据，每改一个 JS 模块里的代码，只会更新当前模块的数据，不会影响其他 JS 模块的数据。以上需求可借助 HMR 来实现。</p>\n<p>但在很多时候，我们开发过程中并没有去写这样的代码，是因为在相应的 loader 中，已经帮我们实现了热更新的代码。如：</p>\n<ul>\n<li>css-loader 中同样也配置了热更新，不需要自己额外添加代码</li>\n<li>我们使用的 vue 框架里，vue-loader 里也已经配置了热更新，所以不需要额外添加代码</li>\n</ul>\n<h2 id=\"dllplugin-动态链接库插件\"> DllPlugin 动态链接库插件</h2>\n<p>前端框架如 Vue.js 和 React 体积大，构建慢。但它们的版本较稳定，不常升级版本。那么同一个版本只构建一次即可，不用每次都重新构建。</p>\n<p>Webpack 已内置 DllPlugin 支持，无需另外安装。它包含两个插件：</p>\n<ul>\n<li>DllPlugin：打包出 dll 文件</li>\n<li>DllReferencePlugin：使用 dll 文件</li>\n</ul>\n<p>这个过程比较复杂，目前在开发环境中不怎么用，所以暂时先不整理，后续再补。</p>\n<p>（完）</p>\n",
      "date_published": "2022-04-13T08:52:02.000Z",
      "date_modified": "2022-04-13T08:52:02.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "核心概念",
      "url": "https://www.fedbook.cn/frontend-engineering/webpack/core-concept/",
      "id": "https://www.fedbook.cn/frontend-engineering/webpack/core-concept/",
      "content_html": "<h1 id=\"核心概念\"> 核心概念</h1>\n<h2 id=\"webpack-五个核心概念\"> Webpack 五个核心概念</h2>\n<h3 id=\"entry\"> Entry</h3>\n<p>入口（Entry）是打包时，第一个被访问的源码文件。默认是 src/index.js （可以通过配置文件指定）。</p>\n<p>Webpack 通过入口，加载整个项目的依赖。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/webpack-entry.png\" height=\"300\" alt=\"Webpack 入口\">\n  <p style=\"text-align: center; color: #888;\">（Webpack 入口）</p>\n</div>\n<h3 id=\"output\"> Output</h3>\n<p>出口（Output）是打包后，输出的文件名称，默认是 dist/main.js（可以通过配置文件指定）。</p>\n<p>如下图，出口是 dist/main.js：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/webpack-output.png\" height=\"300\" alt=\"Webpack 出口\">\n  <p style=\"text-align: center; color: #888;\">（Webpack 出口）</p>\n</div>\n<h3 id=\"loader\"> Loader</h3>\n<p>加载器（Loader）是专门用来处理那些非 JavaScript 文件的工具（Webpack 默认只能识别 JavaScript），将这些资源翻译成 Webpack 能识别的资源。</p>\n<p>Loader 的命名方式一般为 xxx-loader（css-loader | html-loader | file-loader），它们都是以 -loader 为后缀的 npm 包，<a href=\"https://www.webpackjs.com/loaders/\" target=\"_blank\" rel=\"noopener noreferrer\">常用加载器</a>。</p>\n<p>Loader 加载的基本逻辑：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/webpack-loader-basic.png\" height=\"300\" alt=\"Webpack loader 加载的基本逻辑\">\n  <p style=\"text-align: center; color: #888;\">（Webpack loader 加载的基本逻辑）</p>\n</div>\n<p>打包时，我们也可以将不同类型的文件，单独打包：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/webpack-loader-split.png\" height=\"300\" alt=\"webpack loader 单独打包其它文件的逻辑\">\n  <p style=\"text-align: center; color: #888;\">（Webpack loader 单独打包其它文件的逻辑）</p>\n</div>\n<h3 id=\"plugins\"> Plugins</h3>\n<p>插件（Plugins）用于实现 Loader 之外的其他功能，包括但不限于打包优化和压缩，重新定义环境中的变量等。Plugin 是 Webpack 的支柱，用来实现丰富的功能。</p>\n<p>Plugins 的命名方式一般为 xxx-webpack-plugin（html-webpack-plugin），它们都是以 -webpack-plugin 为后缀的 npm 包，<a href=\"https://www.webpackjs.com/plugins/\" target=\"_blank\" rel=\"noopener noreferrer\">常用插件</a>。</p>\n<h3 id=\"mode\"> Mode</h3>\n<p>模式（Mode）是用来区分环境的关键字，不同环境的打包逻辑不同，因此需要区分。</p>\n<p>Mode 有三种固定的写法（名称固定，不能改）：</p>\n<ul>\n<li>development（开发环境：自动优化打包速度，添加一些调试过程中的辅助）</li>\n<li>production（生产环境：自动优化打包结果）</li>\n<li>none（运行最原始的打包，不做任何额外处理）</li>\n</ul>\n<p>通过 <code>process.env.NODE_ENV</code> 可以获得当前的 Mode。</p>\n<h2 id=\"module-chunk-bundle-的区别\"> module chunk  bundle 的区别</h2>\n<ul>\n<li>module：各个源码文件，Webpack 中一切皆模块</li>\n<li>chunk：多模块合并成的，如 entry import() splitChunk 定义的很多文件的集合称为一个 chunk</li>\n<li>bundle：最终的输出文件，由 chunk 构建分析完后输出</li>\n</ul>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/webpack-module-chunk-bundle.png\" alt=\"module chunk  bundle\">\n  <p style=\"text-align: center; color: #888;\">（module chunk  bundle）</p>\n</div>\n<p>（完）</p>\n",
      "date_published": "2022-04-13T08:52:02.000Z",
      "date_modified": "2022-04-13T08:52:02.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "性能优化 - 产出代码",
      "url": "https://www.fedbook.cn/frontend-engineering/webpack/performance-optimization-in-output/",
      "id": "https://www.fedbook.cn/frontend-engineering/webpack/performance-optimization-in-output/",
      "content_html": "<h1 id=\"性能优化-产出代码\"> 性能优化 - 产出代码</h1>\n<blockquote>\n<p>Webpack 性能优化主要有两个方向：优化打包构建速度 - 提高开发体验和效率，优化产出代码 - 提升产品性能，本文主要介绍如何优化产出代码。</p>\n</blockquote>\n<p>优化产出代码后可以带来的效果：</p>\n<ul>\n<li>体积更小，加载更快</li>\n<li>合理分包，不重复加载</li>\n<li>速度更快，内存使用更少</li>\n</ul>\n<p>产出代码的优化措施有 8 点：</p>\n<ul>\n<li>小图片 base64 编码</li>\n<li>bundle 加 hash</li>\n<li>懒加载</li>\n<li>提取公共代码</li>\n<li>IgnorePlugin</li>\n<li>使用 CDN 加速</li>\n<li>使用 production</li>\n<li>使用 Scope Hosting</li>\n</ul>\n<p>前 5 个其实在前面两章中已经介绍过了。</p>\n<h2 id=\"小图片-base64-编码\"> 小图片 base64 编码</h2>\n<p>在生产环境下（<code>webpack.prod.js</code>），将小于某个大小的图片（例如 5kb）转成 base64 格式产出，减少一个网络请求。如下代码所示：</p>\n<div><pre><code><span>// 图片 - 考虑 base64 编码的情况</span>\n<span>{</span>\n  test<span>:</span> <span><span>/</span><span>\\.(png|jpg|jpeg|gif)$</span><span>/</span></span><span>,</span>\n  use<span>:</span> <span>{</span>\n    loader<span>:</span> <span>'url-loader'</span><span>,</span>\n    options<span>:</span> <span>{</span>\n      <span>// 小于 5kb 的图片用 base64 格式产出</span>\n      <span>// 否则，依然延用 file-loader 的形式，产出 url 格式</span>\n      limit<span>:</span> <span>5</span> <span>*</span> <span>1024</span><span>,</span>\n\n      <span>// 打包到 img 目录下</span>\n      outputPath<span>:</span> <span>'/img/'</span><span>,</span>\n\n      <span>// 设置图片的 cdn 地址（也可以统一在外面的 output 中设置，那将作用于所有静态资源）</span>\n      <span>// publicPath: 'http://cdn.abc.com'</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id=\"bundle-加-hash\"> bundle 加 hash</h2>\n<p>在生产环境下（<code>webpack.prod.js</code>），对于出口文件，根据文件的内容计算出一个 hash 值（下述示例为 8 位 hash），如果文件内容更新后，缓存会失效，重新请求新的文件；如果代码没有变化，hash 值不变，就会使用缓存，从而提高加载效率。如下代码所示：</p>\n<div><div><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br></div><pre><code><span>const</span> <span>{</span> merge <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'webpack-merge'</span><span>)</span>\n<span>const</span> webpackCommonConf <span>=</span> <span>require</span><span>(</span><span>'./webpack.common.js'</span><span>)</span>\n<span>const</span> <span>{</span> srcPath<span>,</span> distPath <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'./paths'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>merge</span><span>(</span>webpackCommonConf<span>,</span> <span>{</span>\n  mode<span>:</span> <span>'production'</span><span>,</span>\n  output<span>:</span> <span>{</span>\n    <span>// filename: 'bundle.[contenthash:8].js',  // 打包代码时，加上 hash 戳</span>\n    filename<span>:</span> <span>'[name].[contenthash:8].js'</span><span>,</span>     <span>// name 即多入口时 entry 的 key</span>\n    path<span>:</span> distPath<span>,</span>\n  <span>}</span>\n<span>}</span><span>)</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id=\"懒加载\"> 懒加载</h2>\n<p>通过 <code>import</code> 语法，先加载重要的文件，然后异步加载大的文件。这个逻辑与 Vue 和 React 中组件的异步加载类似，如下代码所示：</p>\n<div><pre><code><span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>// 定义 chunk</span>\n  <span>import</span><span>(</span><span>'./dynamic-data.js'</span><span>)</span><span>.</span><span>then</span><span>(</span><span>res</span> <span>=></span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span>res<span>.</span>default<span>.</span>message<span>)</span>\n  <span>}</span><span>)</span>\n<span>}</span><span>,</span> <span>1500</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id=\"提取公共代码\"> 提取公共代码</h2>\n<p>在生产环境下（<code>webpack.prod.js</code>），将第三方模块和公用引用的代码单独拆分出去。</p>\n<p>参考 <a href=\"/frontend-engineering/webpack5/advanced-config/#_3-抽离公共代码\">高级配置-抽离公共代码</a> 这一章的内容。</p>\n<h2 id=\"ignoreplugin\"> IgnorePlugin</h2>\n<p>参考 <a href=\"/frontend-engineering/webpack5/performance-optimization-in-build/#_2-ignoreplugin-避免引入无用模块\">IgnorePlugin 避免引入无用模块</a> 这一章的内容。</p>\n<h2 id=\"使用-cdn-加速\"> 使用 CDN 加速</h2>\n<p>在生产环境下（<code>webpack.prod.js</code>），设置 <code>output.publicPath</code> 后，打包出来的 html 里都会引用 CDN 的静态资源文件。</p>\n<p>需要注意，在打包完后，需要将结果文件（<code>dist</code> 目录）都上传到 CDN 服务器，保证这些静态资源都是可访问的。</p>\n<div><div><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br></div><pre><code><span>const</span> <span>{</span> merge <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'webpack-merge'</span><span>)</span>\n<span>const</span> webpackCommonConf <span>=</span> <span>require</span><span>(</span><span>'./webpack.common.js'</span><span>)</span>\n<span>const</span> <span>{</span> srcPath<span>,</span> distPath <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'./paths'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>merge</span><span>(</span>webpackCommonConf<span>,</span> <span>{</span>\n  mode<span>:</span> <span>'production'</span><span>,</span>\n  output<span>:</span> <span>{</span>\n    <span>// filename: 'bundle.[contenthash:8].js', // 打包代码时，加上 hash 戳</span>\n    filename<span>:</span> <span>'[name].[contenthash:8].js'</span><span>,</span>    <span>// name 即多入口时 entry 的 key</span>\n    path<span>:</span> distPath<span>,</span>\n    publicPath<span>:</span> <span>'http://cdn.abc.com'</span>          <span>// 修改所有静态文件 url 的前缀（如 cdn 域名）</span>\n  <span>}</span>\n<span>}</span><span>)</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>同理，图片也可以设置 CDN 地址，如下代码所示：</p>\n<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br></div><pre><code><span>// 图片 - 考虑 base64 编码的情况</span>\n<span>{</span>\n  test<span>:</span> <span><span>/</span><span>\\.(png|jpg|jpeg|gif)$</span><span>/</span></span><span>,</span>\n  use<span>:</span> <span>{</span>\n    loader<span>:</span> <span>'url-loader'</span><span>,</span>\n    options<span>:</span> <span>{</span>\n      <span>// 小于 5kb 的图片用 base64 格式产出</span>\n      <span>// 否则，依然延用 file-loader 的形式，产出 url 格式</span>\n      limit<span>:</span> <span>5</span> <span>*</span> <span>1024</span><span>,</span>\n\n      <span>// 打包到 img 目录下</span>\n      outputPath<span>:</span> <span>'/img/'</span><span>,</span>\n\n      <span>// 设置图片的 cdn 地址（也可以统一在外面的 output 中设置，那将作用于所有静态资源）</span>\n      publicPath<span>:</span> <span>'http://cdn.abc.com'</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id=\"使用-production\"> 使用 production</h2>\n<p>前面说过，一般会将 Webpack 配置文件拆分成三份：</p>\n<ul>\n<li>webpack.common.js</li>\n<li>webpack.dev.js</li>\n<li>webpack.prod.js</li>\n</ul>\n<p>使用 production 就是指的使用 <code>mode: 'production'</code> 的方式（即使用 <code>webpack.prod.js</code> 这份配置文件）去打包生产环境的代码。</p>\n<p>它具有如下好处：</p>\n<ul>\n<li>无需配置，production 默认自动开启代码压缩（webpack4.x 后的功能）</li>\n<li>Vue、React 等会自动删掉调试代码（如开发环境的 warning）</li>\n<li>会自动启动 Tree-Shaking</li>\n</ul>\n<div><p>Tree-Shaking</p>\n<p>在 production 模式下，打包时会自动删除没有被调用的函数，从而减小打包后的代码体积。<br>\n只有 ES6 Module（静态引入，编译时引入）才能实现 Tree-Shaking，CommonJS（动态引入，执行时引入）不能够静态分析，无法实现 Tree-Shaking。</p>\n</div>\n<h2 id=\"使用-scope-hosting\"> 使用 Scope Hosting</h2>\n<p>默认的 Webpack 打包结果中，多个 JS 文件会被打包生成多个函数。我们知道，每个函数都会产生一个作用域，那么打包前的文件越多打包后的函数就会越多，这对整个 JS 代码的执行及内存消耗很不友好。</p>\n<p>我们希望将文件合并在一个函数里执行，就能减少作用域数量，提高代码执行效率，这就需要开启 Scope Hosting。</p>\n<p>开启方式：</p>\n<div><pre><code><span>const</span> ModuleConcatenationPlugin <span>=</span> <span>require</span><span>(</span><span>'webpack/lib/optimize/ModuleConcatenationPlugin'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>{</span>\n  resolve<span>:</span> <span>{</span>\n    <span>// 针对 NPM 中的第三方模块优先采用 jsnext:main 中指向的 ES6 模块化语法的文件</span>\n    mainFields<span>:</span> <span>[</span><span>'jsnext:main'</span><span>,</span> <span>'browser'</span><span>,</span> <span>'main'</span><span>]</span>\n  <span>}</span><span>,</span>\n  plugins<span>:</span> <span>[</span>\n    <span>// 开启 Scope Hosting</span>\n    <span>new</span> <span>ModuleConcatenationPlugin</span><span>(</span><span>)</span>\n  <span>]</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>使用 Scope Hosting 的好处：</p>\n<ul>\n<li>代码体积更小</li>\n<li>创造函数作用域更少</li>\n<li>代码可读性更好</li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-04-13T08:52:02.000Z",
      "date_modified": "2022-04-13T08:52:02.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "最佳实践 - 通用模板",
      "url": "https://www.fedbook.cn/frontend-engineering/webpack/generic-template/",
      "id": "https://www.fedbook.cn/frontend-engineering/webpack/generic-template/",
      "content_html": "<h1 id=\"最佳实践-通用模板\"> 最佳实践 - 通用模板</h1>\n<blockquote>\n<p>通过最少量的代码，实际操作一下，总结一份 Webpack5 的通用配置文件模板。</p>\n</blockquote>\n<h2 id=\"初始化项目\"> 初始化项目</h2>\n<div><p>提示</p>\n<p>Webpack5 最小支持的 Node.js 版本已经为 8。</p>\n</div>\n<div><pre><code><span>mkdir</span> webpack-template\n\n<span>cd</span> webpack-template/\n\n<span>npm</span> init -y\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"安装-webpack\"> 安装 Webpack</h2>\n<div><p>提示</p>\n<p>当前（2021 年）执行安装命令时，默认安装的是 Webpack5。<br>\n如果需要安装 Webpack4，就执行 <code>npm install webpack@4 --save-dev</code></p>\n</div>\n<div><pre><code><span># 包含 Webpack 核心内容</span>\n<span>npm</span> <span>install</span> webpack --save-dev\n\n<span># 包含 Webpack 操作的常见命令</span>\n<span>npm</span> <span>install</span> webpack-cli --save-dev\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"创建入口文件\"> 创建入口文件</h2>\n<p>入口文件默认地址为 <code>webpack-template/src/index.js</code>，<code>src/</code> 下面存放项目源码。</p>\n<h2 id=\"执行打包-必须指定-mode\"> 执行打包（必须指定 mode）</h2>\n<p>下面的命令依次包含了入口文件、出口文件（通过 <code>--output-path</code> 指定）和模式。</p>\n<div><pre><code>webpack ./src/index.js --output-path ./dist --mode<span>=</span>development\n</code></pre>\n<div><span>1</span><br></div></div><p>在通用模板中，会使用配置文件来简化命令行选项。</p>\n<h2 id=\"通用模板\"> 通用模板</h2>\n<p>上面介绍的是从无到有创建一个 Webpack 最小工程的前置步骤。</p>\n<p>在使用 Webpack 的过程，大部分就是跟配置文件打交道的过程。默认的配置文件名称是 <code>webpack.config.js</code>，根据需要可以进行拆分配置。</p>\n<p>常用的配置项包括：</p>\n<ul>\n<li>mode（模式，不可省略）</li>\n<li>entry（入口，不可省略）</li>\n<li>output（出口，不可省略）</li>\n<li>module（模块的配置 - 不同类型文件的配置 - loader 配置）</li>\n<li>plugins（插件）</li>\n<li>devServer（开发服务器的配置）</li>\n</ul>\n<p>默认配置文件 <code>webpack.config.js</code> 的基本构成如下：</p>\n<div><pre><code><span>/**\n* Webpack 的配置文件\n*/</span>\n<span>const</span> <span>{</span> resolve <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>{</span>\n  <span>// 打包模式</span>\n  mode<span>:</span> <span>'production'</span><span>,</span>\n\n  <span>// 入口文件</span>\n  entry<span>:</span> <span>'./src/index.js'</span><span>,</span>\n\n  <span>// 出口配置</span>\n  output<span>:</span> <span>{</span>\n    <span>// 输出目录（输出目录必须是绝对路径）</span>\n    path<span>:</span> <span>resolve</span><span>(</span>__dirname<span>,</span> <span>'dist'</span><span>)</span><span>,</span>\n    <span>// 输出文件名称</span>\n    filename<span>:</span> <span>'main.js'</span>\n  <span>}</span><span>,</span>\n\n  <span>// 模块配置</span>\n  module<span>:</span> <span>{</span>\n    rules<span>:</span> <span>[</span>\n      <span>// 指定多个配置规则</span>\n    <span>]</span>\n  <span>}</span><span>,</span>\n\n  <span>// 开发服务器</span>\n  devServer<span>:</span> <span>{</span>\n  \n  <span>}</span><span>,</span>\n\n  <span>// 插件配置</span>\n  plugins<span>:</span> <span>[</span>\n  \n  <span>]</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><p>针对常见需求，我整理了一个 Webpack5 通用模板，包含了基本需求和优化。该通用模板的完整代码参见 GitHub 仓库 <a href=\"https://github.com/wenyuan/webpack-template\" target=\"_blank\" rel=\"noopener noreferrer\">webpack-template</a>，使用步骤见该仓库的 <code>README.md</code>。</p>\n<p>（完）</p>\n",
      "date_published": "2022-04-13T08:52:02.000Z",
      "date_modified": "2022-04-13T08:52:02.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "浏览器宏观认识",
      "url": "https://www.fedbook.cn/frontend-knowledge/browser/browser-macro-knowledge/",
      "id": "https://www.fedbook.cn/frontend-knowledge/browser/browser-macro-knowledge/",
      "content_html": "<h1 id=\"浏览器宏观认识\"> 浏览器宏观认识</h1>\n<h2 id=\"浏览器的架构\"> 浏览器的架构</h2>\n<h3 id=\"线程和进程\"> 线程和进程</h3>\n<p><strong>线程和进程的区别</strong>：</p>\n<ul>\n<li>多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的。</li>\n<li>一个进程就是一个程序的运行实例。启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。</li>\n</ul>\n<p><strong>进程和线程的关系</strong>：</p>\n<ul>\n<li>线程需要依附于进程，而进程中使用多线程并行处理能提升运算效率。</li>\n<li>进程中的任意一线程执行出错，都会导致整个进程的崩溃。</li>\n<li>线程之间共享进程中的数据。</li>\n<li>当一个进程关闭后，操作系统会回收进程所占用的内存。</li>\n<li>进程之间的内容相互隔离。</li>\n</ul>\n<p><strong>过去的单进程浏览器</strong>：</p>\n<ul>\n<li>不稳定。单进程中的插件、渲染线程崩溃导致整个浏览器崩溃。</li>\n<li>不流畅。脚本（死循环）或插件会使浏览器卡顿。</li>\n<li>不安全。插件和脚本可以获取到操作系统任意资源。</li>\n</ul>\n<p><strong>现在的多进程浏览器</strong>：</p>\n<ul>\n<li>解决不稳定。进程相互隔离，一个页面或者插件崩溃时，影响仅仅时当前插件或者页面，不会影响到其他页面。</li>\n<li>解决不流畅。脚本阻塞当前页面渲染进程，不会影响到其他页面。</li>\n<li>解决不安全。采用多进程架构使用沙箱。沙箱看成时操作系统给进程上来一把锁，沙箱的程序可以运行，但是不能在硬盘上写入任何数据，也不能在敏感位置读取任何数据。</li>\n</ul>\n<h3 id=\"chrome-架构\"> Chrome 架构</h3>\n<p>在《浏览器工作原理与实践》中描述的 Chrome 进程架构如下如所示：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/chrome-process-architecture.png\" alt=\"Chrome 进程架构图\" style=\"width: 560px;\">\n  <p style=\"text-align: center; color: #888;\">（Chrome 进程架构图，图来源于网络）</p>\n</div>\n<p>根据实际观察，目前最新的架构又有了很多新的变化，主要是模块分割更加细化了。但大体的进程划分还是如上图所示，包括了：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。</p>\n<ul>\n<li><strong>浏览器进程</strong>：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li>\n<li><strong>渲染进程</strong>：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li>\n<li><strong>GPU 进程</strong>：GPU 的使用初衷是为了实现 3D CSS 的效果，但随着网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</li>\n<li><strong>网络进程</strong>：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li>\n<li><strong>插件进程</strong>：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li>\n</ul>\n<p>不过目前的这种架构也存在问题：一是资源占用高，二是体系架构复杂。</p>\n<div><p>拓展：未来面向服务的架构</p>\n<p>李兵老师提到目前 Chrome 官方团队使用<strong>面向服务的架构</strong>思想设计了新的 Chrome 架构。这种架构的特点就是将各种模块重构成独立的服务，每个服务都可以在独立的进程中运行，访问服务必须使用定义好的接口，通过 IPC 来通信，使得系统更内聚、松耦合、易维护和拓展。</p>\n</div>\n<h2 id=\"tcp-ip-协议\"> TCP/IP 协议</h2>\n<blockquote>\n<p>仅重点介绍在 Web 世界中的 TCP/IP 是如何工作的，更系统的网络协议知识未来会专门针对性地去学习。</p>\n</blockquote>\n<h3 id=\"ip-把数据包送达目的主机\"> IP：把数据包送达目的主机</h3>\n<p>互联网中的数据是通过数据包来传输的。如果发送的数据很大，那么该数据就会被拆分为很多小数据包来传输。数据包要在互联网上进行传输，就要符合<strong>网际协议</strong>（Internet Protocol，简称 <strong>IP</strong>）标准。</p>\n<p>计算机的地址就称为 IP 地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。</p>\n<p>以一个数据包从主机 A 到主机 B 的传输过程为例，可以把网络简单分为三层结构，如下图所示：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/internet-protocol.png\" alt=\"简化的 IP 网络三层传输模型\" style=\"width: 560px;\">\n  <p style=\"text-align: center; color: #888;\">（简化的 IP 网络三层传输模型，图来源于网络）</p>\n</div>\n<ul>\n<li>上层将含有「极客时间」的数据包交给网络层。</li>\n<li>网络层再将 IP 头附加到数据包上，组成新的 <strong>IP 数据包</strong>，并交给底层。\n<ul>\n<li>IP 通过 IP 地址信息把数据包发送给指定的电脑。</li>\n<li>IP 头是 IP 数据包开头的信息，包含 IP 版本、源 IP 地址、目标 IP 地址、生存时间等信息。</li>\n</ul>\n</li>\n<li>底层通过物理网络将数据包传输给主机 B。</li>\n<li>数据包被传输到主机 B 的网络层，在这里主机 B 拆开数据包的 IP 头信息，并将拆开来的数据部分交给上层。</li>\n<li>最终，含有「极客时间」信息的数据包就到达了主机 B 的上层了。</li>\n</ul>\n<h3 id=\"udp-把数据包送达应用程序\"> UDP：把数据包送达应用程序</h3>\n<p>IP 是非常底层的协议，只负责把数据包传送到对方电脑，如果要让对方电脑知道该数据包具体是发给哪个程序的，就需要基于 IP 之上能和应用打交道的协议。</p>\n<p>最常见的是「<strong>用户数据包协议</strong>（User Datagram Protocol）」，简称 UDP。</p>\n<p>为了支持 UDP 协议，前面的三层结构将被扩充为四层结构，在网络层和上层之间增加了传输层，如下图所示：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/user-datagram-protocol.png\" alt=\"简化的 UDP 网络四层传输模型\" style=\"width: 560px;\">\n  <p style=\"text-align: center; color: #888;\">（简化的 UDP 网络四层传输模型，图来源于网络）</p>\n</div>\n<p>此时这个数据包从主机 A 到主机 B 的传输过程为：</p>\n<ul>\n<li>上层将含有「极客时间」的数据包交给传输层。</li>\n<li>传输层会在数据包前面附加上 UDP 头，组成新的 UDP 数据包，再将新的 UDP 数据包交给网络层。\n<ul>\n<li>UDP 引入了端口号，通过端口号可以把数据包发送给正确的程序。</li>\n<li>端口号会被装进 UDP 头里面，UDP 头再和原始数据包合并组成新的 UDP 数据包。</li>\n<li>UDP 头中除了目的端口，还有源端口号等信息。</li>\n</ul>\n</li>\n<li>网络层再将 IP 头附加到数据包上，组成新的 IP 数据包，并交给底层。</li>\n<li>数据包被传输到主机 B 的网络层，在这里主机 B 拆开 IP 头信息，并将拆开来的数据部分交给传输层。</li>\n<li>在传输层，数据包中的 UDP 头会被拆开，<strong>并根据 UDP 中所提供的端口号，把数据部分交给上层的应用程序</strong>。</li>\n<li>最终，含有「极客时间」信息的数据包就抵达了主机 B 上层应用程序这里。</li>\n</ul>\n<p><strong>UDP 的优点</strong>：</p>\n<ul>\n<li>传输速度非常快，可以应用在一些关注速度、对数据完整性要求不严格的领域，如在线视频、互动游戏等。</li>\n</ul>\n<p><strong>UDP 的缺点</strong>：</p>\n<ul>\n<li>不保证数据完整性，对于错误的数据包，UDP 不提供重发机制，只是丢弃当前的包。</li>\n<li>大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而 UDP 协议并不知道如何组装这些数据包，从而把这些数据包还原成完整的文件。</li>\n</ul>\n<h3 id=\"tcp-把数据完整地送达应用程序\"> TCP：把数据完整地送达应用程序</h3>\n<p>为了解决 UDP 的数据可靠性问题，就有了「<strong>传输控制协议</strong>（Transmission Control Protocol）」。</p>\n<p>它有下面两个特点：</p>\n<ul>\n<li>对于数据包丢失的情况，TCP 提供重传机制。</li>\n<li>TCP 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。</li>\n</ul>\n<p>TCP 下的单个数据包的传输过程，如下图所示：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/transmission-control-protocol.png\" alt=\"简化的 TCP 网络四层传输模型\" style=\"width: 560px;\">\n  <p style=\"text-align: center; color: #888;\">（简化的 TCP 网络四层传输模型，图来源于网络）</p>\n</div>\n<p>TCP 单个数据包的传输流程和 UDP 流程差不多，不同的地方在于，TCP 头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包，从而保证了一块大的数据传输的完整性。</p>\n<p>那么 TCP 是如何保证重传机制和数据包的排序功能的呢？</p>\n<p>一个完整的 TCP 连接的生命周期包括了「<strong>建立连接</strong>」、「<strong>传输数据</strong>」和「<strong>断开连接</strong>」三个阶段，以客户端主动向服务器发起连接为例，如下图所示：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/life-cycle-of-the-tcp-connection.png\" alt=\"一个 TCP 连接的生命周期\" style=\"width: 560px;\">\n  <p style=\"text-align: center; color: #888;\">（一个 TCP 连接的生命周期，图来源于网络）</p>\n</div>\n<ul>\n<li><strong>首先，建立连接阶段</strong>。这个阶段客户端和服务器之间总共要发送三个数据包以确认连接的建立（<strong>三次握手</strong>）。\n<ul>\n<li>客户端：发送 SYN              --- 请求建立新连接</li>\n<li>服务器：发送 SYN 和 ACK     --- 服务器能正常接收客户端发送的数据，同意创建新连接</li>\n<li>客户端：发送 ACK              --- 确认收到服务器端同意连接的信号\n<div style=\"text-align: center;\">\n<img src=\"./assets/3-way-handshake.gif\" alt=\"三次握手的动态过程\" style=\"width: 480px;\">\n<p style=\"text-align: center; color: #888;\">（三次握手的动态过程，图来源于网络）</p>\n</div></li>\n</ul>\n</li>\n<li><strong>其次，传输数据阶段</strong>。在该阶段，服务器需要对每个数据包进行确认操作。\n<ul>\n<li>客户端：发送数据包。</li>\n<li>服务器：接收到数据包，并发送确认数据包给客户端。同时按照 TCP 头中的序号为数据包排序。</li>\n<li>客户端：如果在规定时间内没有接收到客户端反馈的确认消息，则判断为数据包丢失，触发重发机制。</li>\n</ul>\n</li>\n<li><strong>最后，断开连接阶段</strong>。数据传输完毕之后，会通过四个数据包的交互来保证双方都能断开连接（<strong>四次挥手</strong>）。\n<ul>\n<li>客户端：发送 FIN               --- 请求释放连接</li>\n<li>服务器：发送 ACK              --- 接收到客户端发送的释放连接的请求</li>\n<li>服务器：发送 FIN 和 ACK      --- 已经准备好释放连接了（这里的 ACK 并不是上一次发给客户端的 ACK）</li>\n<li>客户端：发送 ACK              --- 接收到服务器准备好释放连接的信号\n<div style=\"text-align: center;\">\n<img src=\"./assets/4-way-handshake.gif\" alt=\"四次挥手的动态过程\" style=\"width: 480px;\">\n<p style=\"text-align: center; color: #888;\">（四次挥手的动态过程，图来源于网络）</p>\n</div></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"http-请求流程\"> HTTP 请求流程</h2>\n<p>HTTP 协议是建立在 TCP 连接基础之上的。通常由浏览器发起请求，用来向服务器获取不同类型的文件，例如 HTML 文件、CSS 文件、JavaScript 文件、图片、视频等。</p>\n<h3 id=\"带着问题去学习\"> 带着问题去学习</h3>\n<p>思考两个问题：</p>\n<ul>\n<li>为什么通常在第一次访问一个站点时，打开速度很慢，当再次访问这个站点时，速度就很快了？</li>\n<li>当登录过一个网站之后，下次再访问该站点，就已经处于登录状态了，这是怎么做到的呢？</li>\n</ul>\n<h3 id=\"浏览器地址栏键入域名后的动作\"> 浏览器地址栏键入域名后的动作</h3>\n<p>在浏览器地址栏里键入网站域名会完成的动作：</p>\n<ul>\n<li><strong>构建请求</strong>。浏览器构建请求行信息，构建好后，准备发起网络请求。（例如：<code>GET /index.html HTTP1.1</code>）</li>\n<li><strong>查找缓存</strong>。在真正发起请求前浏览器会查询缓存中是否有请求资源副本，有则拦截请求，返回资源副本，否则进入网络请求。</li>\n<li><strong>准备 IP 和端口</strong>。HTTP 网络请求需要和服务器建立 TCP 连接，而建立 TCP 连接需要准备 IP 地址和端口号，浏览器需要请求 DNS 返回域名对应的 IP，同时会缓存域名解析结果，供下次查询使用。如果 URL 没有特别指明端口号，那么 HTTP 协议默认是 <code>80</code> 端口。</li>\n<li><strong>等待 TCP 队列</strong>。Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，超过则会进入排队等待状态。</li>\n<li><strong>建立 TCP 连接</strong>。TCP 通过「三次握手」建立连接，传输数据，「四次挥手」断开连接。</li>\n<li><strong>发送 HTTP 请求</strong>。建立 TCP 连接后，浏览器就可以和服务器进行 HTTP 数据传输了，首先会向服务器发送请求行，然后以请求头形式发送一些其他信息，如果是 POST 请求还会发送请求体。</li>\n<li><strong>服务器处理并返回请求</strong>。服务器返回的响应数据包括<strong>响应行</strong>（协议版本、状态码），<strong>响应头</strong>，<strong>响应体</strong>。</li>\n<li><strong>服务器断开 TCP 连接</strong>。通常服务器向客户端返回了请求数据后，就要关闭 TCP 连接。如果请求头或者响应头有 <code>Connection: keep-alive</code>，那么 TCP 保持连接状态。\n<ul>\n<li>保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。</li>\n</ul>\n</li>\n<li><strong>重定向</strong>。如果响应行返回的状态码是 301，代表的重定向，此时浏览器就会从响应头的 Location 字段中获取目标地址，并使用该地址重新导航。</li>\n</ul>\n<p>总结 HTTP 请求流程如下图所示：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/http-request-flow.png\" alt=\"HTTP 请求流程示意图\">\n  <p style=\"text-align: center; color: #888;\">（HTTP 请求流程示意图，图来源于网络）</p>\n</div>\n<h3 id=\"问题解答\"> 问题解答</h3>\n<p>为什么很多站点第二次打开速度会很快？</p>\n<ul>\n<li><strong>DNS 缓存</strong>：DNS 缓存比较简单，它主要就是在浏览器本地把对应的 IP 和域名关联起来。</li>\n<li><strong>页面资源缓存</strong>：网站把很多资源都缓存在了本地，浏览器可以直接使用本地副本来回应请求，而不会产生真实的网络请求，\n<ul>\n<li>服务器返回 HTTP 响应头后，浏览器通过响应头中的 <code>Cache-Control</code> 字段来设置是否缓存该资源，以及缓存过期时长。</li>\n<li>缓存过期后，服务器通过 HTTP 请求头中的 <code>If-None-Match</code> 字段值来判断请求的资源是否有更新。如果没有更新，就返回 304 状态码表示缓存可以继续使用，如果资源有更新就返回最新资源给浏览器。</li>\n</ul>\n</li>\n</ul>\n<p>登录状态是如何保持的？</p>\n<ul>\n<li>服务器验证用户登录信息正确，就会生成一段表示用户身份的字符串，并把该字符串写到响应头的 <code>Set-Cookie</code> 字段里。</li>\n<li>浏览器接收到响应头并解析，如果发现有 <code>Set-Cookie</code> 字段，就会把这个字段信息保存到本地。</li>\n<li>当用户再次访问时，浏览器在发起 HTTP 请求之前，会读取之前保存的 Cookie 数据，并把数据写进请求头里的 <code>Cookie</code> 字段里，然后浏览器再将请求头发送给服务器。</li>\n<li>服务器在收到 HTTP 请求头数据之后，就会查找请求头里面的 <code>Cookie</code> 字段信息，获取到信息后，服务器查询后台，并判断该用户是已登录状态，然后生成含有该用户信息的页面数据，并把生成的数据发送给浏览器。</li>\n<li>浏览器在接收到该含有当前用户的页面数据后，就可以正确展示用户登录的状态信息了。</li>\n</ul>\n<h2 id=\"输入-url-到页面展示\"> 输入 URL 到页面展示</h2>\n<p>这几乎是一道面试必问的题目：「浏览器从输入 URL 到页面展示，中间发生了什么？」</p>\n<h3 id=\"完整流程小结\"> 完整流程小结</h3>\n<p>下面总结一下这个问题该如何回答（以下只是我的一种回答，并不是标准答案，每个人都应该有自己的理解和侧重点）：</p>\n<ul>\n<li>用户输入 URL 并回车</li>\n<li>浏览器进程检查 URL，组装协议，构成完整的 URL</li>\n<li>浏览器进程通过进程间通信（IPC）把 URL 请求发送给网络进程</li>\n<li>网络进程接收到 URL 请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程</li>\n<li>如果没有，网络进程向 Web 服务器发起 HTTP 请求（网络请求），请求流程如下：\n<ul>\n<li>进行 DNS 解析，获取服务器 IP 地址和端口（URL 里若未指定端口，则 HTTP 请求默认是 <code>80</code>，HTTPS 默认是 <code>443</code>）</li>\n<li>利用 IP 地址和服务器建立 TCP 连接</li>\n<li>构建请求头信息</li>\n<li>发送请求头信息</li>\n<li>服务器响应后，网络进程接收响应头和响应信息，并解析响应内容</li>\n</ul>\n</li>\n<li>网络进程解析响应流程；\n<ul>\n<li>检查状态码，如果是 <code>301</code>/<code>302</code>，则需要重定向，从 <code>Location</code> 自动中读取地址，重新把 URL 请求发送给网络进程（重复上面的操作），如果是 <code>200</code>，则继续处理请求。</li>\n<li><code>200</code> 响应处理：检查响应类型 <code>Content-Type</code>，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行后续的渲染，如果是 html 则通知浏览器进程准备渲染进程准备进行渲染。</li>\n</ul>\n</li>\n<li>准备渲染进程\n<ul>\n<li>浏览器进程检查当前 URL 是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程</li>\n</ul>\n</li>\n<li>传输数据、更新状态\n<ul>\n<li>渲染进程准备好后，浏览器进程向渲染进程发起「提交文档」的消息，渲染进程接收到消息和网络进程建立传输数据的「管道」</li>\n<li>文档数据传输完成后，渲染进程向浏览器进程返回「确认提交」的消息</li>\n<li>浏览器进程收到「确认提交」的消息后，会更新浏览器界面状态，包括安全状态、地址栏的 URL、前进后退的历史状态、更新 Web 页面，此时的 Web 页面是空白页</li>\n</ul>\n</li>\n<li>渲染进程对文档进行页面解析和子资源加载，生成最终页面\n<ul>\n<li>构建 DOM 树：通过 HTML 解析器将 HTML 转换成 DOM 树。</li>\n<li>样式计算：渲染引擎将 CSS 文本转换为 styleSheets，计算出 DOM 节点的样式。</li>\n<li>布局：创建布局树（只包含可见元素的树），并计算元素的布局信息。</li>\n<li>分层：对布局树进行分层，并生成分层树。</li>\n<li>图层绘制：为每个图层生成绘制列表，并将其提交到合成线程。</li>\n<li>栅格化：合成线程将图层分成图块，通过栅格化把图块转换为位图。</li>\n<li>合成：所有图块都被光栅化后，渲染引擎中的合成线程发送一个绘制图块的命令「DrawQuad」给浏览器进程。</li>\n<li>显示：浏览器进程根据接收到的「DrawQuad」消息绘制页面，并显示到显示器上。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"完整流程示意图\"> 完整流程示意图</h3>\n<p>下图是一张李兵老师梳理的「从输入 URL 到页面展示完整流程示意图」：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/complete-process-from-entering-url-to-page.png\" alt=\"从输入 URL 到页面展示完整流程示意图\">\n  <p style=\"text-align: center; color: #888;\">（从输入 URL 到页面展示完整流程示意图，图来源于网络）</p>\n</div>\n<p>从图中可以看出，整个过程需要各个进程之间的配合。</p>\n<p>另外 GitHub 上还有个仓库，讲了从浏览器地址框输入 <code>google.com</code> 后会发生什么：<a href=\"https://github.com/skyline75489/what-happens-when-zh_CN\" target=\"_blank\" rel=\"noopener noreferrer\">what-happens-when-zh_CN</a></p>\n<p>（完）</p>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T07:36:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "浏览器内核与 JavaScript 引擎",
      "url": "https://www.fedbook.cn/frontend-knowledge/browser/kernel-and-javascript-engine/",
      "id": "https://www.fedbook.cn/frontend-knowledge/browser/kernel-and-javascript-engine/",
      "content_html": "<h1 id=\"浏览器内核与-javascript-引擎\"> 浏览器内核与 JavaScript 引擎</h1>\n<h2 id=\"浏览器内核\"> 浏览器内核</h2>\n<p>不同的浏览器有不同的内核组成：</p>\n<ul>\n<li><strong>Gecko</strong>：早期被 Netscape 和 Mozilla Firefox 浏览器浏览器使用。</li>\n<li><strong>Trident</strong>：微软开发，被 IE4 - IE11 浏览器使用，但是 Edge 浏览器已经转向 Blink。</li>\n<li><strong>Webkit</strong>：苹果基于 KHTML 开发、开源的，用于 Safari，Google Chrome 之前也在使用。</li>\n<li><strong>Blink</strong>：是 Webkit 的一个分支，Google 开发，目前应用于 Google Chrome、Edge、Opera 等。</li>\n<li>等等…</li>\n</ul>\n<p>我们经常说的浏览器内核指的是浏览器的排版引擎（layout engine），它负责处理 HTML 和 CSS，所以又被称为浏览器引擎（browser engine）、页面<strong>渲染引擎</strong>（rendering engine）或样版引擎。</p>\n<h2 id=\"javascript-引擎\"> JavaScript 引擎</h2>\n<p>JavaScript 引擎帮助我们将 JavaScript 代码翻译成 CPU 指令来执行。</p>\n<p>比较常见的 JavaScript 引擎有：</p>\n<ul>\n<li>SpiderMonkey：第一款 JavaScript 引擎，由 Brendan Eich 开发（也就是 JavaScript 作者）。</li>\n<li>Chakra：微软开发，用于 IE 浏览器。</li>\n<li>JavaScriptCore：WebKit 中的 JavaScript 引擎，Apple 公司开发。</li>\n<li>V8：Google 开发的强大 JavaScript 引擎，也帮助 Chrome 从众多浏览器中脱颖而出。</li>\n<li>等等…</li>\n</ul>\n<h2 id=\"两者的关系\"> 两者的关系</h2>\n<p>最初内核的概念包括渲染引擎与 JavaScript 引擎（简称 JS 引擎），目前习惯直接称渲染引擎为内核，JS 引擎独立。</p>\n<p>最初：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/kernel-and-javascript-engine-before.svg\" alt=\"浏览器内核与 JS 引擎最初的关系\">\n  <p style=\"text-align: center; color: #888;\">（浏览器内核与 JS 引擎最初的关系）</p>\n</div>\n<p>因此以前称：Chrome 浏览器使用 Chromium 内核，Blink 渲染引擎，V8 JS 引擎。</p>\n<p>目前：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/kernel-and-javascript-engine-now.svg\" alt=\"浏览器内核与 JS 引擎目前的关系\">\n  <p style=\"text-align: center; color: #888;\">（浏览器内核与 JS 引擎目前的关系）</p>\n</div>\n<p>因此现在称：Chrome 浏览器使用 Blink 内核，V8 JS 引擎。</p>\n<ul>\n<li><strong>渲染引擎</strong>：Rendering Engine，一般习惯将之称为「浏览器内核」，主要功能是解析 HTML/CSS 进行渲染页面，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。</li>\n<li><strong>JS 引擎</strong>：专门处理 JavaScript 脚本的虚拟机、解释器，用来解释执行 JS 代码。在早期内核也是包含 JS 引擎的，而现在 JS 引擎越来独立了，可以把它单独提出来。</li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T07:36:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "浏览器工作原理",
      "url": "https://www.fedbook.cn/frontend-knowledge/browser/",
      "id": "https://www.fedbook.cn/frontend-knowledge/browser/",
      "content_html": "<h1 id=\"浏览器工作原理\"> 浏览器工作原理</h1>\n<p>作为一名前端开发者，虽然经常基于浏览器做应用层开发，但在工作中很少会去深究浏览器的内部运行原理，比如 JavaScript 是怎样运行，页面是怎样渲染出来的，浏览器中的网络和安全问题等等。</p>\n<p>市面上浅显易懂的学习资料不多，李兵老师出的《浏览器基本原理与实践》这门课确实不错，它是我的主要学习资料。后来查询更多资料时发现，前端社区很多浏览器方面的课程和文章中都有这门课的影子，这也是一种站在巨人肩膀上的学习了。</p>\n<p>正如李兵老师所说：了解浏览器是如何工作的，能让你站在更高维度去理解前端。</p>\n<hr>\n<p>这个系列将基于 Google Chrome 浏览器进行学习和实验，所以很多特性也仅是面向该浏览器的（或同一内核的现代浏览器）。大部分较为深入和底层的知识点来源于《浏览器基本原理与实践》这一课程，同时也参考了市面上其它课程的浏览器相关章节。在整理的时候没有完全按照原课程的内容排版，而是根据自己的思路来梳理，方便理解和记忆。</p>\n<hr>\n<p>关于浏览器的知识点，主要参考：</p>\n<ul>\n<li>《浏览器工作原理与实践》（极客时间）</li>\n</ul>\n<div style=\"text-align: right\">\n  <svg t=\"1638087443976\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"8869\" width=\"64\" height=\"64\"><path d=\"M123.648 178.346667C361.642667-98.602667 802.986667-43.946667 967.936 279.68h-396.501333c-71.424 0-117.546667-1.621333-167.509334 24.661333-58.709333 30.933333-102.997333 88.234667-118.485333 155.52L123.648 178.389333z\" fill=\"#EA4335\" p-id=\"8870\"></path><path d=\"M341.674667 512c0 93.866667 76.330667 170.24 170.154666 170.24 93.866667 0 170.154667-76.373333 170.154667-170.24s-76.330667-170.24-170.154667-170.24c-93.866667 0-170.154667 76.373333-170.154666 170.24z\" fill=\"#4285F4\" p-id=\"8871\"></path><path d=\"M577.877333 734.848c-95.530667 28.373333-207.274667-3.114667-268.501333-108.8-46.762667-80.64-170.24-295.765333-226.346667-393.557333-196.565333 301.226667-27.136 711.808 329.685334 781.866666l165.12-279.509333z\" fill=\"#34A853\" p-id=\"8872\"></path><path d=\"M669.866667 341.76a233.130667 233.130667 0 0 1 43.008 286.634667c-40.576 69.973333-170.154667 288.682667-232.96 394.581333 367.658667 22.656 635.733333-337.664 514.645333-681.258667H669.866667z\" fill=\"#FBBC05\" p-id=\"8873\"></path></svg>\n</div>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T07:36:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "渲染引擎的工作原理",
      "url": "https://www.fedbook.cn/frontend-knowledge/browser/execution-details-of-rendering-process/",
      "id": "https://www.fedbook.cn/frontend-knowledge/browser/execution-details-of-rendering-process/",
      "content_html": "<h1 id=\"渲染引擎的工作原理\"> 渲染引擎的工作原理</h1>\n<p>这个系列的第一篇文章中对「<a href=\"/frontend-knowledge/browser/browser-macro-knowledge/#导航流程-输入-url-到页面展示\">浏览器从输入 URL 到页面展示</a>」的整个流程做了小结，但其实最后一步在获得到 HTML、CSS 和 JavaScript 文件后，对渲染进程做的工作只是简单概括了一下，这里单独写一篇作为细节扩充。</p>\n<h2 id=\"html、css-和-javascript-是如何变成页面的\"> HTML、CSS 和 JavaScript 是如何变成页面的</h2>\n<p>渲染引擎的工作过程相当复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出像素。其大致流程如下图所示：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/simple-rendering-process.png\" alt=\"简单的渲染流程示意图\" style=\"width: 600px;\">\n  <p style=\"text-align: center; color: #888;\">（简单的渲染流程示意图，图来源于网络）</p>\n</div>\n<p>按照渲染的时间顺序，整个渲染流程可分为如下几个子阶段：构建 DOM 树、样式计算、布局、分层、图层绘制、栅格化、合成和显示。为了方便记忆，每个子阶段都应该重点关注其<strong>输入的内容</strong>，<strong>处理过程</strong>，<strong>输出内容</strong>。</p>\n<h3 id=\"流程小结\"> 流程小结</h3>\n<p>大体的渲染流程还是<strong>复制之前一篇文章里归纳的 <a href=\"/frontend-knowledge/browser/browser-macro-knowledge/#输入-url-到页面展示\">8 个步骤</a></strong>，这里在每个步骤之下补充一些细节知识点：</p>\n<ul>\n<li><strong>构建 DOM 树</strong>：通过 HTML 解析器将 HTML 转换成 DOM 树。</li>\n<li><strong>样式计算</strong>：渲染引擎将 CSS 文本转换为 styleSheets，计算出 DOM 节点的样式。\n<ul>\n<li>转成 styleSheets 后，会先进行属性值的标准化操作，再根据 CSS 的继承规则和层叠规则计算每个节点的具体样式。</li>\n</ul>\n</li>\n<li><strong>布局</strong>：创建布局树（只包含可见元素的树），并计算元素的布局信息。\n<ul>\n<li>布局是为了计算 DOM 树中可见元素的几何位置，因为前一步只是获得了元素样式，并不知道它应该放哪。</li>\n<li>布局树会忽略不可见节点，比如 <code>head</code> 标签，和使用了 <code>display:none</code> 属性的元素等。</li>\n<li>目前的布局操作中，布局树既是输入内容也是输出内容，Chrome 团队为了分离输入和输出，正在重构布局代码，下一代布局系统叫 LayoutNG。</li>\n</ul>\n</li>\n<li><strong>分层</strong>：对布局树进行分层，并生成分层树。\n<ul>\n<li>分层是为了实现页面中一些复杂的效果：3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等。</li>\n<li>如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。</li>\n<li>拥有层叠上下文属性的元素（比如定位属性元素、透明属性元素、CSS 滤镜属性元素）提升为单独的一层，需要裁剪（clip）的地方也会被创建为图层。</li>\n</ul>\n</li>\n<li><strong>图层绘制</strong>：为每个图层生成绘制列表，并将其提交到合成线程。\n<ul>\n<li>把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表。（就跟绘画一样，先画什么，再画什么……）</li>\n</ul>\n</li>\n<li><strong>栅格化</strong>：合成线程将图层分成图块，通过栅格化把图块转换为位图。\n<ul>\n<li>为了提高性能，即不绘制视口（viewport）以外的图层，合成线程会将图层划分为图块。</li>\n<li>图块是栅格化执行的最小单位，合成线程会按照视口附近的图块来优先生成位图。</li>\n<li>通常栅格化过程都会使用 GPU 来加速生成，这是一种跨进程操作（GPU 操作是运行在 GPU 进程中）。</li>\n</ul>\n</li>\n<li><strong>合成</strong>：所有图块都被光栅化后，渲染引擎中的合成线程发送一个绘制图块的命令「DrawQuad」给浏览器进程。</li>\n<li><strong>显示</strong>：浏览器进程根据接收到的「DrawQuad」消息绘制页面，并显示到显示器上。</li>\n</ul>\n<h3 id=\"完整流程示意图\"> 完整流程示意图</h3>\n<p>下图是一张李兵老师梳理的「完整的渲染流水线示意图」：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/complete-rendering-process.png\" alt=\"完整的渲染流水线示意图\">\n  <p style=\"text-align: center; color: #888;\">（完整的渲染流水线示意图，图来源于网络）</p>\n</div>\n<h2 id=\"重排、重绘、和合成\"> 重排、重绘、和合成</h2>\n<p>这是三个和渲染流水线相关的概念 —— 「重排」、「重绘」和「合成」，这三个概念与 Web 的性能优化有关。</p>\n<h3 id=\"重排-更新了元素的几何属性\"> 重排：更新了元素的几何属性</h3>\n<ul>\n<li>如果修改了元素的几何属性（元素的位置和尺寸大小），就会触发重新布局、解析之后的一系列子阶段。</li>\n<li>重排需要更新完整的渲染流水线，所以开销也是最大的。</li>\n<li>常见的引起重排的操作：\n<ul>\n<li>添加或者删除可见的 DOM 元素。</li>\n<li>元素尺寸改变 —— 边距、填充、边框、宽度和高度。</li>\n<li>内容变化，比如用户在 <code>input</code> 框中输入文字。</li>\n<li>浏览器窗口尺寸改变 —— <code>resize</code> 事件发生时。</li>\n<li>计算 <code>offsetWidth</code> 和 <code>offsetHeight</code> 属性。</li>\n<li>设置 <code>style</code> 属性的值。</li>\n</ul>\n</li>\n</ul>\n<p>常见的引起重排的属性和方法：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">width</td>\n<td style=\"text-align:left\">height</td>\n<td style=\"text-align:left\">margin</td>\n<td style=\"text-align:left\">padding</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">display</td>\n<td style=\"text-align:left\">border</td>\n<td style=\"text-align:left\">position</td>\n<td style=\"text-align:left\">overflow</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">clientWidth</td>\n<td style=\"text-align:left\">clientHeight</td>\n<td style=\"text-align:left\">clientTop</td>\n<td style=\"text-align:left\">clientLeft</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">offsetWidth</td>\n<td style=\"text-align:left\">offsetHeight</td>\n<td style=\"text-align:left\">offsetTop</td>\n<td style=\"text-align:left\">offsetLeft</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">scrollWidth</td>\n<td style=\"text-align:left\">scrollHeight</td>\n<td style=\"text-align:left\">scrollTop</td>\n<td style=\"text-align:left\">scrollLeft</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">scrollIntoView()</td>\n<td style=\"text-align:left\">scrollTo()</td>\n<td style=\"text-align:left\">getComputedStyle()</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">getBoundingClientRect()</td>\n<td style=\"text-align:left\">scrollIntoViewIfNeeded()</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"重绘-更新元素的绘制属性\"> 重绘：更新元素的绘制属性</h3>\n<ul>\n<li>如果修改了元素的外观属性（颜色、背景、边框等），就会直接进入了绘制阶段，然后执行之后的一系列子阶段。</li>\n<li>因为几何位置没有变换，所以布局阶段不会被执行，省去了布局和分层阶段，所以执行效率会比重排操作要高一些。</li>\n</ul>\n<p>常见的引起重绘的属性：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">color</td>\n<td style=\"text-align:left\">border-style</td>\n<td style=\"text-align:left\">visibility</td>\n<td style=\"text-align:left\">background</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">text-decoration</td>\n<td style=\"text-align:left\">background-image</td>\n<td style=\"text-align:left\">background-position</td>\n<td style=\"text-align:left\">background-repeat</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">outline-color</td>\n<td style=\"text-align:left\">outline</td>\n<td style=\"text-align:left\">outline-style</td>\n<td style=\"text-align:left\">border-radius</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">outline-width</td>\n<td style=\"text-align:left\">box-shadow</td>\n<td style=\"text-align:left\">background-size</td>\n<td style=\"text-align:left\"></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"合成-直接合成阶段\"> 合成：直接合成阶段</h3>\n<ul>\n<li>如果更改的是一个既不要布局也不要绘制的属性，渲染引擎将跳过布局和绘制，只执行后续的合成操作。</li>\n<li>例如：使用 CSS3 的 <code>transform</code> 来实现动画效果，比使用 JS 修改 style 高效。</li>\n</ul>\n<h2 id=\"优化策略-减少重排和重绘\"> 优化策略：减少重排和重绘</h2>\n<h3 id=\"_1-对-dom-属性的读写操作要分离\"> 1.对 dom 属性的读写操作要分离</h3>\n<div><pre><code><span>// 这段代码会触发 4 次重排 + 重绘</span>\n<span>// 因为在 console 中用到的这几个属性虽然跟操作修改的值没关联, </span>\n<span>// 但浏览器为了给我们最精确的值, 会立即重排 + 重绘.</span>\n<span>// </span>\n<span>// 这种会强制刷新渲染队列并触发立即重排的属性还有:</span>\n<span>// offsetTop, offsetLeft, offsetWidth, offsetHeight</span>\n<span>// scrollTop, scrollLeft, scrollWidth, scrollHeight</span>\n<span>// clientTop, clientLeft, clientWidth, clientHeight</span>\n<span>// getComputedStyle(), 或者 IE 的 currentStyle</span>\ndiv<span>.</span>style<span>.</span>left <span>=</span> <span>'10px'</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>div<span>.</span>offsetLeft<span>)</span><span>;</span>\ndiv<span>.</span>style<span>.</span>top <span>=</span> <span>'10px'</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>div<span>.</span>offsetTop<span>)</span><span>;</span>\ndiv<span>.</span>style<span>.</span>width <span>=</span> <span>'20px'</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>div<span>.</span>offsetWidth<span>)</span><span>;</span>\ndiv<span>.</span>style<span>.</span>height <span>=</span> <span>'20px'</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>div<span>.</span>offsetHeight<span>)</span><span>;</span>\n\n<span>// 这段代码只会触发 1 次重排 + 重绘</span>\n<span>// 因为操作值的时候, 只有等到渲染队列中到了一定大小, 或一定时间间隔后, 浏览器才会批量执行这些操作;</span>\n<span>// 而读取值的时候, 因为渲染队列本来就是空的, 所以并没有触发重排, 仅仅拿值而已.</span>\ndiv<span>.</span>style<span>.</span>left <span>=</span> <span>'10px'</span><span>;</span>\ndiv<span>.</span>style<span>.</span>top <span>=</span> <span>'10px'</span><span>;</span>\ndiv<span>.</span>style<span>.</span>width <span>=</span> <span>'20px'</span><span>;</span>\ndiv<span>.</span>style<span>.</span>height <span>=</span> <span>'20px'</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>div<span>.</span>offsetLeft<span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>div<span>.</span>offsetTop<span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>div<span>.</span>offsetWidth<span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>div<span>.</span>offsetHeight<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h3 id=\"_2-使用-class-操作样式-而不是频繁操作-style\"> 2.使用 class 操作样式，而不是频繁操作 style</h3>\n<p>虽然现在大部分浏览器有渲染队列优化，不排除有些浏览器以及老版本的浏览器效率仍然低下，所以建议通过改变 <code>class</code> 或者 <code>cssText</code> 属性集中改变样式。</p>\n<div><pre><code><span>// bad</span>\n<span>var</span> left <span>=</span> <span>10</span><span>;</span>\n<span>var</span> top <span>=</span> <span>10</span><span>;</span>\nel<span>.</span>style<span>.</span>left <span>=</span> left <span>+</span> <span>\"px\"</span><span>;</span>\nel<span>.</span>style<span>.</span>top  <span>=</span> top  <span>+</span> <span>\"px\"</span><span>;</span>\n\n<span>// good </span>\nel<span>.</span>className <span>+=</span> <span>\" theclassname\"</span><span>;</span>\n<span>// good</span>\nel<span>.</span>style<span>.</span>cssText <span>+=</span> <span>\"; left: \"</span> <span>+</span> left <span>+</span> <span>\"px; top: \"</span> <span>+</span> top <span>+</span> <span>\"px;\"</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"_3-缓存布局信息\"> 3.缓存布局信息</h3>\n<div><pre><code><span>// bad 强制刷新, 触发两次重排</span>\ndiv<span>.</span>style<span>.</span>left <span>=</span> div<span>.</span>offsetLeft <span>+</span> <span>1</span> <span>+</span> <span>'px'</span><span>;</span>\ndiv<span>.</span>style<span>.</span>top <span>=</span> div<span>.</span>offsetTop <span>+</span> <span>1</span> <span>+</span> <span>'px'</span><span>;</span>\n\n<span>// good 缓存布局信息, 相当于读写分离</span>\n<span>var</span> curLeft <span>=</span> div<span>.</span>offsetLeft<span>;</span>\n<span>var</span> curTop <span>=</span> div<span>.</span>offsetTop<span>;</span>\ndiv<span>.</span>style<span>.</span>left <span>=</span> curLeft <span>+</span> <span>1</span> <span>+</span> <span>'px'</span><span>;</span>\ndiv<span>.</span>style<span>.</span>top <span>=</span> curTop <span>+</span> <span>1</span> <span>+</span> <span>'px'</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"_4-离线改变-dom\"> 4.离线改变 DOM</h3>\n<ul>\n<li>隐藏要操作的 DOM<br>\n在要操作 DOM  之前，通过 <code>display</code> 隐藏 DOM ，当操作完成之后（比如修改 100 次后），才将元素的 display 属性设置为可见，因为不可见的元素不会触发重排和重绘。<div><pre><code>dom<span>.</span>display <span>=</span> <span>'none'</span>\n<span>// 修改 DOM 样式</span>\ndom<span>.</span>display <span>=</span> <span>'block'</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>\n<li>通过使用 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment\" target=\"_blank\" rel=\"noopener noreferrer\">DocumentFragment</a> 创建一个 DOM 碎片，在它上面批量操作 DOM，操作完成之后，再添加到文档中，这样只会触发一次重排。</li>\n<li>复制节点，在副本上工作，然后替换它。</li>\n<li>使用现代化框架，例如 Vue、React。</li>\n</ul>\n<h3 id=\"_5-position-属性为-absolute-或-fixed\"> 5.position 属性为 absolute 或 fixed</h3>\n<p>position 属性为 absolute 或 fixed 的元素，重排开销比较小，不用考虑它对其他元素的影响。</p>\n<h3 id=\"_6-优化动画\"> 6.优化动画</h3>\n<ul>\n<li>可以把动画效果应用到 position 属性为 absolute 或 fixed 的元素上，这样对其他元素影响较小。\n<ul>\n<li>动画效果还应牺牲一些平滑，来换取速度，这中间的度自己衡量：比如实现一个动画，以 1 个像素为单位移动这样最平滑，但是 reflow 就会过于频繁，大量消耗 CPU 资源，如果以 3 个像素为单位移动则会好很多。</li>\n</ul>\n</li>\n<li>启用 GPU 硬件加速\n<ul>\n<li>GPU 硬件加速是指应用 GPU 的图形性能对浏览器中的一些图形操作交给 GPU 来完成，因为 GPU 是专门为处理图形而设计，所以它在速度和能耗上更有效率。</li>\n<li>GPU 加速通常包括以下几个部分：Canvas2D，布局合成，CSS3转换（transitions），CSS3 3D 变换（transforms），WebGL 和视频（video）。</li>\n</ul>\n<div><pre><code><span>/*\n * 根据上面的结论\n * 将 2d transform 换成 3d\n * 就可以强制开启 GPU 加速\n * 提高动画性能\n */</span>\n<span>div</span> <span>{</span>\n  <span>transform</span><span>:</span> <span>translate</span><span>(</span>10px<span>,</span> 10px<span>)</span><span>;</span>\n<span>}</span>\n<span>div</span> <span>{</span>\n  <span>transform</span><span>:</span> <span>translate3d</span><span>(</span>10px<span>,</span> 10px<span>,</span> 0<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div></li>\n</ul>\n<h3 id=\"_7-对-window-resize-事件做防抖处理\"> 7.对 window resize 事件做防抖处理</h3>\n<p>这个延迟时间视场合而定。</p>\n<h3 id=\"_8-不要使用-table-布局\"> 8.不要使用 table 布局</h3>\n<p>因为 table 中某个元素一旦触发了重排，那么整个 table 的元素都会触发重排。在不得已使用 table 的场合，可以设置 <code>table-layout: auto;</code> 或者是 <code>table-layout:fixed</code> 这样可以让 table 一行一行的渲染，这种做法也是为了限制重排的影响范围。</p>\n<h3 id=\"_9-尽可能不要修改影响范围比较大的-dom\"> 9.尽可能不要修改影响范围比较大的 DOM</h3>\n<p>尽可能限制重排的影响范围，尽可能在低层级的 DOM 节点上作修改。比如要改变 p 标签的样式，class 就不要加在它上层的 div 标签上，通过父元素去影响子元素不好。</p>\n<h3 id=\"_10-慎用-css-表达式\"> 10.慎用 CSS 表达式</h3>\n<p>如果 CSS 里面有计算表达式，每次都会重新计算一遍，都会触发一次重排。</p>\n<p>（完）</p>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T07:36:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "V8 引擎的工作原理",
      "url": "https://www.fedbook.cn/frontend-knowledge/browser/execution-details-of-v8-engine/",
      "id": "https://www.fedbook.cn/frontend-knowledge/browser/execution-details-of-v8-engine/",
      "content_html": "<h1 id=\"v8-引擎的工作原理\"> V8 引擎的工作原理</h1>\n<p>V8 是用 C++ 编写的 Google 开源高性能 JavaScript 和 WebAssembly 引擎，它用于 Chrome 和 Node.js 等，既可以独立运行，也可以嵌入到任何 C++ 应用程序中。</p>\n<p>V8 引擎本身的源码非常复杂，大概有超过 100w 行 C++ 代码，作为前端开发者我暂时没有对它进行深入研究。只是通过了解它的架构，了解它是如何对 JavaScript 执行的。</p>\n<h2 id=\"核心概念\"> 核心概念</h2>\n<p>要深入理解 V8 的工作原理，就需要先搞清楚一些概念和原理，比如编译器（Compiler）、解释器（Interpreter）、抽象语法树（AST）、字节码（Bytecode）、即时编译器（JIT）等概念。</p>\n<ul>\n<li><strong>编译器</strong>：编译型语言在经过编译器的编译之后，会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。常见的编译型语言有 C/C++、GO 等。</li>\n<li><strong>解释器</strong>：由解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。常见的解释型语言有 Python、JavaScript 等。</li>\n<li><strong>抽象语法树</strong>：抽象语法树（AST） 是一种特殊的数据结构，它是我们所编写代码的结构化表示。无论是解释型语言还是编译型语言，只有将代码转换成 AST 之后，编译器或者解释器才能理解我们写的代码。</li>\n<li><strong>字节码</strong>：字节码（Bytecode）是介于 AST 和机器码之间的一种代码。在解释型语言的解释过程中，解释器将源代码转换成抽象语法树（AST），会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。</li>\n<li><strong>即时编译器</strong>：直接编译成机器码的执行效率高，但机器码所占用的空间远远超过了字节码。所以就有了字节码配合解释器和编译器的技术，称为即时编译（JIT）。\n<ul>\n<li>具体到 V8，就是指解释器在解释执行字节码的同时，收集代码信息，如果发现有热点代码（一段代码被重复执行多次），后台的编译器就会把该段热点的字节码编译为高效的机器码，并保存起来，以备下次使用。</li>\n<li>另外比如 Java 和 Python 的虚拟机也都是基于这种技术实现的，</li>\n</ul>\n</li>\n</ul>\n<p>概括一下 V8 是如何执行一段 JavaScript 代码的：<strong>V8 依据 JavaScript 代码生成 AST 和执行上下文，再基于 AST 生成字节码，然后通过解释器执行字节码，通过编译器来优化编译字节码</strong>。</p>\n<h2 id=\"执行流程\"> 执行流程</h2>\n<p>V8 执行一段 JavaScript 代码的流程如下图所示：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/v8-engine-workflow.svg\" alt=\"V8 引擎的原理\">\n  <p style=\"text-align: center; color: #888;\">（V8 引擎的原理，图修改自网络）</p>\n</div>\n<p>由图可图，主要有三个模块参与工作：</p>\n<ul>\n<li><strong>Parse</strong> 模块会将 JavaScript 代码转换成 AST（抽象语法树），这是因为解释器并不直接认识 JavaScript 代码。\n<ul>\n<li>如果函数没有被调用，那么是不会被转换成 AST 的。</li>\n</ul>\n</li>\n<li><strong>Ignition</strong> 是一个解释器，会将 AST 转换成 ByteCode（字节码）\n<ul>\n<li>同时会收集 TurboFan 优化所需要的信息（比如函数参数的类型信息，有了类型才能进行真实的运算）。</li>\n<li>如果函数只调用一次，Ignition 会执行解释执行 ByteCode。</li>\n</ul>\n</li>\n<li><strong>TurboFan</strong> 是一个编译器，可以将字节码编译为 CPU 可以直接执行的机器码。\n<ul>\n<li>如果一个函数被多次调用，那么就会被标记为<strong>热点函数</strong>，那么就会<strong>经过 TurboFan 转换成优化的机器码，提高代码的执行性能</strong>。</li>\n<li>但是，<strong>机器码实际上也会被还原为 ByteCode</strong>，这是因为如果后续执行函数的过程中，<strong>类型发生了变化（比如 <code>sum</code> 函数原来执行的是 <code>number</code> 类型，后来执行变成了 <code>string</code> 类型）</strong>，之前优化的机器码并不能正确的处理运算，就会逆向的转换（Deoptimization）成字节码。</li>\n</ul>\n</li>\n</ul>\n<p>总结整个过程：在形成抽象语法树之后，解释器会翻译成字节码。等到真正运行的时候，再将字节码转换成汇编代码，并执行 CPU 可以理解的机器码。</p>\n<p><strong>转成字节码的优点</strong>：字节码可以跨平台，在需要的时候转换成对应平台的机器指令就能运行。</p>\n<p><strong>转成字节码的缺点</strong>：每次「字节码 --&gt; 汇编指令 --&gt; 执行机器指令」这样的过程比较耗费性能。</p>\n<p>鉴于这个缺点，V8 就考虑把<strong>热点函数的字节码直接转换成对应平台的机器码</strong>存储下来，等真正运行的时候直接执行机器码就可以了。对于只执行一次的函数，就保持原来的逻辑以节省空间。</p>\n<p>这么做性能问题解决了，但又引入了新的麻烦：因为 JavaScript 是动态语言，不会对类型做检测。像 <code>sum</code> 函数这种，传入的参数类型不一样，其内部执行的逻辑是不一样的（数字是相加，字符串是拼接）。此时 V8 就引入了 Deoptimization 操作，一旦发现执行操作不一样，就把机器码反向转成字节码。</p>\n<p>根据这个底层原理可知，出于优化考虑，我们在调用某个函数的时候应该尽量传相同类型的参数。所以从某种程度上来说，TypeScript 编译出来的最终 JS 代码，会比我们平时直接写的 JS 代码运行效率高一些。</p>\n<div><p>相关文档</p>\n<ul>\n<li><a href=\"https://v8.dev/blog/scanner\" target=\"_blank\" rel=\"noopener noreferrer\">Parse 的 V8 官方文档</a></li>\n<li><a href=\"https://v8.dev/blog/ignition-interpreter\" target=\"_blank\" rel=\"noopener noreferrer\">Ignition 的 V8 官方文档</a></li>\n<li><a href=\"https://v8.dev/blog/turbofan-jit\" target=\"_blank\" rel=\"noopener noreferrer\">TurboFan 的 V8 官方文档</a></li>\n</ul>\n</div>\n<h2 id=\"parse-过程\"> Parse 过程</h2>\n<p>下面这张图来自于 <a href=\"https://v8.dev/blog/scanner\" target=\"_blank\" rel=\"noopener noreferrer\">V8 官方文档</a>，它描述了 V8 执行的细节 —— JavaScript 源码是如何被解析（Parse 过程）的：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/v8-overview.svg\" alt=\"V8 引擎的解析图\" style=\"width: 550px;\">\n  <p style=\"text-align: center; color: #888;\">（V8 引擎的解析图，图片来源于官方文档）</p>\n</div>\n<ul>\n<li>Blink 将源码交给 V8 引擎，Stream 获取到源码并且进行编码转换。</li>\n<li>Scanner 会进行词法分析（lexical analysis），词法分析会将代码转换成 tokens。</li>\n<li>接下来 tokens 会被转换成 AST 树，经过 Parser 和 PreParser：\n<ul>\n<li>Parser 就是直接将 tokens 转成 AST 树架构。</li>\n<li>PreParser 称之为预解析，为什么需要预解析呢？\n<ul>\n<li>这是因为并不是所有的 JavaScript 代码，在一开始时就会被执行。那么对所有的 JavaScript 代码进行解析，必然会影响网页的运行效率；</li>\n<li>所以 V8 引擎就实现了 <strong>Lazy Parsing（延迟解析）<strong>的方案，它的作用是</strong>将不必要的函数进行预解析</strong>，也就是只解析暂时需要的内容（比如知道内部函数的函数名叫 <code>inner</code>），而对<strong>函数的全量解析</strong>是在<strong>函数被调用时</strong>才会进行；</li>\n<li>比如我们在一个函数 <code>outer</code> 内部定义了另外一个函数 <code>inner</code>，那么 <code>inner</code> 函数就会进行预解析。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>生成 AST 树后，会被 Ignition 转成字节码（ByteCode），之后的过程就是代码的执行过程了。</li>\n</ul>\n<div><p>小工具</p>\n<p>通过 <a href=\"https://astexplorer.net/\" target=\"_blank\" rel=\"noopener noreferrer\">AST Explorer</a> 在线小工具，可以观察 JS 语法经过转换后的 AST 是长什么样的。</p>\n</div>\n<p>（完）</p>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T07:36:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "BFC",
      "url": "https://www.fedbook.cn/frontend-knowledge/css/bfc/",
      "id": "https://www.fedbook.cn/frontend-knowledge/css/bfc/",
      "content_html": "<h1 id=\"bfc\"> BFC</h1>\n<h2 id=\"常见定位方案\"> 常见定位方案</h2>\n<p>在讲 BFC 之前，我们先来了解一下常见的定位方案，定位方案用于控制元素的布局，有三种常见方案：</p>\n<ul>\n<li>普通流（normal flow）</li>\n</ul>\n<blockquote>\n<p>在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。</p>\n</blockquote>\n<ul>\n<li>浮动（float）</li>\n</ul>\n<blockquote>\n<p>在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。</p>\n</blockquote>\n<ul>\n<li>绝对定位（absolute positioning）</li>\n</ul>\n<blockquote>\n<p>在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。</p>\n</blockquote>\n<h2 id=\"bfc-概念\"> BFC 概念</h2>\n<p>BFC 即 Block Formatting Context（块级格式化上下文），属于前面定位方案中的普通流（normal flow）。</p>\n<p>具有 BFC 特性的元素可以看作是一个隔离的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。</p>\n<p>下面我们再分别介绍下 Box 和 Formatting Context 的概念。</p>\n<h3 id=\"box-css-布局的基本单位\"> Box：CSS 布局的基本单位</h3>\n<p>Box 是 CSS 布局的对象和基本单位，直观来说，一个页面有很多个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。不同的 Box，会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此 Box 内的元素会以不同的方式渲染。</p>\n<p>常见盒子：</p>\n<ul>\n<li>block-level box：<code>display</code> 属性为 <code>block</code>、<code>list-item</code>、<code>table</code> 的元素，会生成 block-level box</li>\n<li>inline-level box：<code>display</code> 属性为 <code>inline</code>、<code>inline-block</code>、<code>inline-table</code> 的元素，会生成 inline-level box</li>\n<li>run-in box：CSS3 特有</li>\n</ul>\n<p>PS：这里的 Box 即指盒模型，关于盒模型的具体内容可以查看<a href=\"/frontend-knowledge/css/box-model/\" title=\"盒模型\">盒模型</a>章节</p>\n<h3 id=\"formatting-context\"> Formatting Context</h3>\n<p>Formatting Context 是 W3C CSS2.1 规范中的一个概念。他是页面的一块渲染区域，并且有一套渲染规则，它决定了其子元素如何定位，以及和其他元素的关系和相互作用。</p>\n<p>最常见的 Formatting Context 有 Block formatting context 和 Inline formatting context。</p>\n<ul>\n<li>块级格式化上下文（Block Formatting Context）（BFC）</li>\n<li>行内格式化上下文（Inline Formatting Context）（IFC）</li>\n<li>自适应格式化上下文（Flex Formatting Context）（FFC）（CSS3 新增）</li>\n<li>网格布局格式化上下文（GridLayout Formatting Context）（GFC）（CSS3 新增）</li>\n</ul>\n<h2 id=\"bfc-特性及示例\"> BFC 特性及示例</h2>\n<h3 id=\"特性\"> 特性</h3>\n<ul>\n<li>同一个 BFC 下外边距会发生折叠</li>\n<li>计算 BFC 的高度时，浮动元素也参与计算</li>\n<li>BFC 的区域不会与浮动盒子重叠（清除浮动原理）</li>\n</ul>\n<h3 id=\"示例\"> 示例</h3>\n<h4 id=\"_1-同一个-bfc-下外边距会发生折叠\"> 1）同一个 BFC 下外边距会发生折叠</h4>\n<p>属于同一个 BFC 的两个相邻 Box 在垂直方向排列时，垂直方向的外边距会发生重叠，它们在垂直方向的距离由 margin 决定，取最大值。（如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中）</p>\n<p>如下示例，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 display: flow-root 的元素) ，所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，两个盒子之间的距离是 10px 而非累加的 20px。</p>\n<iframe height=\"328\" style=\"width: 100%;\" scrolling=\"no\" title=\"css-bfc-demo-1\" src=\"https://codepen.io/winyuan/embed/zYBZwVO?height=328&theme-id=light&default-tab=result\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href='https://codepen.io/winyuan/pen/zYBZwVO'>css-bfc-demo-1</a> by wenyuan\n  (<a href='https://codepen.io/winyuan'>@winyuan</a>) on <a href='https://codepen.io'>CodePen</a>.\n</iframe>\n<h4 id=\"_2-计算-bfc-的高度时-浮动元素也参与计算\"> 2）计算 BFC 的高度时，浮动元素也参与计算</h4>\n<p>由于容器内元素浮动，脱离了文档流，此时如果容器内没有其他非浮动元素撑开高度，就会产生高度塌陷的问题（容器高度为 0）。</p>\n<p>如果使容器触发 BFC，那么容器将会包裹住浮动元素，在计算 BFC 的高度时，浮动元素也参与计算。</p>\n<iframe height=\"280\" style=\"width: 100%;\" scrolling=\"no\" title=\"css-bfc-demo-2\" src=\"https://codepen.io/winyuan/embed/yLJMbdZ?height=280&theme-id=light&default-tab=result\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href='https://codepen.io/winyuan/pen/yLJMbdZ'>css-bfc-demo-2</a> by wenyuan\n  (<a href='https://codepen.io/winyuan'>@winyuan</a>) on <a href='https://codepen.io'>CodePen</a>.\n</iframe>\n<h4 id=\"_3-bfc-的区域不会与浮动盒子重叠-清除浮动原理\"> 3）BFC 的区域不会与浮动盒子重叠（清除浮动原理）</h4>\n<p>先来看一个文字环绕效果：</p>\n<iframe height=\"310\" style=\"width: 100%;\" scrolling=\"no\" title=\"css-bfc-demo-3\" src=\"https://codepen.io/winyuan/embed/JjKWJPG?height=310&theme-id=light&default-tab=result\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href='https://codepen.io/winyuan/pen/JjKWJPG'>css-bfc-demo-3</a> by wenyuan\n  (<a href='https://codepen.io/winyuan'>@winyuan</a>) on <a href='https://codepen.io'>CodePen</a>.\n</iframe>\n<p>这时候其实第二个元素有部分被浮动元素所覆盖（但是文本信息不会被浮动元素所覆盖），如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 <code>overflow: hidden</code>，就会变成：</p>\n<iframe height=\"313\" style=\"width: 100%;\" scrolling=\"no\" title=\"css-bfc-demo-4\" src=\"https://codepen.io/winyuan/embed/xxOqrbw?height=313&theme-id=light&default-tab=result\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href='https://codepen.io/winyuan/pen/xxOqrbw'>css-bfc-demo-4</a> by wenyuan\n  (<a href='https://codepen.io/winyuan'>@winyuan</a>) on <a href='https://codepen.io'>CodePen</a>.\n</iframe>\n<p>这个方法可以用来实现两列自适应布局，这时候左边的宽度固定，右边的内容自适应宽度（不指定右边元素的 width 属性）。</p>\n<h2 id=\"哪些元素会生成-bfc\"> 哪些元素会生成 BFC</h2>\n<p>只要元素满足下面任一条件即可触发 BFC 特性：</p>\n<ul>\n<li>根元素（<code>&lt;html&gt;</code>）</li>\n<li>浮动元素（float 属性不为 none）</li>\n<li>绝对定位元素（position 属性为 absolute 或 fixed）</li>\n<li>内联块（display 属性为 inline-block）</li>\n<li>表格单元格（display 属性为 table-cell，HTML 表格单元格默认属性）</li>\n<li>表格标题（display 属性为 table-caption，HTML 表格单元格默认属性）</li>\n<li>具有 overflow 且值不是 visible 的块元素</li>\n<li>弹性盒子（display 属性为 flex 或 inline-flex）</li>\n<li>display: flow-root（CSS 新增的属性，专门用来触发 BFC，但浏览器兼容性差）</li>\n<li>column-span: all（原本的作用是让元素横跨所有列。该属性总是会创建一个新的格式化上下文，即便具有 column-span: all 的元素并不被包裹在一个多列容器中）</li>\n</ul>\n<h2 id=\"bfc-的应用\"> BFC 的应用</h2>\n<ul>\n<li>利用 BFC 避免 margin 重叠</li>\n<li>自适应两栏布局</li>\n<li>清除浮动</li>\n</ul>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context\" title=\"块格式化上下文\" target=\"_blank\" rel=\"noopener noreferrer\">MDN：块格式化上下文</a></li>\n</ul>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T07:36:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Grid 布局",
      "url": "https://www.fedbook.cn/frontend-knowledge/css/grid/",
      "id": "https://www.fedbook.cn/frontend-knowledge/css/grid/",
      "content_html": "<h1 id=\"grid-布局\"> Grid 布局</h1>\n<p>Grid 网格布局虽然强大，但由于其兼容性比 Flex 更差一点，目前并未得到全面应用。这主要取决于现代化浏览器的普及率（有些单位还是会更多地使用 IE）。</p>\n<p>但作为一种全新的布局方式，随着现代化浏览器的逐渐普及，再加上不可能总是做面向 IE 客户的产品，Grid 网格布局未来也许会是一种趋势。</p>\n<p>因此这一章节先放两篇比较好的Grid 网格布局文章，等以后用到了再系统整理。</p>\n<ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html\" target=\"_blank\" rel=\"noopener noreferrer\">CSS Grid 网格布局教程</a></li>\n<li><a href=\"https://www.html.cn/archives/8510\" target=\"_blank\" rel=\"noopener noreferrer\">Flexbox 布局完全指南(图解 Flexbox 布局详细教程)</a></li>\n</ul>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2022-01-06T09:06:13.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "CSS",
      "url": "https://www.fedbook.cn/frontend-knowledge/css/",
      "id": "https://www.fedbook.cn/frontend-knowledge/css/",
      "content_html": "<h1 id=\"css\"> CSS</h1>\n<p>在 Web 前端页面中，</p>\n<ul>\n<li>HTML 属于结构层，负责描绘出内容的结构；</li>\n<li><strong>CSS 属于表现层，负责「如何显示有关内容」</strong>；</li>\n<li>JavaScript 属于行为层，负责「内容应如何对事件做出反应」。</li>\n</ul>\n<hr>\n<p>关于 CSS 的知识点，主要参考：</p>\n<ul>\n<li>《精通CSS 高级Web标准解决方案（第3版）》</li>\n<li>《深入解析CSS》</li>\n<li><strong>W3school</strong> 的 HTML/CSS 部分</li>\n<li><strong>MDN</strong> 中关于 CSS 的内容</li>\n</ul>\n<div style=\"text-align: right\">\n  <svg t=\"1595038960277\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"837\" width=\"64\" height=\"64\"><path d=\"M88.064 27.648l77.824 871.424L512 996.352l346.112-97.28 77.824-871.424z\" fill=\"#2196F3\" p-id=\"838\"></path><path d=\"M771.072 312.32l-10.24 109.568-29.696 328.704L512 811.008l-220.16-60.416-14.336-172.032h107.52l7.168 89.088L512 700.416l119.808-32.768 16.384-148.48-375.808 1.024-11.264-101.376 395.264-4.096 8.192-108.544-413.696 1.024-7.168-101.376h536.576z\" fill=\"#FAFAFA\" p-id=\"839\"></path></svg>\n</div>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T08:41:15.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Flexbox 布局",
      "url": "https://www.fedbook.cn/frontend-knowledge/css/flexbox/",
      "id": "https://www.fedbook.cn/frontend-knowledge/css/flexbox/",
      "content_html": "<h1 id=\"flexbox-布局\"> Flexbox 布局</h1>\n<p>布局的传统解决方案，是基于盒模型，通过它的 <code>display</code>、<code>position</code>、<code>float</code> 等属性来进行布局。它对于一些特殊布局不是很方便，比如垂直居中水平居中，如果运用了浮动特性的话，就需要清除浮动，不但比较麻烦，一不小心还会出现意料之外的布局，最后呈现的结果往往不尽人意。</p>\n<h2 id=\"基础知识\"> 基础知识</h2>\n<p>Flexbox（全称 Flexible Box）布局，也叫 Flex 布局，意为「弹性布局」。</p>\n<p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称「容器」。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称「项目」。</p>\n<p>结合下面这张图片，先介绍一下 flex 布局背后的主要思想。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/flexbox.png\" alt=\"flexbox\">\n  <p style=\"text-align: center; color: #888;\">（Flexbox 布局模块，图来源于网络）</p>\n</div>\n<p>在 Flex 布局中，Flex 项目（就是子元素）要么按照 main axis（主轴）（从 main start 到 main end）排布，要么按照 cross axis（交叉轴）（从 cross start 到 cross end）排布。</p>\n<ul>\n<li><strong>main axis</strong>：Flex 容器的主轴，Flex 项目沿着主轴排布，注意主轴不一定是水平的，主轴是水平还是垂直取决于 <code>flex-direction</code> 属性（见下文）。</li>\n<li><strong>main start|main end</strong>：分别表示主轴的开始位置和结束位置，Flex 项目在容器中会从 main start 到 main end 排布。</li>\n<li><strong>main size</strong>：Flex 项目占据主轴的宽度或高度。Flex 项目的 main size 属性要么是「宽度」，要么是「高度」，这取决于主轴方向。</li>\n<li><strong>cross axis</strong>：垂直于主轴的轴线称为交叉轴，其方向取决于主轴方向。</li>\n<li><strong>cross start|cross end</strong>：分别表示交叉轴的开始位置和结束位置。Flex 项目在交叉轴上的排布从 cross start 开始位置到 cross end 结束位置。</li>\n<li><strong>cross size</strong>：Flex 项目占据交叉轴的高度或宽度。Flex 项目的 cross size 属性要么是「高度」，要么是「宽度」，这取决于交叉轴方向。</li>\n</ul>\n<p>了解完 Flex 布局相关的抽象概念，接下来我们来看看有关 Flex 布局的属性部分，这里分为两部分介绍，一是作用于父元素（容器）的，二是作用于子元素（项目）的。</p>\n<h2 id=\"容器属性\"> 容器属性</h2>\n<p>display 属性用来将父元素定义为 Flex 布局的容器，设置 display 值为 <code>display: flex;</code> 容器对外表现为块级元素；<code>display: inline-flex;</code> 容器对外表现为行内元素，对内两者表现是一样的。</p>\n<p>（注意，设为 Flex 布局以后，子元素的 <code>float</code>、<code>clear</code> 和 <code>vertical-align</code> 属性将失效）。</p>\n<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>container<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br></div></div><div><pre><code><span>.container</span> <span>{</span>\n  <span>display</span><span>:</span> flex | inline-flex<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面的代码就定义了一个 Flex 布局的容器，我们有以下 6 个属性可以设置的容器上：</p>\n<ul>\n<li>flex-direction</li>\n<li>flex-wrap</li>\n<li>flex-flow</li>\n<li>justify-content</li>\n<li>align-items</li>\n<li>align-content</li>\n</ul>\n<h3 id=\"flex-direction\"> flex-direction</h3>\n<p>flex-direction 定义了主轴的方向，即项目的排列方向。</p>\n<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>container<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>item<span>\"</span></span><span>></span></span>1<span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>item<span>\"</span></span><span>></span></span>2<span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>item<span>\"</span></span><span>></span></span>3<span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>item<span>\"</span></span><span>></span></span>3<span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code><span>.container</span>  <span>{</span>\n  <span>flex-direction</span><span>:</span> row | row-reverse | column | column-reverse<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>\n<li>row（默认值）：主轴在水平方向，起点在左侧，也就是我们常见的从左到右；</li>\n<li>row-reverse：主轴在水平方向，起点在右侧；</li>\n<li>column：主轴在垂直方向，起点在上沿；</li>\n<li>column-reverse: 主轴在垂直方向，起点在下沿。</li>\n</ul>\n<div style=\"text-align: left;\">\n  <img src=\"./assets/flex-container_flex-direction_row.png\" alt=\"flex-direction 为 row\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（flex-direction 为 row）</p>\n</div>\n<div style=\"text-align: right;\">\n  <img src=\"./assets/flex-container_flex-direction_row-reverse.png\" alt=\"flex-direction 为 row-reverse\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（flex-direction 为 row-reverse）</p>\n</div>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/flex-container_flex-direction_column.png\" alt=\"flex-direction 为 column\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（flex-direction 为 column）</p>\n</div>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/flex-container_flex-direction_column-reverse.png\" alt=\"flex-direction 为 column-reverse\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（flex-direction 为 column-reverse）</p>\n</div>\n<h3 id=\"flex-wrap\"> flex-wrap</h3>\n<p>默认情况下，项目是排成一行显示的，flex-wrap 用来定义当一行放不下时，项目如何换行。</p>\n<div><pre><code><span>.container</span> <span>{</span>\n  <span>flex-wrap</span><span>:</span> nowrap | wrap | wrap-reverse<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>假设此时主轴是从左到右的水平方向：</p>\n<ul>\n<li>nowrap（默认）：不换行；</li>\n<li>wrap：换行，第一行在上面；</li>\n<li>wrap-reverse：换行，第一行在下面。</li>\n</ul>\n<div style=\"text-align: left;\">\n  <img src=\"./assets/flex-container_flex-wrap_nowrap.png\" alt=\"flex-wrap 为 nowrap\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（默认情况，flex-wrap 为 nowrap，不换行，即使设置了项目的宽度，项目也会根据屏幕的大小被压缩）</p>\n</div>\n<div style=\"text-align: left;\">\n  <img src=\"./assets/flex-container_flex-wrap_wrap.png\" alt=\"flex-wrap 为 wrap\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（flex-wrap 为 wrap）</p>\n</div>\n<div style=\"text-align: left;\">\n  <img src=\"./assets/flex-container_flex-wrap_wrap-reverse.png\" alt=\"flex-wrap 为 wrap-reverse\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（flex-wrap 为 wrap-reverse）</p>\n</div>\n<p>将 flex-wrap 设置为 wrap-reverse 可以看做是调换了交叉轴的开始位置（cross start）和结束位置（cross end）。</p>\n<h3 id=\"flex-flow\"> flex-flow</h3>\n<p>flex-flow 是 flex-direction 和 flex-wrap 的简写，默认值是 row no-wrap。</p>\n<div><pre><code><span>.container</span> <span>{</span>\n  <span>flex-flow</span><span>:</span> &lt;flex-direction> || &lt;flex-wrap><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"justify-content\"> justify-content</h3>\n<p>justify-content 定义了项目在主轴上的对齐方式。</p>\n<div><pre><code><span>.container</span> <span>{</span>\n  <span>justify-content</span><span>:</span> flex-start | flex-end | center | space-between | space-around<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>\n<li>flex-start（默认）：与主轴的起点对齐；</li>\n<li>flex-end：与主轴的终点对齐；</li>\n<li>center：项目居中；</li>\n<li>space-between：两端对齐，项目之间的距离都相等；</li>\n<li>space-around：每个项目的两侧间隔相等，所以项目与项目之间的间隔是项目与边框之间间隔的两倍。</li>\n</ul>\n<p>假设此时主轴是从左到右的水平方向，下面给出了不同属性值的效果图。</p>\n<div style=\"text-align: left;\">\n  <img src=\"./assets/flex-container_justify-content_flex-start.png\" alt=\"justify-content 为 flex-start\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（justify-content 为 flex-start）</p>\n</div>\n<div style=\"text-align: right;\">\n  <img src=\"./assets/flex-container_justify-content_flex-end.png\" alt=\"justify-content 为 flex-end\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（justify-content 为 flex-end）</p>\n</div>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/flex-container_justify-content_center.png\" alt=\"justify-content 为 center\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（justify-content 为 center）</p>\n</div>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/flex-container_justify-content_space-between.png\" alt=\"justify-content 为 space-between\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（justify-content 为 space-between）</p>\n</div>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/flex-container_justify-content_space-around.png\" alt=\"justify-content 为 space-around\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（justify-content 为 space-around）</p>\n</div>\n<h3 id=\"align-items\"> align-items</h3>\n<p>align-items 定义了项目在交叉轴上如何对齐。</p>\n<div><pre><code><span>.container</span> <span>{</span>\n  <span>align-items</span><span>:</span> flex-start | flex-end | center | baseline | stretch<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>\n<li>flex-start：与交叉轴的起点对齐；</li>\n<li>flex-end：与交叉轴的终点对齐；</li>\n<li>center：居中对齐；</li>\n<li>baseline：项目第一行文字的基线对齐；</li>\n<li>stretch（默认值）：如果项目未设置高度或者为 auto，项目将占满整个容器的高度。</li>\n</ul>\n<p>假设交叉轴是从上到下的垂直方向，下面给出了不同属性值的效果图。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/flex-container_align-items_flex-start.png\" alt=\"align-items 为 flex-start\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（align-items 为 flex-start）</p>\n</div>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/flex-container_align-items_flex-end.png\" alt=\"align-items 为 flex-end\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（align-items 为 flex-end）</p>\n</div>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/flex-container_align-items_center.png\" alt=\"align-items 为 center\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（align-items 为 center）</p>\n</div>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/flex-container_align-items_baseline.png\" alt=\"align-items 为 baseline\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（align-items 为 baseline）</p>\n</div>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/flex-container_align-items_stretch.png\" alt=\"align-items 为 stretch\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（align-items 为 stretch）</p>\n</div>\n<h3 id=\"align-content\"> align-content</h3>\n<p>align-content 定义了多根轴线的对齐方式，若此时主轴在水平方向，交叉轴在垂直方向，align-content 就可以理解为多行在垂直方向的对齐方式。项目排列只有一行时，该属性不起作用。</p>\n<div><pre><code><span>.container</span> <span>{</span>\n  <span>align-content</span><span>:</span> flex-start | flex-end | center | space-between | space-around | stretch<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>\n<li>flex-start：与交叉轴的起点对齐；</li>\n<li>flex-end： 与交叉轴的终点对齐；</li>\n<li>center：居中对齐；</li>\n<li>space-between：与交叉轴两端对齐，轴线之间的距离相等；</li>\n<li>space-around：每根轴线两侧的间隔都相等，所以轴线与轴线之间的间隔是轴线与边框之间间隔的两倍；</li>\n<li>stretch（默认值）：如果项目未设置高度或者为 auto，项目将占满整个容器的高度。</li>\n</ul>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/flex-container_align-content_flex-start.png\" alt=\"align-content 为 flex-start\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（align-content 为 flex-start）</p>\n</div>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/flex-container_align-content_flex-end.png\" alt=\"align-contet 为 flex-end\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（align-contet 为 flex-end）</p>\n</div>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/flex-container_align-content_center.png\" alt=\"align-content 为 center\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（align-content 为 center）</p>\n</div>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/flex-container_align-content_space-between.png\" alt=\"align-content 为 space-between\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（align-content 为 space-between）</p>\n</div>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/flex-container_align-content_space-around.png\" alt=\"align-content 为 space-around\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（align-content 为 space-around）</p>\n</div>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/flex-container_align-content_stretch.png\" alt=\"align-content 为 stretch\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（align-content 为 stretch）</p>\n</div>\n<h2 id=\"项目属性\"> 项目属性</h2>\n<p>对项目设置属性，可以更灵活地控制 Flex 布局。以下六种属性可以设置在项目上：</p>\n<ul>\n<li>order</li>\n<li>flex-grow</li>\n<li>flex-shrink</li>\n<li>flex-basis</li>\n<li>flex</li>\n<li>align-self</li>\n</ul>\n<h3 id=\"order\"> order</h3>\n<p>order 定义了项目的排列顺序，默认值为 0，数值越小，排列越靠前。</p>\n<div><pre><code><span>.item</span> <span>{</span>\n  <span>order</span><span>:</span> &lt;integer><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><br>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/flex-item_order.png\" alt=\"order 为 -1\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（给第三个项目设置了 order: -1; 后，该项目排到了最前面）</p>\n</div>\n<h3 id=\"flex-grow\"> flex-grow</h3>\n<p>flex-grow 定义了项目的放大比例，默认为 0，也就是即使存在剩余空间，也不会放大。</p>\n<p>如果所有项目的 flex-grow 都为 1，则所有项目平分剩余空间；如果其中某个项目的 flex-grow 为 2，其余项目的 flex-grow 为 1，则前者占据的剩余空间比其他项目多一倍。</p>\n<div><pre><code><span>.item</span> <span>{</span>\n  <span>flex-grow</span><span>:</span> &lt;number><span>;</span>  \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><br>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/flex-item_flex-grow_1.png\" alt=\"flex-grow 为 1\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（所有项目的 flex-grow 都为 1，平分剩余空间）</p>\n</div>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/flex-item_flex-grow_larger.png\" alt=\"flex-grow 属性值越大，所占剩余空间越大\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（flex-grow 属性值越大，所占剩余空间越大）</p>\n</div>\n<h3 id=\"flex-shrink\"> flex-shrink</h3>\n<p>flex-shrink 定义了项目的缩小比例，默认为 1，即当空间不足时，项目会自动缩小。</p>\n<p>如果所有项目的 flex-shrink 都为 1，当空间不足时，所有项目都将等比缩小；如果其中一个项目的 flex-shrink 为 0，其余都为 1，当空间不足时，flex-shrink 为 0 的不缩小。</p>\n<p>负值对该属性无效。</p>\n<div><pre><code><span>.item</span> <span>{</span>\n  <span>flex-shrink</span><span>:</span> &lt;number>；\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><br>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/flex-item_flex-shrink_1.png\" alt=\"空间不足时，默认等比缩小\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（空间不足时，默认等比缩小）</p>\n</div>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/flex-item_flex-shrink_0.png\" alt=\"flex-shrink 为 0 的不缩小\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（flex-shrink 为 0 的不缩小）</p>\n</div>\n<h3 id=\"flex-basis\"> flex-basis</h3>\n<p>flex-basis 定义了在分配多余的空间之前，项目占据的主轴空间，默认值为 auto，即项目原来的大小。浏览器会根据这个属性来计算主轴是否有多余的空间。</p>\n<p>flex-basis 的设置跟 width 或 height 一样，可以是像素，也可以是百分比。设置了 flex-basis 之后，它的优先级比 width 或 height 高。</p>\n<div><pre><code><span>.item</span> <span>{</span>\n  <span>flex-basis</span><span>:</span> &lt;length> | auto<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><br>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/flex-item_flex-basis.png\" alt=\"不同的 flex-basis 值效果展示\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（不同的 flex-basis 值效果展示）</p>\n</div>\n<h3 id=\"flex\"> flex</h3>\n<p>flex 属性是 flex-grow、flex-shrink、flex-basis 的缩写，默认值是 0 1 auto，后两个属性可选。</p>\n<p>该属性有两个快捷值：auto（1 1 auto）和 none（0 0 auto）。auto 代表在需要的时候可以拉伸也可以收缩，none 表示既不能拉伸也不能收缩。</p>\n<div><pre><code><span>.item</span> <span>{</span>\n  <span>flex</span><span>:</span> auto | none | [ &lt;<span>'flex-grow'</span>> &lt;<span>'flex-shrink'</span>>? || &lt;<span>'flex-basis'</span>> ]\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"align-self\"> align-self</h3>\n<p>align-self 用来定义单个项目与其他项目不一样的对齐方式，可以覆盖 align-items 属性。默认属性值是 auto，即继承父元素的 align-items 属性值。当没有父元素时，它的表现等同于 stretch。</p>\n<p>align-self 的六个可能属性值，除了 auto 之外，其他的表现和 align-items 一样。</p>\n<div><pre><code><span>.item</span> <span>{</span>\n  <span>align-self</span><span>:</span> auto | flex-start | flex-end | center | baseline | stretch<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><br>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/flex-item_align-self.png\" alt=\"第三个项目的对齐方式与其他不同\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（第三个项目的对齐方式与其他不同）</p>\n</div>\n<h2 id=\"简单实例\"> 简单实例</h2>\n<h3 id=\"三栏布局\"> 三栏布局</h3>\n<p>我们首先将容器设置为 Flex 布局：</p>\n<div><pre><code><span>.container</span> <span>{</span>\n  <span>display</span><span>:</span> flex<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>接下来要将 .left 排列在最左边，和将 .center 占满剩余空间。</p>\n<ul>\n<li>order 属性可以改变项目的排列顺序；</li>\n<li>flex-grow 可以定义项目的放大比例。</li>\n</ul>\n<p>利用这两个属性便能解决我们的问题。</p>\n<div><pre><code><span>.left</span> <span>{</span>\n  <span>order</span><span>:</span> -1<span>;</span>\n<span>}</span>\n\n<span>.center</span> <span>{</span>\n  <span>flex-grow</span><span>:</span> 1<span>;</span>   <span>/* flex: 1; 也行 */</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>示例如下：</p>\n<iframe height=\"257\" style=\"width: 100%;\" scrolling=\"no\" title=\"css-flexbox-三栏布局\" src=\"https://codepen.io/winyuan/embed/GRqOZgd?height=257&theme-id=light&default-tab=result\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href='https://codepen.io/winyuan/pen/GRqOZgd'>css-flexbox-三栏布局</a> by wenyuan\n  (<a href='https://codepen.io/winyuan'>@winyuan</a>) on <a href='https://codepen.io'>CodePen</a>.\n</iframe>\n<h3 id=\"居中问题\"> 居中问题</h3>\n<p>当子元素的高度不确定时，处理垂直居中就比较麻烦，但是使用 Flex 布局中容器有关对齐方式的属性便能快速解决，以下代码子元素在父元素中是水平、垂直居中的。</p>\n<div><pre><code><span>.container</span> <span>{</span>\n  <span>display</span><span>:</span> flex<span>;</span>\n  <span>justify-content</span><span>:</span> center<span>;</span>\n  <span>align-items</span><span>:</span> center<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"浏览器兼容性及其他\"> 浏览器兼容性及其他</h2>\n<p>设置为 Flex 布局后，子元素的 float、clear、vertical-align 属性都将失效。</p>\n<p>因为历史原因，W3C 对 flex 做了多次更新，也就导致了各浏览器支持度参差不齐。到目前为止，Flex 布局有以下几种写法：</p>\n<div><pre><code><span>display</span><span>:</span> box<span>;</span>                   <span>/* 2009 version 老语法 */</span>\n<span>display</span><span>:</span> flexbox<span>;</span>               <span>/* 2011 version 过渡语法 */</span>      \n<span>display</span><span>:</span> flex | inline-flex<span>;</span>    <span>/* 2012 version 新语法 */</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>从 <a href=\"https://caniuse.com/#search=flex\" title=\"Can I use flex?\" target=\"_blank\" rel=\"noopener noreferrer\">Can I Use</a> 上可以看出目前 Flex 布局对浏览器的支持情况。从中我们可以总结出新语法目前的支持情况：</p>\n<ul>\n<li>Chrome 29+</li>\n<li>Firefox 28+</li>\n<li>Safari 9+</li>\n<li>iOS Safari 9+</li>\n<li>Android 4.4+</li>\n<li>IE Mobile 11+</li>\n</ul>\n<p>更低的版本需要加上前缀进行支持，不同版本所在时期不同也会导致属性值不同，这里有一个推荐的兼容性写法：</p>\n<div><pre><code><span>.page-wrap</span> <span>{</span>\n  <span>display</span><span>:</span> -webkit-box<span>;</span>      <span>/* 老语法 iOS 6-, Safari 3.1-6 */</span>\n  <span>display</span><span>:</span> -moz-box<span>;</span>         <span>/* 老语法 Firefox 19- (buggy but mostly works) */</span>\n  <span>display</span><span>:</span> -ms-flexbox<span>;</span>      <span>/* 过渡语法 IE 10 */</span>\n  <span>display</span><span>:</span> -webkit-flex<span>;</span>     <span>/* 新语法 Chrome */</span>\n  <span>display</span><span>:</span> flex<span>;</span>             <span>/* 新语法, Spec - Opera 12.1, Firefox 20+ */</span>\n <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>（完）</p>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T07:36:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "浮动（float）",
      "url": "https://www.fedbook.cn/frontend-knowledge/css/float-property/",
      "id": "https://www.fedbook.cn/frontend-knowledge/css/float-property/",
      "content_html": "<h1 id=\"浮动-float\"> 浮动（float）</h1>\n<h2 id=\"float-属性的取值\"> float 属性的取值</h2>\n<ul>\n<li>left：元素向左浮动</li>\n<li>right：元素向右浮动</li>\n<li>none：默认值，元素不会浮动，并会显示在其文本中出现的位置</li>\n</ul>\n<h2 id=\"特性\"> 特性</h2>\n<ul>\n<li>浮动元素会从常规文档流中脱离。如果其兄弟元素为块级元素，该元素会忽视浮动元素并占据它的位置，但内部的文字和其他行内元素都会环绕浮动元素；如果兄弟元素为内联元素，则元素会环绕浮动元素排列。</li>\n<li>不管一个元素是行内元素还是块级元素，只要被设置了浮动，那浮动元素就会形成一个块级框，可以设置它的宽度和高度，同时它的 margin 值也可以设置 top 和 bottom 了。</li>\n</ul>\n<h2 id=\"浮动元素的展示规则\"> 浮动元素的展示规则</h2>\n<h3 id=\"规则\"> 规则</h3>\n<ul>\n<li>浮动元素在浮动的时候，其 margin 不会超过包含块的 padding<br>\n（PS：如果想要元素超出，可以设置 margin 属性）</li>\n<li>如果两个元素一个向左浮动，一个向右浮动，左浮动元素的 margin-right 不会和右浮动元素的 margin-left 相邻</li>\n<li>如果有多个浮动元素，浮动元素会按顺序排下来而不会发生重叠</li>\n<li>如果有多个浮动元素，后面的元素高度不会超过前面的元素，并且不会超过包含块</li>\n<li>如果有非浮动元素和浮动元素同时存在，并且非浮动元素在前，则浮动元素不会高于非浮动元素</li>\n<li>浮动元素会尽可能地向顶端对齐、向左或向右对齐</li>\n</ul>\n<h3 id=\"详解\"> 详解</h3>\n<h4 id=\"_1-浮动元素在浮动的时候-其-margin-不会超过包含块的-padding\"> 1）浮动元素在浮动的时候，其 margin 不会超过包含块的 padding</h4>\n<p>这句话的意思是，浮动元素的浮动位置不能超过包含块的内边界，它的活动范围是父级的 content 区域。如下例所示，橙色方块设置 <code>margin: 0;</code>，但由于它的父级元素设置了 <code>padding: 10px;</code>，故橙色方块始终与左边有 10px 的间距。</p>\n<p>如果想要元素超出，可以设置 margin 属性。即如果给橙色方块设置 <code>margin: -10px;</code> 与父级元素的内边距属性对冲，那么橙色方块就可以与左边界贴边显示。</p>\n<p>示例如下：</p>\n<iframe height=\"278\" style=\"width: 100%;\" scrolling=\"no\" title=\"XWKMRZG\" src=\"https://codepen.io/winyuan/embed/XWKMRZG?height=278&theme-id=light&default-tab=result\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href='https://codepen.io/winyuan/pen/XWKMRZG'>XWKMRZG</a> by wenyuan\n  (<a href='https://codepen.io/winyuan'>@winyuan</a>) on <a href='https://codepen.io'>CodePen</a>.\n</iframe>\n<h4 id=\"_2-如果两个元素一个向左浮动-一个向右浮动-左浮动元素的-margin-right-不会和右浮动元素的-margin-left-相邻\"> 2）如果两个元素一个向左浮动，一个向右浮动，左浮动元素的 margin-right 不会和右浮动元素的 margin-left 相邻</h4>\n<p>这句话的意思是，两个浮动方向相反的元素是怎样都不会接触在一起的，但根据包含块的宽度大小，会有两种情况的表现。</p>\n<p>情况一：当包含块的宽度大于两个浮动元素的宽度总和，此时两个元素一个向左浮动，一个向右浮动。</p>\n<p>示例如下：</p>\n<iframe height=\"274\" style=\"width: 100%;\" scrolling=\"no\" title=\"css-float-demo-2\" src=\"https://codepen.io/winyuan/embed/LYZWyMp?height=274&theme-id=light&default-tab=result\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href='https://codepen.io/winyuan/pen/LYZWyMp'>css-float-demo-2</a> by wenyuan\n  (<a href='https://codepen.io/winyuan'>@winyuan</a>) on <a href='https://codepen.io'>CodePen</a>.\n</iframe>\n<p>情况二：当包含块的宽度小于两个浮动元素的宽度总和，此时后面的浮动元素将会向下浮动，其顶端是前面浮动元素的底端。</p>\n<p>示例所示：</p>\n<iframe height=\"274\" style=\"width: 100%;\" scrolling=\"no\" title=\"css-float-demo-3\" src=\"https://codepen.io/winyuan/embed/wvWJdNy?height=274&theme-id=light&default-tab=result\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href='https://codepen.io/winyuan/pen/wvWJdNy'>css-float-demo-3</a> by wenyuan\n  (<a href='https://codepen.io/winyuan'>@winyuan</a>) on <a href='https://codepen.io'>CodePen</a>.\n</iframe>\n<h4 id=\"_3-如果有多个浮动元素-浮动元素会按顺序排下来而不会发生重叠\"> 3）如果有多个浮动元素，浮动元素会按顺序排下来而不会发生重叠</h4>\n<p>这句话的意思是，下一个浮动元素会紧贴着上一个浮动元素的 右 / 左边界，如果同时向左浮动，那下一个浮动元素就会紧贴上一个浮动元素的右外边界，反之亦然。</p>\n<p>如果下一个浮动元素被挤到了下一行，那它的 左 / 右外边界就会紧贴父元素的 左 / 右 内边距。</p>\n<p>示例如下：</p>\n<iframe height=\"271\" style=\"width: 100%;\" scrolling=\"no\" title=\"css-float-demo-4\" src=\"https://codepen.io/winyuan/embed/mdEWmom?height=271&theme-id=light&default-tab=result\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href='https://codepen.io/winyuan/pen/mdEWmom'>css-float-demo-4</a> by wenyuan\n  (<a href='https://codepen.io/winyuan'>@winyuan</a>) on <a href='https://codepen.io'>CodePen</a>.\n</iframe>\n<h4 id=\"_4-如果有多个浮动元素-后面的元素高度不会超过前面的元素-并且不会超过包含块\"> 4）如果有多个浮动元素，后面的元素高度不会超过前面的元素，并且不会超过包含块</h4>\n<p>即：浮动元素的顶端不能比自前所有浮动元素或块级元素的顶端更高，如果多个元素浮动同一个方向，他们的顶部都是对齐的。</p>\n<p>示例见上一条。</p>\n<h4 id=\"_5-如果有非浮动元素和浮动元素同时存在-并且非浮动元素在前-则浮动元素不会高于非浮动元素\"> 5）如果有非浮动元素和浮动元素同时存在，并且非浮动元素在前，则浮动元素不会高于非浮动元素</h4>\n<p>这条规则是显而易见的，示例如下：</p>\n<iframe height=\"270\" style=\"width: 100%;\" scrolling=\"no\" title=\"css-float-demo-5\" src=\"https://codepen.io/winyuan/embed/yLJMbrG?height=270&theme-id=light&default-tab=result\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href='https://codepen.io/winyuan/pen/yLJMbrG'>css-float-demo-5</a> by wenyuan\n  (<a href='https://codepen.io/winyuan'>@winyuan</a>) on <a href='https://codepen.io'>CodePen</a>.\n</iframe>\n<h4 id=\"_6-浮动元素会尽可能地向顶端对齐、向左或向右对齐\"> 6）浮动元素会尽可能地向顶端对齐、向左或向右对齐</h4>\n<p>这条规则是显而易见的。</p>\n<h2 id=\"重叠问题\"> 重叠问题</h2>\n<p>重叠问题是指两个元素在同一个位置，会出现上下重叠的问题。将浮动元素的 margin 属性设置为负数就会发生重叠。</p>\n<ul>\n<li>行内元素与浮动元素发生重叠，其边框，背景和内容都会显示在浮动元素之上。</li>\n<li>块级元素与浮动元素发生重叠时，边框和背景会显示在浮动元素之下，内容则会显示在浮动元素之上。</li>\n</ul>\n<h2 id=\"父元素高度塌陷问题\"> 父元素高度塌陷问题</h2>\n<p>一个块级元素如果没有设置 height 属性，其高度是由子元素撑开的。如果对子元素设置了浮动，那么子元素就会脱离文档流，也就是说父级元素中没有内容可以撑开其高度，这样父级元素的高度就会被忽略，这就是所谓的高度塌陷。</p>\n<p>解决父元素高度塌陷问题就需要清除浮动。</p>\n<h2 id=\"清除浮动的方法\"> 清除浮动的方法</h2>\n<h3 id=\"方法一-给父元素定义高度\"> 方法一：给父元素定义高度</h3>\n<ul>\n<li>优点：操作简单</li>\n<li>缺点：高度被固定死，只适合内容固定不变的模块</li>\n</ul>\n<p>原理：给父级元素定义固定高度（height），能解决父级元素无法获取高度的问题。</p>\n<h3 id=\"方法二-使用空元素结合-clear-属性\"> 方法二：使用空元素结合 clear 属性</h3>\n<ul>\n<li>优点：浏览器支持好</li>\n<li>缺点：页面中会凭空多出很多无用的空节点</li>\n</ul>\n<p>原理：在父元素的末尾添加一个空元素（作为最后一个子元素），例如 <code>&lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt; (.clearfix { clear: both; })</code>，利用 CSS 的 <code>clear:both</code> 属性清除浮动，让父级元素能够获取高度。</p>\n<h3 id=\"方法三-让父元素也一起浮动\"> 方法三：让父元素也一起浮动</h3>\n<ul>\n<li>缺点：无法解决实际问题</li>\n</ul>\n<h3 id=\"方法四-父元素设置为-display-table\"> 方法四：父元素设置为 display: table</h3>\n<ul>\n<li>缺点：会产生新的未知问题</li>\n</ul>\n<p>原理：将父元素属性强制变成表格。</p>\n<h3 id=\"方法五-父元素设置-overflow-hidden-或-auto\"> 方法五：父元素设置 overflow: hidden 或 auto</h3>\n<ul>\n<li>优点：代码简洁，不存在结构和语义化问题</li>\n<li>缺点：无法显示溢出的元素</li>\n</ul>\n<p>原理：这个方法的关键在于触发了 BFC。在 IE6、IE7、IE8 浏览器中还需要触发 hasLayout（{ overflow: auto; zoom: 1;}）</p>\n<h3 id=\"方法六-父元素伪元素清除浮动\"> 方法六：父元素伪元素清除浮动</h3>\n<ul>\n<li>优点：没有额外标签，代码量也适中，可重复利用率（建议定义公共类）</li>\n<li>缺点：稍显复杂，但是理解其原理后也挺简单的</li>\n</ul>\n<p>原理：IE8 以上和非 IE 浏览器才支持 <code>:after</code>，原理和方法二有点类似，<code>zoom</code>（IE 专有属性）可解决 IE6、IE7 浮动问题。</p>\n<p>将 clearfix 类名加到浮动元素父级盒子上：</p>\n<div><pre><code><span>.clearfix::after</span><span>{</span>\n  <span>content</span><span>:</span> <span>\"\"</span><span>;</span> <span>/* 伪元素没有这个属性则无法生效 */</span>\n  <span>display</span><span>:</span> block<span>;</span> <span>/* 只有块级元素才能清除浮动影响 */</span>\n  <span>height</span><span>:</span> 0<span>;</span>\n  <span>clear</span><span>:</span> both<span>;</span>\n  <span>visibility</span><span>:</span> hidden<span>;</span>\n<span>}</span>\n<span>.clearfix</span> <span>{</span> *<span>zoom</span><span>:</span> 1<span>;</span> <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"方法七-父元素双伪元素清除浮动\"> 方法七：父元素双伪元素清除浮动</h3>\n<ul>\n<li>优点：代码更简洁</li>\n<li>缺点：由于 IE6、IE7 不支持 <code>::after</code>，使用 <code>zoom: 1</code> 触发 hasLayout。</li>\n</ul>\n<p>原理：同上。</p>\n<div><pre><code><span>.clearfix::before,\n.clearfix::after</span> <span>{</span> \n  <span>content</span><span>:</span> <span>\"\"</span><span>;</span> <span>/* 伪元素没有这个属性则无法生效 */</span>\n  <span>display</span><span>:</span> block<span>;</span> <span>/* 只有块级元素才能清除浮动影响 */</span>\n<span>}</span>\n<span>.clearfix::after</span> <span>{</span>\n  <span>clear</span><span>:</span> both<span>;</span>\n<span>}</span>\n<span>.clearfix</span> <span>{</span>\n  *<span>zoom</span><span>:</span> 1<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id=\"浮动的应用\"> 浮动的应用</h2>\n<ul>\n<li>文字环绕效果</li>\n<li>横向菜单排列</li>\n<li>布局（三栏两列等等）</li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T07:36:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "盒模型",
      "url": "https://www.fedbook.cn/frontend-knowledge/css/box-model/",
      "id": "https://www.fedbook.cn/frontend-knowledge/css/box-model/",
      "content_html": "<h1 id=\"盒模型\"> 盒模型</h1>\n<p>盒模型是 CSS 的核心概念，描述了元素如何显示，以及元素之间如何相互作用、相互影响。</p>\n<h2 id=\"边距和边框\"> 边距和边框</h2>\n<p>在网页布局中，我们可以将 HTML 标签看成一个个矩形盒子，盒模型就是用来描述这些矩形盒子所占的空间大小。每个盒子都包括内容（content）、内边距（padding）、边框（border）和外边距（margin）。如下图所示：</p>\n<div style=\"text-align: center;\">\n  <svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"350\" height=\"275\" viewBox=\"0 0 350 275\">\n    <image id=\"wenyuan_box-model\" data-name=\"wenyuan_box-model\" width=\"350\" height=\"275\" xlink:href=\"data:img/png;base64,iVBORw0KGgoAAAANSUhEUgAAAV4AAAETCAYAAAB+7W6oAAAgAElEQVR4nOydB5wkVbX/f7equnty3JnZHNgM7JKWIDkLKiAqiA9FnxEVA2L6m8VnVlAxgOmhiAo8URbEACxRkRyWhV02p9nZCTu5c9X9f86tU7M1vd0zPd01Mzsz97uf3p6urrp9u/r2r0+de+45YuXF1yMt05ACi0IwfwJA8s0SwNUO5Etp2DBgXGbB/LCE7AZQCmCLgHyfDYk0HIRgft+AcYyE7ANQBeD3gLyRngMw14J5IwATgA0gIoBPO5DPcNsXWzCvlpA9AEoANAvI99qQSW77GwaMkyRkL7d9JyB/QM9JoCkE85cAwtx2qQA+70D+m9s+34T5Wbj9on06BOR7bMh+Ot6C+WUTxpm+tv8KyG+7bcvaECxquxJAGkAZgK9KyAfdtsWZJqwvAjLKbfdw213c9mdNGK/j90Vt3A/Ir3Hb5RasXwmIekAmAVQA+AYg/5Fy2z7ZhHUtION83uICoHPSRq9twfyECeNi/jyo7UcA+UX6PBw4YW57BiAT7vPyewBWU9sC4jgL5jcBJLjttADeb0Pu5rY/bMK4jNumfj0pID+ddtsWFqxfCoj53Ddq+wYAd/BnvdKC+X0+X4LGkgA+aENu47bfa8J4J7dN5/MFAXk1tw0L1o0GxBIJGeO2fw7gd9z2cgvmD/lzJgwBfNSBsyHlnu8rTBjv843RDQLyQ3RObPf5HxkwVkjIfvezljcD+DW3vdByxz984/8TDuRaHkdvtWBe5Wt7K49Rb/x/z4Cxyjf+/wDIn3HbcyyYN2WM/884kE9z2xfR58ljkMb/Hh5H3vj/ugHjZN8Y/TMgr+dx1MhjNOKNfwBfkJD/4rbP4/Hf7xv/1O8+HqNfMmGc5Wv7XkB+i9uucdsWdK688X+thFzD4/8ME9aXePyHAPRy253c9mdMGK/3jf8HAHktt13GY3Sab/x/E5B/5/F/kgnra77xn+Dx38rj6GoTxpt84/8xQH7eN/5pjM70jX8ak3fROBHAKgvmtzPG/wdsyF3c9odMGG/jtssBPJUx/n8hIBb4xv+PAdw+xPinMbiV2/6oKYzzaXAtNiB22tJulYbxAwHhCa8pHewGfyGEEE9CqC9DTJ1kKbulFOpZdRPG7RDyIX4zJZByI7Ui3X/7YKgvjAGo3lnSwXZf289CKGGIc9t9Uoq0r+07IeTjXttSys1if9s9MMwfUZvcdkg62Oxre60Q8nvSPdaClDEpRcJrG8JYDSGf49emtrftb9vpl4b8qYAIc9thOFjvPksfgbHeEvL7EkipD1DKhJQi6mv7bxDyZa9tSLkT6pyp4xMw5E0CKJX8ZYSDddJrG8ZGy5DXcdt03tLSQa96bUHti39CiM38eUQgZbPbthp6aRjylwKokO4AoLafdxWF3oaxFQau48FBbdvSQaf3vqQQayDELl/beyW3TT2DIW8WQJWv7bVQJ4gGtdgFA9ezCAj1mg46fG0/CiHauO0wpGzPaPsWALUAkuqcOXjZa5sECYZ5PY9PQkgHLZLflxTicQjR7Rujnf62pTD+ACH/OdC2xHpqidtug2H+wCe8NP53+cbRUzxGvbZ7soz/h0cw/rf52n4eQglDrvH/Zwj5H9/43+Iboz0wcIN//MPBJl/bLwl3jCZ5jGaO/7sh5PO+8b9d7B+jUWnInxlAhMdoPuO/HwP9Fn+DEK/kGP9JGPLnGeP/Jd/43zTM+L8PQmzxjdE9GeP/Vxnj/4X9419syxj/Tsb4fxBC7M4x/iUM+ZuRjH84aKd2baRhCHG/CWMeWbxPOtJ+r4T9omGYdCAGcIRqLIU4TGEhJMKqawNDUwqk1b8kwiICU5iDnpfqrCXVg7ARwSAG2k6o40bStuSfBnpOFtg2nYTUMG1TG9R29nOSgCEMdXy+bbvnhN5XYqBtA8b+5/1tw1DPDzzHz9uw1fP0nixhZWmbftPTWdp2u5dEXG0PGeEDztlQbYPbtodom46lczVabRPZP2sbyWHbTiGUc4wO1XZh498bR6M//mkclYy47aHHf55jdJjxn3uMjuf4p7ZHb4xmG//SEfxDlYZJ/4R1pQX3F8VR4iIHNDoDkesJptDncJC3Xezz49F2EK99sLZd6LFBtH2wjv+JOEan2viX6kcqJEq8K6D13uWJOkBKV8GFIeD/odFoDmaEMPL4wmg044vjSS3wkMXOY2NAm6VyHg2+vNZoRoiUDgwzBMOKwDRK4Vgm7GgLZCoNmJZ63gyVQggTVrgKIt2HdH+rbyS6bYTClTBLKmFH98JORvc/T+NUCITL6mDLFNJOP5BIHKi/9DrhEjUFhpStjuEnyP8JM1QGR4TgpOJ8Tem9APlHLYTLaiHtPsh4v9Z2TcGIjLFDwnsFRSj4N5L4isw9NZp8UGPHQKSyEelEP1LRTvTsewnRnt2oPORYRMrrYaRSiFTMQKJnD1KJKNo3Pgyzsh5Vc4+G09fhhhSUVCJUUo3elg3o2nAfKucfhXBFPWS0B8KwEK6YBmGY6Nr5Ato2rkHZjGWYefgFSHfvhXTSaqRLx0a4rB7Rvj2whY2ymgUwHMf1zRkGZDqNaOdOpGQSkaomRErrIO20epPCDMFOxNCx+VGgrBx1c1bBcoBkdB8cJw3h/4XQaIbAMA7Q0jIS3peGP2na76DJDQmcGakAwhUwrQhC0kDXzufRsu6v6G/fAsdOqmO7dj+PZa/7EiyrDHteuget6+9DMtoJaafU84ec+yk0LjgZSCUQ7dyBPWvvRuuGB2CnYijd9TQWnftZVE4/FOl4L3r2vIS9G+5H57Yn3bZ3PouS0lo0Lj5DCa/qU7gCvXs3YvMD1ymxrGxaAiflTnaRaDt2Cr1716sfi9L6+a51m3b7SpY69a2/fbN63D13FaYtOAG1845VxyZ62iAdR1vBmpwM4TV4q5V1s3TjK7wD9a+7JhfKqqyYhkR/B/ratisR7dz0LyWMmcQ6tuHVe7+mhKuvbdMBz2+97zqkj2+DTMXRvHa161pgYh3bsfHea1E7dxXi3XvQuePpA47f8vBPsG/L4wiV1sCxEzBD5ejc/iRSsS71fOf2A4/xiLZvQTTns0DXjqfVrWrGoWhcdi5qZh8FyypHIt0Pu38Pi7Cpx4lGMYyrNuy5Gv6m4hgz4Jg3GNADSpMB+VgNgbL6+Yh3t2DTQ9cj3t087Fnq79ia8zkpbez4z805nyfBJSt4KMjyHU169rysblUzDkfFtMVwhIO6ZWfCMkKQieiBzjzNlMELL8tjfixFwvs1AOuyCa93HWWwxSu1y0Hj8+E60lZW5PYnbkait3VKnRqy6D2rPta9G4vO+Bis0lrEe1qUWwP6KnHK4KliWITzDUqotHhiLT7srrxSRk+6TVGkA6u0EmYoTEtY0bXrObS8/I+sLoWpRvf2p7H+nq9g5sqLUD37CNBCpHhvh/uNVCKsDZbJjlDr113PQB4G6t0kvPUc3TAsXpwvzdJJPZamDOTHDZXWo69zC9JOArtefRid25/K9+3P5nX8O3w5FjxoydUSADvJBVvg+TySFwGtG8/PgybhNq65DlUzDkPjsrNRNf1wODatVBJIJ3rHs2uaMWIEHoEtJLgv0txCvkeQ+NLSPM3UgGJpI9Uz0Ne6CZvu/46KBBgh9wA4AsAsSn6UcejxFExOiVcAfDlLsw08Pp8A8MYsz9NAfI5Fu26Ybi3jflTycbROmJK33M3HLve1mfkNEnxV+ORw5mvPnnXqVlozWx027fDzUDf/eMj+Lu3/naTQxzpSTwAJ79tHejoG4ny11TupcSMW6mEYBrb9++eFiG4li922LKILzqgFtnyzkWDBuwjABwH8LGMfbwTmYzhcA+C9WbaTNX4pgB/n0UaYrethiXXtUrvsff4vqJ61AqYVGogR1kwelE935L+ni/NyMWSiTGqp17ZNZkh0yWqjsKytj92EeM+eQt7tG/j+NgA1nLIQbEE2c/YnsMBmgyzSVQBaAPwUoKxz+Cevtkz52ouyEWH51g4bnH3Ka7uKl8fX8P0lAP6X0wKW8z5XAWjNMjMW4r6MWDmTfW3o2b0WjQtOQrK/Y6SHaw5iilDANxQkvO5Em8MLLMVA1EPQcEKJIboxtMk93LHFPj8+bRf/2kO2LW0IowQV0w7Bvh1PY/uTv0Wsc2fOY4bhffz0Z/jmQUJ5KPt9MczlO6nVh4CBVHsfZBH2sziLJUpROo8CeDM/NjgdpOdwfdW33YuX/AlGAVoabZVUIdHXxnkl/Oe82M/yYByjB+/4L5aA2u62+PLtu5nLhvOFVN8cpThfUxiQ0sz+ZgXU69rSdqMtMn591Dr8IfpFqfBokchQbec6x2PStsz4kKXXtoAjc7yvgbazNy5yvbavbUkpBoXErufvwI6nfp/zPeYBOTnPACjvMiWuV0m0STjPBbCIX9XLGjLc7NMv+EZUA/gTiyhZqheyyP6TXQFpvifBXeprI8EiO5Mt7cN4uzPaYQft6x9AaVmdyivhd9fkM47kMOPI9qKNDsLxn/3gcRr/wgsOyJmCMQ9cI1PwvyJEWC2gOB3AzwttwfvQi+yIe66886Gyq0l1EimdWuavmOfHtmCp5w8w+Q2pvmFhlbc5Y3Bx2yrfJ+cpzdW2mW0lUhFtu+4gOajtQc/72xYZAzfvtk33ByvzeTa0hmu7rLQOvXtfKVZ0iW/x/ftZFD1+z8K7kye8wL7XkFuBYBCVXvUBn1viTr550Jv8B4B3ZBxL2/t9j5MsyJTguotdDmBL2RP+u/lv74M32MXQyn3rKeRE9O5Zh5Z1FVh46oeR6G/nxSfDjyOTPpFhxiiFMB0gI0WP/zzH6AQa/+7kl8MrDI0R6RVnKkbIsAYCwIq0fKMW+8+SxbQCX6hZvrN7nmCHaX5lIEb4wH0whC+Fnh+UkHjQc+7/Qx07XNu5PpyJ0HYuhnqenrMTvahsWIyKhsXoa9uYs51hoCiBy1mw/pmx64U+K7OMty11yx7hJFrHzoIZ9gmdza6BYzPE9Hi+zwxF80S1y7ftUa5s8Qf2Od8H4Ovcl1re5w38Wp7wpvgHgbixUOGtnnUE5r/mPUjFugdZY0F81sYEHqPjMf4FizKVOyPxJ72SYx8bexv9wCzwzS4XhRtqNtI3UdwU3QTw50yotulS2CqtQt2C4/PYOyde9MFHqN6YL058CbsH1vBjT3hp9SSVxnk9x+MezcYAbf8++4SXZ5n0OorvX83Y7k2Wdfu2PQLgMqqNxY8fBPAw/z2T7+dyX02+kfhf552aQk5EzewjseTsT6q/7XRs2P1Hih7/hbVNwpt0kspVieImygohYfDALmjKOhuZwnvAJYFUi6AG7aE5iBBCTQLVzT9B+SQL4DwOzyJx/Q9PoD3NEQhelMMtfO8JMl3+fxxQtcPmAXgGwAcAfAnAJ91ChlkHy1V8/7eM7Z7w+i3edTxB5zEtyyD01j07PqH1i/eIINFdfNY1sJMxpOJdKvew5uDAs7hTTsq9qVJfdlYBFtlTOxaFwYM9MOHNxOR/kgVXr3g7+LFTcZjhUiw7/wsoqZk10v56k1Yfo3klAP/HsbwbfZENq/neGw3z+P6jAL7Cfx/qa7MMB7KYX6uZw8z8VPDf+3zbIr7wM3KvXc2i+hbf8dniiXPFGA8JuReWnPVJlWFNi+7BiTc35SjJtTkpmMv+zIxiNNIknFVYONkwOI6XUlIoRzqyWMKagxfygyX7OhCpmIZDX/dlND//Z+x95R9qhj0PbuaJMC+JwyV88y7xf51hiSIjPvarvJrtkSwv5Xc1eO19Ict+XrVB/+vEfHMZJKbr2e+7w+dq2IH9VW29ftXxfd4DuHr2kVh69qeQTvQhFe/RonuQ47dyhSq57Vq+gwpeBstKi62NliGC2AtiKAe6ZgIMRkr23d8BK1yOOcdejvpDTlRJyds3P6oWVwxBR5Y42zs45Kshx9LgTB7Osd2b3LqRczSs5UUQmVzKj3OFSNaw2+FafnwJ37/Mk3eeQULfiRPZgs4rWL12ztFYdObVPtHVWcomGqRZSZl0Q2VFjnDW4lBxvH/kkJ+1U/2EawZDomGnoupWUj0Th5xyJRqXno3WVx9Q5XrytIDBPtoGnizbVcBpjvEE2zIWzPPYmn0dP/9lzuWwkZM+ncnb1wzRpt994bkmXpNlv/kATsieNnU/VF+uYcmZmH30Jexe6NaW7gTFs4AHIh+CNyCrrdGa3dILiicL7ueYinWq+mkl1TOw6LSPoHbuMdj44A8HyvYMwW0cJvYUT5aNlFL2EdscPnYe+2TP8Yl4KVvAR/Jjmqz7MPuY/XhhZ94ii8M4esELUatni93PNr7lxIyUY8mZn0D1rCMR72lWk2l0xaCZuHi+XxLfkAgFLbwvGiP1X+WPFt7JhUrBpAQ43tuKsto5qgrvEJRyZrJLOdzr3AJOxxLOTjaDF1PQ5NvnAKygSkG+/T7rhdjzjVbN3eV7fjb7bs/lsDWLJ9fID/0pymXD+xUUwUA15UqqZrhJ0NMJLbqTBBLflEypW8CG5AMW+7sCHinarzV5cbMxkQ/TyR2XSj7T73FcLLmwTssyoTYcJRwCRmP0XWyV3sExvh/gibA23wq1Dv47wpZrI7sQHuBjqjju9yhOJfkC+4DJR/wJ7svzGSvXPAxumzL5bcjsd8W0RarysZOKaYNjEuIJb5D+XhrU/w3gwMqDRaCH3uTGScVV6fWZK9+ooh3s1AEC/BUW3V9yUptcWb08P2t9lueSHAdMS4t/w9uWcsIcWmhxSp4nmaIffsSxwfezBZ3pTqAIh2c5umF6litAT3jDGdtRPWslFp56lUoupNwuOufupGKUAgTCYuXF16vaWcF4G0RRJrmeAJ4gSLc8Ok24Rfdtx65nbkPnzmf8fV/Cftk7/Bsrpi1EX/vmzP2u5fwNq7O8+WxJyf2EfPt5o8fxLUk28s2fO1LKGxZh+vJzVdVjWu1Hy4G1i+HghXSJwsQKcRuQ8FJ+iAAt3isCFV4x4GIr8HgtvBMKimoIl9bAsCLobl6L1lfXoGvHIAFW4Wj1i05BzawjVFkcKsveuv5+9LS8fMBbLZ+2ENMPPQ/Rzp3KkiZ/KVFSNV2JWqxrdyCnh9qjVI004Kgsz0gKdVY0LFGlfWhy0QyVqFV+JLw6bOzgpljhpZwwESMSlPBeScL7VkfaDwAycwZ4xGjhnYLQwhiqOlwxTV1m9zSvxe4X/qJ8wPXzT0Dt/GOVoNqJfiRjnYhUNEI6KXTueBat6+9Tohcqq0Xj0jPUMmUrUqmWOPa2bUTbqw8iVFKFpuWvVSJPwhvv3q2EOV/ohyFc0QDDCsMww6q/ZdMWKNF0w+US6Nj8iJowHI6yunmYtvAULbgTkGKEF+oSykFERIKyet9NwrvNkfabAflMHgcMiShyUk2P4QmMSnVoIFI+TcX9OumkErxUrEuJsLvsUrhuCtNS+6WT/Srm1QiVKIFN9LWrCAHaL1RSqUSYBDcVdVf+UtiWYVgQRijv86R8r47tZe9XkJXrLQKhvpC/WhjDL+KkH4xktJN9uXqwTiSKFV5l9ZKBISIDj4vgaovDcoYv7z4selJhSiNcUSXLkRYTkNCSdaqGvF+kKA2fYyPWs8fdz7SU2Ma796jnvH1JrOnmx4mONDBieGQ6qazXEaFFd8JSjGAq4UZKxfUWyT0W5yItOmeDIYpzMwBYKPZnj9LrjCcoyrJ1bM7zn1ug1KouhxNT8yo5jWa0EBBhAfGYBfPrxegUVdagJO258oDnyUaLg9sDSBRatMXbCIgLiu+HRqPRZKIirqaZRQqvJ7bF+nktzvh/MFiYgSbp0Wg0mgz2FCuYosiQWWaBUbzoSq4yrH28Go1m8uKWJwtEeC8MwLHmrezQblmNRqPJg16Dk4YsKOZs6Zy7Go1GkzchEt7zfVVZNRqNRjO6JA3OXVp0eXeNRqOZzKiEOVIGcYWvyrvPD6q8u0aj0UxmHP5XJFES3p9wzTWNRqPRDEFA4WQqDux7XCK7QGTRyXE0Uw/HkVkrTwtO+5BM2bBtZ9j0thTeQ/tF4ynV5iiU4tZoFF6+BqP4Qg+nBVLeXddX0+SLZRro6Y+joyuG6ooI6qrLkLb3X7qRcDqOg0QqDcswEAqZWQV6AJUbWKAkbA2INO2fSud3OWiaQvVpqJfQaALmGIPrWR2QWT9/3KJwOo5Xkw9dvTEsmFWHG790MY5fORdbdu2Dae63IDq6opg3owb3/OS/8eH/OhG7W7uHFN7drT04+4RFuOen/41lCxqxd18fbEcimUoPe0ulbaTTjjYcNGNNl8VVYD/Ehf80mlGlszeO+TPrcMlrV+LkoxfgNZf/GHvb+9BQV65cBv3xJCrLI1h+SCOa23rQ15+EUyv3JwSTrlXsWbfxRAoNtRWYO6NGHdfS3ImTjpyHL155FqbVlKO6skSJazaozVtWP4uv/PQ+zGyo0m4KzVihyruHtYNWM1bMbqzGbX9/AWe9ZiEufe0R+M3X34p3f/EO7NjTpXxonS1daGnvVb3ZvKMD0d2d2BUy94uiAKrLS1BfU4ZtzZ3o3dmBHS1uusgdezohNzQjfOExWLlkBvpjSWza0YHSkuxp/MIhE9FYEqahM6NpxpSXLU5OU3R8hEaTD6YhUFtVio9/826cvmohTjv2EBy6sBGHLZqOc09crCbJptWWq5bOP2Up/nzrh1BRFoEhgGTaVmL68FNbcNeal/Hxd5ys2jvmsNlq//dfcjxWLZuFadMq1ePP/eDv+NG3VgNN1dl7JoA5c+oxb0at8ilrNENBLilKC+kW2i7KVv0HCe80X9FAjWZUcaREbXUpdrZ04apv/AXzZtbiPy/swBc+cJby+fqZM71G3TJJJm389q5n8IkrTkVZ6f6h+5ZzV6rbv57fpibLyKK9+vNvxIlHzlPCTW6OdNpWE3qUP5r6ctMdT2Dr7n2oLNOh7Jrhkfyv2HkBEt730VWdPuea0YaiB8hi3dvRh5Bl4I6/vUBKjCMOm42PfnO18ttu292JKy48Bt+55nX44e8ew9dvWoMFs+uU++Gc1yzGL699C/qiSRiGgYs+cjP2tPfi2584H68/dTmuvPZO3PX3F/HWC4/GSUfOV+FlrztlGc5+zaKc7+z2f7yIlzentPBq8sJAIOFkJgnvv4trQ3KlgeEqcWumOq37+rDq8Dn4zTfequyGto5+vLx5L37xpyfRF00oK3Vvey9KI26U4/bmLrR39buTZu29iCXcSu2JZFpZqy9ubEEymcZhC6er7c2tPWh5cjOaT1isHpNv95JrfqeiJPa09eKen74Lxx4+B0e8+QeIxZMoK3GDeRrrKqb6R6PJAy+OVwxkZCyYywKJ49Vo8iGRtJVledyKOQN7k3/3B7c8hpqqEkTCIVRVlODQRU3qORLj+uoyJbzk56UJNW87jXsS3fNOXor5s2rV9j9+73J8aUEDnnlpl3pMFnZXVxTSkehu7UY84fpxdzR3IppIorqiVEUzeG4HjWaMqCLhfSOARwDsK+w1XfUX2trVDMPMxko898puLDjnWygptfDK6k8ikbJVHC9FLUTjSUxvqMRrT1qiGnplSyvK2QVAsbzlpa6FSq4GW0o4aUeFpRGxuGsNf++a1+Nfz21Tf1PUw4cvPxFfvepc9EeTaJrmWrbr7roG4bCJfz+3HR/9xl2oKI8okdZoxogEjbbrOVGORjPKuBMStFLNW63mRYmR+JJr4cQj56OmshTPr2/G+q1tqCqPDBxTyX+TQPd19OGko+bjTWcfjt7+BAxD4ANf+RMee34bDl88faBtiuHt6o4pN4Xk2B2yfDu742oBxbBrkjWa4Kkh4d2m651pxgKyWkkgyfdaGnGjEegKn7bt64oqN8On3nWq2n77319UrgR6jqxhyt1Qzj7Zrt44TMvAlz90tnpMccGRsKUE+JRLfoRrvnOP2j53eq2KWjj2shuw7Jxv4el1O9X24992A1a+6Tp89BurUVNZgpBl6s9fMywqkiGYC/u/kfBWkcGhT7tmPCBLd193FLt3d+K6T71B+Xcp1OzWvz6nrFxaUrx5ZwcSvTHlDyZ2tXRj9rwGZfGufvBlFddLUHwwogk1+UbEkynAdpQoI2IpESfoMeV2oHUT5KLQRq8mXwJKC/kK+Xh36UTomrGEBNCLUIhGk8p3e8PnLsLbLzhKbfvvL9yhrNer33kKaA6ZfLUrlkzHOScuUQl0SJjttI37H9+IG279F+bPqlPHqQmysogrtIAS5i33/T/loiCLeWZjldr+/J8+rvI5WKbALaufw9d/sQYzGyr1kmHNmEEj9BIAKX3KNWMBTWJRHC/lZiB27u3CRy8/Ce964yr1+B2f/SMeenKzEslrP3zugJXqce3PHlBhabMaq/GRb9yl4n5POjr7FAWJLb0WrXgjUX346S3Kv0t5HegxLbCg3BCUoUyjyYeA8vHOtYq3dqm8u6njeDXDQqJL2cSa6svx6/+5VO1O4WCdPTHcdPt/8OM/PI6XntmKaXPrVZayC6+6GcsWNKAkElLi+cL6Zvzz0Q0oK4+guy+uJt6GSht5z8Ov4DffvQeYNy3n0CyrLcNhC5tUGskh009qpjwBxvFeFEAcrw4n0+RHW2c/li9oxK3fuQwzGqpw531r1YIKWqn2t0c3uKvMTlik3BAUW0vJb2g5MVm9kYiloh0++Z7TUVdThu3Nnbj/8U1qv0F6KfcnQ3/zOSuUG8PL/ZAJrZ6jhRlrntgMyzJUWxrNGBAl4f0Ol//ZXujrucKr0QwNWZWUp4FEly7733zVzVhx6Gx87SPn4qIzD1NJcfLll396Erfc/awSS8+nS0JKS5DJf0tccPpydRsKWtFGE3QUyxvW0Q2ascGiEfsmAH8oRng1mnxoqq/A2o0tuOrrf8ETL+7EIQsalcvg3V/8Pyz/34excE49pk+rdBczCKEsXco+RhdTFOFA+XppAo1icx99dqtKoLP0zOQAACAASURBVNPR2Y+unpiKjOiPpVA3owavbNmLyz/zB9cbZ+T2gFFEhXJZVJS4r6PRjA22WHnx9Q860r4KkOuKeUlDFG0tHC2EeEZ/8JMXwdMAze29qC6PoLKiRCWyoUgFimIg4aTKEJ7rQOWBkrzsQnACdD47JNDkRiArmkSzpCSk8i/QPhRORj7i4aC2I2FTuSJoWbF2lk1e3JSO9t2OtC8sJv04tWMUn7+5kizeebq8u2Ys8AR1BufLtQdWrwllddJtJJAVTKJL0Qu0qKK8LIyQKdSCiOn8GvngOFpyNfnhxfAWmaGsl4T315Q4Sp93zUSEXA80MVZV4doOOtmNZjQJqrw7Ce//FNuILhao0WgmO+SMMoWprN0iHVMnB5CSycvGrsVXo9Fo8uB4g0v/FBHPq8u7azQazQjoNLi8e/4BlBqNRqMphioS3go1SafRaDSaseBVcjHEdHn3YXkEkLt1NWaNZkjI32gDOAUQsybbqQqwvPu9JLyUrj8cXPcmH460PwKBF3X0hkYzFNKdZJfid0Lg8sl4qoIq704uhg8C2BJYzyYhUqKGVldpNJqhUKJL95N2QVZA5d1VNMODxTUx+cu7C8CiuHwS3wCWC2o0kxPpWYHSmIzhpbq8+zjgpRrU4lsYUjowrRII0x1yTjoJx6bcCrnPpRkqVQke7GR0/2UsOPWjYcIIuUuMpWPDScd1LPl4IvW5HwF19C04H8B/KLassDamXj5eLb75owQ3VIJw+TQkeluR6u9Qx4bL6xCpqEeirx3STmEgjRgtAS6phhkuRaxzF6S0UVY7B46dQjK6D0KYCFc0QNpJxHv3qrZI0EuqZyAV70E60eeKuVtFE6HSGhhGrgROAxZaHu9HwE7FkI73cLYfLTQDaNEdKXES3hsAXFq48E5NtPhm4BM6EkIPwwwpwdz78t+wd/39SPa3q2dKa2ZjxuFvQM2co2GFy5WwKsE0DEQ7tqH5hT+jbdPDkE4a9YechKalZ6Ni+jIl0t27X0TLunvR0/KyasuKVKBh0WmYtuR0lNfPh2OnlUVMVnXXzmfRseXfkM6B1a3MUBkMK4xUrGvYtxcur0fDkjNV+6lYD9Lxbi3A0KJbILUkvDt1effC0OLLgisMRCoblBB1bn9KCaOCcuqaYfS0rFPWq5/+9i3Y9NCPUDV9Ocrq5itrktwQ5DbYt/Vx2Kn4wN5trz6I9k2PonHJGcqi7dj6+KC2kul92P3Cn9G68SHUzj1G9YkEP97bqoQ3KNo2PozGpWejYfFpKKubh1Ss22cBT0GmmOgOlHcv/m3/0+IFFDr1foFMWfFVgitcwYVQYtv66oPo2jmylMo9La+o27Av56Sxd/19Q+6Tinaidf39I3r9keCkE2hZ91e0vboGDYtPR8OS01FWOxepeC9S8e4h/dWTjilq6XppIYsMJ1tLwtuuqwwXx5QSX3YpRCoalKXb3fyiErsgLcuDHbLOW17+G9o2PoiGJWegYfEZKKubq3zMZAWLye6CmMLuhaDieL3y7rHAejZFmfTimyG4Pc1rsfeV+9C1a+oIbibkDmlZ9zdl6TcuPQsNi05VLgiaMKRIDJFzUm8CM8V9ugHF8c4k4e0rrg1d3t1jUorvgEuhUd13N68txsKlgUK+gFcBfCCP/b9AgxTAh3I8/32qaQngdADNw7xuNQ9S4YtN6yEXcSFvxI9DAvzSX9V5IQGeecTFMK0wktGuySW+U1x0A4zjfZMu7x4wk0l8KRSMLFzhuRReXYOuHUVbuCSSy/IU3osArAKwEcD1WZ4/BsDiPJa802veQbPJvm3dAN4IgGoN/psqEgHIXgfe5WQA/xrqRVwf8L2Ide3GotM/osLoKFpjUqCjF4Ik5lWg+DmAHYU2rMu7D2bii69rEJbWzEJ380vY+/Lfg/Lh2nyf71g7hy3Z6wBsBrA643mvZNW2YdppYtH9IrdDf/+ExZaqay9icX8ly0Sz4G378uwzune/gG2P/xqHnHylcjtM+CtBLbpBo5YRvQ3AncUIr+ZAJq74uqJLs/Vtmx7B5odvKKSR/wLwVk6yH/JlrfKusI5g69H0Xf73sxX6NQBeaEQXz0HcA+AK3n4L708ugqN4P2oryu1Tm23sRriGBdNTvu9R8Dr//ZOMAgAfYjdIINBEGy0aSUY71WIPTNSIBy26o4LFgqvjeEeBiSe+nujOQdvGh7D5kZ8U2tBZAC7kv1NZlohREpXjMl7YS7l5m094ib+yS+B+diuckeX1TvT97fjyS38pQ3irfMKLDFM0ULM00dumQs9q5lBcseOuupto/l4tuoNQvl0pIUXRQ+V2Et65urz76DFe4pttAiCfbbSU1xXdnxbz8v18v4gv7T2q2Kq9F8DrM455J4Cbc0TY3MX3azPitDYBWMhWrj993BoW6B5+7Ikt+Ute9PmEE77nXs/fA88KNthKp3afGmkl7kTvXvXDVdG4BPOOvwKRikakEz0qoVQhn8tw2wNHi25WAirv3kVH/54vzTSjxFinlKQvppOR2z7bNvgGEhEuq0Xv3g3Fiu7glx2Mlxz78SH2TfP9d1loHwHwZwArfD5ij7k8djPfmLdm2fsB8Ga4nuHcJGSR/5D7Uc/PXc3W9V18+zP7lMnNcW6hJ6Cv9VWs/8c31QIQw4wM+xn4t2UKrPcZjnpeaC26OQmyvPsXg+iMZmhG0/KliC+4K3dV8D5lyU87aYQQVqtZheFeIqWcFCyEYQh3lSt9td1tIRUmk07GUFI9C+XTFqC/fWsQXSvJeOwJWLYBkxmZ0MSTX4fz41+zEHs0sHtiMw6kjkXaE/F/ApjHbjWyhucA+Dg/t5Lvv8WWuN8afg2A7xRbGqtu/nEwrYibxIcEWJowye0g3ED8lExBOAYsYQGGuy0tU5BSIERvkbfZ0kZaptV+VGbc+94FagFr0c1JgOXdT9Dl3ceQwC1fqdyHgXknaUVWuKwGM1ddFkyDB/Jh3nItgM/l2MdzhF7Bk3Mf5MfRjP08V8U/srRR7XMzgOOBv+F7zj/uvQ+FBPlRAA/w7TEAdxf6Rj2scAXmHvsO2HZCZVoLAhLfpJNU994qqkCMHy26Y8VJNAAri8vVoMu7j4QgxFey4MqATznF61LqxhLKHHbkm5V/skj8UQM/5Mmx3wL4C4Cvs0/XI1c9u1yx5h/l+7uyPFeXEf51JjBQioZM+dkAbgXwXp9POZsqprNsy5vqeasw59i3QxgW0on+wIwTz88bqABr0R1LOmlQ3w7gExzDqBkDCnU7eC6FUUVKlXFr5oqLYR15KTY+dB32bXtipK/ofYvX8f13WCjbeRINfPn/TnYnvJYnyrJhZbQJjnI4iktWPZflmDBP4nm0+SzgGD9Pvt4OXx8/D+BinxFis3sCheQymXvc29FwxIWwe7uR6NkLYQbrZvILLAkvuSHoMthzQYzoUliL7lhTafliLTVjyEjEd0wE10O4qe9i3btRUlqNRWd8DJvW/AD7tj85klY8S/EyDiu7lIXvVN8+57LlS6vT/s6X9kPhXSrM41VoyLH6bQbf54pLX8ipUOfy4zN992fmOGaoFW0HMO+4d2DGyovQ3b4Zhi1gqnD50fsAPRHOJsAYzgesRXc82GpwroZgnE+aETGs2yFgH+5IILdDKtGHdKwbi866GlUzDx/J4d54uoVF90mexMq8qiLL9Qm2eOfnaMvLJUKJ+o/nkDCLF0BQbO+RAD7DIv92n+sh12IImTHevV+/93I4WQXf6O+j+T2sy9HWAcxZ9TbMXHkRYp07VW7hsczVO5QLIitadEeEV949WxTKCFlt8QyvjuMdJ7JZvmNq4Q6BJ75muByzVr0VPatfyvdQbzy9k2N3h1qJcS4v4aVwsfdkeX423zexf5j8t78CcBVvX8ERCX6eyfAfS5/FHPUtGAr5ohjaeTWcP2nOczzJlxdNy87D7KMvQ7Rjy37RHePPMW8XhBbdgggyLeRVurz7+OKJ78EiuH5IfJO9bQhXTUfjitejd+cLiHXtGu4w711Q5vKWYfbt4dsJ/Njv9no3gC/z3x8B8BuuD/gn3z638Pgt5fFMr/d8xmtEud1jOQxtKYAN/NxX+b4bRRIqrVYFPDFOoptJLheEFt3CCbK8+9+La2Lyl3cfC6QTTE2RUUEAyf4ONeEWOvJt2PzoDflOuNUNIbzTeWVbF1/6v523e4sevshhZ5TE5o/sTjifU0HO5HbTPFn2Kv8d4SidtwBoZMu21te256jex2FlP/MJ7pUAlmeZ7xC8jX5EXsj1RkuqZ8IMl8Gm6IWDrBSQZ+lSvDB9RS0RGpvVb5OMANNCvkWXdz8oONjjoN2+Jfs6YJTUuBNuD/5wKPFt5Puh0jWu4MgGP/3s8wX7c8F5GJp58o2s30+OoONbOZ3kNn6tdWwxr/MJ/Cl8/1a+5eKLuYR3xso3ovGICyGjvUj2tasFKwcbXqiZDRsmrLFbeqzJxnSLZ3KfKfxSS+fjLZYJc+EnBFKJXkjDweIzPo6ND/1IFabMwv0cCdA+RGtP8rLgCrYod3FsrRd/eyX7db0E5/fwjUR9CVu2gifHvJvDoV82t/kyi+9QKdae8a2Oy/VRWNmiJKhS8qwjLkbN/GMR62+HcCQOQs0dhJp8Q9pdEacZL6IWX25dliMeUjPqTKxVf+TzpUq/ZDHNPem9EKESxPftQH/7oJW7v+TbUNAP/aeHeH4X3zJpHWnCmmGIjiRqwaNqxgosPusahMKl6O/ehXQ6gZAIH/QVh92ZeRtSaKt3HFHl3fcEUf5EUxgTMc+FJ77ptMCcVZfDhInuPc+jbcMaVRrID1mF9UvPRGndXFgyhETfHrS++gD6Wjfm9Vpl9QvUUtvYvuLTRZdWzxqIaqWqwKFIpUpUTgls8qGycQmmLT0TVnk9yspnQKYTiEbb+ZxMnM+RzoCtcj5oq3ckBFje/QES3rJik4Boph4kvpTgmybdQkYEdXOPRd3cVWjf/hS2PvozlaNg5soLMe2QE4FIOZLxHpW0p3L6IpU0pmPbE2heu1oN5qqm5XDsuIqciNTOgSkNJLp3w0nH0bTyQvT37EF/8ysoqWiAlGmYoVJ07XkJsY7tqJt3HMIV9Ur4etu3oK9lPapnrkBZ3Rz1JSFrlParmXkkauYeRfV5kKI412gXSkvqEO9rga1+RBJo3/QwwiV1qDvkeBWZQDGbVO7INCJoXHoGKpuWQoRLEI93AylHJb0xTFOVSJpokK/XUL5ezUgIqLz78yS8vXoBxfggJsnvHQlPvKcFhhlC9bxjsDDySZSEa1A+bR6S0XYkunaxoRBGOtEJw4qgbuHJKGlajDDCKKlqUkMwTUJuJxBGBMbsI9UkVSLaATNcisZl57pni8d7pGkRjDQQjpQrMSZKm5aicem5CIfKIYWtvhylM5fBkBZMB0gl3dLrjpNCqKwWsKUqy26aEdjCQcXsFYiIUgjLVHahDYnSGctVf0zLQirehVSsU4VmCZX5bWJ+fp6Lgaxeco/I4hcETBmCjOO9NIgYRs1ImWS2hhBq0UCiu1nVarMcE9GunTAM07WOPauQ/nbSiHc3c+UpgWjnDmU5qrSH6rKf01ly6koSymRfmwrlAWf/T8kkLBlBItm/f5uTgokQEonoQCrFpExCOMK9rDZc+Sehduw0DITgxJOw0Ye0TKp62SkkIUXaXTxip+AI+nmMI01iaxquS2ESuEXdCIc0rIHqS5p8CCiOt8niRCFFoMu7F8IoDPVSQLwdEFSHfZeA+A1v/yAn++4QEDfyh/R2d4muiAmIX/AChjfy7H5KQPwOwG4AZ/PCBkdA3CmA9Vyy5xxXasU/AEHVGQ7l4w1DmP+2E/1rBEKzhWFc7kYXiBcFxGqOnX0fhb0KYWyFnb7VobBSYVAEQw0gWgXEz7nf73JXrYk+AXETx+u+hSsUJ4UUv5HSpuwz53ElYltA3C6lvRnCOokrUEgBca+AeI6XLF/A/X6EE6wv4BAySoT7LKS8V8IhvwUt3IgYwtgopXObhBMRQlzpRlKIPQLiV9zH93I8chf3McUT1RSfnBAQv+bv1wVcZy4tIP7I4W2ncSgbndvVAniJlyifz31cA4h/c0a3S7hoG0WC/DPIeQH6YTOLzy87JQgwjvfNurz7ODEKl6n/I+gLKlW2uf79m0U9IJq86Xb3KytoUUGTgIz6/PvVgJjOiw5C/OWucI9VrqgIH13ma6/Mu/LnbSaHh4EFl34EIgLYzqODsn83AKJcQHRl9LFBDHJ5iTruY6mvjzXcx7ivj5XcR7WAgreVc38kr2iDm5RdbTN8fQzztpAAqriPFve71BcOR6b2NDpvYlB9QvfcCqhZKuE/t9xHk/tTxf1OZjm3DvcN/OPpnVsvMU/E7Y+0DBghMnJkgFUoKMLBEBOsFtzEJylWXnz9Fxxp3wzIYdeBDkUAH97RQohn8thvzHEc+ywJuSbI1w3avysE3pKW6Q2mMNeqlWZOSvlPvQoUNFE0XAWK/ZfsSdcv6quS4F6yD66SkHkZ71VToGoXNJGmtgmh3Af0+v5ttmOry3eKJ/X66LkaQhmuhmx9pCQwpq+PYFeDIQ2YefURg6o7UMUHJ0u/bdXvIfo46NxSH8XAauHcfTSHPbfkSvFXoFBIEXGkc14aqbuCtHrp3ARQVcHPn4QQbwqqsSDgMLq7HWlfWOj15kAFClH0uXqfxevh780RM6kZNQJfIvx/Xp0uCu/SXrtJhsqvIE40hPhYSIayJX8vCG+iSLsaxhQ1u7Fdl3cfDwKXxuVCiIQjnS1kzomBL5WOFJzwDE5qIxFQnTVdK3FkBFje/Q4vLeRQa+o1o8AoBNx/1JJWi4T86uDNB3HyHU1OpO9zk1zjSQAbHCGvSyMVqGgKnqnXVu/wBFTevYOE986M+lSaiQlNWJXqz25y4ArhAS6AZgdOc1Al3j23lBbd/AmyvPtQ6+XzQl+yjBzJF4xBIQTutYXdQxM9/s9DTXQ5oQm1pHWqo8KWstf4bDAglhowHgvyO6f9vPkRYHn3VQGEk+l8vIXhBO0C+CMtA820hrwvlVlMIWnN2CL5EzxgeIjDDBifs2CdG3R/tOiOKadZnDw65SuNMkLc8u6GtnpHSODna4aAoAD9Nr/wenWiPD+h+wUzJviPpFRx0EKYk+/HfujqEBQJWKKvMCc8A+XdKbv/+ql+NsaSUbj0/7Qlrb0SMrP+mMKzaMZjoQstJQ6V1aAkVA3bjrnxubFuIJ3O7/dHxcaabuVPKWGVVMGRSZiOqX5C0sleCMO16NW97y3SUmUrXKXiex0ZV7Y/LZa1Siphph3YTtxt20nDilTCdAzYdpTbsWGGymE4UAl7xGheNQivv8j5YyKALbaQv6SlvkGKr8nTa9rqHTPKLS4mqKMaJj51AiKe610M/qJ67qGAcyORagiBUEkVLNtAKtUDwwihrG4eWjc9jGT7TlTPXqF+dErq58OsbICIx2DHe/avqRMGTKsMVqQUphVSuRKQ7IWZBiJltSqNd7xnL/a8tBqJzmYsOfMaVDQuhp2KQ6RjkPEYIiU1EJaAo3I2VCDWsRsl4UqEKmpoNQwcGUJf20aUlzUhXDUNsOkHIILetk0oCdeitHYGpJOiImro69wJs7QeodIapBPBpzTxXEF5+li3OXC2kUtJT65NaHZZvE5fZyeb+PzLht2V1xdIgicJgrKapLIsw2WU5sBB187nUVbWgMoZS9V2SgG549Gb1J4tr9yr7itnHObe6hehauZhgHRXiSVTUaT6utC96xkkox0QVgT9nduR6m1H3fwTkOhtQfvmx2CnYqqdV9d8F/ULToSdjCIR70F/66uoajoUVqQMldOXI+2ksOWhG2BaEYTL6lRuXzpH0fatSkxLKhvh2CnAMNHftglWuFzlEKailcK0EN23A1XTD8Mhp1yJstq5iPW1qly+QV7tj6AUT7WAmCUgXg5CeL029ORafnhuOzptRZ7/P5PwztPl3cceN1tXgLGYAj+3hZtDdrhBoRLbSYlwkYmwScRCkRpE6FI+HEK8ew92v/gXtG98GGaoDNWzj0A63o2ePS8fcGzvnnXqRqkTamatVNaypKXEqRiiHVvhpA/MzU9W6gHbWjcekFSdjs+Ecu5S7mA/qViXuvlJJ/vR27ph0LauXc9i7V2fwfRlZ6N24ckorZ0LI5FQKSKLdj/4JtKG/zKLI0wYnxIIXVDci2bphhbdvAgyLeTVnC1JM7EpEyorgYgPNyi8X+6kmlMt8EsnJSKVTYi1bUM8uRW9reuxd/19cNLuIkg7Fc1Vjy2jHQdduzKrsR98pKKd2PnsHdi7YQ0qZh6G2hlHoXHp6coCtxO9I+uvOOCPfKFkPtV6cm38CLK8e5HrvnU4WSGMQnayz5nSbDNg/DDvI+T+P9xf8TwOobjgSKW6RG/f8RQ2rbkeTjJaaJ8nHGQ179v4CPZtfBTJ/lbUH/IalNXOQZSKXaZs5Rse+rOV7ndGustPR6ihuxzIO+2APYN6ci0/AkwLebEu7z55mGPAsAodEG65XqHS7GRCbhHyd5KPNGyWItazA80v/gV7X/6HcjdMTSR2PvMH7H3lH2hYdhYqZq1ESWk9TLMc6XgXZ5/Mfaa9pacj+bhoybAt5IZ0QFENenJt3JhNwktJo1/kEkAFoPPxHiS85MDpKHQ5KVlf6ks4SDDcSTOqdQYngV1P/w5OrA/de15UUQQaIBndh93P3gHx/J9R2bQcC0/9oIriUEU04weeI28irUBK2NWwV0+uTWj6SXipAsF/UQG2qX42xpJRmFz7blqk85pcywV98SiHL/XNMMMIlVapsC6qp7bzqVvRuf2pg+LcHYxQOaOePWux7u7Po2n5a1F3yIlKgJFIwo7uY0+cofL1Fo44yoTxUcB6W1B+Xk9steiOKaq8eyuvXNNMcLwvY6FfSjXhRkm5rYiqcxbbtx37djyJ1g0PDEyaaYYmSZNwz/xRuSBqFpyA8tr5qgIzRUAEQCmFkwUxueOhJ+rGhYctt+yITto61ozC5Nr/M6XZYcD4eR775oSs3dLKGdj++K/QviHQohtTChLg1nV/U285cl6DigWOdW6HMIqaVmlz4DwY1OSa517Qk2v5EWAc79MWJ0HXZ3zis9yA0VzUl4ciFsrqEe/YgY5XH5rq5zMwtj76Uyw685MIlVSrMLtCEcBaW8i1QU+uaf9u/gQVx2twldVXx7b7mlFgqwNnl4NC/9mQhoBVMQ0tL/91fzn2YDkVAFX8fX2RrdKYfYHbO+hJ9Leja8fTKl9FkVCSnLBAcP80IyOgON5pZPG2FNeGLu9eCKMwufY/+a5cy9WAVVKKHU/fgo7NjwXWrwwoL8iRABYW2Y7B5dp/zPfDQSXTP8RutZIRDFQvjds7il1kZIZL1WKR4pIjiWMMGO+zYL2/mL5kEoQFNxUIMI73LYHE8eYbfK8ZVVLeZVAhGFZErc5qee7O0eyj9yO/J4993wjgS5Tu0i0pr5A8EezFaa1gV1kXC6r/dXYAeDPnIjkewBt8z7cBqB9ibmM3p0mdw4/Lc+yXN7QEOgC/fpUBsTzoKRktumOOTcL7KQC3UlmRwl5dx/EWwihMrn3YlGanAeP3hRxM8aVpBzBCpXA4AU0RkCW6GMB0bkKyWDby4x8AuIbF0vvWU3TNJrZMJR9/FAvoVk7ktIv3nwngP3wciWI35xtpYjE9AcASbr+Hb8RbqPQ4gEMBvDzw1gdDr/NeWp4L4Bbud7qYk0GfdbisViXeKZJOB85zTqGps3NgBFTORpM30uKB/kDhwqs5SDjOhFnw5BpNskhhBfWD8GG+92aShO9GNFAay4H1sy7kMjibj5W+VKWXAniC/yar9RgAl/lei6zZiwB8mwWYoJnB07K4FMgvvADAOgDXsfhnhgjM4dh2sEFSlOiC3UrlDYuQjvcNJKQvBAE86wj5bAqpQPIFuCWGDPWjqxlTwgb7rnSQ5sSnVULuc9Si35H/U8cZIki/83q2RsvZVVDqE+QL+XGZb59nM46/G8CVLLrkE/4/3vYVABU+YaaJuv/H7obfADgMwPsAXOITYo8ZPNbXAvgEgHszclFHfJb0lT5LuSimLTxFRYvYxVu8AxTyGWf+04yMgfLuxZ+7/6Ofulk6EfrYU4zlkw0h8O20SKcLnVwzhUQy0RNU7oVcb24F37+QRxsvskB+21eQlcT3bQDOY2uURJnqj/0RwK8AXMG3LwL4PoXTZrRJro9H2bq+lyfdnmIrOs1XfuTGuAHATUW8/wFo9d/soy9TFS6ookVxVxTiSAPicgvWp4JcuaYn1/InoPLurRYPwECW1WhGggy67lp7MZNr0gBsO+GW1ymeXG/Om+Aqy/Jc5kimCIid/DclyP0ArfgBcCZbvsQ5AG4G8C4Ar2Eh/QmArwFYxNv9+Fdovo4tZBJqyl+5kfOW3APgo0GcBKJu7nEoqWxCdN/2INw49QaM44Pp2X606OZPkOXdPx5EZzQjJfCCk283YXYLiLsL+TyMtIOSsgYIMwSMzvLgU3xhZC+wpfrvIfbfzdbuLp6sI74J4LO87fXs272WJ9PeDoCWih0C4N0AHsyjT+8E8Aq3u4rdHYEmGa9bcLKqcKEyvImia7b1ScgtQU2ueWFRenItf7w43iLdDUfp8u7jhMhev7sYzjWl2WzAuLuQNkwRQtqJe9UWg8D/5iq4qCrYGiVXwL9Y+H7rdSHjNSWLLHEcAFoKfQQL6vnsq32RoyFuZJfBT1msfz2C/vurr8zkH4hHgzoJ7ZsfRqSqCcIMq0Q6xSCAZ2zhfCTIlWt6ci1/lNgG85U90yj+2y/Y76FFd5zplZD9RU23BPc7YPhibaezL3Y6CyPF5h7Oz9Gl/sf472wTWct5nydYdN/Nrga/SU6+WFoSdhtH6GwHcCdPrs3jfbzBmfkO7+DJOvLtfoH7+AjH/wZC28YHVc5INAAAHB1JREFU0d+2EaHS2iC+I2npfs6B/dOMCwPl3T+vlw2PLaMwuXZ9WqSThbYrhY1UOhqUxdvHluR/A/gRW7x3+KIa1rGoPssxvXU8uZVidaplIT3H12YH+2U/kOEjdtgtQZERMY6WuJhvv+NVZ45vX3C87+285Jgs5ddyWBlNxn2HJ/HexaJf/Mlo24SaOce4F/fFrVw71IR4I2B9I4h+eXiWrxbiMaPM4EmI0inyhg8iAh/kmyTkjkLDySiULJ2MBhXV0Mli+msW3W9yPK6f9RxNAF/uBu/SKc2iS/7Xj3A8cIRdDrO5be82jaMU5vE4/itP4v2FLWzwXAa4HZqEe4lF968cB+y96e8C+CT/fTNbw0U7ZtteXYNUdB/MUEkeew/JdAPiPBPB/tNJcsacFovjH4sOEteMlMAnMy4wYfYJiAcLmlyzHUTK6yGMUBBh3bM4HvaDLGp/ybHfK7yKjFan/ZnF1eBqKLSkdx/vdwNPsH1kmNf1rOW/8s2/HWzp3sb7fJ3dC5l8n08AveblLL5F4dgJdYVjhctUFeUiohsS0o3XLrZLA7gZynRW2HwYiOMVwcTxLtDl3cee4i45s/IWnlzLZzb/AExaIUuTa8F8qQWvTvtTHvu+wvezMrZ7oruI7zMXQ+QiW6iax0Ze9bZgmDjdH3PkxMN5vuaQUFTD1n//AvNPfB8MM1Lw0mEBPG8L55o0UoFFIQguUK+t3vwIKI5XXYJ9mickNBObpIRMFRzHG+zXTvr8qbk4mv2ynSzSi9jHmtkNr51z2c+b7dLf8S0C6sryfCXf/4dD2VIchpbLjWDzd+J7bCV/wreMuCCoLFCqvwORqplA4SvY+qW6BfNJ6Xy8IyfION7b89hvCHQ4WSGMwuTajbaw44WuXKPJNQonk04gPl6Drcqh+CJnIPNzU5ZB5Plnj+VbPq+dyXMchlbFfmBqs32YdsrY5dDsyzlRMBUNi1FWP19VpiiCRQbE2SbMG4OMuyUrTk+uDY/6oRKBVGW+UAfwjRuBr1x7xkuBXsiXUhgCqWR/EBm0wBEMw+V5/jbnCfF+tWnC65dZ9ouy+P2FE9tkG7Oexbs6x+uu5tu4UTX9UFVA1A3fLvRzF/NMiMsFrBuDfB/a4h1z5lu8Ymc9hwAVgE4LWRiB+3hPMWBQONXTBVm88Riqmg5F7fzj0bn18WL7khnBkI3/+BLSDMUutp7z+UVYdDDWDyypmoGm5echHS865w7F8fYFLZJ6zdqY02dxyM878kxcogmIUZhce5cpzT0mzKcL/mImYph95JshpI19254Mun/FkK8ZLrOkeRw3KhsXo27J6ShvWKp6lk720aVFwd0RwIu2cD5vB7hyTShHofbzjjG1XjjZQTNYNQUjKDy/0ExTdFwq3oNwWQ0Wnf4xdLe8jC2P3YhUX4f+REZIac1szFx5EWrnHAPHMpHo34d0sh/CNJQAF+He75SQnYW6kzLRk2vjxmMW+8z01cYYMwqTa7emRbq/sHZdf7NpWLATfXCSMVRMX4ZDzvg4Up3N6Nr5LPZtfyKPdqY2ZfULUFo7F7NWXoyyujmId+1Got+dlzNFeGDesAihm2vAOMGEWeSE+GD05Fp+BFje/Qk9uTZuBD659sBIJ9c8i8cNSBFubKJwi0LEOnchVFqN6rrFqF94EhpazkTrhgfQeXC5IA4KyqctxPRDX4vy2StgmmVArB/97ZthGJZyKQ36MVQfTaH5bwVFNXxIwApUeLXFmz9B5S+2OLF0kZWGNSMn8IuMlQYMCn/akO+gIJGm8BipKlAM/uIJw4SdjCKe2K2iXaualqNq9pHY+ext6N76FGJdO3O2O5WYe9wVaFx2FkwjhN7e3UimuhE2wur8ZYOEOC3TENIYOPcjwHEn2PTk2ngRUHl35eMtcvGELu9eCKMwuUbFLlsMGF/O9wC14t8wkXJSuXcS7uea7GtT4tyw7BzMWHI+Yl3b0Lr+PuzbPvUsYIrJrV1yKkorpqO6YRlSsS4k0wlI2Hl/rjRBZsqRXd4LYL0jnG8FlRbSQ0+u5YcMrrz7Jbq8++ShREDkvfRbDSJjBL/cdMnspFVIlBARVDQuQfXMw9CzdwO2PfEbxDq25Tw0XF6PGSvegNb1DyDWtWvCnvCBSbO5q2BbBuxYHIneVsCUbv6FEXwXvaV9gvPh5+mab3EgW/Tk2sTH4jInFPC+p7B3o+N4C2EUJtdW28LuGWrlmvRN7nhfuJF9bEKVBqIMZsneNjVLX960BPNOeT/6d76E/o7N2Ldt8CTc7KMvRcOiU9XEU0nDQjQ/fRvseC+inTsOaD1UVoumpWejat4xaHnpr4h3bEO0szCXRrisDkvO/pQ6vm3jGvS2rFfby+sXuCJpmOhrdTOhltbOgWlF1LZo+xaVW6GkajpCJVVqQYkjpSrfs+A171U11Ehs4+k+GNKCJQKwXdjHnseH0WRAHG7AeCBIi9fzWWrxHTNsi9ehP1a48GoKI/DJtT/ZsHNOrnnWjfclEzyLXfAXmC+pY507YVglmLHiIkiZQv0hJ6K7eS1saaNq2lI0LTsbib5Wtc0qrcbC0z4O4aTRv28rDCuC3vZN6Nu7ATUzj0DN7JVqsUEs0YW5x70TpiPRvu3fiHftUu0RldOWIFJRD0mCaAh07XoBZZUzEa6oQ8/uF9WsM7lEGg85TS3RLa2dhZr5x6B925MwbYm6+ceprkthoGP385DxKOrmroJpWUp4O/e+gnRvB2pnHQUzUgrppJC0k7CMEiXI0a6dMIQ5Ygt3+NOZz3gQyw0Yn7VgPRDcK7to0R1TSkh4t+ry7uNB4M6ZeQIiJSCac4mpO5njuPUsA3p5NQmXTigBpmXH1TMPR828VUqsqI5bf8dWtd0wQ0gmoyo/jWWGUdm0VH3dw/Vz0LD4TFhmBHaqV7kiUjIFIU2EzBI0LDkdphlG0kmqy3HLpqNS6ocjKZMon74clm1CihTq5q1C2k4hTVZ/nPq0Q70u/RxVzzkSYVGKdKxLXd6TkFc0LUXYLIMd74FMx1zLtnYOIg3L4ST6kYp3K4F1nCTSTgqGipQOfmGcN+FmcCGeIUSQXjyk66ONDwGmhbyThHeGLu8+9ozC5No1lrT2Ssiv59qBhDdJJcZH44vL74cmmpyoVBN2FkJqMmIQNHCdtNpP7e+kVM0vR7ihbK6wuS4Q2i/Z1676S2JMwutQ+krDtdTTahv9lITVtnSsG2knDVvSXhRZwG4AKZGKdqm0D8K7rJeSl/DGlKB6p4TimJOJhNtvWo4ibZU4SNIxxRerHBIS39AQ8bQC2OQIeaMdcPps9TnpON68CCgt5B6Lszblm+tUc/BSLSCyZtEamEg7SANPpApKn9rJuD0fq3L/eK73Az8rqjCyg1xKQU6uadHNnyDTQn4wiM5oxp2HbNhd3hfI7781vbSz+rs1MWADPMv8a62AmG/AeC4o4YWeXBsRAZV3X6nLu48TMkhHq3ul/7+2sOFFNdDgIMvIjdE09GczkeB5NjfUzD9GxEoTxmcErNcF/W606A5PgOXdzwkkFsZd662t3nGGXA22gFDpPcmfq6wiR+ilSRMQmgNwIznEQDQKXaEKoFJfYU54VHn3W7mg38apfjbGklGYHf9/ljRbHSmuo7ZpcsgerYk0zZhhc7QDL1Labgv5h6DSQnqYfIWkrd4xo5SEd8UwBQI1E4MZNLVPEzM0kTbyxRGagw3X7+rGJRuuzm5yIDfpybUJT7vFBQR1efeJz7MOnE4DIiSAkHSnZpKca9nyhQwmeJvJ2wTvl+Y40QhvS/FN+Mqup31JySPchu2LA/e2kQM7ztvC/PoO70f9CvFN8jbH10d/v01fBeyR9tG/LVsf/duC7qP/3Hp99Pc7Wx9znFvh9dESAg1CYpoBY22QidC16OZHgHG8t9EHfgitpBijvmsYqZbeyuBucH4IyN8KiHcB4nZA/F5ArOIv6AWA+CPdBMS5vO1k3na7gLiMty0HxK287UO8bTogbuZtn+dtJYD4GW/77n4REN/gbVSMka+ixKe5P9S3ubzv+3nbrQLiCN72ZkDcxn08g7ed6evjm3nbkfTeeNt7eNscap+3fZq3VQDi57ztG74+fo9f+8cCwnK3ii/wtpsFRBPveBVv+52AWM7H/5fbR1AfT+Rt5/n6eAFvO9a37QrettDXx4/ztjpA/Jq3fZW3kVP+h/zaP9gfvCS+AiHuMiA+aSCYf160SxBpDqcKXurVYhErL77+HY60/w7ItmLaMooPLj9aCPHMwfj5OY59loRcE2yrwcQD7m9OqpVXBowmYaCevk8pJ7VLSKPXElY9DNlEr5eUyT3CEZ2WCFXDkDNpLVZKptqkRFsIoTIYksTRSMt0lyOd5hDCYRhygRDCtJ10X1o6O0II0ZqDhcIQIVva8bST3qIWLAgsEAZKHSlTKSe12ULIMYSYA6HKqztJJ7nVlFbCNMwZELKW+7jDkEa/aVjTIGSjgJBuH40uS1g1MOQM7mOrlGgPIVQBQ87hbfuklC0hhCPcRyPtpHtt6ewMIWwKQy4UQli2tGNpJ72V+3iIMESJI50k91EaQswVAhWSCq87ya0WQklDGDMhZA31O+UkdxjSipqG2Qghp3EfdwvH6LGEVct9pHO7F47oCIlQJQw5m/vYIaXcG0K4BIacz33stqWzO4SwJQx5iOqjY/enZXo795HObcSRTsLtY5hcDfNpm+3YzSmZ6g3K4iUBDolw0Jbvn4QQbwqqsSBwk5jbdzvSvrDY2eYBV14R0KXTLcW9Lx1OVhiB52rw2Ms3Px1889OdZeFMlAuf+qHL3w0Z25wck7Fbs2zLluVmT5bcIO1ZSq538c0PRW28krEtkaXf5AZ4Nctrb8my7cCMPW5l4+aMba1889PJNz+9WfoYz9LHdI4+bs6yLXf6t4KRA9Ev2t0wPAGWd3/91F4uNM7IAC5ZNJpCcQPVLC26Y88io/ioBu/XUn94Gs1EwbPeNONCLwnvbwEs1ud/fNBWr2ascX27gxZmaMaWWoN9Zrq8+7iiB79mbCEXg45kGDf+Y3AMoWYc0bKrGSu8SAZj5IU2pzxeefcAwsn+ZXCQuP7pG1f0F0AzdhheHg/NiPFSdxaL5QaFY+JWIJwk6CB2zWjjWbsDaUI1Iyag8u5V1MIm3/LOAvAEQ4tGcQSWck6jOQDPUtNxu4XjJqkPZOHTpYGUd9cUz6AKEfmX+9ZohsQTWBLcgeB/PbjGG/q24wNUNrrwjug43mJRogvfKeQk2MGXZdNMFfwWbliEERK+umrFJ3nRFIdN3/jPAZitT+T4MCC62fCqEGgB1uTJIME1WHCFceCkkBbf8aTM4rXrRfh4NYUypOj6EGJ/Kgx9lajJhieqavKM3QoYrqQPia/Uv+r5EmBayL+Q8DZySJlmDMlXdAchWIS1AGuYAcEVBixhDcy45z15psV3RAxUgi7uMnQnCe9/OJuSZowoSHT9aAGe8gyaNKMqEmKEgutHi++YQ8L7nin2nseVokXXDwtwLvHlOl1ZtokDtmVrInOrzPHFHo1t2fqdbb+x6k++fcx+boN7bdWalLAMayBKIdexI0KLb14EVN790EDKuxsqIFvn4x2OQEXXh+DCBaYYXGeNLj2F2P+50GCxaI2+MXibCqgXGPT5kYDQ8a5ZvX9biNr0dlIT5O5+/m0Dr50hQupYMbjU/Ej6KAb1MUu/pb+Pvn7LA/vtvbZXHVv6+5MxlvPtY17nNlcf1bZQjj5i0LE0aZaXD3ekaPEdkgDLu5+vy7uPEaMlugfg+xjcL+fgr2a2L2zmNrXCSRiDAu1zbSNBsnw5XaVPtDNFwcy67cCcAfn0W46g39RHY1AfZc4+jqTfQZ5bt4/GkH3MdmzgaPEdCzpJDf6XEvNO/vc6foyZ6GaQ7SI326XveF+yT9R+H0x91EwoSgy3MB8VBtSMBuMluhpNwQi9yGKU6SJVaOPy05qA0aKrmdBo8R3EQBxv8Vccurz7aKFFVzMp0OI7iIDKu6slw1/TaSGDRYuuZlKhxXcAgUCyk6k43l8W14Qu7+5Hi65mUqKjHQZyYAQQx3ueVokA0aKrmdRoyzcolpFSLAVQWniDOi0ktOhqpgpafIOgh9Tid7q8e3Fo0dVMKbT4FksNKUZCTdZpCkKLrmZKosW3GJ4xpryPoAi06GqmNFNMfAMs7/4wKUeZSrqjGRFadDWaqSe+uZaAjxQKJ7sCwNaxfgMTGS26Go2PKRRqFlB59zJqYR2AaOFtTI3y7l5lVi26Gk0WpoDlK4Mr736ZVpE8kDT5KLToajRDsl989bzR0IRISd7FddcKZErE8bZq0dVohmMgq1kRV9BTghT5eL8KYC2Jy1Q/G7kwDeOb5AeXuiioRjME6hI8LQRO0mdpSCp1efe8EBdi0nuxNRrNUARY3n01XT9P4+gGjUaj0QxBQOFkW0l4n9c+GY1Goxk7yNJ9hz7fGo1GMzwBlXdfEsBUveSAYu0B1Wg0k5cAy7u/PgDhFbx2WYfuaTQaTR50k/DeBGChPlsajUYzJkRIeE+luDJ9vjUajWZM6CPhbdHl3TUajWZogi7vvkCXd9doNJrhCai8e5KE97sAdutzrtFoNEMTZHn3nxTXhC7vrtFoJj8Blnc/O5CUW0H8Amg0Gs0UYYXn440U/n51HK9Go9GMABXH+wdawqbPmkaj0YwJqry7Lu2u0Wg0Y8fzNLmW1n4CjUajGRqvvDtNaRU5r7WGLN5qKrKgz7lGo9EMTVDl3b2aa5v0+dZoNJqhCai8e4RcDc8V14aO49VoNJMfsnQNYbhLh4vTOl3eXaPRaMaYUhLe/+K6awUyJcq7azQaTVCoXA1UunyePqUajUYzJlQZury7RqPRDE+AaSHvIeGt1eXdNRqNZngCCifbRMK7HkBMn3ONRqMZG8jSvUyfa41GoxmegPLxLtTl3TUajSYPyMUgRCDCe0Eg5d11OJlGo9HkTQ8J7w2ck7dggli7rNFoNFOEMAnvuZQfUn/iGo1GMybESXibaSWFPt8ajUaTm9Eo715E6R+NRqOZGgRU3j1GwvsjAC163Gg0Gs3QBFne/brimtBpITUazeQnwPLuZ+jy7hqNRjO2HEUW7ywAbYVPsLnl3QPIyh7WH75GoxlFGlwjcdwNxS4S3j8C+CCAl4pryyn2DXUC8gn+W/ssNBpNkIQl5GM27IJ1Sq1cC0a0qy328xbdGoVZFMkGCJwQwJvSaDSaAzUKEmnYBYun8vEGUxd4ncUuhqLjIwL8NdBo/n9759YjRRHF8f/pnVmQm1wkGo0IiYq3YCASvIQQkTcTTUyMX8DEj+KTLz76EfwAaoyCXEJAvCsKKoJ3iZegXJbdme1jTnX1bO9sT82lq9nd4f/bJ6aof3dXnzlTffrUKUJqoUpWQsQVuu9aYHYTgGYcPUYICCHjRz7btayGGJjjfRnAuRhidLuEkHEjf5qfTCZj7DBsNCzUcIKWQgghvWlK02VuRVi1hhq2d2d5SELI+KC+3ngi0ZyusdYc7ws+zhsFlogkhIwTFteNnDgwbY73tdjbu2u8XwZCCFkU8hdqDWnEnlCuN8d7wTxw/AvjzJcQsryxEEMNvGWqt9psOrY2Qw6EkOVMjT7sjGU1/FjPjBd+1stFFYSQ5UPucC3MUNOM1y0XfhFwC5jjInA7cto1VF9NTAgh9VJ0uFbqtpFMxMrb7eYec7zt2KpWiCI7eYGKbYnsna87f/GVe+mNCSFLB8teyGe5mmb+yvxXDTzfqEM15FQt40FZw5cQsoRoJs1OaVv1Hqqts5jVtstqiJzZcDVPJ9t6o4ZgFm200WLolxCyKGjXn7jAQtL5tIg9vZd9XpGGOd7nAGyIoSa+KPogJ2nhB4tbywIHHK4e1G+mXKW9bu26jk3t8dGm/den7dynZtv3NGUSDTTntfU7bkTn2zbH+0uM7d1Fks7ea0OdoHfAc6SY1a53fVpsTd3gzRvoQrv1XXD8rvYbqq1z2tZepi0F7dCx+2mXnZfpOe0+13XDtLE0tAe516NpV7Wjm9H+pXb7TzV1sVsrdGN1FyY0Gam2rsYpi+C2d99adXv3JElKZq7D4V7EpYqZdMZN7xf8gqWCNE0xnU4vWDPthiIF2mkbLW0t7Kuja7vuqXS00f3rW9C2IMq8Nsna01SD2q2CdveFdbS16x1oiXb3dRW1F7wk0GzMWmlrJG0UxiSsXXZd2Zj1154pfbmRa5ePWX4/pnve63Y6645dNkEYTLu3HbUXwUa7tcPn3V5m9o9o9p+XdSwGGkYhrZ6pdcUc7xsALg7bM79Ic7qxNhjWzgZC5V48H6he7dngh7RLvuRDaIfPe2lrh8est3boRWh17d7F86tpw+9+3atv2Fj7a4fOaxAb7a1d1f57QfuXuLHaip7XshpeHfqY9ic6VxQ4Yty5ysS5X85dlUyK5a0dbg/3r9J38eKNoTPv37PKePfXDt/r0blZbbSKdhX6xYcD7B16WYYUXqBVGRBCCFmO5A/4FjeeHW3t2W5zvJvjbf1DCCHjj7g837Z7lxAKhfTgkjneNwHcP2iPGnLaCCFkmTJSuGGdOd5Vfu+1vsxf2UEIISRnCL941jzp1CDbu7vsBefdGdclhJAyBowIvG3e9PZ+Md7M6RJCCOmH5R73yzazdLJXAPxQ1mhlHaXqyghCCCHzXKs53iNlQ2Jv6hpSS/EyQggZb2zptfR8J/ZSqWdVV7yRG1YSQsgomKvNlzl3FprNsdFc8rOxqpMRQsjNTh6ctRoRpTUogOvmeF8HsC3/JF+ZRgghZHTE1WssXWq9wRzvT+aBXVERGaGsIyGEkCBdaWbvWIx3bZYxlmQl3gaqNxn6P3mNpVB7SH8ctbHEtUMspnboySuGdqg9BO1/+PalrB0iprb3riqnG4D+l0hyQIHtAj0jwGlx+wthHVT2FxSaAnwgwF9ZMkRyLxS7AbmS1fPVSwJ9XyRRYNLan4TibkCuAVgj0NMAvsj66mqoPOM29MyubFKAowL84bW3QbEHkKtwYnrFtIGkDXHae6AWHnHta5Cd96dZ33Sl117hN/K8BcAxAX712ltU8QQgU1n+sl7z2jNe+zEo7vPXZdrfCfQjuAB5Mmna6lb7Scuv+jsu9tSQad+liqcAue5T9abdmNi/nfbELii2e+3VgJ4X6EnJtBtee82ctp4Q4IJk2ndAZa8vWm+PJm0BTPua134Uioe8tvX9WaDHM23bvU/2K7AekBl/7A8FOJedt2yGyj4LS81VOsVBgVyWTPsRKHYAcjkbT/1NoMeyMbGdTJ2dbAJk2mt/LMC3mTY2QuXp4k7WAhwC5F+v/SAUOwvaFwV6uKC9L8s1d/fL7sdnAnzjtdd77fwbMOFt9B9/L7dDscuPyUpA/xbowaxov2vfC8WduY0C+qUAX3n7X+vtqGj/hwX4M2D/pp0W7H9LwUa/FuBzb/+rvHbD2/8KAY4U7H8rFI8PYf9nBfhkvv3LoPY/JdD3eti/3ctzAj3l7b8JlQMV7H8nFA+U278VynXaRfs/KcD5gP2bjV712jugeLiH/duuu/bd2lCw0VMCfD+i/f8u0KNd9n+bv+6A/bvor0D10P+vz4Kj2U4KFwAAAABJRU5ErkJggg==\"/>\n  </svg>\n  <p style=\"text-align: center; color: #888;\">（盒模型）</p>\n</div>\n<ul>\n<li>内边距：内容区周围的空间。给元素应用的背景会作用于元素内容和内边距。</li>\n<li>边框：在内边距外侧增加一条框线，这条框线可以是实线、虚线或点划线。</li>\n<li>外边距：边框的外侧，围在盒子可见部分之外的透明区域，用于控制元素之间的距离。</li>\n</ul>\n<h3 id=\"外边距折叠\"> 外边距折叠</h3>\n<p>这里要注意一种叫做外边距折叠的机制，即垂直方向上的两个外边距相遇时，会折叠一个外边距。折叠后外边距的高度等于两者中较大的那个高度。</p>\n<h2 id=\"块级元素和行内元素\"> 块级元素和行内元素</h2>\n<h3 id=\"块级元素\"> 块级元素</h3>\n<p>每个块级元素通常都会独占一行或者是多行，可以对其单独设置高度、宽度以及对齐等属性。</p>\n<p>块级元素的特点：</p>\n<ul>\n<li>块级元素会独占一行</li>\n<li>宽度默认是容器的 100%</li>\n<li>高度，行高，外边距和内边距都可以单独设置</li>\n<li>可以容纳内联元素和其他的块级元素\n<ul>\n<li>文字块级标签例如 <code>&lt;p&gt;，&lt;h1&gt; ~ &lt;h6&gt;，&lt;dt&gt;</code> 等里面不能放其他的块级元素。</li>\n</ul>\n</li>\n<li>多个块级元素沿垂直方向堆叠，在垂直方向上的间距由它们的上、下外边距决定</li>\n</ul>\n<p>常见的块级元素：</p>\n<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span> ~ <span><span><span>&lt;</span>h6</span><span>></span></span> // 定义标题\n<span><span><span>&lt;</span>p</span><span>></span></span>         // 标签定义段落\n<span><span><span>&lt;</span>div</span><span>></span></span>       // 定义文档中的分区或节\n<span><span><span>&lt;</span>ul</span><span>></span></span>        // 定义无序列表\n<span><span><span>&lt;</span>ol</span><span>></span></span>        // 定义有序列表\n<span><span><span>&lt;</span>li</span><span>></span></span>        // 标签定义列表项目\n<span><span><span>&lt;</span>hr</span><span>></span></span>        // 创建一条水平线\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Block-level_elements\" title=\"块级元素\" target=\"_blank\" rel=\"noopener noreferrer\">更多常见的块级元素</a></p>\n<h3 id=\"行内元素\"> 行内元素</h3>\n<p>行内元素（内联元素）不占有独立的区域，仅仅依靠自己的字体大小或者是图像大小来支撑结构。一般<strong>不可以</strong>设置宽度、高度以及对齐等属性。</p>\n<p>行内元素的特点：</p>\n<ul>\n<li>和相邻的行内元素在一行上</li>\n<li>高度和宽度无效，但是水平方向上的 padding 和 margin 可以设置，垂直方向上的无效</li>\n<li>默认的宽度就是它本身的宽度</li>\n<li>行内元素只能容纳纯文本或者是其他的行内元素（a 标签除外）</li>\n</ul>\n<p>由一行文本形成的水平盒子叫做行盒子，行盒子的高度由所包含的行内盒子决定。修改行盒子大小的唯一途径就是<strong>修改行高</strong>（line-height），或者给它<strong>内部的行内盒子</strong>设置水平方向的边框、内边距或外边距。</p>\n<p>常见的行内元素：</p>\n<div><pre><code><span><span><span>&lt;</span>a</span><span>></span></span>         // 标签可定义锚\n<span><span><span>&lt;</span>strong</span><span>></span></span>    // 加粗\n<span><span><span>&lt;</span>b</span><span>></span></span>         // 字体加粗\n<span><span><span>&lt;</span>em</span><span>></span></span>        // 定义为强调的内容\n<span><span><span>&lt;</span>i</span><span>></span></span>         // 斜体文本效果\n<span><span><span>&lt;</span>span</span><span>></span></span>      // 组合文档中的行内元素\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Inline_elements\" title=\"行内元素\" target=\"_blank\" rel=\"noopener noreferrer\">更多常见的行内元素</a></p>\n<h3 id=\"行内块级元素\"> 行内块级元素</h3>\n<p>在行内元素中有几个特殊的标签，可以设置它们的宽高度以及对齐属性。</p>\n<div><pre><code><span><span><span>&lt;</span>img</span><span>></span></span>       // 向网页中嵌入一幅图像\n<span><span><span>&lt;</span>input</span><span>></span></span>     // 输入框\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>行内块级元素的特点：</p>\n<ul>\n<li>和相邻的行内元素（行内块）在一行上，但是中间会有空白的间隙</li>\n<li>默认的宽度就是本身内容的宽度</li>\n<li>高度，行高，内边距和外边距都可以设置</li>\n</ul>\n<h3 id=\"显示模式的转换\"> 显示模式的转换</h3>\n<ul>\n<li>块级元素转行内元素：<code>display: inline</code></li>\n<li>行内元素转块级元素：<code>display: block</code></li>\n<li>块级元素、行内元素转换为行内块级元素：<code>display: inline-block</code></li>\n</ul>\n<p>如果想让一个元素可以设置宽度高度，又让它以行内形式显示，我们可以设置 display 的值为 inline-block。</p>\n<h2 id=\"标准盒模型和-ie-盒模型\"> 标准盒模型和 IE 盒模型</h2>\n<p>由于浏览器的差异性，盒模型分为标准盒模型和 IE 盒模型，它们的呈现方式和对盒子大小的计算略有不同。</p>\n<h3 id=\"标准盒模型\"> 标准盒模型</h3>\n<ul>\n<li>元素的 width、height 只包含内容 content，不包含 border 和 padding 值；</li>\n<li>盒子的大小由元素的宽高、边框和内边距决定。</li>\n</ul>\n<div style=\"text-align: center;\">\n  <svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"350\" height=\"256\" viewBox=\"0 0 350 256\">\n    <image id=\"wenyuan_box-sizing_content-box\" data-name=\"wenyuan_box-sizing_content-box\" width=\"340\" height=\"245\" xlink:href=\"data:img/png;base64,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\"/>\n  </svg>\n  <p style=\"text-align: center; color: #888;\">（box-sizing: content-box）</p>\n</div>\n<blockquote>\n<p>我们用盒子的宽高来度量盒子的大小，可以看做是总的元素宽度和高度，与元素本身设置的宽高（width、height）不是同一个概念。</p>\n</blockquote>\n<p>盒子的宽 = <code>width</code> + <code>border-width</code> * 2 + <code>padding-left</code> + <code>padding-right</code> <br>\n盒子的高 = <code>height</code> + <code>border-width</code> * 2 + <code>padding-top</code> + <code>padding-bottom</code></p>\n<h3 id=\"ie-盒模型\"> IE 盒模型</h3>\n<p>IE 盒模型是老的 IE 浏览器在<a href=\"https://zh.wikipedia.org/wiki/%E6%80%AA%E5%BC%82%E6%A8%A1%E5%BC%8F\" title=\"怪异模式\" target=\"_blank\" rel=\"noopener noreferrer\">怪异模式</a>下使用自己的非标准模型。在标准盒模型下通过设置 <code>box-sizing: border-box;</code> 可转换为 IE 盒模型。</p>\n<ul>\n<li>元素的 width、height 不仅包括 content，还包括 border 和 padding；</li>\n<li>盒子的大小取决于 width、height，修改 border 和 padding 值不能改变盒子的大小。</li>\n</ul>\n<p style=\"text-align: center\">\n  <svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"350\" height=\"256\" viewBox=\"0 0 350 256\">\n    <image id=\"wenyuan_box-sizing_border-box\" data-name=\"wenyuan_box-sizing_border-box\" width=\"340\" height=\"245\" xlink:href=\"data:img/png;base64,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\"/>\n  </svg>\n</p>\n<div style=\"text-align:center;color:#888\">（box-sizing: border-box）</div>\n<blockquote>\n<p>在 IE 盒模型中，盒子的大小等于元素的 width、height 值，因而 border 和 padding 的空间会挤压 content 的空间，使得元素的内容宽高小于 width、height 设置的值。</p>\n</blockquote>\n<h3 id=\"两种模型区别\"> 两种模型区别</h3>\n<p>差异：宽高计算方式不同</p>\n<p>标准模型：计算元素的宽高只算 content 的宽高</p>\n<p>IE 模型：计算元素的宽高包含 content、padding、border</p>\n<h3 id=\"浏览器兼容性及其它\"> 浏览器兼容性及其它</h3>\n<ul>\n<li>只要设置了合适的 DTD，大多数浏览器会按照标准盒模型来显示，但是 IE5.X 和 6 在怪异模式下会根据 IE 盒子模型进行显示。</li>\n<li>标准盒模型下元素的 box-sizing 属性（IE8+）默认值为 content-box，将它设置成 border-box 可转换为 IE 盒模型。在实际应用场景中，<strong>若想控制元素总宽高保持固定</strong>，这个设置很有用。</li>\n</ul>\n<div><pre><code><span>/* 根元素设置为 border-box */</span>\n<span>:root</span> <span>{</span>\n  <span>box-sizing</span><span>:</span> border-box<span>;</span>\n<span>}</span>\n\n<span>/* 告诉其他所有元素和伪元素继承其盒模型 */</span>\n<span>*,\n::before,\n::after</span> <span>{</span>\n  <span>box-sizing</span><span>:</span> inherit<span>;</span>\n<span>}</span>\n\n<span>/* 如有必要，恢复第三方组件的盒模型类型，防止破坏其布局 */</span>\n<span>.third-party-component</span> <span>{</span>\n  <span>box-sizing</span><span>:</span> content-box<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><ul>\n<li>元素的宽（width）、高（height）、边框（border）、内边距（padding）、外边距（margin）都是盒子模型的重要组成部分，但是盒子模型的大小只与元素的宽高、边框、内间距有关，外边距只影响盒子所占外围空间的大小。</li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T07:36:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "经典布局",
      "url": "https://www.fedbook.cn/frontend-knowledge/css/layout/",
      "id": "https://www.fedbook.cn/frontend-knowledge/css/layout/",
      "content_html": "<h1 id=\"经典布局\"> 经典布局</h1>\n<p>网页布局（layout）是 CSS 的一个重点应用，在实际开发中，前端工程师在拿到设计稿后，都会先梳理页面的大致结构，构思完页面的布局后，再进行 coding。大多数网站都有着相似的布局，掌握这些布局套路便可以快速高效的完成开发工作。</p>\n<h2 id=\"相关属性\"> 相关属性</h2>\n<p>与布局相关的 CSS 属性主要有 3 个：display、position 和 float。</p>\n<h3 id=\"display\"> display</h3>\n<p>display 是 CSS 布局中很重要的一个属性，它定义了元素生成的显示框类型，常见的几个属性值有：<code>block</code>、<code>inline</code>、<code>inline-block</code>、<code>inherit</code>、<code>none</code>、<code>flex</code>。</p>\n<p>inherit 表示这个元素从父元素继承 display 属性值；none 表示这个元素不显示，也不占用空间位置；flex 是 flex 布局重要的属性设置，后面会单独写一个章节进行介绍，本文先介绍前三个属性值。</p>\n<p>每个元素都有默认的 display 属性，比如 div 标签的默认 display 属性是 block，我们通常称这类元素为<strong>块级元素</strong>；span 标签的默认 display 属性是 inline，我们通常称这类元素为<strong>行内元素</strong>。</p>\n<div style=\"display: flow-root\">\n  <div style=\"float: left; text-align: center;\">\n    <img src=\"./assets/block-elements.png\" alt=\"块级元素\" style=\"height: 300px;\">\n    <p style=\"text-align: center; color: #888;\">（块级元素）</p>\n  </div>\n  <div style=\"float: right; text-align: center;\">\n    <img src=\"./assets/inline-elements.png\" alt=\"行内元素\" style=\"width: 400px;\">\n    <p style=\"text-align: center; color: #888;\">（行内元素）</p>\n  </div>\n</div>\n<p>从上面的图可以看出，块级元素总是独占一行，从上到下显示，行内元素则是从左到右显示。这是因为块级元素前后有换行符，而行内元素前后没有换行符。除此之外，块级元素和行内元素还有其他一些区别和特性：</p>\n<p>块级元素：</p>\n<ul>\n<li>没有设置宽度时，它的宽度是其容器的 100%；</li>\n<li>可以给块级元素设置宽高、内边距、外边距等盒模型属性；</li>\n<li>块级元素可以包含块级元素和行内元素；</li>\n<li>常见的块级元素有：<code>&lt;div&gt;</code>、<code>&lt;h1&gt;</code> ~ <code>&lt;h6&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;dl&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;address&gt;</code>、<code>&lt;form&gt;</code> 等。</li>\n</ul>\n<p>行内元素：</p>\n<ul>\n<li>行内元素不会独占一行，只会占领自身宽高所需要的空间；</li>\n<li>给行内元素设置宽高不会起作用，margin 值只对左右起作用，padding 值也只对左右起作用；</li>\n<li>行内元素一般不可以包含块级元素，只能包含行内元素和文本；</li>\n<li>常见的行内元素有 <code>&lt;a&gt;</code>、<code>&lt;b&gt;</code>、<code>&lt;label&gt;</code>、<code>&lt;span&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;em&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;i&gt;</code>、<code>&lt;input&gt;</code> 等。</li>\n</ul>\n<p>值得注意的是，给 img 标签设置宽高是可以影响图片大小的，这是因为 img 是<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/Replaced_element\" title=\"可替换元素\" target=\"_blank\" rel=\"noopener noreferrer\">可替换元素</a>，可替换元素具有内在的尺寸，所以宽高可以设定。HTML 中的 input、button、textarea、select 都是可替代元素，这些元素即使是空的，浏览器也会根据其标签和属性来决定显示的内容。</p>\n<p>而 inline-block 又是什么呢？顾名思义，作为行内块级元素，它既具有块级元素可以设置宽高的特性，又具有行内元素不换行的特性。我们给 div 标签设置 inline-block 属性看下效果。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/inline-block-elements.png\" alt=\"行内块元素\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（将块级元素的 display 属性设置为 inline-block 后的效果）</p>\n</div>\n<p>在上图中，我们没有设置 margin 值，但是 div 之间会有空隙，这是因为浏览器会将 HTML 中的换行符、制表符、空白符合并成空白符，关于消除中间空隙的办法，推荐阅读《<a href=\"https://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-%E5%8E%BB%E9%99%A4%E9%97%B4%E8%B7%9D/\" target=\"_blank\" rel=\"noopener noreferrer\">去除 inline-block 元素间间距的 N 种方法 - 张鑫旭</a>》。</p>\n<h3 id=\"position\"> position</h3>\n<p>参见《<a href=\"/frontend-knowledge/css/position-property/\">定位（position）</a>》章节。</p>\n<h3 id=\"float\"> float</h3>\n<p>参见《<a href=\"/frontend-knowledge/css/float-property/\">浮动（float）</a>》章节。</p>\n<h2 id=\"布局示例-两栏布局\"> 布局示例：两栏布局</h2>\n<p>常见的两栏布局页面一般是左边固定宽度，右边自适应。这种布局相对简单些，大概的效果如下：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/two-column-layout.png\" alt=\"两栏布局效果图\" style=\"width: 500px;\">\n  <p style=\"text-align: center; color: #888;\">（两栏布局效果图）</p>\n</div>\n<p>先写出基础部分的代码：</p>\n<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>container<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>left<span>\"</span></span><span>></span></span>left<span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>right<span>\"</span></span><span>></span></span>right<span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code><span>.left</span> <span>{</span>\n  <span>width</span><span>:</span> 100px<span>;</span>\n  <span>height</span><span>:</span> 150px<span>;</span>\n  <span>background-color</span><span>:</span> #FFB5BF<span>;</span>\n<span>}</span>\n<span>.right</span> <span>{</span>\n  <span>height</span><span>:</span> 150px<span>;</span>\n  <span>background-color</span><span>:</span> #94E8FF<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>此时大体框架设计好了，.left 和 .right 目前是各自独占一行的，接下来调整样式来实现最终效果图，可以使用 3 种方式。</p>\n<h3 id=\"设置-display-为-inline-block\"> 设置 display 为 inline-block</h3>\n<p>原理：inline-block 兼具块级元素可以设置宽高和行内元素不独占一行的特性。</p>\n<p>方法：设置 .left、.right 的 display 为 inline-block。注意设置了 inline-block 的两个 div 之间会有间距，记得消除。由于左边是固定的，总的宽度是 100%，要计算右边的宽度，可以使用 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/calc\" target=\"_blank\" rel=\"noopener noreferrer\">calc</a> 来计算。</p>\n<div><pre><code><span>.container</span> <span>{</span>\n  <span>font-size</span><span>:</span> 0<span>;</span>   <span>/* 消除间距 */</span>\n<span>}</span>\n<span>.left, .right</span> <span>{</span>\n  <span>display</span><span>:</span> inline-block<span>;</span>\n<span>}</span>\n<span>.right</span> <span>{</span>\n  <span>width</span><span>:</span> <span>calc</span><span>(</span>100% - 100px<span>)</span><span>;</span>   <span>/* 计算宽度，运算符号左右一定要有空格 */</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"使用-float\"> 使用 float</h3>\n<p>float 变化多端，下面又能给出三种利用浮动的特性来达到上图两栏布局的方法。</p>\n<h4 id=\"第一种方法\"> 第一种方法</h4>\n<p>原理：处于文档流中的块级元素无法感知到浮动元素的存在。</p>\n<p>方法：设置 .left 为左浮动，此时 .right 会当 .left 不存在，由于块级元素的默认宽度是父级元素的 100%，此时 .right 的宽度就已经是 100% 了，无需再计算。然后设置 .right 的 margin 值来给 .left 预留空间（左外边距等于 .left 的宽度）。</p>\n<div><pre><code><span>.left</span> <span>{</span>\n  <span>float</span><span>:</span> left<span>;</span>\n<span>}</span>\n<span>.right</span> <span>{</span>\n  <span>margin-left</span><span>:</span> 100px<span>;</span>   <span>/* 为 .left 留出空间 */</span>\n<span>}</span>\n<span>.container</span> <span>{</span>\n  <span>overflow</span><span>:</span> hidden<span>;</span>   <span>/* 别忘了清除浮动 */</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h4 id=\"第二种方法\"> 第二种方法</h4>\n<p>原理：浮动元素会脱离文档流，直到它碰到父元素的边框或另一浮动元素为止。</p>\n<p>方法：设置 .left、.right 均左浮动，这时，它们便会紧贴着排列在一行。因为 .right 是浮动的，所以需要计算宽度。</p>\n<div><pre><code><span>.left</span> <span>{</span>\n  <span>float</span><span>:</span> left<span>;</span>\n<span>}</span>\n<span>.right</span> <span>{</span>\n  <span>float</span><span>:</span> left<span>;</span>\n  <span>width</span><span>:</span> <span>calc</span><span>(</span>100% - 100px<span>)</span><span>;</span>\n<span>}</span>\n<span>.container</span> <span>{</span>\n  <span>overflow</span><span>:</span> hidden<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h4 id=\"第三种方法\"> 第三种方法</h4>\n<p>原理：BFC 不会忽视浮动元素</p>\n<p>方法：设置 .left 为左浮动，接下来让 .right 形成 BFC，.right 就不会和 .left 重合了。</p>\n<div><pre><code><span>.left</span> <span>{</span>\n  <span>float</span><span>:</span> left<span>;</span>\n<span>}</span>\n<span>.right</span> <span>{</span>\n  <span>overflow</span><span>:</span> auto<span>;</span>    <span>/* 形成 BFC */</span>\n<span>}</span>\n<span>.container</span> <span>{</span>\n  <span>overflow</span><span>:</span> hidden<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"使用-absolute\"> 使用 absolute</h3>\n<p>原理：给元素的 positon 属性设置 absolute、fixed 时便会脱离文档流，不再遵循从上到下，从左到右的规律了。</p>\n<p>方法：设置 .left 的 position 为 absolute，.left 脱离了文档流，.right 会无视 .left 的存在。此时 .right 的宽度是 100% 了，然后设置一下 margin 值。</p>\n<div><pre><code><span>.container</span> <span>{</span>\n  <span>position</span><span>:</span> relative<span>;</span>\n<span>}</span>\n<span>.left</span> <span>{</span>\n  <span>position</span><span>:</span> absolute<span>;</span>\n<span>}</span>\n<span>.right</span> <span>{</span>\n  <span>margin-left</span><span>:</span> 100px<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id=\"布局示例-三栏布局\"> 布局示例：三栏布局</h2>\n<p>三栏布局用于需要两边固定宽度，中间自适应的场景，并且主要内容要优先渲染，按照 DOM 从上至下的加载原则，中间的自适应部分要放在前面。</p>\n<p>常见的三栏布局便是圣杯布局和双飞翼布局了。</p>\n<h3 id=\"圣杯布局\"> 圣杯布局</h3>\n<p>首先将布局的基础框架搭出来，在下面代码中，父 div 包含了三个子 div，将 .center 写在最前面，方便最先渲染。为了保证窗口缩小时仍然能展示，给 body 设置了最小宽度。</p>\n<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>container<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>center<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>left<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>right<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>body</span> <span>{</span>\n  <span>min-width</span><span>:</span> 630px<span>;</span>\n<span>}</span>\n<span>.center</span> <span>{</span>\n  <span>width</span><span>:</span> 100%<span>;</span>\n  <span>height</span><span>:</span> 150px<span>;</span>\n  <span>background-color</span><span>:</span> #94E8FF<span>;</span>\n<span>}</span>\n<span>.left</span> <span>{</span>\n  <span>width</span><span>:</span> 100px<span>;</span>\n  <span>height</span><span>:</span> 150px<span>;</span>\n  <span>background-color</span><span>:</span> #FFB5BF<span>;</span>\n<span>}</span>\n<span>.right</span> <span>{</span>\n  <span>width</span><span>:</span> 200px<span>;</span>\n  <span>height</span><span>:</span> 150px<span>;</span>\n  <span>background-color</span><span>:</span> #8990D5<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>刷新浏览器，效果如下：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/holy-grail-layout-step-1.png\" alt=\"基本框架效果图\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（基本框架效果图）</p>\n</div>\n<p>因为 div 默认是块级元素，此时三个子 div 会各占一行显示，接下来给三者都加上左浮动。</p>\n<div><pre><code><span>.container</span> <span>{</span>\n  <span>overflow</span><span>:</span> hidden<span>;</span>   <span>/* 清除浮动 */</span>\n<span>}</span>\n<span>.center, .left, .right</span> <span>{</span>\n  <span>float</span><span>:</span> left<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>由于 .center 设置了 100% 的宽度，所以 .left 和 .right 都被挤到下面去了，为了让它们上去，需要用到 margin 的负值。</p>\n<p>要想让 .left 回到 .center 的最左边，便是要向左移动 .center 的宽度，即 100%；</p>\n<p>.left 移动了之后，.right 会自动补上 .left 的空位，此时，.right 想要达到 .center 的最右边，只需要向左移动它自己本身的宽度就可以了，即 200px。</p>\n<div><pre><code><span>.left</span> <span>{</span>\n  <span>margin-left</span><span>:</span> -100%<span>;</span>\n<span>}</span>\n<span>.right</span> <span>{</span>\n  <span>margin-left</span><span>:</span> -200px<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><br>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/holy-grail-layout-step-2.png\" alt=\"通过使用 margin-left 让左右两边元素上移\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（通过使用 margin-left 让左右两边元素上移）</p>\n</div>\n<p>这个时候貌似是实现了圣杯布局，但仔细一看发现，.center 的文字被遮挡了，此时 .left、.right 都覆盖在 .center 的上面，我们要给两者留出位置。</p>\n<p>圣杯布局的做法是先设置父元素 .container 的 padding 属性，给 .left、.right 留出空间，两者需要的空间大小便是两者的宽度。父元素设置 padding 后，所有子元素都往中间挤了，这时利用定位属性将 .left、.right 分别向左向右拉到准备好的空位。</p>\n<div><pre><code><span>.container</span> <span>{</span>\n  <span>padding-left</span><span>:</span> 100px<span>;</span>\n  <span>padding-right</span><span>:</span> 200px<span>;</span>\n<span>}</span>\n<span>.left</span> <span>{</span>\n  <span>position</span><span>:</span> relative<span>;</span>\n  <span>left</span><span>:</span> -100px<span>;</span>\n<span>}</span>\n<span>.right</span> <span>{</span>\n  <span>position</span><span>:</span> relative<span>;</span>\n  <span>right</span><span>:</span> -200px<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><br>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/holy-grail-layout-step-3.png\" alt=\"父元素设置 padding 给左右两边的元素留空间，使用相对定位让左右两边元素归位\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（父元素设置 padding 给左右两边的元素留空间，使用相对定位让左右两边元素归位）</p>\n</div>\n<p>到这里，圣杯布局便完成了，它的核心思想是使用浮动布局，用 padding 为左右元素留空间，灵活使用 margin 的负值和相对定位让元素移动到相应的位置。完整的代码示例如下：</p>\n<iframe height=\"251\" style=\"width: 100%;\" scrolling=\"no\" title=\"css-layout-圣杯布局\" src=\"https://codepen.io/winyuan/embed/eYzrJVe?height=251&theme-id=light&default-tab=result\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href='https://codepen.io/winyuan/pen/eYzrJVe'>css-layout-圣杯布局</a> by wenyuan\n  (<a href='https://codepen.io/winyuan'>@winyuan</a>) on <a href='https://codepen.io'>CodePen</a>.\n</iframe>\n<h3 id=\"双飞翼布局\"> 双飞翼布局</h3>\n<p>双飞翼布局与圣杯布局的前部分一样，在给左右两边元素留出位置的思路有区别。</p>\n<p>圣杯布局是设置了父元素的 padding 留出空间，之后利用 relative 来归位。</p>\n<p>双飞翼则是多加了一个 div，将中间自适应部分包裹起来，利用子 div 的 margin 来给左右元素留空间。</p>\n<div><div><br><div>&nbsp;</div><br><br><br><br><br><br></div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>container<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>center-container<span>\"</span></span><span>></span></span> <span>&lt;!-- 新增的 div --></span>\n    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>center<span>\"</span></span><span>></span></span>center<span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>left<span>\"</span></span><span>></span></span>left<span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>right<span>\"</span></span><span>></span></span>left<span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><div><div><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code><span>body</span> <span>{</span>\n  <span>min-width</span><span>:</span> 630px<span>;</span>\n<span>}</span>\n<span>.container</span> <span>{</span>\n  <span>overflow</span><span>:</span> hidden<span>;</span>\n<span>}</span>\n<span>.center-container</span> <span>{</span>\n  <span>width</span><span>:</span> 100%<span>;</span>\n  <span>float</span><span>:</span> left<span>;</span>\n<span>}</span>\n<span>.center-container .center</span> <span>{</span>\n  <span>height</span><span>:</span> 150px<span>;</span>\n  <span>background-color</span><span>:</span> #94e8ff<span>;</span>\n\n  <span>margin-left</span><span>:</span> 100px<span>;</span>   <span>/* 新添加的属性 */</span>\n  <span>margin-right</span><span>:</span> 200px<span>;</span>   <span>/* 新添加的属性 */</span>\n<span>}</span>\n<span>.left</span> <span>{</span>\n  <span>width</span><span>:</span> 100px<span>;</span>\n  <span>height</span><span>:</span> 150px<span>;</span>\n  <span>background-color</span><span>:</span> #ffb5bf<span>;</span>\n  <span>float</span><span>:</span> left<span>;</span>\n  <span>margin-left</span><span>:</span> -100%<span>;</span>\n<span>}</span>\n<span>.right</span> <span>{</span>\n  <span>width</span><span>:</span> 200px<span>;</span>\n  <span>height</span><span>:</span> 150px<span>;</span>\n  <span>background-color</span><span>:</span> #8990d5<span>;</span>\n  <span>float</span><span>:</span> left<span>;</span>\n  <span>margin-left</span><span>:</span> -200px<span>;</span>\n<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><br>\n<iframe height=\"249\" style=\"width: 100%;\" scrolling=\"no\" title=\"css-layout-双飞翼布局\" src=\"https://codepen.io/winyuan/embed/gOMzPjb?height=249&theme-id=light&default-tab=result\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href='https://codepen.io/winyuan/pen/gOMzPjb'>css-layout-双飞翼布局</a> by wenyuan\n  (<a href='https://codepen.io/winyuan'>@winyuan</a>) on <a href='https://codepen.io'>CodePen</a>.\n</iframe>\n<p>同样的问题，双飞翼布局通过多加一个 div 并使用了 margin 来实现，圣杯布局则是使用 padding、相对定位（relative）、设置偏移量（left、right）来实现，相对来说，双飞翼布局更容易理解。在圣杯布局中，无限缩小屏幕（假设没有设置 body 的最小宽度），当 .center 的宽度小于 .left 时，会出现布局错乱。</p>\n<p>（完）</p>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T07:36:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "定位（position）",
      "url": "https://www.fedbook.cn/frontend-knowledge/css/position-property/",
      "id": "https://www.fedbook.cn/frontend-knowledge/css/position-property/",
      "content_html": "<h1 id=\"定位-position\"> 定位（position）</h1>\n<h2 id=\"文档流\"> 文档流</h2>\n<p>在介绍 position 之前，有必要先了解下文档流。</p>\n<p>简单说就是元素按照其在 HTML 中的位置顺序决定排布的过程。HTML的布局机制就是用文档流模型的，即块元素（block）独占一行，内联元素（inline），不独占一行。</p>\n<p>在不使用其他与排列和定位相关的特殊 CSS 规则（float 和绝对定位）时，元素的默认排列规则就是标准文档流。元素在标准文档流中定位时，一般使用 margin 来控制元素与元素之间的距离；使用 padding 来控制元素与其内容的距离。</p>\n<h2 id=\"position-属性介绍\"> position 属性介绍</h2>\n<ul>\n<li>\n<p>static（静态定位）</p>\n<p>对象遵循标准文档流，top，right，bottom，left 等属性失效。</p>\n</li>\n<li>\n<p>relative（相对定位）</p>\n<p>对象遵循标准文档流，使用 top，right，bottom，left 等属性相对于该对象在标准文档流中的位置进行偏移（<strong>相对于元素的正常位置进行定位</strong>），同时可通过 z-index 定义层叠关系。</p>\n</li>\n<li>\n<p>absolute（绝对定位）</p>\n<p>对象脱离标准文档流，使用 top，right，bottom，left 等属性进行绝对定位（<strong>相对于 static 定位以外的第一个父元素进行绝对定位</strong>），同时可通过 z-index 定义层叠关系。</p>\n</li>\n<li>\n<p>fixed（固定定位）</p>\n<p>对象脱离标准文档流，使用 top，right，bottom，left 等属性进行绝对定位（<strong>相对于浏览器窗口进行绝对定位</strong>），同时可通过 z-index 定义层叠关系。</p>\n</li>\n<li>\n<p>inherit</p>\n<p>继承父元素的 position 属性值。</p>\n</li>\n</ul>\n<h3 id=\"static-静态定位\"> static 静态定位</h3>\n<p>默认的 position 值，无特殊定位，遵循标准文档流，不做过多解释。</p>\n<h3 id=\"relative-相对定位\"> relative 相对定位</h3>\n<p>把一个元素的 position 属性设置为 relative，该元素仍然会呆在原来的地方。但此后，可以通过 top，right，bottom，left 属性，使该元素<strong>相对于初始位置</strong>平移一定距离。</p>\n<p>无论相对定位的元素是否位移，都不会改变该对象原本在文档流中的占位空间。因此，这样平移元素会导致它原先位置出现空白，且平移后它会有可能遮挡其他元素。。</p>\n<p>当设置了 margin 属性时，该元素在标准文档流中的占位空间也随之改变。同理，padding 也会改变相对定位的元素在标准文档流中的占位空间。</p>\n<p>代码示例：</p>\n<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>common box-1<span>\"</span></span><span>></span></span>box 1<span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>common box-2<span>\"</span></span><span>></span></span>box 2<span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>common box-3<span>\"</span></span><span>></span></span>box 3<span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>.common</span> <span>{</span>\n  <span>width</span><span>:</span> 100px<span>;</span>\n  <span>height</span><span>:</span> 100px<span>;</span>\n  <span>text-align</span><span>:</span> center<span>;</span>\n<span>}</span>\n<span>.box-1</span> <span>{</span>\n  <span>position</span><span>:</span> relative<span>;</span>\n  <span>background-color</span><span>:</span> #FFB5BF<span>;</span>\n<span>}</span>\n<span>.box-2</span> <span>{</span>\n  <span>position</span><span>:</span> relative<span>;</span>\n  <span>background-color</span><span>:</span> #94E8FF<span>;</span>\n  <span>left</span><span>:</span> 10px<span>;</span>\n  <span>top</span><span>:</span> 10px<span>;</span>\n<span>}</span>\n<span>.box-3</span> <span>{</span>\n  <span>background-color</span><span>:</span> #8990D5<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><br>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/position-relative.png\" alt=\"position 为 relative 示例\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（position 为 relative 示例）</p>\n</div>\n<p>从上图中我们不难发现，设置 position 为 relative：</p>\n<ul>\n<li>不添加额外属性（left，right，top，bottom 等）时，表现同 static 一样，如 .box-1；</li>\n<li>属性 left，right，top，bottom 会使元素偏离正常位置，如 .box-2；</li>\n<li>元素的偏移会覆盖相邻元素，如 .box-3。</li>\n</ul>\n<h3 id=\"absolute-绝对定位\"> absolute 绝对定位</h3>\n<p>相对定位事实上是常规文档流定位模型的一部分，因为元素还是相对于它在常规流中的初始位置来定位。绝对定位则会把元素拿出文档流，因此也就不会再占用原来的空间。与此同时，文档流中的其他元素会各自重新定位，仿佛绝对定位的那个元素没有存在过一样。</p>\n<p>绝对定位元素的包含块是距离它最近的定位祖先，也就是 position 属性设置为 <strong>static 之外任意值的祖先元素</strong>。如果没有这么一个定位祖先，那么它就相对于文档的根元素即 html 元素定位。</p>\n<p>在使用 absolute 定位时，必须指定 top，right，bottom，left 中的至少一个，否则 left/right/top/bottom 属性会使用它们的默认值 auto ，这将导致对象遵从标准文档流，在前一个对象之后立即被呈递，简单讲就是都变成 relative，会占用文档空间。</p>\n<p>如果同时设置了 left/right 属性，那么 left 生效。同理 top/bottom 同时存在时，top 生效。</p>\n<p>同时绝对定位（absolute）元素在可视区域之外会导致滚动条出现。而相对定位（relative）元素在可视区域之外，滚动条不会出现。</p>\n<p>代码示例：</p>\n<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>relative<span>\"</span></span><span>></span></span>\n  relative\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>absolute<span>\"</span></span><span>></span></span>absolute<span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code><span>.relative</span> <span>{</span>\n  <span>width</span><span>:</span> 200px<span>;</span>\n  <span>height</span><span>:</span> 200px<span>;</span>\n  <span>border</span><span>:</span> 2px solid #FFB5BF<span>;</span>\n  <span>position</span><span>:</span> relative<span>;</span>\n<span>}</span>\n<span>.absolute</span> <span>{</span>\n  <span>width</span><span>:</span> 100px<span>;</span>\n  <span>height</span><span>:</span> 100px<span>;</span>\n  <span>border</span><span>:</span> 2px solid #94E8FF<span>;</span>\n  <span>position</span><span>:</span> absolute<span>;</span>\n  <span>bottom</span><span>:</span> 10px<span>;</span>\n  <span>right</span><span>:</span> 10px<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><br>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/position-absolute.png\" alt=\"position 为 absolute 示例\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（position 为 absolute 示例）</p>\n</div>\n<p>近年来，已经很少用绝对定位来构建整体布局了，原因是绝对定位的盒子脱离了常规文档流，因此很难用它们创建随视口宽度和内容长度变化而变化的自适应或者响应式布局。Web 技术的特点决定了不太可能指定元素在页面上的确切位置和大小。</p>\n<h3 id=\"fixed-固定定位\"> fixed 固定定位</h3>\n<p>固定定位是由绝对定位衍生出来的，不同之处在于，固定定位元素的包含块是视口（viewport），即用户网页的可视区域。因此，固定定位可用来创建始终停留在窗口相同位置的浮动元素。</p>\n<p>代码示例：</p>\n<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>fixed<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;</span>span</span><span>></span></span>The p tag defines a paragraph. Browsers automatically add some space (margin) before and after each p element...<span><span><span>&lt;/</span>span</span><span>></span></span>\n……（此处省略 N 段文字）\n<span><span><span>&lt;</span>span</span><span>></span></span>The p tag defines a paragraph. Browsers automatically add some space (margin) before and after each p element...<span><span><span>&lt;/</span>span</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code><span>.fixed</span> <span>{</span>\n  <span>width</span><span>:</span> 100px<span>;</span>\n  <span>height</span><span>:</span> 100px<span>;</span>\n  <span>background-color</span><span>:</span> #FFB5BF<span>;</span>\n  <span>position</span><span>:</span> fixed<span>;</span>\n  <span>left</span><span>:</span> 20px<span>;</span>\n  <span>top</span><span>:</span> 20px<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><br>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/position-fixed.gif\" alt=\"position 为 fixed 示例\" style=\"width: 400px;\">\n  <p style=\"text-align: center; color: #888;\">（position 为 fixed 示例）</p>\n</div>\n<p>（完）</p>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T07:36:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "长度和单位",
      "url": "https://www.fedbook.cn/frontend-knowledge/css/length-and-units/",
      "id": "https://www.fedbook.cn/frontend-knowledge/css/length-and-units/",
      "content_html": "<h1 id=\"长度和单位\"> 长度和单位</h1>\n<blockquote>\n<p>CSS 单位 px，em，rem，vw，vh，%，vm 的区别</p>\n</blockquote>\n<h2 id=\"px\"> px</h2>\n<p>px 就是 pixel 的缩写，意为像素。它是一张图片最小的一个点，一张位图就是千千万万的这样的点构成的，比如常常听到的电脑像素是 1024x768，表示的是水平方向是 1024 个像素点，垂直方向是 768 个像素点。</p>\n<p>在网页设计中，px 是最常用的基本单位，它是相对于显示器屏幕分辨率而言的。</p>\n<h2 id=\"em\"> em</h2>\n<p>em 是相对长度单位。参考物是父元素的 font-size，具有继承的特点。如当前父元素的字体尺寸未设置，则相对于浏览器的默认字体尺寸。</p>\n<p>如果自身定义了 font-size 按自身来计算（浏览器默认字体是 16px），整个页面内 1em 不是一个固定的值。</p>\n<p><strong>特点</strong>：</p>\n<ul>\n<li>em 的值并不是固定的。</li>\n<li>em 会继承父级元素的字体大小。</li>\n</ul>\n<h2 id=\"rem\"> rem</h2>\n<h3 id=\"简介\"> 简介</h3>\n<p>rem 是 CSS3 新增的一个相对单位，rem 是相对于根元素 html 的字体大小（font-size）来计算的长度单位。</p>\n<p>如果你没有设置 html 的字体大小，就会以浏览器默认字体大小（16px）为基准，即 1rem = 16px。但如果此时将 rem 与 px 进行换算很麻烦，比如 0.75rem = 12px。</p>\n<p><strong>为了更方便的进行换算</strong>（比如1：10），在做<strong>移动端</strong>页面时，业内流行用 62.5% 来初始化（16px * 62.5% = 10px）。这么做的好处是令 1rem = 10px（同理 1.2rem = 12px，1.4rem = 14px），这样响应式的时候就可以直接改变 font-size 而无需计算其他各种样式中出现的尺寸了。</p>\n<div><pre><code><span>/* rem 的初始赋值：1rem = 10px */</span>\n<span>html</span> <span>{</span>\n  <span>font-size</span><span>:</span> 62.5%<span>;</span>\n<span>}</span>\n\n<span>body</span> <span>{</span>\n  <span>font-size</span><span>:</span> 1.4rem<span>;</span>  <span>/* 1.4 × 10px = 14px */</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><strong>优点</strong>：只需要设置根目录的大小就可以把整个页面成比例地调好。不会像 em 那样，依赖于父元素的字体大小，而造成混乱。</p>\n<p><strong>rem 兼容性</strong>：除了 IE8 及更早版本外，所有浏览器均已支持 rem。</p>\n<p><strong>em 与 rem 的区别</strong>：rem 是相对于根元素（html）的字体大小，而 em 是相对于其父元素的字体大小。</p>\n<p><strong>两者使用规则</strong>：</p>\n<ul>\n<li>如果这个属性根据它的 font-size 进行测量，则使用 em；</li>\n<li>其他的一切事物属性均使用 rem。</li>\n</ul>\n<h3 id=\"_62-5-和-10px-的区别\"> 62.5% 和 10px 的区别</h3>\n<p>在给 html 设置默认字体大小时（rem 的初始赋值），选择 62.5% 而非 10px 的原因，主要是出于兼容性和未来发展趋势的综合考虑。</p>\n<p>桌面浏览器默认页面字体大小是 16px，这种情况下设置成具体像素大小或者对应的百分比，看起来的效果是一样的；</p>\n<p>但是其他类型的设备的默认字体大小不一定是 16px，特别是高分辨率的设备，16px 大小的字体在它们上面看起来会非常小，所以不能在 html 上设置具体像素值，设置成百分比，可以按照设备的基准字体大小给编写的网页设置好最适合用户浏览的字体大小。</p>\n<h3 id=\"chrome-浏览器-12px-的坑\"> Chrome 浏览器 12px 的坑</h3>\n<p>我们开发常用的 Chrome 浏览器，支持的最小字体大小是 12px，此时使用 62.5% 会令 Chrome 和其他浏览器的页面效果不一样。这也是为什么上面说，在做<strong>移动端</strong>页面时用 62.5% 来初始化。</p>\n<p>解决办法：</p>\n<div><pre><code><span>/* rem 的初始赋值：1rem = 100px */</span>\n<span>html</span><span>{</span>\n    <span>font-size</span><span>:</span> 625%<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>1rem = 100px，以此为单位进行换算，可以避免以上问题的出现。</p>\n<h2 id=\"vw、vh\"> vw、vh</h2>\n<h3 id=\"简介-2\"> 简介</h3>\n<p>vw、vh、vmax、vmin 这四个都是 CSS3 中的新单位，是一种视窗单位，也是相对单位，它们的大小都是由视窗大小来决定的，单位 1，代表类似于 1% 。具体描述如下：</p>\n<ul>\n<li>vw：视窗宽度的百分比（1vw 代表视窗宽度的 1%）</li>\n<li>vh：视窗高度的百分比（1vh 代表视窗高度的 1%）</li>\n<li>vmin/vm：取当前 vw 和 vh 中较小的那一个值</li>\n<li>vmax：取当前 vw 和 vh 中较大的那一个值</li>\n</ul>\n<p>视窗，指的是浏览器可视区域的宽高（也就是不包括工具栏和按钮的内容区域），可以通过 window.innerWidth 和 window.innerHeight 获得。1vw 就是 1% 的浏览器的宽度，100vw 就是整个视窗的宽度。</p>\n<div style=\"text-align: center;\">\n  <svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"350\" height=\"275\" viewBox=\"0 0 350 275\">\n    <image id=\"wenyuan_vw-vh\" data-name=\"wenyuan_vw-vh\" width=\"350\" height=\"275\" xlink:href=\"data:img/png;base64,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\"/>\n  </svg>\n  <p style=\"text-align: center; color: #888;\">（浏览器可视区域的宽高）</p>\n</div>\n<h3 id=\"vw、vh-与-百分比的区别\"> vw、vh 与 % 百分比的区别</h3>\n<ul>\n<li>% 是相对于父元素的大小设定的比率，vw、vh 是视窗大小决定的。</li>\n<li>vw、vh 优势在于能够直接获取高度，而用 % 在没有设置 body 高度的情况下，是无法正确获得可视区域的高度的，所以这是挺不错的优势。</li>\n</ul>\n<h3 id=\"vmin、vmax-用处\"> vmin、vmax 用处</h3>\n<p>做移动页面开发时，如果使用 vw、wh 设置字体大小（比如 5vw），在竖屏和横屏状态下显示的字体大小是不一样的。\n由于 vmin 和 vmax 是当前较小的 vw 和 vh 和当前较大的 vw 和 vh。这里就可以用到 vmin 和 vmax。使得文字大小在横竖屏下保持一致。</p>\n<h2 id=\"百分比\"> 百分比 %</h2>\n<p>一般来说就是相对于父元素。</p>\n<ul>\n<li>对于普通定位元素就是我们理解的父元素；</li>\n<li>对于 <code>position: absolute;</code> 的元素是相对于已定位的父元素；</li>\n<li>对于 <code>position: fixed;</code> 的元素是相对于 ViewPort（可视窗口）。</li>\n</ul>\n<h2 id=\"常见问题\"> 常见问题</h2>\n<ul>\n<li>\n<p><strong>假如使用 em 来设置文字大小要注意什么？</strong><br>\n注意父元素的字体大小，因为 em 是根据父元素的大小来设置的。\n比如同样是 1.5em，要是父元素是 20，那 1.5em 就是 30px；要是父元素是 30px，1.5em 就是 45px（特别是在多重 div 嵌套里面更要注意）</p>\n</li>\n<li>\n<p><strong>pt、pc、ch 一般用在什么场景？</strong><br>\n这些我们网页设计基本上用不到，在排版上会有用处。</p>\n</li>\n<li>\n<p><strong>如果父元素没有指定高度，那么子元素的百分比的高度是多少？</strong><br>\n会按照子元素的实际高度，设置百分比则没有效果。</p>\n</li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T07:36:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "选择器与样式优先级",
      "url": "https://www.fedbook.cn/frontend-knowledge/css/selectors-and-selector-priority/",
      "id": "https://www.fedbook.cn/frontend-knowledge/css/selectors-and-selector-priority/",
      "content_html": "<h1 id=\"选择器与样式优先级\"> 选择器与样式优先级</h1>\n<h2 id=\"选择器写法\"> 选择器写法</h2>\n<h3 id=\"一般选择符\"> 一般选择符</h3>\n<ul>\n<li>类型选择符（通过元素名指定）</li>\n<li>ID 选择符（由井号 <code>#</code> 开头）</li>\n<li>类选择符（由句点 <code>.</code> 开头）</li>\n</ul>\n<p>可以将类型选择符和类选择符结合使用，以指定特定的 HTML 元素下特定 class 的样式。</p>\n<p>实例：</p>\n<div><pre><code><span>p.date-postd</span> <span>{</span>\n  <span>color</span><span>:</span> #ccc<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"组合选择符\"> 组合选择符</h3>\n<ul>\n<li>后代选择符（以空格分隔）</li>\n<li>子选择符（以大于号分隔）</li>\n<li>相邻同辈选择符（以加号分隔）</li>\n<li>一般同辈选择符（以波浪号分隔）</li>\n</ul>\n<h4 id=\"后代选择符\"> 后代选择符</h4>\n<p>后代选择符的写法是在两个选择符之间添加空格，用于选取某个或某组元素的所有后代元素。</p>\n<p>实例：</p>\n<div><pre><code><span>/* 只有作为块引用后代的段落元素会被选中，从而缩进，其他段落都不会缩进 */</span>\n<span>blockquote p</span> <span>{</span>\n  <span>padding-left</span><span>:</span> 2em<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id=\"子选择符\"> 子选择符</h4>\n<p>子选择符的写法是在两个选择符之间添加大于号，与后代选择符不同，它只选择一个元素的直接后代，也就是子元素。</p>\n<p>实例：</p>\n<div><pre><code><span>/* 选择了 div 元素中所有直接子元素 p */</span>\n<span>div > p</span> <span>{</span>\n  <span>background-color</span><span>:</span> yellow<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id=\"相邻同辈选择符\"> 相邻同辈选择符</h4>\n<p>相邻同辈选择符的写法是在两个选择符之间使用加号，它可以选择<strong>紧接在</strong>某个元素后面，并与该元素拥有共同父元素的元素。</p>\n<p>实例：</p>\n<div><pre><code><span>/* 选择了 div 元素后的第一个 p 元素 */</span>\n<span>div + p</span> <span>{</span>\n  <span>background-color</span><span>:</span> yellow<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这样选择 div  元素后的第一个段落是可行的，但更简单、更容易维护的方式，还是为这一段增加一个类名。</p>\n<h4 id=\"一般同辈选择符\"> 一般同辈选择符</h4>\n<p>一般同辈选择符的写法是在两个选择符之间使用波浪号，它可以选择<strong>所有</strong>指定元素之后的相邻兄弟元素。</p>\n<p>实例：</p>\n<div><pre><code><span>/* 选择了 div 元素后的所有 p 元素 */</span>\n<span>div ~ p</span> <span>{</span>\n  <span>background-color</span><span>:</span> yellow<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>注：相邻同辈选择符和一般同辈选择符都不会选择前面的同辈元素，这是因为浏览器会按照元素在页面中出现的先后次序给它们应用样式。</p>\n<h3 id=\"通用选择符\"> 通用选择符</h3>\n<p>通用选择符可以匹配任何元素，使用星号表示。</p>\n<p>实例：</p>\n<div><pre><code><span>*</span> <span>{</span>\n  <span>padding</span><span>:</span> 0<span>;</span>\n  <span>margin</span><span>:</span>0<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>但这样写可能带来很多意想不到的后果，特别是会影响 button、select 等表单元素。如果想重设样式，最好还是像下面这样明确指定元素：</p>\n<div><pre><code><span>h1, h2, h3, h4, h5, h6,\nul, ol, li, dl, p</span> <span>{</span>\n  <span>padding</span><span>:</span> 0<span>;</span>\n  <span>margin</span><span>:</span> 0<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"属性选择符\"> 属性选择符</h3>\n<p>属性选择符基于元素是否有某个属性或者属性是否有某个值来选择元素。</p>\n<h4 id=\"根据是否有某个属性\"> 根据是否有某个属性</h4>\n<p>实例：<br>\n当鼠标指针悬停在某个带有 <code>title</code> 属性的元素上时，多数浏览器都会显示一个提示条。利用这种行为，可以借助 <code>&lt;abbr&gt;</code> 元素对某些缩写词给出详尽的解释：</p>\n<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>I'm reading a book called you don't know <span><span><span>&lt;</span>abbr</span> <span>title</span><span><span>=</span><span>\"</span>JavaScript<span>\"</span></span><span>></span></span>js<span><span><span>&lt;/</span>abbr</span><span>></span></span>.<span><span><span>&lt;/</span>p</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br></div></div><p>可是，如果不把鼠标放在这个元素上，谁也不知道它还会显示缩写词的解释。为此，可以使用属性选择符给带有 <code>title</code> 属性的 <code>abbr</code> 元素添加不同的样式，比如在缩写词下面加一条点划线，然后把悬停状态的鼠标指针改成问好。</p>\n<div><pre><code><span>abbr[title]</span> <span>{</span>\n  <span>border-bottom</span><span>:</span> 1px dotted #999<span>;</span>\n<span>}</span>\n\n<span>abbr[title]:hover</span> <span>{</span>\n  <span>cursor</span><span>:</span> help<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h4 id=\"根据属性是否有某个值\"> 根据属性是否有某个值</h4>\n<p>除了可以根据是否存在某个属性来选择元素，还可以根据特定的属性值来应用样式。</p>\n<p>实例：<br>\n下面这个例子可以用来修正一个问题，即鼠标悬停在提交按钮上时，不同浏览器显示的光标不一致。有了这条规则，所有 <code>type</code> 属性值为 <code>submit</code> 的 <code>input</code> 元素在鼠标指针悬停时，都会显示一个手状光标。</p>\n<div><pre><code><span>input[type=\"submit\"]</span> <span>{</span>\n  <span>cursor</span><span>:</span> pointer<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>有时候我们关心的是属性值是否匹配某个模式，而非某个特定值。这时候，通过给属性选择符中的等号前面加上特殊字符，就可以表达出想要匹配的值的形式了。</p>\n<p>在属性选择符中常用的特殊字符如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">选择器</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>a[href^=&quot;http:&quot;</code>]</td>\n<td style=\"text-align:left\">要匹配以某些字符开头的属性值，在等号前面加上插入符（<code>^</code>）。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>img[src$=&quot;.jpg&quot;</code>]</td>\n<td style=\"text-align:left\">要匹配以某些字符结尾的属性值，在等号前面加上美元符号（<code>$</code>）。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>a[href*=&quot;/about/&quot;]</code></td>\n<td style=\"text-align:left\">要匹配包含某些字符的属性值，在等号前面加上星号（<code>*</code>）。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>a[rel~=next]</code></td>\n<td style=\"text-align:left\">要匹配以空格分隔的字符串中属性值（比如 <code>rel</code> 属性的值），在等号前面加上波浪号（<code>~</code>）。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>a[lang|=en]</code></td>\n<td style=\"text-align:left\">要匹配开头是指定值或者指定值后连着一个短划线的情况，比如 <code>en</code> 和 <code>en-us</code>，在等号前面加上竖线（<code>|</code>）。这种方式不常用。</td>\n</tr>\n</tbody>\n</table>\n<p>更多：<a href=\"https://www.w3school.com.cn/cssref/css_selectors.asp\" title=\"CSS 选择器参考手册\" target=\"_blank\" rel=\"noopener noreferrer\">CSS 选择器参考手册</a></p>\n<h2 id=\"样式优先级\"> 样式优先级</h2>\n<p>当声明冲突时，CSS 会根据三种条件来决定样式优先级：</p>\n<ul>\n<li>\n<p><strong>样式表的来源</strong>：</p>\n<p>行内样式 &gt; 嵌入样式 &gt; 外链样式</p>\n</li>\n<li>\n<p><strong>选择器优先级</strong>：</p>\n<ul>\n<li>如果选择器的 ID 数量更多，则它会胜出（即它更明确）。</li>\n<li>如果 ID 数量一致，那么拥有最多类的选择器胜出。</li>\n<li>如果以上两次比较都一致，那么拥有最多标签名的选择器胜出。</li>\n</ul>\n</li>\n<li>\n<p><strong>源码顺序</strong>：</p>\n<p>如果两个声明的来源和优先级相同，那么后出现的样式（在样式表中出现较晚，或者位于页面较晚引入的样式表中）会覆盖先出现的样式。<br>\n例如：<code>link（链接）</code>、<code>visited（访问）</code>、<code>hover（悬停）</code>、<code>active（激活）</code>，就得严格遵守这个顺序，否则会带来意想不到的结果。</p>\n</li>\n</ul>\n<div style=\"text-align: center;\">\n  <svg id=\"SvgjsSvg1006\" width=\"815.0000305175781\" height=\"253\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><defs id=\"SvgjsDefs1007\"><marker id=\"SvgjsMarker1074\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1075\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1078\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1079\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1082\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1083\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1086\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1087\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1090\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1091\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1094\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1095\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1098\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1099\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker></defs><g id=\"SvgjsG1008\" transform=\"translate(25.000015258789062,52.00000762939453)\"><path id=\"SvgjsPath1009\" d=\"M 16.666666666666668 0L 83.33333333333333 0C 105.55555555555556 0 105.55555555555556 50 83.33333333333333 50L 16.666666666666668 50C -5.555555555555556 50 -5.555555555555556 0 16.666666666666668 0Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1010\"><text id=\"SvgjsText1011\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"80px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"15.05\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1012\" dy=\"16\" x=\"50\"><tspan id=\"SvgjsTspan1013\" style=\"text-decoration:;\">冲突的声明</tspan></tspan></text></g></g><g id=\"SvgjsG1014\" transform=\"translate(168.00001525878906,25.00000762939453)\"><path id=\"SvgjsPath1015\" d=\"M 0 52L 61 0L 122 52L 61 104L 0 52Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1016\"><text id=\"SvgjsText1017\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"102px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"34.05\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1018\" dy=\"16\" x=\"61\"><tspan id=\"SvgjsTspan1019\" style=\"text-decoration:;\">不同的来源</tspan></tspan><tspan id=\"SvgjsTspan1020\" dy=\"16\" x=\"61\"><tspan id=\"SvgjsTspan1021\" style=\"text-decoration:;\">或者重要性</tspan></tspan></text></g></g><g id=\"SvgjsG1022\" transform=\"translate(332.00001525878906,25.00000762939453)\"><path id=\"SvgjsPath1023\" d=\"M 0 52L 61 0L 122 52L 61 104L 0 52Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1024\"><text id=\"SvgjsText1025\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"102px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"26.05\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1026\" dy=\"16\" x=\"61\"><tspan id=\"SvgjsTspan1027\" style=\"text-decoration:;\">是不是</tspan></tspan><tspan id=\"SvgjsTspan1028\" dy=\"16\" x=\"61\"><tspan id=\"SvgjsTspan1029\" style=\"text-decoration:;\">内联</tspan><tspan id=\"SvgjsTspan1030\" style=\"text-decoration:;font-size: inherit;\">样式</tspan></tspan><tspan id=\"SvgjsTspan1031\" dy=\"16\" x=\"61\"><tspan id=\"SvgjsTspan1032\" style=\"text-decoration:;\">（作用域）</tspan></tspan></text></g></g><g id=\"SvgjsG1033\" transform=\"translate(502.00001525878906,25.00000762939453)\"><path id=\"SvgjsPath1034\" d=\"M 0 52L 61 0L 122 52L 61 104L 0 52Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1035\"><text id=\"SvgjsText1036\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"102px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"34.05\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1037\" dy=\"16\" x=\"61\"><tspan id=\"SvgjsTspan1038\" style=\"text-decoration:;\">选择器是否有</tspan></tspan><tspan id=\"SvgjsTspan1039\" dy=\"16\" x=\"61\"><tspan id=\"SvgjsTspan1040\" style=\"text-decoration:;\">不同的优先级</tspan></tspan></text></g></g><g id=\"SvgjsG1041\" transform=\"translate(670.0000152587891,52.00000762939453)\"><path id=\"SvgjsPath1042\" d=\"M 16.666666666666668 0L 103.33333333333333 0C 125.55555555555556 0 125.55555555555556 50 103.33333333333333 50L 16.666666666666668 50C -5.555555555555556 50 -5.555555555555556 0 16.666666666666668 0Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1043\"><text id=\"SvgjsText1044\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"100px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"7.05\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1045\" dy=\"16\" x=\"60\"><tspan id=\"SvgjsTspan1046\" style=\"text-decoration:;\">使用源码顺序里</tspan></tspan><tspan id=\"SvgjsTspan1047\" dy=\"16\" x=\"60\"><tspan id=\"SvgjsTspan1048\" style=\"text-decoration:;\">较晚出现的声明</tspan></tspan></text></g></g><g id=\"SvgjsG1049\" transform=\"translate(172.00001525878906,176.00000762939453)\"><path id=\"SvgjsPath1050\" d=\"M 17.333333333333332 0L 96.66666666666667 0C 119.77777777777777 0 119.77777777777777 52 96.66666666666667 52L 17.333333333333332 52C -5.777777777777778 52 -5.777777777777778 0 17.333333333333332 0Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1051\"><text id=\"SvgjsText1052\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"94px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.05\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1053\" dy=\"16\" x=\"57\"><tspan id=\"SvgjsTspan1054\" style=\"text-decoration:;\">使用更高优先级</tspan></tspan><tspan id=\"SvgjsTspan1055\" dy=\"16\" x=\"57\"><tspan id=\"SvgjsTspan1056\" style=\"text-decoration:;\">的来源里的声明</tspan></tspan></text></g></g><g id=\"SvgjsG1057\" transform=\"translate(336.00001525878906,176.00000762939453)\"><path id=\"SvgjsPath1058\" d=\"M 17.333333333333332 0L 96.66666666666667 0C 119.77777777777777 0 119.77777777777777 52 96.66666666666667 52L 17.333333333333332 52C -5.777777777777778 52 -5.777777777777778 0 17.333333333333332 0Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1059\"><text id=\"SvgjsText1060\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"94px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"16.05\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1061\" dy=\"16\" x=\"57\"><tspan id=\"SvgjsTspan1062\" style=\"text-decoration:;\">使用内联声明</tspan></tspan></text></g></g><g id=\"SvgjsG1063\" transform=\"translate(506.00001525878906,176.00000762939453)\"><path id=\"SvgjsPath1064\" d=\"M 17.333333333333332 0L 96.66666666666667 0C 119.77777777777777 0 119.77777777777777 52 96.66666666666667 52L 17.333333333333332 52C -5.777777777777778 52 -5.777777777777778 0 17.333333333333332 0Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1065\"><text id=\"SvgjsText1066\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"94px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.05\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1067\" dy=\"16\" x=\"57\"><tspan id=\"SvgjsTspan1068\" style=\"text-decoration:;\">使用更高</tspan><tspan id=\"SvgjsTspan1069\" style=\"text-decoration:;font-size: inherit;\">优</tspan></tspan><tspan id=\"SvgjsTspan1070\" dy=\"16\" x=\"57\"><tspan id=\"SvgjsTspan1071\" style=\"text-decoration:;font-size: inherit;\">先级的声明</tspan></tspan></text></g></g><g id=\"SvgjsG1072\"><path id=\"SvgjsPath1073\" d=\"M125.00001525878906 77.00000762939453L146.50001525878906 77.00000762939453L146.50001525878906 77.00000762939453L168.00001525878906 77.00000762939453\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1074)\"></path></g><g id=\"SvgjsG1076\"><path id=\"SvgjsPath1077\" d=\"M290.00001525878906 77.00000762939453L311.00001525878906 77.00000762939453L311.00001525878906 77.00000762939453L332.00001525878906 77.00000762939453\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1078)\"></path></g><g id=\"SvgjsG1080\"><path id=\"SvgjsPath1081\" d=\"M454.00001525878906 77.00000762939453L478.00001525878906 77.00000762939453L478.00001525878906 77.00000762939453L502.00001525878906 77.00000762939453\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1082)\"></path></g><g id=\"SvgjsG1084\"><path id=\"SvgjsPath1085\" d=\"M624.0000152587891 77.00000762939453L647.0000152587891 77.00000762939453L647.0000152587891 77.00000762939453L670.0000152587891 77.00000762939453\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1086)\"></path></g><g id=\"SvgjsG1088\"><path id=\"SvgjsPath1089\" d=\"M229.00001525878906 129.00000762939453L229.00001525878906 152.50000762939453L229.00001525878906 152.50000762939453L229.00001525878906 176.00000762939453\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1090)\"></path></g><g id=\"SvgjsG1092\"><path id=\"SvgjsPath1093\" d=\"M393.00001525878906 129.00000762939453L393.00001525878906 152.50000762939453L393.00001525878906 152.50000762939453L393.00001525878906 176.00000762939453\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1094)\"></path></g><g id=\"SvgjsG1096\"><path id=\"SvgjsPath1097\" d=\"M563.0000152587891 129.00000762939453L563.0000152587891 152.50000762939453L563.0000152587891 152.50000762939453L563.0000152587891 176.00000762939453\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1098)\"></path></g><g id=\"SvgjsG1100\" transform=\"translate(247.00001525878906,44.00000762939453)\"><path id=\"SvgjsPath1101\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1102\"><text id=\"SvgjsText1103\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"120px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"10.05\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1104\" dy=\"16\" x=\"60\"><tspan id=\"SvgjsTspan1105\" style=\"text-decoration:;\">否</tspan></tspan></text></g></g><g id=\"SvgjsG1106\" transform=\"translate(412.00001525878906,44.00000762939453)\"><path id=\"SvgjsPath1107\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1108\"><text id=\"SvgjsText1109\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"120px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"10.05\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1110\" dy=\"16\" x=\"60\"><tspan id=\"SvgjsTspan1111\" style=\"text-decoration:;\">否</tspan></tspan></text></g></g><g id=\"SvgjsG1112\" transform=\"translate(579.0000152587891,44.00000762939453)\"><path id=\"SvgjsPath1113\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1114\"><text id=\"SvgjsText1115\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"120px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"10.05\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1116\" dy=\"16\" x=\"60\"><tspan id=\"SvgjsTspan1117\" style=\"text-decoration:;\">否</tspan></tspan></text></g></g><g id=\"SvgjsG1118\" transform=\"translate(183.00001525878906,129.00000762939453)\"><path id=\"SvgjsPath1119\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1120\"><text id=\"SvgjsText1121\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"120px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"10.05\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1122\" dy=\"16\" x=\"60\"><tspan id=\"SvgjsTspan1123\" style=\"text-decoration:;\">是</tspan></tspan></text></g></g><g id=\"SvgjsG1124\" transform=\"translate(349.00001525878906,129.00000762939453)\"><path id=\"SvgjsPath1125\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1126\"><text id=\"SvgjsText1127\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"120px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"10.05\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1128\" dy=\"16\" x=\"60\"><tspan id=\"SvgjsTspan1129\" style=\"text-decoration:;\">是</tspan></tspan></text></g></g><g id=\"SvgjsG1130\" transform=\"translate(516.0000152587891,129.00000762939453)\"><path id=\"SvgjsPath1131\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1132\"><text id=\"SvgjsText1133\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"120px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"10.05\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1134\" dy=\"16\" x=\"60\"><tspan id=\"SvgjsTspan1135\" style=\"text-decoration:;\">是</tspan></tspan></text></g></g></svg>\n  <p style=\"text-align: center; color: #888;\">（层叠的规则流程图，展示了声明的优先顺序）</p>\n</div>\n<h2 id=\"经验法则\"> 经验法则</h2>\n<p>在使用选择器时有一些通用的经验法则，如果遵守这些法则会很有用（特殊情况除外）。</p>\n<ul>\n<li>\n<p><strong>最好让优先级尽可能低</strong><br>\n这样当需要覆盖一些样式时，才能有选择空间。</p>\n</li>\n<li>\n<p><strong>在选择器中不要使用 ID</strong><br>\n就算只用一个 ID 时也会大幅提升优先级，当需要覆盖这个选择器时，通常找不到另一个更有意义的 ID，于是就会复制原来的选择器，然后加上另一个类。</p>\n</li>\n<li>\n<p><strong>不要使用 !important</strong><br>\n它比 ID 更难覆盖，一旦引入一个 !important，想要覆盖原先的声明，就会带来更多的 !important，最终会让一切回到起点。</p>\n</li>\n<li>\n<p><strong>当创建一个用于分发的模块（例如 NPM 包）时，尽量不要使用行内样式</strong><br>\n否则开发人员要么全盘接受包里的样式，要么给每个想修改的属性加上 !important。<br>\n正确的做法是在包里包含一个样式表，这样用户就可以在使用这份样式表的同时，在不引入优先级竞赛的前提下，自定义其中的样式。</p>\n</li>\n</ul>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li>《精通CSS 高级Web标准解决方案（第3版）》</li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T07:36:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "未完待续",
      "url": "https://www.fedbook.cn/frontend-knowledge/css/to-be-continued/",
      "id": "https://www.fedbook.cn/frontend-knowledge/css/to-be-continued/",
      "content_html": "<h1 id=\"未完待续\"> 未完待续</h1>\n<h2 id=\"知识点正在火速整理中\"> 知识点正在火速整理中</h2>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T07:36:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "伪元素和伪类",
      "url": "https://www.fedbook.cn/frontend-knowledge/css/pseudo-elements-and-pseudo-classes/",
      "id": "https://www.fedbook.cn/frontend-knowledge/css/pseudo-elements-and-pseudo-classes/",
      "content_html": "<h1 id=\"伪元素和伪类\"> 伪元素和伪类</h1>\n<h2 id=\"伪元素\"> 伪元素</h2>\n<h3 id=\"伪元素写法\"> 伪元素写法</h3>\n<p>有时候我们想选择的页面区域不是通过元素来表示的（比如想选择一段话的第一个字），而我们也不想为此给页面添加额外的标记。CSS 为这种情况提供了一些特殊选择符，叫作伪元素。</p>\n<p>伪元素是一个附加至选择符末的关键词，允许你对被选择元素的特定部分修改样式。</p>\n<p>常用的伪元素如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">属性</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">::first-letter</td>\n<td style=\"text-align:left\">选择一段文本的第一个字符添加特殊样式。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">::first-line</td>\n<td style=\"text-align:left\">选择一段文本的第一行添加特殊样式。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">::before</td>\n<td style=\"text-align:left\">在元素之前添加内容。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">::after</td>\n<td style=\"text-align:left\">在元素之后添加内容。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"伪元素应用\"> 伪元素应用</h3>\n<p>通过 <code>content</code> 属性，在文本前插入一个引号。</p>\n<div><pre><code><span>.chapter::before</span> <span>{</span>\n  <span>content</span><span>:</span> <span>'\" '</span><span>;</span>\n  <span>font-size</span><span>:</span> 15em<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"伪元素注意事项\"> 伪元素注意事项</h3>\n<ul>\n<li>为了与伪类区分开来，伪元素应该使用双冒号语法（尽管浏览器也兼容但冒号写法）。</li>\n</ul>\n<h2 id=\"伪类\"> 伪类</h2>\n<p>伪类选择符的语法是以有一个冒号开头，用于选择元素的特定状态或关系。</p>\n<h3 id=\"状态伪类\"> 状态伪类</h3>\n<p>有时候，我们想基于文档结构以外的情形来为页面添加样式，比如基于超链接或表单元素的状态。这时候就可以使用伪类选择符。</p>\n<p>一些最常见的用于超链接的伪类列举如下：</p>\n<div><pre><code><span>/* 未访问过的链接为蓝色 */</span>\n<span>a:link</span> <span>{</span>\n  <span>color</span><span>:</span> blue<span>;</span>\n<span>}</span>\n<span>/* 访问过的链接为绿色 */</span>\n<span>a:visited</span> <span>{</span>\n  <span>color</span><span>:</span> green<span>;</span>\n<span>}</span>\n<span>/* 链接在鼠标悬停及获取键盘焦点时为红色 */</span>\n<span>a:hover,\na:focus</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n<span>}</span>\n<span>/* 活动状态时为紫色 */</span>\n<span>a:active</span> <span>{</span>\n  <span>color</span><span>:</span> purple<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>以上伪类的先后次序很重要，应该始终满足正确的顺序：爱恨原则（lvha）—— 因爱（love）生恨（hate）。</p>\n<blockquote>\n<p>:link、:visited、:hover、:focus 和 :active</p>\n</blockquote>\n<h3 id=\"目标伪类\"> 目标伪类</h3>\n<p>目标伪类 <code>:target</code>，它匹配的元素有一个 ID 属性，而且该属性的值出现在当前页面 URL 末尾的井号（#）后边。<a href=\"https://www.w3school.com.cn/tiy/t.asp?f=css_sel_target\" target=\"_blank\" rel=\"noopener noreferrer\">最常见的应用</a>就是页面锚点跳转后，给当前选中的元素增加样式。</p>\n<h3 id=\"反选伪类\"> 反选伪类</h3>\n<p>反选伪类 <code>:not()</code>，专门用于排除某些选择符，可以配合各种放到括号中的选择符使用，不过伪元素和它自身除外。</p>\n<p>实例：</p>\n<div><pre><code><span>/* 选择所有不是段落（p）的元素 */</span>\n<span>:not(p)</span> <span>{</span>\n  <span>color</span><span>:</span> blue<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"结构化伪类\"> 结构化伪类</h3>\n<p>CSS3 新增了一大批与文档结构有关的新伪类。其中最常见的是 <code>nth-child</code> 选择符，可以用来交替地为表格行应用样式。</p>\n<p>考虑到现在手写表格的情况不多，就不展开描述了。<a href=\"https://www.w3school.com.cn/cssref/selector_nth-child.asp\" target=\"_blank\" rel=\"noopener noreferrer\">详情点击此处</a>。</p>\n<h3 id=\"表单伪类\"> 表单伪类</h3>\n<p>还有很多伪类专门用于选择表单元素。这些伪类根据用户与表单控件交互的方式，来反映表单控件的某种状态。</p>\n<p>UI 库泛滥的今天，我们很少在实际业务中手动写这些样式，所以也不展开多讲。<a href=\"https://www.runoob.com/css/css-pseudo-classes.html\" target=\"_blank\" rel=\"noopener noreferrer\">详情点击此处</a>。</p>\n<h2 id=\"区别\"> 区别</h2>\n<ul>\n<li>伪元素创建一个文档树以外的元素，而伪类的操作对象是文档树中已有的元素。</li>\n<li>CSS3 规范中要求使用双冒号(<code>::</code>) 表示伪元素，单冒号(<code>:</code>) 表示伪类。</li>\n</ul>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li>《精通CSS 高级Web标准解决方案（第3版）》</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-elements\" target=\"_blank\" rel=\"noopener noreferrer\">MDN 伪元素</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes\" target=\"_blank\" rel=\"noopener noreferrer\">MDN 伪类</a></li>\n<li><a href=\"https://www.runoob.com/css/css-pseudo-classes.html\" target=\"_blank\" rel=\"noopener noreferrer\">菜鸟教程伪类</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T07:36:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "CSS 引入方式",
      "url": "https://www.fedbook.cn/frontend-knowledge/css/ways-to-insert-css/",
      "id": "https://www.fedbook.cn/frontend-knowledge/css/ways-to-insert-css/",
      "content_html": "<h1 id=\"css-引入方式\"> CSS 引入方式</h1>\n<h2 id=\"引入方式\"> 引入方式</h2>\n<p>css 引入页面的方式有四种：</p>\n<ul>\n<li><strong>内联样式</strong>：即行内样式，通过标签的 style 属性，在标签上直接写样式。</li>\n</ul>\n<div><pre><code><span><span><span>&lt;</span>div</span> <span><span>style</span><span><span>=</span><span>\"</span><span><span>width</span><span>:</span>100px<span>;</span> <span>height</span><span>:</span>100px<span>;</span> <span>background</span><span>:</span>red </span><span>\"</span></span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li><strong>嵌入样式</strong>：通过 style 标签，在网页上创建嵌入的样式表。</li>\n</ul>\n<div><pre><code><span><span><span>&lt;</span>style</span> <span>type</span><span><span>=</span><span>\"</span>text/css<span>\"</span></span><span>></span></span><span><span>\n<span>div</span> <span>{</span> \n  <span>width</span><span>:</span>100px<span>;</span> \n  <span>height</span><span>:</span>100px<span>;</span> \n  <span>background</span><span>:</span>red<span>;</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>\n<li><strong>外链样式</strong>：通过 link 标签，链接外部样式文件到页面中。</li>\n</ul>\n<div><pre><code><span><span><span>&lt;</span>link</span> <span>rel</span><span><span>=</span><span>\"</span>stylesheet<span>\"</span></span> <span>type</span><span><span>=</span><span>\"</span>text/css<span>\"</span></span> <span>href</span><span><span>=</span><span>\"</span>index.css<span>\"</span></span><span>></span></span>\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li><strong>导入样式</strong>：通过 CSS 提供的 @import 语法，在样式表中链接其他样式表。</li>\n</ul>\n<div><pre><code><span>/* 必须出现在样式表中其他的样式之前，否则 @import 引用的样式表不会生效 */</span>\n@import <span><span>url</span><span>(</span><span>\"index.css\"</span><span>)</span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"link-和-import-的区别\"> link 和 @import 的区别</h2>\n<ul>\n<li>link 是 HTML 提供的标签；@import 是 CSS 提供的语法规则。</li>\n<li>加载页面时，link 标签引入的 CSS 被同时加载；@import 引入的 CSS 将在页面加载完毕后被加载。</li>\n<li>浏览器对 link 的兼容性更高，@import 只可以在 IE5+ 才能识别。</li>\n</ul>\n<p>注意：网上常说的「link 引入的样式权重大于 @import 引入的样式权重」是不太合理的。</p>\n<h2 id=\"import-引入-css-的弊端\"> @import 引入 CSS 的弊端</h2>\n<ul>\n<li>\n<p><strong>使用 @import 引入 CSS 会影响浏览器的并行下载</strong><br>\n使用 @import 引用的 CSS 文件只有在引用它的那个 css 文件被下载、解析之后，浏览器才会知道还有另外一个 css 需要下载，这时才去下载，然后下载后开始解析、构建 render tree 等一系列操作。这就导致了浏览器无法并行下载所需的样式文件。</p>\n</li>\n<li>\n<p><strong>多个 @import 会导致下载顺序紊乱</strong><br>\n在 IE 中，@import 会引发资源文件的下载顺序被打乱，即排列在 @import 后面的 js 文件先于 @import下 载，并且打乱甚至破坏 @import 自身的并行下载。</p>\n</li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T07:36:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "修订 Function.prototype.toString()",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es10-function/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es10-function/",
      "content_html": "<h1 id=\"修订-function-prototype-tostring\"> 修订 Function.prototype.toString()</h1>\n<p>函数是对象，并且每个对象都有一个 <code>.toString()</code> 方法，因为它最初存在于 Object.prototype.toString() 上。所有对象（包括函数）都是通过基于原型的类继承从它继承的。这意味着我们以前已经有 funcion.toString() 方法了。</p>\n<p>Function.prototype.toString() 方法返回一个表示当前函数源代码的字符串。这意味着还将返回注释、空格和语法详细信息。</p>\n<div><pre><code><span>function</span> <span>foo</span><span>(</span><span>)</span> <span>{</span>\n  <span>// ES10 新特性</span>\n  console<span>.</span><span>log</span><span>(</span><span>'hello world'</span><span>)</span>\n<span>}</span>\n\nconsole<span>.</span><span>log</span><span>(</span>foo<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span>\n\n<span>// 直接在方法名toString()</span>\nconsole<span>.</span><span>log</span><span>(</span>Number<span>.</span>parseInt<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>（完）</p>\n",
      "date_published": "2022-02-08T11:30:51.000Z",
      "date_modified": "2022-02-08T11:30:51.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Array 扩展",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es10-array/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es10-array/",
      "content_html": "<h1 id=\"array-扩展\"> Array 扩展</h1>\n<h2 id=\"array-prototype-flat\"> Array.prototype.flat()</h2>\n<p>flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。</p>\n<p><strong>语法</strong></p>\n<blockquote>\n<p>const newArray = arr.flat(depth)</p>\n</blockquote>\n<p><strong>解释</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n<th>必选</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>depth</td>\n<td>指定要提取嵌套数组的结构深度，默认值为 1</td>\n<td>N</td>\n</tr>\n</tbody>\n</table>\n<p><strong>示例</strong></p>\n<div><pre><code><span>const</span> numbers <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>[</span><span>3</span><span>,</span> <span>4</span><span>,</span> <span>[</span><span>5</span><span>,</span> <span>6</span><span>]</span><span>]</span><span>]</span>\nconsole<span>.</span><span>log</span><span>(</span>numbers<span>.</span><span>flat</span><span>(</span><span>)</span><span>)</span>\n<span>// [1, 2, 3, 4, [5, 6]]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><p>注意</p>\n<p>此时 flat 的参数没有设置，取默认值 <code>1</code>，也就是说只扁平化向下一级，遇到 <code>[3, 4, [5, 6]]</code> 这个数组会扁平会处理，不会再继续遍历内部的元素是否还有数组。</p>\n</div>\n<p>当 flat 的参数大于等于 <code>2</code>，返回值就是 <code>[1, 2, 3, 4, 5, 6]</code> 了。</p>\n<div><pre><code><span>const</span> numbers <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>[</span><span>3</span><span>,</span> <span>4</span><span>,</span> <span>[</span><span>5</span><span>,</span> <span>6</span><span>]</span><span>]</span><span>]</span>\nconsole<span>.</span><span>log</span><span>(</span>numbers<span>.</span><span>flat</span><span>(</span><span>2</span><span>)</span><span>)</span>\n<span>// [1, 2, 3, 4, 5, 6]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"array-prototype-flatmap\"> Array.prototype.flatMap()</h2>\n<p>flatMap() 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。从方法的名字上也可以看出来它包含两部分功能一个是 map，一个是 flat（深度为 1）。</p>\n<p><strong>语法</strong></p>\n<blockquote>\n<p>const new_array = arr.flatMap(function callback(currentValue[, index[, array]]) {// 返回新数组的元素 }[, thisArg])</p>\n</blockquote>\n<p><strong>解释</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n<th>必选</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>callback</td>\n<td>可以生成一个新数组中的元素的函数，可以传入三个参数：currentValue、index、array</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>thisArg</td>\n<td>遍历函数 this 的指向</td>\n<td>N</td>\n</tr>\n</tbody>\n</table>\n<p><strong>示例</strong></p>\n<div><pre><code><span>const</span> numbers <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span>\nnumbers<span>.</span><span>map</span><span>(</span><span>x</span> <span>=></span> <span>[</span>x <span>*</span> <span>2</span><span>]</span><span>)</span>     <span>// [[2], [4], [6]]</span>\nnumbers<span>.</span><span>flatMap</span><span>(</span><span>x</span> <span>=></span> <span>[</span>x <span>*</span> <span>2</span><span>]</span><span>)</span> <span>// [2, 4, 6]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这个示例可以简单对比下 map 和 flatMap 的区别，或者下面的示例：</p>\n<div><pre><code><span>let</span> arr <span>=</span> <span>[</span><span>'今天天气不错'</span><span>,</span> <span>''</span><span>,</span> <span>'早上好'</span><span>]</span>\narr<span>.</span><span>map</span><span>(</span><span>s</span> <span>=></span> s<span>.</span><span>split</span><span>(</span><span>''</span><span>)</span><span>)</span>\n<span>// [[\"今\", \"天\", \"天\", \"气\", \"不\", \"错\"],[\"\"],[\"早\", \"上\", \"好\"]]</span>\narr<span>.</span><span>flatMap</span><span>(</span><span>s</span> <span>=></span> s<span>.</span><span>split</span><span>(</span><span>''</span><span>)</span><span>)</span>\n<span>// [\"今\", \"天\", \"天\", \"气\", \"不\", \"错\", \"\", \"早\", \"上\", \"好\"]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"推荐阅读\"> 推荐阅读</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat\" target=\"_blank\" rel=\"noopener noreferrer\">Array.prototype.flat()</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap\" target=\"_blank\" rel=\"noopener noreferrer\">Array.prototype.flatMap()</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-02-08T09:16:42.000Z",
      "date_modified": "2022-02-08T09:16:42.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "ES6 - ES12 新特性",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/",
      "content_html": "<h1 id=\"es6-es12-新特性\"> ES6 - ES12 新特性</h1>\n<p><strong>什么是 ECMAScript（What）</strong>：</p>\n<p>ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。</p>\n<p>狭义的理解，我们写的大部分 JavaScript 代码都是 ES5 代码，而 ES6，ES7，ES8，ES9，ES10，ES11，ES12 以及后面出的版本，为我们引入了很多新特性。</p>\n<hr>\n<p><strong>为什么要学习 ES6+ 新特性（Why）</strong>：</p>\n<p>最新的 ES6 到 ES12 语法引入的很多新特性，能让很多依赖第三方库才能做到的事用原生 JS 寥寥几行代码就可迎刃而解。</p>\n<p>本系列只列举常用的特性和最基础的使用场景，详细介绍的话内容量将十分巨大，不妨通过 Google 搜索国外开发者的文档以及参阅 <a href=\"https://github.com/tc39/ecma262\" target=\"_blank\" rel=\"noopener noreferrer\">ECMA 官方发布的标准</a>。</p>\n<p>本系列后面将长期不断更新~</p>\n<hr>\n<p><strong>如何使用 ES6+ 新语法（How）</strong>：</p>\n<p>ES6+ 新特性是不能直接被所有浏览器直接识别的，需要通过 <a href=\"https://babeljs.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Babel</a> 将 ES6+ 的代码转为 ES5 代码，从而在老版本的浏览器执行。</p>\n<hr>\n<p>关于 ECMAScript 的知识点，主要参考：</p>\n<ul>\n<li>《<a href=\"https://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener noreferrer\">ES6 入门教程 - 阮一峰</a>》</li>\n<li>MDN</li>\n<li>《<a href=\"https://coding.imooc.com/class/444.html\" target=\"_blank\" rel=\"noopener noreferrer\">再学JavaScript ES(6-11)全版本语法大全</a>》</li>\n</ul>\n<div style=\"text-align: right\">\n  <svg t=\"1595948360275\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"11728\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"64\" height=\"64\"><defs><style type=\"text/css\"></style></defs><path d=\"M238.592 155.648H399.36v450.56C399.36 809.984 302.08 880.64 146.432 880.64c-37.888 0-87.04-6.144-118.784-17.408l18.432-130.048c22.528 7.168 51.2 12.288 82.944 12.288 67.584 0 110.592-30.72 110.592-141.312V155.648h-1.024z m301.056 547.84c41.984 22.528 110.592 44.032 179.2 44.032 73.728 0 113.664-30.72 113.664-78.848 0-43.008-33.792-69.632-119.808-99.328-118.784-40.96-197.632-107.52-197.632-211.968C515.072 235.52 617.472 143.36 785.408 143.36c81.92 0 139.264 16.384 182.272 35.84L931.84 308.224c-27.648-13.312-79.872-33.792-148.48-33.792-69.632 0-103.424 32.768-103.424 68.608 0 45.056 38.912 65.536 132.096 101.376 125.952 46.08 184.32 112.64 184.32 214.016 0 119.808-91.136 221.184-286.72 221.184-81.92 0-161.792-22.528-201.728-44.032l31.744-132.096z\" fill=\"#F4DE51\" p-id=\"11729\"></path></svg>\n</div>\n",
      "date_published": "2021-12-26T09:08:57.000Z",
      "date_modified": "2022-01-03T09:07:00.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "可选的 Catch Binding",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es10-catch/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es10-catch/",
      "content_html": "<h1 id=\"可选的-catch-binding\"> 可选的 Catch Binding</h1>\n<h2 id=\"可以省略-catch-子句的错误变量\"> 可以省略 catch 子句的错误变量</h2>\n<p>在 ES10 之前我们都是这样捕获异常的（即使不使用错误变量，也必须始终声明它）：</p>\n<div><pre><code><span>try</span> <span>{</span>\n  <span>// tryCode</span>\n<span>}</span> <span>catch</span> <span>(</span>err<span>)</span> <span>{</span>\n  <span>// catchCode</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>在这里 err 是必须的参数，在 ES10 可以省略这个参数：</p>\n<div><pre><code><span>try</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'Foobar'</span><span>)</span>\n<span>}</span> <span>catch</span> <span>{</span>\n  console<span>.</span><span>error</span><span>(</span><span>'Bar'</span><span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>通常，我们不希望忽略应用程序中的错误。至少希望将它们打印到控制台。然而，在一些罕见的情况下，可能根本不需要 catch 变量绑定，比如下面两个案例。</p>\n<h2 id=\"案例-1-验证参数是否为-json-格式\"> 案例 1：验证参数是否为 json 格式</h2>\n<p>这个需求我们只需要返回 <code>true</code> 或 <code>false</code>，并不关心 <code>catch</code> 的参数。</p>\n<div><pre><code><span>const</span> <span>validJSON</span> <span>=</span> <span>json</span> <span>=></span> <span>{</span>\n  <span>try</span> <span>{</span>\n    <span>JSON</span><span>.</span><span>parse</span><span>(</span>json<span>)</span>\n    <span>return</span> <span>true</span>\n  <span>}</span> <span>catch</span> <span>{</span>\n    <span>return</span> <span>false</span>\n  <span>}</span>\n<span>}</span>\n\n<span>const</span> json <span>=</span> <span>'{\"name\":\"zhangsan\", \"age\": 13}'</span>\nconsole<span>.</span><span>log</span><span>(</span><span>validJSON</span><span>(</span>json<span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id=\"案例-2-日志代码中的防错逻辑\"> 案例 2：日志代码中的防错逻辑</h2>\n<p>假设我们试图将一个错误记录到控制台，然后由于某种原因，日志代码本身会导致另一个错误。我们不希望日志代码抛出错误，所以在这种情况下，没有绑定的 catch 子句可能是有意义的。</p>\n<div><pre><code><span>function</span> <span>log</span><span>(</span><span>error</span><span>)</span> <span>{</span>\n  <span>try</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span>error<span>)</span>\n  <span>}</span> <span>catch</span> <span>{</span>\n    <span>// There's not much more we can do.</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>（完）</p>\n",
      "date_published": "2022-02-08T11:50:23.000Z",
      "date_modified": "2022-02-08T11:50:23.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Symbol 扩展",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es10-symbol/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es10-symbol/",
      "content_html": "<h1 id=\"symbol-扩展\"> Symbol 扩展</h1>\n<h2 id=\"symbol-prototype-description\"> Symbol.prototype.description</h2>\n<p>我们知道，Symbol 的描述只被存储在内部的 <code>description</code>，没有直接对外暴露，只有调用 Symbol 的 <code>toString()</code> 时才可以读取这个属性：</p>\n<div><pre><code><span>const</span> name <span>=</span> <span>Symbol</span><span>(</span><span>'es'</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>name<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span> <span>// Symbol(es)</span>\nconsole<span>.</span><span>log</span><span>(</span>name<span>)</span>            <span>// Symbol(es)</span>\nconsole<span>.</span><span>log</span><span>(</span>name <span>===</span> <span>'Symbol(es)'</span><span>)</span>            <span>// false</span>\nconsole<span>.</span><span>log</span><span>(</span>name<span>.</span><span>toString</span><span>(</span><span>)</span> <span>===</span> <span>'Symbol(es)'</span><span>)</span> <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>现在可以通过 <code>description</code> 方法获取 Symbol 的描述：</p>\n<div><pre><code><span>const</span> name <span>=</span> <span>Symbol</span><span>(</span><span>'es'</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>name<span>.</span>description<span>)</span> <span>// es</span>\nconsole<span>.</span><span>log</span><span>(</span>name<span>.</span>description <span>===</span> <span>'es'</span><span>)</span> <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（完）</p>\n",
      "date_published": "2022-02-13T07:16:09.000Z",
      "date_modified": "2022-02-13T07:16:09.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "JSON 扩展",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es10-json/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es10-json/",
      "content_html": "<h1 id=\"json-扩展\"> JSON 扩展</h1>\n<h2 id=\"json-superset\"> JSON superset</h2>\n<p>JSON 超集，简而言之就是让 ECMAScript 兼容所有 JSON 支持的文本。ECMAScript 曾在标准 JSON.parse 部分阐明 JSON 确为其一个子集，但由于 JSON 内容可以正常包含 U+2028 行分隔符 与 U+2029 段分隔符，而 ECMAScript 却不行。</p>\n<h2 id=\"json-stringify-增强能力\"> JSON.stringify() 增强能力</h2>\n<p>JSON.stringify 在 ES10 修复了对于一些超出范围的 Unicode 展示 <code>\b</code> 错误的问题。因为 JSON 都是被编码成 UTF-8，所以遇到 0xD800–0xDFFF 之内的字符会因为无法编码成 UTF-8 进而导致显示错误。在 ES10 它会用转义字符的方式来处理这部分字符而非编码的方式，这样就会正常显示了。</p>\n<div><pre><code><span>// \\uD83D\\uDE0E  emoji 多字节的一个字符</span>\nconsole<span>.</span><span>log</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>'\\uD83D\\uDE0E'</span><span>)</span><span>)</span> <span>// 笑脸</span>\n\n<span>// 如果我们只取其中的一部分 \\uD83D 这其实是个无效的字符串</span>\n<span>// 之前的版本, 这些字符将替换为特殊字符, 而现在将未配对的代码点表示为 JSON 转义序列</span>\nconsole<span>.</span><span>log</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>'\\uD83D'</span><span>)</span><span>)</span> <span>// \"\\ud83d\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://2ality.com/2019/01/well-formed-stringify.html\" target=\"_blank\" rel=\"noopener noreferrer\">Well-formed JSON.stringify</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-02-09T09:54:26.000Z",
      "date_modified": "2022-02-09T09:54:26.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Object.fromEntries()",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es10-object/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es10-object/",
      "content_html": "<h1 id=\"object-fromentries\"> Object.fromEntries()</h1>\n<p>方法 Object.fromEntries() 把键值对列表转换为一个对象，这个方法是和 Object.entries() 相对的。</p>\n<div><pre><code>Object<span>.</span><span>fromEntries</span><span>(</span><span>[</span>\n  <span>[</span><span>'foo'</span><span>,</span> <span>1</span><span>]</span><span>,</span>\n  <span>[</span><span>'bar'</span><span>,</span> <span>2</span><span>]</span>\n<span>]</span><span>)</span>\n<span>// {foo: 1, bar: 2}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"案例-1-object-转换操作\"> 案例 1：Object 转换操作</h2>\n<div><pre><code><span>const</span> obj <span>=</span> <span>{</span>\n  name<span>:</span> <span>'zhangsan'</span><span>,</span>\n  age<span>:</span> <span>13</span>\n<span>}</span>\n<span>const</span> entries <span>=</span> Object<span>.</span><span>entries</span><span>(</span>obj<span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>entries<span>)</span>\n<span>// [Array(2), Array(2)]</span>\n\n<span>// ES10</span>\n<span>const</span> fromEntries <span>=</span> Object<span>.</span><span>fromEntries</span><span>(</span>entries<span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>fromEntries<span>)</span>\n<span>// {name: 'zhangsan', age: 13}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id=\"案例-2-map-转-object\"> 案例 2：Map 转 Object</h2>\n<div><pre><code><span>const</span> map <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span>\nmap<span>.</span><span>set</span><span>(</span><span>'name'</span><span>,</span> <span>'zhangsan'</span><span>)</span>\nmap<span>.</span><span>set</span><span>(</span><span>'age'</span><span>,</span> <span>13</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>map<span>)</span>\n<span>// {'name' => 'zhangsan', 'age' => 13}</span>\n\n<span>const</span> obj <span>=</span> Object<span>.</span><span>fromEntries</span><span>(</span>map<span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>obj<span>)</span>\n<span>// {name: 'zhangsan', age: 13}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id=\"案例-3-过滤\"> 案例 3：过滤</h2>\n<p>course 表示所有课程，想请求课程分数大于 80 的课程组成的对象：</p>\n<div><pre><code><span>const</span> course <span>=</span> <span>{</span>\n  math<span>:</span> <span>80</span><span>,</span>\n  english<span>:</span> <span>85</span><span>,</span>\n  chinese<span>:</span> <span>90</span>\n<span>}</span>\n<span>const</span> res <span>=</span> Object<span>.</span><span>entries</span><span>(</span>course<span>)</span><span>.</span><span>filter</span><span>(</span><span>(</span><span><span>[</span>key<span>,</span> val<span>]</span></span><span>)</span> <span>=></span> val <span>></span> <span>80</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>res<span>)</span>\n<span>// [Array(2), Array(2)]</span>\nconsole<span>.</span><span>log</span><span>(</span>Object<span>.</span><span>fromEntries</span><span>(</span>res<span>)</span><span>)</span>\n<span>// {english: 85, chinese: 90}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://github.com/tc39/proposal-object-from-entries\" target=\"_blank\" rel=\"noopener noreferrer\">proposal-object-from-entries</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-02-08T07:46:18.000Z",
      "date_modified": "2022-02-08T07:46:18.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "可选链 Optional chaining",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es11-chaining/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es11-chaining/",
      "content_html": "<h1 id=\"可选链-optional-chaining\"> 可选链 Optional chaining</h1>\n<p>可让我们在查询具有多层级的对象时，不再需要进行冗余的各种前置校验。</p>\n<div><pre><code><span>const</span> user <span>=</span> <span>{</span>\n  address<span>:</span> <span>{</span>\n    street<span>:</span> <span>'xx街道'</span><span>,</span>\n    <span>getNum</span><span>(</span><span>)</span> <span>{</span>\n      <span>return</span> <span>'80号'</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>在之前的语法中，想获取到深层属性或方法，不得不做的前置校验，否则很容易命中 <code>Uncaught TypeError: Cannot read property...</code> 这种错误，这极有可能让你整个应用挂掉。</p>\n<div><pre><code><span>const</span> street <span>=</span> user <span>&amp;&amp;</span> user<span>.</span>address <span>&amp;&amp;</span> user<span>.</span>address<span>.</span>street\n<span>const</span> num <span>=</span> user <span>&amp;&amp;</span> user<span>.</span>address <span>&amp;&amp;</span> user<span>.</span>address<span>.</span>getNum <span>&amp;&amp;</span> user<span>.</span>address<span>.</span><span>getNum</span><span>(</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>street<span>,</span> num<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>用了 Optional Chaining ，上面代码会变成：</p>\n<div><pre><code><span>const</span> street2 <span>=</span> user<span>?.</span>address<span>?.</span>street\n<span>const</span> num2 <span>=</span> user<span>?.</span>address<span>?.</span>getNum<span>?.</span><span>(</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>street2<span>,</span> num2<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可选链中的 <code>?.</code> 表示如果问号左边表达式有值，就会继续查询问号后面的字段。如果为 <code>null</code> 或者 <code>undefined</code>，该表达式的短路返回值是 <code>undefined</code>。</p>\n<p>根据上面可以看出，用可选链可以大量简化类似繁琐的前置校验操作，而且更安全。</p>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Optional_chaining\" target=\"_blank\" rel=\"noopener noreferrer\">Optional chaining</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-02-26T02:23:37.000Z",
      "date_modified": "2022-02-26T02:23:37.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "BigInt",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es11-bigint/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es11-bigint/",
      "content_html": "<h1 id=\"bigint\"> BigInt</h1>\n<h2 id=\"介绍\"> 介绍</h2>\n<p>在 ES11 增加了新的原始数据类型：BigInt，表示一个任意精度的整数，可以表示超长数据，可以超出 2 的 53 次方。</p>\n<p>JS 中 Number 类型只能安全的表示 -(2^53-1) 至 2^53-1 范围的值</p>\n<div><pre><code>console<span>.</span><span>log</span><span>(</span><span>2</span> <span>**</span> <span>53</span><span>)</span>                 <span>// es7 幂运算符</span>\nconsole<span>.</span><span>log</span><span>(</span>Number<span>.</span><span>MAX_SAFE_INTEGER</span><span>)</span> <span>// 最大值 - 1</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>使用 BigInt 有两种方式：</p>\n<h3 id=\"方式一-数字后面增加-n\"> 方式一：数字后面增加 n</h3>\n<div><pre><code><span>const</span> bigInt <span>=</span> <span>9007199254740993n</span>\nconsole<span>.</span><span>log</span><span>(</span>bigInt<span>)</span>\nconsole<span>.</span><span>log</span><span>(</span><span>typeof</span> bigInt<span>)</span> <span>// bigint</span>\n\nconsole<span>.</span><span>log</span><span>(</span><span>1n</span> <span>==</span> <span>1</span><span>)</span>  <span>// true</span>\nconsole<span>.</span><span>log</span><span>(</span><span>1n</span> <span>===</span> <span>1</span><span>)</span> <span>// false</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"方式二-使用-bigint-函数\"> 方式二：使用 BigInt 函数</h3>\n<div><pre><code><span>const</span> bigIntNum <span>=</span> <span>BigInt</span><span>(</span><span>9007199254740993n</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>bigIntNum<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt\" target=\"_blank\" rel=\"noopener noreferrer\">BigInt</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-02-25T13:44:05.000Z",
      "date_modified": "2022-02-25T13:44:05.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "String 扩展",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es10-string/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es10-string/",
      "content_html": "<h1 id=\"string-扩展\"> String 扩展</h1>\n<h2 id=\"string-prototype-trimstart\"> String.prototype.trimStart()</h2>\n<p>trimStart() 方法从字符串的开头删除空格，trimLeft() 是此方法的别名。</p>\n<p><strong>语法</strong></p>\n<blockquote>\n<p>str.trimStart()</p>\n</blockquote>\n<p>或</p>\n<blockquote>\n<p>str.trimLeft()</p>\n</blockquote>\n<div><p>提示</p>\n<p>虽然 trimLeft 是 trimStart 的别名，但是你会发现 String.prototype.trimLeft.name === 'trimStart'，一定要记住。</p>\n</div>\n<p><strong>示例</strong></p>\n<div><pre><code><span>let</span> str <span>=</span> <span>'   foo  '</span>\nconsole<span>.</span><span>log</span><span>(</span>str<span>.</span>length<span>)</span> <span>// 8</span>\nstr <span>=</span> str<span>.</span><span>trimStart</span><span>(</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>str<span>.</span>length<span>)</span> <span>// 5</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"string-prototype-trimend\"> String.prototype.trimEnd()</h2>\n<p>trimEnd() 方法从一个字符串的右端移除空白字符，trimRight 是 trimEnd 的别名。</p>\n<p><strong>语法</strong></p>\n<blockquote>\n<p>str.trimEnd()</p>\n</blockquote>\n<p>或</p>\n<blockquote>\n<p>str.trimRight()</p>\n</blockquote>\n<div><p>提示</p>\n<p>虽然 trimRight 是 trimEnd 的别名，但是你会发现 String.prototype.trimRight.name === 'trimEnd'，一定要记住。</p>\n</div>\n<p><strong>示例</strong></p>\n<div><pre><code><span>let</span> str <span>=</span> <span>'   foo  '</span>\nconsole<span>.</span><span>log</span><span>(</span>str<span>.</span>length<span>)</span> <span>// 8</span>\nstr <span>=</span> str<span>.</span><span>trimEnd</span><span>(</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>str<span>.</span>length<span>)</span> <span>// 6</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>（完）</p>\n",
      "date_published": "2022-02-08T08:08:53.000Z",
      "date_modified": "2022-02-08T08:08:53.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Promise.allSettled()",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es11-promise/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es11-promise/",
      "content_html": "<h1 id=\"promise-allsettled\"> Promise.allSettled()</h1>\n<p>ES6 的新特性中，Promise.all() 具有并发执行异步任务的能力。但它的最大问题就是如果其中某个任务出现异常（reject），所有任务都会挂掉，Promise 直接进入 reject 状态。</p>\n<p>场景：现在页面上有三个请求，分别请求不同的数据，如果一个接口服务异常，整个都是失败的，都无法渲染出数据。</p>\n<div><pre><code>Promise<span>.</span><span>all</span><span>(</span><span>[</span>\n  Promise<span>.</span><span>reject</span><span>(</span><span>{</span>\n    code<span>:</span> <span>500</span><span>,</span>\n    msg<span>:</span> <span>'服务异常'</span>\n  <span>}</span><span>)</span><span>,</span>\n  Promise<span>.</span><span>resolve</span><span>(</span><span>{</span>\n    code<span>:</span> <span>200</span><span>,</span>\n    data<span>:</span> <span>[</span><span>'1'</span><span>,</span> <span>'2'</span><span>,</span> <span>'3'</span><span>]</span>\n  <span>}</span><span>)</span><span>,</span>\n  Promise<span>.</span><span>resolve</span><span>(</span><span>{</span>\n    code<span>:</span> <span>200</span><span>,</span>\n    data<span>:</span> <span>[</span><span>'4'</span><span>,</span> <span>'5'</span><span>,</span> <span>'6'</span><span>]</span>\n  <span>}</span><span>)</span>\n<span>]</span><span>)</span><span>.</span><span>then</span><span>(</span><span>res</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>res<span>)</span>\n  console<span>.</span><span>log</span><span>(</span><span>'成功'</span><span>)</span>\n<span>}</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>err</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>err<span>)</span>\n  console<span>.</span><span>log</span><span>(</span><span>'失败'</span><span>)</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>我们需要一种机制，如果并发任务中，无论一个任务正常或者异常，都会返回对应的的状态。</p>\n<div><pre><code>Promise<span>.</span><span>allSettled</span><span>(</span><span>[</span>\n  Promise<span>.</span><span>reject</span><span>(</span><span>{</span>\n    code<span>:</span> <span>500</span><span>,</span>\n    msg<span>:</span> <span>'服务异常'</span>\n  <span>}</span><span>)</span><span>,</span>\n  Promise<span>.</span><span>resolve</span><span>(</span><span>{</span>\n    code<span>:</span> <span>200</span><span>,</span>\n    data<span>:</span> <span>[</span><span>'1'</span><span>,</span> <span>'2'</span><span>,</span> <span>'3'</span><span>]</span>\n  <span>}</span><span>)</span><span>,</span>\n  Promise<span>.</span><span>resolve</span><span>(</span><span>{</span>\n    code<span>:</span> <span>200</span><span>,</span>\n    data<span>:</span> <span>[</span><span>'4'</span><span>,</span> <span>'5'</span><span>,</span> <span>'6'</span><span>]</span>\n  <span>}</span><span>)</span>\n<span>]</span><span>)</span><span>.</span><span>then</span><span>(</span><span>res</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>res<span>)</span>\n  <span>// console.log('成功')</span>\n  <span>const</span> data <span>=</span> res<span>.</span><span>filter</span><span>(</span><span>item</span> <span>=></span> item<span>.</span>status <span>===</span> <span>'fulfilled'</span><span>)</span>\n  console<span>.</span><span>log</span><span>(</span>data<span>)</span>\n<span>}</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>err</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>err<span>)</span>\n  console<span>.</span><span>log</span><span>(</span><span>'失败'</span><span>)</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled\" target=\"_blank\" rel=\"noopener noreferrer\">Promise.allSettled()</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-02-25T13:50:11.000Z",
      "date_modified": "2022-02-25T13:50:11.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "动态引入",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es11-dynamic-import/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es11-dynamic-import/",
      "content_html": "<h1 id=\"动态引入\"> 动态引入</h1>\n<p>动态 import 提案几年前就已提出，如今已经进入 ES 正式规范。这里理解成「按需」更为贴切。</p>\n<p>现代前端打包资源越来越大，打包成几 M 的 JS 资源已成常态，而往往前端应用初始化时根本不需要全量加载逻辑资源，为了首屏渲染速度更快，很多时候都是按需加载，比如懒加载图片等。而这些按需执行逻辑资源都体现在某一个事件回调中去加载。</p>\n<h2 id=\"案例\"> 案例</h2>\n<p>页面上有一个按钮，点击按钮才去加载 ajax 模块。</p>\n<div><pre><code><span>const</span> oBtn <span>=</span> document<span>.</span><span>querySelector</span><span>(</span><span>'#btn'</span><span>)</span>\noBtn<span>.</span><span>addEventListener</span><span>(</span><span>'click'</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>import</span><span>(</span><span>'./ajax'</span><span>)</span><span>.</span><span>then</span><span>(</span><span>mod</span> <span>=></span> <span>{</span>\n    <span>// console.log(mod)</span>\n    mod<span>.</span><span>default</span><span>(</span><span>'static/a.json'</span><span>,</span> <span>res</span> <span>=></span> <span>{</span>\n      console<span>.</span><span>log</span><span>(</span>res<span>)</span>\n    <span>}</span><span>)</span>\n  <span>}</span><span>)</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>Webpack 目前已很好的支持了该特性。Vue 中也已使用 Dynamic Import 实现组件的动态导入。</p>\n<p>（完）</p>\n",
      "date_published": "2022-02-25T13:44:05.000Z",
      "date_modified": "2022-02-25T13:44:05.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "新的逻辑操作符",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es12-logical/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es12-logical/",
      "content_html": "<h1 id=\"新的逻辑操作符\"> 新的逻辑操作符</h1>\n<p>新特性结合了逻辑运算符（<code>&amp;&amp;</code>，<code>||</code>，<code>??</code>）和赋值表达式：</p>\n<h2 id=\"逻辑与赋值\"> 逻辑与赋值</h2>\n<p>逻辑与赋值运算符（<code>x &amp;&amp;= y</code>）仅在 <code>x</code> 为<a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy\" target=\"_blank\" rel=\"noopener noreferrer\">真值</a>（在 Boolean 上下文中认定为 <code>true</code> 的值）时赋值。</p>\n<div><pre><code>x <span>&amp;&amp;=</span> y\n<span>//等价于</span>\nx <span>=</span> x <span>&amp;&amp;</span> <span>(</span>x <span>=</span> y<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"逻辑或赋值\"> 逻辑或赋值</h2>\n<p>逻辑或赋值运算符（<code>x ||= y</code>）仅在 <code>x</code> 为<a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy\" target=\"_blank\" rel=\"noopener noreferrer\">虚值</a>（在 Boolean 上下文中认定为 <code>false</code> 的值）时赋值。</p>\n<div><pre><code>x <span>||=</span> y\n<span>//等价于</span>\nx <span>=</span> x <span>||</span> <span>(</span>x <span>=</span> y<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"逻辑空赋值\"> 逻辑空赋值</h2>\n<p>逻辑空赋值运算符（<code>x ??= y</code>）仅在 <code>x</code> 是 nullish（<code>null</code> 或 <code>undefined</code>）时对其赋值。</p>\n<div><pre><code>x <span>??=</span> y\n<span>//等价于</span>\nx <span>=</span> x <span>??</span> <span>(</span>x <span>=</span> y<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Logical_AND_assignment\" target=\"_blank\" rel=\"noopener noreferrer\">逻辑与赋值（<code>&amp;&amp;=</code>）</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Logical_OR_assignment\" target=\"_blank\" rel=\"noopener noreferrer\">逻辑或赋值（<code>||=</code>）</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Logical_nullish_assignment\" target=\"_blank\" rel=\"noopener noreferrer\">逻辑空赋值（<code>??=</code>）</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-02-28T14:09:51.000Z",
      "date_modified": "2022-02-28T14:09:51.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "globalThis",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es11-globalthis/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es11-globalthis/",
      "content_html": "<h1 id=\"globalthis\"> globalThis</h1>\n<p>Javascript 在不同的环境获取全局对象有不通的方式：</p>\n<ul>\n<li>node 中通过 <code>global</code></li>\n<li>web 中通过 <code>window</code>，<code>self</code> 等</li>\n</ul>\n<div><p>提示</p>\n<p><code>self</code>：打开任何一个网页，浏览器会首先创建一个窗口，这个窗口就是一个 <code>window</code> 对象，也是 JS 运行所依附的全局环境对象和全局作用域对象。</p>\n<p><code>self</code> 指窗口本身，它返回的对象跟 <code>window</code> 对象是一模一样的。也正因为如此，<code>window</code> 对象的常用方法和函数都可以用 <code>self</code> 代替 <code>window</code>。</p>\n</div>\n<div><pre><code>self<span>.</span><span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'hello world'</span><span>)</span>\n<span>}</span><span>,</span> <span>1000</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>以前想要获取全局对象，可通过一个全局函数：</p>\n<div><pre><code><span>const</span> <span>getGlobal</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>if</span> <span>(</span><span>typeof</span> self <span>!==</span> <span>'undefined'</span><span>)</span> <span>{</span>\n    <span>return</span> self\n  <span>}</span>\n  <span>if</span> <span>(</span><span>typeof</span> window <span>!==</span> <span>'undefined'</span><span>)</span> <span>{</span>\n    <span>return</span> window\n  <span>}</span>\n  <span>if</span> <span>(</span><span>typeof</span> global <span>!==</span> <span>'undefined'</span><span>)</span> <span>{</span>\n    <span>return</span> global\n  <span>}</span>\n  <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>'无法找到全局对象'</span><span>)</span>\n<span>}</span>\n\n<span>const</span> globals <span>=</span> <span>getGlobal</span><span>(</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>globals<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><code>globalThis</code> 提供了一个标准的方式来获取不同环境下的全局 <code>this</code> 对象（也就是全局对象自身）。不像 <code>window</code> 或者 <code>self</code> 这些属性，它确保可以在有无窗口的各种环境下正常工作。所以，你可以安心的使用 <code>globalThis</code>，不必担心它的运行环境。为便于记忆，你只需要记住，全局作用域中的 <code>this</code> 就是 <code>globalThis</code>。</p>\n<div><pre><code>console<span>.</span><span>log</span><span>(</span>globalThis<span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"参考资料\"> 参考资料</h2>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/globalThis\" target=\"_blank\" rel=\"noopener noreferrer\">globalThis</a></p>\n<p>（完）</p>\n",
      "date_published": "2022-02-25T13:58:24.000Z",
      "date_modified": "2022-02-25T13:58:24.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "数字分隔符",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es12-number/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es12-number/",
      "content_html": "<h1 id=\"数字分隔符\"> 数字分隔符</h1>\n<p>这个新特性是为了方便程序员看代码而出现的，如果数字比较大，那么看起来就不是那么一目了然，比如下面的长数字：</p>\n<div><pre><code><span>const</span> number<span>=</span> <span>123456789</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>一眼看不出这个数字的体量到底是多大，所以 ES12 提供了数字分隔符 <code>_</code>。</p>\n<p>分隔符不仅可以分割十进制，也可以分割二净值或者十六净值的数据，非常好用。</p>\n<div><pre><code><span>const</span> number <span>=</span> <span>1_000_000_000_000</span><span>;</span>\n<span>const</span> binary <span>=</span> <span>0b1010_0101_1111_1101</span><span>;</span>\n<span>const</span> hex <span>=</span> <span>0xAF_BF_C3</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子分别代表了十进制，二进制和十六进制的数据，非常直观好用。</p>\n<p>（完）</p>\n",
      "date_published": "2022-02-27T04:22:14.000Z",
      "date_modified": "2022-02-27T04:22:14.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "String 扩展",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es11-string/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es11-string/",
      "content_html": "<h1 id=\"string-扩展\"> String 扩展</h1>\n<h2 id=\"string-prototype-matchall\"> String.prototype.matchAll()</h2>\n<p><code>matchAll()</code> 方法返回一个包含所有匹配正则表达式及分组捕获结果的迭代器。</p>\n<p><strong>语法</strong></p>\n<blockquote>\n<p>str.matchAll(regexp)</p>\n</blockquote>\n<p><strong>解释</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n<th>必选</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>regexp</td>\n<td>正则表达式对象</td>\n<td>Y</td>\n</tr>\n</tbody>\n</table>\n<div><p>注意</p>\n<ol>\n<li>如果所传参数不是一个正则表达式对象，则会隐式地使用 <code>new RegExp(obj)</code> 将其转换为一个 RegExp</li>\n<li>返回值一个迭代器，但是不可重用，结果耗尽需要再次调用方法，获取一个新的迭代器</li>\n</ol>\n</div>\n<p><strong>示例</strong></p>\n<p>假设有如下字符串，现在需要找出所有的 div 元素。</p>\n<div><pre><code><span>const</span> str <span>=</span> <span><span>`</span><span>\n  &lt;html>\n    &lt;body>\n      &lt;div>第一个div&lt;/div>\n      &lt;p>这是一个p&lt;/p>\n      &lt;span>span&lt;/span>\n      &lt;div>第二个div&lt;/div>\n    &lt;body>\n  &lt;/html>\n</span><span>`</span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"es10-之前-有三种正则全部遍历的方法\"> ES10 之前，有三种正则全部遍历的方法</h3>\n<h4 id=\"_1-regexp-prototype-exec-结合-g\"> 1）RegExp.prototype.exec() 结合 /g</h4>\n<p>可以使用 <code>exec</code> 与 <code>g</code> 修饰符来得到所有匹配项。如果正则表达式有 <code>/g</code> 标志，那么多次调用 <code>.exec()</code> 就会得到所有匹配的结果。如果没有匹配的结果，<code>.exec()</code> 就会返回 null。</p>\n<p>每个匹配到的结果会返回一个对象，这个对象包含捕获的子字符串和更多信息。</p>\n<div><pre><code><span>function</span> <span>selectDiv</span><span>(</span><span>regExp<span>,</span> str</span><span>)</span> <span>{</span>\n  <span>let</span> matches <span>=</span> <span>[</span><span>]</span>\n  <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>\n    <span>// console.log(regExp.lastIndex)</span>\n    <span>const</span> match <span>=</span> regExp<span>.</span><span>exec</span><span>(</span>str<span>)</span>\n    <span>// console.log(match)</span>\n    <span>if</span> <span>(</span>match <span>==</span> <span>null</span><span>)</span> <span>{</span>\n      <span>break</span>\n    <span>}</span>\n    matches<span>.</span><span>push</span><span>(</span>match<span>[</span><span>1</span><span>]</span><span>)</span>\n  <span>}</span>\n  <span>return</span> matches\n<span>}</span>\n\n<span>const</span> regExp <span>=</span> <span><span>/</span><span>&lt;div>(.*)&lt;\\/div></span><span>/</span><span>g</span></span>\n<span>const</span> res <span>=</span> <span>selectDiv</span><span>(</span>regExp<span>,</span> str<span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>res<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h4 id=\"_2-string-prototype-match-结合-g\"> 2）String.prototype.match() 结合 /g</h4>\n<p>如果用 <code>.match</code> 方法结合 <code>/g</code> 的正则模式，将会把所有的匹配打包成一个数组返回，换句话说所有的捕获被忽略。</p>\n<div><pre><code><span>const</span> regExp <span>=</span> <span><span>/</span><span>&lt;div>(.*)&lt;\\/div></span><span>/</span><span>g</span></span>\nconsole<span>.</span><span>log</span><span>(</span>str<span>.</span><span>match</span><span>(</span>regExp<span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><div><p>/g 作用</p>\n<p>因为正则表达式有一个 lastIndex（初始值为 0）属性，每次 <code>.exec()</code> 前，都会根据 lastIndex 属性的值来决定开始匹配的位置。</p>\n<p>如果正则表达式没有 <code>/g</code> 标志，那么运行一次 <code>.exec()</code> 时，不会改变 lastIndex 的值，导致下一次运行 <code>.exec()</code> 时，匹配仍旧是从字符串 0 的位置开始。当正则表达式加了 <code>/g</code> 标志后，运行一次 <code>exec()</code>，正则表达式的 lastIndex 就会改变，下次运行 <code>exec()</code> 就会从前一次的结果之后开始匹配。</p>\n<p>不过如果没有使用 <code>/g</code> 的正则模式，<code>.match</code> 的效果和 <code>RegExp.prototype.exec()</code> 是一致的。</p>\n</div>\n<h4 id=\"_3-string-prototype-replace\"> 3）String.prototype.replace()</h4>\n<p>可以使用一个技巧，通过 <code>.replace()</code> 收集捕获（第二个参数使用一个函数，在函数内部统计匹配值）。</p>\n<div><pre><code><span>function</span> <span>selectDiv</span><span>(</span><span>regExp<span>,</span> str</span><span>)</span> <span>{</span>\n  <span>let</span> matches <span>=</span> <span>[</span><span>]</span>\n  str<span>.</span><span>replace</span><span>(</span>regExp<span>,</span> <span>(</span><span>all<span>,</span> first</span><span>)</span> <span>=></span> <span>{</span>\n    matches<span>.</span><span>push</span><span>(</span>first<span>)</span>\n  <span>}</span><span>)</span>\n  <span>return</span> matches\n<span>}</span>\n\n<span>const</span> regExp <span>=</span> <span><span>/</span><span>&lt;div>(.*)&lt;\\/div></span><span>/</span><span>g</span></span>\n<span>const</span> res <span>=</span> <span>selectDiv</span><span>(</span>regExp<span>,</span> str<span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>res<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"es10-使用-matchall-全部遍历\"> ES10，使用 matchAll 全部遍历</h3>\n<p>使用 <code>.matchAll</code> 方法：</p>\n<div><pre><code><span>function</span> <span>selectDiv</span><span>(</span><span>regExp<span>,</span> str</span><span>)</span> <span>{</span>\n  <span>let</span> matches <span>=</span> <span>[</span><span>]</span>\n  <span>for</span> <span>(</span><span>let</span> match <span>of</span> str<span>.</span><span>matchAll</span><span>(</span>regExp<span>)</span><span>)</span> <span>{</span>\n    matches<span>.</span><span>push</span><span>(</span>match<span>[</span><span>1</span><span>]</span><span>)</span>\n  <span>}</span>\n  <span>return</span> matches\n<span>}</span>\n\n<span>const</span> regExp <span>=</span> <span><span>/</span><span>&lt;div>(.*)&lt;\\/div></span><span>/</span><span>g</span></span>\n<span>const</span> res <span>=</span> <span>selectDiv</span><span>(</span>regExp<span>,</span> str<span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>res<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll\" target=\"_blank\" rel=\"noopener noreferrer\">String.prototype.matchAll()</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace\" target=\"_blank\" rel=\"noopener noreferrer\">String.prototype.replace()</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-02-24T15:58:46.000Z",
      "date_modified": "2022-02-24T15:58:46.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Promise.any() 和 AggregateError",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es12-promise/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es12-promise/",
      "content_html": "<h1 id=\"promise-any-和-aggregateerror\"> Promise.any() 和 AggregateError</h1>\n<p>Promise.any() 接收一个 Promise 可迭代对象，只要其中的一个 promise 提前成功，就直接返回那个已经成功的 promise。</p>\n<p>如果可迭代对象中没有一个 promise 成功（即所有的 promise 都失败/拒绝），就返回一个失败的 promise 和 AggregateError 类型的实例（它是 Error 的一个子类，用于把单一的错误集合在一起）。</p>\n<p>本质上，这个方法和 Promise.all() 是相反的。</p>\n<h2 id=\"举例演示\"> 举例演示</h2>\n<div><pre><code><span>const</span> p1 <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>setTimeout</span><span>(</span>\n    <span>(</span><span>)</span> <span>=></span> <span>resolve</span><span>(</span><span>\"promise one\"</span><span>)</span><span>,</span>\n    Math<span>.</span><span>floor</span><span>(</span>Math<span>.</span><span>random</span><span>(</span><span>)</span> <span>*</span> <span>100</span><span>)</span>\n  <span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n<span>const</span> p2 <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>setTimeout</span><span>(</span>\n    <span>(</span><span>)</span> <span>=></span> <span>resolve</span><span>(</span><span>\"promise two\"</span><span>)</span><span>,</span>\n    Math<span>.</span><span>floor</span><span>(</span>Math<span>.</span><span>random</span><span>(</span><span>)</span> <span>*</span> <span>100</span><span>)</span>\n  <span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n<span>const</span> p3 <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>setTimeout</span><span>(</span>\n    <span>(</span><span>)</span> <span>=></span> <span>resolve</span><span>(</span><span>\"promise three\"</span><span>)</span><span>,</span>\n    Math<span>.</span><span>floor</span><span>(</span>Math<span>.</span><span>random</span><span>(</span><span>)</span> <span>*</span> <span>100</span><span>)</span>\n  <span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n\n<span>(</span><span>async</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n  <span>const</span> result <span>=</span> <span>await</span> Promise<span>.</span><span>any</span><span>(</span><span>[</span>p1<span>,</span> p2<span>,</span> p3<span>]</span><span>)</span><span>;</span>\n  console<span>.</span><span>log</span><span>(</span>result<span>)</span><span>;</span> \n<span>}</span><span>)</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>上述代码可以随机输出 <code>promise one</code>，<code>promise two</code>，<code>promise three</code>。</p>\n<p>如果将上述代码改成所有的都 reject，那么会抛出 AggregateError：</p>\n<div><pre><code><span>const</span> p1 <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>setTimeout</span><span>(</span>\n    <span>(</span><span>)</span> <span>=></span> <span>reject</span><span>(</span><span>\"promise one rejected\"</span><span>)</span><span>,</span>\n    Math<span>.</span><span>floor</span><span>(</span>Math<span>.</span><span>random</span><span>(</span><span>)</span> <span>*</span> <span>100</span><span>)</span>\n  <span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n<span>const</span> p2 <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>setTimeout</span><span>(</span>\n    <span>(</span><span>)</span> <span>=></span> <span>reject</span><span>(</span><span>\"promise two rejected\"</span><span>)</span><span>,</span>\n    Math<span>.</span><span>floor</span><span>(</span>Math<span>.</span><span>random</span><span>(</span><span>)</span> <span>*</span> <span>100</span><span>)</span>\n  <span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n<span>const</span> p3 <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>setTimeout</span><span>(</span>\n    <span>(</span><span>)</span> <span>=></span> <span>reject</span><span>(</span><span>\"promise three rejected\"</span><span>)</span><span>,</span>\n    Math<span>.</span><span>floor</span><span>(</span>Math<span>.</span><span>random</span><span>(</span><span>)</span> <span>*</span> <span>100</span><span>)</span>\n  <span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n\n<span>try</span><span>{</span>\n<span>(</span><span>async</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n  <span>const</span> result <span>=</span> <span>await</span> Promise<span>.</span><span>any</span><span>(</span><span>[</span>p1<span>,</span> p2<span>,</span> p3<span>]</span><span>)</span><span>;</span>\n  console<span>.</span><span>log</span><span>(</span>result<span>)</span><span>;</span> \n<span>}</span><span>)</span><span>(</span><span>)</span><span>;</span>\n<span>}</span> <span>catch</span><span>(</span>error<span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>error<span>.</span>errors<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>报的错如下：</p>\n<div><pre><code>Uncaught <span>(</span>in promise<span>)</span> AggregateError: All promises were rejected\n</code></pre>\n<div><span>1</span><br></div></div><p>注意，必须是所有的 promise 都被 reject 之后才会抛出 AggregateError，如果有部分成功，那么将会返回成功的结果。</p>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/any\" target=\"_blank\" rel=\"noopener noreferrer\">Promise.any()</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/AggregateError\" target=\"_blank\" rel=\"noopener noreferrer\">AggregateError</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-02-26T03:38:30.000Z",
      "date_modified": "2022-02-26T03:38:30.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "String 扩展",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es12-string/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es12-string/",
      "content_html": "<h1 id=\"string-扩展\"> String 扩展</h1>\n<h2 id=\"string-prototype-replaceall\"> String.prototype.replaceAll()</h2>\n<p><code>replaceAll()</code> 方法返回一个全新的字符串，所有符合匹配规则的字符都将被替换掉。</p>\n<p><strong>语法</strong></p>\n<blockquote>\n<p>const newStr = str.replaceAll(regexp|substr, newSubstr|function)</p>\n</blockquote>\n<p>第一个参数（匹配项）可以是一个字符串或者一个正则表达式，第二个参数（替换值）可以是一个字符串或者一个每次匹配都要调用的回调函数，这点和 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace\" target=\"_blank\" rel=\"noopener noreferrer\">replace()</a> 方法是一样的。</p>\n<p><strong>示例</strong></p>\n<div><pre><code><span>const</span> str <span>=</span> <span>'PHP is the best language, I love the PHP, are you interested in PHP?'</span><span>;</span>\n<span>const</span> newStr <span>=</span> str<span>.</span><span>replaceAll</span><span>(</span><span>'PHP'</span><span>,</span> <span>'JavaScript'</span><span>)</span><span>;</span> \nconsole<span>.</span><span>log</span><span>(</span>newStr<span>)</span><span>;</span>\n<span>// \"JavaScript is the best language, I love the JavaScript, are you interested in JavaScript?\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll\" target=\"_blank\" rel=\"noopener noreferrer\">String.prototype.replaceAll()</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-02-26T02:57:21.000Z",
      "date_modified": "2022-02-26T02:57:21.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "类私有域",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es12-private-class-fields/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es12-private-class-fields/",
      "content_html": "<h1 id=\"类私有域\"> 类私有域</h1>\n<p>类属性和类方法在默认情况下是公有的，但可以通过增加 <code>#</code> 前缀的方法来定义私有类字段，这样标识后的私有字段只能在类内部调用，外部无法访问到。</p>\n<h2 id=\"私有属性\"> 私有属性</h2>\n<p>通常，对于属性，我们能以 <code>get</code> 修饰符来进行修饰，然后就可以直接通过属性名来访问了：</p>\n<div><pre><code><span>class</span> <span>Student</span> <span>{</span>\n  <span>get</span> <span>age</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>18</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\nstudent<span>=</span> <span>new</span> <span>Student</span><span>(</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>student<span>.</span>age<span>)</span><span>;</span> <span>// 18</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>在属性名前面加上 <code>#</code>，让其变成私有变量，如下所示：</p>\n<div><pre><code><span>class</span> <span>Student</span> <span>{</span>\n  <span>get</span> <span>#age</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>18</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\nstudent<span>=</span> <span>new</span> <span>Student</span><span>(</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>student<span>.</span>age<span>)</span><span>;</span> <span>// undefined</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>要想访问上述的私有属性，则可以用公有属性去调用私有属性方法：</p>\n<div><pre><code><span>class</span> <span>Student</span> <span>{</span>\n  <span>get</span> <span>#age</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>18</span><span>;</span>\n  <span>}</span>\n   <span>get</span> <span>publicAge</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span>#age\n  <span>}</span>\n<span>}</span>\n\nstudent<span>=</span> <span>new</span> <span>Student</span><span>(</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>student<span>.</span>publicAge<span>)</span><span>;</span> <span>// 18</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id=\"私有方法\"> 私有方法</h2>\n<p>通常类中定义的方法，在通过实例化之后就可以直接进行调用，如下所示：</p>\n<div><pre><code><span>class</span> <span>Student</span> <span>{</span>\n  <span>getAge</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>\"永远18岁\"</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n\nstudent<span>=</span> <span>new</span> <span>Student</span><span>(</span><span>)</span><span>;</span>\nstudent<span>.</span><span>getAge</span><span>(</span><span>)</span><span>;</span> <span>// \"永远18岁\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>但是如果我们不希望 <code>getAge()</code> 方法直接暴露给外部使用，那么只需要在方法前面加上 <code>#</code> 就可以把它变成一个私有方法。</p>\n<div><pre><code><span>class</span> <span>Student</span> <span>{</span>\n  <span>#getAge</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>\"永远18岁\"</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n\nstudent<span>=</span> <span>new</span> <span>Student</span><span>(</span><span>)</span><span>;</span>\nstudent<span>.</span><span>getAge</span><span>(</span><span>)</span><span>;</span> <span>// Uncaught TypeError: student.getAge is not a function</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>用以前的方式调用类的私有方法会报错。怎么处理呢？我们知道私有方法是可以在方法内部调用的，那么只需要创建一个公有方法，然后在这个公有方法中调用私有方法即可，如下所示：</p>\n<div><pre><code><span>class</span> <span>Student</span> <span>{</span>\n  <span>#getAge</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>\"永远18岁\"</span><span>)</span>\n  <span>}</span>\n  \n  <span>getPublicAge</span><span>(</span><span>)</span><span>{</span>\n    <span>this</span><span>.</span><span>#getAge</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\nstudent<span>=</span> <span>new</span> <span>Student</span><span>(</span><span>)</span><span>;</span>\nstudent<span>.</span><span>getPublicAge</span><span>(</span><span>)</span><span>;</span> <span>// \"永远18岁\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>总的来说，类私有域这个新特性很好用。</p>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/Private_class_fields\" target=\"_blank\" rel=\"noopener noreferrer\">类私有域</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-02-26T03:29:27.000Z",
      "date_modified": "2022-02-26T03:29:27.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Class",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es6-class/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es6-class/",
      "content_html": "<h1 id=\"class\"> Class</h1>\n<p>对于面向对象编程而言，主要关注类的声明、属性、方法、静态方法、继承、多态、私有属性。</p>\n<h2 id=\"声明类\"> 声明类</h2>\n<p>ES6 之前类是通过构造函数来实现的：</p>\n<div><pre><code><span>let</span> <span>Animal</span> <span>=</span> <span>function</span><span>(</span><span>type</span><span>)</span> <span>{</span>\n  <span>this</span><span>.</span>type <span>=</span> type\n  <span>this</span><span>.</span><span>walk</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'I am walking'</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>let</span> dog <span>=</span> <span>new</span> <span>Animal</span><span>(</span><span>'dog'</span><span>)</span>\n<span>let</span> monkey <span>=</span> <span>new</span> <span>Animal</span><span>(</span><span>'monkey'</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>或者可以这样写：</p>\n<div><pre><code><span>let</span> <span>Animal</span> <span>=</span> <span>function</span><span>(</span><span>type</span><span>)</span> <span>{</span>\n  <span>this</span><span>.</span>type <span>=</span> type\n<span>}</span>\n\n<span>Animal</span><span>.</span>prototype<span>.</span><span>walk</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'I am walking'</span><span>)</span>\n<span>}</span>\n\n<span>let</span> dog <span>=</span> <span>new</span> <span>Animal</span><span>(</span><span>'dog'</span><span>)</span>\n<span>let</span> monkey <span>=</span> <span>new</span> <span>Animal</span><span>(</span><span>'monkey'</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>上面这两种写法跟传统的面向对象语言差异很大，很容易让新学习这门语言的程序员感到困惑。</p>\n<p>在 ES6 中把类的声明专业化了，通过 class 语法来代替 function 的方式:</p>\n<div><pre><code><span>class</span> <span>Animal</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>type</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>type <span>=</span> type\n  <span>}</span>\n  <span>walk</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'I am walking'</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>let</span> dog <span>=</span> <span>new</span> <span>Animal</span><span>(</span><span>'dog'</span><span>)</span>\n<span>let</span> monkey <span>=</span> <span>new</span> <span>Animal</span><span>(</span><span>'monkey'</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>这样就和其他编程语言（Java、Python）保持一致了，声明一个类时有构造函数、方法。</p>\n<p>但 <code>class</code> 不是新的数据类型，它本质上还是一个 <code>function</code>，通过观察原型可以发现，<code>Animal.prototype</code> 对象上有两个方法，一个是构造函数（<code>constructor</code>）、一个是自定义的方法（<code>walk</code>），这和上面 ES5 的第二种写法是一样的。而且和 ES5 一样，都有个 API 用来判断对象的自有属性（<code>hasOwnProperty</code>）。</p>\n<div><pre><code><span>class</span> <span>Animal</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>type</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>type <span>=</span> type\n  <span>}</span>\n  <span>walk</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'I am walking'</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n\nconsole<span>.</span><span>log</span><span>(</span><span>Animal</span><span>.</span>prototype<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>从上面代码可以看出：</p>\n<ul>\n<li>类里面有一个 <code>constructor()</code> 方法，这就是构造方法。</li>\n<li><code>this</code> 关键字指向实例对象。</li>\n<li>给类增加自定义方法的时候，前面不需要加上 <code>function</code> 关键字，直接把函数定义放进去了就可以了。另外，方法与方法之间不需要逗号分隔，加了会报错。</li>\n<li>类的所有方法（<code>constructor()</code> 和自定义方法）都定义在类的 <code>prototype</code> 属性上面，因此在类的实例上面调用方法，其实就是调用原型上的方法。</li>\n</ul>\n<p>所以可以得出结论：<code>class</code> 的方式是 <code>function</code> 方式的语法糖，它诞生的目的是让对象原型的写法更加清晰、更像面向对象编程的语法。</p>\n<h2 id=\"构造函数-constructor\"> 构造函数 constructor</h2>\n<p><code>constructor</code> 是一种用于创建和初始化 <code>class</code> 创建的对象的特殊方法。</p>\n<p>它是类的默认方法，通过 <code>new</code> 命令生成对象实例时，自动调用该方法。一个类必须有 <code>constructor()</code> 方法，如果没有显式定义，一个空的 <code>constructor()</code> 方法会被默认添加。</p>\n<div><pre><code><span>class</span> <span>Animal</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>type</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>type <span>=</span> type\n  <span>}</span>\n<span>}</span>\n\n<span>let</span> dog <span>=</span> <span>new</span> <span>Animal</span><span>(</span><span>'dog'</span><span>)</span>\n<span>let</span> monkey <span>=</span> <span>new</span> <span>Animal</span><span>(</span><span>'monkey'</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><code>constructor()</code> 方法默认返回实例对象（即 <code>this</code>），但完全可以指定返回另外一个对象。</p>\n<p>下面的代码中，<code>constructor()</code> 函数返回一个全新的对象，结果导致实例对象不是 <code>Foo</code> 类的实例。</p>\n<div><pre><code><span>class</span> <span>Foo</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> Object<span>.</span><span>create</span><span>(</span><span>null</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>new</span> <span>Foo</span><span>(</span><span>)</span> <span>instanceof</span> <span>Foo</span>\n<span>// false</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>在一个构造方法中可以使用 <code>super</code> 关键字来调用一个父类的构造方法（super 这个知识点下面单独讲）。</p>\n<h2 id=\"类的实例化\"> 类的实例化</h2>\n<p>class 的实例化必须通过 new 关键字，且类的所有实例共享一个原型对象。</p>\n<div><pre><code><span>class</span> <span>Example</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>a <span>=</span> a<span>;</span>\n    <span>this</span><span>.</span>b <span>=</span> b<span>;</span>\n    console<span>.</span><span>log</span><span>(</span><span>'Example'</span><span>)</span><span>;</span>\n  <span>}</span>\n  <span>sum</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span>a <span>+</span> <span>this</span><span>.</span>b<span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>let</span> exam1 <span>=</span> <span>new</span> <span>Example</span><span>(</span><span>2</span><span>,</span> <span>1</span><span>)</span><span>;</span>\n<span>let</span> exam2 <span>=</span> <span>new</span> <span>Example</span><span>(</span><span>3</span><span>,</span> <span>1</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>exam1<span>.</span>_proto_ <span>==</span> exam2<span>.</span>_proto_<span>)</span><span>;</span> <span>// true </span>\n\nexam1<span>.</span>_proto_<span>.</span><span>sub</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n  <span>return</span> <span>this</span><span>.</span>a <span>-</span> <span>this</span><span>.</span>b<span>;</span>\n<span>}</span>\nconsole<span>.</span><span>log</span><span>(</span>exam1<span>.</span><span>sub</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// 1 </span>\nconsole<span>.</span><span>log</span><span>(</span>exam2<span>.</span><span>sub</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// 2</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>上面代码中，<code>exam1</code> 和 <code>exam2</code> 都是 <code>Example</code> 的实例，它们的原型都是 <code>Example.prototype</code>，所以 <code>__proto__</code> 属性是相等的。</p>\n<p>这也意味着，可以通过实例的 <code>__proto__</code> 属性为「类」添加方法。</p>\n<blockquote>\n<p><code>__proto__</code> 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 <code>Object.getPrototypeOf()</code> 方法来获取实例对象的原型，然后再来为原型添加方法/属性。</p>\n</blockquote>\n<p>使用实例的 <code>__proto__</code> 属性改写原型，必须相当谨慎，不推荐使用，因为这会改变「类」的原始定义，影响到所有实例。</p>\n<h2 id=\"setters-getters\"> Setters &amp; Getters</h2>\n<p>对于类中的属性，除了可以直接在 <code>constructor</code> 中通过 <code>this</code> 直接定义，还可以直接在类的顶层来定义：</p>\n<div><pre><code><span>class</span> <span>Animal</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>type<span>,</span> age</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>type <span>=</span> type\n    <span>this</span><span>.</span>_age <span>=</span> age\n  <span>}</span>\n  <span>get</span> <span>age</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span>_age\n  <span>}</span>\n  <span>set</span> <span>age</span><span>(</span><span>val</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>_age <span>=</span> val\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>乍一看没有什么实质性用途，不过 get/set 的真正用途要体现在只读属性/私有属性上：</p>\n<ul>\n<li><code>addr</code> 是个只读属性</li>\n</ul>\n<div><pre><code><span>class</span> <span>Animal</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>type</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>type <span>=</span> type\n  <span>}</span>\n  <span>get</span> <span>addr</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>'北京动物园'</span>\n  <span>}</span>\n<span>}</span>\n\n<span>let</span> dog <span>=</span> <span>new</span> <span>Animal</span><span>(</span><span>'dog'</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>dog<span>.</span>addr<span>)</span>  <span>// \"北京动物园\"</span>\ndog<span>.</span>addr <span>=</span> <span>'上海动物园'</span>\nconsole<span>.</span><span>log</span><span>(</span>dog<span>.</span>addr<span>)</span>  <span>// \"北京动物园\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><ul>\n<li>对某个属性设置 <code>get</code> 和 <code>set</code>，拦截该属性的赋值和读取行为</li>\n</ul>\n<div><pre><code><span>class</span> <span>Animal</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>type</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>type <span>=</span> type\n  <span>}</span>\n  <span>get</span> <span>addr</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>'北京动物园'</span>\n  <span>}</span>\n  <span>set</span> <span>addr</span><span>(</span><span>value</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span><span>`</span><span>can not set addr: </span><span><span>${</span>value<span>}</span></span><span>`</span></span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>let</span> dog <span>=</span> <span>new</span> <span>Animal</span><span>(</span><span>'dog'</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>dog<span>.</span>addr<span>)</span>  <span>// \"北京动物园\"</span>\ndog<span>.</span>addr <span>=</span> <span>'上海动物园'</span> <span>// \"can not set addr: 上海动物园\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>但是如果某个属性有存值操作，那这个属性的 getter 不可单独出现：</p>\n<div><pre><code><span>class</span> <span>Animal</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>type</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>type <span>=</span> type\n  <span>}</span>\n  <span>get</span> <span>type</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span>type\n  <span>}</span>\n<span>}</span>\n\n<span>let</span> dog <span>=</span> <span>new</span> <span>Animal</span><span>(</span><span>'dog'</span><span>)</span>\n<span>// Uncaught TypeError: Cannot set property type of #&lt;Animal> which has only a getter</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>getter 与 setter 必须同级出现，否则会出现问题：</p>\n<div><pre><code><span>class</span> <span>Father</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n  <span>get</span> <span>a</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span>_a<span>;</span>\n  <span>}</span>\n<span>}</span>\n<span>class</span> <span>Child</span> <span>extends</span> <span>Father</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n  <span>set</span> <span>a</span><span>(</span><span>a</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>_a <span>=</span> a<span>;</span>\n  <span>}</span>\n<span>}</span>\n<span>let</span> child <span>=</span> <span>new</span> <span>Child</span><span>(</span><span>)</span><span>;</span>\nchild<span>.</span>a <span>=</span> <span>2</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>child<span>.</span>a<span>)</span><span>;</span> <span>// undefined</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>正确写法：创建类的时候同时声明 get 和 set，或者把 get 和 set 都放在子类中：</p>\n<div><pre><code><span>class</span> <span>Father</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n  <span>// 或者都放在子类中</span>\n  <span>get</span> <span>a</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span>_a<span>;</span>\n  <span>}</span>\n  <span>set</span> <span>a</span><span>(</span><span>a</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>_a <span>=</span> a<span>;</span>\n  <span>}</span>\n<span>}</span>\n<span>class</span> <span>Child</span> <span>extends</span> <span>Father</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n<span>let</span> child <span>=</span> <span>new</span> <span>Child</span><span>(</span><span>)</span><span>;</span>\nchild<span>.</span>a <span>=</span> <span>2</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>child<span>.</span>a<span>)</span><span>;</span> <span>// 2</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id=\"静态方法-static\"> 静态方法 static</h2>\n<blockquote>\n<p>JS 中静态方法通常是实用程序方法，例如创建或克隆对象的功能。</p>\n</blockquote>\n<p>静态方法是面向对象最常用的功能，在 ES5 中利用 function 实现的类是这样实现一个静态方法的：</p>\n<div><pre><code><span>let</span> <span>Animal</span> <span>=</span> <span>function</span><span>(</span><span>type</span><span>)</span> <span>{</span>\n  <span>this</span><span>.</span>type <span>=</span> type\n  <span>this</span><span>.</span><span>walk</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'I am walking'</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n\nAnimal<span>.</span><span>eat</span> <span>=</span> <span>function</span><span>(</span><span>food</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'I am eating'</span><span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>在 ES6 中使用 <code>static</code> 的标记是不是静态方法，这也和其他变成语言保持了一致：</p>\n<div><pre><code><span>class</span> <span>Animal</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>type</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>type <span>=</span> type\n  <span>}</span>\n  <span>walk</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'I am walking'</span><span>)</span>\n  <span>}</span>\n  <span>static</span> <span>eat</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'I am eating'</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n\nAnimal<span>.</span><span>eat</span><span>(</span><span>)</span> <span>// \"I am eating\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>不能在类的实例上调用静态方法，而应该通过类本身调用，否则会抛出一个错误，表示不存在该方法：</p>\n<div><pre><code><span>class</span> <span>Animal</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>type</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>type <span>=</span> type\n  <span>}</span>\n  <span>walk</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'I am walking'</span><span>)</span>\n  <span>}</span>\n  <span>static</span> <span>eat</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'I am eating'</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>let</span> dog <span>=</span> <span>new</span> <span>Animal</span><span>(</span><span>'dog'</span><span>)</span>\ndog<span>.</span><span>eat</span><span>(</span><span>)</span>\n<span>// Uncaught TypeError: dog.eat is not a function</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>如果静态方法包含 <code>this</code> 关键字，这个 <code>this</code> 指的是类，而不是实例。</p>\n<p>下面代码中，静态方法 <code>bar</code> 调用了 <code>this.baz</code>，这里的 <code>this</code> 指的是 <code>Foo</code> 类，而不是 <code>Foo</code> 的实例，等同于调用 <code>Foo.baz</code>。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。</p>\n<div><pre><code><span>class</span> <span>Foo</span> <span>{</span>\n  <span>static</span> <span>bar</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span><span>baz</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n  <span>static</span> <span>baz</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'hello'</span><span>)</span><span>;</span>\n  <span>}</span>\n  <span>baz</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'world'</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\nFoo<span>.</span><span>bar</span><span>(</span><span>)</span> <span>// \"hello\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>父类的静态方法，可以被子类继承。</p>\n<p>下面代码中，父类 <code>Foo</code> 有一个静态方法，子类 <code>Bar</code> 可以调用这个方法：</p>\n<div><pre><code><span>class</span> <span>Foo</span> <span>{</span>\n  <span>static</span> <span>classMethod</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>'hello'</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>Bar</span> <span>extends</span> <span>Foo</span> <span>{</span>\n<span>}</span>\n\nBar<span>.</span><span>classMethod</span><span>(</span><span>)</span> <span>// \"hello\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>静态方法也是可以从 <code>super</code> 对象上调用的：</p>\n<div><pre><code><span>class</span> <span>Foo</span> <span>{</span>\n  <span>static</span> <span>classMethod</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>'hello'</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>Bar</span> <span>extends</span> <span>Foo</span> <span>{</span>\n  <span>static</span> <span>classMethod</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>super</span><span>.</span><span>classMethod</span><span>(</span><span>)</span> <span>+</span> <span>', too'</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\nBar<span>.</span><span>classMethod</span><span>(</span><span>)</span> <span>// \"hello, too\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id=\"关键字-super\"> 关键字 super</h2>\n<p>super 关键字用于访问和调用一个对象的父对象上的函数。</p>\n<ul>\n<li>关键字 <code>super</code> 作为函数时，<code>super()</code> 只能用在子类的构造函数之中，用在其他地方就会报错。并且必须在使用 <code>this</code> 关键字之前使用。</li>\n<li>关键字 <code>super</code> 作为对象时，可以用来调用父对象上的函数。</li>\n</ul>\n<p>调用父类的构造函数：</p>\n<div><pre><code><span>class</span> <span>Polygon</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>height<span>,</span> width</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>name <span>=</span> <span>'Rectangle'</span><span>;</span>\n    <span>this</span><span>.</span>height <span>=</span> height<span>;</span>\n    <span>this</span><span>.</span>width <span>=</span> width<span>;</span>\n  <span>}</span>\n  <span>sayName</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'Hi, I am a '</span><span>,</span> <span>this</span><span>.</span>name <span>+</span> <span>'.'</span><span>)</span><span>;</span>\n  <span>}</span>\n  <span>get</span> <span>area</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span>height <span>*</span> <span>this</span><span>.</span>width<span>;</span>\n  <span>}</span>\n  <span>set</span> <span>area</span><span>(</span><span>value</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>_area <span>=</span> value<span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>Square</span> <span>extends</span> <span>Polygon</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>length</span><span>)</span> <span>{</span>\n    <span>// this.height; // 这样直接 this.height 会报错：ReferenceError，因为 super 需要先被调用！</span>\n\n    <span>// 这里 super 单独出现, 调用父类的构造函数</span>\n    <span>// 参数作为父类 Polygon 的 height, width</span>\n    <span>super</span><span>(</span>length<span>,</span> length<span>)</span><span>;</span>\n\n    <span>// 注意: 子类的 this 必须在调用 super() 之后使用</span>\n    <span>this</span><span>.</span>name <span>=</span> <span>'Square'</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>调用父类上的静态方法：</p>\n<div><pre><code><span>class</span> <span>Rectangle</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n  <span>static</span> <span>logNbSides</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>'I have 4 sides'</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>Square</span> <span>extends</span> <span>Rectangle</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span><span>)</span>\n  <span>}</span>\n  <span>static</span> <span>logDescription</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>super</span><span>.</span><span>logNbSides</span><span>(</span><span>)</span> <span>+</span> <span>' which are all equal'</span><span>;</span>\n  <span>}</span>\n<span>}</span>\nSquare<span>.</span><span>logDescription</span><span>(</span><span>)</span><span>;</span> <span>// \"I have 4 sides which are all equal\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>子类 constructor 方法中必须有 super ，且必须出现在 this 之前。</p>\n<p>错误写法 1：</p>\n<div><pre><code><span>class</span> <span>Father</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n<span>}</span>\n<span>class</span> <span>Child</span> <span>extends</span> <span>Father</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n<span>}</span>\n<span>let</span> test <span>=</span> <span>new</span> <span>Child</span><span>(</span><span>)</span><span>;</span>\n<span>// Uncaught ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>错误写法 2：</p>\n<div><pre><code><span>class</span> <span>Father</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n<span>}</span>\n<span>class</span> <span>Child</span> <span>extends</span> <span>Father</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>a</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>a <span>=</span> a<span>;</span>\n    <span>super</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n<span>let</span> test <span>=</span> <span>new</span> <span>Child</span><span>(</span><span>)</span><span>;</span>\n<span>// Uncaught ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>关键字 <code>super</code> 作为函数时，<code>super()</code> 只能出现在子类的构造函数里用于调用父类构造函数，用在其他地方就会报错。</p>\n<p>错误写法：</p>\n<div><pre><code><span>class</span> <span>Father</span> <span>{</span>\n  <span>test</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>0</span><span>;</span>\n  <span>}</span>\n  <span>static</span> <span>test1</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>1</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n<span>class</span> <span>Child1</span> <span>extends</span> <span>Father</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n<span>class</span> <span>Child2</span> <span>extends</span> <span>Father</span> <span>{</span>\n  <span>test2</span><span>(</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span><span>)</span><span>;</span> <span>// Uncaught SyntaxError: 'super' keyword unexpected     </span>\n    <span>// here</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>关键字 <code>super</code> 作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p>\n<div><pre><code><span>class</span> <span>Father</span> <span>{</span>\n  <span>test</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>0</span><span>;</span>\n  <span>}</span>\n  <span>static</span> <span>test1</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>1</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n<span>class</span> <span>Child</span> <span>extends</span> <span>Father</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span><span>{</span>\n    <span>super</span><span>(</span><span>)</span><span>;</span>\n    <span>// 调用父类普通方法</span>\n    console<span>.</span><span>log</span><span>(</span><span>super</span><span>.</span><span>test</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// 0</span>\n  <span>}</span>\n  <span>static</span> <span>test3</span><span>(</span><span>)</span> <span>{</span>\n    <span>// 调用父类静态方法</span>\n    <span>return</span> <span>super</span><span>.</span><span>test1</span><span>(</span><span>)</span> <span>+</span> <span>2</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\nChild<span>.</span><span>test3</span><span>(</span><span>)</span><span>;</span> <span>// 3</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h2 id=\"继承-extends\"> 继承 extends</h2>\n<p>面向对象之所以可以应对复杂的项目实现，很大程度上要归功于继承。在 ES5 中是这样实现继承的：</p>\n<div><pre><code><span>// 定义父类</span>\n<span>let</span> <span>Animal</span> <span>=</span> <span>function</span><span>(</span><span>type</span><span>)</span> <span>{</span>\n  <span>this</span><span>.</span>type <span>=</span> type\n<span>}</span>\n<span>// 定义方法</span>\n<span>Animal</span><span>.</span>prototype<span>.</span><span>walk</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'I am walking'</span><span>)</span>\n<span>}</span>\n<span>// 定义静态方法</span>\nAnimal<span>.</span><span>eat</span> <span>=</span> <span>function</span><span>(</span><span>food</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'I am eating'</span><span>)</span>\n<span>}</span>\n<span>// 定义子类</span>\n<span>let</span> <span>Dog</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n  <span>// 初始化父类</span>\n  <span>Animal</span><span>.</span><span>call</span><span>(</span><span>this</span><span>,</span> <span>'dog'</span><span>)</span>\n  <span>this</span><span>.</span><span>woof</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'Wang Wang'</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n<span>// 继承</span>\n<span>Dog</span><span>.</span>prototype <span>=</span> <span>Animal</span><span>.</span>prototype\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>从代码上看，很繁琐，而且阅读性也较差。ES6 的 Class 可以通过 <code>extends</code> 关键字实现继承，这要比之前清晰和方便很多：</p>\n<div><pre><code><span>class</span> <span>Animal</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>type</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>type <span>=</span> type\n  <span>}</span>\n  <span>walk</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'I am walking'</span><span>)</span>\n  <span>}</span>\n  <span>static</span> <span>eat</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'I am eating'</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>Dog</span> <span>extends</span> <span>Animal</span> <span>{</span>\n  <span>constructor</span> <span>(</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span><span>'dog'</span><span>)</span>\n  <span>}</span>\n  <span>woof</span> <span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'Wang Wang'</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>上面代码中，需要注意的是<strong>子类的构造函数必须执行一次 <code>super</code> 函数，否则 JavaScript 引擎会报错</strong>。</p>\n<p>注意点：</p>\n<ul>\n<li>\n<p>子类必须在 <code>constructor()</code> 方法中调用 <code>super()</code> 方法，这是因为子类自己的 <code>this</code> 对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用 <code>super()</code> 方法，子类就得不到 <code>this</code> 对象。</p>\n<blockquote>\n<p>ES5 的继承，实质是先创造子类的实例对象 <code>this</code>，然后再将父类的方法添加到 <code>this</code> 上面（<code>Parent.apply(this)</code>）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到 <code>this</code> 上面（所以必须先调用 <code>super()</code> 方法），然后再用子类的构造函数修改 <code>this</code>。</p>\n</blockquote>\n</li>\n<li>\n<p>另一个需要注意的地方是，在子类的构造函数中，只有调用 <code>super()</code> 之后，才可以使用 <code>this</code> 关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有 <code>super()</code> 方法才能调用父类实例。</p>\n</li>\n</ul>\n<h2 id=\"不存在变量提升\"> 不存在变量提升</h2>\n<p>类不存在变量提升（hoist），这一点与 ES5 完全不同。</p>\n<div><pre><code><span>new</span> <span>Foo</span><span>(</span><span>)</span><span>;</span> <span>// ReferenceError</span>\n<span>class</span> <span>Foo</span> <span>{</span><span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>上面代码中，<code>Foo</code> 类使用在前，定义在后，这样会报错，因为 ES6 不会把类的声明提升到代码头部。这种规定的原因与继承有关，必须保证子类在父类之后定义。</p>\n<div><pre><code><span>{</span>\n  <span>let</span> Foo <span>=</span> <span>class</span> <span>{</span><span>}</span><span>;</span>\n  <span>class</span> <span>Bar</span> <span>extends</span> <span>Foo</span> <span>{</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面的代码不会报错，因为 <code>Bar</code> 继承 <code>Foo</code> 的时候，<code>Foo</code> 已经有定义了。但是，如果存在 <code>class</code> 的提升，上面代码就会报错，因为 <code>class</code> 会被提升到代码头部，而 <code>let</code> 命令是不提升的，所以导致 <code>Bar</code> 继承 <code>Foo</code> 的时候，<code>Foo</code> 还没有定义。</p>\n<h2 id=\"总结\"> 总结</h2>\n<p>虽然 ES6 在类的定义上仅是 ES5 定义类的语法糖，但是从开发者的角度而言，开发更有效率了，代码可阅读性大大提升。</p>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/class\" target=\"_blank\" rel=\"noopener noreferrer\">Class 的基本语法</a></li>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/class-extends\" target=\"_blank\" rel=\"noopener noreferrer\">Class 的继承</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes\" target=\"_blank\" rel=\"noopener noreferrer\">类</a></li>\n<li><a href=\"https://www.kancloud.cn/kancloud/you-dont-know-js-this-object-prototypes/516675\" target=\"_blank\" rel=\"noopener noreferrer\">ES6 class</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-01-02T04:25:13.000Z",
      "date_modified": "2022-03-07T16:09:21.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Function 扩展",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es6-function/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es6-function/",
      "content_html": "<h1 id=\"function-扩展\"> Function 扩展</h1>\n<h2 id=\"默认参数\"> 默认参数</h2>\n<p>在 ES5 中函数如果需要支持默认参数，需要这么写：</p>\n<div><pre><code><span>function</span> <span>foo</span><span>(</span><span>x<span>,</span> y</span><span>)</span> <span>{</span>\n  y <span>=</span> y <span>||</span> <span>'world'</span>\n  console<span>.</span><span>log</span><span>(</span>x<span>,</span> y<span>)</span>\n<span>}</span>\n<span>foo</span><span>(</span><span>'hello'</span><span>,</span> <span>'javascript'</span><span>)</span>\n<span>foo</span><span>(</span><span>'hello'</span><span>,</span> <span>0</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>ES6 中改变了这种繁琐的写法，现在可以这么写：</p>\n<div><pre><code><span>function</span> <span>foo</span><span>(</span>x<span>,</span> y <span>=</span> <span>'world'</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>x<span>,</span> y<span>)</span>\n<span>}</span>\n<span>foo</span><span>(</span><span>'hello'</span><span>,</span> <span>0</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"rest-参数\"> Rest 参数</h2>\n<p>以求和运算为例，ES5 中处理不定参数是借助 <code>arguments</code> 来做的：</p>\n<div><pre><code><span>function</span> <span>sum</span><span>(</span><span>)</span> <span>{</span>\n  <span>let</span> num <span>=</span> <span>0</span>\n  <span>Array</span><span>.</span>prototype<span>.</span><span>forEach</span><span>.</span><span>call</span><span>(</span>arguments<span>,</span> <span>function</span><span>(</span><span>item</span><span>)</span> <span>{</span>\n    num <span>+=</span> item <span>*</span> <span>1</span>\n  <span>}</span><span>)</span>\n  <span>return</span> num\n<span>}</span>\n\nconsole<span>.</span><span>log</span><span>(</span><span>sum</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>)</span><span>)</span> <span>// 10</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>ES6 引入 Rest 参数（形式为 <code>...变量名</code>），用于获取函数的多余参数，这样就不需要使用 <code>arguments</code> 对象了。</p>\n<div><pre><code><span>function</span> <span>sum</span><span>(</span><span><span>...</span>nums</span><span>)</span> <span>{</span>\n  <span>let</span> num <span>=</span> <span>0</span>\n  nums<span>.</span><span>forEach</span><span>(</span><span>function</span><span>(</span><span>item</span><span>)</span> <span>{</span>\n    num <span>+=</span> item <span>*</span> <span>1</span>\n  <span>}</span><span>)</span>\n  <span>return</span> num\n<span>}</span>\n\nconsole<span>.</span><span>log</span><span>(</span><span>sum</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>)</span><span>)</span> <span>// 10</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>Rest 参数的强大之处：</p>\n<ul>\n<li>Rest 参数可以将确定的参数在传值时分离出来（此时 Rest 参数必须排在参数最后），而如果使用 <code>arguments</code> 需在函数内部进行分离操作。</li>\n<li><code>arguments</code> 不是数组，所以不能直接使用数组的原生 API 如 <code>forEach</code>，而 Rest 参数是数组，可以直接使用数组的原生 API。</li>\n</ul>\n<h2 id=\"扩展运算符\"> 扩展运算符</h2>\n<p>扩展运算符和 Rest 参数是形似（都用符号 <code>...</code> 来表示）但相反意义的操作符。</p>\n<p>Rest 参数是将不定的参数「收敛」到数组中，而扩展运算符是将固定的数组内容「打散」到参数里去。</p>\n<p>Rest 参数与扩展运算符可以理解为互为逆运算。</p>\n<h2 id=\"length-属性\"> length 属性</h2>\n<p>函数指定了默认值以后，函数的 <code>length</code> 属性，将返回第一个默认参数前面的参数个数。</p>\n<div><pre><code><span>function</span> <span>foo</span><span>(</span><span>x<span>,</span> y <span>=</span> <span>2</span><span>,</span> z <span>=</span> <span>3</span></span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>x<span>,</span> y<span>)</span>\n<span>}</span>\nconsole<span>.</span><span>log</span><span>(</span>foo<span>.</span>length<span>)</span> <span>// 1</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"name-属性\"> name 属性</h2>\n<p>函数的 <code>name</code> 属性，返回该函数的函数名。</p>\n<div><pre><code><span>function</span> <span>foo</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n\nconsole<span>.</span><span>log</span><span>(</span>foo<span>.</span>name<span>)</span> <span>// \"foo\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"箭头函数\"> 箭头函数</h2>\n<h3 id=\"参数和括号\"> 参数和括号</h3>\n<p>如果只有一个参数，可以省略括号；如果大于一个参数或没有参数，一定要带括号。</p>\n<div><pre><code><span>// 只有一个参数</span>\n<span>let</span> <span>hello1</span> <span>=</span> <span>name</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'say hello'</span><span>,</span> name<span>)</span>\n<span>}</span>\n\n<span>// 没有参数</span>\n<span>let</span> <span>hello2</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'say hello'</span><span>)</span>\n<span>}</span>\n\n<span>// 多个参数</span>\n<span>let</span> <span>hello3</span> <span>=</span> <span>(</span><span>name<span>,</span> age</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'say hello'</span><span>,</span> name<span>,</span> age<span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id=\"返回值\"> 返回值</h3>\n<p>如果返回值是表达式，可以省略 <code>return</code> 和 <code>{}</code>。</p>\n<div><pre><code><span>let</span> <span>pow</span> <span>=</span> <span>x</span> <span>=></span> x <span>*</span> x\n</code></pre>\n<div><span>1</span><br></div></div><p>如果返回值是字面量对象，一定要用小括号包起来。</p>\n<div><pre><code><span>let</span> <span>person</span> <span>=</span> <span>(</span><span>name</span><span>)</span> <span>=></span> <span>(</span><span>{</span>\n  age<span>:</span> <span>20</span><span>,</span>\n  addr<span>:</span> <span>'Beijing City'</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>其他情况就中规中矩即可。</p>\n<h3 id=\"this-指向\"> this 指向</h3>\n<p>箭头函数中 <code>this</code> 指向<strong>函数定义时</strong>所在的<strong>外层作用域</strong>的 <code>this</code>，即包裹箭头函数的函数。</p>\n<p>如果包裹箭头函数的，依旧是个箭头函数，则继续往外层找，直到 <code>window</code>（浏览器环境下非严格模式）或 <code>undefined</code>（严格模式）。</p>\n<h3 id=\"注意点\"> 注意点</h3>\n<ul>\n<li>箭头函数不可以当作构造函数</li>\n<li>箭头函数不可以使用 <code>arguments</code> 对象</li>\n</ul>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/function\" target=\"_blank\" rel=\"noopener noreferrer\">函数的扩展</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions\" target=\"_blank\" rel=\"noopener noreferrer\">箭头函数</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Default_parameters\" target=\"_blank\" rel=\"noopener noreferrer\">默认参数值</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-01-01T14:19:39.000Z",
      "date_modified": "2022-01-04T09:23:13.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "解构赋值",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es6-destructuring/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es6-destructuring/",
      "content_html": "<h1 id=\"解构赋值\"> 解构赋值</h1>\n<h2 id=\"数组解构赋值\"> 数组解构赋值</h2>\n<h3 id=\"基本用法\"> 基本用法</h3>\n<p>将值从数组中取出，赋值给其他变量。这是一个拷贝过程，原数组和元素本身不会被改变。</p>\n<div><pre><code><span>let</span> <span>[</span>a<span>,</span> b<span>,</span> c<span>]</span> <span>=</span> <span>[</span><span>'a'</span><span>,</span> <span>'b'</span><span>,</span> <span>'c'</span><span>]</span> <span>// [\"a\", \"b\", \"c\"]</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"可以是任意可遍历的对象\"> 可以是任意可遍历的对象</h3>\n<p>赋值的元素不仅是数组，它可以是任意可遍历的对象。</p>\n<div><pre><code><span>let</span> <span>[</span>a<span>,</span> b<span>,</span> c<span>]</span> <span>=</span> <span>\"abc\"</span>                       <span>// [\"a\", \"b\", \"c\"]</span>\n<span>let</span> <span>[</span>one<span>,</span> two<span>,</span> three<span>]</span> <span>=</span> <span>new</span> <span>Set</span><span>(</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>)</span>  <span>// [1, 2, 3]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"使用场景\"> 使用场景</h3>\n<h4 id=\"_1-循环体中使用-配合-object-entries\"> 1）循环体中使用，配合 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\" target=\"_blank\" rel=\"noopener noreferrer\"><code>Object.entries()</code></a></h4>\n<ul>\n<li>每次遍历得到一个数组，该数组的元素是给定对象自身可枚举属性的键和值</li>\n<li>接下来的解构操作本质上就是解构的基本用法</li>\n</ul>\n<div><pre><code><span>let</span> user <span>=</span> <span>{</span>\n  name<span>:</span> <span>'zhangsan'</span><span>,</span>\n  age<span>:</span> <span>13</span>\n<span>}</span>\n\n<span>for</span> <span>(</span><span>let</span> <span>[</span>key<span>,</span> value<span>]</span> <span>of</span> Object<span>.</span><span>entries</span><span>(</span>user<span>)</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span><span>`</span><span><span>${</span>key<span>}</span></span><span>:</span><span><span>${</span>value<span>}</span></span><span>`</span></span><span>)</span>\n<span>}</span>\n<span>// name:zhangsan</span>\n<span>// age:13</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h4 id=\"_2-循环体中使用-配合-map-对象\"> 2）循环体中使用，配合 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map\" target=\"_blank\" rel=\"noopener noreferrer\">Map 对象</a></h4>\n<div><pre><code><span>let</span> user <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span>\nuser<span>.</span><span>set</span><span>(</span><span>'name'</span><span>,</span> <span>'zhangsan'</span><span>)</span>\nuser<span>.</span><span>set</span><span>(</span><span>'age'</span><span>,</span> <span>13</span><span>)</span>\n\n<span>for</span> <span>(</span><span>let</span> <span>[</span>key<span>,</span> value<span>]</span> <span>of</span> user<span>.</span><span>entries</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span><span>`</span><span><span>${</span>key<span>}</span></span><span>:</span><span><span>${</span>value<span>}</span></span><span>`</span></span><span>)</span>\n<span>}</span>\n<span>// name:zhangsan</span>\n<span>// age:13</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"跳过赋值元素\"> 跳过赋值元素</h3>\n<p>如果想忽略数组的某个元素对变量进行赋值，可以使用逗号来处理。</p>\n<div><pre><code><span>let</span> <span>[</span>mon<span>,</span> <span>,</span> wed<span>]</span> <span>=</span> <span>[</span><span>'Monday'</span><span>,</span> <span>'Tuesday'</span><span>,</span> <span>'Wednesday'</span><span>,</span> <span>'Thursday'</span><span>,</span> <span>'Friday'</span><span>,</span> <span>'Saturday'</span><span>,</span> <span>'Sunday'</span><span>]</span>\n\nconsole<span>.</span><span>log</span><span>(</span>wed<span>)</span> <span>// Wednesday</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"rest-参数\"> rest 参数</h3>\n<p>可以使用 rest 参数（形式为 <code>...变量名</code>）来接受赋值数组的剩余元素，不过要确保这个 rest 参数是放在被赋值变量的最后一个位置上。</p>\n<div><pre><code><span>let</span> <span>[</span>mon<span>,</span> tues<span>,</span> <span>...</span>rest<span>]</span> <span>=</span> <span>[</span><span>'Monday'</span><span>,</span> <span>'Tuesday'</span><span>,</span> <span>'Wednesday'</span><span>,</span> <span>'Thursday'</span><span>,</span> <span>'Friday'</span><span>,</span> <span>'Saturday'</span><span>,</span> <span>'Sunday'</span><span>]</span>\n\nconsole<span>.</span><span>log</span><span>(</span>mon<span>)</span>         <span>// Monday</span>\nconsole<span>.</span><span>log</span><span>(</span>tues<span>)</span>        <span>// Tuesday</span>\n\n<span>// rest 是个数组</span>\nconsole<span>.</span><span>log</span><span>(</span>rest<span>[</span><span>0</span><span>]</span><span>)</span>     <span>// Wednesday</span>\nconsole<span>.</span><span>log</span><span>(</span>rest<span>[</span><span>1</span><span>]</span><span>)</span>     <span>// Thursday</span>\nconsole<span>.</span><span>log</span><span>(</span>rest<span>.</span>length<span>)</span> <span>// 5</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"默认值\"> 默认值</h3>\n<p>如果数组的内容少于变量的个数，没有分配到内容的变量会是 <code>undefined</code>。</p>\n<div><pre><code><span>let</span> <span>[</span>firstName<span>,</span> lastName<span>]</span> <span>=</span> <span>[</span><span>]</span>\n\nconsole<span>.</span><span>log</span><span>(</span>firstName<span>)</span> <span>// undefined</span>\nconsole<span>.</span><span>log</span><span>(</span>lastName<span>)</span>  <span>// undefined</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>也可以给变量赋予默认值，防止 <code>undefined</code> 的情况出现。</p>\n<div><pre><code><span>let</span> <span>[</span>firstName <span>=</span> <span>'Guest'</span><span>,</span> lastName <span>=</span> <span>'Anonymous'</span><span>]</span> <span>=</span> <span>[</span><span>'Kobe'</span><span>]</span>\n\nconsole<span>.</span><span>log</span><span>(</span>firstName<span>)</span> <span>// Kobe</span>\nconsole<span>.</span><span>log</span><span>(</span>lastName<span>)</span>  <span>// Anonymous</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"对象解构赋值\"> 对象解构赋值</h2>\n<h3 id=\"基本用法-2\"> 基本用法</h3>\n<p>左侧的变量名要和右侧对象中存在的 key 名一致，但是顺序无需一致。</p>\n<div><pre><code><span>let</span> options <span>=</span> <span>{</span>\n  title<span>:</span> <span>'Menu'</span><span>,</span>\n  width<span>:</span> <span>100</span><span>,</span>\n  height<span>:</span> <span>200</span>\n<span>}</span>\n\n<span>let</span> <span>{</span>title<span>,</span> width<span>,</span> height<span>}</span> <span>=</span> options\n\nconsole<span>.</span><span>log</span><span>(</span>title<span>)</span>  <span>// Menu</span>\nconsole<span>.</span><span>log</span><span>(</span>width<span>)</span>  <span>// 100</span>\nconsole<span>.</span><span>log</span><span>(</span>height<span>)</span> <span>// 200</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>提取出来的值也可以赋值给其它的变量名。</p>\n<div><pre><code><span>let</span> options <span>=</span> <span>{</span>\n  title<span>:</span> <span>'Menu'</span><span>,</span>\n  width<span>:</span> <span>100</span><span>,</span>\n  height<span>:</span> <span>200</span>\n<span>}</span>\n\n<span>let</span> <span>{</span>title<span>:</span> t<span>,</span> width<span>:</span> w<span>,</span> height<span>:</span> h<span>}</span> <span>=</span> options\n\nconsole<span>.</span><span>log</span><span>(</span>t<span>)</span> <span>// Menu</span>\nconsole<span>.</span><span>log</span><span>(</span>w<span>)</span> <span>// 100</span>\nconsole<span>.</span><span>log</span><span>(</span>h<span>)</span> <span>// 200</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"rest-运算符\"> rest 运算符</h3>\n<p>可以像数组一样，只提取指定的属性，将其他可以暂存到一个变量下，这就要用到 rest 运算符（形式为 <code>...变量名</code>）了。</p>\n<div><pre><code><span>let</span> options <span>=</span> <span>{</span>\n  title<span>:</span> <span>'Menu'</span><span>,</span>\n  height<span>:</span> <span>200</span><span>,</span>\n  width<span>:</span> <span>100</span>\n<span>}</span>\n\n<span>let</span> <span>{</span>title<span>,</span> <span>...</span>rest<span>}</span> <span>=</span> options\n\nconsole<span>.</span><span>log</span><span>(</span>rest<span>.</span>height<span>)</span> <span>// 200</span>\nconsole<span>.</span><span>log</span><span>(</span>rest<span>.</span>width<span>)</span>  <span>// 100</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"默认值-2\"> 默认值</h3>\n<p>赋值的过程中也可以指定默认值。</p>\n<div><pre><code><span>let</span> options <span>=</span> <span>{</span>\n  title<span>:</span> <span>'Menu'</span>\n<span>}</span>\n\n<span>let</span> <span>{</span>width <span>=</span> <span>100</span><span>,</span> height <span>=</span> <span>200</span><span>,</span> title<span>}</span> <span>=</span> options\n\nconsole<span>.</span><span>log</span><span>(</span>title<span>)</span>  <span>// Menu</span>\nconsole<span>.</span><span>log</span><span>(</span>width<span>)</span>  <span>// 100</span>\nconsole<span>.</span><span>log</span><span>(</span>height<span>)</span> <span>// 200</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"嵌套对象\"> 嵌套对象</h3>\n<p>如果一个 Array 或者 Object 比较复杂，它嵌套了 Array 或者 Object，那只要被赋值的结构和右侧赋值的元素一致就好了。</p>\n<p>就像这样：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/destructuring-complex.png\" alt=\"嵌套对象的解构赋值\" style=\"width: 550px;\">\n  <p style=\"text-align: center; color: #888;\">（嵌套对象的解构赋值）</p>\n</div>\n<div><pre><code><span>let</span> options <span>=</span> <span>{</span>\n  size<span>:</span> <span>{</span>\n    width<span>:</span> <span>100</span><span>,</span>\n    height<span>:</span> <span>200</span>\n  <span>}</span><span>,</span>\n  items<span>:</span> <span>[</span><span>\"Cake\"</span><span>,</span> <span>\"Donut\"</span><span>]</span><span>,</span>\n  extra<span>:</span> <span>true</span>    <span>// 不提取这个值</span>\n<span>}</span>\n\n<span>let</span> <span>{</span>\n  size<span>:</span> <span>{</span>\n    width<span>,</span>\n    height\n  <span>}</span><span>,</span>\n  items<span>:</span> <span>[</span>item1<span>,</span> item2<span>]</span><span>,</span>\n  title <span>=</span> <span>'Menu'</span> <span>// 默认参数</span>\n<span>}</span> <span>=</span> options\n\nconsole<span>.</span><span>log</span><span>(</span>title<span>)</span>  <span>// Menu</span>\nconsole<span>.</span><span>log</span><span>(</span>width<span>)</span>  <span>// 100</span>\nconsole<span>.</span><span>log</span><span>(</span>height<span>)</span> <span>// 200</span>\nconsole<span>.</span><span>log</span><span>(</span>item1<span>)</span>  <span>// Cake</span>\nconsole<span>.</span><span>log</span><span>(</span>item2<span>)</span>  <span>// Donut</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id=\"字符串解构赋值\"> 字符串解构赋值</h2>\n<p>本质上就是把字符串当做是数组来解构。</p>\n<div><pre><code><span>let</span> str <span>=</span> <span>'hello'</span>\n\n<span>let</span> <span>[</span>a<span>,</span> b<span>,</span> c<span>,</span> d<span>,</span> e<span>]</span> <span>=</span> str\n\nconsole<span>.</span><span>log</span><span>(</span>a<span>,</span> b<span>,</span> c<span>,</span> d<span>,</span> e<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/destructuring\" target=\"_blank\" rel=\"noopener noreferrer\">变量的解构赋值</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\" target=\"_blank\" rel=\"noopener noreferrer\">解构赋值</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-01-01T13:26:23.000Z",
      "date_modified": "2022-01-01T13:26:23.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Array 扩展",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es6-array/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es6-array/",
      "content_html": "<h1 id=\"array-扩展\"> Array 扩展</h1>\n<h2 id=\"es5-中数组遍历方式\"> ES5 中数组遍历方式</h2>\n<h3 id=\"for-循环\"> for 循环</h3>\n<div><pre><code><span>let</span> arr <span>=</span> <span>[</span><span>'a'</span><span>,</span> <span>'b'</span><span>,</span> <span>'c'</span><span>,</span> <span>'b'</span><span>,</span> <span>'d'</span><span>]</span>\n\n<span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>arr<span>[</span>i<span>]</span><span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"foreach\"> forEach()</h3>\n<p>没有返回值，只是针对每个元素调用 func。</p>\n<p>优点是不需要通过索引来获取数组项，缺点是不支持 <code>break</code>、<code>continue</code>。</p>\n<p>易混淆点：在 <code>forEach()</code> 的循环体里使用 <code>return</code> 起的作用是 <code>continue</code>（离开当前循环，进入下一次循环），而不是原本的结束遍历。</p>\n<div><pre><code><span>let</span> arr <span>=</span> <span>[</span><span>'a'</span><span>,</span> <span>'b'</span><span>,</span> <span>'c'</span><span>,</span> <span>'b'</span><span>,</span> <span>'d'</span><span>]</span>\n\narr<span>.</span><span>forEach</span><span>(</span><span>function</span><span>(</span><span>ele<span>,</span> idx<span>,</span> array</span><span>)</span> <span>{</span>\n  <span>if</span> <span>(</span>arr<span>[</span>idx<span>]</span> <span>==</span> <span>'b'</span><span>)</span> <span>{</span>\n    <span>return</span><span>;</span>\n  <span>}</span>\n  console<span>.</span><span>log</span><span>(</span>idx<span>,</span> ele<span>)</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"map\"> map()</h3>\n<p>返回新的数组，每个元素为调用 func 的结果。</p>\n<div><pre><code><span>let</span> arr <span>=</span> <span>[</span><span>'a'</span><span>,</span> <span>'b'</span><span>,</span> <span>'c'</span><span>,</span> <span>'b'</span><span>,</span> <span>'d'</span><span>]</span>\n\n<span>let</span> result <span>=</span> arr<span>.</span><span>map</span><span>(</span><span>function</span><span>(</span><span>value</span><span>)</span> <span>{</span>\n  value <span>+=</span> value\n  console<span>.</span><span>log</span><span>(</span>value<span>)</span>\n  <span>return</span> value\n<span>}</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>arr<span>,</span> result<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"filter\"> filter()</h3>\n<p>返回符合 func 条件的元素数组。</p>\n<div><pre><code><span>let</span> arr <span>=</span> <span>[</span><span>'a'</span><span>,</span> <span>'b'</span><span>,</span> <span>'c'</span><span>,</span> <span>'b'</span><span>,</span> <span>'d'</span><span>]</span>\n\n<span>let</span> result <span>=</span> arr<span>.</span><span>filter</span><span>(</span><span>function</span><span>(</span><span>value</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>value<span>)</span>\n  <span>return</span> value <span>==</span> <span>'b'</span>\n<span>}</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>arr<span>,</span> result<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"some\"> some()</h3>\n<p>返回 boolean，判断是否有元素符合 func 条件。</p>\n<div><pre><code><span>let</span> arr <span>=</span> <span>[</span><span>'a'</span><span>,</span> <span>'b'</span><span>,</span> <span>'c'</span><span>,</span> <span>'b'</span><span>,</span> <span>'d'</span><span>]</span>\n\n<span>let</span> result <span>=</span> arr<span>.</span><span>some</span><span>(</span><span>function</span><span>(</span><span>value</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>value<span>)</span>\n  <span>return</span> value <span>==</span> <span>'c'</span>\n<span>}</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>arr<span>,</span> result<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"every\"> every()</h3>\n<p>返回 boolean，判断是否每个元素都符合 func 条件。</p>\n<div><pre><code><span>let</span> arr <span>=</span> <span>[</span><span>'a'</span><span>,</span> <span>'b'</span><span>,</span> <span>'c'</span><span>,</span> <span>'b'</span><span>,</span> <span>'d'</span><span>]</span>\n\n<span>let</span> result <span>=</span> arr<span>.</span><span>every</span><span>(</span><span>function</span><span>(</span><span>value</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>value<span>)</span>\n  <span>return</span> value <span>==</span> <span>'c'</span>\n<span>}</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>arr<span>,</span> result<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"reduce\"> reduce()</h3>\n<p>为数组里的每个元素执行 func 函数，返回函数累计处理的结果。</p>\n<div><pre><code>arr<span>.</span><span>reduce</span><span>(</span><span>callback</span><span>(</span>accumulator<span>,</span> currentValue<span>,</span> index<span>,</span> array<span>)</span><span>,</span> initialValue<span>)</span>\n\n<span>// 回调函数(callback)将执行数组中每个值，它包含 4 个参数:</span>\n\n<span>// accumulator: 累计器, 也叫 previousValue, 它是上一次回调的返回值, 或者是提供的 initialValue。</span>\n<span>// currentValue: 当前值, 数组中当前被处理的元素。</span>\n<span>// index: 当前索引, 如果提供了 initialValue, index 值从 0 开始, 否则从 1 开始。</span>\n<span>// array: 源数组, 即调用 reduce() 的数组。</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>数组累加：</p>\n<div><pre><code><span>let</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>]</span>\n\n<span>let</span> sum <span>=</span> arr<span>.</span><span>reduce</span><span>(</span><span>(</span><span>acc<span>,</span> cur</span><span>)</span> <span>=></span> <span>{</span>\n <span>return</span> acc <span>+</span> cur \n<span>}</span><span>,</span> <span>0</span><span>)</span>\n\nconsole<span>.</span><span>log</span><span>(</span>sum<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"es6-中数组遍历方式\"> ES6 中数组遍历方式</h2>\n<h3 id=\"for-of\"> for...of</h3>\n<p>for...of 可以遍历一切可遍历的元素（数组、对象、集合）。</p>\n<div><pre><code><span>for</span> <span>(</span><span>let</span> item <span>of</span> arr<span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>item<span>)</span>\n<span>}</span>\n\n<span>for</span> <span>(</span><span>let</span> item <span>of</span> arr<span>.</span><span>values</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>item<span>)</span>\n<span>}</span>\n\n<span>for</span> <span>(</span><span>let</span> item <span>of</span> arr<span>.</span><span>keys</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>item<span>)</span>\n<span>}</span>\n\n<span>for</span> <span>(</span><span>let</span> <span>[</span>index<span>,</span> item<span>]</span> <span>of</span> arr<span>.</span><span>entries</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>index<span>,</span> item<span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id=\"数组的新增方法\"> 数组的新增方法</h2>\n<h3 id=\"array-from\"> Array.from()</h3>\n<p>用于将类数组的对象（array-like object）和可遍历的对象（包括 ES6 新增的数据结构 Set 和 Map），转为真正的数组。</p>\n<p>转换后就可以对它们使用数组的原生 API 了。</p>\n<p><strong>语法</strong></p>\n<blockquote>\n<p>Array.from(arrayLike[, mapFn[, thisArg]])</p>\n</blockquote>\n<p><strong>解释</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n<th>必选</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>arrayLike</td>\n<td>想要转换成数组的伪数组对象或可迭代对象</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>mapFn</td>\n<td>如果指定了该参数，新数组中的每个元素会执行该回调函数</td>\n<td>N</td>\n</tr>\n<tr>\n<td>thisArg</td>\n<td>执行回调函数 <code>mapFn</code> 时 <code>this</code> 对象</td>\n<td>N</td>\n</tr>\n</tbody>\n</table>\n<p><strong>示例</strong></p>\n<div><pre><code><span>// 转换类数组对象</span>\n<span>let</span> arrLike <span>=</span> <span>{</span>\n  <span>0</span><span>:</span> <span>'a'</span><span>,</span>\n  <span>1</span><span>:</span> <span>'b'</span><span>,</span>\n  <span>2</span><span>:</span> <span>'c'</span><span>,</span>\n  length<span>:</span> <span>3</span>\n<span>}</span>\n\n<span>let</span> arr <span>=</span> Array<span>.</span><span>from</span><span>(</span>arrLike<span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>arr<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>拓展用法：利用该方法的第二个参数，初始化一个长度为 <code>5</code> 的数组，每个数组元素默认为 <code>1</code>：</p>\n<div><pre><code><span>let</span> arr <span>=</span> Array<span>.</span><span>from</span><span>(</span><span>{</span>\n  length<span>:</span> <span>5</span>\n<span>}</span><span>,</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n  <span>return</span> <span>1</span>\n<span>}</span><span>)</span>\n\nconsole<span>.</span><span>log</span><span>(</span>arr<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"array-of\"> Array.of()</h3>\n<p>用于创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。</p>\n<p><strong>语法</strong></p>\n<blockquote>\n<p>Array.of(element0[, element1[, ...[, elementN]]])</p>\n</blockquote>\n<p><strong>解释</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n<th>必选</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>elementN</td>\n<td>任意个参数，将按顺序成为返回数组中的元素</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>start</td>\n<td>起始索引，默认值为 <code>0</code></td>\n<td>N</td>\n</tr>\n<tr>\n<td>end</td>\n<td>终止索引，默认值为 <code>this.length</code></td>\n<td>N</td>\n</tr>\n</tbody>\n</table>\n<p><strong>示例</strong></p>\n<p>和 Array 构造函数之间的区别在于处理整数参数：</p>\n<ul>\n<li><code>Array.of(7)</code> 创建一个具有单个元素 <code>7</code> 的数组。</li>\n<li><code>Array(7)</code> 创建一个长度为 <code>7</code> 的空数组。</li>\n</ul>\n<div><pre><code>Array<span>.</span><span>of</span><span>(</span><span>7</span><span>)</span><span>;</span>       <span>// [7]</span>\nArray<span>.</span><span>of</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>;</span> <span>// [1, 2, 3]</span>\n\n<span>Array</span><span>(</span><span>7</span><span>)</span><span>;</span>          <span>// [ , , , , , , ]</span>\n<span>Array</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>;</span>    <span>// [1, 2, 3]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"array-prototype-fill\"> Array.prototype.fill()</h3>\n<p>用给定值填充一个数组中从起始索引到终止索引内的全部元素，不包括终止索引。</p>\n<p><strong>语法</strong></p>\n<blockquote>\n<p>arr.fill(value[, start[, end]])</p>\n</blockquote>\n<p><strong>解释</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n<th>必选</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value</td>\n<td>用来填充数组元素的值</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>start</td>\n<td>起始索引，默认值为 <code>0</code></td>\n<td>N</td>\n</tr>\n<tr>\n<td>end</td>\n<td>终止索引，默认值为 <code>this.length</code></td>\n<td>N</td>\n</tr>\n</tbody>\n</table>\n<p><strong>示例</strong></p>\n<div><pre><code><span>// 用数字 0 替换索引 1 到索引 2(不包含) 的元素</span>\n<span>let</span> array <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>]</span>\narray<span>.</span><span>fill</span><span>(</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>)</span> <span>// [1,0,3,4]</span>\n\n<span>// 初始化一个长度固定, 元素为指定值的数组</span>\n<span>Array</span><span>(</span><span>5</span><span>)</span><span>.</span><span>fill</span><span>(</span><span>1</span><span>)</span>    <span>// [1,1,1,1,1]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"array-prototype-find\"> Array.prototype.find()</h3>\n<p>返回数组中满足 func 函数内条件的第一个元素，否则返回 <code>undefined</code>。</p>\n<p><strong>语法</strong></p>\n<blockquote>\n<p>arr.find(callback[, thisArg])</p>\n</blockquote>\n<p><strong>解释</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n<th>必选</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>callback</td>\n<td>在数组每一项上执行的函数，接收 3 个参数，<code>element</code>、<code>index</code>、<code>array</code></td>\n<td>Y</td>\n</tr>\n<tr>\n<td>thisArg</td>\n<td>执行回调时用作 <code>this</code> 的对象</td>\n<td>N</td>\n</tr>\n</tbody>\n</table>\n<p><strong>示例</strong></p>\n<div><pre><code><span>let</span> array <span>=</span> <span>[</span><span>5</span><span>,</span> <span>12</span><span>,</span> <span>8</span><span>,</span> <span>130</span><span>,</span> <span>44</span><span>]</span><span>;</span>\n\n<span>let</span> found <span>=</span> array<span>.</span><span>find</span><span>(</span><span>function</span><span>(</span><span>element</span><span>)</span> <span>{</span>\n    <span>return</span> element <span>></span> <span>10</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n\nconsole<span>.</span><span>log</span><span>(</span>found<span>)</span><span>;</span> <span>// 12</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"array-prototype-findindex\"> Array.prototype.findIndex()</h3>\n<p>返回数组中满足 func 函数内条件的第一个元素的索引。否则返回 <code>-1</code>。</p>\n<p><strong>语法</strong></p>\n<blockquote>\n<p>arr.findIndex(callback[, thisArg])</p>\n</blockquote>\n<p><strong>解释</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n<th>必选</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>callback</td>\n<td>在数组每一项上执行的函数，接收 3 个参数，<code>element</code>、<code>index</code>、<code>array</code></td>\n<td>Y</td>\n</tr>\n<tr>\n<td>thisArg</td>\n<td>执行回调时用作 <code>this</code> 的对象</td>\n<td>N</td>\n</tr>\n</tbody>\n</table>\n<p><strong>示例</strong></p>\n<div><pre><code><span>let</span> array <span>=</span> <span>[</span><span>5</span><span>,</span> <span>12</span><span>,</span> <span>8</span><span>,</span> <span>130</span><span>,</span> <span>44</span><span>]</span><span>;</span>\n\n<span>let</span> found <span>=</span> array<span>.</span><span>findIndex</span><span>(</span><span>function</span><span>(</span><span>element</span><span>)</span> <span>{</span>\n    <span>return</span> element <span>></span> <span>10</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n\nconsole<span>.</span><span>log</span><span>(</span>found<span>)</span><span>;</span> <span>// 1</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"array-prototype-copywithin\"> Array.prototype.copyWithin()</h3>\n<p>在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p>\n<p><strong>语法</strong></p>\n<blockquote>\n<p>arr.copyWithin(target, start = 0, end = this.length)</p>\n</blockquote>\n<p><strong>解释</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n<th>必选</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>target</td>\n<td>从该位置开始替换数据。如果为负值，表示倒数</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>start</td>\n<td>从该位置开始读取数据，默认为 <code>0</code>。如果为负值，表示从末尾开始计算</td>\n<td>N</td>\n</tr>\n<tr>\n<td>end</td>\n<td>到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算</td>\n<td>N</td>\n</tr>\n</tbody>\n</table>\n<p><strong>示例</strong></p>\n<div><pre><code><span>let</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>]</span>\nconsole<span>.</span><span>log</span><span>(</span>arr<span>.</span><span>copyWithin</span><span>(</span><span>1</span><span>,</span> <span>3</span><span>)</span><span>)</span> <span>// [1, 4, 5, 4, 5]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/array\" target=\"_blank\" rel=\"noopener noreferrer\">数组的扩展</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array\" target=\"_blank\" rel=\"noopener noreferrer\">Array</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-01-01T13:26:23.000Z",
      "date_modified": "2022-01-11T09:14:24.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Generator",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es6-generator/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es6-generator/",
      "content_html": "<h1 id=\"generator\"> Generator</h1>\n<p>Generators 是可以用来控制迭代器的函数。它们可以暂停，然后在任何时候恢复。</p>\n<p>常规循环：</p>\n<div><pre><code><span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>5</span><span>;</span> i <span>+=</span> <span>1</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>i<span>)</span>\n<span>}</span>\n<span>// 立即依次打印出: 0, 1, 2, 3, 4 </span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>利用 Generator：</p>\n<div><pre><code><span>function</span><span>*</span> <span>generatorForLoop</span><span>(</span><span>)</span> <span>{</span>\n  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>5</span><span>;</span> i <span>+=</span> <span>1</span><span>)</span> <span>{</span>\n    <span>yield</span> console<span>.</span><span>log</span><span>(</span>i<span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>const</span> genForLoop <span>=</span> <span>generatorForLoop</span><span>(</span><span>)</span>\n\nconsole<span>.</span><span>log</span><span>(</span>genForLoop<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// 0</span>\nconsole<span>.</span><span>log</span><span>(</span>genForLoop<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// 1</span>\nconsole<span>.</span><span>log</span><span>(</span>genForLoop<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// 2</span>\nconsole<span>.</span><span>log</span><span>(</span>genForLoop<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// 3</span>\nconsole<span>.</span><span>log</span><span>(</span>genForLoop<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// 4</span>\nconsole<span>.</span><span>log</span><span>(</span>genForLoop<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// undefined</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>常规的循环只能一次遍历完所有值，Generator 可以通过调用 <code>next()</code> 方法拿到依次遍历的值，让遍历的执行变得「可控」。</p>\n<h2 id=\"基本语法\"> 基本语法</h2>\n<h3 id=\"定义\"> 定义</h3>\n<div><pre><code><span>function</span><span>*</span> <span>gen</span><span>(</span><span>)</span> <span>{</span>\n  <span>yield</span> <span>1</span>\n  <span>yield</span> <span>2</span>\n  <span>yield</span> <span>3</span>\n  <span>return</span> <span>4</span>\n<span>}</span>\n\n<span>let</span> g <span>=</span> <span>gen</span><span>(</span><span>)</span>\ng<span>.</span><span>next</span><span>(</span><span>)</span> <span>// {value: 1, done: false}</span>\ng<span>.</span><span>next</span><span>(</span><span>)</span> <span>// {value: 2, done: false}</span>\ng<span>.</span><span>next</span><span>(</span><span>)</span> <span>// {value: 3, done: false}</span>\ng<span>.</span><span>next</span><span>(</span><span>)</span> <span>// {value: 4, done: true}</span>\ng<span>.</span><span>next</span><span>(</span><span>)</span> <span>// {value: undefined, done: true}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>这个是 Generator 的定义方法，有几个点值得注意：</p>\n<ul>\n<li>比普通函数多一个 <code>*</code></li>\n<li>函数内部用 <code>yield</code> 来控制程序的执行的「暂停」</li>\n<li>函数的返回值通过调用 <code>next()</code> 来「恢复」程序执行</li>\n</ul>\n<div><p>注意</p>\n<p>Generator 函数的定义不能使用箭头函数，否则会触发 SyntaxError 错误</p>\n</div>\n<div><pre><code><span>let</span> generator <span>=</span> <span>*</span> <span>(</span><span>)</span> <span>=></span> <span>{</span><span>}</span> <span>// Uncaught SyntaxError: Unexpected token '*'</span>\n<span>let</span> generator <span>=</span> <span>(</span><span>)</span> <span>*</span> <span>=></span> <span>{</span><span>}</span> <span>// Uncaught SyntaxError: Unexpected token ')'</span>\n<span>let</span> <span>generator</span> <span>=</span> <span>(</span> <span><span>*</span></span> <span>)</span> <span>=></span> <span>{</span><span>}</span> <span>// Uncaught SyntaxError: Unexpected token '*'</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"yield-表达式\"> yield 表达式</h3>\n<blockquote>\n<p>yield 关键字用来暂停和恢复一个生成器函数</p>\n</blockquote>\n<p>关于 <code>yield</code> 表达式，要熟记几个知识点：</p>\n<ul>\n<li><code>yield</code> 表达式的返回值是 <code>undefined</code>，但是遍历器对象的 <code>next()</code> 方法可以修改这个默认值。</li>\n</ul>\n<div><pre><code><span>function</span><span>*</span> <span>gen</span><span>(</span><span>)</span> <span>{</span>\n  <span>let</span> val\n  val <span>=</span> <span>yield</span> <span>1</span>\n  console<span>.</span><span>log</span><span>(</span> <span><span>`</span><span>1:</span><span><span>${</span>val<span>}</span></span><span>`</span></span> <span>)</span> <span>// 1:undefined</span>\n  val <span>=</span> <span>yield</span> <span>2</span>\n  console<span>.</span><span>log</span><span>(</span> <span><span>`</span><span>2:</span><span><span>${</span>val<span>}</span></span><span>`</span></span> <span>)</span> <span>// 2:undefined</span>\n  val <span>=</span> <span>yield</span> <span>3</span>\n  console<span>.</span><span>log</span><span>(</span> <span><span>`</span><span>3:</span><span><span>${</span>val<span>}</span></span><span>`</span></span> <span>)</span> <span>// 3:undefined</span>\n<span>}</span>\n\n<span>let</span> g <span>=</span> <span>gen</span><span>(</span><span>)</span>\n\nconsole<span>.</span><span>log</span><span>(</span>g<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// {value: 1, done: false}</span>\nconsole<span>.</span><span>log</span><span>(</span>g<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// {value: 2, done: false}</span>\nconsole<span>.</span><span>log</span><span>(</span>g<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// {value: 3, done: false}</span>\nconsole<span>.</span><span>log</span><span>(</span>g<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// {value: undefined, done: true}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><ul>\n<li><code>yield*</code> 表达式用于将值的生成过程委托给另一个生成器或可遍历对象。</li>\n</ul>\n<div><div><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br></div><pre><code><span>// 如果在 Generator 函数内部, 调用另一个 Generator 函数</span>\n<span>// 需要在前者的函数体内部, 自己手动完成遍历</span>\n<span>function</span><span>*</span> <span>g1</span><span>(</span><span>)</span> <span>{</span>\n  <span>yield</span> <span>2</span>\n  <span>yield</span> <span>3</span>\n  <span>yield</span> <span>4</span>\n<span>}</span>\n\n<span>function</span><span>*</span> <span>g2</span><span>(</span><span>)</span> <span>{</span>\n  <span>yield</span> <span>1</span>\n  <span>yield</span> <span>g1</span><span>(</span><span>)</span>\n  <span>yield</span> <span>5</span>\n<span>}</span>\n\n<span>const</span> iterator <span>=</span> <span>g2</span><span>(</span><span>)</span>\n\nconsole<span>.</span><span>log</span><span>(</span>iterator<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// {value: 1, done: false}</span>\nconsole<span>.</span><span>log</span><span>(</span>iterator<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// {value: g1, done: false}</span>\nconsole<span>.</span><span>log</span><span>(</span>iterator<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// {value: 5, done: false}</span>\nconsole<span>.</span><span>log</span><span>(</span>iterator<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// {value: undefined, done: true}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><div><div><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code><span>// 使用 yield* 表达式</span>\n<span>// g1() yield 出去的每个值都会在 g2() 的 next() 方法中返回, 就像那些 yield 语句是写在 g2() 里一样</span>\n<span>function</span><span>*</span> <span>g1</span><span>(</span><span>)</span> <span>{</span>\n  <span>yield</span> <span>2</span>\n  <span>yield</span> <span>3</span>\n  <span>yield</span> <span>4</span>\n<span>}</span>\n\n<span>function</span><span>*</span> <span>g2</span><span>(</span><span>)</span> <span>{</span>\n  <span>yield</span> <span>1</span>\n  <span>yield</span><span>*</span> <span>g1</span><span>(</span><span>)</span>\n  <span>yield</span> <span>5</span>\n<span>}</span>\n\n<span>const</span> iterator <span>=</span> <span>g2</span><span>(</span><span>)</span>\n\nconsole<span>.</span><span>log</span><span>(</span>iterator<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// {value: 1, done: false}</span>\nconsole<span>.</span><span>log</span><span>(</span>iterator<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// {value: 2, done: false}</span>\nconsole<span>.</span><span>log</span><span>(</span>iterator<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// {value: 3, done: false}</span>\nconsole<span>.</span><span>log</span><span>(</span>iterator<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// {value: 4, done: false}</span>\nconsole<span>.</span><span>log</span><span>(</span>iterator<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// {value: 5, done: false}</span>\nconsole<span>.</span><span>log</span><span>(</span>iterator<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// {value: undefined, done: true}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><ul>\n<li>Generator 对象的 <code>next()</code> 方法，遇到 <code>yield</code> 就暂停，并返回一个对象，这个对象包括两个属性：<code>value</code> 和 <code>done</code>。</li>\n</ul>\n<h3 id=\"方法\"> 方法</h3>\n<p>Generator 对象有几个方法，<code>next</code>、<code>return</code>、<code>throw</code>。</p>\n<ul>\n<li>next([value])\n<ul>\n<li><code>next()</code> 方法可以获取每一次遍历的结果，返回的对象包含两个属性：<code>value</code>（当前程序的运行结果） 和 <code>done</code>（遍历是否结束）。</li>\n<li><code>next()</code> 方法可以接受参数，这个参数用于在 Generator 外部给内部传递数据，而这个参数就是作为 <code>yield</code> 的返回值。</li>\n</ul>\n</li>\n</ul>\n<div><pre><code><span>function</span><span>*</span> <span>gen</span><span>(</span><span>)</span> <span>{</span>\n  <span>let</span> val <span>=</span> <span>100</span>\n  <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span> <span><span>`</span><span>before </span><span><span>${</span>val<span>}</span></span><span>`</span></span> <span>)</span>\n    val <span>=</span> <span>yield</span> val\n    console<span>.</span><span>log</span><span>(</span> <span><span>`</span><span>return </span><span><span>${</span>val<span>}</span></span><span>`</span></span> <span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>let</span> g <span>=</span> <span>gen</span><span>(</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>g<span>.</span><span>next</span><span>(</span><span>20</span><span>)</span><span>.</span>value<span>)</span>\n<span>// before 100</span>\n<span>// 100</span>\nconsole<span>.</span><span>log</span><span>(</span>g<span>.</span><span>next</span><span>(</span><span>30</span><span>)</span><span>.</span>value<span>)</span>\n<span>// return 30</span>\n<span>// before 30</span>\n<span>// 30</span>\nconsole<span>.</span><span>log</span><span>(</span>g<span>.</span><span>next</span><span>(</span><span>40</span><span>)</span><span>.</span>value<span>)</span>\n<span>// return 40</span>\n<span>// before 40</span>\n<span>// 40</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><ul>\n<li>return()</li>\n</ul>\n<p><code>return()</code> 方法可以让 Generator 遍历终止，有点类似 for 循环的 break。</p>\n<div><pre><code><span>function</span><span>*</span> <span>gen</span><span>(</span><span>)</span> <span>{</span>\n  <span>yield</span> <span>1</span>\n  <span>yield</span> <span>2</span>\n  <span>yield</span> <span>3</span>\n<span>}</span>\n\n<span>let</span> g <span>=</span> <span>gen</span><span>(</span><span>)</span>\n\nconsole<span>.</span><span>log</span><span>(</span>g<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span>   <span>// {value: 1, done: false}</span>\nconsole<span>.</span><span>log</span><span>(</span>g<span>.</span><span>return</span><span>(</span><span>)</span><span>)</span> <span>// {value: undefined, done: true}</span>\nconsole<span>.</span><span>log</span><span>(</span>g<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span>   <span>// {value: undefined, done: true}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><code>return()</code> 也可以传入参数，作为返回的 <code>value</code> 值。</p>\n<div><pre><code><span>function</span><span>*</span> <span>gen</span><span>(</span><span>)</span> <span>{</span>\n  <span>yield</span> <span>1</span>\n  <span>yield</span> <span>2</span>\n  <span>yield</span> <span>3</span>\n<span>}</span>\n\n<span>let</span> g <span>=</span> <span>gen</span><span>(</span><span>)</span>\n\nconsole<span>.</span><span>log</span><span>(</span>g<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span>      <span>// {value: 1, done: false}</span>\nconsole<span>.</span><span>log</span><span>(</span>g<span>.</span><span>return</span><span>(</span><span>100</span><span>)</span><span>)</span> <span>// {value: 100, done: true}</span>\nconsole<span>.</span><span>log</span><span>(</span>g<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span>      <span>// {value: undefined, done: true}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><ul>\n<li>throw()</li>\n</ul>\n<p>可以通过 throw 方法在 Generator 外部控制内部执行的「终断」。</p>\n<div><pre><code><span>function</span><span>*</span> <span>gen</span><span>(</span><span>)</span> <span>{</span>\n  <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>\n    <span>try</span> <span>{</span>\n      <span>yield</span> <span>42</span>\n    <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>\n      console<span>.</span><span>log</span><span>(</span>e<span>.</span>message<span>)</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n\n<span>let</span> g <span>=</span> <span>gen</span><span>(</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>g<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// { value: 42, done: false }</span>\nconsole<span>.</span><span>log</span><span>(</span>g<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// { value: 42, done: false }</span>\nconsole<span>.</span><span>log</span><span>(</span>g<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// { value: 42, done: false }</span>\n<span>// 中断操作</span>\ng<span>.</span><span>throw</span><span>(</span><span>new</span> <span>Error</span><span>(</span><span>'break'</span><span>)</span><span>)</span>\n\nconsole<span>.</span><span>log</span><span>(</span>g<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// {value: undefined, done: true}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><div><p>提示</p>\n<p>如果想退出遍历 <code>catch</code> 之后可以配合 <code>return false</code> 使用，能起到 「break」 的作用</p>\n</div>\n<h2 id=\"应用场景\"> 应用场景</h2>\n<h3 id=\"场景-1\"> 场景 1</h3>\n<p>使用 Generator，按顺序读取 a.json、b.json、c.json。</p>\n<div><pre><code><span>function</span> <span>request</span><span>(</span><span>url</span><span>)</span> <span>{</span>\n  <span>ajax</span><span>(</span>url<span>,</span> <span>res</span> <span>=></span> <span>{</span>\n    getData<span>.</span><span>next</span><span>(</span>res<span>)</span>\n  <span>}</span><span>)</span>\n<span>}</span>\n\n<span>function</span><span>*</span> <span>gen</span><span>(</span><span>)</span> <span>{</span>\n  <span>let</span> res1 <span>=</span> <span>yield</span> <span>request</span><span>(</span><span>'static/a.json'</span><span>)</span>\n  console<span>.</span><span>log</span><span>(</span>res1<span>)</span>\n  <span>let</span> res2 <span>=</span> <span>yield</span> <span>request</span><span>(</span><span>'static/b.json'</span><span>)</span>\n  console<span>.</span><span>log</span><span>(</span>res2<span>)</span>\n  <span>let</span> res3 <span>=</span> <span>yield</span> <span>request</span><span>(</span><span>'static/c.json'</span><span>)</span>\n  console<span>.</span><span>log</span><span>(</span>res3<span>)</span>\n<span>}</span>\n\n<span>let</span> getData <span>=</span> <span>gen</span><span>(</span><span>)</span>\ngetData<span>.</span><span>next</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id=\"场景-2\"> 场景 2</h3>\n<p>酒桌小游戏敲7，无限循环转圈去数数，遇到 7 和 7 的倍数就敲桌子。只要调用 <code>n.next</code> 我们就可以知道下一个需要敲桌子的数字是什么了。</p>\n<div><pre><code><span>function</span><span>*</span> <span>count</span><span>(</span><span>x <span>=</span> <span>1</span></span><span>)</span> <span>{</span>\n  <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>x <span>%</span> <span>7</span> <span>===</span> <span>0</span><span>)</span> <span>{</span>\n      <span>yield</span> x\n    <span>}</span>\n    x<span>++</span>\n  <span>}</span>\n<span>}</span>\n<span>// ES5 中就是个死循环 因为 ES5 的循环需要有个终止值，当前这个需求没有终止，一直在数数</span>\n<span>let</span> n <span>=</span> <span>count</span><span>(</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>n<span>.</span><span>next</span><span>(</span><span>)</span><span>.</span>value<span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>n<span>.</span><span>next</span><span>(</span><span>)</span><span>.</span>value<span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>n<span>.</span><span>next</span><span>(</span><span>)</span><span>.</span>value<span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>n<span>.</span><span>next</span><span>(</span><span>)</span><span>.</span>value<span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>n<span>.</span><span>next</span><span>(</span><span>)</span><span>.</span>value<span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>n<span>.</span><span>next</span><span>(</span><span>)</span><span>.</span>value<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/generator\" target=\"_blank\" rel=\"noopener noreferrer\">Generator 函数的语法</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator\" target=\"_blank\" rel=\"noopener noreferrer\">Generator</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/yield*\" target=\"_blank\" rel=\"noopener noreferrer\">yield*</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-01-15T14:58:14.000Z",
      "date_modified": "2022-01-16T14:03:45.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "let 和 const",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es6-let-const/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es6-let-const/",
      "content_html": "<h1 id=\"let-和-const\"> let 和 const</h1>\n<h2 id=\"前言\"> 前言</h2>\n<p>这两个关键字是 ES6 新增的声明变量方式，与 <code>var</code> 的区别：</p>\n<ul>\n<li><code>var</code> 有变量提升，值可变。允许重复声明。</li>\n<li><code>let</code> 不存在变量提升，值可变。不允许重复声明。</li>\n<li><code>const</code> 不存在变量提升，值不可变，但如果是定义对象，则属性可变。不允许重复声明。</li>\n</ul>\n<h2 id=\"let\"> let</h2>\n<h3 id=\"全局声明时不是全局对象的属性\"> 全局声明时不是全局对象的属性</h3>\n<p><code>let</code> 声明的全局变量不是全局对象 <code>window</code> 的属性，不可以通过 <code>window.变量名</code> 的方式访问这些变量。</p>\n<div><pre><code><span>var</span> a <span>=</span> <span>5</span>\nconsole<span>.</span><span>log</span><span>(</span>window<span>.</span>a<span>)</span> <span>// 5</span>\n\n<span>let</span> b <span>=</span> <span>5</span>\nconsole<span>.</span><span>log</span><span>(</span>window<span>.</span>b<span>)</span> <span>// undefined</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"拥有块级作用域\"> 拥有块级作用域</h3>\n<p><code>let</code> 声明的变量拥有<strong>块级作用域</strong>。</p>\n<ul>\n<li>场景一：防止内层变量覆盖外层变量。</li>\n<li>场景二：防止用来计数的循环变量在循环结束后泄露为全局变量。</li>\n</ul>\n<div><pre><code><span>for</span><span>(</span><span>var</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>5</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n  <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span>i<span>)</span><span>;</span>\n  <span>}</span><span>)</span>\n<span>}</span>\n<span>// 5 5 5 5 5</span>\n\n\n<span>for</span><span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>5</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n  <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span>i<span>)</span><span>;</span>\n  <span>}</span><span>)</span>\n<span>}</span>\n<span>// 0 1 2 3 4</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id=\"暂时性死区\"> 暂时性死区</h3>\n<ul>\n<li>对于 <code>let</code>，不存在变量提升，所以变量的调用不能先于声明。</li>\n<li>ES6 明确规定，如果区块中存在 <code>let</code> 和 <code>const</code> 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错（该区域不受外部影响，哪怕外部声明过同名变量）。</li>\n</ul>\n<div><pre><code><span>var</span> a <span>=</span> <span>5</span><span>;</span>\n<span>if</span> <span>(</span><span>true</span><span>)</span> <span>{</span>\n  a <span>=</span> <span>6</span><span>;</span>\n  <span>let</span> a<span>;</span>\n<span>}</span>\n<span>// ReferenceError: Cannot access 'a' before initialization</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"隐蔽的暂时性死区\"> 隐蔽的暂时性死区</h3>\n<ul>\n<li>ES6 允许为函数参数设置默认值，即直接在形参后面通过 <code>=</code> 指定默认值。</li>\n<li>按照<a href=\"https://es6.ruanyifeng.com/#docs/function#%E4%BD%9C%E7%94%A8%E5%9F%9F\" target=\"_blank\" rel=\"noopener noreferrer\">阮一峰老师书中的描述</a>：一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域。等到初始化结束，这个作用域就会消失。</li>\n<li>我的理解是在这个临时作用域里，参数具有跟 <code>let</code>、<code>const</code> 一样的特性（这条结论没能找到比较权威的出处）。</li>\n</ul>\n<div><pre><code><span>var</span> a <span>=</span><span>1</span><span>;</span>\n<span>function</span> <span>foo</span><span>(</span><span>b <span>=</span> a<span>,</span> a <span>=</span> <span>2</span></span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>a<span>,</span> b<span>)</span><span>;</span>\n<span>}</span>\n<span>foo</span><span>(</span><span>)</span>\n<span>// ReferenceError: Cannot access 'a' before initialization</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id=\"const\"> const</h2>\n<p>和 <code>let</code> 一样，具有<strong>块级作用域</strong>，<strong>不会变量提升</strong>，有<strong>暂时性死区</strong>。</p>\n<p><code>const</code> 定义的是常量，<strong>值不能被改变</strong>：</p>\n<ul>\n<li><code>const</code> 声明的变量必须进行初始化。</li>\n<li><code>const</code> 实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。因此它定义的对象的属性可变。</li>\n<li>让对象或者数组这种引用数据类型也不被改变，需要使用 <code>Object.freeze(obj)</code>（浅层冻结，将最近一层的对象进行冻结）。</li>\n</ul>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/let\" target=\"_blank\" rel=\"noopener noreferrer\">let 和 const 命令</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-12-31T10:28:11.000Z",
      "date_modified": "2022-01-01T12:12:16.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Map",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es6-map/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es6-map/",
      "content_html": "<h1 id=\"map\"> Map</h1>\n<p>ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是「键」的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了「字符串—值」的对应，Map 结构提供了「值—值」的对应，是一种更完善的 Hash 结构实现。如果你需要「键值对」的数据结构，Map 比 Object 更合适。</p>\n<h2 id=\"基本语法\"> 基本语法</h2>\n<h3 id=\"实例化\"> 实例化</h3>\n<div><pre><code><span>let</span> map <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>[</span>iterable<span>]</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>Iterable 可以是一个数组或者其他 iterable 对象，其元素为键值对(两个元素的数组，例如: <code>[[ 1, 'one' ], [ 2, 'two' ]]</code>)。 每个键值对都会添加到新的 Map。<code>null</code> 会被当做 <code>undefined</code>。</p>\n<h3 id=\"添加数据\"> 添加数据</h3>\n<div><pre><code><span>let</span> map <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span>\n<span>let</span> keyObj <span>=</span> <span>{</span><span>}</span>\n<span>let</span> <span>keyFunc</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n<span>let</span> keyString <span>=</span> <span>'a string'</span>\n\n<span>// 添加键</span>\nmap<span>.</span><span>set</span><span>(</span>keyString<span>,</span> <span>\"和键'a string'关联的值\"</span><span>)</span>\nmap<span>.</span><span>set</span><span>(</span>keyObj<span>,</span> <span>'和键keyObj关联的值'</span><span>)</span>\nmap<span>.</span><span>set</span><span>(</span>keyFunc<span>,</span> <span>'和键keyFunc关联的值'</span><span>)</span>\n\nconsole<span>.</span><span>log</span><span>(</span>map<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"删除数据\"> 删除数据</h3>\n<div><pre><code><span>// 删除指定的数据</span>\nmap<span>.</span><span>delete</span><span>(</span>keyObj<span>)</span>\n\n<span>// 删除所有数据</span>\nmap<span>.</span><span>clear</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"统计数据\"> 统计数据</h3>\n<div><pre><code><span>// 统计所有 key-value 的总数</span>\nconsole<span>.</span><span>log</span><span>(</span>map<span>.</span>size<span>)</span>        <span>// 2</span>\n\n<span>// 判断是否有 key-value</span>\nconsole<span>.</span><span>log</span><span>(</span>map<span>.</span><span>has</span><span>(</span>keyObj<span>)</span><span>)</span> <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"查询数据\"> 查询数据</h3>\n<p><code>get()</code> 方法返回某个 Map 对象中的一个指定元素。</p>\n<div><pre><code>console<span>.</span><span>log</span><span>(</span>map<span>.</span><span>get</span><span>(</span>keyObj<span>)</span><span>)</span> <span>// 和键 keyObj 关联的值</span>\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"遍历方式\"> 遍历方式</h2>\n<ul>\n<li><code>keys()</code> 返回一个新的 Iterator 对象。它包含按照顺序插入 Map 对象中每个元素的 key 值</li>\n<li><code>values()</code> 方法返回一个新的 Iterator 对象。它包含按顺序插入Map对象中每个元素的 value 值</li>\n<li><code>entries()</code> 方法返回一个新的包含 <code>[key, value]</code> 对的 Iterator 对象，返回的迭代器的迭代顺序与 Map 对象的插入顺序相同</li>\n<li><code>forEach()</code> 方法将会以插入顺序对 Map 对象中的每一个键值对执行一次参数中提供的回调函数</li>\n<li><code>for...of</code> 可以直接遍历每个成员</li>\n</ul>\n<div><pre><code><span>let</span> map <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>[</span><span>[</span><span>'name'</span><span>,</span> <span>'zhangsan'</span><span>]</span><span>,</span> <span>[</span><span>'age'</span><span>,</span> <span>13</span><span>]</span><span>]</span><span>)</span>\n\nmap<span>.</span><span>forEach</span><span>(</span><span>(</span><span>value<span>,</span> key</span><span>)</span> <span>=></span> console<span>.</span><span>log</span><span>(</span>value<span>,</span> key<span>)</span><span>)</span> <span>// zhangsan name  // 13 'age'</span>\n\n<span>for</span> <span>(</span><span>let</span> <span>[</span>key<span>,</span> value<span>]</span> <span>of</span> map<span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>key<span>,</span> value<span>)</span>                            <span>// name zhangsan  // age 13</span>\n<span>}</span>\n\n<span>for</span> <span>(</span><span>let</span> key <span>of</span> map<span>.</span><span>keys</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>key<span>)</span>                                   <span>// name  // age</span>\n<span>}</span>\n\n<span>for</span> <span>(</span><span>let</span> value <span>of</span> map<span>.</span><span>values</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>value<span>)</span>                                 <span>// zhangsan  // 13</span>\n<span>}</span>\n\n<span>for</span> <span>(</span><span>let</span> <span>[</span>key<span>,</span> value<span>]</span> <span>of</span> map<span>.</span><span>entries</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>key<span>,</span> value<span>)</span>                            <span>// name zhangsan  // age 13</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>Object 也是按键值对存储和读取的，它们两者之间除了之前说的以外，还有其他一些区别。</p>\n<ul>\n<li>\n<p><strong>键的类型</strong></p>\n<p>一个 Object 的键只能是字符串或者 Symbol，但一个 Map 的键可以是任意值，包括函数、对象、基本类型。</p>\n</li>\n<li>\n<p><strong>键的顺序</strong></p>\n<p>Map 中的键值是有序的，而添加到对象中的键则不是。因此，当对它进行遍历时，Map 对象是按插入的顺序返回键值。</p>\n</li>\n<li>\n<p><strong>键值对的统计</strong></p>\n<p>可以通过 <code>size</code> 属性直接获取一个 Map 的键值对个数，而 Object 的键值对个数只能手动计算。</p>\n</li>\n<li>\n<p><strong>键值对的遍历</strong></p>\n<p>Map 可直接进行迭代，而 Object 的迭代需要先获取它的键数组，然后再进行迭代。</p>\n</li>\n<li>\n<p><strong>性能</strong></p>\n<p>Map 在涉及频繁增删键值对的场景下会<a href=\"https://blog.csdn.net/weixin_43398820/article/details/118056553\" target=\"_blank\" rel=\"noopener noreferrer\">有些性能优势</a>。</p>\n</li>\n</ul>\n<h2 id=\"weekmap\"> WeekMap</h2>\n<p>WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。</p>\n<div><pre><code><span>// WeakMap 可以使用 set 方法添加成员</span>\n<span>const</span> wm1 <span>=</span> <span>new</span> <span>WeakMap</span><span>(</span><span>)</span>\n<span>const</span> key <span>=</span> <span>{</span>\n  foo<span>:</span> <span>1</span>\n<span>}</span>\nwm1<span>.</span><span>set</span><span>(</span>key<span>,</span> <span>2</span><span>)</span>\nwm1<span>.</span><span>get</span><span>(</span>key<span>)</span> <span>// 2</span>\n\n<span>// WeakMap 也可以接受一个数组，</span>\n<span>// 作为构造函数的参数</span>\n<span>const</span> k1 <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span>\n<span>const</span> k2 <span>=</span> <span>[</span><span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>]</span>\n<span>const</span> wm2 <span>=</span> <span>new</span> <span>WeakMap</span><span>(</span><span>[</span>\n  <span>[</span>k1<span>,</span> <span>'foo'</span><span>]</span><span>,</span>\n  <span>[</span>k2<span>,</span> <span>'bar'</span><span>]</span>\n<span>]</span><span>)</span>\nwm2<span>.</span><span>get</span><span>(</span>k2<span>)</span> <span>// 'bar'</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>WeakMap 与 Map 的区别有两点：</p>\n<ul>\n<li>WeakMap 只接受对象作为键名（<code>null</code> 除外），不接受其他类型的值作为键名。</li>\n</ul>\n<div><pre><code><span>const</span> map <span>=</span> <span>new</span> <span>WeakMap</span><span>(</span><span>)</span>\nmap<span>.</span><span>set</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span>\n<span>// TypeError: 1 is not an object!</span>\nmap<span>.</span><span>set</span><span>(</span><span>Symbol</span><span>(</span><span>)</span><span>,</span> <span>2</span><span>)</span>\n<span>// TypeError: Invalid value used as weak map key</span>\nmap<span>.</span><span>set</span><span>(</span><span>null</span><span>,</span> <span>2</span><span>)</span>\n<span>// TypeError: Invalid value used as weak map key</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>\n<li>WeakMap 的键名所指向的对象，不计入垃圾回收机制（该特性同 WeakSet）。</li>\n</ul>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/set-map\" target=\"_blank\" rel=\"noopener noreferrer\">Set 和 Map 数据结构</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map\" target=\"_blank\" rel=\"noopener noreferrer\">Map</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_43398820/article/details/118056553\" target=\"_blank\" rel=\"noopener noreferrer\">Map和Object的性能对比</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-01-04T08:56:00.000Z",
      "date_modified": "2022-01-04T08:56:00.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Promise",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es6-promise/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es6-promise/",
      "content_html": "<h1 id=\"promise\"> Promise</h1>\n<h2 id=\"promise-简介\"> Promise 简介</h2>\n<p>Promise 是一种处理异步代码的方式，支持链式调用，可以解决回调地狱问题。</p>\n<details><summary>jQuery 回调地狱写法</summary>\n<div><pre><code><span>// 一个异步事件要依赖另一个异步事件的返回值</span>\n<span>// 可以发现每个异步请求是在函数里面一层一层嵌套的</span>\n<span>function</span> <span>ajax1</span><span>(</span><span>)</span> <span>{</span>\n  $<span>.</span><span>ajax</span><span>(</span><span>{</span>\n    type<span>:</span> <span>'POST'</span><span>,</span>\n    url<span>:</span> <span>''</span><span>,</span>\n    data<span>:</span> <span>{</span><span>}</span><span>,</span>\n    dataType<span>:</span> <span>'json'</span><span>,</span>\n    <span>success</span><span>:</span> <span>function</span><span>(</span><span>res</span><span>)</span> <span>{</span>\n      <span>ajax2</span><span>(</span>res<span>.</span>data<span>)</span>\n    <span>}</span>\n  <span>}</span><span>)</span>\n<span>}</span>\n<span>function</span> <span>ajax2</span><span>(</span><span>data</span><span>)</span> <span>{</span>\n  $<span>.</span><span>ajax</span><span>(</span><span>{</span>\n    type<span>:</span> <span>'POST'</span><span>,</span>\n    url<span>:</span> <span>''</span><span>,</span>\n    data<span>:</span> data<span>,</span>\n    dataType<span>:</span> <span>'json'</span><span>,</span>\n    <span>success</span><span>:</span> <span>function</span> <span>(</span><span>res</span><span>)</span> <span>{</span>\n      <span>ajax3</span><span>(</span>res<span>.</span>data<span>)</span>\n    <span>}</span>\n  <span>}</span><span>)</span>\n<span>}</span>\n<span>function</span> <span>ajax3</span><span>(</span><span>data</span><span>)</span> <span>{</span>\n  $<span>.</span><span>ajax</span><span>(</span><span>{</span>\n    type<span>:</span> <span>'POST'</span><span>,</span>\n    url<span>:</span> <span>''</span><span>,</span>\n    data<span>:</span> data<span>,</span>\n    dataType<span>:</span> <span>'json'</span><span>,</span>\n    <span>success</span><span>:</span> <span>function</span> <span>(</span><span>res</span><span>)</span> <span>{</span>\n      console<span>.</span><span>log</span><span>(</span>res<span>)</span>\n    <span>}</span>\n  <span>}</span><span>)</span>\n<span>}</span>\n\n<span>// 运行</span>\n<span>ajax1</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div></details>\n<details><summary>Promise 链式调用写法</summary>\n<div><pre><code><span>// Promise 是支持链式调用的</span>\n<span>// 使用方法是将 Promise 封装, 每次在 then 中执行完毕后返回一个新的 Promise</span>\n<span>const</span> ajax1 <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>function</span> <span>(</span><span>resolve<span>,</span>reject</span><span>)</span> <span>{</span>\n  $<span>.</span><span>ajax</span><span>(</span><span>{</span>\n    type<span>:</span> <span>'POST'</span><span>,</span>\n    url<span>:</span> <span>''</span><span>,</span>\n    data<span>:</span> <span>{</span><span>}</span><span>,</span>\n    dataType<span>:</span> <span>'json'</span><span>,</span>\n    <span>success</span><span>:</span> <span>function</span> <span>(</span><span>res</span><span>)</span> <span>{</span>\n      <span>resolve</span><span>(</span>res<span>.</span>data<span>)</span>\n    <span>}</span>\n  <span>}</span><span>)</span>\n<span>}</span><span>)</span>\n<span>function</span> <span>ajax2</span> <span>(</span><span>data</span><span>)</span> <span>{</span>\n  <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>function</span> <span>(</span><span>resolve<span>,</span>reject</span><span>)</span> <span>{</span>\n    $<span>.</span><span>ajax</span><span>(</span><span>{</span>\n      type<span>:</span> <span>'POST'</span><span>,</span>\n      url<span>:</span> <span>''</span><span>,</span>\n      data<span>:</span> data<span>,</span>\n      dataType<span>:</span> <span>'json'</span><span>,</span>\n      <span>success</span><span>:</span> <span>function</span> <span>(</span><span>res</span><span>)</span> <span>{</span>\n        <span>resolve</span><span>(</span>res<span>.</span>data<span>)</span>\n      <span>}</span>\n    <span>}</span><span>)</span>\n  <span>}</span><span>)</span>\n<span>}</span>\n<span>function</span> <span>ajax3</span> <span>(</span><span>data</span><span>)</span> <span>{</span>\n  <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>function</span> <span>(</span><span>resolve<span>,</span>reject</span><span>)</span> <span>{</span>\n    $<span>.</span><span>ajax</span><span>(</span><span>{</span>\n      type<span>:</span> <span>'POST'</span><span>,</span>\n      url<span>:</span> <span>''</span><span>,</span>\n      data<span>:</span> data<span>,</span>\n      dataType<span>:</span> <span>'json'</span><span>,</span>\n      <span>success</span><span>:</span> <span>function</span> <span>(</span><span>res</span><span>)</span> <span>{</span>\n        <span>resolve</span><span>(</span>res<span>.</span>data<span>)</span>\n      <span>}</span>\n    <span>}</span><span>)</span>\n  <span>}</span><span>)</span>\n<span>}</span>\n\n<span>// 运行</span>\najax1<span>.</span><span>then</span><span>(</span><span>function</span> <span>(</span><span>data</span><span>)</span> <span>{</span>\n  <span>return</span> <span>ajax2</span><span>(</span>data<span>)</span>\n<span>}</span><span>)</span><span>.</span><span>then</span><span>(</span><span>function</span> <span>(</span><span>data</span><span>)</span> <span>{</span>\n  <span>return</span> <span>ajax3</span><span>(</span>data<span>)</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div></details>\n<p>Promise 对象有三种状态：pending（等待中）、fulfilled（已成功）和 rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</p>\n<p>一个 Promise 必然处于以下几种状态之一：</p>\n<ul>\n<li>等待中（pending）：初始状态，既没有被兑现，也没有被拒绝。</li>\n<li>已成功（fulfilled）：意味着操作成功。</li>\n<li>已拒绝（rejected）：意味着操作失败。</li>\n</ul>\n<h2 id=\"基本语法\"> 基本语法</h2>\n<p>创建 Promise 实例：</p>\n<div><pre><code><span>const</span> promise <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>function</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>{</span>\n  <span>// ... some code</span>\n\n  <span>if</span> <span>(</span> <span>/* 异步操作成功 */</span> <span>)</span> <span>{</span>\n    <span>resolve</span><span>(</span>value<span>)</span>\n  <span>}</span> <span>else</span> <span>{</span>\n    <span>reject</span><span>(</span>error<span>)</span>\n  <span>}</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 <code>resolve</code> 和 <code>reject</code>，它们都是函数类型，由 JavaScript 引擎提供，不用自己实现。</p>\n<ul>\n<li>处理结果正常的话，调用 <code>resolve(处理结果值)</code>，将 Promise 对象的状态从「等待中」变为「成功」（即从 pending 变为 fulfilled）。该函数在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。</li>\n<li>处理结果错误的话，调用 <code>reject(错误信息)</code>，将 Promise 对象的状态从「等待中」变为「失败」（即从 pending 变为 rejected）。该函数在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</li>\n</ul>\n<p>Promise 内部的状态（pending、fulfilled、rejected）走向如下图所示：</p>\n<div style=\"text-align: center;\">\n  <svg id=\"SvgjsSvg1006\" width=\"631\" height=\"258\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><defs id=\"SvgjsDefs1007\"><marker id=\"SvgjsMarker1050\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1051\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#e57373\" stroke=\"#e57373\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1054\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1055\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#e57373\" stroke=\"#e57373\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1058\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1059\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#e57373\" stroke=\"#e57373\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1062\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1063\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#e57373\" stroke=\"#e57373\" stroke-width=\"1\"></path></marker></defs><g id=\"SvgjsG1008\" transform=\"translate(25,108)\"><path id=\"SvgjsPath1009\" d=\"M 0 0L 149 0L 149 42L 0 42Z\" stroke=\"rgba(229,115,115,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1010\"><text id=\"SvgjsText1011\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"129px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"9\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1012\" dy=\"20\" x=\"74.5\"><tspan id=\"SvgjsTspan1013\" style=\"text-decoration:;\">state: 'pending'</tspan></tspan></text></g></g><g id=\"SvgjsG1014\" transform=\"translate(41,69)\"><path id=\"SvgjsPath1015\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1016\"><text id=\"SvgjsText1017\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"120px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1018\" dy=\"20\" x=\"60\"><tspan id=\"SvgjsTspan1019\" style=\"text-decoration:;\">new Promise</tspan></tspan></text></g></g><g id=\"SvgjsG1020\" transform=\"translate(260,43)\"><path id=\"SvgjsPath1021\" d=\"M 0 0L 149 0L 149 42L 0 42Z\" stroke=\"rgba(229,115,115,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1022\"><text id=\"SvgjsText1023\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"129px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"9\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1024\" dy=\"20\" x=\"74.5\"><tspan id=\"SvgjsTspan1025\" style=\"text-decoration:;\">resolve(res)</tspan></tspan></text></g></g><g id=\"SvgjsG1026\" transform=\"translate(260,174)\"><path id=\"SvgjsPath1027\" d=\"M 0 0L 149 0L 149 42L 0 42Z\" stroke=\"rgba(229,115,115,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1028\"><text id=\"SvgjsText1029\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"129px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"9\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1030\" dy=\"20\" x=\"74.5\"><tspan id=\"SvgjsTspan1031\" style=\"text-decoration:;\">reject(err)</tspan></tspan></text></g></g><g id=\"SvgjsG1032\" transform=\"translate(457,43)\"><path id=\"SvgjsPath1033\" d=\"M 0 0L 149 0L 149 42L 0 42Z\" stroke=\"rgba(229,115,115,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1034\"><text id=\"SvgjsText1035\" font-family=\"微软雅黑\" text-anchor=\"start\" font-size=\"16px\" width=\"129px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"start\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"-1\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1036\" dy=\"20\" x=\"10\"><tspan id=\"SvgjsTspan1037\" style=\"text-decoration:;\">state: 'fulfilled'</tspan></tspan><tspan id=\"SvgjsTspan1038\" dy=\"20\" x=\"10\"><tspan id=\"SvgjsTspan1039\" style=\"text-decoration:;\">result: res</tspan></tspan></text></g></g><g id=\"SvgjsG1040\" transform=\"translate(457,174)\"><path id=\"SvgjsPath1041\" d=\"M 0 0L 149 0L 149 42L 0 42Z\" stroke=\"rgba(229,115,115,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1042\"><text id=\"SvgjsText1043\" font-family=\"微软雅黑\" text-anchor=\"start\" font-size=\"16px\" width=\"129px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"start\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"-1\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1044\" dy=\"20\" x=\"10\"><tspan id=\"SvgjsTspan1045\" style=\"text-decoration:;\">state: 'rejected'</tspan></tspan><tspan id=\"SvgjsTspan1046\" dy=\"20\" x=\"10\"><tspan id=\"SvgjsTspan1047\" style=\"text-decoration:;\">result: err</tspan></tspan></text></g></g><g id=\"SvgjsG1048\"><path id=\"SvgjsPath1049\" d=\"M410 64L433 64L433 64L453.4 64\" stroke=\"#e57373\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1050)\"></path></g><g id=\"SvgjsG1052\"><path id=\"SvgjsPath1053\" d=\"M410 195L433 195L433 195L453.4 195\" stroke=\"#e57373\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1054)\"></path></g><g id=\"SvgjsG1056\"><path id=\"SvgjsPath1057\" d=\"M175 129L193 129L193 64L256.4 64\" stroke=\"#e57373\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1058)\"></path></g><g id=\"SvgjsG1060\"><path id=\"SvgjsPath1061\" d=\"M175 129L193 129L193 195L256.4 195\" stroke=\"#e57373\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1062)\"></path></g><g id=\"SvgjsG1064\" transform=\"translate(161,25)\"><path id=\"SvgjsPath1065\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1066\"><text id=\"SvgjsText1067\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"120px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1068\" dy=\"20\" x=\"60\"><tspan id=\"SvgjsTspan1069\" style=\"text-decoration:;\">成功</tspan></tspan></text></g></g><g id=\"SvgjsG1070\" transform=\"translate(161,193)\"><path id=\"SvgjsPath1071\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1072\"><text id=\"SvgjsText1073\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"120px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1074\" dy=\"20\" x=\"60\"><tspan id=\"SvgjsTspan1075\" style=\"text-decoration:;\">失败</tspan></tspan></text></g></g></svg>\n  <p style=\"text-align: center; color: #888;\">（Promise 状态的走向）</p>\n</div>\n<h2 id=\"promise-prototype-then\"> Promise.prototype.then()</h2>\n<p><strong>基本语法</strong></p>\n<blockquote>\n<p>promise.then(onFulfilled, onRejected)</p>\n</blockquote>\n<p>Promise 实例生成以后，可以用 <code>then</code> 方法指定 fulfilled 状态和 rejected 状态的回调函数。该方法的第一个参数又名 onFulfilled，第二个参数又名 onRejected，都应是函数类型。</p>\n<div><pre><code>promise<span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>value</span><span>)</span> <span>{</span>\n  <span>// success</span>\n<span>}</span><span>,</span> <span>function</span><span>(</span><span>error</span><span>)</span> <span>{</span>\n  <span>// failure</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>示例</strong></p>\n<div><pre><code><span>let</span> p1 <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>resolve</span><span>(</span><span>'p1 成功'</span><span>)</span>\n  <span>reject</span><span>(</span><span>'p1 失败'</span><span>)</span>\n<span>}</span><span>)</span>\n\n<span>let</span> p2 <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>reject</span><span>(</span><span>'p2 失败'</span><span>)</span>\n  <span>resolve</span><span>(</span><span>'p2 成功'</span><span>)</span>\n<span>}</span><span>)</span>\n\n<span>let</span> p3 <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>throw</span><span>(</span><span>'p3 报错'</span><span>)</span>\n<span>}</span><span>)</span>\n\np1<span>.</span><span>then</span><span>(</span><span>value</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>value<span>)</span>\n<span>}</span><span>,</span> <span>error</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>error<span>)</span>\n<span>}</span><span>)</span>\n\np2<span>.</span><span>then</span><span>(</span><span>value</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>value<span>)</span>\n<span>}</span><span>,</span> <span>error</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>error<span>)</span>\n<span>}</span><span>)</span>\n\np3<span>.</span><span>then</span><span>(</span><span>value</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>value<span>)</span>\n<span>}</span><span>,</span> <span>error</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>error<span>)</span>\n<span>}</span><span>)</span>\n\n<span>// \"p1 成功\"</span>\n<span>// \"p2 失败\"</span>\n<span>// \"p3 报错\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><p>这里包含了四个知识点：</p>\n<ul>\n<li>执行了 <code>resolve</code>，Promise 状态会变成 <code>fulfilled</code>，即「已完成状态」。</li>\n<li>执行了 <code>reject</code>，Promise 状态会变成 <code>rejected</code>，即「被拒绝状态」。</li>\n<li>Promise 状态的改变不可逆，第一次成功就永久为 <code>fulfilled</code>，第一次失败就永久为 <code>rejected</code>。</li>\n<li>Promise 中有 <code>throw</code> 的话，就相当于执行了 <code>reject</code>。</li>\n</ul>\n<h2 id=\"promise-prototype-catch\"> Promise.prototype.catch()</h2>\n<p>可以使用 Promise 对象的 <code>catch</code> 方法来捕获异步操作过程中出现的任何异常。</p>\n<p><strong>基本语法</strong></p>\n<blockquote>\n<p>p.catch(onRejected)</p>\n</blockquote>\n<blockquote>\n<p>p.catch(function(reason) { // rejection })</p>\n</blockquote>\n<p><strong>示例</strong></p>\n<div><pre><code><span>function</span> <span>test</span><span>(</span><span>)</span> <span>{</span>\n  <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n    <span>reject</span><span>(</span><span>new</span> <span>Error</span><span>(</span><span>'es'</span><span>)</span><span>)</span>\n  <span>}</span><span>)</span>\n<span>}</span>\n\n<span>test</span><span>(</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>(</span><span>e</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>e<span>.</span>message<span>)</span> <span>// es</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><p>注意</p>\n<p>虽然都能被 <code>catch</code> 捕获到，但不建议在 Promise 内部使用 <code>throw new Error()</code> 来触发异常，而应该使用 <code>reject(new Error())</code> 的方式来做，因为 <code>throw</code> 的方式并没有改变 Promise 的状态。</p>\n</div>\n<h2 id=\"promise-resolve\"> Promise.resolve()</h2>\n<p>静态方法 <code>Promise.resolve(value)</code> 可以认为是 <code>new Promise()</code> 方法的快捷方式。</p>\n<p>比如下面两个写法是等价的：</p>\n<div><pre><code><span>// 写法一</span>\nPromise<span>.</span><span>resolve</span><span>(</span><span>42</span><span>)</span>\n\n<span>// 写法二</span>\n<span>new</span> <span>Promise</span><span>(</span><span>function</span><span>(</span><span>resolve</span><span>)</span> <span>{</span>\n  <span>resolve</span><span>(</span><span>42</span><span>)</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面代码中的 <code>resolve(42)</code> 会让这个 Promise 对象立即进入确定（即 fulfilled）状态，并将 <code>42</code> 传递给后面 <code>then</code> 里所指定的 onFulfilled 函数。</p>\n<p>方法 <code>Promise.resolve(value)</code> 的返回值也是一个 Promise 对象，所以我们可以像下面那样接着对其返回值进行 <code>.then</code> 调用：</p>\n<div><pre><code>Promise<span>.</span><span>resolve</span><span>(</span><span>42</span><span>)</span><span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>value</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>value<span>)</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这种简写方式在进行 Promise 对象的初始化或者编写测试代码的时候都非常方便。</p>\n<h2 id=\"promise-reject\"> Promise.reject()</h2>\n<p><code>Promise.reject(error)</code> 是和 <code>Promise.resolve(value)</code> 类似的静态方法，是 <code>new Promise()</code> 方法的快捷方式。</p>\n<p>下面两个写法是等价的：</p>\n<div><pre><code><span>// 写法一</span>\nPromise<span>.</span><span>reject</span><span>(</span><span>new</span> <span>Error</span><span>(</span><span>\"出错了\"</span><span>)</span><span>)</span>\n\n<span>// 写法二</span>\n<span>new</span> <span>Promise</span><span>(</span><span>function</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>{</span>\n  <span>reject</span><span>(</span><span>new</span> <span>Error</span><span>(</span><span>'出错了'</span><span>)</span><span>)</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>这段代码的功能是调用该 Promise 对象通过 <code>.then</code> 指定的 onRejected 函数，并将错误（Error）对象传递给这个 onRejected 函数。</p>\n<div><pre><code>Promise<span>.</span><span>reject</span><span>(</span><span>new</span> <span>Error</span><span>(</span><span>'BOOM!'</span><span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"promise-all\"> Promise.all()</h2>\n<p><strong>基本语法</strong></p>\n<blockquote>\n<p>Promise.all(promiseArray)</p>\n</blockquote>\n<p><strong>示例</strong></p>\n<div><pre><code><span>var</span> p1 <span>=</span> Promise<span>.</span><span>resolve</span><span>(</span><span>1</span><span>)</span>\n<span>var</span> p2 <span>=</span> Promise<span>.</span><span>resolve</span><span>(</span><span>2</span><span>)</span>\n<span>var</span> p3 <span>=</span> Promise<span>.</span><span>resolve</span><span>(</span><span>3</span><span>)</span>\nPromise<span>.</span><span>all</span><span>(</span><span>[</span>p1<span>,</span> p2<span>,</span> p3<span>]</span><span>)</span><span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>results</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>results<span>)</span> <span>// [1, 2, 3]</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><code>Promise.all()</code> 生成并返回一个新的 Promise 对象，所以它可以使用 Promise 实例的所有方法。参数传递 promise 数组中所有的 Promise 对象都变为 <code>resolve</code> 的时候，该方法才会返回，新创建的 Promise 则会使用这些 promise 的值。</p>\n<p>如果参数中的任何一个 promise 为 <code>reject</code> 的话，则整个 Promise.all 调用会立即终止，并返回一个 <code>reject</code> 的新的 Promise 对象。</p>\n<p>由于参数数组中的每个元素都是由 Promise.resolve 包装（wrap）的，所以 Promise.all 可以处理不同类型的 Promise 对象。</p>\n<h2 id=\"promise-race\"> Promise.race()</h2>\n<p><strong>基本语法</strong></p>\n<blockquote>\n<p>Promise.race(promiseArray)</p>\n</blockquote>\n<p><strong>示例</strong></p>\n<div><pre><code><span>var</span> p1 <span>=</span> Promise<span>.</span><span>resolve</span><span>(</span><span>1</span><span>)</span>\n<span>var</span> p2 <span>=</span> Promise<span>.</span><span>resolve</span><span>(</span><span>2</span><span>)</span>\n<span>var</span> p3 <span>=</span> Promise<span>.</span><span>resolve</span><span>(</span><span>3</span><span>)</span>\nPromise<span>.</span><span>race</span><span>(</span><span>[</span>p1<span>,</span> p2<span>,</span> p3<span>]</span><span>)</span><span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>value</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>value<span>)</span> <span>// 1</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><code>Promise.race()</code> 生成并返回一个新的 Promise 对象。</p>\n<p>参数 promise 数组中的任何一个 Promise 对象如果变为 <code>resolve</code> 或者 <code>reject</code> 的话，该函数就会返回，并使用这个 Promise 对象的值进行 <code>resolve</code> 或者 <code>reject</code>。</p>\n<h2 id=\"参考文档\"> 参考文档</h2>\n<ul>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/promise\" target=\"_blank\" rel=\"noopener noreferrer\">Promise 对象</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise\" target=\"_blank\" rel=\"noopener noreferrer\">Promise</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch\" target=\"_blank\" rel=\"noopener noreferrer\">Fetch</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-01-13T09:38:24.000Z",
      "date_modified": "2022-03-07T07:54:14.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Object 扩展",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es6-object/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es6-object/",
      "content_html": "<h1 id=\"object-扩展\"> Object 扩展</h1>\n<h2 id=\"属性简洁表示法\"> 属性简洁表示法</h2>\n<p>在 ES6 之前 Object 的属性必须是 key-value 形式。</p>\n<div><pre><code><span>let</span> name <span>=</span> <span>'zhangsan'</span>\n<span>let</span> age <span>=</span> <span>13</span>\n<span>let</span> obj <span>=</span> <span>{</span>\n  name<span>:</span> name<span>,</span>\n  age<span>:</span> age<span>,</span>\n  <span>study</span><span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>name <span>+</span> <span>'在自学前端'</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>在 ES6 之后是可以用简写的形式来表达。</p>\n<div><pre><code><span>let</span> name <span>=</span> <span>'zhangsan'</span>\n<span>let</span> age <span>=</span> <span>13</span>\n<span>let</span> obj <span>=</span> <span>{</span>\n  name<span>,</span>\n  age<span>,</span>\n  <span>study</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>name <span>+</span> <span>'在自学前端'</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id=\"属性名表达式\"> 属性名表达式</h2>\n<p>在 ES6 可以直接用变量或者表达式来定义 Object 的 key。</p>\n<div><pre><code><span>let</span> s <span>=</span> <span>'school'</span>\n<span>let</span> obj <span>=</span> <span>{</span>\n  name<span>:</span> <span>'zhangsan'</span><span>,</span>\n  <span>[</span>s<span>]</span><span>:</span> <span>'mit'</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"object-is\"> Object.is()</h2>\n<p>判断两个对象是否相等，与严格比较运算符（<code>===</code>）的行为基本一致。</p>\n<div><pre><code><span>// new Object()</span>\n<span>let</span> obj1 <span>=</span> <span>{</span>\n  name<span>:</span> <span>'zhangsan'</span><span>,</span>\n  age<span>:</span> <span>13</span>\n<span>}</span>\n\n<span>// new Object()</span>\n<span>let</span> obj2 <span>=</span> <span>{</span>\n  name<span>:</span> <span>'zhangsan'</span><span>,</span>\n  age<span>:</span> <span>13</span>\n<span>}</span>\nconsole<span>.</span><span>log</span><span>(</span>obj1 <span>==</span> obj2<span>)</span>          <span>// false</span>\nconsole<span>.</span><span>log</span><span>(</span>Object<span>.</span><span>is</span><span>(</span>obj1<span>,</span> obj2<span>)</span><span>)</span> <span>// false</span>\n\n<span>let</span> obj3 <span>=</span> obj1\nconsole<span>.</span><span>log</span><span>(</span>obj1 <span>===</span> obj3<span>)</span>         <span>// true</span>\nconsole<span>.</span><span>log</span><span>(</span>Object<span>.</span><span>is</span><span>(</span>obj1<span>,</span> obj3<span>)</span><span>)</span> <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id=\"object-assign\"> Object.assign()</h2>\n<p>用于将所有可枚举属性的值从一个或多个源对象复制到目标对象，它将返回目标对象。</p>\n<p><strong>语法</strong></p>\n<blockquote>\n<p>Object.assign(target, ...sources)</p>\n</blockquote>\n<p><strong>解释</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n<th>必选</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>target</td>\n<td>目标对象</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>sources</td>\n<td>源对象</td>\n<td>N</td>\n</tr>\n</tbody>\n</table>\n<p>从语法上可以看出源对象的个数是不限制的（零个或多个），如果是零个直接返回目标对象，如果是多个，相同属性会被位于后边的源对象属相覆盖。</p>\n<div><pre><code><span>let</span> target <span>=</span> <span>{</span> a<span>:</span> <span>1</span> <span>}</span>\n\n<span>let</span> source1 <span>=</span> <span>{</span> a<span>:</span> <span>2</span><span>,</span> b<span>:</span> <span>2</span> <span>}</span>\n<span>let</span> source2 <span>=</span> <span>{</span> a<span>:</span> <span>3</span><span>,</span> c<span>:</span> <span>3</span> <span>}</span>\n\nObject<span>.</span><span>assign</span><span>(</span>target<span>,</span> source1<span>,</span> source2<span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>target<span>)</span> <span>// {a:3, b:2, c:3}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><code>Object.assign()</code> 对于引用数据类型属于浅拷贝，也就是说对于同名属性，后面的源对象会整个的覆盖位于前面的源对象。</p>\n<p>如下，复制后 <code>age</code> 属性消失了，因为源对象中的 <code>desc</code> 里没有 <code>age</code>。</p>\n<div><pre><code><span>let</span> target <span>=</span> <span>{</span>\n  desc<span>:</span> <span>{</span>\n    name<span>:</span> <span>'zhangsan'</span><span>,</span>\n    age<span>:</span> <span>'13'</span>\n  <span>}</span>\n<span>}</span>\n<span>let</span> source <span>=</span> <span>{</span>\n  desc<span>:</span> <span>{</span>\n    name<span>:</span> <span>'lisi'</span>\n  <span>}</span>\n<span>}</span>\n\nObject<span>.</span><span>assign</span><span>(</span>target<span>,</span> source<span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>target<span>)</span> <span>// { desc: { name: 'lisi' } }</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id=\"对象的遍历方式\"> 对象的遍历方式</h2>\n<h3 id=\"for-in\"> for...in</h3>\n<p>for...in 可以遍历出对象的 key，然后通过 key 获取值。</p>\n<div><pre><code><span>let</span> obj <span>=</span> <span>{</span>\n  name<span>:</span> <span>'zhangsan'</span><span>,</span>\n  age<span>:</span> <span>13</span><span>,</span>\n  school<span>:</span> <span>'mit'</span>\n<span>}</span>\n\n<span>for</span> <span>(</span><span>let</span> key <span>in</span> obj<span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>key<span>,</span> obj<span>[</span>key<span>]</span><span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"object-keys\"> Object.keys()</h3>\n<p>用于返回对象所有 key 组成的数组。</p>\n<div><pre><code><span>let</span> obj <span>=</span> <span>{</span>\n  name<span>:</span> <span>'zhangsan'</span><span>,</span>\n  age<span>:</span> <span>13</span><span>,</span>\n  school<span>:</span> <span>'mit'</span>\n<span>}</span>\n\nObject<span>.</span><span>keys</span><span>(</span>obj<span>)</span><span>.</span><span>forEach</span><span>(</span><span>key</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>key<span>,</span> obj<span>[</span>key<span>]</span><span>)</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"object-getownpropertynames\"> Object.getOwnPropertyNames()</h3>\n<p>用于返回对象所有 key 组成的数组。</p>\n<div><pre><code><span>let</span> obj <span>=</span> <span>{</span>\n  name<span>:</span> <span>'zhangsan'</span><span>,</span>\n  age<span>:</span> <span>13</span><span>,</span>\n  school<span>:</span> <span>'mit'</span>\n<span>}</span>\n\nObject<span>.</span><span>getOwnPropertyNames</span><span>(</span>obj<span>)</span><span>.</span><span>forEach</span><span>(</span><span>key</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>key<span>,</span> obj<span>[</span>key<span>]</span><span>)</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"reflect-ownkeys\"> Reflect.ownKeys()</h3>\n<p>用于返回对象所有 key 组成的数组。</p>\n<div><pre><code><span>let</span> obj <span>=</span> <span>{</span>\n  name<span>:</span> <span>'zhangsan'</span><span>,</span>\n  age<span>:</span> <span>13</span><span>,</span>\n  school<span>:</span> <span>'mit'</span>\n<span>}</span>\n\nReflect<span>.</span><span>ownKeys</span><span>(</span>obj<span>)</span><span>.</span><span>forEach</span><span>(</span><span>key</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>key<span>,</span> obj<span>[</span>key<span>]</span><span>)</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/object-methods\" target=\"_blank\" rel=\"noopener noreferrer\">对象的新增方法</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\" target=\"_blank\" rel=\"noopener noreferrer\">Object.assign()</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-01-02T02:56:52.000Z",
      "date_modified": "2022-01-11T09:14:24.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Module",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es6-module/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es6-module/",
      "content_html": "<h1 id=\"module\"> Module</h1>\n<h2 id=\"模块化的发展\"> 模块化的发展</h2>\n<p>随着项目中引入的 js 文件越来越多，模块化解决的问题：</p>\n<ul>\n<li>全局变量污染：各个文件的变量都是挂载到 <code>window</code> 对象上，污染全局变量。</li>\n<li>变量重名：不同文件中的变量如果重名，后面的会覆盖前面的，造成程序运行错误。</li>\n<li>文件依赖顺序：多个文件之间存在依赖关系，需要保证一定加载顺序问题严重。</li>\n</ul>\n<p>在模块化思想中，每个 js 文件被看作是一个模块，每个模块通过固定的方式引入，并且通过固定的方式向外暴露指定的内容。一个个模块按照其依赖关系组合，最终插入到主程序中。</p>\n<p>模块化的发展历史：</p>\n<p>无模块化 --&gt; CommonJS 规范 --&gt; AMD 规范--&gt; CMD 规范--&gt; ES6 模块化</p>\n<h3 id=\"commonjs-规范\"> CommonJS 规范</h3>\n<p>Commonjs 是 Node 中模块化规范，它的诞生给了 js 模块化发展重要的启发。但是局限性很明显：Commonjs 基于 Node 原生 api 在服务端可以实现模块同步加载，但是仅仅局限于服务端，客户端如果同步加载依赖的话时间消耗非常大，所以需要一个在客户端上基于 Commonjs 但是对于加载模块做改进的方案，于是 AMD 规范诞生了。</p>\n<div><pre><code><span>// utils.js 文件</span>\n<span>function</span> <span>add</span><span>(</span><span>a<span>,</span>b</span><span>)</span><span>{</span>\n  <span>return</span> a <span>+</span> b\n<span>}</span>\nmodule<span>.</span>exports <span>=</span> <span>{</span> add <span>}</span>\n\n<span>// main.js</span>\n<span>var</span> nameModule <span>=</span> <span>require</span><span>(</span><span>'./utils.js'</span><span>)</span> \nnameModule<span>.</span><span>add</span><span>(</span><span>1</span><span>,</span><span>2</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"amd-规范\"> AMD 规范</h3>\n<p>异步模块定义，允许指定回调函数。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到所有依赖加载完成之后（前置依赖），这个回调函数才会运行。</p>\n<blockquote>\n<p><a href=\"https://github.com/amdjs/amdjs-api/wiki/AMD\" target=\"_blank\" rel=\"noopener noreferrer\">AMD</a> 是 RequireJS 在推广过程中对模块定义的规范化产出（使用 AMD 必须用到 RequireJS 库函数）。</p>\n</blockquote>\n<div><pre><code><span>require</span><span>(</span><span>[</span>module<span>]</span><span>,</span> callback<span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"cmd-规范\"> CMD 规范</h3>\n<p>同样是受到 Commonjs 的启发，国内（阿里）诞生了一个 CMD（Common Module Definition）规范。该规范借鉴了 Commonjs 的规范与 AMD 规范，在两者基础上做了改进。</p>\n<blockquote>\n<p><a href=\"https://github.com/seajs/seajs/issues/242\" target=\"_blank\" rel=\"noopener noreferrer\">CMD</a> 是 SeaJS 在推广过程中对模块定义的规范化产出。</p>\n</blockquote>\n<p>AMD 和 CMD 区别：</p>\n<ul>\n<li>AMD 是依赖关系前置，在定义模块的时候就要声明其依赖的模块</li>\n<li>CMD 是按需加载依赖就近，只有在用到某个模块的时候再去 require</li>\n</ul>\n<div><pre><code><span>// AMD 默认推荐的是</span>\n<span>define</span><span>(</span><span>[</span><span>'./a'</span><span>,</span> <span>'./b'</span><span>]</span><span>,</span> <span>function</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>{</span> <span>// 依赖必须一开始就写好</span>\n  a<span>.</span><span>doSomething</span><span>(</span><span>)</span>\n  <span>// 此处略去 100 行</span>\n  b<span>.</span><span>doSomething</span><span>(</span><span>)</span>\n  <span>...</span>\n<span>}</span><span>)</span> \n\n<span>// CMD</span>\n<span>define</span><span>(</span><span>function</span><span>(</span><span>require<span>,</span> exports<span>,</span> module</span><span>)</span> <span>{</span>\n  <span>var</span> a <span>=</span> <span>require</span><span>(</span><span>'./a'</span><span>)</span>\n  a<span>.</span><span>doSomething</span><span>(</span><span>)</span>\n  <span>// 此处略去 100 行</span>\n  <span>var</span> b <span>=</span> <span>require</span><span>(</span><span>'./b'</span><span>)</span> <span>// 依赖可以就近书写</span>\n  b<span>.</span><span>doSomething</span><span>(</span><span>)</span>\n  <span>// ... </span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id=\"es6-规范\"> ES6 规范</h3>\n<p>ES6 规范中，将模块化纳入 JavaScript 标准，从此 js 模块化被官方扶正。</p>\n<p>在 ES6 中，使用 <code>import</code> 关键字引入模块，通过 <code>exprot</code> 关键字导出模块，功能较之于前几个方案更为强大。但是由于 ES6 目前无法在浏览器中执行，所以只能通过 babel 将不被支持的 <code>import</code> 编译为当前受到广泛支持的 <code>require</code>。</p>\n<h2 id=\"export\"> export</h2>\n<p>模块功能主要由两个命令构成：<code>export</code> 和 <code>import</code>。<code>export</code> 命令用于规定模块的对外接口，<code>import</code> 命令用于输入其他模块提供的功能。</p>\n<p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用 <code>export</code> 关键字输出该变量。</p>\n<h3 id=\"导出变量或者常量\"> 导出变量或者常量</h3>\n<div><pre><code><span>export</span> <span>const</span> name <span>=</span> <span>'zhangsan'</span>\n<span>export</span> <span>let</span> addr <span>=</span> <span>'BeiJing City'</span>\n<span>export</span> <span>var</span> list <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>或者</p>\n<div><pre><code><span>const</span> name <span>=</span> <span>'zhangsan'</span>\n<span>let</span> addr <span>=</span> <span>'BeiJing City'</span>\n<span>var</span> list <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span>\n<span>export</span> <span>{</span>\n  name<span>,</span>\n  addr<span>,</span>\n  list\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"导出函数\"> 导出函数</h3>\n<div><pre><code><span>export</span> <span>function</span> <span>say</span><span>(</span><span>content</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>content<span>)</span>\n<span>}</span>\n<span>export</span> <span>function</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'run'</span><span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>或者</p>\n<div><pre><code><span>const</span> <span>say</span> <span>=</span> <span>(</span><span>content</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>content<span>)</span>\n<span>}</span>\n<span>let</span> <span>run</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'run'</span><span>)</span>\n<span>}</span>\n<span>export</span> <span>{</span>\n  say<span>,</span>\n  run\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"导出-object\"> 导出 Object</h3>\n<div><pre><code><span>export</span> <span>(</span><span>{</span>\n  code<span>:</span> <span>0</span><span>,</span>\n  message<span>:</span> <span>'success'</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>或者</p>\n<div><pre><code><span>let</span> data <span>=</span> <span>{</span>\n  code<span>:</span> <span>0</span><span>,</span>\n  message<span>:</span> <span>'success'</span>\n<span>}</span>\n<span>export</span> <span>{</span>\n  data\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"导出-class\"> 导出 Class</h3>\n<div><pre><code><span>class</span> <span>Test</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>id <span>=</span> <span>2</span>\n  <span>}</span>\n<span>}</span>\n<span>export</span> <span>{</span>\n  Test\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>或者</p>\n<div><pre><code><span>export</span> <span>class</span> <span>Test</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>id <span>=</span> <span>2</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"as\"> as</h2>\n<p>如果想为输入的变量重新取一个名字，<code>import</code> 命令要使用 <code>as</code> 关键字，将输入的变量重命名。</p>\n<div><pre><code><span>const</span> name <span>=</span> <span>'zhangsan'</span>\n<span>let</span> addr <span>=</span> <span>'BeiJing City'</span>\n<span>var</span> list <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span>\n<span>export</span> <span>{</span>\n  name <span>as</span> cname<span>,</span>\n  addr <span>as</span> caddr<span>,</span>\n  list\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"export-default\"> export default</h2>\n<p>使用 <code>import</code> 命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。</p>\n<p>为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到 <code>export default</code> 命令，为模块指定默认输出。</p>\n<div><pre><code><span>const</span> name <span>=</span> <span>'zhangsan'</span>\n<span>let</span> addr <span>=</span> <span>'BeiJing City'</span>\n<span>var</span> list <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span>\n<span>export</span> <span>{</span>\n  name <span>as</span> cname<span>,</span>\n  addr <span>as</span> caddr\n<span>}</span>\n<span>export</span> <span>default</span> list\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ul>\n<li>使用 <code>export default</code> 时，对应的 <code>import</code> 语句不需要使用大括号。\n<ul>\n<li>一个模块只能有一个默认输出，该命令只能使用一次，因此 <code>import</code> 命令只可能唯一对应 <code>export default</code> 命令，后面才不用加大括号。</li>\n</ul>\n</li>\n<li>不使用 <code>export default</code> 时，对应的 <code>import</code> 语句需要使用大括号。</li>\n</ul>\n<h2 id=\"import\"> import</h2>\n<p>使用 <code>export</code> 命令定义了模块的对外接口以后，其他 JS 文件就可以通过 <code>import</code> 命令加载这个模块。</p>\n<h3 id=\"直接导入\"> 直接导入</h3>\n<p>假设导出模块 A 是这样的：</p>\n<div><pre><code><span>const</span> name <span>=</span> <span>'zhangsan'</span>\n<span>let</span> addr <span>=</span> <span>'BeiJing City'</span>\n<span>var</span> list <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span>\n<span>export</span> <span>{</span>\n  name <span>as</span> cname<span>,</span>\n  addr <span>as</span> caddr\n<span>}</span>\n<span>export</span> <span>default</span> list\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>则导入：</p>\n<div><pre><code><span>import</span> list<span>,</span> <span>{</span>\n  cname<span>,</span>\n  caddr\n<span>}</span> <span>from</span> <span>A</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面代码中：</p>\n<ul>\n<li><code>list</code> 是使用 <code>export default</code> 导出的，对应的 <code>import</code> 语句不需要使用大括号。</li>\n<li>其他的是使用 <code>export</code> 导出的，对应的 <code>import</code> 语句需要使用大括号。</li>\n</ul>\n<h3 id=\"修改导入名称\"> 修改导入名称</h3>\n<div><pre><code><span>import</span> list<span>,</span> <span>{</span>\n  cname <span>as</span> name<span>,</span>\n  caddr\n<span>}</span> <span>from</span> <span>A</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"批量导入\"> 批量导入</h3>\n<div><pre><code><span>import</span> list<span>,</span> <span>*</span> <span>as</span> mod <span>from</span> <span>A</span>\nconsole<span>.</span><span>log</span><span>(</span>list<span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>mod<span>.</span>cname<span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>mod<span>.</span>caddr<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"参考文档\"> 参考文档</h2>\n<ul>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/module\" target=\"_blank\" rel=\"noopener noreferrer\">Module 的语法</a></li>\n<li><a href=\"https://hackernoon.com/import-export-default-require-commandjs-javascript-nodejs-es6-vs-cheatsheet-different-tutorial-example-5a321738b50f\" target=\"_blank\" rel=\"noopener noreferrer\">import, export, default cheatsheet</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-01-17T09:55:03.000Z",
      "date_modified": "2022-01-17T09:55:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Proxy",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es6-proxy/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es6-proxy/",
      "content_html": "<h1 id=\"proxy\"> Proxy</h1>\n<div><p>缺乏实战</p>\n<p>Proxy 在学习的时候深感很强大、很强大。但是实际用的时候，很多时候觉得发挥不出它的精华，所以没有找到一用就如虎添翼的感觉。<br>\n后续有待从开源项目（以知名框架为主）中学习它的应用场景。</p>\n</div>\n<p>在 ES6 标准中新增的一个非常强大的功能是 Proxy，它可以用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种「元编程」（meta programming），即对编程语言进行编程。</p>\n<p>Proxy 可以理解成，在目标对象之前架设一层「拦截」，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p>\n<p>Proxy 这个词的原意是代理，用在这里表示由它来「代理」某些操作，可以译为「代理器」。</p>\n<h2 id=\"基本语法\"> 基本语法</h2>\n<p><strong>语法</strong></p>\n<div><pre><code><span>let</span> p <span>=</span> <span>new</span> <span>Proxy</span><span>(</span>target<span>,</span> handler<span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>解释</strong></p>\n<p>我们可以看下表来对照一下。</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n<th>必选</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>target</td>\n<td>用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>handler</td>\n<td>一个对象，其属性是当执行一个操作时定义代理的行为的函数</td>\n<td>Y</td>\n</tr>\n</tbody>\n</table>\n<p>MDN 给出的解释偏官方，通俗的讲第一个参数 <code>target</code> 就是用来代理的「对象」，被代理之后它是不能直接被访问的，而 <code>handler</code> 就是实现代理的过程。</p>\n<h2 id=\"拦截操作场景\"> 拦截操作场景</h2>\n<h3 id=\"读操作场景\"> 读操作场景</h3>\n<p>我们通常这样读取一个对象的 key-value：</p>\n<div><pre><code><span>let</span> o <span>=</span> <span>{</span> \n  name<span>:</span> <span>'zhangsan'</span><span>,</span>\n  age<span>:</span> <span>13</span>\n<span>}</span>\n\nconsole<span>.</span><span>log</span><span>(</span>o<span>.</span>name<span>)</span>   <span>// zhangsan</span>\nconsole<span>.</span><span>log</span><span>(</span>o<span>.</span>age<span>)</span>    <span>// 13</span>\nconsole<span>.</span><span>log</span><span>(</span>o<span>.</span>gender<span>)</span> <span>// undefined</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>读取 <code>gender</code> 的时候返回的是 <code>undefined</code>，因为该对象中没有这个 key-value。</p>\n<p>实际业务中，为了避免读取不存在的属性时返回 <code>undefined</code>，我们会做这样的保护：</p>\n<div><pre><code>console<span>.</span><span>log</span><span>(</span>o<span>.</span>gender <span>||</span> <span>''</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>如果我们对所有代码都是这种写法，那阅读性和观赏性就降低了。ES6 的 Proxy 就可以解决这一问题：</p>\n<div><pre><code><span>let</span> o <span>=</span> <span>{</span> \n  name<span>:</span> <span>'zhangsan'</span><span>,</span>\n  age<span>:</span> <span>13</span>\n<span>}</span>\n\n<span>let</span> handler <span>=</span> <span>{</span>\n  <span>get</span><span>(</span>obj<span>,</span> key<span>)</span> <span>{</span>\n    <span>return</span> Reflect<span>.</span><span>has</span><span>(</span>obj<span>,</span> key<span>)</span> <span>?</span> obj<span>[</span>key<span>]</span> <span>:</span> <span>''</span>\n  <span>}</span>\n<span>}</span>\n\n<span>let</span> p <span>=</span> <span>new</span> <span>Proxy</span><span>(</span>o<span>,</span> handler<span>)</span>\n\nconsole<span>.</span><span>log</span><span>(</span>p<span>.</span>gender<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>这个代码的意思是如果 <code>o</code> 对象有这个 key-value 则直接返回，如果没有一律返回 <code>''</code>。这里是自定义的处理逻辑，实际业务中可以根据自己的需要来写适合自己的规则。</p>\n<h3 id=\"写操作场景-1\"> 写操作场景 1</h3>\n<p>从服务端获取的数据希望是只读，不允许在任何一个环节被修改。</p>\n<p>在 ES5 中只能通过遍历把所有的属性设置为只读：</p>\n<div><pre><code><span>// response.data 是 JSON 格式的数据，来自服务端的响应</span>\n<span>for</span> <span>(</span><span>let</span> <span>[</span>key<span>]</span> <span>of</span> Object<span>.</span><span>entries</span><span>(</span>response<span>.</span>data<span>)</span><span>)</span> <span>{</span>\n  Object<span>.</span><span>defineProperty</span><span>(</span>response<span>.</span>data<span>,</span> key<span>,</span> <span>{</span>\n    writable<span>:</span> <span>false</span>\n  <span>}</span><span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>在 ES5 中使用 Proxy 就简单很多了：</p>\n<div><pre><code><span>let</span> data <span>=</span> <span>new</span> <span>Proxy</span><span>(</span>response<span>.</span>data<span>,</span> <span>{</span>\n  <span>set</span><span>(</span>obj<span>,</span> key<span>,</span> value<span>)</span> <span>{</span>\n    <span>return</span> <span>false</span>\n  <span>}</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"写操作场景-2\"> 写操作场景 2</h3>\n<p>对于数据交互而言，校验是不可或缺的一个环境，传统的做法是将校验写在了业务逻辑里，导致代码耦合度较高。</p>\n<p>如果使用 Proxy 就可以将代码设计的非常灵活：</p>\n<div><pre><code><span>// validator.js</span>\n<span>export</span> <span>default</span> <span>(</span><span>obj<span>,</span> key<span>,</span> value</span><span>)</span> <span>=></span> <span>{</span>\n  <span>if</span> <span>(</span>Reflect<span>.</span><span>has</span><span>(</span>key<span>)</span> <span>&amp;&amp;</span> value <span>></span> <span>20</span><span>)</span> <span>{</span>\n    obj<span>[</span>key<span>]</span> <span>=</span> value\n  <span>}</span>\n<span>}</span>\n\n<span>// other js file</span>\n<span>import</span> Validator <span>from</span> <span>'./validator'</span>\n<span>let</span> data <span>=</span> <span>new</span> <span>Proxy</span><span>(</span>response<span>.</span>data<span>,</span> <span>{</span>\n  set<span>:</span> Validator\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id=\"写操作场景-3\"> 写操作场景 3</h3>\n<p><code>set</code> 方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。</p>\n<p>假定 <code>person</code> 对象有一个 <code>age</code> 属性，那么可以使用 Proxy 保证 <code>age</code> 的属性值符合要求。</p>\n<div><pre><code><span>let</span> validator <span>=</span> <span>{</span>\n  <span>set</span><span>(</span>target<span>,</span> key<span>,</span> value<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>key <span>===</span> <span>'age'</span><span>)</span> <span>{</span>\n      <span>if</span> <span>(</span><span>typeof</span> value <span>!==</span> <span>'number'</span> <span>||</span> Number<span>.</span><span>isNaN</span><span>(</span>value<span>)</span><span>)</span> <span>{</span>\n        <span>throw</span> <span>new</span> <span>TypeError</span><span>(</span><span>'Age must be a number'</span><span>)</span>\n      <span>}</span>\n      <span>if</span> <span>(</span>value <span>&lt;=</span> <span>0</span><span>)</span> <span>{</span>\n        <span>throw</span> <span>new</span> <span>TypeError</span><span>(</span><span>'Age must be a positive number'</span><span>)</span>\n      <span>}</span>\n    <span>}</span>\n\n    <span>// 对于满足条件的 age 属性以及其他属性，直接保存</span>\n    target<span>[</span>key<span>]</span> <span>=</span> value\n    <span>return</span> <span>true</span>\n  <span>}</span>\n<span>}</span>\n\n<span>const</span> person <span>=</span> <span>{</span>\n  age<span>:</span> <span>27</span>\n<span>}</span>\n<span>const</span> proxy <span>=</span> <span>new</span> <span>Proxy</span><span>(</span>person<span>,</span> validator<span>)</span>\n\nproxy<span>.</span>age <span>=</span> <span>'foo'</span> <span>// 报错</span>\nproxy<span>.</span>age <span>=</span> <span>NaN</span>   <span>// 报错</span>\nproxy<span>.</span>age <span>=</span> <span>0</span>     <span>// 报错</span>\nproxy<span>.</span>age <span>=</span> <span>28</span>\nconsole<span>.</span><span>log</span><span>(</span>person<span>.</span>age<span>)</span> <span>// 28</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h2 id=\"常用拦截操作\"> 常用拦截操作</h2>\n<h3 id=\"get\"> get</h3>\n<p>拦截对象属性的读取，比如 <code>proxy.foo</code> 和 <code>proxy['foo']</code>。</p>\n<p><code>get</code> 方法可以接受三个参数：</p>\n<ul>\n<li><code>target</code>：目标对象</li>\n<li><code>propKey</code>：属性名</li>\n<li>proxy 实例本身（可选）：严格地说，是操作行为所针对的对象</li>\n</ul>\n<p>下面是两个使用示例：</p>\n<p>拦截前，可以正常获取数组元素，如果数组索引越界则返回 <code>undefined</code>。</p>\n<div><pre><code><span>let</span> arr <span>=</span> <span>[</span><span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>]</span>\n\nconsole<span>.</span><span>log</span><span>(</span>arr<span>[</span><span>1</span><span>]</span><span>)</span>  <span>// 8</span>\nconsole<span>.</span><span>log</span><span>(</span>arr<span>[</span><span>10</span><span>]</span><span>)</span> <span>// undefined</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>拦截后，规定如果数组索引越界就返回 <code>error</code>。</p>\n<div><pre><code><span>let</span> arr <span>=</span> <span>[</span><span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>]</span>\narr <span>=</span> <span>new</span> <span>Proxy</span><span>(</span>arr<span>,</span> <span>{</span>\n  <span>get</span><span>(</span>target<span>,</span> prop<span>)</span> <span>{</span>\n    <span>// console.log(target, prop)</span>\n    <span>return</span> prop <span>in</span> target <span>?</span> target<span>[</span>prop<span>]</span> <span>:</span> <span>'error'</span>\n  <span>}</span>\n<span>}</span><span>)</span>\n\nconsole<span>.</span><span>log</span><span>(</span>arr<span>[</span><span>1</span><span>]</span><span>)</span>  <span>// 8</span>\nconsole<span>.</span><span>log</span><span>(</span>arr<span>[</span><span>10</span><span>]</span><span>)</span> <span>// error</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>拦截前，可以正常获取对象属性，如果属性不存在则返回 <code>undefined</code>。</p>\n<div><pre><code><span>let</span> dict <span>=</span> <span>{</span>\n  <span>'hello'</span><span>:</span> <span>'你好'</span><span>,</span>\n  <span>'world'</span><span>:</span> <span>'世界'</span>\n<span>}</span>\n\nconsole<span>.</span><span>log</span><span>(</span>dict<span>[</span><span>'hello'</span><span>]</span><span>)</span>      <span>// 你好</span>\nconsole<span>.</span><span>log</span><span>(</span>dict<span>[</span><span>'javascript'</span><span>]</span><span>)</span> <span>// undefined</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>拦截后，规定如果属性不存在就返回 key 的值。</p>\n<div><pre><code><span>let</span> dict <span>=</span> <span>{</span>\n  <span>'hello'</span><span>:</span> <span>'你好'</span><span>,</span>\n  <span>'world'</span><span>:</span> <span>'世界'</span>\n<span>}</span>\ndict <span>=</span> <span>new</span> <span>Proxy</span><span>(</span>dict<span>,</span> <span>{</span>\n  <span>get</span><span>(</span>target<span>,</span> prop<span>)</span> <span>{</span>\n    <span>return</span> prop <span>in</span> target <span>?</span> target<span>[</span>prop<span>]</span> <span>:</span> prop\n  <span>}</span>\n<span>}</span><span>)</span>\n\nconsole<span>.</span><span>log</span><span>(</span>dict<span>[</span><span>'hello'</span><span>]</span><span>)</span>      <span>// 你好</span>\nconsole<span>.</span><span>log</span><span>(</span>dict<span>[</span><span>'javascript'</span><span>]</span><span>)</span> <span>// javascript</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id=\"set\"> set</h3>\n<p>拦截对象属性的设置，比如 <code>proxy.foo = v</code> 或 <code>proxy['foo'] = v</code>，返回一个布尔值。</p>\n<p><code>set</code> 方法可以接受三个参数：</p>\n<ul>\n<li><code>target</code>：目标对象</li>\n<li><code>propKey</code>：属性名</li>\n<li><code>propVal</code>：属性值</li>\n<li>proxy 实例本身（可选）：严格地说，是操作行为所针对的对象</li>\n</ul>\n<p>下面是一个使用示例：</p>\n<p>拦截前，可以给数组添加任意类型的元素。</p>\n<div><pre><code><span>let</span> arr <span>=</span> <span>[</span><span>]</span>\n\narr<span>.</span><span>push</span><span>(</span><span>5</span><span>)</span>\narr<span>.</span><span>push</span><span>(</span><span>'a'</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>arr<span>[</span><span>0</span><span>]</span><span>,</span> arr<span>[</span><span>1</span><span>]</span><span>,</span> arr<span>.</span>length<span>)</span> <span>// 5 'a' 2</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>拦截后，规定只能给数组添加数字类型的元素。</p>\n<div><pre><code><span>let</span> arr <span>=</span> <span>[</span><span>]</span>\narr <span>=</span> <span>new</span> <span>Proxy</span><span>(</span>arr<span>,</span> <span>{</span>\n  <span>set</span><span>(</span>target<span>,</span> prop<span>,</span> val<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>typeof</span> val <span>===</span> <span>'number'</span><span>)</span> <span>{</span>\n      target<span>[</span>prop<span>]</span> <span>=</span> val\n      <span>return</span> <span>true</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      <span>return</span> <span>false</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span><span>)</span>\n\narr<span>.</span><span>push</span><span>(</span><span>5</span><span>)</span>\narr<span>.</span><span>push</span><span>(</span><span>'a'</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>arr<span>[</span><span>0</span><span>]</span><span>,</span> arr<span>[</span><span>1</span><span>]</span><span>,</span> arr<span>.</span>length<span>)</span> <span>// 5 undefined 1</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id=\"has\"> has</h3>\n<p>拦截 <code>propKey in proxy</code> 的操作，返回一个布尔值。</p>\n<p><code>has</code> 方法可以接受两个参数：</p>\n<ul>\n<li><code>target</code>：目标对象</li>\n<li><code>propKey</code>：需查询的属性名</li>\n</ul>\n<p>下面是一个使用示例：</p>\n<p>定义了一个新方法，用来判断某个数字在不在自己指定的范围内。</p>\n<div><pre><code><span>let</span> range <span>=</span> <span>{</span>\n  start<span>:</span> <span>1</span><span>,</span>\n  end<span>:</span> <span>5</span>\n<span>}</span>\n\nrange <span>=</span> <span>new</span> <span>Proxy</span><span>(</span>range<span>,</span> <span>{</span>\n  <span>has</span><span>(</span><span>target<span>,</span> prop</span><span>)</span> <span>{</span>\n    <span>return</span> prop <span>>=</span> target<span>.</span>start <span>&amp;&amp;</span> prop <span>&lt;=</span> target<span>.</span>end\n  <span>}</span>\n<span>}</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span><span>2</span> <span>in</span> range<span>)</span>\nconsole<span>.</span><span>log</span><span>(</span><span>9</span> <span>in</span> range<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id=\"ownkeys\"> ownKeys</h3>\n<p>拦截以下操作（也就是拦截对象自身属性的读取操作），并返回一个数组：</p>\n<ul>\n<li><code>Object.getOwnPropertyNames(proxy)</code></li>\n<li><code>Object.getOwnPropertySymbols(proxy)</code></li>\n<li><code>Object.keys(proxy)</code></li>\n<li><code>for...in</code> 循环</li>\n</ul>\n<blockquote>\n<p>该方法返回目标对象所有自身的属性的属性名，而 <code>Object.keys()</code> 的返回结果仅包括目标对象自身的可遍历属性。</p>\n</blockquote>\n<p>下面是一个使用示例：</p>\n<p>拦截前，每种方法能正常打印出它能获取到的值。</p>\n<div><pre><code><span>let</span> userInfo <span>=</span> <span>{</span>\n  username<span>:</span> <span>'zhangsan'</span><span>,</span>\n  age<span>:</span> <span>13</span><span>,</span>\n  _password<span>:</span> <span>'******'</span><span>,</span>\n  <span>[</span><span>Symbol</span><span>(</span><span>'level'</span><span>)</span><span>]</span><span>:</span> <span>'VIP1'</span>\n<span>}</span>\n\nconsole<span>.</span><span>log</span><span>(</span>Object<span>.</span><span>getOwnPropertyNames</span><span>(</span>userInfo<span>)</span><span>)</span>   <span>// ['username', 'age', '_password']</span>\nconsole<span>.</span><span>log</span><span>(</span>Object<span>.</span><span>getOwnPropertySymbols</span><span>(</span>userInfo<span>)</span><span>)</span> <span>// [Symbol(level)]</span>\nconsole<span>.</span><span>log</span><span>(</span>Object<span>.</span><span>keys</span><span>(</span>userInfo<span>)</span><span>)</span>                  <span>// ['username', 'age', '_password']</span>\n<span>for</span> <span>(</span><span>let</span> key <span>in</span> userInfo<span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>key<span>)</span>                                  <span>// username  // age  // _password</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>拦截后，规定变量名前加下划线表示私有，只打印输出<strong>目标对象自身的可遍历非私有属性</strong>。</p>\n<blockquote>\n<p>需要注意，使用 <code>Object.keys()</code> 方法时，有三类属性会被 <code>ownKeys()</code> 方法自动过滤，不会返回：</p>\n<ul>\n<li>目标对象上不存在的属性</li>\n<li>属性名为 Symbol 值</li>\n<li>不可遍历（<code>enumerable</code>）的属性</li>\n</ul>\n</blockquote>\n<div><pre><code><span>let</span> userInfo <span>=</span> <span>{</span>\n  username<span>:</span> <span>'zhangsan'</span><span>,</span>\n  age<span>:</span> <span>13</span><span>,</span>\n  _password<span>:</span> <span>'******'</span><span>,</span>\n  <span>[</span><span>Symbol</span><span>(</span><span>'level'</span><span>)</span><span>]</span><span>:</span> <span>'VIP1'</span>\n<span>}</span>\nuserInfo <span>=</span> <span>new</span> <span>Proxy</span><span>(</span>userInfo<span>,</span> <span>{</span>\n  <span>ownKeys</span><span>(</span><span>target</span><span>)</span> <span>{</span>\n    <span>return</span> Object<span>.</span><span>keys</span><span>(</span>target<span>)</span><span>.</span><span>filter</span><span>(</span><span>key</span> <span>=></span> <span>!</span>key<span>.</span><span>startsWith</span><span>(</span><span>'_'</span><span>)</span><span>)</span>\n  <span>}</span>\n<span>}</span><span>)</span>\n\nconsole<span>.</span><span>log</span><span>(</span>Object<span>.</span><span>getOwnPropertyNames</span><span>(</span>userInfo<span>)</span><span>)</span>   <span>// ['username', 'age']</span>\nconsole<span>.</span><span>log</span><span>(</span>Object<span>.</span><span>getOwnPropertySymbols</span><span>(</span>userInfo<span>)</span><span>)</span> <span>// []</span>\nconsole<span>.</span><span>log</span><span>(</span>Object<span>.</span><span>keys</span><span>(</span>userInfo<span>)</span><span>)</span>                  <span>// ['username', 'age']</span>\n<span>for</span> <span>(</span><span>let</span> key <span>in</span> userInfo<span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>key<span>)</span>                                  <span>// username  // age</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id=\"deleteproperty\"> deleteProperty</h3>\n<p>拦截 <code>delete proxy[propKey]</code> 的操作，返回一个布尔值。</p>\n<p>下面是一个使用示例：</p>\n<p>拦截前，<code>delete</code> 操作符可以删除对象的指定属性。</p>\n<div><pre><code><span>let</span> userInfo <span>=</span> <span>{</span>\n  username<span>:</span> <span>'zhangsan'</span><span>,</span>\n  age<span>:</span> <span>13</span><span>,</span>\n  _password<span>:</span> <span>'******'</span>\n<span>}</span>\n\nconsole<span>.</span><span>log</span><span>(</span>userInfo<span>.</span>age<span>)</span>         <span>// 13</span>\nconsole<span>.</span><span>log</span><span>(</span>userInfo<span>.</span>_password<span>)</span>   <span>// ******</span>\nuserInfo<span>.</span>age <span>=</span> <span>18</span>               \nconsole<span>.</span><span>log</span><span>(</span>userInfo<span>.</span>age<span>)</span>         <span>// 18</span>\n<span>try</span> <span>{</span>\n  userInfo<span>.</span>_password <span>=</span> <span>'123456'</span>\n<span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>e<span>.</span>message<span>)</span>\n<span>}</span> <span>finally</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>userInfo<span>.</span>_password<span>)</span> <span>// 123456</span>\n<span>}</span>\n\n<span>try</span> <span>{</span>\n  <span>delete</span> userInfo<span>.</span>_password\n<span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>e<span>.</span>message<span>)</span>\n<span>}</span> <span>finally</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>userInfo<span>.</span>_password<span>)</span> <span>// undefined</span>\n<span>}</span>\n\n<span>for</span> <span>(</span><span>let</span> key <span>in</span> userInfo<span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>key<span>)</span>                <span>// username  // age</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>拦截后，规定变量名前加下划线表示私有，<code>delete</code> 操作符无法删除对象的私有属性。</p>\n<div><pre><code><span>let</span> userInfo <span>=</span> <span>{</span>\n  username<span>:</span> <span>'zhangsan'</span><span>,</span>\n  age<span>:</span> <span>13</span><span>,</span>\n  _password<span>:</span> <span>'******'</span>\n<span>}</span>\nuserInfo <span>=</span> <span>new</span> <span>Proxy</span><span>(</span>userInfo<span>,</span> <span>{</span>\n  <span>get</span><span>(</span>target<span>,</span> prop<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>prop<span>.</span><span>startsWith</span><span>(</span><span>'_'</span><span>)</span><span>)</span> <span>{</span>\n      <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>'不可访问'</span><span>)</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      <span>return</span> target<span>[</span>prop<span>]</span>\n    <span>}</span>\n  <span>}</span><span>,</span>\n  <span>set</span><span>(</span>target<span>,</span> prop<span>,</span> val<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>prop<span>.</span><span>startsWith</span><span>(</span><span>'_'</span><span>)</span><span>)</span> <span>{</span>\n      <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>'不可访问'</span><span>)</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      target<span>[</span>prop<span>]</span> <span>=</span> val\n      <span>return</span> <span>true</span>\n    <span>}</span>\n  <span>}</span><span>,</span>\n  <span>deleteProperty</span><span>(</span><span>target<span>,</span> prop</span><span>)</span> <span>{</span> <span>// 拦截删除</span>\n    <span>if</span> <span>(</span>prop<span>.</span><span>startsWith</span><span>(</span><span>'_'</span><span>)</span><span>)</span> <span>{</span>\n      <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>'不可删除'</span><span>)</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      <span>delete</span> target<span>[</span>prop<span>]</span>\n      <span>return</span> <span>true</span>\n    <span>}</span>\n  <span>}</span><span>,</span>\n  <span>ownKeys</span><span>(</span><span>target</span><span>)</span> <span>{</span>\n    <span>return</span> Object<span>.</span><span>keys</span><span>(</span>target<span>)</span><span>.</span><span>filter</span><span>(</span><span>key</span> <span>=></span> <span>!</span>key<span>.</span><span>startsWith</span><span>(</span><span>'_'</span><span>)</span><span>)</span>\n  <span>}</span>\n<span>}</span><span>)</span>\n\nconsole<span>.</span><span>log</span><span>(</span>userInfo<span>.</span>age<span>)</span>         <span>// 13</span>\nconsole<span>.</span><span>log</span><span>(</span>userInfo<span>.</span>_password<span>)</span>   <span>// Uncaught Error: 不可访问</span>\nuserInfo<span>.</span>age <span>=</span> <span>18</span>               \nconsole<span>.</span><span>log</span><span>(</span>userInfo<span>.</span>age<span>)</span>         <span>// 18</span>\n<span>try</span> <span>{</span>\n  userInfo<span>.</span>_password <span>=</span> <span>'123456'</span>\n<span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>e<span>.</span>message<span>)</span>          <span>// 不可访问</span>\n<span>}</span> <span>finally</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>userInfo<span>.</span>_password<span>)</span>\n<span>}</span>\n\n<span>try</span> <span>{</span>\n  <span>delete</span> userInfo<span>.</span>_password\n<span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>e<span>.</span>message<span>)</span>          <span>// 不可删除</span>\n<span>}</span> <span>finally</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>userInfo<span>.</span>_password<span>)</span>\n<span>}</span>\n\n<span>for</span> <span>(</span><span>let</span> key <span>in</span> userInfo<span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>key<span>)</span>                <span>// username  // age</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br></div></div><h3 id=\"apply\"> apply</h3>\n<p>拦截 Proxy 实例作为函数调用的操作，比如 <code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</p>\n<p><code>apply</code> 方法可以接受三个参数：</p>\n<ul>\n<li><code>target</code>：目标对象</li>\n<li><code>ctx</code>：目标对象的上下文对象（<code>this</code>）</li>\n<li><code>args</code>：目标对象的参数数组</li>\n</ul>\n<p>下面是一个使用示例：</p>\n<p>拦截前，函数可以正常调用、也可以通过 <code>call</code> 和 <code>apply</code> 调用：</p>\n<div><pre><code><span>let</span> <span>sum</span> <span>=</span> <span>(</span><span><span>...</span>args</span><span>)</span> <span>=></span> <span>{</span>\n  <span>let</span> num <span>=</span> <span>0</span>\n  args<span>.</span><span>forEach</span><span>(</span><span>item</span> <span>=></span> <span>{</span>\n    num <span>+=</span> item\n  <span>}</span><span>)</span>\n  <span>return</span> num\n<span>}</span>\n\nconsole<span>.</span><span>log</span><span>(</span><span>sum</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span><span>)</span>                  <span>// 3</span>\nconsole<span>.</span><span>log</span><span>(</span><span>sum</span><span>.</span><span>call</span><span>(</span><span>null</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>)</span>    <span>// 6</span>\nconsole<span>.</span><span>log</span><span>(</span><span>sum</span><span>.</span><span>apply</span><span>(</span><span>null</span><span>,</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>)</span><span>)</span> <span>// 6</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>拦截后，修改了函数内部的处理逻辑：</p>\n<div><pre><code><span>let</span> <span>sum</span> <span>=</span> <span>(</span><span><span>...</span>args</span><span>)</span> <span>=></span> <span>{</span>\n  <span>let</span> num <span>=</span> <span>0</span>\n  args<span>.</span><span>forEach</span><span>(</span><span>item</span> <span>=></span> <span>{</span>\n    num <span>+=</span> item\n  <span>}</span><span>)</span>\n  <span>return</span> num\n<span>}</span>\n\nsum <span>=</span> <span>new</span> <span>Proxy</span><span>(</span>sum<span>,</span> <span>{</span>\n  <span>apply</span><span>(</span><span>target<span>,</span> ctx<span>,</span> args</span><span>)</span> <span>{</span>\n    <span>return</span> <span>target</span><span>(</span><span>...</span>args<span>)</span> <span>*</span> <span>2</span>\n  <span>}</span>\n<span>}</span><span>)</span>\n\nconsole<span>.</span><span>log</span><span>(</span><span>sum</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span><span>)</span>                  <span>// 6</span>\nconsole<span>.</span><span>log</span><span>(</span><span>sum</span><span>.</span><span>call</span><span>(</span><span>null</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>)</span>    <span>// 12</span>\nconsole<span>.</span><span>log</span><span>(</span><span>sum</span><span>.</span><span>apply</span><span>(</span><span>null</span><span>,</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>)</span><span>)</span> <span>// 12</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id=\"construct\"> construct</h3>\n<p>拦截 Proxy 实例作为构造函数调用的操作，比如 <code>new proxy(...args)</code>。</p>\n<p><code>construct</code> 方法可以接受三个参数：</p>\n<ul>\n<li><code>target</code>：目标对象</li>\n<li><code>args</code>：构造函数的参数数组</li>\n<li><code>newTarget</code>：创造实例对象时，<code>new</code> 命令作用的构造函数（下面例子的 <code>User</code>）</li>\n</ul>\n<div><p>TODO...</p>\n<p>暂时没有想到什么好的示例，等以后看开源项目源码时再补充。</p>\n</div>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/proxy\" target=\"_blank\" rel=\"noopener noreferrer\">Proxy</a></li>\n<li><a href=\"https://habr.com/en/post/448214/\" target=\"_blank\" rel=\"noopener noreferrer\">ES6 Proxies in practice</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-01-08T14:01:38.000Z",
      "date_modified": "2022-01-08T14:01:38.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Number",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es6-number/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es6-number/",
      "content_html": "<h1 id=\"number\"> Number</h1>\n<h2 id=\"二进制与八进制\"> 二进制与八进制</h2>\n<p>在 ES5 中把十进制转化为二进制的方式：</p>\n<div><pre><code><span>const</span> a <span>=</span> <span>5</span>\n\nconsole<span>.</span><span>log</span><span>(</span>a<span>.</span><span>toString</span><span>(</span><span>2</span><span>)</span><span>)</span> <span>// 101</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>把二进制转化为十进制的方式：</p>\n<div><pre><code><span>const</span> b <span>=</span> <span>101</span>\n\nconsole<span>.</span><span>log</span><span>(</span><span>parseInt</span><span>(</span>b<span>,</span> <span>2</span><span>)</span><span>)</span> <span>// 5</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀 <code>0b</code>（或 <code>0B</code>）和 <code>0o</code>（或 <code>0O</code>）表示。</p>\n<div><pre><code><span>const</span> a <span>=</span> <span>0B0101</span>\nconsole<span>.</span><span>log</span><span>(</span>a<span>)</span> <span>// 5</span>\n\n<span>const</span> b <span>=</span> <span>0O777</span>\nconsole<span>.</span><span>log</span><span>(</span>b<span>)</span> <span>// 511</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"新增方法\"> 新增方法</h2>\n<h3 id=\"number-isfinite\"> Number.isFinite()</h3>\n<p>用来检查一个数值是否为有限的（finite），即不是 <code>Infinity</code>。</p>\n<div><pre><code>Number<span>.</span><span>isFinite</span><span>(</span><span>15</span><span>)</span>        <span>// true</span>\nNumber<span>.</span><span>isFinite</span><span>(</span><span>0.8</span><span>)</span>       <span>// true</span>\nNumber<span>.</span><span>isFinite</span><span>(</span><span>NaN</span><span>)</span>       <span>// false</span>\nNumber<span>.</span><span>isFinite</span><span>(</span><span>Infinity</span><span>)</span>  <span>// false</span>\nNumber<span>.</span><span>isFinite</span><span>(</span><span>-</span><span>Infinity</span><span>)</span> <span>// false</span>\nNumber<span>.</span><span>isFinite</span><span>(</span><span>'foo'</span><span>)</span>     <span>// false</span>\nNumber<span>.</span><span>isFinite</span><span>(</span><span>'15'</span><span>)</span>      <span>// false</span>\nNumber<span>.</span><span>isFinite</span><span>(</span><span>true</span><span>)</span>      <span>// false</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"number-isnan\"> Number.isNaN()</h3>\n<p>用来检查一个值是否为 <code>NaN</code>。</p>\n<div><pre><code>Number<span>.</span><span>isNaN</span><span>(</span><span>NaN</span><span>)</span>             <span>// true</span>\nNumber<span>.</span><span>isNaN</span><span>(</span><span>15</span><span>)</span>              <span>// false</span>\nNumber<span>.</span><span>isNaN</span><span>(</span><span>'15'</span><span>)</span>            <span>// false</span>\nNumber<span>.</span><span>isNaN</span><span>(</span><span>true</span><span>)</span>            <span>// false</span>\nNumber<span>.</span><span>isNaN</span><span>(</span><span>9</span> <span>/</span> <span>NaN</span><span>)</span>         <span>// true</span>\nNumber<span>.</span><span>isNaN</span><span>(</span><span>'true'</span> <span>/</span> <span>0</span><span>)</span>      <span>// true</span>\nNumber<span>.</span><span>isNaN</span><span>(</span><span>'true'</span> <span>/</span> <span>'true'</span><span>)</span> <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"number-parseint\"> Number.parseInt()</h3>\n<p>ES6 将全局方法 <code>parseInt()</code> 移植到 Number 对象上面，行为完全保持不变。这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。</p>\n<div><pre><code><span>// ES5 的写法</span>\n<span>parseInt</span><span>(</span><span>'12.34'</span><span>)</span> <span>// 12</span>\n\n<span>// ES6 的写法</span>\nNumber<span>.</span><span>parseInt</span><span>(</span><span>'12.34'</span><span>)</span> <span>// 12</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"number-parsefloat\"> Number.parseFloat()</h3>\n<p>ES6 将全局方法 <code>parseFloat()</code> 移植到 Number 对象上面，行为完全保持不变。这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。</p>\n<div><pre><code><span>// ES5 的写法</span>\n<span>parseFloat</span><span>(</span><span>'123.45#'</span><span>)</span> <span>// 123.45</span>\n\n<span>// ES6 的写法</span>\nNumber<span>.</span><span>parseFloat</span><span>(</span><span>'123.45#'</span><span>)</span> <span>// 123.45</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"number-isinteger\"> Number.isInteger()</h3>\n<p>用来判断一个数值是否为整数。</p>\n<div><pre><code>Number<span>.</span><span>isInteger</span><span>(</span><span>25</span><span>)</span>   <span>// true</span>\nNumber<span>.</span><span>isInteger</span><span>(</span><span>25.1</span><span>)</span> <span>// false</span>\n\nNumber<span>.</span><span>isInteger</span><span>(</span><span>)</span>     <span>// false</span>\nNumber<span>.</span><span>isInteger</span><span>(</span><span>null</span><span>)</span> <span>// false</span>\nNumber<span>.</span><span>isInteger</span><span>(</span><span>'15'</span><span>)</span> <span>// false</span>\nNumber<span>.</span><span>isInteger</span><span>(</span><span>true</span><span>)</span> <span>// false</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"number-issafeinteger\"> Number.isSafeInteger()</h3>\n<p>JavaScript 能够准确表示的整数范围在 <code>-2^53</code> 到 <code>2^53</code> 之间（不含两个端点），超过这个范围，无法精确表示这个值。</p>\n<p>这个方法用来判断一个整数是否落在这个范围之内。</p>\n<div><pre><code>Math<span>.</span><span>pow</span><span>(</span><span>2</span><span>,</span> <span>53</span><span>)</span> <span>// 9007199254740992</span>\nMath<span>.</span><span>pow</span><span>(</span><span>2</span><span>,</span> <span>53</span><span>)</span> <span>===</span> Math<span>.</span><span>pow</span><span>(</span><span>2</span><span>,</span> <span>53</span><span>)</span> <span>-</span> <span>1</span> <span>// false</span>\nMath<span>.</span><span>pow</span><span>(</span><span>2</span><span>,</span> <span>53</span><span>)</span> <span>===</span> Math<span>.</span><span>pow</span><span>(</span><span>2</span><span>,</span> <span>53</span><span>)</span> <span>+</span> <span>1</span> <span>// true</span>\n\nNumber<span>.</span><span>isSafeInteger</span><span>(</span>Math<span>.</span><span>pow</span><span>(</span><span>2</span><span>,</span> <span>53</span><span>)</span><span>)</span> <span>// false</span>\nNumber<span>.</span><span>isSafeInteger</span><span>(</span>Math<span>.</span><span>pow</span><span>(</span><span>2</span><span>,</span> <span>53</span><span>)</span> <span>-</span> <span>1</span><span>)</span> <span>// true</span>\nNumber<span>.</span><span>isSafeInteger</span><span>(</span>Math<span>.</span><span>pow</span><span>(</span><span>2</span><span>,</span> <span>53</span><span>)</span> <span>+</span> <span>1</span><span>)</span> <span>// false</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"number-max-safe-integer\"> Number.MAX_SAFE_INTEGER</h3>\n<p>这个常量用来表示 JavaScript 能够精确表示的最大整数（上边界 - 1）。</p>\n<div><pre><code>Number<span>.</span><span>MAX_SAFE_INTEGER</span> <span>===</span> Math<span>.</span><span>pow</span><span>(</span><span>2</span><span>,</span> <span>53</span><span>)</span> <span>-</span> <span>1</span> <span>// true</span>\n\nNumber<span>.</span><span>MAX_SAFE_INTEGER</span> <span>===</span> <span>9007199254740991</span>    <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"number-min-safe-integer\"> Number.MIN_SAFE_INTEGER</h3>\n<p>这个常量用来表示 JavaScript 能够精确表示的最小整数（下边界 + 1）。</p>\n<div><pre><code>Number<span>.</span><span>MIN_SAFE_INTEGER</span> <span>===</span> <span>-</span>Number<span>.</span><span>MAX_SAFE_INTEGER</span> <span>// true</span>\n\nNumber<span>.</span><span>MIN_SAFE_INTEGER</span> <span>===</span> <span>-</span><span>9007199254740991</span>        <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"math-扩展\"> Math 扩展</h2>\n<h3 id=\"math-trunc\"> Math.trunc()</h3>\n<p>方法用于去除一个数的小数部分，返回整数部分。</p>\n<div><pre><code>console<span>.</span><span>log</span><span>(</span>Math<span>.</span><span>trunc</span><span>(</span><span>5.5</span><span>)</span><span>)</span>       <span>// 5</span>\nconsole<span>.</span><span>log</span><span>(</span>Math<span>.</span><span>trunc</span><span>(</span><span>-</span><span>5.5</span><span>)</span><span>)</span>      <span>// -5</span>\nconsole<span>.</span><span>log</span><span>(</span>Math<span>.</span><span>trunc</span><span>(</span><span>true</span><span>)</span><span>)</span>      <span>// 1</span>\nconsole<span>.</span><span>log</span><span>(</span>Math<span>.</span><span>trunc</span><span>(</span><span>false</span><span>)</span><span>)</span>     <span>// 0</span>\nconsole<span>.</span><span>log</span><span>(</span>Math<span>.</span><span>trunc</span><span>(</span><span>NaN</span><span>)</span><span>)</span>       <span>// NaN</span>\nconsole<span>.</span><span>log</span><span>(</span>Math<span>.</span><span>trunc</span><span>(</span><span>undefined</span><span>)</span><span>)</span> <span>// NaN</span>\nconsole<span>.</span><span>log</span><span>(</span>Math<span>.</span><span>trunc</span><span>(</span><span>)</span><span>)</span>          <span>// NaN</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"math-sign\"> Math.sign()</h3>\n<p>方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。</p>\n<p>它会返回五种值：</p>\n<ul>\n<li>参数为正数，返回 <code>+1</code></li>\n<li>参数为负数，返回 <code>-1</code></li>\n<li>参数为 <code>0</code>，返回 <code>0</code></li>\n<li>参数为 <code>-0</code>，返回 <code>-0</code></li>\n<li>其他值，返回 <code>NaN</code></li>\n</ul>\n<div><pre><code>console<span>.</span><span>log</span><span>(</span>Math<span>.</span><span>sign</span><span>(</span><span>5</span><span>)</span><span>)</span>     <span>// 1</span>\nconsole<span>.</span><span>log</span><span>(</span>Math<span>.</span><span>sign</span><span>(</span><span>-</span><span>5</span><span>)</span><span>)</span>    <span>// -1</span>\nconsole<span>.</span><span>log</span><span>(</span>Math<span>.</span><span>sign</span><span>(</span><span>0</span><span>)</span><span>)</span>     <span>// 0</span>\nconsole<span>.</span><span>log</span><span>(</span>Math<span>.</span><span>sign</span><span>(</span><span>NaN</span><span>)</span><span>)</span>   <span>// NaN</span>\nconsole<span>.</span><span>log</span><span>(</span>Math<span>.</span><span>sign</span><span>(</span><span>true</span><span>)</span><span>)</span>  <span>// 1</span>\nconsole<span>.</span><span>log</span><span>(</span>Math<span>.</span><span>sign</span><span>(</span><span>false</span><span>)</span><span>)</span> <span>// 0</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"math-cbrt\"> Math.cbrt()</h3>\n<p>方法用于计算一个数的立方根。</p>\n<div><pre><code>console<span>.</span><span>log</span><span>(</span>Math<span>.</span><span>cbrt</span><span>(</span><span>8</span><span>)</span><span>)</span>       <span>// 2</span>\n\nconsole<span>.</span><span>log</span><span>(</span>Math<span>.</span><span>cbrt</span><span>(</span><span>'hello'</span><span>)</span><span>)</span> <span>// NaN</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/number\" target=\"_blank\" rel=\"noopener noreferrer\">数值的扩展</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number\" target=\"_blank\" rel=\"noopener noreferrer\">Number</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math\" target=\"_blank\" rel=\"noopener noreferrer\">Math</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-01-06T09:40:57.000Z",
      "date_modified": "2022-01-06T09:40:57.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Reflect",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es6-reflect/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es6-reflect/",
      "content_html": "<h1 id=\"reflect\"> Reflect</h1>\n<p>Reflect 对象与 Proxy 对象一样，也是 ES6 为了操作对象而提供的新 API。</p>\n<h2 id=\"设计目的\"> 设计目的</h2>\n<h4 id=\"_1-将-object-属于语言内部的方法放到-reflect-上\"> 1）将 Object 属于语言内部的方法放到 Reflect 上</h4>\n<p>比如 <code>defineProperty</code> 方法，它本来是 Object 对象上的，但为了让代码更加规范，会逐步将这些方法转移到 Reflect 上。</p>\n<p>在使用上还是一样的：</p>\n<div><pre><code><span>let</span> obj <span>=</span> <span>{</span><span>}</span>\n<span>let</span> newVal <span>=</span> <span>''</span>\nReflect<span>.</span><span>defineProperty</span><span>(</span>obj<span>,</span> <span>'name'</span><span>,</span> <span>{</span>\n  <span>get</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> newVal\n  <span>}</span><span>,</span>\n  <span>set</span><span>(</span>val<span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'set'</span><span>)</span>\n    <span>// this.name = val</span>\n    newVal <span>=</span> val\n  <span>}</span>\n<span>}</span><span>)</span>\nobj<span>.</span>name <span>=</span> <span>'es'</span>\nconsole<span>.</span><span>log</span><span>(</span>obj<span>.</span>name<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h4 id=\"_2-修改某些-object-方法的返回结果-让其变得更合理\"> 2）修改某些 Object 方法的返回结果，让其变得更合理</h4>\n<p>比如以前的 <code>Object.defineProperty</code> 没有返回值，如果当前有些属性无法定义，会抛出异常。而在 Reflect 中会返回布尔值。</p>\n<div><pre><code><span>// 老写法</span>\n<span>try</span> <span>{</span>\n  Object<span>.</span><span>defineProperty</span><span>(</span>target<span>,</span> property<span>,</span> attributes<span>)</span>\n  <span>// success</span>\n<span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>\n  <span>// failure</span>\n<span>}</span>\n\n<span>// 新写法</span>\n<span>if</span> <span>(</span>Reflect<span>.</span><span>defineProperty</span><span>(</span>target<span>,</span> property<span>,</span> attributes<span>)</span><span>)</span> <span>{</span>\n  <span>// success</span>\n<span>}</span> <span>else</span> <span>{</span>\n  <span>// failure</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h4 id=\"_3-让-object-操作变成函数行为\"> 3）让 Object 操作变成函数行为</h4>\n<p>函数式操作比命令式操作看上去可读性更好。</p>\n<p>比如判断对象是否具有某个方法：</p>\n<div><pre><code><span>// 老写法</span>\n<span>'assign'</span> <span>in</span> Object <span>// true</span>\n\n<span>// 新写法</span>\nReflect<span>.</span><span>has</span><span>(</span>Object<span>,</span> <span>'assign'</span><span>)</span> <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id=\"_4-reflect-对象的方法与-proxy-对象的方法一一对应\"> 4）Reflect 对象的方法与 Proxy 对象的方法一一对应</h4>\n<p>只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。</p>\n<p>比如用 Proxy 写的一个功能：对 user 对象进行代理，使得以下划线开头的属性作为私有属性被保护起来，不能被获取、设置、删除、遍历：</p>\n<div><pre><code><span>let</span> user <span>=</span> <span>{</span>\n  name<span>:</span> <span>'zhangsan'</span><span>,</span>\n  age<span>:</span> <span>13</span><span>,</span>\n  _password<span>:</span> <span>'******'</span>\n<span>}</span>\nuser <span>=</span> <span>new</span> <span>Proxy</span><span>(</span>user<span>,</span> <span>{</span>\n  <span>get</span><span>(</span>target<span>,</span> prop<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>prop<span>.</span><span>startsWith</span><span>(</span><span>'_'</span><span>)</span><span>)</span> <span>{</span>\n      <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>'不可访问'</span><span>)</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      <span>return</span> target<span>[</span>prop<span>]</span>\n    <span>}</span>\n  <span>}</span><span>,</span>\n  <span>set</span><span>(</span>target<span>,</span> prop<span>,</span> val<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>prop<span>.</span><span>startsWith</span><span>(</span><span>'_'</span><span>)</span><span>)</span> <span>{</span>\n      <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>'不可访问'</span><span>)</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      target<span>[</span>prop<span>]</span> <span>=</span> val\n      <span>return</span> <span>true</span>\n    <span>}</span>\n  <span>}</span><span>,</span>\n  <span>deleteProperty</span><span>(</span><span>target<span>,</span> prop</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>prop<span>.</span><span>startsWith</span><span>(</span><span>'_'</span><span>)</span><span>)</span> <span>{</span>\n      <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>'不可删除'</span><span>)</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      <span>delete</span> target<span>[</span>prop<span>]</span>\n      <span>return</span> <span>true</span>\n    <span>}</span>\n  <span>}</span><span>,</span>\n  <span>ownKeys</span><span>(</span><span>target</span><span>)</span> <span>{</span>\n    <span>return</span> Object<span>.</span><span>keys</span><span>(</span>target<span>)</span><span>.</span><span>filter</span><span>(</span><span>key</span> <span>=></span> <span>!</span>key<span>.</span><span>startsWith</span><span>(</span><span>'_'</span><span>)</span><span>)</span>\n  <span>}</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>如果用 Reflect 进行改造：</p>\n<div><div><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><div>&nbsp;</div><br><br><br></div><pre><code><span>let</span> user <span>=</span> <span>{</span>\n  name<span>:</span> <span>'zhangsan'</span><span>,</span>\n  age<span>:</span> <span>13</span><span>,</span>\n  _password<span>:</span> <span>'******'</span>\n<span>}</span>\nuser <span>=</span> <span>new</span> <span>Proxy</span><span>(</span>user<span>,</span> <span>{</span>\n  <span>get</span><span>(</span>target<span>,</span> prop<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>prop<span>.</span><span>startsWith</span><span>(</span><span>'_'</span><span>)</span><span>)</span> <span>{</span>\n      <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>'不可访问'</span><span>)</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      <span>return</span> Reflect<span>.</span><span>get</span><span>(</span>target<span>,</span> prop<span>)</span>\n    <span>}</span>\n  <span>}</span><span>,</span>\n  <span>set</span><span>(</span>target<span>,</span> prop<span>,</span> val<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>prop<span>.</span><span>startsWith</span><span>(</span><span>'_'</span><span>)</span><span>)</span> <span>{</span>\n      <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>'不可访问'</span><span>)</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      Reflect<span>.</span><span>set</span><span>(</span>target<span>,</span> prop<span>,</span> val<span>)</span>\n      <span>return</span> <span>true</span>\n    <span>}</span>\n  <span>}</span><span>,</span>\n  <span>deleteProperty</span><span>(</span><span>target<span>,</span> prop</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>prop<span>.</span><span>startsWith</span><span>(</span><span>'_'</span><span>)</span><span>)</span> <span>{</span>\n      <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>'不可删除'</span><span>)</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      Reflect<span>.</span><span>deleteProperty</span><span>(</span>target<span>,</span> prop<span>)</span>\n      <span>return</span> <span>true</span>\n    <span>}</span>\n  <span>}</span><span>,</span>\n  <span>ownKeys</span><span>(</span><span>target</span><span>)</span> <span>{</span>\n    <span>return</span> Reflect<span>.</span><span>ownKeys</span><span>(</span>target<span>)</span><span>.</span><span>filter</span><span>(</span><span>key</span> <span>=></span> <span>!</span>key<span>.</span><span>startsWith</span><span>(</span><span>'_'</span><span>)</span><span>)</span>\n  <span>}</span>\n<span>}</span><span>)</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法，这些方法与处理器对象的方法相同。Reflect 不是一个函数对象，因此它是不可构造的。</p>\n<div><p>提示</p>\n<p>与大多数全局对象不同，Reflect 没有构造函数。你不能将其与一个 <code>new</code> 运算符一起使用，或者将 Reflect 对象作为一个函数来调用。Reflect 的所有属性和方法都是静态的（就像 Math 对象）</p>\n</div>\n<h2 id=\"常用方法\"> 常用方法</h2>\n<h3 id=\"reflect-apply\"> Reflect.apply()</h3>\n<p><strong>语法</strong></p>\n<blockquote>\n<p>Reflect.apply(target, thisArgument, argumentsList)</p>\n</blockquote>\n<p><strong>解释</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n<th>必选</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>target</td>\n<td>目标函数</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>thisArgument</td>\n<td>target 函数调用时绑定的 <code>this</code> 对象</td>\n<td>N</td>\n</tr>\n<tr>\n<td>argumentsList</td>\n<td>target 函数调用时传入的实参列表，该参数应该是一个类数组的对象</td>\n<td>N</td>\n</tr>\n</tbody>\n</table>\n<p><strong>示例</strong></p>\n<div><pre><code><span>Reflect</span><span>.</span><span>apply</span><span>(</span>Math<span>.</span>floor<span>,</span> <span>undefined</span><span>,</span> <span>[</span><span>1.75</span><span>]</span><span>)</span>\n<span>// 1</span>\n\n<span>Reflect</span><span>.</span><span>apply</span><span>(</span>String<span>.</span>fromCharCode<span>,</span> <span>undefined</span><span>,</span> <span>[</span><span>104</span><span>,</span> <span>101</span><span>,</span> <span>108</span><span>,</span> <span>108</span><span>,</span> <span>111</span><span>]</span><span>)</span>\n<span>// \"hello\"</span>\n\n<span>Reflect</span><span>.</span><span>apply</span><span>(</span><span>RegExp</span><span>.</span>prototype<span>.</span>exec<span>,</span> <span><span>/</span><span>ab</span><span>/</span></span><span>,</span> <span>[</span><span>'confabulation'</span><span>]</span><span>)</span><span>.</span>index\n<span>// 4</span>\n\n<span>Reflect</span><span>.</span><span>apply</span><span>(</span><span>''</span><span>.</span>charAt<span>,</span> <span>'ponies'</span><span>,</span> <span>[</span><span>3</span><span>]</span><span>)</span>\n<span>// \"i\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><strong>ES5 对比</strong></p>\n<p>该方法与 ES5 中 <code>Function.prototype.apply()</code> 方法类似：调用一个方法并且显式地指定 <code>this</code> 变量和参数列表（<code>arguments</code>），参数列表可以是数组，或类似数组的对象。</p>\n<div><pre><code><span>Function</span><span>.</span>prototype<span>.</span><span>apply</span><span>.</span><span>call</span><span>(</span>Math<span>.</span>floor<span>,</span> <span>undefined</span><span>,</span> <span>[</span><span>1.75</span><span>]</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"reflect-construct\"> Reflect.construct()</h3>\n<p>Reflect.construct() 方法的行为有点像 <code>new</code> 操作符 构造函数，相当于运行 <code>new target(...args)</code>。</p>\n<p><strong>语法</strong></p>\n<blockquote>\n<p>Reflect.construct(target, argumentsList[, newTarget])</p>\n</blockquote>\n<p><strong>解释</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n<th>必选</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>target</td>\n<td>被运行的目标函数</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>argumentsList</td>\n<td>调用构造函数的数组或者伪数组</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>newTarget</td>\n<td>该参数为构造函数， 参考 new.target 操作符，如果没有 newTarget 参数， 默认和 target 一样</td>\n<td>N</td>\n</tr>\n</tbody>\n</table>\n<div><p>WARNING</p>\n<p>如果 target 或者 newTarget 不是构造函数，抛出 TypeError</p>\n</div>\n<p>Reflect.construct 允许你使用可变的参数来调用构造函数：</p>\n<div><pre><code><span>var</span> obj <span>=</span> <span>new</span> <span>Foo</span><span>(</span><span>...</span>args<span>)</span>\n<span>var</span> obj <span>=</span> Reflect<span>.</span><span>construct</span><span>(</span>Foo<span>,</span> args<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例</strong></p>\n<div><pre><code><span>var</span> d <span>=</span> Reflect<span>.</span><span>construct</span><span>(</span>Date<span>,</span> <span>[</span><span>1776</span><span>,</span> <span>6</span><span>,</span> <span>4</span><span>]</span><span>)</span>\nd <span>instanceof</span> <span>Date</span> <span>// true</span>\nd<span>.</span><span>getFullYear</span><span>(</span><span>)</span>   <span>// 1776</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果使用 newTarget 参数，则表示继承了 newTarget 这个超类：</p>\n<div><pre><code><span>function</span> <span>someConstructor</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n<span>var</span> result <span>=</span> Reflect<span>.</span><span>construct</span><span>(</span>Array<span>,</span> <span>[</span><span>]</span><span>,</span> someConstructor<span>)</span>\n\nReflect<span>.</span><span>getPrototypeOf</span><span>(</span>result<span>)</span> <span>// 输出：someConstructor.prototype</span>\nArray<span>.</span><span>isArray</span><span>(</span>result<span>)</span>          <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"reflect-defineproperty\"> Reflect.defineProperty()</h3>\n<p>静态方法 Reflect.defineProperty() 基本等同于 Object.defineProperty() 方法，唯一不同是返回 Boolean 值。</p>\n<p><strong>语法</strong></p>\n<blockquote>\n<p>Reflect.defineProperty(target, propertyKey, attributes)</p>\n</blockquote>\n<p><strong>解释</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n<th>必选</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>target</td>\n<td>目标对象</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>propertyKey</td>\n<td>要定义或修改的属性的名称</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>attributes</td>\n<td>要定义或修改的属性的描述</td>\n<td>Y</td>\n</tr>\n</tbody>\n</table>\n<p><strong>示例</strong></p>\n<div><pre><code><span>const</span> student <span>=</span> <span>{</span><span>}</span>\nReflect<span>.</span><span>defineProperty</span><span>(</span>student<span>,</span> <span>'name'</span><span>,</span> <span>{</span>\n  value<span>:</span> <span>'zhangsan'</span>\n<span>}</span><span>)</span> <span>// true</span>\nstudent<span>.</span>name <span>// \"zhangsan\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"reflect-deleteproperty\"> Reflect.deleteProperty()</h3>\n<p>Reflect.deleteProperty() 允许你删除一个对象上的属性。返回一个 Boolean 值表示该属性是否被成功删除。它几乎与非严格的 <code>delete</code> 操作符相同。</p>\n<p><strong>语法</strong></p>\n<blockquote>\n<p>Reflect.deleteProperty(target, propertyKey)</p>\n</blockquote>\n<p><strong>解释</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n<th>必选</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>target</td>\n<td>删除属性的目标对象</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>propertyKey</td>\n<td>将被删除的属性的名称</td>\n<td>Y</td>\n</tr>\n</tbody>\n</table>\n<p><strong>示例</strong></p>\n<div><pre><code><span>var</span> obj <span>=</span> <span>{</span>\n  x<span>:</span> <span>1</span><span>,</span>\n  y<span>:</span> <span>2</span>\n<span>}</span>\nReflect<span>.</span><span>deleteProperty</span><span>(</span>obj<span>,</span> <span>\"x\"</span><span>)</span> <span>// true</span>\nobj <span>// { y: 2 }</span>\n\n<span>var</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>]</span>\nReflect<span>.</span><span>deleteProperty</span><span>(</span>arr<span>,</span> <span>\"3\"</span><span>)</span> <span>// true</span>\narr <span>// [1, 2, 3, , 5]</span>\n\n<span>// 如果属性不存在，返回 true</span>\nReflect<span>.</span><span>deleteProperty</span><span>(</span><span>{</span><span>}</span><span>,</span> <span>\"foo\"</span><span>)</span> <span>// true</span>\n\n<span>// 如果属性不可配置，返回 false</span>\nReflect<span>.</span><span>deleteProperty</span><span>(</span>Object<span>.</span><span>freeze</span><span>(</span><span>{</span>\n  foo<span>:</span> <span>1</span>\n<span>}</span><span>)</span><span>,</span> <span>\"foo\"</span><span>)</span> <span>// false</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id=\"reflect-get\"> Reflect.get()</h3>\n<p>Reflect.get() 方法的工作方式，就像从 Object (<code>target[propertyKey]</code>) 中获取属性，但它是作为一个函数执行的。</p>\n<p><strong>语法</strong></p>\n<blockquote>\n<p>Reflect.get(target, propertyKey[, receiver])</p>\n</blockquote>\n<p><strong>解释</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n<th>必选</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>target</td>\n<td>需要取值的目标对象</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>propertyKey</td>\n<td>需要获取的值的键值</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>receiver</td>\n<td>如果遇到 getter，此值将提供给目标调用</td>\n<td>N</td>\n</tr>\n</tbody>\n</table>\n<p><strong>示例</strong></p>\n<div><pre><code><span>// Object</span>\n<span>var</span> obj <span>=</span> <span>{</span>\n    x<span>:</span> <span>1</span><span>,</span>\n    y<span>:</span> <span>2</span>\n<span>}</span>\nReflect<span>.</span><span>get</span><span>(</span>obj<span>,</span> <span>'x'</span><span>)</span> <span>// 1</span>\n\n<span>// Array</span>\nReflect<span>.</span><span>get</span><span>(</span><span>[</span><span>'zero'</span><span>,</span> <span>'one'</span><span>]</span><span>,</span> <span>1</span><span>)</span> <span>// \"one\"</span>\n\n<span>// Proxy with a get handler</span>\n<span>var</span> x <span>=</span> <span>{</span>\n    p<span>:</span> <span>1</span>\n<span>}</span>\n<span>var</span> obj <span>=</span> <span>new</span> <span>Proxy</span><span>(</span>x<span>,</span> <span>{</span>\n    <span>get</span><span>(</span>t<span>,</span> k<span>,</span> r<span>)</span> <span>{</span>\n        <span>return</span> k <span>+</span> <span>'bar'</span>\n    <span>}</span>\n<span>}</span><span>)</span>\nReflect<span>.</span><span>get</span><span>(</span>obj<span>,</span> <span>'foo'</span><span>)</span> <span>// \"foobar\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h3 id=\"reflect-getownpropertydescriptor\"> Reflect.getOwnPropertyDescriptor()</h3>\n<p>静态方法 Reflect.getOwnPropertyDescriptor() 与 Object.getOwnPropertyDescriptor() 方法相似。如果在对象中存在，则返回给定的属性的属性描述符，否则返回 <code>undefined</code>。</p>\n<p><strong>语法</strong></p>\n<blockquote>\n<p>Reflect.getOwnPropertyDescriptor(target, propertyKey)</p>\n</blockquote>\n<p><strong>解释</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n<th>必选</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>target</td>\n<td>需要寻找属性的目标对象</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>propertyKey</td>\n<td>获取自己的属性描述符的属性的名称</td>\n<td>N</td>\n</tr>\n</tbody>\n</table>\n<p><strong>示例</strong></p>\n<div><pre><code>Reflect<span>.</span><span>getOwnPropertyDescriptor</span><span>(</span><span>{</span>\n  x<span>:</span> <span>'hello'</span>\n<span>}</span><span>,</span> <span>'x'</span><span>)</span>\n<span>// {value: \"hello\", writable: true, enumerable: true, configurable: true}</span>\n\nReflect<span>.</span><span>getOwnPropertyDescriptor</span><span>(</span><span>{</span>\n  x<span>:</span> <span>'hello'</span>\n<span>}</span><span>,</span> <span>'y'</span><span>)</span>\n<span>// undefined</span>\n\nReflect<span>.</span><span>getOwnPropertyDescriptor</span><span>(</span><span>[</span><span>]</span><span>,</span> <span>'length'</span><span>)</span>\n<span>// {value: 0, writable: true, enumerable: false, configurable: false}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><strong>对比</strong></p>\n<p>如果该方法的第一个参数不是一个对象（一个原始值），那么将造成 TypeError 错误。而对于 Object.getOwnPropertyDescriptor，非对象的第一个参数将被强制转换为一个对象处理。</p>\n<div><pre><code>Reflect<span>.</span><span>getOwnPropertyDescriptor</span><span>(</span><span>\"foo\"</span><span>,</span> <span>0</span><span>)</span>\n<span>// TypeError: \"foo\" is not non-null object</span>\n\nObject<span>.</span><span>getOwnPropertyDescriptor</span><span>(</span><span>\"foo\"</span><span>,</span> <span>0</span><span>)</span>\n<span>// { value: \"f\", writable: false, enumerable: true, configurable: false }</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"reflect-getprototypeof\"> Reflect.getPrototypeOf()</h3>\n<p>静态方法 Reflect.getPrototypeOf() 与 Object.getPrototypeOf() 方法是一样的。都是返回指定对象的原型（即内部的 <code>[[Prototype]]</code> 属性的值）。</p>\n<p><strong>语法</strong></p>\n<blockquote>\n<p>Reflect.getPrototypeOf(target)</p>\n</blockquote>\n<p><strong>解释</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n<th>必选</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>target</td>\n<td>获取原型的目标对象</td>\n<td>Y</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"reflect-has\"> Reflect.has()</h3>\n<p>Reflect.has() 用于检查一个对象是否拥有某个属性， 相当于 <code>in</code> 操作符。</p>\n<p><strong>语法</strong></p>\n<blockquote>\n<p>Reflect.has(target, propertyKey)</p>\n</blockquote>\n<p><strong>解释</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n<th>必选</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>target</td>\n<td>获取原型的目标对象</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>propertyKey</td>\n<td>属性名，需要检查目标对象是否存在此属性</td>\n<td>Y</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"reflect-isextensible\"> Reflect.isExtensible()</h3>\n<p>Reflect.isExtensible 判断一个对象是否可扩展 （即是否能够添加新的属性），它与 Object.isExtensible() 方法一样。</p>\n<p><strong>语法</strong></p>\n<blockquote>\n<p>Reflect.isExtensible(target)</p>\n</blockquote>\n<p><strong>解释</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n<th>必选</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>target</td>\n<td>获取原型的目标对象</td>\n<td>Y</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"reflect-ownkeys\"> Reflect.ownKeys()</h3>\n<p>Reflect.ownKeys() 方法返回一个由目标对象自身的属性键组成的数组。</p>\n<p>它的返回值等同于 <code>Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))</code>。</p>\n<p><strong>语法</strong></p>\n<blockquote>\n<p>Reflect.ownKeys(target)</p>\n</blockquote>\n<p><strong>解释</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n<th>必选</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>target</td>\n<td>获取原型的目标对象</td>\n<td>Y</td>\n</tr>\n</tbody>\n</table>\n<p><strong>示例</strong></p>\n<div><pre><code>Reflect<span>.</span><span>ownKeys</span><span>(</span><span>{</span>\n  z<span>:</span> <span>3</span><span>,</span>\n  y<span>:</span> <span>2</span><span>,</span>\n  x<span>:</span> <span>1</span>\n<span>}</span><span>)</span> <span>// [ \"z\", \"y\", \"x\" ]</span>\nReflect<span>.</span><span>ownKeys</span><span>(</span><span>[</span><span>]</span><span>)</span> <span>// [\"length\"]</span>\n\n<span>var</span> sym <span>=</span> Symbol<span>.</span><span>for</span><span>(</span><span>\"comet\"</span><span>)</span>\n<span>var</span> sym2 <span>=</span> Symbol<span>.</span><span>for</span><span>(</span><span>\"meteor\"</span><span>)</span>\n<span>var</span> obj <span>=</span> <span>{</span>\n  <span>[</span>sym<span>]</span><span>:</span> <span>0</span><span>,</span>\n  <span>\"str\"</span><span>:</span> <span>0</span><span>,</span>\n  <span>\"773\"</span><span>:</span> <span>0</span><span>,</span>\n  <span>\"0\"</span><span>:</span> <span>0</span><span>,</span>\n  <span>[</span>sym2<span>]</span><span>:</span> <span>0</span><span>,</span>\n  <span>\"-1\"</span><span>:</span> <span>0</span><span>,</span>\n  <span>\"8\"</span><span>:</span> <span>0</span><span>,</span>\n  <span>\"second str\"</span><span>:</span> <span>0</span>\n<span>}</span>\nReflect<span>.</span><span>ownKeys</span><span>(</span>obj<span>)</span>\n<span>// [ \"0\", \"8\", \"773\", \"str\", \"-1\", \"second str\", Symbol(comet), Symbol(meteor) ]</span>\n<span>// Indexes in numeric order,</span>\n<span>// strings in insertion order,</span>\n<span>// symbols in insertion order</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id=\"reflect-preventextensions\"> Reflect.preventExtensions()</h3>\n<p>Reflect.preventExtensions() 方法阻止新属性添加到对象（例如：防止将来对对象的扩展被添加到对象中）。</p>\n<p>该方法与 Object.preventExtensions() 方法一致。</p>\n<p><strong>语法</strong></p>\n<blockquote>\n<p>Reflect.preventExtensions(target)</p>\n</blockquote>\n<p><strong>解释</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n<th>必选</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>target</td>\n<td>获取原型的目标对象</td>\n<td>Y</td>\n</tr>\n</tbody>\n</table>\n<p><strong>示例</strong></p>\n<div><pre><code><span>// Objects are extensible by default.</span>\n<span>var</span> empty <span>=</span> <span>{</span><span>}</span>\nReflect<span>.</span><span>isExtensible</span><span>(</span>empty<span>)</span> <span>// === true</span>\n\n<span>// ...but that can be changed.</span>\nReflect<span>.</span><span>preventExtensions</span><span>(</span>empty<span>)</span>\nReflect<span>.</span><span>isExtensible</span><span>(</span>empty<span>)</span> <span>// === false</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><div><pre><code>Reflect<span>.</span><span>preventExtensions</span><span>(</span><span>1</span><span>)</span>\n<span>// TypeError: 1 is not an object</span>\n\nObject<span>.</span><span>preventExtensions</span><span>(</span><span>1</span><span>)</span>\n<span>// 1</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"reflect-set\"> Reflect.set()</h3>\n<p>Reflect.set 方法允许你在对象上设置属性。它的作用是给属性赋值并且就像<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Property_Accessors\" target=\"_blank\" rel=\"noopener noreferrer\">属性访问器</a>语法一样，但是它是以函数的方式。</p>\n<p><strong>语法</strong></p>\n<blockquote>\n<p>Reflect.set(target, propertyKey, value[, receiver])</p>\n</blockquote>\n<p><strong>解释</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n<th>必选</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>target</td>\n<td>获取原型的目标对象</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>propertyKey</td>\n<td>设置的属性的名称</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>value</td>\n<td>设置的值</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>receiver</td>\n<td>如果遇到 setter，this 将提供给目标调用</td>\n<td>N</td>\n</tr>\n</tbody>\n</table>\n<p><strong>示例</strong></p>\n<div><pre><code><span>// Object</span>\n<span>var</span> obj <span>=</span> <span>{</span><span>}</span>\nReflect<span>.</span><span>set</span><span>(</span>obj<span>,</span> <span>\"prop\"</span><span>,</span> <span>\"value\"</span><span>)</span> <span>// true</span>\nobj<span>.</span>prop <span>// \"value\"</span>\n\n<span>// Array</span>\n<span>var</span> arr <span>=</span> <span>[</span><span>\"duck\"</span><span>,</span> <span>\"duck\"</span><span>,</span> <span>\"duck\"</span><span>]</span>\nReflect<span>.</span><span>set</span><span>(</span>arr<span>,</span> <span>2</span><span>,</span> <span>\"goose\"</span><span>)</span> <span>// true</span>\narr<span>[</span><span>2</span><span>]</span> <span>// \"goose\"</span>\n\n<span>// It can truncate an array.</span>\nReflect<span>.</span><span>set</span><span>(</span>arr<span>,</span> <span>\"length\"</span><span>,</span> <span>1</span><span>)</span> <span>// true</span>\narr <span>// [\"duck\"]</span>\n\n<span>// With just one argument, propertyKey and value are \"undefined\".</span>\n<span>var</span> obj <span>=</span> <span>{</span><span>}</span>\nReflect<span>.</span><span>set</span><span>(</span>obj<span>)</span> <span>// true</span>\nReflect<span>.</span><span>getOwnPropertyDescriptor</span><span>(</span>obj<span>,</span> <span>\"undefined\"</span><span>)</span>\n<span>// { value: undefined, writable: true, enumerable: true, configurable: true }</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h3 id=\"reflect-setprototypeof\"> Reflect.setPrototypeOf()</h3>\n<p>Reflect.setPrototypeOf() 方法改变指定对象的原型（即内部的 <code>[[Prototype]]</code> 属性值）。</p>\n<p><strong>语法</strong></p>\n<blockquote>\n<p>Reflect.setPrototypeOf(target, prototype)</p>\n</blockquote>\n<p><strong>解释</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n<th>必选</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>target</td>\n<td>获取原型的目标对象</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>prototype</td>\n<td>对象的新原型（一个对象或 <code>null</code>）</td>\n<td>Y</td>\n</tr>\n</tbody>\n</table>\n<p><strong>示例</strong></p>\n<div><pre><code>Reflect<span>.</span><span>setPrototypeOf</span><span>(</span><span>{</span><span>}</span><span>,</span> <span>Object</span><span>.</span>prototype<span>)</span> <span>// true</span>\n\n<span>// It can change an object's [[Prototype]] to null.</span>\nReflect<span>.</span><span>setPrototypeOf</span><span>(</span><span>{</span><span>}</span><span>,</span> <span>null</span><span>)</span> <span>// true</span>\n\n<span>// Returns false if target is not extensible.</span>\nReflect<span>.</span><span>setPrototypeOf</span><span>(</span>Object<span>.</span><span>freeze</span><span>(</span><span>{</span><span>}</span><span>)</span><span>,</span> <span>null</span><span>)</span> <span>// false</span>\n\n<span>// Returns false if it cause a prototype chain cycle.</span>\n<span>var</span> target <span>=</span> <span>{</span><span>}</span>\n<span>var</span> proto <span>=</span> Object<span>.</span><span>create</span><span>(</span>target<span>)</span>\nReflect<span>.</span><span>setPrototypeOf</span><span>(</span>target<span>,</span> proto<span>)</span> <span>// false</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><p>注意</p>\n<p>对于以上所有 API 第一个参数是 Object 的，如果给定的不是 Object 则抛出一个 TypeError 异常</p>\n</div>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/reflect\" target=\"_blank\" rel=\"noopener noreferrer\">Reflect</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect\" target=\"_blank\" rel=\"noopener noreferrer\">Reflect</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-01-09T14:25:03.000Z",
      "date_modified": "2022-01-11T09:14:24.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "RegExp 扩展",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es6-regexp/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es6-regexp/",
      "content_html": "<h1 id=\"regexp-扩展\"> RegExp 扩展</h1>\n<h2 id=\"y-修饰符\"> y 修饰符</h2>\n<p>ES6 为正则表达式添加了 y 修饰符，叫做「粘连」（sticky）修饰符。</p>\n<p>y 修饰符的作用与 g 修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。</p>\n<p>不同之处在于，g 修饰符只要剩余位置中存在匹配就可，而 y 修饰符确保匹配必须从剩余的第一个位置开始，这也就是「粘连」的涵义。</p>\n<div><pre><code><span>const</span> str <span>=</span> <span>'aaa_aa_a'</span>\n<span>const</span> regex1 <span>=</span> <span><span>/</span><span>a+</span><span>/</span><span>g</span></span>\n<span>const</span> regex2 <span>=</span> <span><span>/</span><span>a+</span><span>/</span><span>y</span></span>\n\nregex1<span>.</span><span>exec</span><span>(</span>str<span>)</span> <span>// [ 'aaa', index: 0, input: 'aaa_aa_a', groups: undefined ]</span>\nregex1<span>.</span><span>exec</span><span>(</span>str<span>)</span> <span>// [ 'aa', index: 4, input: 'aaa_aa_a', groups: undefined ]</span>\n\nregex2<span>.</span><span>exec</span><span>(</span>str<span>)</span> <span>// [ 'aaa', index: 0, input: 'aaa_aa_a', groups: undefined ]</span>\nregex2<span>.</span><span>exec</span><span>(</span>str<span>)</span> <span>// null</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面代码有两个正则表达式，都表示从字符串中从头开始匹配 <code>a</code> 字符，遇到其它字符后停止匹配。连续执行表示依次往后匹配，如果没有找到 <code>a</code>，就代表匹配失败，返回 <code>null</code>。匹配失败后如果再执行的话，就是重新从头开始。</p>\n<p>此时 g 修饰符和 y 修饰符的区别就体现出来了：</p>\n<ul>\n<li>这两个正则表达式各执行了两次。</li>\n<li>第一次执行，两者行为相同，剩余字符串都是 <code>_aa_a</code>。</li>\n<li>第二次执行，g 修饰能从 <code>_aa</code> 中找到 <code>aa</code>；而 y 修饰符需要直接遇到 <code>a</code>，但先遇到的是 <code>_</code>，所以返回 <code>null</code>。</li>\n</ul>\n<p>进一步说，y 修饰符号隐含了头部匹配的标志 <code>^</code>。</p>\n<h2 id=\"u-修饰符\"> u 修饰符</h2>\n<p>ES6 为正则表达式添加了 u 修饰符，含义为「Unicode 模式」，用来正确处理大于 <code>\\uFFFF</code> 的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。</p>\n<div><pre><code><span>// ES5</span>\n<span>/</span><span>^</span>\\uD83D<span>/</span><span>.</span><span>test</span><span>(</span><span>'\\uD83D\\uDC2A'</span><span>)</span>  <span>// true</span>\n\n<span>// ES6, 引入 u 修饰符</span>\n<span>/</span><span>^</span>\\uD83D<span>/</span>u<span>.</span><span>test</span><span>(</span><span>'\\uD83D\\uDC2A'</span><span>)</span> <span>// false</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面代码中， <code>\\uD83D\\uDC2A</code> 是一个四个字节的 UTF-16 编码，代表一个字符 <code>🐪</code>。但是，ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致正则匹配结果为 <code>true</code>。加了 u 修饰符以后，ES6 就会识别其为一个字符，所以正则匹配结果为 <code>false</code>。</p>\n<p>一旦加上 u 修饰符号，就会修改下面这些正则表达式的行为。</p>\n<h3 id=\"点字符\"> 点字符</h3>\n<p>点（<code>.</code>）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于 0xFFFF 的 <code>Unicode</code> 字符，点字符不能识别，必须加上 u 修饰符。</p>\n<div><pre><code><span>let</span> s <span>=</span> <span>'𠮷'</span>\n\n<span>/</span><span>^</span><span>.</span>$<span>/</span><span>.</span><span>test</span><span>(</span>s<span>)</span> <span>// false</span>\n\n<span>/</span><span>^</span><span>.</span>$<span>/</span>u<span>.</span><span>test</span><span>(</span>s<span>)</span> <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><p>提示</p>\n<p>'𠮷'这个字读 jí，是'吉'字的异形体，Unicode 码点 <a href=\"https://www.fileformat.info/info/unicode/char/20bb7/index.htm\" target=\"_blank\" rel=\"noopener noreferrer\">U+20BB7</a></p>\n</div>\n<h3 id=\"unicode-字符表示法\"> Unicode 字符表示法</h3>\n<p>ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上 u 修饰符，才能识别。</p>\n<div><pre><code><span><span>/</span><span>\\u{61}</span><span>/</span></span><span>.</span><span>test</span><span>(</span><span>'a'</span><span>)</span>      <span>// false</span>\n\n<span>/</span>\\u<span>{</span><span>61</span><span>}</span><span>/</span>u<span>.</span><span>test</span><span>(</span><span>'a'</span><span>)</span>     <span>// true</span>\n\n<span>/</span>\\u<span>{</span><span>20</span>BB7<span>}</span><span>/</span>u<span>.</span><span>test</span><span>(</span><span>'𠮷'</span><span>)</span> <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面代码表示，如果不加 u 修饰符，正则表达式无法识别 <code>\\u{61}</code> 这种表示法，只会认为这匹配 61 个连续的 u。</p>\n<h3 id=\"量词\"> 量词</h3>\n<p>使用 u 修饰符后，所有量词都会正确识别码点大于 <code>0xFFFF</code> 的 Unicode 字符。</p>\n<div><pre><code><span><span>/</span><span>a{2}</span><span>/</span></span><span>.</span><span>test</span><span>(</span><span>'aa'</span><span>)</span>   <span>// true</span>\n\n<span>/</span>a<span>{</span><span>2</span><span>}</span><span>/</span>u<span>.</span><span>test</span><span>(</span><span>'aa'</span><span>)</span>  <span>// true</span>\n\n<span>/</span>𠮷<span>{</span><span>2</span><span>}</span><span>/</span><span>.</span><span>test</span><span>(</span><span>'𠮷𠮷'</span><span>)</span> <span>// false</span>\n\n<span>/</span>𠮷<span>{</span><span>2</span><span>}</span><span>/</span>u<span>.</span><span>test</span><span>(</span><span>'𠮷𠮷'</span><span>)</span> <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>另外，只有在使用 u 修饰符的情况下，Unicode 表达式当中的大括号才会被正确解读，否则会被解读为量词。</p>\n<div><pre><code><span><span>/</span><span>^\\u{3}$</span><span>/</span></span><span>.</span><span>test</span><span>(</span><span>'uuu'</span><span>)</span> <span>// true</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>上面代码中，由于正则表达式没有 u 修饰符，所以大括号被解读为量词。加上 u 修饰符，就会被解读为 Unicode 表达式。</p>\n<div><pre><code><span><span>/</span><span>\\u{20BB7}{2}</span><span>/</span><span>u</span></span><span>.</span><span>test</span><span>(</span><span>'𠮷𠮷'</span><span>)</span> <span>// true</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>使用 u 修饰符之后 Unicode 表达式+量词也是可以的。</p>\n<h3 id=\"预定义模式\"> 预定义模式</h3>\n<p>u 修饰符也影响到预定义模式，能否正确识别码点大于 <code>0xFFFF</code> 的 Unicode 字符。</p>\n<div><pre><code><span><span>/</span><span>^\\S$</span><span>/</span></span><span>.</span><span>test</span><span>(</span><span>'𠮷'</span><span>)</span>  <span>// false</span>\n\n<span>/</span><span>^</span>\\<span>S</span>$<span>/</span>u<span>.</span><span>test</span><span>(</span><span>'𠮷'</span><span>)</span> <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面代码的 <code>\\S</code> 是预定义模式，匹配所有不是空格的字符。只有加了 u 修饰符，它才能正确匹配码点大于 <code>0xFFFF</code> 的 Unicode 字符。</p>\n<p>利用这一点，可以写出一个正确返回字符串长度的函数。</p>\n<div><pre><code><span>function</span> <span>codePointLength</span><span>(</span><span>text</span><span>)</span> <span>{</span>\n    <span>const</span> result <span>=</span> text<span>.</span><span>match</span><span>(</span><span><span>/</span><span>[\\s\\S]</span><span>/</span><span>gu</span></span><span>)</span>\n    <span>return</span> result <span>?</span> result<span>.</span>length <span>:</span> <span>0</span>\n<span>}</span>\n\n<span>const</span> s <span>=</span> <span>'𠮷𠮷'</span>\n\n<span>// 不准确的结果</span>\nconsole<span>.</span><span>log</span><span>(</span>s<span>.</span>length<span>)</span>           <span>// 4</span>\n<span>// 准确的结果</span>\nconsole<span>.</span><span>log</span><span>(</span><span>codePointLength</span><span>(</span>s<span>)</span><span>)</span> <span>// 2</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"i-修饰符\"> i 修饰符</h3>\n<p>有些 Unicode 字符的编码不同，但是字型很相近，比如，<code>\\u004B</code>与 <code>\\u212A</code> 都是大写的 <code>K</code>。</p>\n<div><pre><code><span><span>/</span><span>[a-z]</span><span>/</span><span>i</span></span><span>.</span><span>test</span><span>(</span><span>'\\u212A'</span><span>)</span>  <span>// false</span>\n\n<span>/</span><span>[</span>a<span>-</span>z<span>]</span><span>/</span>iu<span>.</span><span>test</span><span>(</span><span>'\\u212A'</span><span>)</span> <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面代码中，不加 i 修饰符，就无法识别非规范的 K 字符。</p>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2014/12/unicode.html\" target=\"_blank\" rel=\"noopener noreferrer\">Unicode与JavaScript详解</a></li>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/regex\" target=\"_blank\" rel=\"noopener noreferrer\">正则的扩展</a></li>\n<li>《<a href=\"https://github.com/qdlaoyao/js-regex-mini-book\" target=\"_blank\" rel=\"noopener noreferrer\">JavaScript 正则表达式迷你书</a>》</li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-01-05T09:48:04.000Z",
      "date_modified": "2022-01-06T08:57:44.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "幂运算符",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es7-pow/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es7-pow/",
      "content_html": "<h1 id=\"幂运算符\"> 幂运算符</h1>\n<h2 id=\"es7-以前求幂运算\"> ES7 以前求幂运算</h2>\n<ul>\n<li>自己封装函数</li>\n</ul>\n<div><pre><code><span>function</span> <span>pow</span><span>(</span><span>x<span>,</span> y</span><span>)</span> <span>{</span>\n  <span>let</span> res <span>=</span> <span>1</span>\n  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> y<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n    res <span>*=</span> x\n  <span>}</span>\n  <span>return</span> res\n<span>}</span>\n\n<span>pow</span><span>(</span><span>2</span><span>,</span> <span>10</span><span>)</span>\n<span>// 1024</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ul>\n<li>使用 <code>Math.pow()</code></li>\n</ul>\n<blockquote>\n<p>Math.pow() 函数返回基数（base）的指数（exponent）次幂。</p>\n</blockquote>\n<div><pre><code>console<span>.</span><span>log</span><span>(</span>Math<span>.</span><span>pow</span><span>(</span><span>2</span><span>,</span> <span>10</span><span>)</span><span>)</span> <span>// 1024</span>\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"es7-新方法\"> ES7 新方法</h2>\n<p>求幂运算符（<code>**</code>）返回将第一个操作数加到第二个操作数的幂的结果。它等效于 <code>Math.pow()</code>，不同之处在于它也接受 BigInt 作为操作数。</p>\n<div><pre><code>console<span>.</span><span>log</span><span>(</span><span>2</span> <span>**</span> <span>10</span><span>)</span> <span>// 1024</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>（完）</p>\n",
      "date_published": "2022-01-19T08:34:52.000Z",
      "date_modified": "2022-01-31T07:57:00.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "String 扩展",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es6-string/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es6-string/",
      "content_html": "<h1 id=\"string-扩展\"> String 扩展</h1>\n<h2 id=\"unicode-表示法\"> Unicode 表示法</h2>\n<p>ES6 加强了对 Unicode 的支持，允许采用 <code>\\uxxxx</code> 形式表示一个字符，其中 <code>xxxx</code> 表示字符的 Unicode 码点。</p>\n<div><pre><code><span>\"\\u0061\"</span> <span>// 'a'</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>但是，这种表示法只限于码点在 <code>\\u0000</code> ~ <code>\\uFFFF</code> 之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。</p>\n<div><pre><code><span>\"\\uD842\\uDFB7\"</span> <span>// \"𠮷\"</span>\n\n<span>\"\\u20BB7\"</span>      <span>// \" 7\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面代码表示，如果直接在 <code>\\u</code> 后面跟上超过 <code>0xFFFF</code> 的数值（比如 <code>\\u20BB7</code>），JavaScript 会理解成 <code>\\u20BB+7</code>。由于 <code>\\u20BB</code> 是一个不可打印字符，所以只会显示一个空格，后面跟着一个 <code>7</code>。</p>\n<p>ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。</p>\n<div><pre><code><span>\"\\u{20BB7}\"</span> <span>// \"𠮷\"</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。</p>\n<div><pre><code><span>'\\z'</span> <span>===</span> <span>'z'</span>      <span>// true</span>\n<span>'\\172'</span> <span>===</span> <span>'z'</span>    <span>// true</span>\n<span>'\\x7A'</span> <span>===</span> <span>'z'</span>    <span>// true</span>\n<span>'\\u007A'</span> <span>===</span> <span>'z'</span>  <span>// true</span>\n<span>'\\u{7A}'</span> <span>===</span> <span>'z'</span>  <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"遍历器接口\"> 遍历器接口</h2>\n<p>ES6 为字符串添加了遍历器接口，使得字符串可以被 for...of 循环遍历。</p>\n<div><pre><code><span>for</span> <span>(</span><span>let</span> item <span>of</span> <span>'HelloWorld'</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>item<span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"模板字符串\"> 模板字符串</h2>\n<p>在 ES6 之前使用字符串时有很多痛点：</p>\n<ul>\n<li>字符串很长要手动换行</li>\n<li>字符串中有变量或者表达式，需要不断拼接</li>\n<li>字符串中有逻辑运算，需要使用逻辑判断 + 字符串拼接</li>\n</ul>\n<p>而在 ES6 的模板字符串很好的解决了这些问题：</p>\n<ul>\n<li><strong>模板字符串是增强版的字符串，用反引号标识</strong></li>\n</ul>\n<div><pre><code><span><span>`</span><span>string text</span><span>`</span></span>\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li><strong>模板字符串可以解析换行操作</strong></li>\n</ul>\n<div><pre><code><span><span>`</span><span>string text line 1\n string text line 2</span><span>`</span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><ul>\n<li><strong>模板字符串表示多行字符串时，所有的空格和缩进都会被保留在输出之中</strong></li>\n</ul>\n<div><pre><code><span><span>`</span><span>\n&lt;ul>\n  &lt;li>first&lt;/li>\n  &lt;li>second&lt;/li>\n&lt;/ul>\n</span><span>`</span></span>\n\n<span>// 上述代码中，&lt;ul> 标签前面会有一个换行也被保留下来</span>\n<span>// 如果不想要这个换行，可以使用 trim 方法消除它</span>\n<span><span>`</span><span>\n&lt;ul>\n  &lt;li>first&lt;/li>\n  &lt;li>second&lt;/li>\n&lt;/ul>\n</span><span>`</span></span><span>.</span><span>trim</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><ul>\n<li><strong>模板字符串中可以使用 <code>${}</code> 包裹变量或表达式</strong></li>\n</ul>\n<div><pre><code><span>let</span> name <span>=</span> <span>'zhangsan'</span><span>,</span> age <span>=</span> <span>13</span>\n<span><span>`</span><span>My name is </span><span><span>${</span>name<span>}</span></span><span>, I am </span><span><span>${</span>age<span>}</span></span><span> years old.</span><span>`</span></span>\n\n<span>// 大括号内部可以放入任意的 JavaScript 表达式, 包括运算、引用对象属性等</span>\n<span>let</span> x <span>=</span> <span>1</span><span>,</span> y <span>=</span> <span>2</span>\n<span><span>`</span><span><span>${</span>x<span>}</span></span><span> + </span><span><span>${</span>y<span>}</span></span><span> = </span><span><span>${</span>x <span>+</span> y<span>}</span></span><span>`</span></span>\n\n<span>let</span> obj <span>=</span> <span>{</span> x<span>:</span> <span>1</span><span>,</span> y<span>:</span> <span>2</span><span>}</span>\n<span><span>`</span><span><span>${</span>obj<span>.</span>x <span>+</span> obj<span>.</span>y<span>}</span></span><span>`</span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id=\"扩展方法\"> 扩展方法</h2>\n<h3 id=\"string-prototype-fromcodepoint\"> String.prototype.fromCodePoint()</h3>\n<p>用于从 Unicode 码点返回对应字符，并且可以识别大于 <code>0xFFFF</code> 的字符。</p>\n<div><pre><code><span>// ES5</span>\nconsole<span>.</span><span>log</span><span>(</span>String<span>.</span><span>fromCharCode</span><span>(</span><span>0x20BB7</span><span>)</span><span>)</span>\n\n<span>// ES6</span>\nconsole<span>.</span><span>log</span><span>(</span>String<span>.</span><span>fromCodePoint</span><span>(</span><span>0x20BB7</span><span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"string-prototype-includes\"> String.prototype.includes()</h3>\n<p>ES5 中可以使用 indexOf 方法来判断一个字符串是否包含在另一个字符串中，indexOf 返回出现的下标位置，如果不存在则返回 <code>-1</code>。</p>\n<div><pre><code><span>const</span> str <span>=</span> <span>'HelloWorld'</span>\n\nconsole<span>.</span><span>log</span><span>(</span>str<span>.</span><span>indexOf</span><span>(</span><span>'or'</span><span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>ES6 提供了 includes 方法来判断一个字符串是否包含在另一个字符串中，返回 boolean 类型的值。</p>\n<div><pre><code><span>const</span> str <span>=</span> <span>'HelloWorld'</span>\n\nconsole<span>.</span><span>log</span><span>(</span>str<span>.</span><span>includes</span><span>(</span><span>'or'</span><span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"string-prototype-startswith\"> String.prototype.startsWith()</h3>\n<p>判断参数字符串是否在原字符串的头部，返回 boolean 类型的值。</p>\n<div><pre><code><span>const</span> str <span>=</span> <span>'HelloWorld'</span>\n\nconsole<span>.</span><span>log</span><span>(</span>str<span>.</span><span>startsWith</span><span>(</span><span>'el'</span><span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"string-prototype-endswith\"> String.prototype.endsWith()</h3>\n<p>判断参数字符串是否在原字符串的尾部，返回 boolean 类型的值。</p>\n<div><pre><code><span>const</span> str <span>=</span> <span>'HelloWorld'</span>\n\nconsole<span>.</span><span>log</span><span>(</span>str<span>.</span><span>endsWith</span><span>(</span><span>'orld'</span><span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"string-prototype-repeat\"> String.prototype.repeat()</h3>\n<p>repeat 方法返回一个新字符串，表示将原字符串重复 n 次。</p>\n<div><pre><code><span>const</span> str <span>=</span> <span>'Hello'</span>\n\n<span>const</span> newStr <span>=</span> str<span>.</span><span>repeat</span><span>(</span><span>10</span><span>)</span>\n\nconsole<span>.</span><span>log</span><span>(</span>newStr<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/string\" target=\"_blank\" rel=\"noopener noreferrer\">字符串的扩展</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals\" target=\"_blank\" rel=\"noopener noreferrer\">模板字符串</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-01-04T09:55:41.000Z",
      "date_modified": "2022-01-05T08:00:08.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Symbol",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es6-symbol/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es6-symbol/",
      "content_html": "<h1 id=\"symbol\"> Symbol</h1>\n<p>ES6 引入了一种新的原始数据类型 <code>Symbol</code> ，表示独一无二的值。</p>\n<p>Symbol 值通过 Symbol 函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>\n<h2 id=\"声明方式\"> 声明方式</h2>\n<div><pre><code><span>let</span> s1 <span>=</span> <span>Symbol</span><span>(</span><span>)</span>\n<span>let</span> s2 <span>=</span> <span>Symbol</span><span>(</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>s1<span>)</span>        <span>// Symbol()</span>\nconsole<span>.</span><span>log</span><span>(</span>s2<span>)</span>        <span>// Symbol()</span>\nconsole<span>.</span><span>log</span><span>(</span>s1 <span>===</span> s2<span>)</span> <span>// false</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>\n<div><pre><code><span>let</span> s1 <span>=</span> <span>Symbol</span><span>(</span><span>'foo'</span><span>)</span>\n<span>let</span> s2 <span>=</span> <span>Symbol</span><span>(</span><span>'foo'</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>s1<span>)</span>        <span>// Symbol(foo)</span>\nconsole<span>.</span><span>log</span><span>(</span>s2<span>)</span>        <span>// Symbol(foo)</span>\nconsole<span>.</span><span>log</span><span>(</span>s1 <span>===</span> s2<span>)</span> <span>// false</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"symbol-for\"> Symbol.for()</h2>\n<p><code>Symbol.for()</code> 接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。</p>\n<div><pre><code><span>let</span> s1 <span>=</span> Symbol<span>.</span><span>for</span><span>(</span><span>'foo'</span><span>)</span>\n<span>let</span> s2 <span>=</span> Symbol<span>.</span><span>for</span><span>(</span><span>'foo'</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>s1 <span>===</span> s2<span>)</span> <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><p>注意</p>\n<p>Symbol.for() 与 Symbol() 这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for() 不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的 key 是否已经存在，如果不存在才会新建一个值。</p>\n</div>\n<h2 id=\"symbol-keyfor\"> Symbol.keyFor()</h2>\n<p><code>Symbol.keyFor()</code> 方法返回一个已登记的 Symbol 类型值的 key。</p>\n<blockquote>\n<p>Symbol.keyFor() 方法使用全局符号注册表来查找符号的键。因此，它不适用于非全局符号。如果该符号不是全局符号，则将无法找到它并返回未定义。</p>\n</blockquote>\n<div><pre><code><span>const</span> s1 <span>=</span> <span>Symbol</span><span>(</span><span>'foo'</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>Symbol<span>.</span><span>keyFor</span><span>(</span>s1<span>)</span><span>)</span> <span>// undefined</span>\n\n<span>const</span> s2 <span>=</span> Symbol<span>.</span><span>for</span><span>(</span><span>'foo'</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>Symbol<span>.</span><span>keyFor</span><span>(</span>s2<span>)</span><span>)</span> <span>// foo</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"作为属性名\"> 作为属性名</h2>\n<p>由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p>\n<p>比如在一个班级中，可能会有同学名字相同的情况，这时候使用对象来描述学生信息的时候，如果直接使用学生姓名作为 key 会有问题。如果使用 Symbol，同名的学生信息就不会被覆盖。</p>\n<div><pre><code><span>let</span> stu1 <span>=</span> <span>Symbol</span><span>(</span><span>'李四'</span><span>)</span>\n<span>let</span> stu2 <span>=</span> <span>Symbol</span><span>(</span><span>'李四'</span><span>)</span>\n<span>let</span> stu3 <span>=</span> <span>Symbol</span><span>(</span><span>'李四'</span><span>)</span>\n\n<span>// 第一种写法</span>\n<span>let</span> grade <span>=</span> <span>{</span>\n  <span>[</span>stu1<span>]</span><span>:</span> <span>{</span>\n    address<span>:</span> <span>'xxx'</span><span>,</span>\n    tel<span>:</span> <span>'111'</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 第二种写法</span>\ngrade<span>[</span>stu2<span>]</span> <span>=</span> <span>{</span>\n  address<span>:</span> <span>'yyy'</span><span>,</span>\n  tel<span>:</span> <span>'222'</span>\n<span>}</span>\n\n<span>// 第三种写法</span>\nObject<span>.</span><span>defineProperty</span><span>(</span>grade<span>,</span> stu3<span>,</span> <span>{</span>\n  value<span>:</span> <span>{</span> address<span>:</span> <span>'zzz'</span><span>,</span> tel<span>:</span> <span>'333'</span> <span>}</span><span>,</span>\n  writable<span>:</span> <span>true</span><span>,</span>\n  configurable<span>:</span> <span>true</span><span>,</span>\n  enumerable<span>:</span> <span>true</span>\n<span>}</span><span>)</span>\n\n<span>// 以上写法都能往学生信息中写入同名学生</span>\nconsole<span>.</span><span>log</span><span>(</span>grade<span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>grade<span>[</span>stu1<span>]</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>grade<span>[</span>stu2<span>]</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>grade<span>[</span>stu3<span>]</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><h2 id=\"属性遍历\"> 属性遍历</h2>\n<p>Symbol 作为属性名，遍历对象的时候，常规的遍历方法（如下）是无法获取到该属性的：</p>\n<ul>\n<li>for...in、for...of 循环中</li>\n<li>Object.keys()</li>\n<li>Object.getOwnPropertyNames()</li>\n<li>JSON.stringify()</li>\n</ul>\n<p>它有一个 <code>Object.getOwnPropertySymbols()</code> 方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p>\n<div><pre><code><span>let</span> obj <span>=</span> <span>{</span><span>}</span>\n<span>let</span> a <span>=</span> <span>Symbol</span><span>(</span><span>'a'</span><span>)</span>\n<span>let</span> b <span>=</span> <span>Symbol</span><span>(</span><span>'b'</span><span>)</span>\n\nobj<span>[</span>a<span>]</span> <span>=</span> <span>'Hello'</span>\nobj<span>[</span>b<span>]</span> <span>=</span> <span>'World'</span>\n\n<span>let</span> objectSymbols <span>=</span> Object<span>.</span><span>getOwnPropertySymbols</span><span>(</span>obj<span>)</span>\n\nconsole<span>.</span><span>log</span><span>(</span>objectSymbols<span>)</span> <span>// [Symbol(a), Symbol(b)]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>另外，在 ES6 中还有一个新的 API，<code>Reflect.ownKeys()</code> 方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p>\n<div><pre><code><span>let</span> obj <span>=</span> <span>{</span><span>}</span>\n<span>let</span> a <span>=</span> <span>Symbol</span><span>(</span><span>'a'</span><span>)</span>\n<span>let</span> b <span>=</span> <span>Symbol</span><span>(</span><span>'b'</span><span>)</span>\n\nobj<span>[</span>a<span>]</span> <span>=</span> <span>'Hello'</span>\nobj<span>[</span>b<span>]</span> <span>=</span> <span>'World'</span>\n\n<span>let</span> objectSymbols <span>=</span> Reflect<span>.</span><span>ownKeys</span><span>(</span>obj<span>)</span>\n\nconsole<span>.</span><span>log</span><span>(</span>objectSymbols<span>)</span> <span>// [Symbol(a), Symbol(b)]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id=\"消除魔术字符串\"> 消除魔术字符串</h2>\n<p>魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。</p>\n<div><pre><code><span>function</span> <span>getArea</span><span>(</span><span>shape</span><span>)</span> <span>{</span>\n  <span>let</span> area <span>=</span> <span>0</span>\n  <span>switch</span> <span>(</span>shape<span>)</span> <span>{</span>\n    <span>case</span> <span>'Triangle'</span><span>:</span>\n      area <span>=</span> <span>1</span>\n      <span>break</span>\n    <span>case</span> <span>'Circle'</span><span>:</span>\n      area <span>=</span> <span>2</span>\n      <span>break</span>\n  <span>}</span>\n  <span>return</span> area\n<span>}</span>\nconsole<span>.</span><span>log</span><span>(</span><span>getArea</span><span>(</span><span>'Triangle'</span><span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>上面代码中，字符串 <code>Triangle</code> 和 <code>Circle</code> 就是魔术字符串。它多次出现，与代码形成「强耦合」，不利于将来的修改和维护。</p>\n<p>使用 Symbol 就可以很好的解决这个问题：</p>\n<div><pre><code><span>const</span> shapeType <span>=</span> <span>{</span>\n  triangle<span>:</span> <span>Symbol</span><span>(</span><span>)</span><span>,</span>\n  circle<span>:</span> <span>Symbol</span><span>(</span><span>)</span>\n<span>}</span>\n\n<span>function</span> <span>getArea</span><span>(</span><span>shape</span><span>)</span> <span>{</span>\n  <span>let</span> area <span>=</span> <span>0</span>\n  <span>switch</span> <span>(</span>shape<span>)</span> <span>{</span>\n    <span>case</span> shapeType<span>.</span>triangle<span>:</span>\n      area <span>=</span> <span>1</span>\n      <span>break</span>\n    <span>case</span> shapeType<span>.</span>circle<span>:</span>\n      area <span>=</span> <span>2</span>\n      <span>break</span>\n  <span>}</span>\n  <span>return</span> area\n<span>}</span>\nconsole<span>.</span><span>log</span><span>(</span><span>getArea</span><span>(</span>shapeType<span>.</span>triangle<span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/symbol\" target=\"_blank\" rel=\"noopener noreferrer\">Symbol</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Symbol\" target=\"_blank\" rel=\"noopener noreferrer\">Symbol</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA%E5%B1%9E%E6%80%A7%E5%92%8C%E9%BB%98%E8%AE%A4%E5%80%BC\" target=\"_blank\" rel=\"noopener noreferrer\">Object.defineProperty()</a></li>\n</ul>\n",
      "date_published": "2022-01-03T09:07:00.000Z",
      "date_modified": "2022-01-03T09:07:00.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Set",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es6-set/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es6-set/",
      "content_html": "<h1 id=\"set\"> Set</h1>\n<p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>\n<h2 id=\"基本语法\"> 基本语法</h2>\n<h3 id=\"生成-set-实例\"> 生成 Set 实例</h3>\n<p>定义一个空的 Set 实例。</p>\n<div><pre><code><span>let</span> s <span>=</span> <span>new</span> <span>Set</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>在实例化的同时传入默认的数据。</p>\n<div><pre><code><span>let</span> s <span>=</span> <span>new</span> <span>Set</span><span>(</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>]</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><div><p>注意</p>\n<p>初始化的参数必须是可遍历的，可以是数组或者自定义遍历的数据结构。</p>\n</div>\n<h3 id=\"添加数据\"> 添加数据</h3>\n<div><pre><code>s<span>.</span><span>add</span><span>(</span><span>'hello'</span><span>)</span>\ns<span>.</span><span>add</span><span>(</span><span>'goodbye'</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>或者</p>\n<div><pre><code>s<span>.</span><span>add</span><span>(</span><span>'hello'</span><span>)</span><span>.</span><span>add</span><span>(</span><span>'goodbye'</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><div><p>注意</p>\n<p>Set 数据结构不允许数据重复，所以添加重复的数据是无效的。</p>\n</div>\n<h3 id=\"删除数据\"> 删除数据</h3>\n<p>删除数据分两种，一种是删除指定的数据，一种是删除全部数据。</p>\n<div><pre><code><span>// 删除指定数据</span>\ns<span>.</span><span>delete</span><span>(</span><span>'hello'</span><span>)</span> <span>// true</span>\n\n<span>// 删除全部数据</span>\ns<span>.</span><span>clear</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"统计数据\"> 统计数据</h3>\n<p>Set 可以快速进行统计数据，如数据是否存在、数据的总数。</p>\n<div><pre><code><span>// 判断是否包含数据项，返回 true 或 false</span>\ns<span>.</span><span>has</span><span>(</span><span>'hello'</span><span>)</span> <span>// true</span>\n\n<span>// 计算数据项总数</span>\ns<span>.</span>size         <span>// 2</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"数组去重\"> 数组去重</h3>\n<p>去除数组中的重复元素。</p>\n<div><pre><code><span>let</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span>\n<span>let</span> s <span>=</span> <span>new</span> <span>Set</span><span>(</span>arr<span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>s<span>)</span> <span>// Set { 1, 2, 3, 4 }</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"合并去重\"> 合并去重</h3>\n<p>合并两数组，去除重复元素。</p>\n<div><pre><code><span>let</span> arr1 <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>]</span>\n<span>let</span> arr2 <span>=</span> <span>[</span><span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>]</span>\n\n<span>let</span> s <span>=</span> <span>new</span> <span>Set</span><span>(</span><span>[</span><span>...</span>arr1<span>,</span> <span>...</span>arr2<span>]</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>s<span>)</span>             <span>// Set { 1, 2, 3, 4, 5, 6 }</span>\nconsole<span>.</span><span>log</span><span>(</span><span>[</span><span>...</span>s<span>]</span><span>)</span>        <span>// [ 1, 2, 3, 4, 5, 6 ]</span>\nconsole<span>.</span><span>log</span><span>(</span>Array<span>.</span><span>from</span><span>(</span>s<span>)</span><span>)</span> <span>// [ 1, 2, 3, 4, 5, 6 ]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"交集\"> 交集</h3>\n<p>取两个数组中相同的元素。</p>\n<div><pre><code><span>let</span> arr1 <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>]</span>\n<span>let</span> arr2 <span>=</span> <span>[</span><span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>]</span>\n\n<span>let</span> s1 <span>=</span> <span>new</span> <span>Set</span><span>(</span>arr1<span>)</span>\n<span>let</span> s2 <span>=</span> <span>new</span> <span>Set</span><span>(</span>arr2<span>)</span>\n<span>let</span> result <span>=</span> <span>new</span> <span>Set</span><span>(</span>arr1<span>.</span><span>filter</span><span>(</span><span>item</span> <span>=></span> s2<span>.</span><span>has</span><span>(</span>item<span>)</span><span>)</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>Array<span>.</span><span>from</span><span>(</span>result<span>)</span><span>)</span> <span>// [ 2, 3, 4 ]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"差集\"> 差集</h3>\n<p>取两个数组中不同的元素。</p>\n<div><pre><code><span>let</span> arr1 <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>]</span>\n<span>let</span> arr2 <span>=</span> <span>[</span><span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>]</span>\n\n<span>let</span> s1 <span>=</span> <span>new</span> <span>Set</span><span>(</span>arr1<span>)</span>\n<span>let</span> s2 <span>=</span> <span>new</span> <span>Set</span><span>(</span>arr2<span>)</span>\n<span>let</span> arr3 <span>=</span> <span>new</span> <span>Set</span><span>(</span>arr1<span>.</span><span>filter</span><span>(</span><span>item</span> <span>=></span> <span>!</span>s2<span>.</span><span>has</span><span>(</span>item<span>)</span><span>)</span><span>)</span>\n<span>let</span> arr4 <span>=</span> <span>new</span> <span>Set</span><span>(</span>arr2<span>.</span><span>filter</span><span>(</span><span>item</span> <span>=></span> <span>!</span>s1<span>.</span><span>has</span><span>(</span>item<span>)</span><span>)</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>arr3<span>)</span>               <span>// Set { 1 }</span>\nconsole<span>.</span><span>log</span><span>(</span>arr4<span>)</span>               <span>// Set { 5, 6 }</span>\nconsole<span>.</span><span>log</span><span>(</span><span>[</span><span>...</span>arr3<span>,</span> <span>...</span>arr4<span>]</span><span>)</span> <span>// [ 1, 5, 6 ]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id=\"遍历方式\"> 遍历方式</h2>\n<ul>\n<li><code>keys()</code>：返回键名的遍历器</li>\n<li><code>values()</code>：返回键值的遍历器</li>\n<li><code>entries()</code>：返回键值对的遍历器</li>\n<li><code>forEach()</code>：使用回调函数遍历每个成员</li>\n<li><code>for...of</code>：可以直接遍历每个成员</li>\n</ul>\n<div><pre><code><span>let</span> s <span>=</span> <span>new</span> <span>Set</span><span>(</span><span>[</span><span>'hello'</span><span>,</span> <span>'goodbye'</span><span>]</span><span>)</span>\n\nconsole<span>.</span><span>log</span><span>(</span>s<span>.</span><span>keys</span><span>(</span><span>)</span><span>)</span>    <span>// SetIterator {'hello', 'goodbye'}</span>\nconsole<span>.</span><span>log</span><span>(</span>s<span>.</span><span>values</span><span>(</span><span>)</span><span>)</span>  <span>// SetIterator {'hello', 'goodbye'}</span>\nconsole<span>.</span><span>log</span><span>(</span>s<span>.</span><span>entries</span><span>(</span><span>)</span><span>)</span> <span>// SetIterator {'hello' => 'hello', 'goodbye' => 'goodbye'}</span>\n\ns<span>.</span><span>forEach</span><span>(</span><span>item</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>item<span>)</span>             <span>// hello  // goodbye</span>\n<span>}</span><span>)</span>\n\n<span>for</span> <span>(</span><span>let</span> item <span>of</span> s<span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>item<span>)</span>             <span>// hello  // goodbye</span>\n<span>}</span>\n\n<span>for</span> <span>(</span><span>let</span> item <span>of</span> s<span>.</span><span>keys</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>item<span>)</span>             <span>// hello  // goodbye</span>\n<span>}</span>\n\n<span>for</span> <span>(</span><span>let</span> item <span>of</span> s<span>.</span><span>values</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>item<span>)</span>             <span>// hello  // goodbye</span>\n<span>}</span>\n\n<span>for</span> <span>(</span><span>let</span> item <span>of</span> s<span>.</span><span>entries</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>item<span>[</span><span>0</span><span>]</span><span>,</span> item<span>[</span><span>1</span><span>]</span><span>)</span> <span>// hello hello  // goodbye goodbye</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h2 id=\"weakset\"> WeakSet</h2>\n<p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有三个区别：</p>\n<ul>\n<li>WeakSet 的成员只能是对象，而不能是其他类型的值。</li>\n</ul>\n<div><pre><code><span>let</span> ws <span>=</span> <span>new</span> <span>WeakSet</span><span>(</span><span>)</span>\nws<span>.</span><span>add</span><span>(</span><span>1</span><span>)</span>\n<span>// TypeError: Invalid value used in weak set</span>\nws<span>.</span><span>add</span><span>(</span><span>Symbol</span><span>(</span><span>)</span><span>)</span>\n<span>// TypeError: invalid value used in weak set</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>let</span> ws <span>=</span> <span>new</span> <span>WeakSet</span><span>(</span><span>)</span>\n<span>const</span> obj1 <span>=</span> <span>{</span>\n  name<span>:</span> <span>'imooc'</span>\n<span>}</span>\n<span>const</span> obj2 <span>=</span> <span>{</span>\n  age<span>:</span> <span>5</span>\n<span>}</span>\nws<span>.</span><span>add</span><span>(</span>obj1<span>)</span>\nws<span>.</span><span>add</span><span>(</span>obj2<span>)</span>\nws<span>.</span><span>delete</span><span>(</span>obj1<span>)</span>\n\nconsole<span>.</span><span>log</span><span>(</span>ws<span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>ws<span>.</span><span>has</span><span>(</span>obj2<span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><ul>\n<li>WeakSet 没有 <code>size</code> 属性，没有办法遍历它的成员。</li>\n<li>WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</li>\n</ul>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/set-map\" target=\"_blank\" rel=\"noopener noreferrer\">Set 和 Map 数据结构</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set\" target=\"_blank\" rel=\"noopener noreferrer\">Set</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-01-04T07:49:34.000Z",
      "date_modified": "2022-01-04T08:56:00.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Array.prototype.includes()",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es7-array/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es7-array/",
      "content_html": "<h1 id=\"array-prototype-includes\"> Array.prototype.includes()</h1>\n<p>在 ES7 之前想判断数组中是否包含一个元素，一般这样写：</p>\n<div><pre><code>console<span>.</span><span>log</span><span>(</span>arr<span>.</span><span>find</span><span>(</span><span>function</span><span>(</span><span>item</span><span>)</span> <span>{</span>\n  <span>return</span> item <span>===</span> <span>2</span>\n<span>}</span><span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>或者</p>\n<div><pre><code>console<span>.</span><span>log</span><span>(</span>arr<span>.</span><span>filter</span><span>(</span><span>function</span><span>(</span><span>item</span><span>)</span> <span>{</span>\n  <span>return</span> item <span>===</span> <span>2</span>\n<span>}</span><span>)</span><span>.</span>length <span>></span> <span>0</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>ES7 引入的 <code>Array.prototype.includes()</code> 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 <code>true</code>，否则返回 <code>false</code>。</p>\n<h2 id=\"基本用法\"> 基本用法</h2>\n<div><pre><code><span>const</span> arr <span>=</span> <span>[</span><span>'es6'</span><span>,</span> <span>'es7'</span><span>,</span> <span>'es8'</span><span>]</span>\nconsole<span>.</span><span>log</span><span>(</span>arr<span>.</span><span>includes</span><span>(</span><span>'es6'</span><span>)</span><span>)</span> <span>// true</span>\nconsole<span>.</span><span>log</span><span>(</span>arr<span>.</span><span>includes</span><span>(</span><span>'es9'</span><span>)</span><span>)</span> <span>// false</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"接收两个参数\"> 接收两个参数</h2>\n<p>要搜索的值和搜索的开始索引。第二个参数可选。从该索引处开始查找。如果为负值，表示从末尾开始往前跳该赋值的绝对值个索引，然后继续往后搜寻。</p>\n<div><pre><code><span>const</span> arr <span>=</span> <span>[</span><span>'es6'</span><span>,</span> <span>'es7'</span><span>,</span> <span>'es8'</span><span>]</span>\nconsole<span>.</span><span>log</span><span>(</span>arr<span>.</span><span>includes</span><span>(</span><span>'es7'</span><span>,</span> <span>1</span><span>)</span><span>)</span>  <span>// true</span>\nconsole<span>.</span><span>log</span><span>(</span>arr<span>.</span><span>includes</span><span>(</span><span>'es7'</span><span>,</span> <span>2</span><span>)</span><span>)</span>  <span>// false</span>\nconsole<span>.</span><span>log</span><span>(</span>arr<span>.</span><span>includes</span><span>(</span><span>'es7'</span><span>,</span> <span>-</span><span>1</span><span>)</span><span>)</span> <span>// false</span>\nconsole<span>.</span><span>log</span><span>(</span>arr<span>.</span><span>includes</span><span>(</span><span>'es7'</span><span>,</span> <span>-</span><span>2</span><span>)</span><span>)</span> <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"与-indexof-比较\"> 与 indexOf() 比较</h2>\n<div><pre><code><span>const</span> arr <span>=</span> <span>[</span><span>'es6'</span><span>,</span> <span>'es7'</span><span>,</span> <span>'es8'</span><span>]</span>\nconsole<span>.</span><span>log</span><span>(</span>arr<span>.</span><span>includes</span><span>(</span><span>'es6'</span><span>)</span><span>)</span>     <span>// true</span>\nconsole<span>.</span><span>log</span><span>(</span>arr<span>.</span><span>indexOf</span><span>(</span><span>'es6'</span><span>)</span> <span>></span> <span>-</span><span>1</span><span>)</span> <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><p>注意</p>\n<p>只能判断简单类型的数据，对于复杂类型的数据，比如对象类型的数组，二维数组，这些是无法判断的。</p>\n</div>\n<div><pre><code><span>const</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span> <span>[</span><span>2</span><span>,</span> <span>3</span><span>]</span><span>,</span> <span>4</span><span>]</span>\nconsole<span>.</span><span>log</span><span>(</span>arr<span>.</span><span>includes</span><span>(</span><span>[</span><span>2</span><span>,</span> <span>3</span><span>]</span><span>)</span><span>)</span> <span>// false</span>\nconsole<span>.</span><span>log</span><span>(</span>arr<span>.</span><span>indexOf</span><span>(</span><span>[</span><span>2</span><span>,</span> <span>3</span><span>]</span><span>)</span><span>)</span>  <span>// -1</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>优缺点比较</strong>：</p>\n<p>两者都是采用 <code>===</code> 的操作符来作比较的，不同之处在于：对于 <code>NaN</code> 的处理结果不同。在 js 中 <code>NaN === NaN</code> 的结果是 <code>false</code>，<code>indexOf()</code> 就是这样处理的，但是 <code>includes()</code> 不是这样的。</p>\n<div><pre><code><span>const</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span> <span>NaN</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span>\nconsole<span>.</span><span>log</span><span>(</span>arr<span>.</span><span>indexOf</span><span>(</span><span>NaN</span><span>)</span><span>)</span>  <span>// -1</span>\nconsole<span>.</span><span>log</span><span>(</span>arr<span>.</span><span>includes</span><span>(</span><span>NaN</span><span>)</span><span>)</span> <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><p>总结</p>\n<p>如果只想知道某个值是否在数组中存在，而并不关心它的索引位置，建议使用 <code>includes()</code>。如果想获取一个值在数组中的位置，那么只能使用 <code>indexOf()</code> 方法。</p>\n</div>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes\" target=\"_blank\" rel=\"noopener noreferrer\">Array.prototype.includes()</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-01-18T09:16:48.000Z",
      "date_modified": "2022-01-18T09:16:48.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "async / await",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es8-async-await/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es8-async-await/",
      "content_html": "<h1 id=\"async-await\"> async / await</h1>\n<p>async 和 await 是一种更加优雅的异步编程解决方案，是 Promise 的拓展。</p>\n<h2 id=\"基本语法\"> 基本语法</h2>\n<p>前面添加了 <code>async</code> 的函数在执行后都会自动返回一个 Promise 对象：</p>\n<div><pre><code><span>async</span> <span>function</span> <span>foo</span><span>(</span><span>)</span> <span>{</span>\n  <span>return</span> <span>'hello'</span>\n<span>}</span>\nconsole<span>.</span><span>log</span><span>(</span><span>foo</span><span>(</span><span>)</span><span>)</span> <span>// Promise</span>\n<span>foo</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>相当于：</p>\n<div><pre><code><span>function</span> <span>foo</span><span>(</span><span>)</span> <span>{</span>\n  <span>return</span> Promise<span>.</span><span>resolve</span><span>(</span><span>'hello'</span><span>)</span>\n<span>}</span>\nconsole<span>.</span><span>log</span><span>(</span><span>foo</span><span>(</span><span>)</span><span>)</span> <span>// Promise</span>\n<span>foo</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>await</code> 后面需要跟异步操作，不然就没有意义，而且 <code>await</code> 后面的 Promise 对象不必写 <code>then</code>，因为 <code>await</code> 的作用之一就是获取后面 Promise 对象成功状态传递出来的参数。</p>\n<div><pre><code><span>function</span> <span>timeout</span><span>(</span><span>)</span> <span>{</span>\n  <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>resolve</span> <span>=></span> <span>{</span>\n    <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n      console<span>.</span><span>log</span><span>(</span><span>1</span><span>)</span>\n      <span>resolve</span><span>(</span><span>'success'</span><span>)</span>\n    <span>}</span><span>,</span> <span>1000</span><span>)</span>\n  <span>}</span><span>)</span>\n<span>}</span>\n\n<span>// 不加 async 和 await 是 2、1, 加了是 1、2</span>\n<span>async</span> <span>function</span> <span>foo</span><span>(</span><span>)</span> <span>{</span>\n  <span>let</span> res <span>=</span> <span>await</span> <span>timeout</span><span>(</span><span>)</span>\n  console<span>.</span><span>log</span><span>(</span><span>2</span><span>)</span>\n  console<span>.</span><span>log</span><span>(</span>res<span>)</span>\n<span>}</span>\n<span>foo</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id=\"对于失败的处理\"> 对于失败的处理</h2>\n<div><pre><code><span>function</span> <span>timeout</span><span>(</span><span>)</span> <span>{</span>\n  <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n    <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n      <span>reject</span><span>(</span><span>'error'</span><span>)</span>\n    <span>}</span><span>,</span> <span>1000</span><span>)</span>\n  <span>}</span><span>)</span>\n<span>}</span>\n<span>async</span> <span>function</span> <span>foo</span><span>(</span><span>)</span> <span>{</span>\n  <span>return</span> <span>await</span> <span>timeout</span><span>(</span><span>)</span>\n<span>}</span>\n\n<span>foo</span><span>(</span><span>)</span><span>.</span><span>then</span><span>(</span><span>res</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>res<span>)</span>\n<span>}</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>err</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>err<span>)</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>在 <code>async</code> 函数中使用 <code>await</code>，那么 <code>await</code> 这里的代码就会变成同步的了，意思就是说只有等 <code>await</code> 后面的 Promise 执行完成得到结果才会继续下去，<code>await</code> 就是等待。</p>\n<h2 id=\"应用\"> 应用</h2>\n<p>需要发送多个请求，后面请求的发送得依赖上一个请求返回的数据。对于这个问题，既可以用的 Promise 的链式调用来解决，也可以用 async/await 来解决，然而后者会更简洁些。</p>\n<div><pre><code><span>// 把 ajax 封装成模块</span>\n<span>import</span> ajax <span>from</span> <span>'./ajax'</span>\n\n<span>function</span> <span>request</span><span>(</span><span>url</span><span>)</span> <span>{</span>\n  <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>resolve</span> <span>=></span> <span>{</span>\n    <span>ajax</span><span>(</span>url<span>,</span> <span>res</span> <span>=></span> <span>{</span>\n      <span>resolve</span><span>(</span>res<span>)</span>\n    <span>}</span><span>)</span>\n  <span>}</span><span>)</span>\n<span>}</span>\n<span>async</span> <span>function</span> <span>getData</span><span>(</span><span>)</span> <span>{</span>\n  <span>let</span> res1 <span>=</span> <span>await</span> <span>request</span><span>(</span><span>'static/a.json'</span><span>)</span>\n  console<span>.</span><span>log</span><span>(</span>res1<span>)</span>\n  <span>let</span> res2 <span>=</span> <span>await</span> <span>request</span><span>(</span><span>'static/b.json'</span><span>)</span>\n  console<span>.</span><span>log</span><span>(</span>res2<span>)</span>\n  <span>let</span> res3 <span>=</span> <span>await</span> <span>request</span><span>(</span><span>'static/c.json'</span><span>)</span>\n  console<span>.</span><span>log</span><span>(</span>res3<span>)</span>\n<span>}</span>\n\n<span>getData</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><div><p>注意</p>\n<p><code>await</code> 只能在 <code>async</code> 标记的函数内部使用，单独使用会触发 Syntax error。</p>\n</div>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/async\" target=\"_blank\" rel=\"noopener noreferrer\">async 函数</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function\" target=\"_blank\" rel=\"noopener noreferrer\">async函数</a></li>\n<li><a href=\"https://zh.javascript.info/async-await\" target=\"_blank\" rel=\"noopener noreferrer\">Async/await</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-01-19T09:39:20.000Z",
      "date_modified": "2022-01-19T09:44:08.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Object 扩展",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es8-object/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es8-object/",
      "content_html": "<h1 id=\"object-扩展\"> Object 扩展</h1>\n<h2 id=\"以前遍历对象\"> 以前遍历对象</h2>\n<p>以前是这样获取对象的每一个属性值的：</p>\n<div><pre><code><span>const</span> obj <span>=</span> <span>{</span>\n  name<span>:</span> <span>'zhangsan'</span><span>,</span>\n  age<span>:</span> <span>13</span><span>,</span>\n  gender<span>:</span> <span>'male'</span>\n<span>}</span>\n\nconsole<span>.</span><span>log</span><span>(</span>Object<span>.</span><span>keys</span><span>(</span>obj<span>)</span><span>)</span>\n<span>// ['name', 'age', 'gender']</span>\n\n<span>const</span> res <span>=</span> Object<span>.</span><span>keys</span><span>(</span>obj<span>)</span><span>.</span><span>map</span><span>(</span><span>key</span> <span>=></span> obj<span>[</span>key<span>]</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>res<span>)</span>\n<span>// ['zhangsan', 13, 'male']</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>ES8 中对象扩展补充了两个静态方法，用于遍历对象：<code>Object.values()</code>，<code>Object.entries()</code></p>\n<h2 id=\"object-values\"> Object.values()</h2>\n<p><code>Object.values()</code> 返回一个数组，其元素是在对象上找到的可枚举属性值。属性的顺序与通过手动循环对象的属性值（for...in）所给出的顺序相同（区别在于 for...in 还会遍历原型上的属性值）。</p>\n<div><pre><code><span>const</span> obj <span>=</span> <span>{</span>\n  name<span>:</span> <span>'zhangsan'</span><span>,</span>\n  age<span>:</span> <span>13</span><span>,</span>\n  gender<span>:</span> <span>'male'</span>\n<span>}</span>\n\nconsole<span>.</span><span>log</span><span>(</span>Object<span>.</span><span>values</span><span>(</span>obj<span>)</span><span>)</span>\n<span>// ['zhangsan', 13, 'male']</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><p>提示</p>\n<p><code>Object.values()</code> 是在对象上找到可枚举的属性的值，所以只要这个对象是可枚举的就可以，不只是 <code>{}</code> 这种形式。</p>\n</div>\n<h2 id=\"object-entries\"> Object.entries()</h2>\n<p><code>Object.entries()</code> 方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for...in 循环也枚举原型链中的属性）。</p>\n<div><pre><code><span>const</span> obj <span>=</span> <span>{</span>\n  name<span>:</span> <span>'zhangsan'</span><span>,</span>\n  age<span>:</span> <span>13</span><span>,</span>\n  gender<span>:</span> <span>'male'</span>\n<span>}</span>\n\n<span>for</span> <span>(</span><span>let</span> <span>[</span>k<span>,</span> v<span>]</span> <span>of</span> Object<span>.</span><span>entries</span><span>(</span>obj<span>)</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>k<span>,</span> v<span>)</span>\n  <span>// name zhangsan</span>\n  <span>// age 13</span>\n  <span>// gender male</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><p>提示</p>\n<p><code>Object.entries()</code> 返回的是数组，因此上述代码还用到了数组的解构赋值。</p>\n</div>\n<h2 id=\"object-getownpropertydescriptors\"> Object.getOwnPropertyDescriptors()</h2>\n<h3 id=\"属性描述符\"> 属性描述符</h3>\n<div><pre><code><span>const</span> obj <span>=</span> <span>{</span>\n  name<span>:</span> <span>'zhangsan'</span><span>,</span>\n  age<span>:</span> <span>13</span><span>,</span>\n  gender<span>:</span> <span>'male'</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>前面的几个例子中，都把这个对象的所有 key、value 遍历出来了，如果我们不想让 <code>gender</code> 这个属性和值被枚举怎么办？</p>\n<div><pre><code>Object<span>.</span><span>defineProperty</span><span>(</span>obj<span>,</span> <span>'gender'</span><span>,</span> <span>{</span>\n  enumerable<span>:</span> <span>false</span>\n<span>}</span><span>)</span>\n\nObject<span>.</span><span>entries</span><span>(</span>obj<span>)</span><span>.</span><span>map</span><span>(</span><span>(</span><span><span>[</span>key<span>,</span> value<span>]</span></span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span> <span><span>`</span><span>key: </span><span><span>${</span>key<span>.</span><span>padEnd</span><span>(</span><span>10</span><span>)</span><span>}</span></span><span> value: </span><span><span>${</span>value<span>}</span></span><span>`</span></span> <span>)</span>\n  <span>// key: name       value: zhangsan</span>\n  <span>// key: age        value: 13</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>defineProperty 的第三个参数就是属性描述符（descriptor）它包括几个属性：</p>\n<ul>\n<li>value：属性的值</li>\n<li>writable：属性的值是否可被改变</li>\n<li>enumerable：属性的值是否可被枚举</li>\n<li>configurable：描述符本身是否可被修改，属性是否可被删除</li>\n</ul>\n<p>具体可参考 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\" target=\"_blank\" rel=\"noopener noreferrer\">Object.defineProperty</a>。</p>\n<h3 id=\"函数介绍\"> 函数介绍</h3>\n<p>获取对象指定属性的描述符：</p>\n<div><pre><code>console<span>.</span><span>log</span><span>(</span>Object<span>.</span><span>getOwnPropertyDescriptor</span><span>(</span>obj<span>,</span> <span>'gender'</span><span>)</span><span>)</span>\n<span>// {value: 'male', writable: true, enumerable: true, configurable: true}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>获取对象所有属性的描述符：</p>\n<div><pre><code>console<span>.</span><span>log</span><span>(</span>Object<span>.</span><span>getOwnPropertyDescriptors</span><span>(</span>obj<span>)</span><span>)</span>\n<span>// {name: {…}, age: {…}, gender: {…}}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"参考文档\"> 参考文档</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/values\" target=\"_blank\" rel=\"noopener noreferrer\">Object.values()</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\" target=\"_blank\" rel=\"noopener noreferrer\">Object.entries()</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors\" target=\"_blank\" rel=\"noopener noreferrer\">Object.getOwnPropertyDescriptors()</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-01-19T10:19:03.000Z",
      "date_modified": "2022-01-27T10:01:35.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "尾逗号 Trailing commas",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es8-trailing-commas/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es8-trailing-commas/",
      "content_html": "<h1 id=\"尾逗号-trailing-commas\"> 尾逗号 Trailing commas</h1>\n<h2 id=\"es8-以前\"> ES8 以前</h2>\n<p>在 ES8 以前，函数定义和调用时，都不允许最后一个参数后面出现逗号。</p>\n<div><pre><code><span>function</span> <span>foo</span><span>(</span>\n  <span>param1<span>,</span>\n  param2</span>\n<span>)</span> <span>{</span>\n  <span>/* ... */</span>\n<span>}</span>\n\n<span>foo</span><span>(</span>\n  <span>'hello'</span><span>,</span>\n  <span>'world'</span>\n<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面代码中，如果在 <code>param2</code> 或 <code>'world'</code> 后面加一个逗号，就会报错。</p>\n<h2 id=\"es8-新规定\"> ES8 新规定</h2>\n<p>如果像上面这样，将参数写成多行（即每个参数占据一行），以后修改代码的时候，想为函数 foo 添加第三个参数，或者调整参数的次序，就势必要在原来最后一个参数后面添加一个逗号。这对于版本管理系统来说，就会显示添加逗号的那一行也发生了变动。这看上去有点冗余，因此新的语法允许定义和调用时，尾部直接有一个逗号。</p>\n<div><pre><code><span>function</span> <span>foo</span><span>(</span>\n  <span>param1<span>,</span>\n  param2<span>,</span></span>\n<span>)</span> <span>{</span>\n  <span>/* ... */</span>\n<span>}</span>\n\n<span>foo</span><span>(</span>\n  <span>'hello'</span><span>,</span>\n  <span>'world'</span><span>,</span>\n<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>这样的规定也使得，函数参数与数组和对象的尾逗号规则，保持一致了。</p>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Trailing_commas\" target=\"_blank\" rel=\"noopener noreferrer\">尾后逗号</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-01-31T07:57:00.000Z",
      "date_modified": "2022-01-31T07:57:00.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Object 扩展",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es9-object/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es9-object/",
      "content_html": "<h1 id=\"object-扩展\"> Object 扩展</h1>\n<p>ES6 支持了 Function 的 Rest 参数和扩展运算符和 ，而 ES9 给 Object 也赋予了这两个特性。</p>\n<h2 id=\"rest-参数\"> Rest 参数</h2>\n<p>当对象 key-value 不确定的时候，把必选的 key 赋值给一个变量，用另一个变量收敛其他可选的 key 数据，这在之前是做不到的。</p>\n<div><pre><code><span>const</span> input <span>=</span> <span>{</span>\n  a<span>:</span> <span>1</span><span>,</span>\n  b<span>:</span> <span>2</span><span>,</span>\n  c<span>:</span> <span>3</span>\n<span>}</span>\n\n<span>let</span> <span>{</span> a<span>,</span> <span>...</span>rest <span>}</span> <span>=</span> input\n\nconsole<span>.</span><span>log</span><span>(</span>a<span>,</span> rest<span>)</span> <span>// 1 {b: 2, c: 3}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id=\"扩展运算符\"> 扩展运算符</h2>\n<p>可以把 <code>input</code> 对象的数据都拓展到 <code>output</code> 对象，这个功能很实用。</p>\n<div><pre><code><span>const</span> input <span>=</span> <span>{</span>\n  a<span>:</span> <span>1</span><span>,</span>\n  b<span>:</span> <span>2</span>\n<span>}</span>\n\n<span>const</span> output <span>=</span> <span>{</span>\n  <span>...</span>input<span>,</span>\n  c<span>:</span> <span>3</span>\n<span>}</span>\n\nconsole<span>.</span><span>log</span><span>(</span>output<span>)</span> <span>// {a: 1, b: 2, c: 3}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>（完）</p>\n",
      "date_published": "2022-02-07T11:41:07.000Z",
      "date_modified": "2022-02-07T11:41:07.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "String 扩展",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es8-string/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es8-string/",
      "content_html": "<h1 id=\"string-扩展\"> String 扩展</h1>\n<p>在 ES8 中 String 新增了两个实例函数 <code>String.prototype.padStart()</code> 和 <code>String.prototype.padEnd()</code>，允许将空字符串或其他字符串添加到原始字符串的开头或结尾。</p>\n<h2 id=\"string-prototype-padstart\"> String.prototype.padStart()</h2>\n<p>把指定字符串填充到字符串头部（如果需要的话则重复填充），返回新字符串。</p>\n<p><strong>语法</strong></p>\n<blockquote>\n<p>str.padStart(targetLength [, padString])</p>\n</blockquote>\n<p><strong>解释</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n<th>必选</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>targetLength</td>\n<td>目标字符要保持的长度值。如果小于当前字符串的长度，则返回当前字符串本身。</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>padString</td>\n<td>用于填充的字符串，默认为空。如果这个字符串太长，在达到目标长度后会被截断。</td>\n<td>N</td>\n</tr>\n</tbody>\n</table>\n<p><strong>示例</strong></p>\n<div><pre><code><span>const</span> str <span>=</span> <span>'hello'</span>\nconsole<span>.</span><span>log</span><span>(</span>str<span>.</span><span>padStart</span><span>(</span><span>8</span><span>,</span> <span>'.'</span><span>)</span><span>)</span>     <span>// ...hello</span>\nconsole<span>.</span><span>log</span><span>(</span>str<span>.</span><span>padStart</span><span>(</span><span>8</span><span>)</span><span>)</span>          <span>//    hello</span>\nconsole<span>.</span><span>log</span><span>(</span>str<span>.</span><span>padStart</span><span>(</span><span>8</span><span>,</span> <span>'world'</span><span>)</span><span>)</span> <span>// worhello</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>场景1：日期格式化</strong></p>\n<p>希望把当前日期格式化成：yyyy-mm-dd 的格式：</p>\n<div><pre><code><span>const</span> now <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span>\n<span>const</span> year <span>=</span> now<span>.</span><span>getFullYear</span><span>(</span><span>)</span>\n<span>const</span> month <span>=</span> <span>(</span>now<span>.</span><span>getMonth</span><span>(</span><span>)</span> <span>+</span> <span>1</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>.</span><span>padStart</span><span>(</span><span>2</span><span>,</span> <span>'0'</span><span>)</span>\n<span>const</span> day <span>=</span> <span>(</span>now<span>.</span><span>getDate</span><span>(</span><span>)</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>.</span><span>padStart</span><span>(</span><span>2</span><span>,</span> <span>'0'</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>year<span>,</span> month<span>,</span> day<span>)</span>\nconsole<span>.</span><span>log</span><span>(</span><span><span>`</span><span><span>${</span>year<span>}</span></span><span>-</span><span><span>${</span>month<span>}</span></span><span>-</span><span><span>${</span>day<span>}</span></span><span>`</span></span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>场景2：数字替换</strong></p>\n<div><pre><code><span>// 数字替换, 比如手机号、身份证号</span>\n<span>const</span> tel <span>=</span> <span>'13012345678'</span>\n<span>const</span> newTel <span>=</span> tel<span>.</span><span>slice</span><span>(</span><span>-</span><span>4</span><span>)</span><span>.</span><span>padStart</span><span>(</span>tel<span>.</span>length<span>,</span> <span>'*'</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>newTel<span>)</span> <span>// *******5678</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"string-prototype-padend\"> String.prototype.padEnd()</h2>\n<p>把指定字符串填充到字符串尾部（如果需要的话则重复填充），返回新字符串。</p>\n<p><strong>语法</strong></p>\n<blockquote>\n<p>str.padEnd(targetLength [, padString])</p>\n</blockquote>\n<p><strong>解释</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n<th>必选</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>targetLength</td>\n<td>目标字符要保持的长度值。如果小于当前字符串的长度，则返回当前字符串本身。</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>padString</td>\n<td>用于填充的字符串，默认为空。如果这个字符串太长，在达到目标长度后会被截断。</td>\n<td>N</td>\n</tr>\n</tbody>\n</table>\n<p><strong>示例</strong></p>\n<div><pre><code><span>const</span> str <span>=</span> <span>'hello'</span>\nconsole<span>.</span><span>log</span><span>(</span>str<span>.</span><span>padEnd</span><span>(</span><span>8</span><span>,</span> <span>'.'</span><span>)</span><span>)</span>       <span>// hello...</span>\nconsole<span>.</span><span>log</span><span>(</span>str<span>.</span><span>padEnd</span><span>(</span><span>8</span><span>)</span><span>)</span>            <span>// hello   (前面有三个空格)</span>\nconsole<span>.</span><span>log</span><span>(</span>str<span>.</span><span>padEnd</span><span>(</span><span>8</span><span>,</span> <span>'world'</span><span>)</span><span>)</span>   <span>// hellowor</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>场景：时间戳统一长度</strong></p>\n<p>在前端处理时间戳的时候单位都是 ms（毫秒），但是后端返回的时间戳则不一定是毫秒，可能只有 10 位（以 s 秒为单位）。所以在前端处理这个时间戳的时候，保险起见，要先做一个 13 位的补全，保证单位是毫秒。</p>\n<div><pre><code>console<span>.</span><span>log</span><span>(</span><span>new</span> <span>Date</span><span>(</span><span>)</span><span>.</span><span>getTime</span><span>(</span><span>)</span><span>)</span> <span>// 13 位的时间戳</span>\n<span>// 补全</span>\ntimestamp <span>=</span> <span>1643467755</span>\ntimestamp <span>=</span> <span>+</span><span>String</span><span>(</span>timestamp<span>)</span><span>.</span><span>padEnd</span><span>(</span><span>13</span><span>,</span> <span>'0'</span><span>)</span> <span>// 1643467755000</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/padStart\" target=\"_blank\" rel=\"noopener noreferrer\">String.prototype.padStart()</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/padEnd\" target=\"_blank\" rel=\"noopener noreferrer\">String.prototype.padEnd()</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-01-27T10:01:35.000Z",
      "date_modified": "2022-01-29T14:51:50.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "RegExp 扩展",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es9-regexp/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es9-regexp/",
      "content_html": "<h1 id=\"regexp-扩展\"> RegExp 扩展</h1>\n<h2 id=\"dotall-模式\"> dotAll 模式</h2>\n<p>正则表达式中，点（<code>.</code>）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用 <code>u</code> 修饰符解决；另一个是行终止符（line terminator character）。</p>\n<p>行终止符：</p>\n<ul>\n<li>U+000A 换行符（\\n）</li>\n<li>U+000D 回车符（\\r）</li>\n<li>U+2028 行分隔符（line separator）</li>\n<li>U+2029 段分隔符（paragraph separator）</li>\n</ul>\n<p>在 ES5 中，可以使用 <code>[\\d\\D]</code>、<code>[\\w\\W]</code>、<code>[\\s\\S]</code> 和 <code>[^]</code> 中任何的一个。</p>\n<div><pre><code>console<span>.</span><span>log</span><span>(</span><span><span>/</span><span>foo[\\d\\D]bar</span><span>/</span></span><span>.</span><span>test</span><span>(</span><span>'foo\\nbar'</span><span>)</span><span>)</span> <span>// true</span>\n<span>// or</span>\nconsole<span>.</span><span>log</span><span>(</span><span><span>/</span><span>foo[\\w\\W]bar</span><span>/</span></span><span>.</span><span>test</span><span>(</span><span>'foo\\nbar'</span><span>)</span><span>)</span> <span>// true</span>\n<span>// or</span>\nconsole<span>.</span><span>log</span><span>(</span><span><span>/</span><span>foo[\\s\\S]bar</span><span>/</span></span><span>.</span><span>test</span><span>(</span><span>'foo\\nbar'</span><span>)</span><span>)</span> <span>// true</span>\n<span>// or</span>\nconsole<span>.</span><span>log</span><span>(</span><span><span>/</span><span>foo[^]bar</span><span>/</span></span><span>.</span><span>test</span><span>(</span><span>'foo\\nbar'</span><span>)</span><span>)</span>    <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>但这种解决方案不太符合直觉，于是有了 dotAll 模式（即点 - dot 代表一切字符）。只需要在最后面加 <code>s</code>，点号（<code>.</code>）匹配就可以包含换行符了。</p>\n<div><pre><code>console<span>.</span><span>log</span><span>(</span><span><span>/</span><span>foo.bar</span><span>/</span></span><span>.</span><span>test</span><span>(</span><span>'foo\\nbar'</span><span>)</span><span>)</span>  <span>// false</span>\nconsole<span>.</span><span>log</span><span>(</span><span><span>/</span><span>foo.bar</span><span>/</span><span>s</span></span><span>.</span><span>test</span><span>(</span><span>'foo\\nbar'</span><span>)</span><span>)</span> <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>如何判断当前正则是否使用了 dotAll 模式呢？</p>\n<div><pre><code><span>const</span> re <span>=</span> <span><span>/</span><span>foo.bar</span><span>/</span><span>s</span></span>\nconsole<span>.</span><span>log</span><span>(</span>re<span>.</span><span>test</span><span>(</span><span>'foo\\nbar'</span><span>)</span><span>)</span> <span>// true</span>\nconsole<span>.</span><span>log</span><span>(</span>re<span>.</span>dotAll<span>)</span>           <span>// true</span>\nconsole<span>.</span><span>log</span><span>(</span>re<span>.</span>flags<span>)</span>            <span>// 's'</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"具名组匹配\"> 具名组匹配</h2>\n<p>我们在写正则表达式的时候，可以把一部分用<code>()</code>包裹起来，被包裹起来的这部分称作「分组捕获」。</p>\n<div><pre><code>console<span>.</span><span>log</span><span>(</span><span>'2022-02-02'</span><span>.</span><span>match</span><span>(</span><span><span>/</span><span>(\\d{4})-(\\d{2})-(\\d{2})</span><span>/</span></span><span>)</span><span>)</span>\n<span>// ['2022-02-02', '2022', '02', '02', index: 0, input: '2022-02-02', groups: undefined]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>这个正则匹配很简单，按照 match 的语法，没有使用 <code>g</code> 标识符，所以返回值第一个数值是正则表达式的完整匹配，接下来的第二个值到第四个值是分组匹配（2022, 02, 02）。</p>\n<p>此外 match 返回值还有几个属性，分别是：</p>\n<ul>\n<li>index：匹配到的结果的开始位置索引</li>\n<li>input：搜索的字符串</li>\n<li>groups：一个捕获组数组 或 <code>undefined</code>（如果没有定义命名捕获组）</li>\n</ul>\n<p>可以通过数组来获取这些捕获：</p>\n<div><pre><code><span>let</span> t <span>=</span> <span>'2022-02-07'</span><span>.</span><span>match</span><span>(</span><span><span>/</span><span>(\\d{4})-(\\d{2})-(\\d{2})</span><span>/</span></span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>t<span>[</span><span>1</span><span>]</span><span>)</span> <span>// 2022</span>\nconsole<span>.</span><span>log</span><span>(</span>t<span>[</span><span>2</span><span>]</span><span>)</span> <span>// 02</span>\nconsole<span>.</span><span>log</span><span>(</span>t<span>[</span><span>3</span><span>]</span><span>)</span> <span>// 07</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面的 <code>groups</code> 打印出来是 <code>undefined</code>，原因是没有定义命名捕获分组。如果定义命名捕获分组后，返回值 <code>groups</code> 就是 Object 了：</p>\n<div><pre><code>console<span>.</span><span>log</span><span>(</span><span>'2022-02-07'</span><span>.</span><span>match</span><span>(</span><span><span>/</span><span>(?&lt;year>\\d{4})-(?&lt;month>\\d{2})-(?&lt;day>\\d{2})</span><span>/</span></span><span>)</span><span>)</span>\n<span>// ['2022-02-07', '2022', '02', '07', index: 0, input: '2022-02-07', groups: {…}]</span>\n<span>// 其中 groups = {year: '2022', month: '02', day: '07'}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这个 Object 的 key 就是正则表达式中定义的，也就是把捕获分组进行了命名。想获取这些捕获可以这样做：</p>\n<div><pre><code><span>let</span> t <span>=</span> <span>'2022-02-07'</span><span>.</span><span>match</span><span>(</span><span><span>/</span><span>(?&lt;year>\\d{4})-(?&lt;month>\\d{2})-(?&lt;day>\\d{2})</span><span>/</span></span><span>)</span>\n<span>// ['2022-02-07', '2022', '02', '07', index: 0, input: '2022-02-07', groups: {…}]</span>\nconsole<span>.</span><span>log</span><span>(</span>t<span>.</span>groups<span>.</span>year<span>)</span>  <span>// 2022</span>\nconsole<span>.</span><span>log</span><span>(</span>t<span>.</span>groups<span>.</span>month<span>)</span> <span>// 02</span>\nconsole<span>.</span><span>log</span><span>(</span>t<span>.</span>groups<span>.</span>day<span>)</span>   <span>// 07</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"后行断言\"> 后行断言</h2>\n<p>在 ES9 之前 JavaScript 正则只支持先行断言，不支持后行断言。</p>\n<p><strong>所谓先行断言</strong>（语法：<code>(?=reg)</code>），就是匹配的某段或某个字符串，它后面必须跟随指定的字符串，通俗的说就是「知道后面拿前面」。</p>\n<p>例如下面这段代码，要匹配 <strong>空白符 + <code>world</code></strong> 前面的一个或多个字符：</p>\n<div><pre><code><span>let</span> test <span>=</span> <span>'hello world'</span>\nconsole<span>.</span><span>log</span><span>(</span>test<span>.</span><span>match</span><span>(</span><span><span>/</span><span>\\w+(?=\\sworld)</span><span>/</span></span><span>)</span><span>)</span>\n<span>// ['hello', index: 0, input: 'hello world', groups: undefined]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>ES9 支持的后行断言</strong>（语法：<code>(?&lt;=reg)</code>），是匹配的某段或某个字符串，它前面必须有指定字符串，通俗的说就是「知道前面拿后面」。</p>\n<p>例如下面这段代码，要匹配 <strong><code>hello</code> + 空白符</strong> 后面的一个或多个字符：</p>\n<div><pre><code><span>let</span> test <span>=</span> <span>'hello world'</span>\nconsole<span>.</span><span>log</span><span>(</span>test<span>.</span><span>match</span><span>(</span><span><span>/</span><span>(?&lt;=hello\\s)\\w+</span><span>/</span></span><span>)</span><span>)</span>\n<span>// ['world', index: 6, input: 'hello world', groups: undefined]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（完）</p>\n",
      "date_published": "2022-02-07T11:31:47.000Z",
      "date_modified": "2022-02-07T11:31:47.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "HTML",
      "url": "https://www.fedbook.cn/frontend-knowledge/html/",
      "id": "https://www.fedbook.cn/frontend-knowledge/html/",
      "content_html": "<h1 id=\"html\"> HTML</h1>\n<p>在 Web 前端页面中，</p>\n<ul>\n<li><strong>HTML 属于结构层，负责描绘出内容的结构</strong>；</li>\n<li>CSS 属于表现层，负责「如何显示有关内容」；</li>\n<li>JavaScript 属于行为层，负责「内容应如何对事件做出反应」。</li>\n</ul>\n<hr>\n<p>最近几年，提到 HTML 在广义上指的就是 HTML5。</p>\n<p>回顾一下 HTML 的版本历史：</p>\n<ul>\n<li><strong>HTML4/4.01（SGML）</strong>\n<ul>\n<li>HTML4 之前都是一脉相传，不进行过多的研究。HTML4 是基于 SGML 这种标记语言写的，它是 XML（可扩展标记语言）的超集。这个版本对编写规范的要求不高。</li>\n</ul>\n</li>\n<li><strong>XHTML（XML）</strong>\n<ul>\n<li>为了规范，基于 XML 衍生出了 XHTML，这个标准能够严格约束大家的编码习惯。但是在 XHTML2.0 后，由于它不向前兼容，并且要求更加严格，反而给开发者带来了困扰。</li>\n</ul>\n</li>\n<li><strong>HTML5</strong>\n<ul>\n<li>基于 HTML4（返璞归真），在理念上进行了转变，对编写规范的要求降低了，去掉了一部分很严格的规范。</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">HTML4</th>\n<th style=\"text-align:center\">XHTML</th>\n<th style=\"text-align:center\">HTML5</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">标签允许不结束</td>\n<td style=\"text-align:center\">标签必须结束</td>\n<td style=\"text-align:center\">标签允许不结束</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">属性不用带引号</td>\n<td style=\"text-align:center\">属性必须带引号</td>\n<td style=\"text-align:center\">属性不用带引号</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">标签属性可大写</td>\n<td style=\"text-align:center\">标签属性必须小写</td>\n<td style=\"text-align:center\">标签属性可大写</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Boolean属性可省略值</td>\n<td style=\"text-align:center\">Boolean属性必须写值</td>\n<td style=\"text-align:center\">Boolean属性可省略值</td>\n</tr>\n</tbody>\n</table>\n<br>\n<p>现在 HTML5 已经成为一个正式的推荐标准，在工业生产中大家都在使用这个标准，所以研究 HTML5 之前的标准意义不是太大。且 HTML5 的发展也是基于前面的 HTML4 以及 XHTML 而来的，因此除非必要，否则这个系列不会特意去区分 HTML5 的新特性。在梳理知识点的时候直接涵盖了 HTML5、HTML4 的内容。</p>\n<hr>\n<p>关于 HTML 的知识点，主要参考：</p>\n<ul>\n<li><strong>W3school</strong> 的 HTML/CSS 部分</li>\n<li><strong>MDN</strong> 中关于 HTML 的内容</li>\n</ul>\n<div style=\"text-align: right\">\n  <svg t=\"1594540244644\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"837\" width=\"64\" height=\"64\"><path d=\"M89.088 59.392l62.464 803.84c1.024 12.288 9.216 22.528 20.48 25.6L502.784 993.28c6.144 2.048 12.288 2.048 18.432 0l330.752-104.448c11.264-4.096 19.456-14.336 20.48-25.6l62.464-803.84c1.024-17.408-12.288-31.744-29.696-31.744H118.784c-17.408 0-31.744 14.336-29.696 31.744z\" fill=\"#FC490B\" p-id=\"838\"></path><path d=\"M774.144 309.248h-409.6l12.288 113.664h388.096l-25.6 325.632-227.328 71.68-227.328-71.68-13.312-169.984h118.784v82.944l124.928 33.792 123.904-33.792 10.24-132.096H267.264L241.664 204.8h540.672z\" fill=\"#FFFFFF\" p-id=\"839\"></path></svg>\n</div>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T08:41:15.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "for await of",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es9-for-await-of/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es9-for-await-of/",
      "content_html": "<h1 id=\"for-await-of\"> for await of</h1>\n<p>异步迭代器（for-await-of）：循环等待每个 Promise 对象变为 <code>resolved</code> 状态才进入下一步。</p>\n<p>我们知道 for...of 是同步运行的，但有时候一些任务集合是异步的，那这种遍历的输出顺序就不一定了。</p>\n<div><pre><code><span>function</span> <span>Gen</span><span>(</span><span>time</span><span>)</span> <span>{</span>\n  <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>function</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>{</span>\n    <span>setTimeout</span><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>\n      <span>resolve</span><span>(</span>time<span>)</span>\n    <span>}</span><span>,</span> time<span>)</span>\n  <span>}</span><span>)</span>\n<span>}</span>\n\n<span>async</span> <span>function</span> <span>test</span><span>(</span><span>)</span> <span>{</span>\n  <span>let</span> arr <span>=</span> <span>[</span><span>Gen</span><span>(</span><span>2000</span><span>)</span><span>,</span> <span>Gen</span><span>(</span><span>100</span><span>)</span><span>,</span> <span>Gen</span><span>(</span><span>3000</span><span>)</span><span>]</span>\n  <span>for</span> <span>(</span><span>let</span> item <span>of</span> arr<span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span>Date<span>.</span><span>now</span><span>(</span><span>)</span><span>,</span> item<span>.</span><span>then</span><span>(</span>console<span>.</span>log<span>)</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>test</span><span>(</span><span>)</span>\n<span>// 1643787864547 Promise {&lt;pending>}</span>\n<span>// 1643787864547 Promise {&lt;pending>}</span>\n<span>// 1643787864547 Promise {&lt;pending>}</span>\n<span>// 100</span>\n<span>// 2000</span>\n<span>// 3000</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>这里写了几个小任务，分别是 2000ms 、100ms、3000ms 后任务结束。在上述遍历的过程中可以看到三个任务是同步启动的，但是输出上并不是按任务的执行顺序输出的，这显然不太符合我们的要求。</p>\n<p>可以通过 <code>await</code> 来中断程序的执行，直到这个 Promise 对象的状态发生改变，这样代码的打印的结果就是期望的那样了（按照任务的先后顺序）：</p>\n<div><div><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br></div><pre><code><span>function</span> <span>Gen</span><span>(</span><span>time</span><span>)</span> <span>{</span>\n  <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>function</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>{</span>\n    <span>setTimeout</span><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>\n      <span>resolve</span><span>(</span>time<span>)</span>\n    <span>}</span><span>,</span> time<span>)</span>\n  <span>}</span><span>)</span>\n<span>}</span>\n\n<span>async</span> <span>function</span> <span>test</span><span>(</span><span>)</span> <span>{</span>\n  <span>let</span> arr <span>=</span> <span>[</span><span>Gen</span><span>(</span><span>2000</span><span>)</span><span>,</span> <span>Gen</span><span>(</span><span>100</span><span>)</span><span>,</span> <span>Gen</span><span>(</span><span>3000</span><span>)</span><span>]</span>\n  <span>for</span> <span>(</span><span>let</span> item <span>of</span> arr<span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span>Date<span>.</span><span>now</span><span>(</span><span>)</span><span>,</span> <span>await</span> item<span>.</span><span>then</span><span>(</span>console<span>.</span>log<span>)</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>test</span><span>(</span><span>)</span>\n<span>// 2000</span>\n<span>// 1643787906179 undefined</span>\n<span>// 100</span>\n<span>// 1643787908189 undefined</span>\n<span>// 3000</span>\n<span>// 1643787908190 undefined</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>上面这种方式的原理是利用了 <code>await</code> 中断程序的功能，在 ES9 中也可以用 for...await...of 的语法来操作：</p>\n<div><div><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br></div><pre><code><span>function</span> <span>Gen</span><span>(</span><span>time</span><span>)</span> <span>{</span>\n  <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>function</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>{</span>\n    <span>setTimeout</span><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>\n      <span>resolve</span><span>(</span>time<span>)</span>\n    <span>}</span><span>,</span> time<span>)</span>\n  <span>}</span><span>)</span>\n<span>}</span>\n\n<span>async</span> <span>function</span> <span>test</span><span>(</span><span>)</span> <span>{</span>\n  <span>let</span> arr <span>=</span> <span>[</span><span>Gen</span><span>(</span><span>2000</span><span>)</span><span>,</span> <span>Gen</span><span>(</span><span>100</span><span>)</span><span>,</span> <span>Gen</span><span>(</span><span>3000</span><span>)</span><span>]</span>\n  <span>for</span> <span>await</span> <span>(</span><span>let</span> item <span>of</span> arr<span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span>Date<span>.</span><span>now</span><span>(</span><span>)</span><span>,</span> item<span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>test</span><span>(</span><span>)</span>\n<span>// 1643788502772 2000</span>\n<span>// 1643788502772 100</span>\n<span>// 1643788503775 3000</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>这种写法和第二种写法的效果差不多，但是原理却完全不同：</p>\n<ul>\n<li>第二种写法是代码块中有 <code>await</code> 导致等待 Promise 的状态而不再继续执行。</li>\n<li>第三种写法是整个代码块都不执行，等待 <code>arr</code> 当前的值（Promise 状态）发生变化之后，才执行代码块的内容。</li>\n</ul>\n<p>更多的知识点参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for-await...of\" target=\"_blank\" rel=\"noopener noreferrer\">for await...of</a>。</p>\n<div><p>提示</p>\n<p>上面代码中用到了一个语法糖 <code>item.then(console.log)</code>，<br>\n它等价于 <code>item.then(value =&gt; console.log(value))</code>。（<a href=\"https://stackoverflow.com/questions/50836242/how-does-thenconsole-log-and-then-console-log-in-a-promise-chain\" target=\"_blank\" rel=\"noopener noreferrer\">参考这里</a>）</p>\n</div>\n<p>（完）</p>\n",
      "date_published": "2022-02-01T13:09:14.000Z",
      "date_modified": "2022-02-02T08:41:17.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Promise.prototype.finally()",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es9-promise/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/es9-promise/",
      "content_html": "<h1 id=\"promise-prototype-finally\"> Promise.prototype.finally()</h1>\n<p>指定不管最后状态如何都会执行的回调函数。</p>\n<p>Promise.prototype.finally() 方法返回一个 Promise，在 promise 执行结束时，无论结果是 fulfilled 或者是 rejected，在执行 <code>then()</code> 和 <code>catch()</code> 后，都会执行 <code>finally()</code> 指定的回调函数。</p>\n<p>这为指定执行完 promise 后，无论结果是 fulfilled 还是 rejected 都需要执行的代码提供了一种方式，避免同样的语句需要在 <code>then()</code> 和 <code>catch ()</code> 中各写一次的情况。</p>\n<p><strong>基本语法</strong></p>\n<blockquote>\n<p>p.finally(onFinally)</p>\n</blockquote>\n<p><strong>示例</strong></p>\n<div><pre><code><span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n    <span>resolve</span><span>(</span><span>'success'</span><span>)</span>\n    <span>// reject('fail')</span>\n  <span>}</span><span>,</span> <span>1000</span><span>)</span>\n<span>}</span><span>)</span><span>.</span><span>then</span><span>(</span><span>res</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>res<span>)</span>\n<span>}</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>err</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>err<span>)</span>\n<span>}</span><span>)</span><span>.</span><span>finally</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'finally'</span><span>)</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id=\"场景-1-loading-关闭\"> 场景 1：loading 关闭</h2>\n<p>一般的界面设计中，每次发送请求都会有 loading 提示，请求发送完毕，就需要关闭 loading 提示框，不然界面就无法被点击。因为不管请求成功或是失败，这个 loading 都需要关闭掉，这时把关闭 loading 的代码写在 finally 里再合适不过了。</p>\n<h2 id=\"场景-2-数据库断开链接\"> 场景 2：数据库断开链接</h2>\n<div><pre><code><span>let</span> connection\ndb<span>.</span><span>open</span><span>(</span><span>)</span>\n  <span>.</span><span>then</span><span>(</span><span>conn</span> <span>=></span> <span>{</span>\n    connection <span>=</span> conn\n    <span>return</span> connection<span>.</span><span>select</span><span>(</span><span>{</span>\n      name<span>:</span> <span>'zhangsan'</span>\n    <span>}</span><span>)</span>\n  <span>}</span><span>)</span>\n  <span>.</span><span>then</span><span>(</span><span>result</span> <span>=></span> <span>{</span>\n    <span>// Process result</span>\n    <span>// Use `connection` to make more queries</span>\n  <span>}</span><span>)</span>···\n  <span>.</span><span>catch</span><span>(</span><span>error</span> <span>=></span> <span>{</span>\n    <span>// handle errors</span>\n  <span>}</span><span>)</span>\n  <span>.</span><span>finally</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n    connection<span>.</span><span>close</span><span>(</span><span>)</span>\n  <span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally\" target=\"_blank\" rel=\"noopener noreferrer\">Promise.prototype.finally()</a></li>\n<li><a href=\"https://2ality.com/2017/07/promise-prototype-finally.html\" target=\"_blank\" rel=\"noopener noreferrer\">Promise.prototype.finally()</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-02-07T11:51:55.000Z",
      "date_modified": "2022-02-07T11:51:55.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "空值合并运算符",
      "url": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/nullish/",
      "id": "https://www.fedbook.cn/frontend-knowledge/es6-and-beyond/nullish/",
      "content_html": "<h1 id=\"空值合并运算符\"> 空值合并运算符</h1>\n<p>空值合并运算符（<code>??</code>）是一个逻辑运算符。当左侧操作数为 <code>null</code> 或 <code>undefined</code> 时，其返回右侧的操作数。否则返回左侧的操作数。</p>\n<p>当我们查询某个属性时，经常会遇到，如果没有该属性就会设置一个默认的值。</p>\n<div><pre><code><span>const</span> b <span>=</span> <span>0</span> <span>// 或者 null undefined false</span>\n<span>const</span> a <span>=</span> b <span>||</span> <span>5</span>\nconsole<span>.</span><span>log</span><span>(</span>a<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>空值合并运算符 <code>??</code> 我们仅在第一项为 <code>null</code> 或 <code>undefined</code> 时设置默认值。</p>\n<div><pre><code><span>// false 0  无效</span>\n<span>const</span> a <span>=</span> b <span>??</span> <span>123</span>\nconsole<span>.</span><span>log</span><span>(</span>a<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator\" target=\"_blank\" rel=\"noopener noreferrer\">空值合并运算符</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-02-26T02:31:07.000Z",
      "date_modified": "2022-02-26T02:31:07.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "JavaScript 手写函数",
      "url": "https://www.fedbook.cn/frontend-knowledge/javascript-handwritten/",
      "id": "https://www.fedbook.cn/frontend-knowledge/javascript-handwritten/",
      "content_html": "<h1 id=\"javascript-手写函数\"> JavaScript 手写函数</h1>\n<p>现如今这个时代，已经有很多现成的库了，为什么还要手写？当然这并不是必须的，在实际的开发过程中，我也会去优先选择一些优秀的库，并不会到处造轮子，因为那会增加维护的成本。</p>\n<p>对于手写代码，谈一点自己的思考。很多时候大家会谈论「CURD 工程师 / API 工程师」。没错，通过这些操作确实能够应付大部分业务开发了（好吧~我们面对的很多问题都达不到科研的层面）。但如果能在工作中多一些思考，对一些自己经常使用的东西多一些学习和思考，一方面能加深自己的理解，例如 Promise 的 resolve 函数不执行会发生什么？另一方面了解其背后实现，也可以反思是否有待优化的空间，优秀的项目不都是不断的总结、迭代优化的吗？</p>\n<p>所谓的「手撕代码」并非最终目的，在写代码时，变量名定义、函数或接口设计、代码可读性和细节处理这些点也可体现出一名开发者的代码水平和习惯。在平常的工作中要养成一个良好的习惯，不要只是为了面试而面试。</p>\n<div style=\"text-align: right\">\n  <svg t=\"1595948360275\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"11728\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"64\" height=\"64\"><defs><style type=\"text/css\"></style></defs><path d=\"M238.592 155.648H399.36v450.56C399.36 809.984 302.08 880.64 146.432 880.64c-37.888 0-87.04-6.144-118.784-17.408l18.432-130.048c22.528 7.168 51.2 12.288 82.944 12.288 67.584 0 110.592-30.72 110.592-141.312V155.648h-1.024z m301.056 547.84c41.984 22.528 110.592 44.032 179.2 44.032 73.728 0 113.664-30.72 113.664-78.848 0-43.008-33.792-69.632-119.808-99.328-118.784-40.96-197.632-107.52-197.632-211.968C515.072 235.52 617.472 143.36 785.408 143.36c81.92 0 139.264 16.384 182.272 35.84L931.84 308.224c-27.648-13.312-79.872-33.792-148.48-33.792-69.632 0-103.424 32.768-103.424 68.608 0 45.056 38.912 65.536 132.096 101.376 125.952 46.08 184.32 112.64 184.32 214.016 0 119.808-91.136 221.184-286.72 221.184-81.92 0-161.792-22.528-201.728-44.032l31.744-132.096z\" fill=\"#F4DE51\" p-id=\"11729\"></path></svg>\n</div>\n",
      "date_published": "2022-01-20T14:50:03.000Z",
      "date_modified": "2022-03-05T15:00:41.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "语义类标签",
      "url": "https://www.fedbook.cn/frontend-knowledge/html/semantic-elements/",
      "id": "https://www.fedbook.cn/frontend-knowledge/html/semantic-elements/",
      "content_html": "<h1 id=\"语义类标签\"> 语义类标签</h1>\n<h2 id=\"语义类标签的利弊\"> 语义类标签的利弊</h2>\n<ul>\n<li>优势\n<ul>\n<li>增强了可读性，易修改，易维护。</li>\n<li>无障碍阅读（机器阅读）支持。</li>\n<li>更适合搜索引擎检索（SEO）等等。</li>\n</ul>\n</li>\n<li>缺点\n<ul>\n<li>不恰当地使用语义标签，反而会造成负面作用。（例如给所有并列关系都用 <code>ul</code>，会造成大量冗余标签）</li>\n</ul>\n</li>\n</ul>\n<p><strong>原则：用对比不用好，不用比用错好。</strong></p>\n<h2 id=\"几种比较重要的语义标签\"> 几种比较重要的语义标签</h2>\n<h3 id=\"用于消除歧义的标签-em\"> 用于消除歧义的标签（em）</h3>\n<p>有时候，HTML 的有些标签实际上就是必要的，甚至必要的程度可以达到：如果没有这个标签，文字会产生歧义的程度。</p>\n<p>例如<code>今天我吃了一个苹果。</code>，当把这句话放到不同上下文中，可能表达的意思完全不一样。</p>\n<blockquote>\n<p>昨天我吃了一个香蕉。\n今天我吃了一个苹果。\n<br>\n昨天我吃了两个苹果。\n今天我吃了一个苹果。</p>\n</blockquote>\n<p>当没有上下文时，如何消除歧义呢？这就要用到 em 标签了。em 表示重音：</p>\n<div><pre><code>今天我吃了一个<span><span><span>&lt;</span>em</span><span>></span></span>苹果<span><span><span>&lt;/</span>em</span><span>></span></span>。\n今天我吃了<span><span><span>&lt;</span>em</span><span>></span></span>一个<span><span><span>&lt;/</span>em</span><span>></span></span>苹果。\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"用于强调重要内容的标签-strong\"> 用于强调重要内容的标签（strong）</h3>\n<p>网上一些文章常常会拿 em 和 strong 做对比，实际上，我们只要理解了 em 的真正意思，它和 strong 可谓天差地别，并没有任何混淆的可能。</p>\n<p>从上下文来看，如果我们觉得某个词很重要，那就可以使用 strong 标签。</p>\n<p>从样式上，strong 标签表现为加粗样式；em 表现为倾斜样式。</p>\n<h3 id=\"作为整体结构的语义类标签\"> 作为整体结构的语义类标签</h3>\n<ul>\n<li><strong>h1-h6</strong>：最基本的标题，它们表示了文章中不同层级的标题。</li>\n<li><strong>header</strong>：如其名，通常出现在前部，表示导航或者介绍性的内容。</li>\n<li><strong>footer</strong>：通常出现在尾部，包含一些作者信息、相关链接、版权信息等。</li>\n<li><strong>aside</strong>：表示跟文章主体不那么相关的部分，它可能包含导航、广告等工具性质的内容。</li>\n<li><strong>main</strong>： 整个页面只出现一个，表示页面的主要内容，可以理解为特殊的 div。</li>\n<li><strong>article</strong>：一种特别的结构，它表示具有一定独立性质的文章。所以，article 和 body 具有相似的结构。同时，一个 HTML 页面中，可能有多个 article 存在。</li>\n<li><strong>section</strong>：一个“有语义的 div”，它会改变 h1-h6 的语义，使得其中的 h1-h6 下降一级。</li>\n</ul>\n<p>正确使用整体结构类的语义标签，可以让页面对机器更友好。比如一个典型的新闻专题页面，它的 body 类似这样：</p>\n<div><pre><code><span><span><span>&lt;</span>body</span><span>></span></span>\n  <span>&lt;!-- 顶部导航 --></span>\n  <span><span><span>&lt;</span>header</span><span>></span></span>\n    <span><span><span>&lt;</span>nav</span><span>></span></span>……<span><span><span>&lt;/</span>nav</span><span>></span></span>\n  <span><span><span>&lt;/</span>header</span><span>></span></span>\n  <span>&lt;!-- 侧边栏 --></span>\n  <span><span><span>&lt;</span>aside</span><span>></span></span>\n    <span><span><span>&lt;</span>nav</span><span>></span></span>……<span><span><span>&lt;/</span>nav</span><span>></span></span>\n  <span><span><span>&lt;/</span>aside</span><span>></span></span>\n  <span>&lt;!-- 新闻区 1 --></span>\n  <span><span><span>&lt;</span>article</span><span>></span></span>\n    <span><span><span>&lt;</span>header</span><span>></span></span>……<span><span><span>&lt;/</span>header</span><span>></span></span>\n    <span><span><span>&lt;</span>section</span><span>></span></span>……<span><span><span>&lt;/</span>section</span><span>></span></span>\n    <span><span><span>&lt;</span>section</span><span>></span></span>……<span><span><span>&lt;/</span>section</span><span>></span></span>\n    <span><span><span>&lt;</span>section</span><span>></span></span>……<span><span><span>&lt;/</span>section</span><span>></span></span>\n    <span><span><span>&lt;</span>footer</span><span>></span></span>……<span><span><span>&lt;/</span>footer</span><span>></span></span>\n  <span><span><span>&lt;/</span>article</span><span>></span></span>\n  <span>&lt;!-- 新闻区 2 --></span>\n  <span><span><span>&lt;</span>article</span><span>></span></span>……<span><span><span>&lt;/</span>article</span><span>></span></span>\n  <span>&lt;!-- 新闻区 3 --></span>\n  <span><span><span>&lt;</span>article</span><span>></span></span>……<span><span><span>&lt;/</span>article</span><span>></span></span>\n  <span>&lt;!-- 尾部信息 --></span>\n  <span><span><span>&lt;</span>footer</span><span>></span></span>\n    <span><span><span>&lt;</span>address</span><span>></span></span>……<span><span><span>&lt;/</span>address</span><span>></span></span>\n  <span><span><span>&lt;/</span>footer</span><span>></span></span>\n<span><span><span>&lt;/</span>body</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p><strong>一些实践中的经验：</strong></p>\n<ul>\n<li>header 和 footer 一般都是放在 article 或者 body 的直接子元素，但是标准中并没有明确规定。</li>\n<li>aside 很容易被理解为侧边栏，实际上二者是包含关系，侧边栏是 aside，aside 不一定是侧边栏。</li>\n<li>aside 和 header 中都可能出现导航（nav 标签），二者的区别是，header 中的导航多数是到文章自己的目录，而 aside 中的导航多数是到关联页面或者是整站地图。</li>\n<li>footer 中包含 address，这是个非常容易被误用的标签。address 并非像 date 一样，表示一个给机器阅读的地址，而是表示“文章（作者）的联系方式”，address 明确地只关联到 article 和 body。</li>\n</ul>\n<h3 id=\"其它一些语义标签\"> 其它一些语义标签</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">标签</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">hr</td>\n<td style=\"text-align:left\">表示故事走向的转变或者话题的转变。如果不是出于语义目的，那么显示一条横线更好的方式是通过 CSS 设置 border 来实现。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">small</td>\n<td style=\"text-align:left\">之前表示字体缩小的废弃标签，HTML5 救回来表示补充评论。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">s</td>\n<td style=\"text-align:left\">之前表示划线的废弃标签，HTML5 救回来表示错误的内容，经常用于电商领域表示打着前的价格。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">i</td>\n<td style=\"text-align:left\">之前表示斜体的废弃标签，HTML5 救回来表示读的时候变调。表现样式与 em 相同，但是一种无意义的斜体，该元素只在没有更适合的语义元素表示时使用。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">b</td>\n<td style=\"text-align:left\">之前表示黑体的废弃标签，HTML5 救回来表示关键字。如果不是出于语义目的，那么显示粗体更好的方式是通过 CSS 将 font-weight 属性设置为 &quot;bold&quot;。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">u</td>\n<td style=\"text-align:left\">之前表示下划线的废弃标签，HTML5 救回来表示避免歧义的注记。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">data</td>\n<td style=\"text-align:left\">与 time 标签类似，给机器阅读的内容，意义广泛，可以自由定义。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">var</td>\n<td style=\"text-align:left\">变量，多用于计算机和数学领域。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">kbd</td>\n<td style=\"text-align:left\">用户输入，表示键盘按键居多。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sub</td>\n<td style=\"text-align:left\">下标，多用于化学/物理/数学领域。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sup</td>\n<td style=\"text-align:left\">上标，多用于化学/物理/数学领域。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">bdi, bdo</td>\n<td style=\"text-align:left\">用于多语言混合时指定语言或者书写方向（左到右或者右到左）。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">mark</td>\n<td style=\"text-align:left\">表示高亮，这里并非指显示为高亮，而是从读者角度希望的高亮（注意与 strong 的区分）。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">wbr</td>\n<td style=\"text-align:left\">表示可以换行的位置，主要是英文等文字不允许单词中间换行，这个标签一般在把多个单词粘成很长的单词时候用。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">menu</td>\n<td style=\"text-align:left\">ul 的变体，用于功能菜单时使用。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">dl, dd, dt</td>\n<td style=\"text-align:left\">一般出现较为严肃的文章，对一些术语进行定义，dt 和 dd 其实并不总是成对出现，两者是多对多的关系。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">abbr</td>\n<td style=\"text-align:left\">表示缩写，比如 WWW 是 World Wide Web 的缩写，那就可以用：<br> <code>&lt;abbr title=&quot;World Wide Web&quot;&gt;WWW&lt;/abbr&gt;</code>。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"更多资源\"> 更多资源</h2>\n<p>要想系统学习语义标签，可以看下 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element\" title=\"MDN 的 HTML 元素参考\" target=\"_blank\" rel=\"noopener noreferrer\">MDN 的 HTML 元素参考</a>，它里面会有标准的定义，告诉我们<strong>每种标签适用的场景</strong>。</p>\n<p>如果是简单了解标签的写法，可以看下 <a href=\"https://www.w3school.com.cn/tags/tag_comment.asp\" title=\"W3school HTML标签\" target=\"_blank\" rel=\"noopener noreferrer\">W3school HTML标签</a>。</p>\n<p>（完）</p>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T07:36:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "未完待续",
      "url": "https://www.fedbook.cn/frontend-knowledge/javascript-handwritten/to-be-continued/",
      "id": "https://www.fedbook.cn/frontend-knowledge/javascript-handwritten/to-be-continued/",
      "content_html": "<h1 id=\"未完待续\"> 未完待续</h1>\n<h2 id=\"知识点正在火速整理中\"> 知识点正在火速整理中</h2>\n",
      "date_published": "2022-01-20T14:50:03.000Z",
      "date_modified": "2022-01-20T14:50:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "实现 call 方法",
      "url": "https://www.fedbook.cn/frontend-knowledge/javascript-handwritten/%E5%AE%9E%E7%8E%B0call%E6%96%B9%E6%B3%95/",
      "id": "https://www.fedbook.cn/frontend-knowledge/javascript-handwritten/%E5%AE%9E%E7%8E%B0call%E6%96%B9%E6%B3%95/",
      "content_html": "<h1 id=\"实现-call-方法\"> 实现 call 方法</h1>\n<h2 id=\"功能描述\"> 功能描述</h2>\n<p><code>call()</code> 方法使用一个指定的 <code>this</code> 值和单独给出的一个或多个参数来调用一个函数。</p>\n<p>基本用法如下：</p>\n<div><pre><code><span>// call()</span>\n<span>// obj: 这个对象将代替 func 里 this 对象</span>\n<span>// param1 ~ paramN: 这是一个参数列表</span>\n<span>func</span><span>.</span><span>call</span><span>(</span>obj<span>,</span> param1<span>,</span> …<span>,</span> paramN<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"实现思路\"> 实现思路</h2>\n<ul>\n<li>如果不传入 context 参数，默认指向为 window</li>\n<li>将函数设为对象的属性</li>\n<li>指定函数中的 this 为对象，并传入给定实参，执行函数</li>\n<li>删除对象中我们添加的属性</li>\n</ul>\n<h2 id=\"手写实现\"> 手写实现</h2>\n<div><pre><code><span>/**\n * context: 函数中的 this 将改变为指向这个参数\n * args：传递给函数的实参信息\n * this：在未改变指向时，指向要处理的函数 func\n */</span>\n<span>Function</span><span>.</span>prototype<span>.</span><span>myCall</span>  <span>=</span> <span>function</span><span>(</span><span>context<span>,</span> <span>...</span>args</span><span>)</span> <span>{</span>\n  <span>// null、undefined 和不传时，context为 window（注意是双等号不是三等号）</span>\n  context <span>=</span> context <span>==</span> <span>null</span> <span>?</span> window <span>:</span> context<span>;</span>\n  \n  <span>// 必须保证 context 是一个对象类型</span>\n  <span>let</span> contextType <span>=</span> <span>typeof</span> context<span>;</span>\n  <span>if</span> <span>(</span><span>!</span><span><span>/</span><span>^(object|function)$</span><span>/</span><span>i</span></span><span>.</span><span>test</span><span>(</span>contextType<span>)</span><span>)</span> <span>{</span>\n   context <span>=</span> <span>Object</span><span>(</span>context<span>)</span><span>;</span>\n <span>}</span>\n  \n  <span>let</span> result<span>;</span>\n  <span>let</span> key <span>=</span> <span>Symbol</span><span>(</span><span>'key'</span><span>)</span> <span>// 成员名唯一，防止修改原始对象的值</span>\n  context<span>[</span>key<span>]</span> <span>=</span> <span>this</span><span>;</span> <span>// 把函数作为对象的某个成员值（这里的这个 this 是待处理函数 func）</span>\n  result <span>=</span> context<span>[</span>key<span>]</span><span>(</span><span>...</span>args<span>)</span><span>;</span> <span>// 此时的函数是对象中的属性，基于对象[成员]的方式执行函数，函数中的 this 指向就是对象</span>\n  <span>delete</span> context<span>[</span>key<span>]</span><span>;</span> <span>// 设置的成员属性用完后要删除掉</span>\n  <span>return</span> result<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h2 id=\"测试用例\"> 测试用例</h2>\n<div><pre><code><span>// 目标：调用方法时打印出 \"张三\"</span>\nwindow<span>.</span>name <span>=</span> <span>'window'</span><span>;</span>\n<span>let</span> obj <span>=</span> <span>{</span> name<span>:</span> <span>'张三'</span> <span>}</span><span>;</span>\n<span>let</span> <span>func</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>name<span>)</span><span>;</span>\n<span>}</span>\n\n<span>// 对比两个输出结果</span>\n<span>func</span><span>.</span><span>call</span><span>(</span>obj<span>)</span><span>;</span>\nfunc<span>.</span><span>myCall</span><span>(</span>obj<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>（完）</p>\n",
      "date_published": "2022-01-20T14:50:03.000Z",
      "date_modified": "2022-01-20T14:50:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "实现符合 Promises/A+ 规范的 Promise",
      "url": "https://www.fedbook.cn/frontend-knowledge/javascript-handwritten/my-promise/",
      "id": "https://www.fedbook.cn/frontend-knowledge/javascript-handwritten/my-promise/",
      "content_html": "<h1 id=\"实现符合-promises-a-规范的-promise\"> 实现符合 Promises/A+ 规范的 Promise</h1>\n<h2 id=\"promises-a-规范\"> Promises/A+ 规范</h2>\n<p>在手写实现前，肯定要先阅读 Promises/A+ 规范的原文：<a href=\"https://promisesaplus.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Promises/A+</a>。</p>\n<p>原文是英文版的，但是没有很多专业术语，所以如果有一些 Promise 的使用基础，阅读起来不会很困难。</p>\n<p>这里对 Promises/A+ 规范做一个简单的翻译（非 1:1 翻译，开头引言去掉了，中间有些地方没有直译，为了理解起来不绕采用了意译），因为接下来手写实现时要以规范作为目标，并且变量名也要和规范中用到的保持一致。详细的规范还是建议看一下原文。</p>\n<h3 id=\"_1-术语\"> 1. 术语</h3>\n<p>1.1. &quot;promise&quot; 是一个对象或者函数，并且拥有符合本规范的 <code>then</code> 方法。<br>\n1.2. &quot;thenable&quot; 是定义 <code>then</code> 方法的对象或者函数。<br>\n1.3. &quot;value&quot; 是任意合法的 JavaScript 值（包括 <code>undefined</code>，thenable，promise）。<br>\n1.4. &quot;exception&quot; 是使用 <code>throw</code> 语句抛出的值。<br>\n1.5. &quot;reason&quot; 表示一个 promise 被拒绝的原因。</p>\n<h3 id=\"_2-要求\"> 2. 要求</h3>\n<h4 id=\"_2-1-promise-状态-states\"> 2.1. Promise 状态（states）</h4>\n<blockquote>\n<p>译者注：下面假定 promise 为 Promise 构造函数的实例。</p>\n</blockquote>\n<p>一个 promise 的状态必须为这三种状态之一：等待中（pending），完成了（fulfilled），拒绝了（rejected）</p>\n<ul>\n<li>2.1.1. 当一个 promise 是 pending 状态时：\n<ul>\n<li>2.1.1.1. 可以改变为 fulfilled 状态或者 rejected 状态。</li>\n</ul>\n</li>\n<li>2.1.2. 当一个 promise 是 fulfilled 状态时：\n<ul>\n<li>2.1.2.1. 不能改变到其他状态。</li>\n<li>2.1.2.2. 必须有一个 value，并且不能改变。</li>\n</ul>\n</li>\n<li>2.1.3. 当一个 promise 是 rejected 状态：\n<ul>\n<li>2.1.3.1. 不能改变到其他状态。</li>\n<li>2.1.3.2. 必须有一个 reason，并且不能改变。</li>\n</ul>\n</li>\n</ul>\n<p>这里的不可变只是意味着恒等（即可用 <code>===</code> 判断相等），而不是深层次的不可变。（比如 value 或者 reason 是一个对象时，只要求引用地址相等，其属性值可以被更改）</p>\n<h4 id=\"_2-2-then-方法\"> 2.2. then 方法</h4>\n<p>一个 promise 必须提供一个 <code>then</code> 方法来接收它当前的完成值（value）或拒绝原因（reason）。</p>\n<p>每一个 promise 的 <code>then</code> 方法接收两个参数：</p>\n<div><pre><code>promise<span>.</span><span>then</span><span>(</span>onFulfilled<span>,</span> onRejected<span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li>2.2.1. <code>onFulfilled</code> 和 <code>onRejected</code> 都是可选参数：\n<ul>\n<li>2.2.1.1. 如果 <code>onFulfilled</code> 不是函数，会被忽略。</li>\n<li>2.2.1.2. 如果 <code>onRejected</code> 不是函数，会被忽略。</li>\n</ul>\n</li>\n<li>2.2.2. 如果 <code>onFulfilled</code> 是一个函数：\n<ul>\n<li>2.2.2.1. 该函数必须在 promise 过渡到 fulfilled 状态后调用，其第一个参数为 promise 的 value。</li>\n<li>2.2.2.2. 该函数不能在过渡到 fulfilled 状态之前调用。</li>\n<li>2.2.2.3. 该函数只能被调用一次。</li>\n</ul>\n</li>\n<li>2.2.3. 如果 <code>onRejected</code> 是一个函数：\n<ul>\n<li>2.2.3.1. 该函数必须在 promise 过渡到 rejected 状态后调用，其第一个参数为 promise 的 reason。</li>\n<li>2.2.3.2. 该函数不能在过渡到 rejected 状态之前调用。</li>\n<li>2.2.3.3. 该函数只能被调用一次。</li>\n</ul>\n</li>\n<li>2.2.4. <code>onFulfilled</code> 和 <code>onRejected</code> 只有在执行上下文栈仅包含平台代码时才可以被调用。（平台代码：<a href=\"https://promisesaplus.com/#point-67\" target=\"_blank\" rel=\"noopener noreferrer\">注释 3.1</a>）</li>\n<li>2.2.5. <code>onFulfilled</code> 和 <code>onRejected</code> 只能<a href=\"/frontend-knowledge/javascript/function-invocation/#作为函数调用\">以函数的形式被调用</a>（严格模式中 <code>this</code> 值为 <code>undefined</code>，非严格模式中为全局对象，<a href=\"https://promisesaplus.com/#point-69\" target=\"_blank\" rel=\"noopener noreferrer\">注释 3.2</a>）。</li>\n<li>2.2.6. <code>then</code> 方法可以被一个 promise 多次调用：\n<ul>\n<li>2.2.6.1. 当 promise 过渡到 fulfilled 状态时，所有相应的 onFulfilled 回调必须按照 then 的顺序依次执行。</li>\n<li>2.2.6.2. 当 promise 过渡到 rejected 状态时，所有相应的 onRejected 回调必须按照 then 的顺序依次执行。</li>\n</ul>\n</li>\n<li>2.2.7. <code>then</code> 方法必须返回一个 promise。（<a href=\"https://promisesaplus.com/#point-71\" target=\"_blank\" rel=\"noopener noreferrer\">注释 3.3</a>）<div><pre><code>promise2 <span>=</span> promise1<span>.</span><span>then</span><span>(</span>onFulfilled<span>,</span> onRejected<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li>2.2.7.1. 如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 返回一个值 <code>x</code>，就进入 Promise 的解决过程 <code>[[Resolve]](promise2, x)</code>。</li>\n<li>2.2.7.2. 如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 抛出一个异常 <code>e</code>，则 <code>promise2</code> 必须过渡到 rejected 状态，并以 <code>e</code> 为 reason 参数。</li>\n<li>2.2.7.3. 如果 <code>onFulfilled</code> 不是一个函数，并且 <code>promise1</code> 已过渡到 fulfilled 状态，那么 <code>promise2</code> 必须也过渡到 fulfilled 状态并返回和 <code>promise1</code> 相同的 value。</li>\n<li>2.2.7.4. 如果 <code>onRejected</code> 不是一个函数，并且 <code>promise1</code> 已过渡到 rejected 状态，那么 <code>promise2</code> 必须也过渡到 rejected 状态并返回和 <code>promise1</code> 相同的原因 reason。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"_2-3-promise-的解决过程\"> 2.3. Promise 的解决过程</h4>\n<blockquote>\n<p>译者注：</p>\n<ul>\n<li>Resolution Procedure：这个词不知道怎么翻译比较贴切，就直译为「解决过程」了。</li>\n<li>这段逻辑很复杂，理解起来有点绕，不过可以搭配后面手写时的注释来理解。</li>\n</ul>\n</blockquote>\n<p>Promise 的解决过程是一个抽象的操作，它需要输入一个 promise 和一个 value，可以表示为 <code>[[Resolve]](promise, x)</code>。如果 <code>x</code> 有 <code>then</code> 方法且看上去像一个 Promise 的实例，解决过程中就会让 <code>promise</code> 接受这个 <code>x</code> 的状态；否则就用 <code>x</code> 的值来执行 <code>promise</code>。</p>\n<p>这种 thenable 的特性使得 promise 的实现更具有通用性：只要它暴露出一个符合 Promises/A+ 规范的 <code>then</code> 方法即可。这使得那些符合 Promises/A+ 规范的实现可以与不符合规范但可用的实现能良好的共存。</p>\n<p>运行 <code>[[Resolve]](promise, x)</code> 时主要执行了以下步骤：</p>\n<ul>\n<li>2.3.1. 如果 <code>promise</code> 和 <code>x</code> 指向同一个对象，以 <code>TypeError</code> 为 reason 拒绝执行 <code>promise</code>。</li>\n<li>2.3.2. 如果 <code>x</code> 是 <code>promise</code>，则使 <code>promise</code> 接受 <code>x</code> 的状态（<a href=\"https://promisesaplus.com/#point-73\" target=\"_blank\" rel=\"noopener noreferrer\">注释 3.4</a>）：\n<ul>\n<li>2.3.2.1. 如果 <code>x</code> 处于 pending 状态，<code>promise</code> 需保持为等待状态直至 <code>x</code> 被执行或拒绝。</li>\n<li>2.3.2.2. 如果 <code>x</code> 处于 fulfilled 状态，用相同的 value 执行 <code>promise</code>。</li>\n<li>2.3.2.3. 如果 <code>x</code> 处于 rejected 状态，用相同的 reason 执行 <code>promise</code>。</li>\n</ul>\n</li>\n<li>2.3.3. 如果 <code>x</code> 是对象或者函数：\n<ul>\n<li>2.3.3.1. 把 <code>x.then</code> 赋值给 <code>then</code>。（<a href=\"https://promisesaplus.com/#point-75\" target=\"_blank\" rel=\"noopener noreferrer\">注释 3.5</a>）</li>\n<li>2.3.3.2. 如果取 <code>x.then</code> 的值时抛出错误 <code>e</code> ，拒绝执行这个 <code>promise</code> 并以 <code>e</code> 作为 reason。</li>\n<li>2.3.3.3. 如果 <code>then</code> 是函数，将 <code>x</code> 作为函数的作用域 <code>this</code> 调用 <code>then</code>。传递两个回调函数作为参数，第一个参数叫 <code>resolvePromise</code>，第二个参数叫 <code>rejectPromise</code>：\n<ul>\n<li>2.3.3.3.1. 如果 <code>resolvePromise</code> 以 <code>y</code> 为 value 被调用，执行 <code>[[Resolve]](promise, y)</code>。</li>\n<li>2.3.3.3.2. 如果 <code>rejectPromise</code> 以 <code>r</code> 为 reason 被调用， 拒绝 <code>promise</code> 并以 <code>r</code> 为 reason。</li>\n<li>2.3.3.3.3. 如果 <code>resolvePromise</code> 和 <code>rejectPromise</code> 都被调用，或者被同样的参数调用了多次，则优先采用首次调用，并忽略其他的调用。</li>\n<li>2.3.3.3.4. 如果调用 <code>then</code> 方法抛出了异常 <code>e</code>：\n<ul>\n<li>2.3.3.3.4.1. 如果 <code>resolvePromise</code> 或者 <code>rejectPromise</code> 已经被调用，忽略异常。</li>\n<li>2.3.3.3.4.2. 如果没有被调用，拒绝执行 <code>promise</code> 并以 <code>e</code> 为 reason。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>2.3.3.4. 如果 <code>then</code> 不是一个函数，成功执行 <code>promise</code> 并以 <code>x</code> 为 value。</li>\n</ul>\n</li>\n<li>2.3.4. 如果 <code>x</code> 不是一个对象或者函数，成功执行 <code>promise</code> 并以 <code>x</code> 为 value。</li>\n</ul>\n<p>如果一个 promise 是用一个循环 thenable 链中的 thenable 来解析的，那么 <code>[[Resolve]](promise，thenable)</code> 的递归性质最终会导致 <code>[[Resolve]](promise，thenable)</code> 被再次调用，根据上述的算法将会陷入无限递归之中。我们鼓励大家去实现但不是必须去实现这样的一个算法：去检测这样的递归，如果检测到，则以一个可识别的 <code>TypeError</code> 为 reason 来拒绝执行 <code>promise</code>。<a href=\"https://promisesaplus.com/#point-77\" target=\"_blank\" rel=\"noopener noreferrer\">注释 3.6</a>)</p>\n<h3 id=\"_3-注释\"> 3. 注释</h3>\n<p>3.1. 这里的「平台代码」指的是引擎、环境和 promise 实现代码。在实践中，该要求确保在调用 then 方法被调用的那一轮的事件循环之后，使用新堆栈异步执行 <code>onFulfilled</code> 和 <code>onRejected</code>。这可以通过「宏任务」机制（如 <code>setTimeout</code> 或 <code>setImmediate</code>）或「微任务」机制（如 <code>MutationObserver</code> 或 <code>process.nextTick</code>）实现。由于 promise 实现被认为是平台代码（注：即都是 JavaScript），因此它本身可能包含一个任务调度队列或调用处理程序的「trampoline」。</p>\n<p>3.2. 也就是说在严格模式（strict）中，函数 <code>this</code> 的值为 <code>undefined</code>；在非严格模式中其为全局对象。</p>\n<p>3.3. 代码实现在满足所有要求的情况下，可以允许 <code>promise2 === promise1</code>。每个实现都要文档说明其是否允许以及在何种条件下允许 <code>promise2 === promise1</code>。</p>\n<p>3.4. 总体来说，如果 <code>x</code> 符合当前实现，我们才认为它是真正的 promise。本规则允许那些特例实现接受符合已知要求的 promises 状态。</p>\n<p>3.5. 这步我们先是存储了一个指向 <code>x.then</code> 的引用，然后测试并调用该引用，以避免多次访问 <code>x.then</code> 属性。这种预防措施确保了该属性的一致性，因为其值可能在检索调用时被改变。</p>\n<p>3.6. 实现不应该对 thenable 链的深度设限，并假定超出本限制的递归就是无限循环。只有真正的循环递归才应能导致 <code>TypeError</code> 异常；如果一条无限长的链上 thenable 均不相同，那么递归下去永远是正确的行为。</p>\n<h2 id=\"完成一个基本的-promise\"> 完成一个基本的 Promise</h2>\n<h3 id=\"定义一个-mypromise\"> 定义一个 MyPromise</h3>\n<p>首先看一下原生 Promise 的基础用法：</p>\n<div><pre><code><span>let</span> promise <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>resolve</span><span>(</span><span>'success'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span>\n\npromise<span>.</span><span>then</span><span>(</span><span>(</span><span>value</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'Resolved:'</span> <span>+</span> value<span>)</span><span>;</span>\n<span>}</span><span>,</span> <span>(</span><span>reason</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'Rejected:'</span> <span>+</span> reason<span>)</span><span>;</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>Promise 是个构造函数（ES5），在使用前需要实例化。实例化的时候传入了一个参数：</p>\n<div><pre><code><span>let</span> promise <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span><span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>并且这个参数是一个函数，它相当于一个执行器，当 <code>new Promise()</code> 的时候就会自动执行。</p>\n<p>基于这样的要求，我们先将自己写的 Promise 命名为 MyPromise，它是一个类（或者 ES5 的构造函数），在类的构造函数 constructor 里面添加一个参数，这里就用 executor 来做形参，且执行一下这个参数（记住了它是一个函数类型）。用 ES6 的方式来写如下：</p>\n<div><pre><code><span>class</span> <span>MyPromise</span> <span>{</span>\n  <span>constructor</span> <span>(</span><span>executor</span><span>)</span> <span>{</span>\n    <span>executor</span><span>(</span>resolve<span>,</span> reject<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 我是在 Node 环境下测试的</span>\n<span>// 所以遵循 CommonJS 的规范进行模块导出</span>\nmodule<span>.</span>exports <span>=</span> MyPromise<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"初始化状态\"> 初始化状态</h3>\n<p>因为我们需要根据状态进行下一步的操作，所以先要声明三种状态：pending、fulfilled、rejected：</p>\n<div><pre><code><span>const</span> <span>PENDING</span> <span>=</span> <span>'pending'</span><span>;</span>\n<span>const</span> <span>FULFILLED</span> <span>=</span> <span>'fulfilled'</span><span>;</span>\n<span>const</span> <span>REJECTED</span> <span>=</span> <span>'rejected'</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>然后设置初始化状态：</p>\n<ul>\n<li>初始状态为 pending</li>\n<li>resolve 和 reject 都是函数，它们都有参数，分别是 value 和 reason，也需要初始化</li>\n</ul>\n<div><div><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br></div><pre><code><span>const</span> <span>PENDING</span> <span>=</span> <span>'pending'</span><span>;</span>\n<span>const</span> <span>FULFILLED</span> <span>=</span> <span>'fulfilled'</span><span>;</span>\n<span>const</span> <span>REJECTED</span> <span>=</span> <span>'rejected'</span><span>;</span>\n\n<span>class</span> <span>MyPromise</span> <span>{</span>\n  <span>constructor</span> <span>(</span><span>executor</span><span>)</span> <span>{</span>\n    <span>// 初始状态为 pending</span>\n    <span>this</span><span>.</span>status <span>=</span> <span>PENDING</span><span>;</span>\n    <span>// resolve 的参数</span>\n    <span>this</span><span>.</span>value <span>=</span> <span>undefined</span><span>;</span>\n    <span>// reject 的参数</span>\n    <span>this</span><span>.</span>reason <span>=</span> <span>undefined</span><span>;</span>\n    \n    <span>executor</span><span>(</span>resolve<span>,</span> reject<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\nmodule<span>.</span>exports <span>=</span> MyPromise<span>;</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id=\"编写-resolve-和-reject-方法\"> 编写 resolve 和 reject 方法</h3>\n<p>现在开始编写 resolve 和 reject 方法。</p>\n<p>这里有一个注意点，在哪里定义这两个函数：</p>\n<ul>\n<li>\n<p>方案一：定义在 constructor 外面，用类方法的形式来创建这两个函数。本质上是定义到了 Promise 的 prototype 上面，每一个 Promise 的实例会继承同一个 resolve 和 reject。<br>\n这种方案需注意，在 constructor 中调用 resolve 和 reject 时，要使用 bind 来绑定 this，从而解决 this 指向问题。</p>\n<div><div><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><div>&nbsp;</div><div>&nbsp;</div><br><br></div><pre><code><span>class</span> <span>MyPromise</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>executor</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>status <span>=</span> <span>PENDING</span><span>;</span>\n    <span>this</span><span>.</span>value <span>=</span> <span>undefined</span><span>;</span>\n    <span>this</span><span>.</span>reason <span>=</span> <span>undefined</span><span>;</span>\n\n    <span>// 对于 resolve 来说, 这里就是将实例的 resolve 方法内的 this 指向当前实例对象</span>\n    <span>// 对于 reject 来说, 这里就是将实例的 reject 方法内的 this 指向当前实例对象</span>\n    <span>execute</span><span>(</span><span>this</span><span>.</span><span>resolve</span><span>.</span><span>bind</span><span>(</span><span>this</span><span>)</span><span>,</span> <span>this</span><span>.</span><span>reject</span><span>.</span><span>bind</span><span>(</span><span>this</span><span>)</span><span>)</span><span>;</span>\n  <span>}</span>\n  <span>resolve</span><span>(</span><span>value</span><span>)</span> <span>{</span><span>}</span>\n  <span>reject</span><span>(</span><span>reason</span><span>)</span> <span>{</span><span>}</span>\n<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div></li>\n<li>\n<p>方案二：定义在 constructor 里面，每一次实例化的时候，都会在构造函数里重新声明 resolve 和 reject 函数。</p>\n<div><div><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><br><div>&nbsp;</div><br><br><br></div><pre><code><span>class</span> <span>MyPromise</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>executor</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>status <span>=</span> <span>PENDING</span><span>;</span>\n    <span>this</span><span>.</span>value <span>=</span> <span>undefined</span><span>;</span>\n    <span>this</span><span>.</span>reason <span>=</span> <span>undefined</span><span>;</span>\n\n    <span>const</span> <span>resolve</span> <span>=</span> <span>(</span><span>value</span><span>)</span> <span>=></span> <span>{</span><span>}</span>  \n    <span>const</span> <span>reject</span>  <span>=</span> <span>(</span><span>reason</span><span>)</span> <span>=></span> <span>{</span><span>}</span>  \n\n    <span>executor</span><span>(</span>resolve<span>,</span> reject<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div></li>\n</ul>\n<p>两种方案都可以继续往下做，这里我们选择第二种定义方式。下面是定义 resolve 和 reject 方法后的完整代码：</p>\n<div><div><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br></div><pre><code><span>const</span> <span>PENDING</span> <span>=</span> <span>'pending'</span><span>;</span>\n<span>const</span> <span>FULFILLED</span> <span>=</span> <span>'fulfilled'</span><span>;</span>\n<span>const</span> <span>REJECTED</span> <span>=</span> <span>'rejected'</span><span>;</span>\n\n<span>class</span> <span>MyPromise</span> <span>{</span>\n  <span>constructor</span> <span>(</span><span>executor</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>status <span>=</span> <span>PENDING</span><span>;</span>\n    <span>this</span><span>.</span>value <span>=</span> <span>undefined</span><span>;</span>\n    <span>this</span><span>.</span>reason <span>=</span> <span>undefined</span><span>;</span>\n\n    <span>// 每次实例化时重新声明 resolve</span>\n    <span>const</span> <span>resolve</span> <span>=</span> <span>(</span><span>value</span><span>)</span> <span>=></span> <span>{</span>\n      <span>// 只有 pending 状态才能变成 fulfilled</span>\n      <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>PENDING</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span>status <span>=</span> <span>FULFILLED</span><span>;</span>\n        <span>this</span><span>.</span>value <span>=</span> value<span>;</span>\n      <span>}</span>\n    <span>}</span>\n    \n    <span>// 每次实例化时重新声明 reject</span>\n    <span>const</span> <span>reject</span> <span>=</span> <span>(</span><span>reason</span><span>)</span> <span>=></span> <span>{</span>\n      <span>// 只有 pending 状态才能变成 rejected</span>\n      <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>PENDING</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span>status <span>=</span> <span>REJECTED</span><span>;</span>\n        <span>this</span><span>.</span>reason <span>=</span> reason<span>;</span>\n      <span>}</span>\n    <span>}</span>\n\n    <span>executor</span><span>(</span>resolve<span>,</span> reject<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\nmodule<span>.</span>exports <span>=</span> MyPromise<span>;</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><h3 id=\"编写-then-方法\"> 编写 then 方法</h3>\n<p>then 作为 Promise 的一个方法，直接写在 MyPromise 里面就行了。</p>\n<p>它包含了两个参数：</p>\n<ul>\n<li>onFulfilled（成功的回调）：当状态变成 fulfilled 时执行的代码</li>\n<li>onRejected（失败的回调）：当状态变成 rejected 时执行的代码</li>\n</ul>\n<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br></div><pre><code><span>const</span> <span>PENDING</span> <span>=</span> <span>'pending'</span><span>;</span>\n<span>const</span> <span>FULFILLED</span> <span>=</span> <span>'fulfilled'</span><span>;</span>\n<span>const</span> <span>REJECTED</span> <span>=</span> <span>'rejected'</span><span>;</span>\n\n<span>class</span> <span>MyPromise</span> <span>{</span>\n  <span>constructor</span> <span>(</span><span>executor</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>status <span>=</span> <span>PENDING</span><span>;</span>\n    <span>this</span><span>.</span>value <span>=</span> <span>undefined</span><span>;</span>\n    <span>this</span><span>.</span>reason <span>=</span> <span>undefined</span><span>;</span>\n\n    <span>const</span> <span>resolve</span> <span>=</span> <span>(</span><span>value</span><span>)</span> <span>=></span> <span>{</span>\n      <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>PENDING</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span>status <span>=</span> <span>FULFILLED</span><span>;</span>\n        <span>this</span><span>.</span>value <span>=</span> value<span>;</span>\n      <span>}</span>\n    <span>}</span>\n    \n    <span>const</span> <span>reject</span> <span>=</span> <span>(</span><span>reason</span><span>)</span> <span>=></span> <span>{</span>\n      <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>PENDING</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span>status <span>=</span> <span>REJECTED</span><span>;</span>\n        <span>this</span><span>.</span>reason <span>=</span> reason<span>;</span>\n      <span>}</span>\n    <span>}</span>\n\n    <span>executor</span><span>(</span>resolve<span>,</span> reject<span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>// 定义 then 方法</span>\n  <span>then</span> <span>(</span><span>onFulfilled<span>,</span> onRejected</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>FULFILLED</span><span>)</span> <span>{</span>\n      <span>onFulfilled</span><span>(</span><span>this</span><span>.</span>value<span>)</span><span>;</span>\n    <span>}</span>\n    \n    <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>REJECTED</span><span>)</span> <span>{</span>\n      <span>onRejected</span><span>(</span><span>this</span><span>.</span>reason<span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n\n<span>}</span>\n\nmodule<span>.</span>exports <span>=</span> MyPromise<span>;</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><p>测试代码：</p>\n<div><pre><code><span>const</span> MyPromise <span>=</span> <span>require</span><span>(</span><span>'./MyPromise'</span><span>)</span><span>;</span>\n\n<span>let</span> promise <span>=</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>resolve</span><span>(</span><span>'success'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span>\n\npromise<span>.</span><span>then</span><span>(</span><span>(</span><span>value</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'Resolved:'</span><span>,</span> value<span>)</span><span>;</span>\n<span>}</span><span>,</span> <span>(</span><span>reason</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'Rejected:'</span><span>,</span> reason<span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"捕获错误\"> 捕获错误</h3>\n<p>如果只是上面的代码，会发现无法捕获到 <code>throw</code> 出来的错误：</p>\n<div><div><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br></div><pre><code><span>const</span> MyPromise <span>=</span> <span>require</span><span>(</span><span>'./MyPromise'</span><span>)</span><span>;</span>\n\n<span>let</span> promise <span>=</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>'Exception: Error'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span>\n\npromise<span>.</span><span>then</span><span>(</span><span>(</span><span>value</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'Resolved:'</span><span>,</span> value<span>)</span><span>;</span>\n<span>}</span><span>,</span> <span>(</span><span>reason</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'Rejected:'</span><span>,</span> reason<span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>这个错误是在执行器（<code>executor</code>）执行以后抛出来的，那么只要用 <code>try...catch</code> 捕获它就可以了：</p>\n<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code><span>const</span> <span>PENDING</span> <span>=</span> <span>'pending'</span><span>;</span>\n<span>const</span> <span>FULFILLED</span> <span>=</span> <span>'fulfilled'</span><span>;</span>\n<span>const</span> <span>REJECTED</span> <span>=</span> <span>'rejected'</span><span>;</span>\n\n<span>class</span> <span>MyPromise</span> <span>{</span>\n  <span>constructor</span> <span>(</span><span>executor</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>status <span>=</span> <span>PENDING</span><span>;</span>\n    <span>this</span><span>.</span>value <span>=</span> <span>undefined</span><span>;</span>\n    <span>this</span><span>.</span>reason <span>=</span> <span>undefined</span><span>;</span>\n\n    <span>const</span> <span>resolve</span> <span>=</span> <span>(</span><span>value</span><span>)</span> <span>=></span> <span>{</span>\n      <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>PENDING</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span>status <span>=</span> <span>FULFILLED</span><span>;</span>\n        <span>this</span><span>.</span>value <span>=</span> value<span>;</span>\n      <span>}</span>\n    <span>}</span>\n    \n    <span>const</span> <span>reject</span> <span>=</span> <span>(</span><span>reason</span><span>)</span> <span>=></span> <span>{</span>\n      <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>PENDING</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span>status <span>=</span> <span>REJECTED</span><span>;</span>\n        <span>this</span><span>.</span>reason <span>=</span> reason<span>;</span>\n      <span>}</span>\n    <span>}</span>\n\n    <span>// 捕获 executor 里面抛出的异常</span>\n    <span>try</span> <span>{</span>\n      <span>executor</span><span>(</span>resolve<span>,</span> reject<span>)</span><span>;</span>\n    <span>}</span> <span>catch</span><span>(</span>e<span>)</span> <span>{</span>\n      <span>reject</span><span>(</span>e<span>)</span><span>;</span>\n    <span>}</span>\n    \n  <span>}</span>\n\n  <span>then</span> <span>(</span><span>onFulfilled<span>,</span> onRejected</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>FULFILLED</span><span>)</span> <span>{</span>\n      <span>onFulfilled</span><span>(</span><span>this</span><span>.</span>value<span>)</span><span>;</span>\n    <span>}</span>\n    \n    <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>REJECTED</span><span>)</span> <span>{</span>\n      <span>onRejected</span><span>(</span><span>this</span><span>.</span>reason<span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n\n<span>}</span>\n\nmodule<span>.</span>exports <span>=</span> MyPromise<span>;</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><p>至此，一个最基本的 Promise 就写好了。但还有很多问题需要解决，比如多个 <code>promise.then</code> 的处理，所以还得继续往下。</p>\n<h2 id=\"处理-promise-中的异步与多次调用的问题\"> 处理 Promise 中的异步与多次调用的问题</h2>\n<p>如果在原本的代码里，加入异步的逻辑（比如 setTimeout），执行代码会发现什么也没有打印出来：</p>\n<div><div><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br></div><pre><code><span>const</span> MyPromise <span>=</span> <span>require</span><span>(</span><span>'./MyPromise'</span><span>)</span><span>;</span>\n\n<span>let</span> promise <span>=</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n    <span>resolve</span><span>(</span><span>'success'</span><span>)</span><span>;</span>\n  <span>}</span><span>,</span> <span>2000</span><span>)</span><span>;</span>\n<span>}</span><span>)</span>\n\npromise<span>.</span><span>then</span><span>(</span><span>(</span><span>value</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'Resolved:'</span><span>,</span> value<span>)</span><span>;</span>\n<span>}</span><span>,</span> <span>(</span><span>reason</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'Rejected:'</span><span>,</span> reason<span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>因为 setTimeout 是一段异步代码，在 <code>new MyPromise()</code> 执行完以后，状态没有马上改变（依旧是 pending），所以在 <code>promise.then</code> 里面 onFulfilled 和 onRejected 两个地方都不会执行。</p>\n<p>为了跟原生 Promise 一样支持异步逻辑，我们在前面编写的 then 函数里，除了处理 fulfilled 和 rejected 两种状态，现在还需要加入 pending 状态的处理。</p>\n<p>多次调用的意思就是多次调用 then 方法，就像这样：</p>\n<div><pre><code><span>const</span> MyPromise <span>=</span> <span>require</span><span>(</span><span>'./MyPromise'</span><span>)</span><span>;</span>\n\n<span>let</span> promise <span>=</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n    <span>resolve</span><span>(</span><span>'success'</span><span>)</span><span>;</span>\n  <span>}</span><span>,</span> <span>2000</span><span>)</span><span>;</span>\n<span>}</span><span>)</span>\n\n<span>// 此处调用两次 promise.then</span>\npromise<span>.</span><span>then</span><span>(</span><span>(</span><span>value</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'Resolved 1:'</span><span>,</span> value<span>)</span><span>;</span>\n<span>}</span><span>,</span> <span>(</span><span>reason</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'Rejected 1:'</span><span>,</span> reason<span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n\npromise<span>.</span><span>then</span><span>(</span><span>(</span><span>value</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'Resolved 2:'</span><span>,</span> value<span>)</span><span>;</span>\n<span>}</span><span>,</span> <span>(</span><span>reason</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'Rejected 2:'</span><span>,</span> reason<span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>我们这里在解决异步问题的时候，可以顺便把多次调用 then 这个功能也一起实现了。</p>\n<p>根据 Promises/A+ 规范的 <a href=\"https://promisesaplus.com/#point-36\" target=\"_blank\" rel=\"noopener noreferrer\">2.2.6</a> 所述：在有多个 <code>promise.then</code> 的情况下，原生 Promise 会依次去执行 onFulfilled 或依次去执行 onRejected。换个说法：因为状态的变化是不可逆的，一旦从 pending 变成 fulfilled（或 rejected），就会调用 <code>resolve()</code>（或 <code>reject()</code>），接下里只会依次执行每个 then 里面的成功回调（或失败回调），而不会成功回调与失败回调穿插执行。</p>\n<p>为了实现这样的功能，我们需要用到发布订阅的设计模式，把 <code>promise.then</code> 里面的成功回调（或失败回调）都收集起来放到数组中，等到 <code>resolve()</code>（或 <code>reject()</code>） 执行的时候，再依次去执行数组里放的成功回调（或失败回调）。</p>\n<div><div><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br></div><pre><code><span>const</span> <span>PENDING</span> <span>=</span> <span>'pending'</span><span>;</span>\n<span>const</span> <span>FULFILLED</span> <span>=</span> <span>'fulfilled'</span><span>;</span>\n<span>const</span> <span>REJECTED</span> <span>=</span> <span>'rejected'</span><span>;</span>\n\n<span>class</span> <span>MyPromise</span> <span>{</span>\n  <span>constructor</span> <span>(</span><span>executor</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>status <span>=</span> <span>PENDING</span><span>;</span>\n    <span>this</span><span>.</span>value <span>=</span> <span>undefined</span><span>;</span>\n    <span>this</span><span>.</span>reason <span>=</span> <span>undefined</span><span>;</span>\n\n    <span>// 收集所有成功的回调函数, 即 resolve(value) 后触发的 onFulfilled</span>\n    <span>this</span><span>.</span>onFulfilledCallbacks <span>=</span> <span>[</span><span>]</span><span>;</span>\n    <span>// 收集所有失败的回调函数</span>\n    <span>this</span><span>.</span>onRejectedCallbacks <span>=</span> <span>[</span><span>]</span><span>;</span>\n\n    <span>const</span> <span>resolve</span> <span>=</span> <span>(</span><span>value</span><span>)</span> <span>=></span> <span>{</span>\n      <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>PENDING</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span>status <span>=</span> <span>FULFILLED</span><span>;</span>\n        <span>this</span><span>.</span>value <span>=</span> value<span>;</span>\n        <span>// 发布</span>\n        <span>// 处理异步里的 resolve()</span>\n        <span>this</span><span>.</span>onFulfilledCallbacks<span>.</span><span>forEach</span><span>(</span><span>fn</span> <span>=></span> <span>fn</span><span>(</span><span>)</span><span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span>\n    \n    <span>const</span> <span>reject</span> <span>=</span> <span>(</span><span>reason</span><span>)</span> <span>=></span> <span>{</span>\n      <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>PENDING</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span>status <span>=</span> <span>REJECTED</span><span>;</span>\n        <span>this</span><span>.</span>reason <span>=</span> reason<span>;</span>\n        <span>// 发布</span>\n        <span>// 处理异步里的 reject()</span>\n        <span>this</span><span>.</span>onRejectedCallbacks<span>.</span><span>forEach</span><span>(</span><span>fn</span> <span>=></span> <span>fn</span><span>(</span><span>)</span><span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span>\n\n    <span>try</span> <span>{</span>\n      <span>executor</span><span>(</span>resolve<span>,</span> reject<span>)</span><span>;</span>\n    <span>}</span> <span>catch</span><span>(</span>e<span>)</span> <span>{</span>\n      <span>reject</span><span>(</span>e<span>)</span><span>;</span>\n    <span>}</span>\n    \n  <span>}</span>\n\n  <span>then</span> <span>(</span><span>onFulfilled<span>,</span> onRejected</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>FULFILLED</span><span>)</span> <span>{</span>\n      <span>onFulfilled</span><span>(</span><span>this</span><span>.</span>value<span>)</span><span>;</span>\n    <span>}</span>\n    \n    <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>REJECTED</span><span>)</span> <span>{</span>\n      <span>onRejected</span><span>(</span><span>this</span><span>.</span>reason<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>// 对 pending 状态的处理(异步时会进来)</span>\n    <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>PENDING</span><span>)</span> <span>{</span>\n      <span>// 订阅过程</span>\n      <span>// 为什么 push 的内容是 ()=>{onFulfilled(this.value);}</span>\n      <span>// 而不是 onFulfilled 呢</span>\n      <span>// 因为这样在后面发布时, 只需要遍历数组并直接执行每个元素就可以了</span>\n      <span>this</span><span>.</span>onFulfilledCallbacks<span>.</span><span>push</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n        <span>onFulfilled</span><span>(</span><span>this</span><span>.</span>value<span>)</span><span>;</span>\n      <span>}</span><span>)</span><span>;</span>\n      <span>// 同上</span>\n      <span>this</span><span>.</span>onRejectedCallbacks<span>.</span><span>push</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n        <span>onRejected</span><span>(</span><span>this</span><span>.</span>reason<span>)</span><span>;</span>\n      <span>}</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n\n<span>}</span>\n\nmodule<span>.</span>exports <span>=</span> MyPromise<span>;</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br></div></div><h2 id=\"实现-promise-的链式调用功能\"> 实现 Promise 的链式调用功能</h2>\n<p>我们常常用到的 <code>new Promise().then().then()</code>，这就是链式调用，用来解决回调地狱。</p>\n<h3 id=\"原生-promise-链式调用的特性\"> 原生 Promise 链式调用的特性</h3>\n<p>这块比较复杂，对应 Promises/A+ 规范的 <a href=\"https://promisesaplus.com/#the-promise-resolution-procedure\" target=\"_blank\" rel=\"noopener noreferrer\">The Promise Resolution Procedure</a>。规范理解起来比较拗口，所以先总结下所有原生 Promise 链式调用的特点。</p>\n<ul>\n<li>通过 return 可以直接将结果结果给下一个 then。</li>\n</ul>\n<div><div><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br></div><pre><code><span>let</span> promise <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>resolve</span><span>(</span><span>'First resolve'</span><span>)</span><span>;</span> <span>// 传递一个普通值</span>\n<span>}</span><span>)</span>\n\npromise<span>.</span><span>then</span><span>(</span><span>value</span> <span>=></span> <span>{</span>\n  <span>return</span> value<span>;</span>\n<span>}</span><span>)</span>\n<span>.</span><span>then</span><span>(</span><span>value</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>value<span>)</span><span>;</span> <span>// 可以直接打印出 \"First resolve\"</span>\n<span>}</span><span>)</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ul>\n<li>通过新的 promise 去 resolve 结果</li>\n</ul>\n<div><div><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br></div><pre><code><span>let</span> promise <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>resolve</span><span>(</span><span>'First resolve'</span><span>)</span><span>;</span> <span>// 传递一个普通值</span>\n<span>}</span><span>)</span>\n\npromise<span>.</span><span>then</span><span>(</span><span>value</span> <span>=></span> <span>{</span>\n  <span>return</span> value<span>;</span>\n<span>}</span><span>)</span>\n<span>.</span><span>then</span><span>(</span><span>value</span> <span>=></span> <span>{</span>\n  <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n    <span>resolve</span><span>(</span>value<span>)</span><span>;</span>\n  <span>}</span><span>)</span>\n<span>}</span><span>)</span>\n<span>.</span><span>then</span><span>(</span><span>value</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>value<span>)</span><span>;</span> <span>// 可以打印出 \"First resolve\"</span>\n<span>}</span><span>)</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><ul>\n<li>在 then 中只要 new 了新的 promise，哪怕有异步代码，也可以 resolve 结果给下一个 then 的 onFulfilled 回调。</li>\n</ul>\n<div><div><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br></div><pre><code><span>let</span> promise <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>resolve</span><span>(</span><span>'First resolve'</span><span>)</span><span>;</span> <span>// 传递一个普通值</span>\n<span>}</span><span>)</span>\n\npromise<span>.</span><span>then</span><span>(</span><span>value</span> <span>=></span> <span>{</span>\n  <span>return</span> value<span>;</span>\n<span>}</span><span>)</span>\n<span>.</span><span>then</span><span>(</span><span>value</span> <span>=></span> <span>{</span>\n  <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n    <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n      <span>resolve</span><span>(</span>value<span>)</span><span>;</span>\n    <span>}</span><span>,</span> <span>2000</span><span>)</span>\n  <span>}</span><span>)</span>\n<span>}</span><span>)</span>\n<span>.</span><span>then</span><span>(</span><span>value</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>value<span>)</span><span>;</span> <span>// 两秒后可以打印出 \"First resolve\"</span>\n<span>}</span><span>)</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><ul>\n<li>通过新的 promise 去 reject 时, 可以 reject 结果给下一个 then 的 onRejected 回调。</li>\n</ul>\n<div><div><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br></div><pre><code><span>let</span> promise <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>resolve</span><span>(</span><span>'First resolve'</span><span>)</span><span>;</span> <span>// 传递一个普通值</span>\n<span>}</span><span>)</span>\n\npromise<span>.</span><span>then</span><span>(</span><span>value</span> <span>=></span> <span>{</span>\n  <span>return</span> value<span>;</span>\n<span>}</span><span>)</span>\n<span>.</span><span>then</span><span>(</span><span>value</span> <span>=></span> <span>{</span>\n  <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n    <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n      <span>reject</span><span>(</span><span>'Error'</span><span>)</span><span>;</span>\n    <span>}</span><span>,</span> <span>2000</span><span>)</span>\n  <span>}</span><span>)</span>\n<span>}</span><span>)</span>\n<span>.</span><span>then</span><span>(</span><span>value</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>value<span>)</span><span>;</span>\n<span>}</span><span>,</span> <span>reason</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'Rejected: '</span> <span>+</span> reason<span>)</span><span>;</span> <span>// 两秒后可以打印出 \"Rejected: Error\"</span>\n<span>}</span><span>)</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><ul>\n<li>then 走了失败的回调函数后，再走 then。\n<ul>\n<li>默认会 <code>return undefined;</code> 给下一个 then 的 onFulfilled 回调。</li>\n<li>即：即便走了 onRejected 回调，如果下面继续 then，这条链会把失败的<strong>返回结果</strong>直接传给下一个 then 的 onFulfilled 回调中去。</li>\n</ul>\n</li>\n</ul>\n<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br></div><pre><code><span>let</span> promise <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>resolve</span><span>(</span><span>'First resolve'</span><span>)</span><span>;</span> <span>// 传递一个普通值</span>\n<span>}</span><span>)</span>\n\npromise<span>.</span><span>then</span><span>(</span><span>value</span> <span>=></span> <span>{</span>\n  <span>return</span> value<span>;</span>\n<span>}</span><span>)</span>\n<span>.</span><span>then</span><span>(</span><span>value</span> <span>=></span> <span>{</span>\n  <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n    <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n      <span>reject</span><span>(</span><span>'Error'</span><span>)</span><span>;</span>\n    <span>}</span><span>,</span> <span>2000</span><span>)</span>\n  <span>}</span><span>)</span>\n<span>}</span><span>)</span>\n<span>.</span><span>then</span><span>(</span><span>value</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>value<span>)</span><span>;</span>\n<span>}</span><span>,</span> <span>reason</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'Rejected: '</span> <span>+</span> reason<span>)</span><span>;</span> <span>// 两秒后可以打印出 \"Rejected: Error\"</span>\n<span>}</span><span>)</span>\n<span>.</span><span>then</span><span>(</span><span>value</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'失败后, 下一个 then 的 onFulfilled: '</span> <span>+</span> value<span>)</span><span>;</span> <span>// \"失败后, 下一个 then 的 onFulfilled: undefined\"</span>\n<span>}</span><span>,</span> <span>reason</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'失败后, 下一个 then 的 onRejected: '</span> <span>+</span> reason<span>)</span><span>;</span>\n<span>}</span><span>)</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><ul>\n<li>在 then 中抛出异常时，如果下面还有 then，一定会走到失败的回调函数中去。</li>\n</ul>\n<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br></div><pre><code><span>let</span> promise <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>resolve</span><span>(</span><span>'First resolve'</span><span>)</span><span>;</span> <span>// 传递一个普通值</span>\n<span>}</span><span>)</span>\n\npromise<span>.</span><span>then</span><span>(</span><span>value</span> <span>=></span> <span>{</span>\n  <span>return</span> value<span>;</span>\n<span>}</span><span>)</span>\n<span>.</span><span>then</span><span>(</span><span>value</span> <span>=></span> <span>{</span>\n  <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n    <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n      <span>reject</span><span>(</span><span>'Error'</span><span>)</span><span>;</span>\n    <span>}</span><span>,</span> <span>2000</span><span>)</span>\n  <span>}</span><span>)</span>\n<span>}</span><span>)</span>\n<span>.</span><span>then</span><span>(</span><span>value</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>value<span>)</span><span>;</span>\n<span>}</span><span>,</span> <span>reason</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'Rejected: '</span> <span>+</span> reason<span>)</span><span>;</span> <span>// 两秒后可以打印出 \"Rejected: Error\"</span>\n<span>}</span><span>)</span>\n<span>.</span><span>then</span><span>(</span><span>value</span> <span>=></span> <span>{</span>\n  <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>'Throw Error'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span>\n<span>.</span><span>then</span><span>(</span><span>value</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'抛出异常后, 下一个 then 的 onFulfilled: '</span> <span>+</span> reason<span>)</span><span>;</span>\n<span>}</span><span>,</span> <span>reason</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'抛出异常后, 下一个 then 的 onRejected: '</span> <span>+</span> reason<span>)</span><span>;</span> <span>// \"抛出异常后, 下一个 then 的 onRejected: Error: Throw Error\"</span>\n<span>}</span><span>)</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><ul>\n<li>用 catch 捕获的情况：抛出异常后会找离它最近的失败回调函数。\n<ul>\n<li>在 then 中抛出异常时，如果下面还有 then，且指定了失败的回调函数，那么会走这个失败的回调函数。</li>\n<li>在 then 中抛出异常时，如果下面还有 then，且没有指定失败的回调函数，那么会走 catch 捕获。</li>\n</ul>\n</li>\n</ul>\n<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br></div><pre><code><span>let</span> promise <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>resolve</span><span>(</span><span>'First resolve'</span><span>)</span><span>;</span> <span>// 传递一个普通值</span>\n<span>}</span><span>)</span>\n\npromise<span>.</span><span>then</span><span>(</span><span>value</span> <span>=></span> <span>{</span>\n  <span>return</span> value<span>;</span>\n<span>}</span><span>)</span>\n<span>.</span><span>then</span><span>(</span><span>value</span> <span>=></span> <span>{</span>\n  <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n    <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n      <span>reject</span><span>(</span><span>'Error'</span><span>)</span><span>;</span>\n    <span>}</span><span>,</span> <span>2000</span><span>)</span>\n  <span>}</span><span>)</span>\n<span>}</span><span>)</span>\n<span>.</span><span>then</span><span>(</span><span>value</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>value<span>)</span><span>;</span>\n<span>}</span><span>,</span> <span>reason</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'Rejected: '</span> <span>+</span> reason<span>)</span><span>;</span> <span>// 两秒后可以打印出 \"Rejected: Error\"</span>\n<span>}</span><span>)</span>\n<span>.</span><span>then</span><span>(</span><span>value</span> <span>=></span> <span>{</span>\n  <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>'Throw Error'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span>\n<span>.</span><span>then</span><span>(</span><span>value</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'抛出异常后, 下一个 then 的 onFulfilled: '</span> <span>+</span> reason<span>)</span><span>;</span>\n<span>}</span><span>)</span>\n<span>.</span><span>catch</span><span>(</span><span>err</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'Catch: '</span> <span>+</span> err<span>)</span><span>;</span>\n<span>}</span><span>)</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><ul>\n<li>如果在 catch 里面 return 一个值，后面继续 then，那么还能继续走成功的回调。\n<ul>\n<li>因此 catch 在 Promise 的源码层面上就是一个 then，它也是遵循 then 的运行原则的。</li>\n<li>示例比较简单，基于上面的代码再拼接一个 then 就可以了，此处省略。</li>\n</ul>\n</li>\n</ul>\n<p>小节上面的特性：</p>\n<ul>\n<li>走成功回调（onFulfilled）的条件：\n<ul>\n<li>在上一个 then 里 return 一个普通值（value：对应 Promises/A+ 规范的 <a href=\"https://promisesaplus.com/#point-8\" target=\"_blank\" rel=\"noopener noreferrer\">1.3</a>）</li>\n<li>在上一个 then 里 return 一个新的 Promise，并且这个 Promise 里面是成功态的结果（即里面调用了 <code>resolve(value)</code> 方法）。</li>\n</ul>\n</li>\n<li>走失败回调（onRejected）的条件：\n<ul>\n<li>在上一个 then 里 return 一个新的 Promise，并且这个 Promise 里面是失败态的原因（即里面调用了 <code>reject(reason)</code> 方法）。</li>\n<li>在上一个 then 里抛出了异常（<code>throw new Error()</code>）。</li>\n</ul>\n</li>\n</ul>\n<p>最后，<strong>Promise 要实现链式调用，是因为每个 then 都需要返回一个新的 Promise 对象</strong>。</p>\n<details><summary>明白了这一点，顺便也就可以区分这样一种情况了。</summary>\n<p>下面两个写法的 promise2 不一样：</p>\n<ul>\n<li>第一个 promise2 是第二次 then 返回的新的 Promise 对象</li>\n<li>第二个 promise2 是第一次 then 返回的新的 Promise 对象</li>\n</ul>\n<div><pre><code><span>// 第一种 promise2</span>\n<span>let</span> promise <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>resolve</span><span>(</span><span>'First resolve'</span><span>)</span><span>;</span> <span>// 传递一个普通值</span>\n<span>}</span><span>)</span>\n\n<span>let</span> promise2 <span>=</span> promise<span>.</span><span>then</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n\n<span>}</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span>// 第二种 promise2</span>\n<span>let</span> promise <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>resolve</span><span>(</span><span>'First resolve'</span><span>)</span><span>;</span> <span>// 传递一个普通值</span>\n<span>}</span><span>)</span>\n\n<span>let</span> promise2 <span>=</span> promise<span>.</span><span>then</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n\n<span>}</span><span>)</span>\n\npromise2<span>.</span><span>then</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div></details>\n<p>接下来，在 MyPromise 中逐步实现以上提到的 Promise 链式调用特性。</p>\n<h3 id=\"then-方法返回一个新的-promise\"> then 方法返回一个新的 Promise</h3>\n<p>前面提到，Promise 链式调用的原理是：在 then 中返回一个新的 Promise，这个 Promise 本身又提供了 then 方法。</p>\n<p>并且当前 then 中的返回值可以传递到下一个 then 中，作为回调函数（onFulfilled 或 onRejected）的参数。</p>\n<p>先修改 then 函数的代码如下（根据 Promises/A+ 规范的 <a href=\"https://promisesaplus.com/#point-40\" target=\"_blank\" rel=\"noopener noreferrer\">2.2.7</a> 所述，在 then 中返回一个 promise2）：</p>\n<div><pre><code>  <span>// 定义 then 方法</span>\n  <span>then</span> <span>(</span><span>onFulfilled<span>,</span> onRejected</span><span>)</span> <span>{</span>\n    <span>// 定义一个 promise2</span>\n    <span>let</span> promise2 <span>=</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n      <span>// 将之前写的代码都放到 promise2 里面</span>\n      <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>FULFILLED</span><span>)</span> <span>{</span>\n        <span>onFulfilled</span><span>(</span><span>this</span><span>.</span>value<span>)</span><span>;</span>\n      <span>}</span>\n      \n      <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>REJECTED</span><span>)</span> <span>{</span>\n        <span>onRejected</span><span>(</span><span>this</span><span>.</span>reason<span>)</span><span>;</span>\n      <span>}</span>\n      \n      <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>PENDING</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span>onFulfilledCallbacks<span>.</span><span>push</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n          <span>onFulfilled</span><span>(</span><span>this</span><span>.</span>value<span>)</span><span>;</span>\n        <span>}</span><span>)</span><span>;</span>\n        <span>this</span><span>.</span>onRejectedCallbacks<span>.</span><span>push</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n          <span>onRejected</span><span>(</span><span>this</span><span>.</span>reason<span>)</span><span>;</span>\n        <span>}</span><span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span><span>)</span><span>;</span>\n\n    <span>// 返回 promise2</span>\n    <span>return</span> promise2<span>;</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h3 id=\"新-promise-对象的回调函数返回值-x\"> 新 Promise 对象的回调函数返回值 x</h3>\n<p>接下来按照 Promises/A+ 规范的顺序来继续改写代码。</p>\n<p>规范的 <a href=\"https://promisesaplus.com/#point-41\" target=\"_blank\" rel=\"noopener noreferrer\">2.2.7.1</a> 规定：上面返回的这个新 Promise 对象，它的成功或失败的回调函数（onFulfilled 或 onRejected）执行完以后，都需要返回一个值 x。</p>\n<p>这里先定义好 x，把 onFulfilled 或 onRejected 的返回结果赋值给它，后面要对 x 做处理。</p>\n<div><div><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><div>&nbsp;</div><br><br><br><br><div>&nbsp;</div><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br></div><pre><code>  <span>// 定义 then 方法</span>\n  <span>then</span> <span>(</span><span>onFulfilled<span>,</span> onRejected</span><span>)</span> <span>{</span>\n    <span>// 定义一个 promise2</span>\n    <span>let</span> promise2 <span>=</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n      <span>// 将之前写的代码都放到 promise2 里面</span>\n      <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>FULFILLED</span><span>)</span> <span>{</span>\n        <span>let</span> x <span>=</span> <span>onFulfilled</span><span>(</span><span>this</span><span>.</span>value<span>)</span><span>;</span>\n      <span>}</span>\n\n      <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>REJECTED</span><span>)</span> <span>{</span>\n        <span>let</span> x <span>=</span> <span>onRejected</span><span>(</span><span>this</span><span>.</span>reason<span>)</span><span>;</span>\n      <span>}</span>\n\n      <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>PENDING</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span>onFulfilledCallbacks<span>.</span><span>push</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n          <span>let</span> x <span>=</span> <span>onFulfilled</span><span>(</span><span>this</span><span>.</span>value<span>)</span><span>;</span>\n        <span>}</span><span>)</span><span>;</span>\n        <span>this</span><span>.</span>onRejectedCallbacks<span>.</span><span>push</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n          <span>let</span> x <span>=</span> <span>onRejected</span><span>(</span><span>this</span><span>.</span>reason<span>)</span><span>;</span>\n        <span>}</span><span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span><span>)</span><span>;</span>\n\n    <span>// 返回 promise2</span>\n    <span>return</span> promise2<span>;</span>\n  <span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h3 id=\"then-方法内部异常捕获\"> then 方法内部异常捕获</h3>\n<p>规范的 <a href=\"https://promisesaplus.com/#point-42\" target=\"_blank\" rel=\"noopener noreferrer\">2.2.7.2</a> 规定：如果 then 里面有异常抛出，需要进行捕获，然后 reject 出去，如果有下一个 then 就可以直接走失败的回调了。</p>\n<p>代码增加 <code>try...catch</code> 进行捕获即可：</p>\n<div><div><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br></div><pre><code>  <span>// 定义 then 方法</span>\n  <span>then</span> <span>(</span><span>onFulfilled<span>,</span> onRejected</span><span>)</span> <span>{</span>\n    <span>// 定义一个 promise2</span>\n    <span>let</span> promise2 <span>=</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n      <span>// 将之前写的代码都放到 promise2 里面</span>\n      <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>FULFILLED</span><span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n          <span>let</span> x <span>=</span> <span>onFulfilled</span><span>(</span><span>this</span><span>.</span>value<span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>\n          <span>reject</span><span>(</span>e<span>)</span><span>;</span>\n        <span>}</span>\n      <span>}</span>\n\n      <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>REJECTED</span><span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n          <span>let</span> x <span>=</span> <span>onRejected</span><span>(</span><span>this</span><span>.</span>reason<span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>\n          <span>reject</span><span>(</span>e<span>)</span><span>;</span>\n        <span>}</span>\n      <span>}</span>\n\n      <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>PENDING</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span>onFulfilledCallbacks<span>.</span><span>push</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n          <span>try</span> <span>{</span>\n            <span>let</span> x <span>=</span> <span>onFulfilled</span><span>(</span><span>this</span><span>.</span>value<span>)</span><span>;</span>\n          <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>\n            <span>reject</span><span>(</span>e<span>)</span><span>;</span>\n          <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        <span>this</span><span>.</span>onRejectedCallbacks<span>.</span><span>push</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n          <span>try</span> <span>{</span>\n            <span>let</span> x <span>=</span> <span>onRejected</span><span>(</span><span>this</span><span>.</span>reason<span>)</span><span>;</span>\n          <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>\n            <span>reject</span><span>(</span>e<span>)</span><span>;</span>\n          <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span><span>)</span><span>;</span>\n\n    <span>// 返回 promise2</span>\n    <span>return</span> promise2<span>;</span>\n  <span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h3 id=\"x-值的处理\"> x 值的处理</h3>\n<p>还是回到规范的 <a href=\"https://promisesaplus.com/#point-41\" target=\"_blank\" rel=\"noopener noreferrer\">2.2.7.1</a>：如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行下面的 Promise 的解决过程。</p>\n<p>规范的 <a href=\"https://promisesaplus.com/#the-promise-resolution-procedure\" target=\"_blank\" rel=\"noopener noreferrer\">2.3</a> 详细描述了 Promise 解决过程，其中首先要对 x 值进行处理。</p>\n<p>考虑到 x 有可能是普通值，也可能是一个 Promise 对象，就需要一个专门处理 x 的函数（根据规范，这个函数就命名为 resolvePromise）：</p>\n<ul>\n<li>如果是普通值，通过 <code>Promise.resolve()</code> 方法将它转换成 Promise 对象后再 return 出去。</li>\n<li>如果是 Promise 对象，可以直接 return 出去。</li>\n</ul>\n<div><div><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br></div><pre><code>  <span>// 定义 then 方法</span>\n  <span>then</span> <span>(</span><span>onFulfilled<span>,</span> onRejected</span><span>)</span> <span>{</span>\n    <span>// 定义一个 promise2</span>\n    <span>let</span> promise2 <span>=</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n      <span>// 将之前写的代码都放到 promise2 里面</span>\n      <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>FULFILLED</span><span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n          <span>let</span> x <span>=</span> <span>onFulfilled</span><span>(</span><span>this</span><span>.</span>value<span>)</span><span>;</span>\n          <span>resolvePromise</span><span>(</span>promise2<span>,</span> x<span>,</span> resolve<span>,</span> reject<span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>\n          <span>reject</span><span>(</span>e<span>)</span><span>;</span>\n        <span>}</span>\n      <span>}</span>\n\n      <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>REJECTED</span><span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n          <span>let</span> x <span>=</span> <span>onRejected</span><span>(</span><span>this</span><span>.</span>reason<span>)</span><span>;</span>\n          <span>resolvePromise</span><span>(</span>promise2<span>,</span> x<span>,</span> resolve<span>,</span> reject<span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>\n          <span>reject</span><span>(</span>e<span>)</span><span>;</span>\n        <span>}</span>\n      <span>}</span>\n\n      <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>PENDING</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span>onFulfilledCallbacks<span>.</span><span>push</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n          <span>try</span> <span>{</span>\n            <span>let</span> x <span>=</span> <span>onFulfilled</span><span>(</span><span>this</span><span>.</span>value<span>)</span><span>;</span>\n            <span>resolvePromise</span><span>(</span>promise2<span>,</span> x<span>,</span> resolve<span>,</span> reject<span>)</span><span>;</span>\n          <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>\n            <span>reject</span><span>(</span>e<span>)</span><span>;</span>\n          <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        <span>this</span><span>.</span>onRejectedCallbacks<span>.</span><span>push</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n          <span>try</span> <span>{</span>\n            <span>let</span> x <span>=</span> <span>onRejected</span><span>(</span><span>this</span><span>.</span>reason<span>)</span><span>;</span>\n            <span>resolvePromise</span><span>(</span>promise2<span>,</span> x<span>,</span> resolve<span>,</span> reject<span>)</span><span>;</span>\n          <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>\n            <span>reject</span><span>(</span>e<span>)</span><span>;</span>\n          <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span><span>)</span><span>;</span>\n\n    <span>// 返回 promise2</span>\n    <span>return</span> promise2<span>;</span>\n  <span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><p>resolvePromise() 各参数的意义：</p>\n<div><pre><code><span>/**\n * Promise 解决过程, 即规范所说的 [[Resolve]](promise2, x)\n * 对 resolve()、reject() 中的返回值 x 进行处理\n * @param {promise} promise2: promise1.then 方法返回的新的 promise 对象\n * @param {[type]} x: promise1 中 onFulfilled 或 onRejected 的返回值\n * @param {[type]} resolve: promise2 的 resolve 方法\n * @param {[type]} reject: promise2 的 reject 方法\n */</span>\n<span>function</span> <span>resolvePromise</span><span>(</span><span>promise2<span>,</span> x<span>,</span> resolve<span>,</span> reject</span><span>)</span> <span>{</span><span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>这里的 resolvePromise 函数我们先当作黑盒子，暂时先不去编写它的具体实现。</p>\n<h3 id=\"用异步设置事件循环顺序\"> 用异步设置事件循环顺序</h3>\n<p>根据 Promises/A+ 规范 <a href=\"https://promisesaplus.com/#point-67\" target=\"_blank\" rel=\"noopener noreferrer\">3.1</a> 所述，onFulfilled 和 onRejected 必须是异步的，且以宏任务的方式执行，这里就用规范里给的 setTimeout 来包裹：</p>\n<p>为什么要包裹成异步代码呢？有两个原因：</p>\n<ul>\n<li>如果不包裹，<code>let promise2 = new Promise((resolve, reject) =&gt; {})</code> 函数体里面的代码以同步的方式执行，其中的 <code>resolvePromise()</code> 提前使用到了 <code>promise2</code> 这个变量。但此时 new Promise 的过程还没执行完，是拿不到 promise2 的，会报引用错误。</li>\n<li><code>resolvePromise();</code> 函数必须等异步的 <code>let x = onFulfilled(this.value);</code> 函数运行完，才能执行。只有把这一大块包裹成异步代码才能实现这一点。</li>\n</ul>\n<p>其实本质就是利用事件循环机制，把代码放在事件循环末尾去执行。而 <code>status === PENDING</code> 的分支不需要包裹，因为只有 resolve 或 reject 的时候才会进来。</p>\n<div><p>提示</p>\n<p>下面的代码里，虽然我们把 setTimeout 延时设置为 0，但实际延时 &gt;= 4ms。详情参见：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/setTimeout#%E5%AE%9E%E9%99%85%E5%BB%B6%E6%97%B6%E6%AF%94%E8%AE%BE%E5%AE%9A%E5%80%BC%E6%9B%B4%E4%B9%85%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9A%E6%9C%80%E5%B0%8F%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4\" target=\"_blank\" rel=\"noopener noreferrer\">实际延时比设定值更久的原因：最小延迟时间</a></p>\n</div>\n<div><div><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code>  <span>// 定义 then 方法</span>\n  <span>then</span> <span>(</span><span>onFulfilled<span>,</span> onRejected</span><span>)</span> <span>{</span>\n    <span>// 定义一个 promise2</span>\n    <span>let</span> promise2 <span>=</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n      <span>// 将之前写的代码都放到 promise2 里面</span>\n      <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>FULFILLED</span><span>)</span> <span>{</span>\n        <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n          <span>try</span> <span>{</span>\n            <span>let</span> x <span>=</span> <span>onFulfilled</span><span>(</span><span>this</span><span>.</span>value<span>)</span><span>;</span>\n            <span>resolvePromise</span><span>(</span>promise2<span>,</span> x<span>,</span> resolve<span>,</span> reject<span>)</span><span>;</span>\n          <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>\n            <span>reject</span><span>(</span>e<span>)</span><span>;</span>\n          <span>}</span>\n        <span>}</span><span>,</span> <span>0</span><span>)</span><span>;</span>\n      <span>}</span>\n\n      <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>REJECTED</span><span>)</span> <span>{</span>\n        <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n          <span>try</span> <span>{</span>\n            <span>let</span> x <span>=</span> <span>onRejected</span><span>(</span><span>this</span><span>.</span>reason<span>)</span><span>;</span>\n            <span>resolvePromise</span><span>(</span>promise2<span>,</span> x<span>,</span> resolve<span>,</span> reject<span>)</span><span>;</span>\n          <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>\n            <span>reject</span><span>(</span>e<span>)</span><span>;</span>\n          <span>}</span>\n        <span>}</span><span>,</span> <span>0</span><span>)</span><span>;</span>\n      <span>}</span>\n\n      <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>PENDING</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span>onFulfilledCallbacks<span>.</span><span>push</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n          <span>try</span> <span>{</span>\n            <span>let</span> x <span>=</span> <span>onFulfilled</span><span>(</span><span>this</span><span>.</span>value<span>)</span><span>;</span>\n            <span>resolvePromise</span><span>(</span>promise2<span>,</span> x<span>,</span> resolve<span>,</span> reject<span>)</span><span>;</span>\n          <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>\n            <span>reject</span><span>(</span>e<span>)</span><span>;</span>\n          <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        <span>this</span><span>.</span>onRejectedCallbacks<span>.</span><span>push</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n          <span>try</span> <span>{</span>\n            <span>let</span> x <span>=</span> <span>onRejected</span><span>(</span><span>this</span><span>.</span>reason<span>)</span><span>;</span>\n            <span>resolvePromise</span><span>(</span>promise2<span>,</span> x<span>,</span> resolve<span>,</span> reject<span>)</span><span>;</span>\n          <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>\n            <span>reject</span><span>(</span>e<span>)</span><span>;</span>\n          <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span><span>)</span><span>;</span>\n\n    <span>// 返回 promise2</span>\n    <span>return</span> promise2<span>;</span>\n  <span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div><h3 id=\"实现-resolvepromise-方法\"> 实现 resolvePromise 方法</h3>\n<p>接下来实现 resolvePromise 方法，也就是规范的 <a href=\"https://promisesaplus.com/#the-promise-resolution-procedure\" target=\"_blank\" rel=\"noopener noreferrer\">2.3. The Promise Resolution Procedure</a> 这一部分。</p>\n<ul>\n<li><a href=\"https://promisesaplus.com/#point-48\" target=\"_blank\" rel=\"noopener noreferrer\">2.3.1</a>：如果 promise 和 x 指向同一对象，以 TypeError 为拒因拒绝执行 promise。</li>\n</ul>\n<div><pre><code><span>function</span> <span>resolvePromise</span><span>(</span><span>promise2<span>,</span> x<span>,</span> resolve<span>,</span> reject</span><span>)</span> <span>{</span>\n  <span>// 2.3.1 如果 promise 和 x 指向同一对象，以 TypeError 为拒因拒绝执行 promise</span>\n  <span>if</span> <span>(</span>promise2 <span>===</span> x<span>)</span> <span>{</span>\n    <span>return</span> <span>reject</span><span>(</span><span>new</span> <span>TypeError</span><span>(</span><span>'Chaining cycle detected for promise #&lt;MyPromise>'</span><span>)</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>因为如果从 onFulfilled 或 onRejected 中返回的 x 就是 promise2，会导致循环引用报错。</p>\n<p>例如下面这种情况，使用原生 Promise 执行这个代码，会报类型错误：</p>\n<div><pre><code><span>const</span> promise <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>resolve</span><span>(</span><span>100</span><span>)</span>\n<span>}</span><span>)</span>\n<span>const</span> p1 <span>=</span> promise<span>.</span><span>then</span><span>(</span><span>value</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>value<span>)</span>\n  <span>return</span> p1\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>\n<li><a href=\"https://promisesaplus.com/#point-53\" target=\"_blank\" rel=\"noopener noreferrer\">2.3.3</a>：如果 x 为对象或者函数。</li>\n</ul>\n<div><pre><code><span>function</span> <span>resolvePromise</span><span>(</span><span>promise2<span>,</span> x<span>,</span> resolve<span>,</span> reject</span><span>)</span> <span>{</span>\n  <span>// 2.3.1 如果 promise 和 x 指向同一对象，以 TypeError 为拒因拒绝执行 promise</span>\n  <span>if</span> <span>(</span>promise2 <span>===</span> x<span>)</span> <span>{</span>\n    <span>return</span> <span>reject</span><span>(</span><span>new</span> <span>TypeError</span><span>(</span><span>'Chaining cycle detected for promise #&lt;MyPromise>'</span><span>)</span><span>)</span>\n  <span>}</span>\n\n  <span>// 2.3.3 注意 null 也是 object, 需要排除</span>\n  <span>if</span> <span>(</span><span>(</span><span>typeof</span> x <span>===</span> <span>'object'</span> <span>&amp;&amp;</span> x <span>!==</span> <span>null</span><span>)</span> <span>||</span> <span>(</span><span>typeof</span> x <span>===</span> <span>'function'</span><span>)</span><span>)</span> <span>{</span>\n    <span>// 2.3.3.2 捕获错误异常</span>\n    <span>try</span> <span>{</span>\n      <span>// 2.3.3.1 如果 x 是 Promise 对象, 它一定有 then 方法</span>\n      <span>let</span> then <span>=</span> x<span>.</span>then<span>;</span>\n      <span>// 2.3.3.3 这样暂且就可以认定 x 是个 Promise 对象(但不能绝对排除人为给 x 设置了一个 then 方法的情况)</span>\n      <span>if</span> <span>(</span><span>typeof</span> then <span>===</span> <span>'function'</span><span>)</span> <span>{</span>\n        <span>then</span><span>.</span><span>call</span><span>(</span>x<span>,</span> <span>(</span><span>y</span><span>)</span> <span>=></span> <span>{</span>\n          <span>// 2.3.3.3.1 注意这里是一个新的 promise, 需要递归调用</span>\n          <span>// 就是支持处理 resolve(new Promise(()=>{}) 这种在 resolve() 里无限嵌套 new Promise() 的场景</span>\n          <span>resolvePromise</span><span>(</span>promise2<span>,</span> y<span>,</span> resolve<span>,</span> reject<span>)</span><span>;</span>\n        <span>}</span><span>,</span> <span>(</span><span>r</span><span>)</span> <span>=></span> <span>{</span>\n          <span>// 2.3.3.3.2</span>\n          <span>reject</span><span>(</span>r<span>)</span><span>;</span>\n        <span>}</span><span>)</span>\n      <span>}</span> <span>else</span> <span>{</span>\n        <span>// 2.3.3.4 如果 x 不是个 Promise 对象</span>\n        <span>resolve</span><span>(</span>x<span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>\n      <span>// 2.3.3.2</span>\n      <span>reject</span><span>(</span>e<span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span> <span>else</span> <span>{</span>\n    <span>// 2.3.4</span>\n    <span>resolve</span><span>(</span>x<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><ul>\n<li>细节处理，<a href=\"https://promisesaplus.com/#point-59\" target=\"_blank\" rel=\"noopener noreferrer\">2.3.3.3.3</a>：如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用。</li>\n</ul>\n<p>什么意思呢，就像下面这样，调用了 resolve() 后又调用了 reject()：</p>\n<div><div><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br></div><pre><code><span>let</span> promise1 <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>resolve</span><span>(</span><span>'promise 1'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n\n<span>let</span> promise2 <span>=</span> promise1<span>.</span><span>then</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n    <span>resolve</span><span>(</span><span>)</span><span>;</span>\n    <span>reject</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span><span>)</span><span>;</span>\n<span>}</span><span>,</span> <span>(</span><span>reason</span><span>)</span> <span>=></span> <span>{</span>\n  <span>return</span> reason\n<span>}</span><span>)</span><span>;</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>这个时候可以增加一个表示 <code>called</code>，记录是否调用过：</p>\n<div><div><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br><br></div><pre><code><span>function</span> <span>resolvePromise</span><span>(</span><span>promise2<span>,</span> x<span>,</span> resolve<span>,</span> reject</span><span>)</span> <span>{</span>\n  <span>// 2.3.1 如果 promise 和 x 指向同一对象，以 TypeError 为拒因拒绝执行 promise</span>\n  <span>if</span> <span>(</span>promise2 <span>===</span> x<span>)</span> <span>{</span>\n    <span>return</span> <span>reject</span><span>(</span><span>new</span> <span>TypeError</span><span>(</span><span>'Chaining cycle detected for promise #&lt;MyPromise>'</span><span>)</span><span>)</span>\n  <span>}</span>\n\n  <span>// 2.3.3.3.3 避免多次调用</span>\n  <span>let</span> called <span>=</span> <span>false</span><span>;</span>\n\n  <span>// 2.3.3 注意 null 也是 object, 需要排除</span>\n  <span>if</span> <span>(</span><span>(</span><span>typeof</span> x <span>===</span> <span>'object'</span> <span>&amp;&amp;</span> x <span>!==</span> <span>null</span><span>)</span> <span>||</span> <span>(</span><span>typeof</span> x <span>===</span> <span>'function'</span><span>)</span><span>)</span> <span>{</span>\n    <span>// 2.3.3.2 捕获错误异常</span>\n    <span>try</span> <span>{</span>\n      <span>// 2.3.3.1 如果 x 是 Promise 对象, 它一定有 then 方法</span>\n      <span>let</span> then <span>=</span> x<span>.</span>then<span>;</span>\n      <span>// 2.3.3.3 这样暂且就可以认定 x 是个 Promise 对象(但不能绝对排除人为给 x 设置了一个 then 方法的情况)</span>\n      <span>if</span> <span>(</span><span>typeof</span> then <span>===</span> <span>'function'</span><span>)</span> <span>{</span>\n        <span>then</span><span>.</span><span>call</span><span>(</span>x<span>,</span> <span>(</span><span>y</span><span>)</span> <span>=></span> <span>{</span>\n          <span>if</span> <span>(</span>called<span>)</span> <span>return</span><span>;</span>\n          called <span>=</span> <span>true</span><span>;</span>\n          <span>// 2.3.3.3.1 注意这里是一个新的 promise, 需要递归调用</span>\n          <span>// 就是支持处理 resolve(new Promise(()=>{}) 这种在 resolve() 里无限嵌套 new Promise() 的场景</span>\n          <span>resolvePromise</span><span>(</span>promise2<span>,</span> y<span>,</span> resolve<span>,</span> reject<span>)</span><span>;</span>\n        <span>}</span><span>,</span> <span>(</span><span>r</span><span>)</span> <span>=></span> <span>{</span>\n          <span>if</span> <span>(</span>called<span>)</span> <span>return</span><span>;</span>\n          called <span>=</span> <span>true</span><span>;</span>\n          <span>// 2.3.3.3.2</span>\n          <span>reject</span><span>(</span>r<span>)</span><span>;</span>\n        <span>}</span><span>)</span>\n      <span>}</span> <span>else</span> <span>{</span>\n        <span>// 2.3.3.4 如果 x 不是个 Promise 对象</span>\n        <span>resolve</span><span>(</span>x<span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>\n      <span>if</span> <span>(</span>called<span>)</span> <span>return</span><span>;</span>\n      called <span>=</span> <span>true</span><span>;</span>\n      <span>// 2.3.3.2</span>\n      <span>reject</span><span>(</span>e<span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span> <span>else</span> <span>{</span>\n    <span>// 2.3.4</span>\n    <span>resolve</span><span>(</span>x<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><h3 id=\"修补-bug-支持-then-不带参数\"> 修补 bug：支持 then 不带参数</h3>\n<p>前面写的代码有一个 bug，就是当 then 不带参数调用时，会报错：</p>\n<div><pre><code>promise2<span>.</span><span>then</span><span>(</span><span>)</span><span>.</span><span>then</span><span>(</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>value</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>value<span>)</span>\n<span>}</span><span>,</span> <span>(</span><span>reason</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>reason<span>)</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>根据规范 <a href=\"https://promisesaplus.com/#point-23\" target=\"_blank\" rel=\"noopener noreferrer\">2.2.1</a> 所述，onFulfilled 和 onRejected 应该是可选参数。因此要重新修改下 then 方法，增加回调函数的默认值：</p>\n<div><div><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code>  <span>// 定义 then 方法</span>\n  <span>then</span> <span>(</span><span>onFulfilled<span>,</span> onRejected</span><span>)</span> <span>{</span>\n    <span>// 设置默认值, 如果是函数就赋值给它本身, 如果不是就将成功的回调的参数 value 返给它</span>\n    onFulfilled <span>=</span> <span>typeof</span> onFulfilled <span>===</span> <span>'function'</span> <span>?</span> <span>onFulfilled</span> <span>:</span> <span>value</span> <span>=></span> value<span>;</span>\n    <span>// 设置默认值, 如果是函数就赋值给它本身, 如果不是就将失败的回调的参数 reason 作为错误原因抛出去</span>\n    onRejected <span>=</span> <span>typeof</span> onRejected <span>===</span> <span>'function'</span> <span>?</span> <span>onRejected</span> <span>:</span> <span>reason</span> <span>=></span> <span>{</span> <span>throw</span> reason<span>}</span><span>;</span>\n    <span>// 定义一个 promise2</span>\n    <span>let</span> promise2 <span>=</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n      <span>// 将之前写的代码都放到 promise2 里面</span>\n      <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>FULFILLED</span><span>)</span> <span>{</span>\n        <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n          <span>try</span> <span>{</span>\n            <span>let</span> x <span>=</span> <span>onFulfilled</span><span>(</span><span>this</span><span>.</span>value<span>)</span><span>;</span>\n            <span>resolvePromise</span><span>(</span>promise2<span>,</span> x<span>,</span> resolve<span>,</span> reject<span>)</span><span>;</span>\n          <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>\n            <span>reject</span><span>(</span>e<span>)</span><span>;</span>\n          <span>}</span>\n        <span>}</span><span>,</span> <span>0</span><span>)</span><span>;</span>\n      <span>}</span>\n\n      <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>REJECTED</span><span>)</span> <span>{</span>\n        <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n          <span>try</span> <span>{</span>\n            <span>let</span> x <span>=</span> <span>onRejected</span><span>(</span><span>this</span><span>.</span>reason<span>)</span><span>;</span>\n            <span>resolvePromise</span><span>(</span>promise2<span>,</span> x<span>,</span> resolve<span>,</span> reject<span>)</span><span>;</span>\n          <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>\n            <span>reject</span><span>(</span>e<span>)</span><span>;</span>\n          <span>}</span>\n        <span>}</span><span>,</span> <span>0</span><span>)</span><span>;</span>\n      <span>}</span>\n\n      <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>PENDING</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span>onFulfilledCallbacks<span>.</span><span>push</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n          <span>try</span> <span>{</span>\n            <span>let</span> x <span>=</span> <span>onFulfilled</span><span>(</span><span>this</span><span>.</span>value<span>)</span><span>;</span>\n            <span>resolvePromise</span><span>(</span>promise2<span>,</span> x<span>,</span> resolve<span>,</span> reject<span>)</span><span>;</span>\n          <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>\n            <span>reject</span><span>(</span>e<span>)</span><span>;</span>\n          <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        <span>this</span><span>.</span>onRejectedCallbacks<span>.</span><span>push</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n          <span>try</span> <span>{</span>\n            <span>let</span> x <span>=</span> <span>onRejected</span><span>(</span><span>this</span><span>.</span>reason<span>)</span><span>;</span>\n            <span>resolvePromise</span><span>(</span>promise2<span>,</span> x<span>,</span> resolve<span>,</span> reject<span>)</span><span>;</span>\n          <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>\n            <span>reject</span><span>(</span>e<span>)</span><span>;</span>\n          <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span><span>)</span><span>;</span>\n\n    <span>// 返回 promise2</span>\n    <span>return</span> promise2<span>;</span>\n  <span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br></div></div><h3 id=\"修补-bug-补充-catch-方法\"> 修补 bug：补充 catch 方法</h3>\n<p>目前完成的 MyPromise 还有一个小问题，执行以下代码：</p>\n<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br></div><pre><code><span>const</span> MyPromise <span>=</span> <span>require</span><span>(</span><span>'./MyPromise'</span><span>)</span><span>;</span>\n\n<span>let</span> promise1 <span>=</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>resolve</span><span>(</span><span>'promise 1'</span><span>)</span>\n<span>}</span><span>)</span>\n\n<span>let</span> promise2 <span>=</span> promise1<span>.</span><span>then</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>return</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n    <span>resolve</span><span>(</span><span>'new Promise resolve'</span><span>)</span><span>;</span>\n  <span>}</span><span>)</span>\n<span>}</span><span>,</span> <span>(</span><span>reason</span><span>)</span> <span>=></span> <span>{</span>\n  <span>return</span> reason<span>;</span>\n<span>}</span><span>)</span>\n\npromise2<span>.</span><span>then</span><span>(</span><span>)</span><span>.</span><span>then</span><span>(</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>value</span><span>)</span> <span>=></span> <span>{</span>\n  <span>throw</span> <span>Error</span><span>(</span><span>'Error'</span><span>)</span><span>;</span>\n<span>}</span><span>,</span> <span>(</span><span>reason</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>reason<span>)</span><span>;</span>\n<span>}</span><span>)</span>\n<span>.</span><span>catch</span><span>(</span><span>(</span><span>e</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>e<span>)</span><span>;</span>\n<span>}</span><span>)</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>会发现报错：<code>TypeError: promise2.then(...).then(...).then(...).catch is not a function</code>。</p>\n<p>根据报错，就需要在我们的 MyPromise 类里定义一个 catch 方法：</p>\n<ul>\n<li>catch 方法和 then 方法比较相似</li>\n<li>唯一的区别是 catch 方法的第一个参数是 null</li>\n</ul>\n<div><div><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br></div><pre><code><span>const</span> <span>PENDING</span> <span>=</span> <span>'pending'</span><span>;</span>\n<span>const</span> <span>FULFILLED</span> <span>=</span> <span>'fulfilled'</span><span>;</span>\n<span>const</span> <span>REJECTED</span> <span>=</span> <span>'rejected'</span><span>;</span>\n\n<span>class</span> <span>MyPromise</span> <span>{</span>\n  <span>constructor</span> <span>(</span><span>executor</span><span>)</span> <span>{</span><span>}</span>\n\n  <span>// 定义 then 方法</span>\n  <span>then</span> <span>(</span><span>onFulfilled<span>,</span> onRejected</span><span>)</span> <span>{</span><span>}</span>\n\n  <span>// 用 then 模拟 catch</span>\n  <span>// catch 本身是 then 的一个语法糖</span>\n  <span>catch</span> <span>(</span>errorCallback<span>)</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span><span>then</span><span>(</span><span>null</span><span>,</span> errorCallback<span>)</span><span>;</span>\n  <span>}</span>\n\n<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id=\"promises-a-测试\"> Promises/A+ 测试</h2>\n<p>如何证明写的这个 MyPromise 就符合 Promises/A+ 规范呢？</p>\n<p>跑一下 Promise A+ 测试就好啦。</p>\n<h3 id=\"安装官方测试工具\"> 安装官方测试工具</h3>\n<p>我们使用 Promises/A+ 官方的测试工具 promises-aplus-tests 来对我们的 MyPromise 进行测试。</p>\n<div><pre><code><span># 安装 promises-aplus-tests</span>\n<span>npm</span> <span>install</span> promises-aplus-tests -D\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"使用-es6-module-对外暴露-mypromise-类\"> 使用 ES6 Module 对外暴露 MyPromise 类</h3>\n<div><pre><code><span>class</span> <span>MyPromise</span> <span>{</span>\n  <span>// ...</span>\n<span>}</span>\n\n<span>function</span> <span>resolvePromise</span><span>(</span><span>promise2<span>,</span> x<span>,</span> resolve<span>,</span> reject</span><span>)</span> <span>{</span> \n  <span>// ...</span>\n<span>}</span>\n\nmodule<span>.</span>exports <span>=</span> MyPromise<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"实现静态方法-deferred\"> 实现静态方法 deferred</h3>\n<p>要使用 promises-aplus-tests 这个工具测试，必须实现一个静态方法 <code>deferred()</code>，通过查看<a href=\"https://github.com/promises-aplus/promises-tests\" target=\"_blank\" rel=\"noopener noreferrer\">官方</a>对这个方法的定义可知：</p>\n<p>我们要给自己手写的 MyPromise 上实现一个静态方法 <code>deferred()</code>，该方法要返回一个包含 <code>{ promise, resolve, reject }</code> 的对象：</p>\n<ul>\n<li>promise 是一个处于 pending 状态的 Promsie 对象。</li>\n<li>resolve(value) 用 value「解决」上面那个 promise。</li>\n<li>reject(reason) 用 reason「拒绝」上面那个 promise。</li>\n</ul>\n<p><code>deferred()</code> 的实现如下：</p>\n<div><pre><code><span>class</span> <span>MyPromise</span> <span>{</span>\n  <span>// ...</span>\n<span>}</span>\n\n<span>function</span> <span>resolvePromise</span><span>(</span><span>promise2<span>,</span> x<span>,</span> resolve<span>,</span> reject</span><span>)</span> <span>{</span> \n  <span>// ...</span>\n<span>}</span>\n\nMyPromise<span>.</span><span>deferred</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n  <span>let</span> result <span>=</span> <span>{</span><span>}</span><span>;</span>\n  result<span>.</span>promise <span>=</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n    result<span>.</span>resolve <span>=</span> resolve<span>;</span>\n    result<span>.</span>reject <span>=</span> reject<span>;</span>\n  <span>}</span><span>)</span><span>;</span>\n  <span>return</span> result<span>;</span>\n<span>}</span>\n\nmodule<span>.</span>exports <span>=</span> MyPromise<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id=\"配置-package-json\"> 配置 package.json</h3>\n<p>我们实现了 deferred 方法，也通过 ES6 Module 对外暴露了 MyPromise，最后配置一下 package.json 就可以跑测试了：</p>\n<div><pre><code><span>// package.json</span>\n<span>{</span>\n  <span>\"devDependencies\"</span><span>:</span> <span>{</span>\n    <span>\"promises-aplus-tests\"</span><span>:</span> <span>\"^2.1.2\"</span>\n  <span>}</span><span>,</span>\n  <span>\"scripts\"</span><span>:</span> <span>{</span>\n    <span>\"test\"</span><span>:</span> <span>\"promises-aplus-tests MyPromise\"</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"执行测试命令\"> 执行测试命令</h3>\n<div><pre><code><span>npm</span> run <span>test</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>发现结果是：</p>\n<div><pre><code><span>866</span> passing <span>(</span>34s<span>)</span>\n  <span>6</span> failing\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>官方一共有 872 个测试用例，通过了 866 个，有 6 个没通过。</p>\n<p><strong>不要慌</strong>，哪几个没通过它给出了提示：</p>\n<div><pre><code><span>1</span><span>)</span> <span>2.2</span>.2: If <span><span>`</span>onFulfilled<span>`</span></span> is a function, <span>2.2</span>.2.2: it must not be called before <span><span>`</span>promise<span>`</span></span> is fulfilled fulfilled after a delay:\n\n<span>2</span><span>)</span> <span>2.2</span>.3: If <span><span>`</span>onRejected<span>`</span></span> is a function, <span>2.2</span>.3.2: it must not be called before <span><span>`</span>promise<span>`</span></span> is rejected rejected after a delay:\n\n<span>3</span><span>)</span> <span>2.2</span>.4: <span><span>`</span>onFulfilled<span>`</span></span> or <span><span>`</span>onRejected<span>`</span></span> must not be called <span>until</span> the execution context stack contains only platform code. Clean-stack execution ordering tests <span>(</span>fulfillment <span>case</span><span>)</span> when <span><span>`</span>on\nFulfilled<span>`</span></span> is added immediately before the promise is fulfilled:\n\n<span>4</span><span>)</span> <span>2.2</span>.4: <span><span>`</span>onFulfilled<span>`</span></span> or <span><span>`</span>onRejected<span>`</span></span> must not be called <span>until</span> the execution context stack contains only platform code. Clean-stack execution ordering tests <span>(</span>fulfillment <span>case</span><span>)</span> when the\n promise is fulfilled asynchronously:\n\n<span>5</span><span>)</span> <span>2.2</span>.4: <span><span>`</span>onFulfilled<span>`</span></span> or <span><span>`</span>onRejected<span>`</span></span> must not be called <span>until</span> the execution context stack contains only platform code. Clean-stack execution ordering tests <span>(</span>rejection <span>case</span><span>)</span> when <span><span>`</span>onRe\njected<span>`</span></span> is added immediately before the promise is rejected:\n\n<span>6</span><span>)</span> <span>2.2</span>.4: <span><span>`</span>onFulfilled<span>`</span></span> or <span><span>`</span>onRejected<span>`</span></span> must not be called <span>until</span> the execution context stack contains only platform code. Clean-stack execution ordering tests <span>(</span>rejection <span>case</span><span>)</span> when the p\nromise is rejected asynchronously:\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>这个错误提示语很明确了，前面那么多代码写下来，自然而然就能想到跟事件循环有关，对着规范打一下补丁试试看。</p>\n<h3 id=\"修补最后一个-bug\"> 修补最后一个 bug</h3>\n<div><div><br><br><div>&nbsp;</div><br><br><br><div>&nbsp;</div><br><br><br><br><br><div>&nbsp;</div><br><br><br><div>&nbsp;</div><br><br><br></div><pre><code>    <span>const</span> <span>resolve</span> <span>=</span> <span>(</span><span>value</span><span>)</span> <span>=></span> <span>{</span>\n      <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>PENDING</span><span>)</span> <span>{</span>\n        <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n          <span>this</span><span>.</span>status <span>=</span> <span>FULFILLED</span><span>;</span>\n          <span>this</span><span>.</span>value <span>=</span> value<span>;</span>\n          <span>this</span><span>.</span>onFulfilledCallbacks<span>.</span><span>forEach</span><span>(</span><span>fn</span> <span>=></span> <span>fn</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span><span>,</span> <span>0</span><span>)</span>\n      <span>}</span>\n    <span>}</span>\n\n    <span>const</span> <span>reject</span> <span>=</span> <span>(</span><span>reason</span><span>)</span> <span>=></span> <span>{</span>\n      <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>PENDING</span><span>)</span> <span>{</span>\n        <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n          <span>this</span><span>.</span>status <span>=</span> <span>REJECTED</span><span>;</span>\n          <span>this</span><span>.</span>reason <span>=</span> reason<span>;</span>\n          <span>this</span><span>.</span>onRejectedCallbacks<span>.</span><span>forEach</span><span>(</span><span>fn</span> <span>=></span> <span>fn</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span><span>,</span> <span>0</span><span>)</span>\n      <span>}</span>\n    <span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>为什么 resolve 和 reject 要加 setTimeout？</p>\n<p>根据规范的 <a href=\"https://promisesaplus.com/#point-34\" target=\"_blank\" rel=\"noopener noreferrer\">2.2.4</a> 所述：onFulfilled 和 onRejected 只允许在 execution context 栈仅包含平台代码时运行。</p>\n<ul>\n<li>这里的平台代码指的是引擎、环境以及 promise 的实施代码。实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。</li>\n<li>这个事件队列可以采用宏任务（macro-task）机制，比如 setTimeout 或者 setImmediate；也可以采用微任务（micro-task）机制来实现，比如 MutationObserver 或者 process.nextTick。</li>\n</ul>\n<h3 id=\"再次执行测试命令\"> 再次执行测试命令</h3>\n<div><pre><code><span>npm</span> run <span>test</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>发现结果是：</p>\n<div><pre><code><span>872</span> passing <span>(</span>49s<span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>Promises/A+ 官方测试总共 872 用例，我们手写的 MyPromise 现在完美通过了所有用例</strong>，棒！撒花！！！</p>\n<h2 id=\"promise-其他扩展方法\"> Promise 其他扩展方法</h2>\n<p>在 ES6 的官方 Promise 还有很多 API，比如：</p>\n<ul>\n<li>Promise.resolve</li>\n<li>Promise.reject</li>\n<li>Promise.prototype.catch</li>\n<li>Promise.prototype.finally</li>\n<li>Promise.all</li>\n<li>Promise.allSettled</li>\n<li>Promise.any</li>\n<li>Promise.race</li>\n</ul>\n<p>虽然这些都不在 Promises/A+ 规范里面，但是我们也来实现一下吧，加深理解。其实我们前面我们用了很大功夫实现了 Promises/A+，现在再来实现这些已经是小菜一碟了，因为这些 API 全部是前面的封装而已。</p>\n<h3 id=\"实现-promise-resolve\"> 实现 Promise.resolve</h3>\n<p>方法介绍：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve\" target=\"_blank\" rel=\"noopener noreferrer\">Promise.resolve()</a></p>\n<p>这是一个静态方法，什么是静态方法呢？</p>\n<p>类（class）通过 <code>static</code> 关键字定义静态方法。不能在类的实例上调用静态方法，而应该通过类本身调用。这些通常是实用程序方法，例如创建或克隆对象的功能。</p>\n<p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上 <code>static</code> 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为「静态方法」。</p>\n<p>手写实现：</p>\n<div><pre><code><span>class</span> <span>MyPromise</span> <span>{</span>\n  <span>constructor</span> <span>(</span><span>executor</span><span>)</span> <span>{</span>\n    <span>// ...</span>\n  <span>}</span>\n\n  <span>// 定义 then 方法</span>\n  <span>then</span> <span>(</span><span>onFulfilled<span>,</span> onRejected</span><span>)</span> <span>{</span>\n    <span>// ...</span>\n  <span>}</span>\n\n  <span>// 用 then 模拟 catch</span>\n  <span>// catch 本身是 then 的一个语法糖</span>\n  <span>catch</span> <span>(</span>errorCallback<span>)</span> <span>{</span>\n    <span>// ...</span>\n  <span>}</span>\n\n  <span>/**\n   * Promise.resolve()\n   * @param {[type]} value 要解析为 Promise 对象的值 \n  */</span>\n  <span>static</span> <span>resolve</span><span>(</span><span>value</span><span>)</span> <span>{</span>\n    <span>// 如果这个值是一个 promise, 那么将返回这个 promise</span>\n    <span>if</span> <span>(</span>value <span>instanceof</span> <span>MyPromise</span><span>)</span> <span>{</span>\n      <span>return</span> value<span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span>value <span>instanceof</span> <span>Object</span> <span>&amp;&amp;</span> <span>'then'</span> <span>in</span> value<span>)</span> <span>{</span>\n      <span>// 如果这个值是 thenable(即带有 then 方法), 返回的 promise 会跟随这个 thenable 的对象, 采用它的最终状态</span>\n      <span>return</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n        value<span>.</span><span>then</span><span>(</span>resolve<span>,</span> reject<span>)</span><span>;</span>\n      <span>}</span><span>)</span>\n    <span>}</span>\n\n    <span>// 否则返回的 promise 将以此值完成, 即以此值执行 resolve() 方法(状态为 fulfilled)</span>\n    <span>return</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve</span><span>)</span> <span>=></span> <span>{</span>\n      <span>resolve</span><span>(</span>value<span>)</span>\n    <span>}</span><span>)</span>\n  <span>}</span>\n\n<span>}</span>\n\n<span>function</span> <span>resolvePromise</span><span>(</span><span>promise2<span>,</span> x<span>,</span> resolve<span>,</span> reject</span><span>)</span> <span>{</span>\n  <span>// ...</span>\n<span>}</span>\n\nmodule<span>.</span>exports <span>=</span> MyPromise<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><p>测试用例：</p>\n<div><pre><code><span>const</span> MyPromise <span>=</span> <span>require</span><span>(</span><span>'./MyPromise'</span><span>)</span><span>;</span>\n\n<span>const</span> promise1 <span>=</span> MyPromise<span>.</span><span>resolve</span><span>(</span><span>123</span><span>)</span><span>;</span>\n\npromise1<span>.</span><span>then</span><span>(</span><span>(</span><span>value</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>value<span>)</span><span>;</span>\n  <span>// expected output: 123</span>\n<span>}</span><span>)</span><span>;</span>\n\n<span>// Resolve 一个 thenable 对象</span>\n<span>let</span> p1 <span>=</span> MyPromise<span>.</span><span>resolve</span><span>(</span><span>{</span>\n  <span>then</span><span>:</span> <span>function</span> <span>(</span><span>onFulfill</span><span>)</span> <span>{</span>\n    <span>onFulfill</span><span>(</span><span>\"Resolving\"</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>p1 <span>instanceof</span> <span>MyPromise</span><span>)</span> <span>// true, 这是一个 Promise 对象</span>\n\n<span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'p1 :>> '</span><span>,</span> p1<span>)</span><span>;</span>\n<span>}</span><span>,</span> <span>1000</span><span>)</span><span>;</span>\n\np1<span>.</span><span>then</span><span>(</span><span>function</span> <span>(</span><span>v</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>v<span>)</span><span>;</span> <span>// 输出\"fulfilled!\"</span>\n<span>}</span><span>,</span> <span>function</span> <span>(</span><span>e</span><span>)</span> <span>{</span>\n  <span>// 不会被调用</span>\n<span>}</span><span>)</span><span>;</span>\n\n<span>// Thenable 在 callback 之前抛出异常</span>\n<span>// MyPromise rejects</span>\n<span>let</span> thenable <span>=</span> <span>{</span>\n  <span>then</span><span>:</span> <span>function</span> <span>(</span><span>resolve</span><span>)</span> <span>{</span>\n    <span>throw</span> <span>new</span> <span>TypeError</span><span>(</span><span>\"Throwing\"</span><span>)</span><span>;</span>\n    <span>resolve</span><span>(</span><span>\"Resolving\"</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span><span>;</span>\n\n<span>let</span> p2 <span>=</span> MyPromise<span>.</span><span>resolve</span><span>(</span>thenable<span>)</span><span>;</span>\np2<span>.</span><span>then</span><span>(</span><span>function</span> <span>(</span><span>v</span><span>)</span> <span>{</span>\n  <span>// 不会被调用</span>\n<span>}</span><span>,</span> <span>function</span> <span>(</span><span>e</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>e<span>)</span><span>;</span> <span>// TypeError: Throwing</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><p>输出结果：</p>\n<div><pre><code><span>true</span>\n<span>123</span>\nResolving\nTypeError: Throwing\np1 :<span>>></span> MyPromise <span>{</span>PromiseState: <span>'fulfilled'</span>, PromiseResult: <span>'Resolving'</span>, onFulfilledCallbacks: Array<span>(</span><span>1</span><span>)</span>, onRejectedCallbacks: Array<span>(</span><span>1</span><span>)</span><span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"实现-promise-reject\"> 实现 Promise.reject</h3>\n<p>方法介绍：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject\" target=\"_blank\" rel=\"noopener noreferrer\">Promise.reject()</a></p>\n<p>手写实现：</p>\n<div><pre><code><span>class</span> <span>MyPromise</span> <span>{</span>\n  <span>constructor</span> <span>(</span><span>executor</span><span>)</span> <span>{</span>\n    <span>// ...</span>\n  <span>}</span>\n\n  <span>// 定义 then 方法</span>\n  <span>then</span> <span>(</span><span>onFulfilled<span>,</span> onRejected</span><span>)</span> <span>{</span>\n    <span>// ...</span>\n  <span>}</span>\n\n  <span>// 用 then 模拟 catch</span>\n  <span>// catch 本身是 then 的一个语法糖</span>\n  <span>catch</span> <span>(</span>errorCallback<span>)</span> <span>{</span>\n    <span>// ...</span>\n  <span>}</span>\n\n  <span>/**\n   * Promise.reject()\n   * @param {*} reason 表示 Promise 被拒绝的原因\n   * @returns \n  */</span>\n  <span>static</span> <span>reject</span><span>(</span><span>reason</span><span>)</span> <span>{</span>\n    <span>return</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n      <span>reject</span><span>(</span>reason<span>)</span><span>;</span>\n    <span>}</span><span>)</span>\n  <span>}</span>\n\n<span>}</span>\n\n<span>function</span> <span>resolvePromise</span><span>(</span><span>promise2<span>,</span> x<span>,</span> resolve<span>,</span> reject</span><span>)</span> <span>{</span>\n  <span>// ...</span>\n<span>}</span>\n\nmodule<span>.</span>exports <span>=</span> MyPromise<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><p>测试用例：</p>\n<div><pre><code><span>const</span> MyPromise <span>=</span> <span>require</span><span>(</span><span>'./MyPromise'</span><span>)</span><span>;</span>\n\nMyPromise<span>.</span><span>reject</span><span>(</span><span>new</span> <span>Error</span><span>(</span><span>'fail'</span><span>)</span><span>)</span><span>.</span><span>then</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>\n  <span>// not called</span>\n<span>}</span><span>,</span> <span>function</span> <span>(</span><span>error</span><span>)</span> <span>{</span>\n  console<span>.</span><span>error</span><span>(</span>error<span>)</span><span>;</span> <span>// Error: fail</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>输出结果：</p>\n<div><pre><code>Error: fail\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"实现-promise-prototype-catch\"> 实现 Promise.prototype.catch</h3>\n<p>方法介绍：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch\" target=\"_blank\" rel=\"noopener noreferrer\">Promise.prototype.catch()</a></p>\n<p>这个方法其实在前面已经实现过了。</p>\n<p>事实上，我们显式使用 <code>obj.catch(onRejected)</code>，内部实际调用的是 <code>obj.then(undefined, onRejected)</code>。</p>\n<p><code>Promise.prototype.catch()</code> 方法是 <code>.then(null, rejection)</code> 或 <code>.then(undefined, rejection)</code> 的别名，用于指定发生错误时的回调函数。</p>\n<p>测试用例：</p>\n<div><pre><code><span>const</span> MyPromise <span>=</span> <span>require</span><span>(</span><span>'./MyPromise'</span><span>)</span><span>;</span>\n\n<span>let</span> p1 <span>=</span> <span>new</span> <span>MyPromise</span><span>(</span><span>function</span> <span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>{</span>\n  <span>resolve</span><span>(</span><span>'Success'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n\np1<span>.</span><span>then</span><span>(</span><span>function</span> <span>(</span><span>value</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>value<span>)</span><span>;</span> <span>// \"Success!\"</span>\n  <span>throw</span> <span>'oh, no!'</span><span>;</span>\n<span>}</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>function</span> <span>(</span><span>e</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>e<span>)</span><span>;</span> <span>// \"oh, no!\"</span>\n<span>}</span><span>)</span><span>.</span><span>then</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'after a catch the chain is restored'</span><span>)</span><span>;</span>\n<span>}</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'Not fired due to the catch'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n\n<span>// 以下行为与上述相同</span>\np1<span>.</span><span>then</span><span>(</span><span>function</span> <span>(</span><span>value</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>value<span>)</span><span>;</span> <span>// \"Success!\"</span>\n  <span>return</span> Promise<span>.</span><span>reject</span><span>(</span><span>'oh, no!'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>function</span> <span>(</span><span>e</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>e<span>)</span><span>;</span> <span>// \"oh, no!\"</span>\n<span>}</span><span>)</span><span>.</span><span>then</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'after a catch the chain is restored'</span><span>)</span><span>;</span>\n<span>}</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'Not fired due to the catch'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n\n<span>// 捕获异常</span>\n<span>const</span> p2 <span>=</span> <span>new</span> <span>MyPromise</span><span>(</span><span>function</span> <span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>{</span>\n  <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>'test'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\np2<span>.</span><span>catch</span><span>(</span><span>function</span> <span>(</span><span>error</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>error<span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n<span>// Error: test</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><p>输出结果：</p>\n<div><pre><code>Success\nSuccess\nError: <span>test</span>\noh, no<span>!</span>\noh, no<span>!</span>\nafter a catch the chain is restored\nafter a catch the chain is restored\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"实现-promise-prototype-finally\"> 实现 Promise.prototype.finally</h3>\n<p>方法介绍：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally\" target=\"_blank\" rel=\"noopener noreferrer\">Promise.prototype.finally()</a></p>\n<p>该方法是 ES2018 引入标准的。</p>\n<p>由于无法知道 promise 的最终状态，所以 finally 的回调函数中不接收任何参数，它仅用于无论最终结果如何都要执行的情况。</p>\n<p>手写实现：</p>\n<div><pre><code><span>class</span> <span>MyPromise</span> <span>{</span>\n  <span>constructor</span> <span>(</span><span>executor</span><span>)</span> <span>{</span>\n    <span>// ...</span>\n  <span>}</span>\n\n  <span>// 定义 then 方法</span>\n  <span>then</span> <span>(</span><span>onFulfilled<span>,</span> onRejected</span><span>)</span> <span>{</span>\n    <span>// ...</span>\n  <span>}</span>\n\n  <span>// 用 then 模拟 catch</span>\n  <span>// catch 本身是 then 的一个语法糖</span>\n  <span>catch</span> <span>(</span>errorCallback<span>)</span> <span>{</span>\n    <span>// ...</span>\n  <span>}</span>\n\n  <span>/**\n   * finally\n   * @param {*} callBack 无论结果是 fulfilled 或者是 rejected, 都会执行的回调函数\n   * @returns \n  */</span>\n  <span>finally</span><span>(</span>callBack<span>)</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span><span>then</span><span>(</span>callBack<span>,</span> callBack<span>)</span>\n  <span>}</span>\n\n<span>}</span>\n\n<span>function</span> <span>resolvePromise</span><span>(</span><span>promise2<span>,</span> x<span>,</span> resolve<span>,</span> reject</span><span>)</span> <span>{</span>\n  <span>// ...</span>\n<span>}</span>\n\nmodule<span>.</span>exports <span>=</span> MyPromise<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>测试用例：</p>\n<div><pre><code><span>const</span> MyPromise <span>=</span> <span>require</span><span>(</span><span>'./MyPromise'</span><span>)</span><span>;</span>\n\n<span>let</span> p1 <span>=</span> <span>new</span> <span>MyPromise</span><span>(</span><span>function</span> <span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>{</span>\n  <span>resolve</span><span>(</span><span>1</span><span>)</span>\n<span>}</span><span>)</span><span>.</span><span>then</span><span>(</span><span>function</span> <span>(</span><span>value</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>value<span>)</span><span>;</span>\n<span>}</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>function</span> <span>(</span><span>e</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>e<span>)</span><span>;</span>\n<span>}</span><span>)</span><span>.</span><span>finally</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'finally'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>输出结果：</p>\n<div><pre><code><span>1</span>\nfinally\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"实现-promise-all\"> 实现 Promise.all</h3>\n<p>方法介绍：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all\" target=\"_blank\" rel=\"noopener noreferrer\">Promise.all()</a></p>\n<p>手写实现：</p>\n<div><pre><code><span>class</span> <span>MyPromise</span> <span>{</span>\n  <span>constructor</span> <span>(</span><span>executor</span><span>)</span> <span>{</span>\n    <span>// ...</span>\n  <span>}</span>\n\n  <span>// 定义 then 方法</span>\n  <span>then</span> <span>(</span><span>onFulfilled<span>,</span> onRejected</span><span>)</span> <span>{</span>\n    <span>// ...</span>\n  <span>}</span>\n\n  <span>// 用 then 模拟 catch</span>\n  <span>// catch 本身是 then 的一个语法糖</span>\n  <span>catch</span> <span>(</span>errorCallback<span>)</span> <span>{</span>\n    <span>// ...</span>\n  <span>}</span>\n\n  <span>/**\n   * Promise.all()\n   * @param {iterable} promises 一个 promise 的 iterable 类型(注: Array, Map, Set 都属于 ES6 的 iterable 类型)的输入\n   * @returns\n   */</span>\n  <span>static</span> <span>all</span><span>(</span><span>promises</span><span>)</span> <span>{</span>\n    <span>return</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n      <span>// 参数校验</span>\n      <span>if</span> <span>(</span>Array<span>.</span><span>isArray</span><span>(</span>promises<span>)</span><span>)</span> <span>{</span>\n        <span>let</span> result <span>=</span> <span>[</span><span>]</span><span>;</span> <span>// 存储结果</span>\n        <span>let</span> count <span>=</span> <span>0</span><span>;</span> <span>// 计数器</span>\n\n        <span>// 如果传入的参数是一个空的可迭代对象，则返回一个已完成（already resolved）状态的 Promise</span>\n        <span>if</span> <span>(</span>promises<span>.</span>length <span>===</span> <span>0</span><span>)</span> <span>{</span>\n          <span>return</span> <span>resolve</span><span>(</span>promises<span>)</span><span>;</span>\n        <span>}</span>\n\n        promises<span>.</span><span>forEach</span><span>(</span><span>(</span><span>item<span>,</span> index</span><span>)</span> <span>=></span> <span>{</span>\n          <span>// MyPromise.resolve方法中已经判断了参数是否为promise与thenable对象，所以无需在该方法中再次判断</span>\n          MyPromise<span>.</span><span>resolve</span><span>(</span>item<span>)</span><span>.</span><span>then</span><span>(</span>\n            <span>value</span> <span>=></span> <span>{</span>\n              count<span>++</span><span>;</span>\n              <span>// 每个promise执行的结果存储在result中</span>\n              result<span>[</span>index<span>]</span> <span>=</span> value<span>;</span>\n              <span>// Promise.all 等待所有都完成（或第一个失败）</span>\n              count <span>===</span> promises<span>.</span>length <span>&amp;&amp;</span> <span>resolve</span><span>(</span>result<span>)</span><span>;</span>\n            <span>}</span><span>,</span>\n            <span>reason</span> <span>=></span> <span>{</span>\n              <span>/**\n               * 如果传入的 promise 中有一个失败(rejected),\n               * Promise.all 异步地将失败的那个结果给失败状态的回调函数，而不管其它 promise 是否完成\n               */</span>\n              <span>reject</span><span>(</span>reason<span>)</span><span>;</span>\n            <span>}</span>\n          <span>)</span>\n        <span>}</span><span>)</span>\n      <span>}</span> <span>else</span> <span>{</span>\n        <span>return</span> <span>reject</span><span>(</span><span>new</span> <span>TypeError</span><span>(</span><span>'Argument is not iterable'</span><span>)</span><span>)</span>\n      <span>}</span>\n    <span>}</span><span>)</span>\n  <span>}</span>\n\n<span>}</span>\n\n<span>function</span> <span>resolvePromise</span><span>(</span><span>promise2<span>,</span> x<span>,</span> resolve<span>,</span> reject</span><span>)</span> <span>{</span>\n  <span>// ...</span>\n<span>}</span>\n\nmodule<span>.</span>exports <span>=</span> MyPromise<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br></div></div><p>测试用例：</p>\n<div><pre><code><span>const</span> MyPromise <span>=</span> <span>require</span><span>(</span><span>'./MyPromise'</span><span>)</span><span>;</span>\n\n<span>const</span> promise1 <span>=</span> MyPromise<span>.</span><span>resolve</span><span>(</span><span>3</span><span>)</span><span>;</span>\n<span>const</span> promise2 <span>=</span> <span>42</span><span>;</span>\n<span>const</span> promise3 <span>=</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>setTimeout</span><span>(</span>resolve<span>,</span> <span>100</span><span>,</span> <span>'foo'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n\nMyPromise<span>.</span><span>all</span><span>(</span><span>[</span>promise1<span>,</span> promise2<span>,</span> promise3<span>]</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>values</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>values<span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n<span>// expected output: Array [3, 42, \"foo\"]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>输出结果：</p>\n<div><pre><code><span>(</span><span>3</span><span>)</span> <span>[</span><span>3</span>, <span>42</span>, <span>'foo'</span><span>]</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>测试 Promise.all 的快速返回失败行为：</p>\n<p>Promise.all 在任意一个传入的 promise 失败时返回失败。例如，如果你传入的 promise 中，有四个 promise 在一定的时间之后调用成功函数，有一个立即调用失败函数，那么 Promise.all 将立即变为失败。</p>\n<div><pre><code><span>const</span> MyPromise <span>=</span> <span>require</span><span>(</span><span>'./MyPromise'</span><span>)</span><span>;</span>\n\n<span>let</span> p1 <span>=</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>setTimeout</span><span>(</span>resolve<span>,</span> <span>1000</span><span>,</span> <span>'one'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n<span>let</span> p2 <span>=</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>setTimeout</span><span>(</span>resolve<span>,</span> <span>2000</span><span>,</span> <span>'two'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n<span>let</span> p3 <span>=</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>setTimeout</span><span>(</span>resolve<span>,</span> <span>3000</span><span>,</span> <span>'three'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n<span>let</span> p4 <span>=</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>setTimeout</span><span>(</span>resolve<span>,</span> <span>4000</span><span>,</span> <span>'four'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n<span>let</span> p5 <span>=</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>reject</span><span>(</span><span>'reject'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n\nMyPromise<span>.</span><span>all</span><span>(</span><span>[</span>p1<span>,</span> p2<span>,</span> p3<span>,</span> p4<span>,</span> p5<span>]</span><span>)</span><span>.</span><span>then</span><span>(</span><span>values</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>values<span>)</span><span>;</span>\n<span>}</span><span>,</span> <span>reason</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>reason<span>)</span>\n<span>}</span><span>)</span><span>;</span>\n\n<span>//From console:</span>\n<span>//\"reject\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>输出结果：</p>\n<div><pre><code>reject\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"实现-promise-allsettled\"> 实现 Promise.allSettled</h3>\n<p>方法介绍：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled\" target=\"_blank\" rel=\"noopener noreferrer\">Promise.allSettled()</a></p>\n<p>手写实现：</p>\n<div><pre><code><span>class</span> <span>MyPromise</span> <span>{</span>\n  <span>constructor</span> <span>(</span><span>executor</span><span>)</span> <span>{</span>\n    <span>// ...</span>\n  <span>}</span>\n\n  <span>// 定义 then 方法</span>\n  <span>then</span> <span>(</span><span>onFulfilled<span>,</span> onRejected</span><span>)</span> <span>{</span>\n    <span>// ...</span>\n  <span>}</span>\n\n  <span>// 用 then 模拟 catch</span>\n  <span>// catch 本身是 then 的一个语法糖</span>\n  <span>catch</span> <span>(</span>errorCallback<span>)</span> <span>{</span>\n    <span>// ...</span>\n  <span>}</span>\n\n  <span>/**\n   * Promise.allSettled()\n   * @param {iterable} promises 一个 promise 的 iterable 类型(注: Array, Map, Set 都属于 ES6 的 iterable 类型)的输入\n   * @returns\n   */</span>\n  <span>static</span> <span>allSettled</span><span>(</span><span>promises</span><span>)</span> <span>{</span>\n    <span>return</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n      <span>// 参数校验</span>\n      <span>if</span> <span>(</span>Array<span>.</span><span>isArray</span><span>(</span>promises<span>)</span><span>)</span> <span>{</span>\n        <span>let</span> result <span>=</span> <span>[</span><span>]</span><span>;</span> <span>// 存储结果</span>\n        <span>let</span> count <span>=</span> <span>0</span><span>;</span>   <span>// 计数器</span>\n\n        <span>// 如果传入的是一个空数组, 那么就直接返回一个 resolved 的空数组 promise 对象</span>\n        <span>if</span> <span>(</span>promises<span>.</span>length <span>===</span> <span>0</span><span>)</span> <span>return</span> <span>resolve</span><span>(</span>promises<span>)</span><span>;</span>\n\n        promises<span>.</span><span>forEach</span><span>(</span><span>(</span><span>item<span>,</span> index</span><span>)</span> <span>=></span> <span>{</span>\n          <span>// 非 promise 值, 通过 Promise.resolve 转换为 promise 进行统一处理</span>\n          MyPromise<span>.</span><span>resolve</span><span>(</span>item<span>)</span><span>.</span><span>then</span><span>(</span>\n            <span>value</span> <span>=></span> <span>{</span>\n              count<span>++</span><span>;</span>\n              <span>// 对于每个结果对象, 都有一个 status 字符串. 如果它的值为 fulfilled, 则结果对象上存在一个 value</span>\n              result<span>[</span>index<span>]</span> <span>=</span> <span>{</span>\n                status<span>:</span> <span>'fulfilled'</span><span>,</span>\n                value\n              <span>}</span>\n              <span>// 所有给定的 promise 都已经 fulfilled 或 rejected 后, 返回这个 promise</span>\n              count <span>===</span> promises<span>.</span>length <span>&amp;&amp;</span> <span>resolve</span><span>(</span>result<span>)</span><span>;</span>\n            <span>}</span><span>,</span>\n            <span>reason</span> <span>=></span> <span>{</span>\n              count<span>++</span><span>;</span>\n              <span>/**\n               * 对于每个结果对象, 都有一个 status 字符串. 如果值为 rejected, 则存在一个 reason\n               * value(或 reason)反映了每个 promise 决议(或拒绝)的值\n               */</span>\n              result<span>[</span>index<span>]</span> <span>=</span> <span>{</span>\n                status<span>:</span> <span>'rejected'</span><span>,</span>\n                reason\n              <span>}</span>\n              <span>// 所有给定的promise都已经fulfilled或rejected后,返回这个promise</span>\n              count <span>===</span> promises<span>.</span>length <span>&amp;&amp;</span> <span>resolve</span><span>(</span>result<span>)</span><span>;</span>\n            <span>}</span>\n          <span>)</span>\n        <span>}</span><span>)</span>\n      <span>}</span> <span>else</span> <span>{</span>\n        <span>return</span> <span>reject</span><span>(</span><span>new</span> <span>TypeError</span><span>(</span><span>'Argument is not iterable'</span><span>)</span><span>)</span>\n      <span>}</span>\n    <span>}</span><span>)</span>\n  <span>}</span>\n\n<span>}</span>\n\n<span>function</span> <span>resolvePromise</span><span>(</span><span>promise2<span>,</span> x<span>,</span> resolve<span>,</span> reject</span><span>)</span> <span>{</span>\n  <span>// ...</span>\n<span>}</span>\n\nmodule<span>.</span>exports <span>=</span> MyPromise<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br></div></div><p>测试用例：</p>\n<div><pre><code><span>const</span> MyPromise <span>=</span> <span>require</span><span>(</span><span>'./MyPromise'</span><span>)</span><span>;</span>\n\n<span>const</span> promise1 <span>=</span> MyPromise<span>.</span><span>resolve</span><span>(</span><span>3</span><span>)</span><span>;</span>\n<span>const</span> promise2 <span>=</span> <span>1</span><span>;</span>\n<span>const</span> promises <span>=</span> <span>[</span>promise1<span>,</span> promise2<span>]</span><span>;</span>\n\nMyPromise<span>.</span><span>allSettled</span><span>(</span>promises<span>)</span><span>.</span>\n<span>then</span><span>(</span><span>(</span><span>results</span><span>)</span> <span>=></span> results<span>.</span><span>forEach</span><span>(</span><span>(</span><span>result</span><span>)</span> <span>=></span> console<span>.</span><span>log</span><span>(</span>result<span>)</span><span>)</span><span>)</span><span>;</span>\n\n<span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>const</span> p1 <span>=</span> MyPromise<span>.</span><span>resolve</span><span>(</span><span>3</span><span>)</span><span>;</span>\n  <span>const</span> p2 <span>=</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>setTimeout</span><span>(</span>reject<span>,</span> <span>100</span><span>,</span> <span>'foo'</span><span>)</span><span>)</span><span>;</span>\n  <span>const</span> ps <span>=</span> <span>[</span>p1<span>,</span> p2<span>]</span><span>;</span>\n\n  MyPromise<span>.</span><span>allSettled</span><span>(</span>ps<span>)</span><span>.</span>\n  <span>then</span><span>(</span><span>(</span><span>results</span><span>)</span> <span>=></span> results<span>.</span><span>forEach</span><span>(</span><span>(</span><span>result</span><span>)</span> <span>=></span> console<span>.</span><span>log</span><span>(</span>result<span>)</span><span>)</span><span>)</span><span>;</span>\n<span>}</span><span>,</span> <span>1000</span><span>)</span><span>;</span>\n\nMyPromise<span>.</span><span>allSettled</span><span>(</span><span>[</span><span>]</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>results</span><span>)</span> <span>=></span> console<span>.</span><span>log</span><span>(</span>results<span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>输出结果：</p>\n<div><pre><code><span>(</span><span>0</span><span>)</span> <span>[</span><span>]</span>\n<span>{</span>status: <span>'fulfilled'</span>, value: <span>3</span><span>}</span>\n<span>{</span>status: <span>'fulfilled'</span>, value: <span>1</span><span>}</span>\n<span>{</span>status: <span>'fulfilled'</span>, value: <span>3</span><span>}</span>\n<span>{</span>status: <span>'rejected'</span>, reason: <span>'foo'</span><span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"实现-promise-any\"> 实现 Promise.any</h3>\n<p>方法介绍：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/any\" target=\"_blank\" rel=\"noopener noreferrer\">Promise.any()</a></p>\n<p>本质上，这个方法和 Promise.all() 是相反的。</p>\n<blockquote>\n<p>注意：Promise.any() 方法依然是实验性的，尚未被所有的浏览器完全支持。它当前处于 TC39 第四阶段草案（Stage 4）。</p>\n</blockquote>\n<p>手写实现：</p>\n<div><pre><code><span>class</span> <span>MyPromise</span> <span>{</span>\n  <span>constructor</span> <span>(</span><span>executor</span><span>)</span> <span>{</span>\n    <span>// ...</span>\n  <span>}</span>\n\n  <span>// 定义 then 方法</span>\n  <span>then</span> <span>(</span><span>onFulfilled<span>,</span> onRejected</span><span>)</span> <span>{</span>\n    <span>// ...</span>\n  <span>}</span>\n\n  <span>// 用 then 模拟 catch</span>\n  <span>// catch 本身是 then 的一个语法糖</span>\n  <span>catch</span> <span>(</span>errorCallback<span>)</span> <span>{</span>\n    <span>// ...</span>\n  <span>}</span>\n\n  <span>/**\n   * Promise.any()\n   * @param {iterable} promises 一个 promise 的 iterable 类型(注: Array, Map, Set 都属于 ES6 的 iterable 类型)的输入\n   * @returns\n   */</span>\n  <span>static</span> <span>any</span><span>(</span><span>promises</span><span>)</span> <span>{</span>\n    <span>return</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n      <span>// 参数校验</span>\n      <span>if</span> <span>(</span>Array<span>.</span><span>isArray</span><span>(</span>promises<span>)</span><span>)</span> <span>{</span>\n        <span>let</span> errors <span>=</span> <span>[</span><span>]</span><span>;</span> <span>// </span>\n        <span>let</span> count <span>=</span> <span>0</span><span>;</span> <span>// 计数器</span>\n\n        <span>// 如果传入的参数是一个空的可迭代对象, 则返回一个已失败(already rejected)状态的 Promise</span>\n        <span>if</span> <span>(</span>promises<span>.</span>length <span>===</span> <span>0</span><span>)</span> <span>return</span> <span>reject</span><span>(</span><span>new</span> <span>AggregateError</span><span>(</span><span>[</span><span>]</span><span>,</span> <span>'All promises were rejected'</span><span>)</span><span>)</span><span>;</span>\n\n        promises<span>.</span><span>forEach</span><span>(</span><span>item</span> <span>=></span> <span>{</span>\n          <span>// 非 Promise 值, 通过 Promise.resolve 转换为 Promise</span>\n          MyPromise<span>.</span><span>resolve</span><span>(</span>item<span>)</span><span>.</span><span>then</span><span>(</span>\n            <span>value</span> <span>=></span> <span>{</span>\n              <span>// 只要其中的一个 promise 成功, 就返回那个已经成功的 promise </span>\n              <span>resolve</span><span>(</span>value<span>)</span><span>;</span>\n            <span>}</span><span>,</span>\n            <span>reason</span> <span>=></span> <span>{</span>\n              count<span>++</span><span>;</span>\n              errors<span>.</span><span>push</span><span>(</span>reason<span>)</span><span>;</span>\n              <span>/**\n               * 如果可迭代对象中没有一个 promise 成功，就返回一个失败的 promise 和 AggregateError类型的实例,\n               * AggregateError是 Error 的一个子类, 用于把单一的错误集合在一起\n               */</span>\n              count <span>===</span> promises<span>.</span>length <span>&amp;&amp;</span> <span>reject</span><span>(</span><span>new</span> <span>AggregateError</span><span>(</span>errors<span>,</span> <span>'All promises were rejected'</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n          <span>)</span>\n        <span>}</span><span>)</span>\n      <span>}</span> <span>else</span> <span>{</span>\n        <span>return</span> <span>reject</span><span>(</span><span>new</span> <span>TypeError</span><span>(</span><span>'Argument is not iterable'</span><span>)</span><span>)</span>\n      <span>}</span>\n    <span>}</span><span>)</span>\n  <span>}</span>\n\n<span>}</span>\n\n<span>function</span> <span>resolvePromise</span><span>(</span><span>promise2<span>,</span> x<span>,</span> resolve<span>,</span> reject</span><span>)</span> <span>{</span>\n  <span>// ...</span>\n<span>}</span>\n\nmodule<span>.</span>exports <span>=</span> MyPromise<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br></div></div><p>测试用例：</p>\n<div><pre><code><span>const</span> MyPromise <span>=</span> <span>require</span><span>(</span><span>'./MyPromise'</span><span>)</span><span>;</span>\n\nconsole<span>.</span><span>log</span><span>(</span><span>new</span> <span>AggregateError</span><span>(</span><span>'All promises were rejected'</span><span>)</span><span>)</span><span>;</span>\n\nMyPromise<span>.</span><span>any</span><span>(</span><span>[</span><span>]</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>e</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>e<span>)</span><span>;</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><blockquote>\n<p>注意：和 Promise.any() 一样，这个 AggregateError 也是一个实验中的功能，处于 Stage 3 Draft（第三阶段草案）。</p>\n<p>因此需要使用 <code>node v16.13.0</code> 及以上版本才能支持，否则会报错。</p>\n</blockquote>\n<p>输出结果：</p>\n<div><pre><code>AggregateError\nAggregateError\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>用其他用例测试一下该方法：</p>\n<div><pre><code><span>const</span> MyPromise <span>=</span> <span>require</span><span>(</span><span>'./MyPromise'</span><span>)</span><span>;</span>\n\n<span>/**\n * 验证 Promise.any() 方法\n */</span>\n\n<span>// console.log(new AggregateError('All promises were rejected'));</span>\n\nMyPromise<span>.</span><span>any</span><span>(</span><span>[</span><span>]</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>e</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>e<span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n\n<span>const</span> pErr <span>=</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>reject</span><span>(</span><span>\"总是失败\"</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n\n<span>const</span> pSlow <span>=</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>setTimeout</span><span>(</span>resolve<span>,</span> <span>500</span><span>,</span> <span>\"最终完成\"</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n\n<span>const</span> pFast <span>=</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>setTimeout</span><span>(</span>resolve<span>,</span> <span>100</span><span>,</span> <span>\"很快完成\"</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n\nMyPromise<span>.</span><span>any</span><span>(</span><span>[</span>pErr<span>,</span> pSlow<span>,</span> pFast<span>]</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>value</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>value<span>)</span><span>;</span>\n  <span>// 期望输出: \"很快完成\"</span>\n<span>}</span><span>)</span>\n\n\n<span>const</span> pErr1 <span>=</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>reject</span><span>(</span><span>\"总是失败\"</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n\n<span>const</span> pErr2 <span>=</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>reject</span><span>(</span><span>\"总是失败\"</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n\n<span>const</span> pErr3 <span>=</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>reject</span><span>(</span><span>\"总是失败\"</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n\nMyPromise<span>.</span><span>any</span><span>(</span><span>[</span>pErr1<span>,</span> pErr2<span>,</span> pErr3<span>]</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>e</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>e<span>)</span><span>;</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><p>输出结果：</p>\n<div><pre><code>AggregateError: All promises were rejected\nAggregateError: All promises were rejected\n很快完成\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"实现-promise-race\"> 实现 Promise.race()</h3>\n<p>方法介绍：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/race\" target=\"_blank\" rel=\"noopener noreferrer\">Promise.race()</a></p>\n<p>手写实现：</p>\n<div><pre><code><span>class</span> <span>MyPromise</span> <span>{</span>\n  <span>constructor</span> <span>(</span><span>executor</span><span>)</span> <span>{</span>\n    <span>// ...</span>\n  <span>}</span>\n\n  <span>// 定义 then 方法</span>\n  <span>then</span> <span>(</span><span>onFulfilled<span>,</span> onRejected</span><span>)</span> <span>{</span>\n    <span>// ...</span>\n  <span>}</span>\n\n  <span>// 用 then 模拟 catch</span>\n  <span>// catch 本身是 then 的一个语法糖</span>\n  <span>catch</span> <span>(</span>errorCallback<span>)</span> <span>{</span>\n    <span>// ...</span>\n  <span>}</span>\n\n  <span>/**\n   * Promise.race()\n   * @param {iterable} promises 可迭代对象, 类似 Array. 详见 iterable\n   * @returns\n   */</span>\n  <span>static</span> <span>race</span><span>(</span><span>promises</span><span>)</span> <span>{</span>\n    <span>return</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n      <span>// 参数校验</span>\n      <span>if</span> <span>(</span>Array<span>.</span><span>isArray</span><span>(</span>promises<span>)</span><span>)</span> <span>{</span>\n        <span>// 如果传入的迭代 promises 是空的, 则返回的 promise 将永远等待</span>\n        <span>if</span> <span>(</span>promises<span>.</span>length <span>></span> <span>0</span><span>)</span> <span>{</span>\n          promises<span>.</span><span>forEach</span><span>(</span><span>item</span> <span>=></span> <span>{</span>\n            <span>/**\n             * 如果迭代包含一个或多个非承诺值和/或已解决/拒绝的承诺,\n             * 则 Promise.race 将解析为迭代中找到的第一个值\n             */</span>\n            MyPromise<span>.</span><span>resolve</span><span>(</span>item<span>)</span><span>.</span><span>then</span><span>(</span>resolve<span>,</span> reject<span>)</span><span>;</span>\n          <span>}</span><span>)</span>\n        <span>}</span>\n      <span>}</span> <span>else</span> <span>{</span>\n        <span>return</span> <span>reject</span><span>(</span><span>new</span> <span>TypeError</span><span>(</span><span>'Argument is not iterable'</span><span>)</span><span>)</span>\n      <span>}</span>\n    <span>}</span><span>)</span>\n  <span>}</span>\n\n<span>}</span>\n\n<span>function</span> <span>resolvePromise</span><span>(</span><span>promise2<span>,</span> x<span>,</span> resolve<span>,</span> reject</span><span>)</span> <span>{</span>\n  <span>// ...</span>\n<span>}</span>\n\nmodule<span>.</span>exports <span>=</span> MyPromise<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div><p>测试用例：</p>\n<div><pre><code><span>const</span> MyPromise <span>=</span> <span>require</span><span>(</span><span>'./MyPromise'</span><span>)</span><span>;</span>\n\n<span>/**\n * 验证 Promise.race() 方法\n */</span>\n\n<span>// 数组全是非 Promise 值, 测试通过</span>\n<span>let</span> p1 <span>=</span> MyPromise<span>.</span><span>race</span><span>(</span><span>[</span><span>1</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>]</span><span>)</span><span>;</span>\n<span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'p1 :>> '</span><span>,</span> p1<span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n\n<span>// 空数组, 测试通过</span>\n<span>let</span> p2 <span>=</span> MyPromise<span>.</span><span>race</span><span>(</span><span>[</span><span>]</span><span>)</span><span>;</span>\n<span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'p2 :>> '</span><span>,</span> p2<span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n\n<span>const</span> p11 <span>=</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>setTimeout</span><span>(</span>resolve<span>,</span> <span>500</span><span>,</span> <span>'one'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n\n<span>const</span> p22 <span>=</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>setTimeout</span><span>(</span>resolve<span>,</span> <span>100</span><span>,</span> <span>'two'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n\n<span>// // 数组里有非Promise值, 测试通过</span>\nMyPromise<span>.</span><span>race</span><span>(</span><span>[</span>p11<span>,</span> p22<span>,</span> <span>10</span><span>]</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>value</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'p3 :>> '</span><span>,</span> value<span>)</span><span>;</span>\n  <span>// Both resolve, but p22 is faster</span>\n<span>}</span><span>)</span><span>;</span>\n<span>// expected output: 10</span>\n\n<span>// 数组里有'已解决的Promise' 和 非Promise值 测试通过</span>\n<span>let</span> p12 <span>=</span> MyPromise<span>.</span><span>resolve</span><span>(</span><span>'已解决的Promise'</span><span>)</span>\n<span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n  MyPromise<span>.</span><span>race</span><span>(</span><span>[</span>p12<span>,</span> p22<span>,</span> <span>10</span><span>]</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>value</span><span>)</span> <span>=></span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'p4 :>> '</span><span>,</span> value<span>)</span><span>;</span>\n  <span>}</span><span>)</span><span>;</span>\n  <span>// expected output:已解决的Promise</span>\n<span>}</span><span>)</span><span>;</span>\n\n<span>// Promise.race 的一般情况 测试通过</span>\n<span>const</span> p13 <span>=</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>setTimeout</span><span>(</span>resolve<span>,</span> <span>500</span><span>,</span> <span>'one'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n\n<span>const</span> p14 <span>=</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>setTimeout</span><span>(</span>resolve<span>,</span> <span>100</span><span>,</span> <span>'two'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n\nMyPromise<span>.</span><span>race</span><span>(</span><span>[</span>p13<span>,</span> p14<span>]</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>value</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'p5 :>> '</span><span>,</span> value<span>)</span><span>;</span>\n  <span>// Both resolve, but promise2 is faster</span>\n<span>}</span><span>)</span><span>;</span>\n<span>// expected output: \"two\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br></div></div><p>输出结果：</p>\n<div><pre><code>p1 :<span>>></span>  MyPromise <span>{</span>PromiseState: <span>'pending'</span>, PromiseResult: null, onFulfilledCallbacks: Array<span>(</span><span>0</span><span>)</span>, onRejectedCallbacks: Array<span>(</span><span>0</span><span>)</span><span>}</span>\np2 :<span>>></span>  MyPromise <span>{</span>PromiseState: <span>'pending'</span>, PromiseResult: null, onFulfilledCallbacks: Array<span>(</span><span>0</span><span>)</span>, onRejectedCallbacks: Array<span>(</span><span>0</span><span>)</span><span>}</span>\np3 :<span>>></span>  <span>10</span>\np4 :<span>>></span>  已解决的Promise\np5 :<span>>></span>  two\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"源码仓库\"> 源码仓库</h2>\n<p>以上所有的代码，我都放在了仓库 <a href=\"https://github.com/wenyuan/my-promise\" target=\"_blank\" rel=\"noopener noreferrer\">my-promise</a> 中。</p>\n<p>（完）</p>\n",
      "date_published": "2022-03-06T14:12:56.000Z",
      "date_modified": "2022-03-17T15:03:47.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "未完待续",
      "url": "https://www.fedbook.cn/frontend-knowledge/html/to-be-continued/",
      "id": "https://www.fedbook.cn/frontend-knowledge/html/to-be-continued/",
      "content_html": "<h1 id=\"未完待续\"> 未完待续</h1>\n<h2 id=\"知识点正在火速整理中\"> 知识点正在火速整理中</h2>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T07:36:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "HTML 基本结构",
      "url": "https://www.fedbook.cn/frontend-knowledge/html/html-basic-structure/",
      "id": "https://www.fedbook.cn/frontend-knowledge/html/html-basic-structure/",
      "content_html": "<h1 id=\"html-基本结构\"> HTML 基本结构</h1>\n<h2 id=\"基本结构\"> 基本结构</h2>\n<p>现在绝大多数前端开发都是使用下面的结构：</p>\n<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>\n<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>\"</span>zh-CN<span>\"</span></span><span>></span></span>\n<span><span><span>&lt;</span>head</span><span>></span></span>\n  <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>\"</span>utf-8<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>title</span><span>></span></span>页面名称 - 产品中文全称 - 官方网站 - 前端修炼小册<span><span><span>&lt;/</span>title</span><span>></span></span>\n  <span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>\"</span>keywords<span>\"</span></span> <span>content</span><span><span>=</span><span>\"</span>产品名,专题名,专题相关名词,之间用英文半角逗号隔开<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>\"</span>description<span>\"</span></span> <span>content</span><span><span>=</span><span>\"</span>不超过150个字符，描述内容要和页面内容相关。<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>\"</span>viewport<span>\"</span></span> <span>content</span><span><span>=</span><span>\"</span>width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>link</span> <span>rel</span><span><span>=</span><span>\"</span>stylesheet<span>\"</span></span> <span>href</span><span><span>=</span><span>\"</span>/css/index.css<span>\"</span></span><span>/></span></span>\n  <span><span><span>&lt;</span>link</span> <span>rel</span><span><span>=</span><span>\"</span>shortcut icon<span>\"</span></span> <span>href</span><span><span>=</span><span>\"</span>/img/favicon.ico<span>\"</span></span><span>/></span></span>\n<span><span><span>&lt;/</span>head</span><span>></span></span>\n<span><span><span>&lt;</span>body</span><span>></span></span>\n  页面源代码内容\n<span><span><span>&lt;/</span>body</span><span>></span></span>\n<span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>\"</span>/js/index.js<span>\"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n<span><span><span>&lt;/</span>html</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><ul>\n<li><code>&lt;!DOCTYPE html&gt;</code> 是 HTML5 的文档声明，必须位于文档最前面位置。</li>\n<li><code>&lt;html lang=&quot;en&quot;&gt;</code> 是一个 HTML 页面的根元素，lang 设置为 <code>en</code> ，页面也可以输出中文，只是浏览器会提示是否需要翻译此页，如果改成 <code>zh-CN</code> 就没有翻译的选项了。</li>\n<li><code>&lt;head&gt;</code> 这个元素包含关于文档的元信息。</li>\n<li><code>&lt;meta&gt;</code> 定义文档元数据，常用来描述当前页面的特性，比如文档字符集 <code>charset=&quot;utf-8&quot;</code>。\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000002407912\" title=\"常用 meta 整理\" target=\"_blank\" rel=\"noopener noreferrer\">常用 meta 整理</a></li>\n</ul>\n</li>\n<li><code>&lt;title&gt;</code> 该元素指定该文档的标题。</li>\n<li><code>&lt;body&gt;</code> 该元素包含可见页面的所有内容。</li>\n</ul>\n<h2 id=\"主流元素分类\"> 主流元素分类</h2>\n<ul>\n<li>\n<p>根元素</p>\n<p>html</p>\n</li>\n<li>\n<p>元数据元素</p>\n<p>head、base、meta、title、link、style</p>\n</li>\n<li>\n<p>分区元素</p>\n<p>body、header、footer、aside、main、nav、section、article、h1~h6、hgroup、address</p>\n</li>\n<li>\n<p>块文本元素</p>\n<p>div、p、ol、ul、li、dd、dl、dt、hr、blockquote、figcaption、figure</p>\n</li>\n<li>\n<p>内联文本元素</p>\n<p>a、span、br、abbr、cite、code、small、time、bdi、bdo、data、dfn、kbd、mark、q、rb、rp、rt、rtc、ruby、samp、u、var、wbr</p>\n</li>\n<li>\n<p>媒体元素</p>\n<p>audio、img、video、map、track、area</p>\n</li>\n<li>\n<p>内嵌元素</p>\n<p>embed、iframe、object、param、picture、source</p>\n</li>\n<li>\n<p>脚本元素</p>\n<p>canvas、script、noscript</p>\n</li>\n<li>\n<p>编辑标识元素</p>\n<p>del、ins</p>\n</li>\n<li>\n<p>表格元素</p>\n<p>table、caption、thead、tbody、tfoot、tr、th、td、colgroup、col</p>\n</li>\n<li>\n<p>表单元素</p>\n<p>form、label、input、button、select、datalist、optgroup、option、textarea、fieldset、legend、meter、output、progress</p>\n</li>\n<li>\n<p>交互元素</p>\n<p>details、dialog、menu、summary</p>\n</li>\n<li>\n<p>Web 组件</p>\n<p>template、slot</p>\n</li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T07:36:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "实现 apply 方法",
      "url": "https://www.fedbook.cn/frontend-knowledge/javascript-handwritten/%E5%AE%9E%E7%8E%B0apply%E6%96%B9%E6%B3%95/",
      "id": "https://www.fedbook.cn/frontend-knowledge/javascript-handwritten/%E5%AE%9E%E7%8E%B0apply%E6%96%B9%E6%B3%95/",
      "content_html": "<h1 id=\"实现-apply-方法\"> 实现 apply 方法</h1>\n<h2 id=\"功能描述\"> 功能描述</h2>\n<p><code>apply()</code> 方法调用一个具有给定 <code>this</code> 值的函数，以及以一个数组（或类数组对象）的形式提供的参数。</p>\n<p><code>apply()</code> 该方法的语法和作用与 <code>call()</code> 方法类似，只有一个区别，就是 <code>apply()</code> 方法接受的是一个包含多个参数的数组，而 <code>call()</code> 方法接受的是一个参数列表。</p>\n<p>基本用法如下：</p>\n<div><pre><code><span>// apply() </span>\n<span>// 该方法能接收两个参数</span>\n<span>// obj: 这个对象将代替 func 里 this 对象</span>\n<span>// args: 这是一个数组，它将作为参数传给 func（args --> arguments）</span>\n<span>func</span><span>.</span><span>apply</span><span>(</span>obj<span>,</span> args<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"实现思路\"> 实现思路</h2>\n<p>实现 <code>apply()</code> 的思路 和 实现 <code>call()</code> 是一样的，只要把入参中的 <code>...args</code> 换成 <code>args</code> 即可。</p>\n<h2 id=\"手写实现\"> 手写实现</h2>\n<div><pre><code><span>/**\n * context: 函数中的 this 将改变为指向这个参数\n * args：传递给函数的实参信息\n * this：在未改变指向时，指向要处理的函数 func\n */</span>\n<span>Function</span><span>.</span>prototype<span>.</span><span>myApply</span> <span>=</span> <span>function</span><span>(</span><span>context<span>,</span> args</span><span>)</span> <span>{</span>\n  <span>// null、undefined 和不传时，context为 window（注意是双等号不是三等号）</span>\n  context <span>=</span> context <span>==</span> <span>null</span> <span>?</span> window <span>:</span> context<span>;</span>\n\n  <span>// 必须保证 context 是一个对象类型</span>\n  <span>let</span> contextType <span>=</span> <span>typeof</span> context<span>;</span>\n  <span>if</span> <span>(</span><span>!</span><span><span>/</span><span>^(object|function)$</span><span>/</span><span>i</span></span><span>.</span><span>test</span><span>(</span>contextType<span>)</span><span>)</span> <span>{</span>\n   context <span>=</span> <span>Object</span><span>(</span>context<span>)</span><span>;</span>\n <span>}</span>\n  \n  <span>let</span> result<span>;</span>\n  <span>let</span> key <span>=</span> <span>Symbol</span><span>(</span><span>'key'</span><span>)</span> <span>// 成员名唯一，防止修改原始对象的值</span>\n  context<span>[</span>key<span>]</span> <span>=</span> <span>this</span><span>;</span> <span>// 把函数作为对象的某个成员值（这里的这个 this 是待处理函数 func）</span>\n  result <span>=</span> context<span>[</span>key<span>]</span><span>(</span><span>...</span>args<span>)</span><span>;</span> <span>// 此时的函数是对象中的属性，基于对象[成员]的方式执行函数，函数中的 this 指向就是对象</span>\n  <span>delete</span> context<span>[</span>key<span>]</span><span>;</span> <span>// 设置的成员属性用完后要删除掉</span>\n  <span>return</span> result<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h2 id=\"测试用例\"> 测试用例</h2>\n<div><pre><code><span>// 目标：调用方法时打印出 \"张三 性别:男 年龄:13\"</span>\nwindow<span>.</span>name <span>=</span> <span>'window'</span><span>;</span>\n<span>let</span> obj <span>=</span> <span>{</span> name<span>:</span> <span>'张三'</span> <span>}</span><span>;</span>\n<span>let</span> <span>func</span> <span>=</span> <span>function</span><span>(</span><span>sex<span>,</span> age</span><span>)</span><span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>name <span>+</span> <span>' 性别:'</span> <span>+</span> sex <span>+</span> <span>' 年龄:'</span> <span>+</span> age<span>)</span><span>;</span>\n<span>}</span>\n\n<span>// 对比两个输出结果</span>\n<span>func</span><span>.</span><span>apply</span><span>(</span>obj<span>,</span> <span>[</span><span>'男'</span><span>,</span> <span>13</span><span>]</span><span>)</span><span>;</span>\nfunc<span>.</span><span>myApply</span><span>(</span>obj<span>,</span> <span>[</span><span>'男'</span><span>,</span> <span>13</span><span>]</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>（完）</p>\n",
      "date_published": "2022-01-20T14:50:03.000Z",
      "date_modified": "2022-01-20T14:50:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "实现 bind 方法",
      "url": "https://www.fedbook.cn/frontend-knowledge/javascript-handwritten/%E5%AE%9E%E7%8E%B0bind%E6%96%B9%E6%B3%95/",
      "id": "https://www.fedbook.cn/frontend-knowledge/javascript-handwritten/%E5%AE%9E%E7%8E%B0bind%E6%96%B9%E6%B3%95/",
      "content_html": "<h1 id=\"实现-bind-方法\"> 实现 bind 方法</h1>\n<h2 id=\"功能描述\"> 功能描述</h2>\n<p><code>bind()</code> 方法创建一个新的函数，在 <code>bind()</code> 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code> 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p>\n<p>基本用法如下：</p>\n<div><pre><code><span>let</span> <span>func</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>name<span>)</span><span>;</span>\n<span>}</span>\n\n<span>let</span> funcBind <span>=</span> <span>func</span><span>.</span><span>bind</span><span>(</span><span>{</span> name<span>:</span> <span>'张三'</span> <span>}</span><span>)</span><span>;</span>\n<span>funcBind</span><span>(</span><span>)</span><span>;</span> <span>// \"张三\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上述代码可以简化如下：</p>\n<div><pre><code><span>(</span><span>function</span> <span>func</span><span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>name<span>)</span><span>;</span>\n<span>}</span><span>)</span><span>.</span><span>bind</span><span>(</span><span>{</span> name<span>:</span> <span>'张三'</span> <span>}</span><span>)</span><span>(</span><span>)</span><span>;</span> <span>// \"张三\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"实现思路\"> 实现思路</h2>\n<ul>\n<li><code>bind()</code> 返回了一个函数，对于函数来说有两种方式调用，一种是直接调用，一种是通过 <code>new</code> 的方式</li>\n<li><strong>直接调用</strong>：这里选择了 <code>apply</code> 的方式实现。但是对于参数需要注意以下情况：因为 <code>bind</code> 可以实现类似这样的代码 <code>func.bind(obj, 1)(2)</code>，所以我们需要将两边的参数拼接起来，于是就有了这样的实现 <code>args.concat(...arguments)</code>；</li>\n<li><strong>通过 new 方式调用</strong>：首先要掌握如何判断 <code>this</code>，然后对于 <code>new</code> 的情况来说，不会被任何方式改变 <code>this</code>，所以对于这种情况我们需要忽略传入的 <code>this</code>。</li>\n</ul>\n<h2 id=\"手写实现\"> 手写实现</h2>\n<div><pre><code><span>/**\n * this: 要处理的函数 func\n * context: 要改变的函数中的 this 指向 (obj)\n * params：要处理的函数传递的实参 [10, 20]\n */</span>\n<span>Function</span><span>.</span>prototype<span>.</span><span>myBind</span> <span>=</span> <span>function</span><span>(</span><span>context<span>,</span> <span>...</span>params</span><span>)</span> <span>{</span>\n  <span>// this: 要处理的函数</span>\n  <span>if</span> <span>(</span><span>typeof</span> <span>this</span> <span>!==</span> <span>'function'</span><span>)</span> <span>{</span>\n    <span>throw</span> <span>new</span> <span>TypeError</span><span>(</span><span>this</span> <span>+</span> <span>' must be a function'</span><span>)</span>\n  <span>}</span>\n  <span>// this：下面返回的函数 F 中的 this 是由当初绑定的位置触发决定的（总之不是要处理的函数 func）</span>\n  <span>// 所以需要 myBind 函数刚进来时，保存要处理的函数 _this = this</span>\n  <span>let</span> self <span>=</span> <span>this</span><span>;</span>\n\n  <span>// 返回一个函数</span>\n  <span>return</span> <span>function</span> <span>F</span><span>(</span><span><span>...</span>args</span><span>)</span> <span>{</span>\n    <span>// 因为返回了一个函数，我们可以 new F()，所以需要判断</span>\n    <span>if</span> <span>(</span><span>this</span> <span>instanceof</span> <span>F</span><span>)</span> <span>{</span>\n      <span>// args：可能传递的事件对象等信息 [MouseEvent]</span>\n      <span>return</span> <span>new</span> <span>self</span><span>(</span><span>...</span>params<span>,</span> <span>...</span>args<span>)</span>\n    <span>}</span>\n    <span>return</span> <span>self</span><span>.</span><span>apply</span><span>(</span>context<span>,</span> args<span>.</span><span>concat</span><span>(</span><span>...</span>args<span>)</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h2 id=\"测试用例\"> 测试用例</h2>\n<p>直接调用：</p>\n<div><pre><code><span>// 目标：调用方法时打印出 \"张三 性别:男 年龄:13\"</span>\nwindow<span>.</span>name <span>=</span> <span>'window'</span><span>;</span>\n<span>let</span> <span>func</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>name<span>)</span><span>;</span>\n<span>}</span>\n\n<span>// 对比两个输出结果</span>\n<span>let</span> funcBind <span>=</span> <span>func</span><span>.</span><span>bind</span><span>(</span><span>{</span> name<span>:</span> <span>'张三'</span> <span>}</span><span>)</span><span>;</span>\n<span>funcBind</span><span>(</span><span>)</span><span>;</span> <span>// \"张三\"</span>\n<span>let</span> funcMyBind <span>=</span> func<span>.</span><span>myBind</span><span>(</span><span>{</span> name<span>:</span> <span>'张三'</span> <span>}</span><span>)</span><span>;</span>\n<span>funcMyBind</span><span>(</span><span>)</span><span>;</span> <span>// \"张三\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id=\"注意事项\"> 注意事项</h2>\n<p>这里只是做 <code>bind()</code> 方法的简易实现，之后会写个最终版实现。</p>\n<p>（完）</p>\n",
      "date_published": "2022-01-20T14:50:03.000Z",
      "date_modified": "2022-01-20T14:50:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "实现 instanceof 运算符",
      "url": "https://www.fedbook.cn/frontend-knowledge/javascript-handwritten/%E5%AE%9E%E7%8E%B0instanceof%E8%BF%90%E7%AE%97%E7%AC%A6/",
      "id": "https://www.fedbook.cn/frontend-knowledge/javascript-handwritten/%E5%AE%9E%E7%8E%B0instanceof%E8%BF%90%E7%AE%97%E7%AC%A6/",
      "content_html": "<h1 id=\"实现-instanceof-运算符\"> 实现 instanceof 运算符</h1>\n<h2 id=\"功能描述\"> 功能描述</h2>\n<p><code>instanceof</code> 运算符用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</p>\n<h2 id=\"实现思路\"> 实现思路</h2>\n<p><code>instanceof</code> 左侧必须是对象，才能找到它的原型链；<br>\n<code>instanceof</code> 右侧必须是函数，函数才会有 <code>prototype</code> 属性。<br>\n通过迭代，左侧对象的原型不等于右侧的 <code>prototype</code> 时，沿着原型链重新赋值左侧。</p>\n<p>具体步骤如下：</p>\n<ul>\n<li>步骤 1：先取得当前类的原型，当前实例对象的原型链</li>\n<li>步骤 2：一直循环（执行原型链的查找机制）\n<ul>\n<li>取得当前实例对象原型链的原型链（<code>proto = proto.__proto__</code>，沿着原型链一直向上查找）；</li>\n<li>如果当前实例的原型链 <code>__proto__</code> 上找到了当前类的原型 <code>prototype</code>，则返回 <code>true</code>；</li>\n<li>如果一直找到 <code>Object.prototype.__proto__ == null</code>，<code>Object</code> 的基类（<code>null</code>）上面都没找到，则返回 <code>false</code>。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"手写实现\"> 手写实现</h2>\n<div><pre><code><span>function</span> <span>myInstanceof</span><span>(</span><span>instanceObject<span>,</span> classFunc</span><span>)</span> <span>{</span>\n  classFunc <span>=</span> classFunc<span>.</span>prototype<span>;</span> <span>// 取得当前类的原型对象</span>\n  <span>let</span> proto <span>=</span> Object<span>.</span><span>getPrototypeOf</span><span>(</span>instanceObject<span>)</span><span>;</span> <span>// 取得当前实例对象的原型对象</span>\n  \n  <span>while</span><span>(</span><span>true</span><span>)</span> <span>{</span>\n    <span>// 找到了 Object 的基类 Object.prototype.__proto__</span>\n    <span>if</span><span>(</span>proto <span>===</span> <span>null</span><span>)</span> <span>return</span> <span>false</span><span>;</span>\n\n    <span>// 在当前实例对象的原型链上，找到了当前类</span>\n    <span>if</span><span>(</span>proto <span>===</span> classFunc<span>)</span> <span>return</span> <span>true</span><span>;</span>\n\n    <span>// 沿着原型链 __proto__ 一层一层向上查</span>\n    proto <span>=</span> Object<span>.</span><span>getPrototypeof</span><span>(</span>proto<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id=\"测试用例\"> 测试用例</h2>\n<div><pre><code><span>myInstanceof</span><span>(</span><span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>]</span><span>,</span> Array<span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>（完）</p>\n",
      "date_published": "2022-01-20T14:50:03.000Z",
      "date_modified": "2022-01-20T14:50:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "实现 new 运算符",
      "url": "https://www.fedbook.cn/frontend-knowledge/javascript-handwritten/%E5%AE%9E%E7%8E%B0new%E8%BF%90%E7%AE%97%E7%AC%A6/",
      "id": "https://www.fedbook.cn/frontend-knowledge/javascript-handwritten/%E5%AE%9E%E7%8E%B0new%E8%BF%90%E7%AE%97%E7%AC%A6/",
      "content_html": "<h1 id=\"实现-new-运算符\"> 实现 new 运算符</h1>\n<h2 id=\"功能描述\"> 功能描述</h2>\n<p><code>new</code> 运算符用于创建一个自定义对象的实例，或具有构造函数的内置对象的实例。</p>\n<h2 id=\"实现思路\"> 实现思路</h2>\n<ul>\n<li>步骤 1：创建构造函数的实例对象，这个对象的 <code>__proto__</code> 要指向构造函数的 <code>prototype</code></li>\n<li>步骤 2：把构造函数当作普通函数执行，并改变 <code>this</code> 指向</li>\n<li>步骤 3：分析构造函数的返回值\n<ul>\n<li>返回值为 <code>object</code> 或 <code>function</code> 类型则作为 <code>new</code> 方法的返回值返回；</li>\n<li>否则返回构造函数的实例对象。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"手写实现\"> 手写实现</h2>\n<div><pre><code><span>/**\n  * Func：要操作的构造函数（最后要创建这个构造函数的实例）\n  * args：存储未来传递给构造函数 Func 的实参\n  */</span>\n<span>function</span> <span>myNew</span><span>(</span><span>Func<span>,</span> <span>...</span>args</span><span>)</span> <span>{</span>\n  <span>// 创建一个 Func 的实例对象（实例.__proto__ = 构造函数.prototype）</span>\n  <span>let</span> instance <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>Func</span><span>.</span>prototype<span>)</span><span>;</span>\n  <span>// 把 Func 当做普通函数执行，并将其 this 指向 instance</span>\n  <span>let</span> result <span>=</span> <span>Func</span><span>.</span><span>apply</span><span>(</span>instance<span>,</span> args<span>)</span><span>;</span>\n  <span>// 分析构造函数的返回值</span>\n  <span>if</span> <span>(</span>result <span>!==</span> <span>null</span> <span>&amp;&amp;</span> <span><span>/</span><span>^(object|function)$</span><span>/</span></span><span>.</span><span>test</span><span>(</span><span>typeof</span> result<span>)</span><span>)</span> <span>{</span>\n    <span>return</span> result<span>;</span>\n  <span>}</span>\n  <span>return</span> instance<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id=\"测试用例\"> 测试用例</h2>\n<div><pre><code><span>function</span> <span>Person</span><span>(</span><span>name<span>,</span> age</span><span>)</span> <span>{</span>\n  <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n  <span>this</span><span>.</span>age <span>=</span> age<span>;</span>\n<span>}</span>\n\n<span>// 对比两个输出结果</span>\n<span>const</span> p1 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>'zhangsan'</span><span>,</span> <span>13</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span><span>'new:'</span><span>,</span> p1<span>)</span><span>;</span>\n\n<span>const</span> p2 <span>=</span> <span>myNew</span><span>(</span>Person<span>,</span> <span>'zhangsan'</span><span>,</span> <span>13</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span><span>'myNew:'</span><span>,</span> p2<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>（完）</p>\n",
      "date_published": "2022-01-20T14:50:03.000Z",
      "date_modified": "2022-01-20T14:50:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "实现 Object.create 方法",
      "url": "https://www.fedbook.cn/frontend-knowledge/javascript-handwritten/%E5%AE%9E%E7%8E%B0object-create%E6%96%B9%E6%B3%95/",
      "id": "https://www.fedbook.cn/frontend-knowledge/javascript-handwritten/%E5%AE%9E%E7%8E%B0object-create%E6%96%B9%E6%B3%95/",
      "content_html": "<h1 id=\"实现-object-create-方法\"> 实现 Object.create 方法</h1>\n<h2 id=\"功能描述\"> 功能描述</h2>\n<p><code>Object.create()</code> 方法创建一个新对象，使用现有的对象来提供新创建的对象的 <code>__proto__</code>（新对象的 <code>__proto__</code> 属性会指向原对象）。</p>\n<h2 id=\"手写实现\"> 手写实现</h2>\n<div><pre><code><span>function</span> <span>objectCreate</span><span>(</span><span>obj</span><span>)</span> <span>{</span>\n  <span>// 排除传入的是非 object 的情况</span>\n  <span>if</span> <span>(</span><span>typeof</span> obj <span>!==</span> <span>'object'</span><span>)</span> <span>{</span>\n    <span>throw</span> <span>new</span> <span>TypeError</span><span>(</span><span><span>`</span><span>Object prototype may only be an Object or null: </span><span><span>${</span>obj<span>}</span></span><span>`</span></span><span>)</span><span>;</span>\n  <span>}</span>\n  <span>// 让空对象的 __proto__ 指向传进来的对象（prototype）</span>\n  <span>// 目标 {}.__proto__ = prototype</span>\n  <span>function</span> <span>F</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n  <span>F</span><span>.</span>prototype <span>=</span> obj<span>;</span>\n  <span>return</span> <span>new</span> <span>F</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id=\"测试用例\"> 测试用例</h2>\n<div><pre><code><span>let</span> obj <span>=</span> <span>{</span> \n  name<span>:</span> <span>'test'</span><span>,</span>\n  colors<span>:</span> <span>[</span><span>'red'</span><span>,</span> <span>'green'</span><span>,</span> <span>'blue'</span><span>]</span>\n<span>}</span><span>;</span>\n<span>// 对比两个输出结果</span>\nconsole<span>.</span><span>log</span><span>(</span><span>'Object.create()'</span><span>,</span> Object<span>.</span><span>create</span><span>(</span>obj<span>)</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span><span>'objectCreate()'</span><span>,</span> <span>objectCreate</span><span>(</span>obj<span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"注意事项\"> 注意事项</h2>\n<p>原生的 <code>Object.create(proto，[propertiesObject])</code> 方法支持两个参数：</p>\n<ul>\n<li><code>proto</code>：必须，表示新建对象的原型对象。</li>\n<li><code>propertiesObject</code>：可选，需要传入一个对象。如果该参数被指定且不为 <code>undefined</code>，该传入对象的自有可枚举属性（即其自身定义的属性，而不是其原型链上的枚举属性）将添加到新创建对象。</li>\n</ul>\n<p><strong>此处我们手写实现的函数省略了对第二个参数的支持</strong>。</p>\n<p>（完）</p>\n",
      "date_published": "2022-01-20T14:50:03.000Z",
      "date_modified": "2022-01-20T14:50:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "实现浅克隆（shallowClone）",
      "url": "https://www.fedbook.cn/frontend-knowledge/javascript-handwritten/%E5%AE%9E%E7%8E%B0%E6%B5%85%E5%85%8B%E9%9A%86-shallow-clone/",
      "id": "https://www.fedbook.cn/frontend-knowledge/javascript-handwritten/%E5%AE%9E%E7%8E%B0%E6%B5%85%E5%85%8B%E9%9A%86-shallow-clone/",
      "content_html": "<h1 id=\"实现浅克隆-shallowclone\"> 实现浅克隆（shallowClone）</h1>\n<h2 id=\"功能描述\"> 功能描述</h2>\n<p>浅克隆（shallowClone），只拷贝对象或数组的第一层内容。</p>\n<p>注意：对于引用值时，浅克隆之后会出现你改我也改的情况。</p>\n<h2 id=\"手写实现\"> 手写实现</h2>\n<div><pre><code><span>const</span> <span>shallowClone</span> <span>=</span> <span>(</span><span>target</span><span>)</span> <span>=></span> <span>{</span>\n  <span>if</span> <span>(</span><span>typeof</span> target <span>===</span> <span>'object'</span> <span>&amp;&amp;</span> target <span>!==</span> <span>null</span><span>)</span> <span>{</span>\n    <span>const</span> cloneTarget <span>=</span> Array<span>.</span><span>isArray</span><span>(</span>target<span>)</span> <span>?</span> <span>[</span><span>]</span> <span>:</span> <span>{</span><span>}</span><span>;</span>\n    <span>for</span> <span>(</span><span>let</span> prop <span>in</span> target<span>)</span> <span>{</span>\n      <span>if</span> <span>(</span>target<span>.</span><span>hasOwnProperty</span><span>(</span>prop<span>)</span><span>)</span> <span>{</span> <span>// 遍历对象自身可枚举属性（不考虑继承属性和原型对象）</span>\n        cloneTarget<span>[</span>prop<span>]</span> <span>=</span> target<span>[</span>prop<span>]</span><span>;</span>\n      <span>}</span>\n    <span>}</span>\n    <span>return</span> cloneTarget<span>;</span>\n  <span>}</span> <span>else</span> <span>{</span>\n    <span>return</span> target<span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id=\"测试用例\"> 测试用例</h2>\n<div><pre><code><span>let</span> oldObj <span>=</span> <span>{</span>\n  name<span>:</span> <span>'old'</span><span>,</span>\n  params<span>:</span> <span>{</span>\n    a<span>:</span> <span>1</span><span>,</span>\n    b<span>:</span> <span>2</span>\n  <span>}</span>\n<span>}</span>\n<span>let</span> newObj <span>=</span> <span>shallowClone</span><span>(</span>oldObj<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>（完）</p>\n",
      "date_published": "2022-01-20T14:50:03.000Z",
      "date_modified": "2022-01-20T14:50:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "实现节流函数（throttle）",
      "url": "https://www.fedbook.cn/frontend-knowledge/javascript-handwritten/%E5%AE%9E%E7%8E%B0%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0-throttle/",
      "id": "https://www.fedbook.cn/frontend-knowledge/javascript-handwritten/%E5%AE%9E%E7%8E%B0%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0-throttle/",
      "content_html": "<h1 id=\"实现节流函数-throttle\"> 实现节流函数（throttle）</h1>\n<h2 id=\"功能描述\"> 功能描述</h2>\n<p>设定一个特定的时间，让函数在特定的时间内只执行一次，不会频繁执行。</p>\n<p>举例：fps 游戏里面的狙击枪，即使一直按住开枪键不松手，也会有储蓄时间，子弹不会一直发射，弹孔不会连成一条线。</p>\n<h2 id=\"手写实现\"> 手写实现</h2>\n<div><pre><code><span>// func 是用户传入需要节流的函数</span>\n<span>// wait 是等待时间</span>\n<span>const</span> <span>throttle</span> <span>=</span> <span>(</span><span>func<span>,</span> wait<span>=</span><span>500</span></span><span>)</span> <span>=></span> <span>{</span>\n  <span>// 上一次执行该函数的时间</span>\n  <span>let</span> lastTime <span>=</span> <span>0</span><span>;</span>\n  <span>// 使用闭包返回一个函数并且用到闭包函数外面的变量 lastTime</span>\n  <span>return</span> <span>function</span><span>(</span><span><span>...</span>args</span><span>)</span> <span>{</span>\n    <span>// 当前时间</span>\n    <span>let</span> now <span>=</span> <span>+</span><span>new</span> <span>Date</span><span>(</span><span>)</span><span>;</span>\n    <span>// 将当前时间和上一次执行函数时间对比</span>\n    <span>// 如果差值大于设置的等待时间就执行函数</span>\n    <span>if</span> <span>(</span>now <span>-</span> lastTime <span>></span> wait<span>)</span> <span>{</span>\n      lastTime <span>=</span> now<span>;</span>\n      <span>func</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>,</span> args<span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id=\"测试用例\"> 测试用例</h2>\n<div><pre><code><span>// 用 onmousemove 测试一下节流函数</span>\n<span>function</span> <span>func</span><span>(</span><span>e</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>e<span>)</span><span>;</span>\n<span>}</span>\n<span>let</span> throttleFunc <span>=</span> <span>throttle</span><span>(</span>func<span>,</span> <span>1000</span><span>)</span>\ndocument<span>.</span><span>onmousemove</span> <span>=</span> <span>(</span><span>e</span><span>)</span> <span>=></span> <span>{</span>\n  <span>throttleFunc</span><span>(</span>e<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"常见应用场景\"> 常见应用场景</h2>\n<p>间隔一段时间执行一次回调的场景有：</p>\n<ul>\n<li>鼠标的移入移出，页面的滚动。</li>\n<li>浏览器的拖拽，固定时间内只执行一次。</li>\n<li>浏览器的缩放。</li>\n<li>其它。</li>\n</ul>\n<h2 id=\"防抖与节流的异同比较\"> 防抖与节流的异同比较</h2>\n<p>相同点：</p>\n<ul>\n<li>目的都是降低回调执行频率，节省计算资源。</li>\n</ul>\n<p>不同点：</p>\n<ul>\n<li>函数防抖，即触发高频事件后 n 秒内函数只会执行一次，利用 <code>clearTimeout</code> 和 <code>setTimeout</code> 实现。</li>\n<li>函数节流，即高频事件触发，但在 n 秒内只会执行一次，因此节流会稀释函数的执行频率。</li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-01-20T14:50:03.000Z",
      "date_modified": "2022-01-20T14:50:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "实现深克隆（deepClone）",
      "url": "https://www.fedbook.cn/frontend-knowledge/javascript-handwritten/%E5%AE%9E%E7%8E%B0%E6%B7%B1%E5%85%8B%E9%9A%86-deep-clone/",
      "id": "https://www.fedbook.cn/frontend-knowledge/javascript-handwritten/%E5%AE%9E%E7%8E%B0%E6%B7%B1%E5%85%8B%E9%9A%86-deep-clone/",
      "content_html": "<h1 id=\"实现深克隆-deepclone\"> 实现深克隆（deepClone）</h1>\n<h2 id=\"功能描述\"> 功能描述</h2>\n<p>深克隆（deepClone），层层拷贝对象或数组的每一层内容。</p>\n<p>注意：对于引用值时，深克隆之后<strong>不会</strong>出现你改我也改的情况。</p>\n<h2 id=\"手写实现-简易版\"> 手写实现（简易版）</h2>\n<div><pre><code><span>let</span> newObj <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>oldObj<span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>局限性：</p>\n<ul>\n<li>无法实现对函数、RegExp 等特殊对象的克隆；</li>\n<li>会抛弃对象的 <code>constructor</code>，所有的构造函数会指向 <code>Object</code>；</li>\n<li>对象有循环引用，会报错。</li>\n</ul>\n<h2 id=\"手写实现-面试版\"> 手写实现（面试版）</h2>\n<div><pre><code><span>function</span> <span>deepClone</span><span>(</span><span>target</span><span>)</span>  <span>{</span>\n  <span>if</span> <span>(</span>target <span>===</span> <span>null</span><span>)</span> <span>return</span> <span>null</span><span>;</span>\n  <span>if</span> <span>(</span><span>typeof</span> target <span>!==</span> <span>'object'</span><span>)</span> <span>return</span> target<span>;</span>\n\n  <span>const</span> cloneTarget <span>=</span> Array<span>.</span><span>isArray</span><span>(</span>target<span>)</span> <span>?</span> <span>[</span><span>]</span> <span>:</span> <span>{</span><span>}</span><span>;</span>\n  <span>for</span> <span>(</span><span>let</span> prop <span>in</span> target<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>target<span>.</span><span>hasOwnProperty</span><span>(</span>prop<span>)</span><span>)</span> <span>{</span>\n      cloneTarget<span>[</span>prop<span>]</span> <span>=</span> <span>deepClone</span><span>(</span>target<span>[</span>prop<span>]</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n  <span>return</span> cloneTarget<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id=\"手写实现-完善版\"> 手写实现（完善版）</h2>\n<p>考虑日期、正则等特殊对象，解决循环引用情况。</p>\n<div><pre><code><span>const</span> <span>isObject</span> <span>=</span> <span>(</span><span>target</span><span>)</span> <span>=></span> <span>(</span><span>typeof</span> target <span>===</span> <span>'object'</span> <span>||</span> <span>typeof</span> target <span>===</span> <span>'function'</span><span>)</span> <span>&amp;&amp;</span> target <span>!==</span> <span>null</span><span>;</span>\n\n<span>function</span> <span>deepClone</span> <span>(</span>target<span>,</span> map <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n  <span>// 先判断该引用类型是否被拷贝过</span>\n  <span>if</span> <span>(</span>map<span>.</span><span>get</span><span>(</span>target<span>)</span><span>)</span> <span>{</span>\n    <span>return</span> target<span>;</span>\n  <span>}</span>\n\n  <span>// 获取当前值的构造函数：获取它的类型</span>\n  <span>let</span> constructor <span>=</span> target<span>.</span>constructor<span>;</span>\n\n  <span>// 检测当前对象target是否与 正则、日期格式对象匹配</span>\n  <span>if</span> <span>(</span><span><span>/</span><span>^(RegExp|Date)$</span><span>/</span><span>i</span></span><span>.</span><span>test</span><span>(</span>constructor<span>.</span>name<span>)</span><span>)</span><span>{</span>\n    <span>return</span> <span>new</span> <span>constructor</span><span>(</span>target<span>)</span><span>;</span> <span>// 创建一个新的特殊对象(正则类/日期类)的实例</span>\n  <span>}</span>\n\n  <span>if</span> <span>(</span><span>isObject</span><span>(</span>target<span>)</span><span>)</span> <span>{</span>\n    map<span>.</span><span>set</span><span>(</span>target<span>,</span> <span>true</span><span>)</span><span>;</span> <span>// 为循环引用的对象做标记</span>\n    <span>const</span> cloneTarget <span>=</span> Array<span>.</span><span>isArray</span><span>(</span>target<span>)</span> <span>?</span> <span>[</span><span>]</span> <span>:</span> <span>{</span><span>}</span><span>;</span>\n    <span>for</span> <span>(</span><span>let</span> prop <span>in</span> target<span>)</span> <span>{</span>\n      <span>if</span> <span>(</span>target<span>.</span><span>hasOwnProperty</span><span>(</span>prop<span>)</span><span>)</span> <span>{</span>\n        cloneTarget<span>[</span>prop<span>]</span> <span>=</span> <span>deepClone</span><span>(</span>target<span>[</span>prop<span>]</span><span>,</span> map<span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span>\n    <span>return</span> cloneTarget<span>;</span>\n  <span>}</span> <span>else</span> <span>{</span>\n    <span>return</span> target<span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>（完）</p>\n",
      "date_published": "2022-01-20T14:50:03.000Z",
      "date_modified": "2022-01-20T14:50:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "实现防抖函数（debounce）",
      "url": "https://www.fedbook.cn/frontend-knowledge/javascript-handwritten/%E5%AE%9E%E7%8E%B0%E9%98%B2%E6%8A%96%E5%87%BD%E6%95%B0-debounce/",
      "id": "https://www.fedbook.cn/frontend-knowledge/javascript-handwritten/%E5%AE%9E%E7%8E%B0%E9%98%B2%E6%8A%96%E5%87%BD%E6%95%B0-debounce/",
      "content_html": "<h1 id=\"实现防抖函数-debounce\"> 实现防抖函数（debounce）</h1>\n<h2 id=\"功能描述\"> 功能描述</h2>\n<p>延迟要执行的动作，若在延迟的这段时间内再次触发了，则取消之前的动作，重新计时。</p>\n<p>举例：电脑或手机的休眠倒计时，一旦再次操作就重新计时。</p>\n<h2 id=\"手写实现\"> 手写实现</h2>\n<div><pre><code><span>// func 是用户传入需要防抖的函数</span>\n<span>// wait 是等待时间</span>\n<span>const</span> <span>debounce</span> <span>=</span> <span>(</span><span>func<span>,</span> wait<span>=</span><span>500</span></span><span>)</span> <span>=></span> <span>{</span>\n  <span>// 缓存一个定时器 id</span>\n  <span>let</span> timer <span>=</span> <span>0</span><span>;</span>\n  <span>// 这里返回的函数是每次用户实际调用的防抖函数</span>\n  <span>// 如果已经设定过定时器了就清空上一次的定时器</span>\n  <span>// 开始一个新的定时器，延迟执行用户传入的方法</span>\n  <span>return</span> <span>function</span><span>(</span><span><span>...</span>args</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>timer<span>)</span> <span>clearTimeout</span><span>(</span>timer<span>)</span><span>;</span>\n    timer <span>=</span> <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n      <span>func</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>,</span> args<span>)</span><span>;</span>\n    <span>}</span><span>,</span> wait<span>)</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id=\"测试用例\"> 测试用例</h2>\n<div><pre><code><span>// 用 onmousemove 测试一下防抖函数</span>\n<span>function</span> <span>func</span><span>(</span><span>e</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>e<span>)</span><span>;</span>\n<span>}</span>\n<span>let</span> debounceFunc <span>=</span> <span>debounce</span><span>(</span>func<span>,</span> <span>1000</span><span>)</span><span>;</span>\ndocument<span>.</span><span>onmousemove</span> <span>=</span> <span>(</span><span>e</span><span>)</span> <span>=></span> <span>{</span>\n  <span>debounceFunc</span><span>(</span>e<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"常见应用场景\"> 常见应用场景</h2>\n<p>连续的事件，只需触发一次回调的场景有：</p>\n<ul>\n<li>搜索框场景：搜索时等用户完整输入内容后再发送查询请求。</li>\n<li>按钮提交场景：防止多次提交按钮，只执行最后一次提交。</li>\n<li>其它。</li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-01-20T14:50:03.000Z",
      "date_modified": "2022-01-20T14:50:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "JavaScript",
      "url": "https://www.fedbook.cn/frontend-knowledge/javascript/",
      "id": "https://www.fedbook.cn/frontend-knowledge/javascript/",
      "content_html": "<h1 id=\"javascript\"> JavaScript</h1>\n<p>在 Web 前端页面中，</p>\n<ul>\n<li>HTML 属于结构层，负责描绘出内容的结构；</li>\n<li>CSS 属于表现层，负责「如何显示有关内容」；</li>\n<li><strong>JavaScript 属于行为层，负责「内容应如何对事件做出反应」</strong>。</li>\n</ul>\n<hr>\n<p>这个系列主要梳理 JavaScript 基础知识点，内容涵盖 ECMAScript 5.1（<strong>ES5</strong>）和 ECMAScript 2015（<strong>ES6</strong>），以及少数 ECMAScript 2016（<strong>ES7</strong>）中常用的新特性。</p>\n<p>关于 <strong>ES7/ES8/ES9</strong> 等后出的新语法，会单独拎出来作为一个系列（ES 规范系列）进行汇总。</p>\n<hr>\n<p>关于 JavaScript 的知识点，主要参考：</p>\n<ul>\n<li>《JavaScript高级程序设计（第3版）》</li>\n<li>《JavaScript高级程序设计（第4版）》</li>\n<li>《你不知道的JavaScript（上卷）》</li>\n<li>《你不知道的JavaScript（中卷）》</li>\n<li>《ES6标准入门（第3版）》</li>\n<li>《<a href=\"https://zh.javascript.info/\" title=\"现代 JavaScript 教程\" target=\"_blank\" rel=\"noopener noreferrer\">现代 JavaScript 教程</a>》</li>\n<li>《<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript\" title=\"MDN - JavaScript 系列\" target=\"_blank\" rel=\"noopener noreferrer\">MDN - JavaScript 系列</a>》</li>\n</ul>\n<div style=\"text-align: right\">\n  <svg t=\"1595948360275\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"11728\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"64\" height=\"64\"><defs><style type=\"text/css\"></style></defs><path d=\"M238.592 155.648H399.36v450.56C399.36 809.984 302.08 880.64 146.432 880.64c-37.888 0-87.04-6.144-118.784-17.408l18.432-130.048c22.528 7.168 51.2 12.288 82.944 12.288 67.584 0 110.592-30.72 110.592-141.312V155.648h-1.024z m301.056 547.84c41.984 22.528 110.592 44.032 179.2 44.032 73.728 0 113.664-30.72 113.664-78.848 0-43.008-33.792-69.632-119.808-99.328-118.784-40.96-197.632-107.52-197.632-211.968C515.072 235.52 617.472 143.36 785.408 143.36c81.92 0 139.264 16.384 182.272 35.84L931.84 308.224c-27.648-13.312-79.872-33.792-148.48-33.792-69.632 0-103.424 32.768-103.424 68.608 0 45.056 38.912 65.536 132.096 101.376 125.952 46.08 184.32 112.64 184.32 214.016 0 119.808-91.136 221.184-286.72 221.184-81.92 0-161.792-22.528-201.728-44.032l31.744-132.096z\" fill=\"#F4DE51\" p-id=\"11729\"></path></svg>\n</div>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T08:41:15.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "数据类型",
      "url": "https://www.fedbook.cn/frontend-knowledge/javascript/data-types/",
      "id": "https://www.fedbook.cn/frontend-knowledge/javascript/data-types/",
      "content_html": "<h1 id=\"数据类型\"> 数据类型</h1>\n<h2 id=\"前言\"> 前言</h2>\n<p>最新的 ECMAScript 标准定义了 8 种数据类型:</p>\n<ul>\n<li>7 种基本数据类型：\n<ul>\n<li>Undefined</li>\n<li>Null</li>\n<li>Boolean</li>\n<li>Number</li>\n<li>BigInt（ECMAScript 2020）</li>\n<li>String</li>\n<li>Symbol（ECMAScript 2015）</li>\n</ul>\n</li>\n<li>1 种复杂数据类型（又称引用数据类型）：\n<ul>\n<li>Object</li>\n</ul>\n</li>\n</ul>\n<p>基本数据类型保存在<strong>栈内存</strong>，引用类型保存在<strong>堆内存</strong>中。根本原因在于保存在栈内存的必须是大小固定的数据，引用类型的大小不固定，只能保存在堆内存中，但是可以把它的地址写在栈内存中以供我们访问。</p>\n<p>如果是基本数据类型，则按值访问，操作的就是变量保存的值；如果是引用类型的值，我们只是通过保存在变量中的引用类型的地址来操作实际对象。</p>\n<h2 id=\"使用-typeof-操作符判断数据类型\"> 使用 typeof 操作符判断数据类型</h2>\n<p><code>typeof</code> 用于检测给定变量的数据类型，对一个值使用 <code>typeof</code> 操作符会返回一个表示操作数的类型的字符串。但 <code>typeof</code> 的运算结果，与运行时类型的规定有很多不一致的地方。</p>\n<p>我们可以看下表来对照一下。</p>\n<table>\n<thead>\n<tr>\n<th>示例表达式</th>\n<th>typeof 结果</th>\n<th>运行时类型行为</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>void(0)</td>\n<td><code>undefined</code></td>\n<td>Undefined</td>\n</tr>\n<tr>\n<td>null</td>\n<td><code>object</code></td>\n<td>Null</td>\n</tr>\n<tr>\n<td>true</td>\n<td><code>boolean</code></td>\n<td>Boolean</td>\n</tr>\n<tr>\n<td>3</td>\n<td><code>number</code></td>\n<td>Number</td>\n</tr>\n<tr>\n<td>9007199254740992n</td>\n<td><code>bigint</code></td>\n<td>BigInt</td>\n</tr>\n<tr>\n<td>&quot;ok&quot;</td>\n<td><code>string</code></td>\n<td>String</td>\n</tr>\n<tr>\n<td>Symbol(&quot;a&quot;)</td>\n<td><code>symbol</code></td>\n<td>Symbol</td>\n</tr>\n<tr>\n<td>(function(){})</td>\n<td><code>function</code></td>\n<td>Function object</td>\n</tr>\n<tr>\n<td>{}</td>\n<td><code>object</code></td>\n<td>Any other object</td>\n</tr>\n</tbody>\n</table>\n<p>在表格中，多数项是对应的，但是请注意 <code>object —— Null</code> 和 <code>function —— Object</code> 是特例，我们理解类型的时候需要特别注意这个区别。</p>\n<p>此外，由于 <code>typeof</code> 是一个操作符而不是函数，后面可加括号也可省略。</p>\n<h2 id=\"_8-种数据类型介绍\"> 8 种数据类型介绍</h2>\n<h3 id=\"undefined-类型\"> Undefined 类型</h3>\n<p>Undefined 类型只有一个值，即特殊的 <code>undefined</code>。<br>\n在使用 <code>var</code> 声明变量但未对其加以初始化时，这个变量的值就是 <code>undefined</code>；</p>\n<p>对未初始化和未声明的变量执行 <code>typeof</code> 操作符都会返回 <code>undefined</code> 值。</p>\n<p><strong>显示地初始化变量是明智的选择</strong>，这样当 <code>typeof</code> 操作符返回 <code>&quot;undefined&quot;</code> 值时，我们就知道被检测地变量还没有被声明，而不是尚未初始化。（—— 出自红宝书）</p>\n<h3 id=\"null-类型\"> Null 类型</h3>\n<p>Null 类型也只有一个值，即特殊的 <code>null</code>。<br>\n从逻辑角度来看，<code>null</code> 值表示一个<strong>空对象指针</strong>，所以使用 <code>typeof</code> 操作符检测 <code>null</code> 值时会返回 <code>&quot;object&quot;</code>。</p>\n<p>如果定义的变量准备在将来<strong>用于保存对象</strong>，那么最好将该变量初始化为 <code>null</code> 而不是其他值。这样一来，只要直接检查相应的变量是否等于 <code>null</code> 值就可以知道它是否已经保存了一个对象的引用。（—— 出自红宝书）</p>\n<p>实际上，<code>undefined</code> 值是派生自 <code>null</code> 值的，因此 <code>null == undefined</code> 会返回 <code>true</code>，但 <code>null === undefined</code> 则返回 <code>false</code> 了。</p>\n<h3 id=\"boolean-类型\"> Boolean 类型</h3>\n<p>Boolean 类型只有两个字面值：<code>true</code> 和 <code>false</code>。</p>\n<h3 id=\"number-类型\"> Number 类型</h3>\n<p>Number 类型使用 <a href=\"https://baike.baidu.com/item/IEEE%20754/3869922?fr=aladdin\" target=\"_blank\" rel=\"noopener noreferrer\">IEEE754</a> 格式来表示整数和浮点数值。</p>\n<h4 id=\"_1-浮点数值的整数化\"> 1）浮点数值的整数化</h4>\n<p>因为保存浮点数值需要得内存空间是保存整数值的两倍，所以凡是可以「整数化」的浮点数都会被转换为整数值，例如：<code>1.</code> 和 <code>1.0</code> 都会被解析为 <code>1</code>。</p>\n<p>对于那些极大或极小的数值，可以用 e 表示法（即科学计数法）表示的浮点数值表示。（用 e 表示法表示的数值等于 e 前面的数值乘以 10 的指数次幂）</p>\n<h4 id=\"_2-数值范围限制\"> 2）数值范围限制</h4>\n<p>JavaScript 能够表示的<strong>最小数值</strong>为 <code>Number.MIN_VALUE</code>，在大多数浏览器中这个值是 <code>5e-324</code>；<br>\nJavaScript 能够表示的<strong>最大数值</strong>为 <code>Number.MAX_VALUE</code>，在大多数浏览器中这个值是 <code>1.7976931348623157e+308</code>。</p>\n<p>超出范围的正数会被转换成 <code>Infinity</code>（正无穷），超出范围的负数会被转换成 <code>-Infinity</code>（负无穷）。</p>\n<p>可以使用 <code>isFinite()</code> 函数判断括号里的参数是否位于最小与最大数值之间。</p>\n<h4 id=\"_3-特殊的-nan\"> 3）特殊的 NaN</h4>\n<p><code>NaN</code>，即非数值（Not a Number）是一个特殊的数值。它有两个特点：一是任何涉及 <code>NaN</code> 的操作都会返回 <code>NaN</code>，二是 <code>NaN</code> 与任何值都不相等，包括 <code>NaN</code> 本身。</p>\n<p>可以通过 <code>isNaN()</code> 函数来确认括号里的参数是否「不是数值」，需要注意的是，<code>isNaN()</code> 在接收到一个参数后，会尝试将这个值转换为数值，某些不是数值的值会直接转换为数值，例如字符串 <code>&quot;10&quot;</code> 或 <code>Boolean</code> 值。</p>\n<h4 id=\"_4-数值转换函数\"> 4）数值转换函数</h4>\n<p>有 3 个函数可以把非数值转换为数值：<code>Number()</code>、<code>parseInt()</code> 和 <code>parseFloat()</code>。</p>\n<p>由于 <code>Number()</code> 函数在转换字符串时比较复杂而且不够合理，因此更常用过的是另外两个函数。（—— 出自红宝书）</p>\n<p><code>parseInt()</code> 在转换时可以拥有第二个参数：转换时使用的基数（即多少进制），建议无论在什么情况下都明确指定基数。（—— 出自红宝书）</p>\n<p><code>parseFloat()</code> 只解析十进制值，因此它没有用第二个参数指定基数的用法。另外如果字符串没有小数点，或者小数点后都是零，<code>parseFloat()</code> 会返回整数。</p>\n<p><strong>转换规则</strong>：这 3 个函数都会忽略字符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或负号，就会返回 <code>NaN</code>，直到解析完所有后续字符或者遇到了一个非数字字符。<br>\n区别是 <code>parseInt()</code> 转换过程中，小数点不是有效的数字字符；而 <code>parseFloat()</code> 转换过程中，第一个小数点是有效的，后面的小数点是无效的，从第二个小数点开始的后面所有字符会被忽略。</p>\n<h3 id=\"bigint-类型-ecmascript-2020\"> BigInt 类型（ECMAScript 2020）</h3>\n<p>BigInt 类型是在 ECMAScript 2020（ES11）引入的新特性。</p>\n<p>JavaScript 中能够精确表达的最大数字是 <code>2^53 - 1</code>，即 <code>Number.MAX_SAFE_INTEGER</code>，如果超过了这个范围，运算结果就不再准确了。</p>\n<div><pre><code><span>const</span> max <span>=</span> Number<span>.</span><span>MAX_SAFE_INTEGER</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>max<span>)</span><span>;</span> <span>// 9007199254740991</span>\n\nconsole<span>.</span><span>log</span><span>(</span>max <span>+</span> <span>1</span><span>)</span><span>;</span> <span>// 9007199254740992</span>\nconsole<span>.</span><span>log</span><span>(</span>max <span>+</span> <span>2</span><span>)</span><span>;</span> <span>// 9007199254740992</span>\nconsole<span>.</span><span>log</span><span>(</span>max <span>+</span> <span>3</span><span>)</span><span>;</span> <span>// 9007199254740994</span>\nconsole<span>.</span><span>log</span><span>(</span>Math<span>.</span><span>pow</span><span>(</span><span>2</span><span>,</span> <span>53</span><span>)</span> <span>===</span> Math<span>.</span><span>pow</span><span>(</span><span>2</span><span>,</span> <span>53</span><span>)</span> <span>+</span> <span>1</span><span>)</span><span>;</span> <span>// true</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>而新的 BigInt 数据类型可以解决这个问题，它能够创建更大的数字。</p>\n<p>通过在数字末尾加上字母 <code>n</code>，就可以将它转换成 BigInt。但要注意，我们无法将标准数字与 BigInt 数字混合在一起计算，否则将抛出 TypeError。</p>\n<div><pre><code><span>const</span> bigNum <span>=</span> <span>100000000000000000000000000000n</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>bigNum <span>+</span> <span>1n</span><span>)</span><span>;</span> <span>// 200000000000000000000000000000n</span>\nconsole<span>.</span><span>log</span><span>(</span>bigNum <span>+</span> <span>1</span><span>)</span><span>;</span> <span>// TypeError: Cannot mix BigInt and other types, use explicit conversions</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"string-类型\"> String 类型</h3>\n<p>String 类型用于表示由零或多个 16 位 Unicode 字符组成的字符序列，即字符串。</p>\n<p><strong>数值转换字符串</strong></p>\n<p>要把一个值转换为一个字符串有两种方式：</p>\n<p>第一种，几乎每个值都有的 <code>toString()</code> 方法（除了 <code>null</code> 和 <code>undefined</code>）。其中数值型字符串在调用该方法时，可以传递一个参数——输出数值的基数（默认是十进制）。</p>\n<p>第二种，<code>String()</code> 函数，它在转换过程中，如果值有 <code>toString()</code> 方法，则调用该方法（没有参数）；如果值是 <code>null</code>，则返回 <code>&quot;null&quot;</code>；如果值是 <code>undefined</code>，则返回 <code>&quot;undefined&quot;</code>。</p>\n<h3 id=\"symbol-类型-ecmascript-2015\"> Symbol 类型（ECMAScript 2015）</h3>\n<p>Symbol 类型是在 ECMAScript 2015（ES6）引入的新特性。</p>\n<p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。因此 ES6 引入了一种新的基本数据类型 Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，</p>\n<p>关于 Symbol 的知识点可以参考阮一峰老师编写的《ES6标准入门（第3版）》中 <a href=\"https://es6.ruanyifeng.com/#docs/symbol\" title=\"Symbol - ECMAScript 6入门\" target=\"_blank\" rel=\"noopener noreferrer\">Symbol</a> 章节。</p>\n<h3 id=\"object-类型\"> Object 类型</h3>\n<p>JavaScript 中的对象是一组数据和功能的集合。对象可以通过执行 <code>new</code> 操作符后跟要创建的对象类型的名称来创建。</p>\n<p>简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。</p>\n<h2 id=\"判断数据类型\"> 判断数据类型</h2>\n<p>JavaScript 中判断数据类型主要有下列几种方式：</p>\n<h3 id=\"typeof\"> typeof</h3>\n<p><code>typeof</code> 只能区分基本类型：undefined、object、boolean、number、bigint，string，symbol，function，object，对于 null、array、object 来说，使用 typeof 都会统一返回 object 字符串。</p>\n<div><pre><code><span>typeof</span> <span>{</span><span>}</span> <span>// \"object\"</span>\n<span>typeof</span> <span>[</span><span>]</span> <span>// \"object\"</span>\n<span>typeof</span> <span>null</span> <span>// \"object\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"object-prototype-tostring-call\"> Object.prototype.toString.call()</h3>\n<p><code>Object.prototype.toString.call()</code> 能用于判断原生引用类型数据，返回一个形如 <code>&quot;[object XXX]&quot;</code> 的字符串。</p>\n<p>判断基本类型：</p>\n<div><pre><code><span>Object</span><span>.</span>prototype<span>.</span><span>toString</span><span>.</span><span>call</span><span>(</span><span>null</span><span>)</span><span>;</span> <span>// \"[object Null]\"</span>\n<span>Object</span><span>.</span>prototype<span>.</span><span>toString</span><span>.</span><span>call</span><span>(</span><span>undefined</span><span>)</span><span>;</span> <span>// \"[object Undefined]\"</span>\n<span>Object</span><span>.</span>prototype<span>.</span><span>toString</span><span>.</span><span>call</span><span>(</span><span>'abc'</span><span>)</span><span>;</span> <span>// \"[object String]\"</span>\n<span>Object</span><span>.</span>prototype<span>.</span><span>toString</span><span>.</span><span>call</span><span>(</span><span>123</span><span>)</span><span>;</span> <span>// \"[object Number]\"</span>\n<span>Object</span><span>.</span>prototype<span>.</span><span>toString</span><span>.</span><span>call</span><span>(</span><span>true</span><span>)</span><span>;</span> <span>// \"[object Boolean]\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>判断原生引用类型：</p>\n<div><pre><code><span>// 函数类型</span>\n<span>function</span> <span>fn</span><span>(</span><span>)</span><span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'test'</span><span>)</span><span>;</span>\n<span>}</span>\n<span>Object</span><span>.</span>prototype<span>.</span><span>toString</span><span>.</span><span>call</span><span>(</span>fn<span>)</span><span>;</span> <span>// \"[object Function]\"</span>\n\n<span>// 日期类型</span>\n<span>var</span> date <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>;</span>\n<span>Object</span><span>.</span>prototype<span>.</span><span>toString</span><span>.</span><span>call</span><span>(</span>date<span>)</span><span>;</span> <span>// \"[object Date]\"</span>\n\n<span>// 数组类型</span>\n<span>var</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>]</span><span>;</span>\n<span>Object</span><span>.</span>prototype<span>.</span><span>toString</span><span>.</span><span>call</span><span>(</span>arr<span>)</span><span>;</span> <span>// \"[object Array]\"</span>\n\n<span>// 正则表达式</span>\n<span>var</span> reg <span>=</span> <span><span>/</span><span>[hbc]at</span><span>/</span><span>gi</span></span><span>;</span>\n<span>Object</span><span>.</span>prototype<span>.</span><span>toString</span><span>.</span><span>call</span><span>(</span>reg<span>)</span><span>;</span> <span>// \"[object RegExp]\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>但是无法判断自定义类型：</p>\n<div><pre><code><span>function</span> <span>Person</span><span>(</span><span>name<span>,</span> age</span><span>)</span> <span>{</span>\n  <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n  <span>this</span><span>.</span>age <span>=</span> age<span>;</span>\n<span>}</span>\n<span>var</span> person <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>\"Rose\"</span><span>,</span> <span>18</span><span>)</span><span>;</span>\n<span>Object</span><span>.</span>prototype<span>.</span><span>toString</span><span>.</span><span>call</span><span>(</span>arr<span>)</span><span>;</span> <span>// \"[object Object]\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>很明显这种方法不能准确判断 <code>person</code> 是 <code>Person</code> 类的实例。</p>\n<h3 id=\"instanceof\"> instanceof</h3>\n<p><code>instanceof</code> 运算符用于测试构造函数的 <code>prototype</code> 属性是否出现在对象的原型链中的任何位置，</p>\n<p>可以用来判断某个构造函数的 <code>prototype</code> 属性是否存在另外一个要检测对象的原型链上，即判断一个对象是否是某个构造函数或其子构造函数的实例。</p>\n<p>它的用法类似于 <code>object instanceof class</code></p>\n<p>注意左侧必须是对象（object），如果不是，直接返回 false。</p>\n<div><pre><code><span>function</span> <span>Person</span><span>(</span><span>name<span>,</span> age</span><span>)</span> <span>{</span>\n  <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n  <span>this</span><span>.</span>age <span>=</span> age<span>;</span>\n<span>}</span>\n<span>var</span> person <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>\"Rose\"</span><span>,</span> <span>18</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>person <span>instanceof</span> <span>Person</span><span>)</span><span>;</span> <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id=\"数据类型转换\"> 数据类型转换</h2>\n<p>参考 <a href=\"https://www.runoob.com/js/js-type-conversion.html\" title=\"JavaScript 类型转换\" target=\"_blank\" rel=\"noopener noreferrer\">JavaScript 类型转换</a>。</p>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li>《JavaScript高级程序设计（第3版）》</li>\n<li>《ES6标准入门（第3版）》</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures\" title=\"JavaScript 数据类型和数据结构\" target=\"_blank\" rel=\"noopener noreferrer\">MDN：JavaScript 数据类型和数据结构</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T07:36:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "事件循环机制，微任务和宏任务的关系",
      "url": "https://www.fedbook.cn/frontend-knowledge/javascript/event-loop/",
      "id": "https://www.fedbook.cn/frontend-knowledge/javascript/event-loop/",
      "content_html": "<h1 id=\"事件循环机制-微任务和宏任务的关系\"> 事件循环机制，微任务和宏任务的关系</h1>\n<blockquote>\n<p>本文涉及到的名词：事件循环（Event Loop），宏任务（macro-task）与微任务（micro-task），执行栈和任务队列等。</p>\n</blockquote>\n<h2 id=\"前言\"> 前言</h2>\n<p>JavaScript 是单线程的，同一时间只能做一件事情。如果碰到某个耗时长的任务（比如一个需要 3s 的网络请求），那么后续的任务都要等待，这种效果是无法接受的，这时我们就引入了<a href=\"/frontend-knowledge/javascript/sync-and-async/\" title=\"同步与异步 Promise，async/await\">异步任务</a>的概念。</p>\n<p>所以 JavaScript 执行主要包括同步任务和异步任务：</p>\n<ul>\n<li><strong>同步任务</strong>：会放入到<a href=\"/frontend-knowledge/javascript/execution-context.html\" title=\"执行上下文\">执行栈</a>中，他们是要按顺序执行的任务；</li>\n<li><strong>异步任务</strong>：会放入到任务队列中，这些异步任务一定要等到执行栈清空后才会执行，也就是说异步任务一定是在同步任务之后执行的。</li>\n</ul>\n<p>本文所讲的 JavaScript 事件循环机制，它主要与异步任务有关。</p>\n<h2 id=\"消息队列\"> 消息队列</h2>\n<p>事件循环主要与消息队列有关，所以必须要先知道宏任务与微任务。</p>\n<p>在任务队列中，有两种任务：宏任务和微任务。</p>\n<p><strong>宏任务</strong>：script 标签中的整体代码、setTimeout、setInterval、setImmediate、I/O、UI渲染<br>\n<strong>微任务</strong>：process.nextTick（Node.js）、Promise、Object.observe（不常用）、MutationObserver（Node.js）</p>\n<p><strong>任务优先级</strong>：process.nextTick &gt; Promise.then &gt; setTimeout &gt; setImmediate</p>\n<p>以上这些是常见的宏任务和微任务，记住就行了，不用追究为什么它是宏任务或微任务，因为就是这样规定的。</p>\n<h2 id=\"事件循环\"> 事件循环</h2>\n<p>那么什么是事件循环机制呢？</p>\n<ul>\n<li>一开始整个脚本（script 标签中的整体代码）作为一个宏任务执行。</li>\n<li>执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列。</li>\n<li>当前宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）。</li>\n<li>当前宏任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染（浏览器会在两个宏任务交接期间，对页面进行重新渲染）。</li>\n<li>渲染完毕后，JavaScript 线程继续接管，开始下一个宏任务（从任务队列中获取），依此循环，直到宏任务和微任务队列都为空。</li>\n</ul>\n<p>上面这一过程就称为：事件循环（Event Loop）。</p>\n<p>说的通俗一点：宏任务和他所产生的微任务是绑定的，一个宏任务执行完成后，开始执行这个宏任务所产生的微任务，以及微任务产生的微任务。等它们全部执行完后，才会执行下一个宏任务。</p>\n<div style=\"text-align: center;\">\n  <svg id=\"SvgjsSvg1135\" width=\"581.5000305175781\" height=\"393.99998474121094\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><defs id=\"SvgjsDefs1136\"></defs><g id=\"SvgjsG1137\" transform=\"translate(25.000015258789062,24.99999237060547)\"><path id=\"SvgjsPath1138\" d=\"M 0 0L 94 0L 94 126L 0 126Z\" stroke=\"rgba(0,0,0,1)\" stroke-width=\"1\" fill-opacity=\"1\" fill=\"#f57f17\"></path><g id=\"SvgjsG1139\"><text id=\"SvgjsText1140\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"74px\" fill=\"#ffffff\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"51\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1141\" dy=\"20\" x=\"47\"><tspan id=\"SvgjsTspan1142\" style=\"text-decoration:;\">宏任务</tspan></tspan></text></g></g><g id=\"SvgjsG1143\" transform=\"translate(119.00001525878906,44.49999237060547)\"><path id=\"SvgjsPath1144\" d=\"M 0 0L 37 0L 37 87L 0 87Z\" stroke=\"rgba(0,0,0,1)\" stroke-width=\"1\" fill-opacity=\"1\" fill=\"#2196f3\"></path><g id=\"SvgjsG1145\"><text id=\"SvgjsText1146\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"17px\" fill=\"#ffffff\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"11.5\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1147\" dy=\"20\" x=\"18.5\"><tspan id=\"SvgjsTspan1148\" style=\"text-decoration:;\">微</tspan></tspan><tspan id=\"SvgjsTspan1149\" dy=\"20\" x=\"18.5\"><tspan id=\"SvgjsTspan1150\" style=\"text-decoration:;\">任</tspan></tspan><tspan id=\"SvgjsTspan1151\" dy=\"20\" x=\"18.5\"><tspan id=\"SvgjsTspan1152\" style=\"text-decoration:;\">务</tspan></tspan></text></g></g><g id=\"SvgjsG1153\" transform=\"translate(156.00001525878906,44.49999237060547)\"><path id=\"SvgjsPath1154\" d=\"M 0 0L 37 0L 37 87L 0 87Z\" stroke=\"rgba(0,0,0,1)\" stroke-width=\"1\" fill-opacity=\"1\" fill=\"#2196f3\"></path><g id=\"SvgjsG1155\"><text id=\"SvgjsText1156\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"17px\" fill=\"#ffffff\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"11.5\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1157\" dy=\"20\" x=\"18.5\"><tspan id=\"SvgjsTspan1158\" style=\"text-decoration:;\">微</tspan></tspan><tspan id=\"SvgjsTspan1159\" dy=\"20\" x=\"18.5\"><tspan id=\"SvgjsTspan1160\" style=\"text-decoration:;\">任</tspan></tspan><tspan id=\"SvgjsTspan1161\" dy=\"20\" x=\"18.5\"><tspan id=\"SvgjsTspan1162\" style=\"text-decoration:;\">务</tspan></tspan></text></g></g><g id=\"SvgjsG1163\" transform=\"translate(193.00001525878906,44.49999237060547)\"><path id=\"SvgjsPath1164\" d=\"M 0 0L 37 0L 37 87L 0 87Z\" stroke=\"rgba(0,0,0,1)\" stroke-width=\"1\" fill-opacity=\"1\" fill=\"#2196f3\"></path><g id=\"SvgjsG1165\"><text id=\"SvgjsText1166\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"17px\" fill=\"#ffffff\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"11.5\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1167\" dy=\"20\" x=\"18.5\"><tspan id=\"SvgjsTspan1168\" style=\"text-decoration:;\">微</tspan></tspan><tspan id=\"SvgjsTspan1169\" dy=\"20\" x=\"18.5\"><tspan id=\"SvgjsTspan1170\" style=\"text-decoration:;\">任</tspan></tspan><tspan id=\"SvgjsTspan1171\" dy=\"20\" x=\"18.5\"><tspan id=\"SvgjsTspan1172\" style=\"text-decoration:;\">务</tspan></tspan></text></g></g><g id=\"SvgjsG1173\" transform=\"matrix(-1.8369701987210297e-16,-1,1,-1.8369701987210297e-16,26.000015258789077,246.99999237060555)\"><path id=\"SvgjsPath1174\" d=\"M 90.00000000000006 0Q 81.00000000000006 0 81.00000000000006 9L 81.00000000000006 93.00000000000003Q 81.00000000000006 102.00000000000003 68.00000000000006 102.00000000000003Q 81.00000000000006 102.00000000000003 81.00000000000006 111.00000000000003L 81.00000000000006 195.00000000000006Q 81.00000000000006 204.00000000000006 90.00000000000006 204.00000000000006\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill=\"none\"></path><path id=\"SvgjsPath1175\" d=\"M 0 0L 90.00000000000006 0L 90.00000000000006 204.00000000000006L 0 204.00000000000006Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1176\"><text id=\"SvgjsText1177\" font-family=\"微软雅黑\" text-anchor=\"end\" font-size=\"13px\" width=\"64px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"end\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"92.37500000000003\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1178\" transform=\"translate(59.500015258789176,184.99999237060547)\"><path id=\"SvgjsPath1179\" d=\"M 0 0L 137 0L 137 43L 0 43Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1180\"><text id=\"SvgjsText1181\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"137px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"9.5\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1182\" dy=\"20\" x=\"68.5\"><tspan id=\"SvgjsTspan1183\" style=\"text-decoration:;\">一个事件循环结束</tspan></tspan></text></g></g><g id=\"SvgjsG1184\" transform=\"translate(259.00001525878906,57.99999237060547)\"><path id=\"SvgjsPath1185\" d=\"M 0 19.8L 38 19.8L 38 0L 68 30L 38 60L 38 40.2L 0 40.2L 0 19.8Z\" stroke=\"none\" fill-opacity=\"1\" fill=\"#2196f3\"></path><g id=\"SvgjsG1186\"><text id=\"SvgjsText1187\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"68px\" fill=\"#ffffff\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"20.375\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1188\" transform=\"translate(351.50001525878906,24.99999237060547)\"><path id=\"SvgjsPath1189\" d=\"M 0 0L 94 0L 94 126L 0 126Z\" stroke=\"rgba(0,0,0,1)\" stroke-width=\"1\" fill-opacity=\"1\" fill=\"#f57f17\"></path><g id=\"SvgjsG1190\"><text id=\"SvgjsText1191\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"74px\" fill=\"#ffffff\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"51\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1192\" dy=\"20\" x=\"47\"><tspan id=\"SvgjsTspan1193\" style=\"text-decoration:;\">宏任务</tspan></tspan></text></g></g><g id=\"SvgjsG1194\" transform=\"translate(445.50001525878906,44.49999237060547)\"><path id=\"SvgjsPath1195\" d=\"M 0 0L 37 0L 37 87L 0 87Z\" stroke=\"rgba(0,0,0,1)\" stroke-width=\"1\" fill-opacity=\"1\" fill=\"#2196f3\"></path><g id=\"SvgjsG1196\"><text id=\"SvgjsText1197\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"17px\" fill=\"#ffffff\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"11.5\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1198\" dy=\"20\" x=\"18.5\"><tspan id=\"SvgjsTspan1199\" style=\"text-decoration:;\">微</tspan></tspan><tspan id=\"SvgjsTspan1200\" dy=\"20\" x=\"18.5\"><tspan id=\"SvgjsTspan1201\" style=\"text-decoration:;\">任</tspan></tspan><tspan id=\"SvgjsTspan1202\" dy=\"20\" x=\"18.5\"><tspan id=\"SvgjsTspan1203\" style=\"text-decoration:;\">务</tspan></tspan></text></g></g><g id=\"SvgjsG1204\" transform=\"translate(482.50001525878906,44.49999237060547)\"><path id=\"SvgjsPath1205\" d=\"M 0 0L 37 0L 37 87L 0 87Z\" stroke=\"rgba(0,0,0,1)\" stroke-width=\"1\" fill-opacity=\"1\" fill=\"#2196f3\"></path><g id=\"SvgjsG1206\"><text id=\"SvgjsText1207\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"17px\" fill=\"#ffffff\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"11.5\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1208\" dy=\"20\" x=\"18.5\"><tspan id=\"SvgjsTspan1209\" style=\"text-decoration:;\">微</tspan></tspan><tspan id=\"SvgjsTspan1210\" dy=\"20\" x=\"18.5\"><tspan id=\"SvgjsTspan1211\" style=\"text-decoration:;\">任</tspan></tspan><tspan id=\"SvgjsTspan1212\" dy=\"20\" x=\"18.5\"><tspan id=\"SvgjsTspan1213\" style=\"text-decoration:;\">务</tspan></tspan></text></g></g><g id=\"SvgjsG1214\" transform=\"translate(519.5000152587891,44.49999237060547)\"><path id=\"SvgjsPath1215\" d=\"M 0 0L 37 0L 37 87L 0 87Z\" stroke=\"rgba(0,0,0,1)\" stroke-width=\"1\" fill-opacity=\"1\" fill=\"#2196f3\"></path><g id=\"SvgjsG1216\"><text id=\"SvgjsText1217\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"17px\" fill=\"#ffffff\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"11.5\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1218\" dy=\"20\" x=\"18.5\"><tspan id=\"SvgjsTspan1219\" style=\"text-decoration:;\">微</tspan></tspan><tspan id=\"SvgjsTspan1220\" dy=\"20\" x=\"18.5\"><tspan id=\"SvgjsTspan1221\" style=\"text-decoration:;\">任</tspan></tspan><tspan id=\"SvgjsTspan1222\" dy=\"20\" x=\"18.5\"><tspan id=\"SvgjsTspan1223\" style=\"text-decoration:;\">务</tspan></tspan></text></g></g><g id=\"SvgjsG1224\" transform=\"translate(351.50001525878906,242.99999237060547)\"><path id=\"SvgjsPath1225\" d=\"M 0 0L 94 0L 94 126L 0 126Z\" stroke=\"rgba(0,0,0,1)\" stroke-width=\"1\" fill-opacity=\"1\" fill=\"#f57f17\"></path><g id=\"SvgjsG1226\"><text id=\"SvgjsText1227\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"74px\" fill=\"#ffffff\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"51\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1228\" dy=\"20\" x=\"47\"><tspan id=\"SvgjsTspan1229\" style=\"text-decoration:;\">宏任务</tspan></tspan></text></g></g><g id=\"SvgjsG1230\" transform=\"translate(445.50001525878906,262.49999237060547)\"><path id=\"SvgjsPath1231\" d=\"M 0 0L 37 0L 37 87L 0 87Z\" stroke=\"rgba(0,0,0,1)\" stroke-width=\"1\" fill-opacity=\"1\" fill=\"#2196f3\"></path><g id=\"SvgjsG1232\"><text id=\"SvgjsText1233\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"17px\" fill=\"#ffffff\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"11.5\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1234\" dy=\"20\" x=\"18.5\"><tspan id=\"SvgjsTspan1235\" style=\"text-decoration:;\">微</tspan></tspan><tspan id=\"SvgjsTspan1236\" dy=\"20\" x=\"18.5\"><tspan id=\"SvgjsTspan1237\" style=\"text-decoration:;\">任</tspan></tspan><tspan id=\"SvgjsTspan1238\" dy=\"20\" x=\"18.5\"><tspan id=\"SvgjsTspan1239\" style=\"text-decoration:;\">务</tspan></tspan></text></g></g><g id=\"SvgjsG1240\" transform=\"translate(482.50001525878906,262.49999237060547)\"><path id=\"SvgjsPath1241\" d=\"M 0 0L 37 0L 37 87L 0 87Z\" stroke=\"rgba(0,0,0,1)\" stroke-width=\"1\" fill-opacity=\"1\" fill=\"#2196f3\"></path><g id=\"SvgjsG1242\"><text id=\"SvgjsText1243\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"17px\" fill=\"#ffffff\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"11.5\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1244\" dy=\"20\" x=\"18.5\"><tspan id=\"SvgjsTspan1245\" style=\"text-decoration:;\">微</tspan></tspan><tspan id=\"SvgjsTspan1246\" dy=\"20\" x=\"18.5\"><tspan id=\"SvgjsTspan1247\" style=\"text-decoration:;\">任</tspan></tspan><tspan id=\"SvgjsTspan1248\" dy=\"20\" x=\"18.5\"><tspan id=\"SvgjsTspan1249\" style=\"text-decoration:;\">务</tspan></tspan></text></g></g><g id=\"SvgjsG1250\" transform=\"translate(519.5000152587891,262.49999237060547)\"><path id=\"SvgjsPath1251\" d=\"M 0 0L 37 0L 37 87L 0 87Z\" stroke=\"rgba(0,0,0,1)\" stroke-width=\"1\" fill-opacity=\"1\" fill=\"#2196f3\"></path><g id=\"SvgjsG1252\"><text id=\"SvgjsText1253\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"17px\" fill=\"#ffffff\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"11.5\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1254\" dy=\"20\" x=\"18.5\"><tspan id=\"SvgjsTspan1255\" style=\"text-decoration:;\">微</tspan></tspan><tspan id=\"SvgjsTspan1256\" dy=\"20\" x=\"18.5\"><tspan id=\"SvgjsTspan1257\" style=\"text-decoration:;\">任</tspan></tspan><tspan id=\"SvgjsTspan1258\" dy=\"20\" x=\"18.5\"><tspan id=\"SvgjsTspan1259\" style=\"text-decoration:;\">务</tspan></tspan></text></g></g><g id=\"SvgjsG1260\" transform=\"matrix(6.123233995736766e-17,1,-1,6.123233995736766e-17,428.5,164)\"><path id=\"SvgjsPath1261\" d=\"M 0 19.8L 38 19.8L 38 0L 68 30L 38 60L 38 40.2L 0 40.2L 0 19.8Z\" stroke=\"none\" fill-opacity=\"1\" fill=\"#2196f3\"></path><g id=\"SvgjsG1262\"><text id=\"SvgjsText1263\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"68px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"20.375\" transform=\"rotate(0)\"></text></g></g></svg>\n  <p style=\"text-align: center; color: #888;\">（图解 JavaScript 事件循环）</p>\n</div>\n<h2 id=\"为什么要分两种任务\"> 为什么要分两种任务</h2>\n<p>每一个任务的执行当中，有可能会产生新的任务，那么这些新的任务有两种插入消息队列的方式：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/two-ways-insert-mq.svg\" alt=\"两种插入消息队列的方式\">\n  <p style=\"text-align: center; color: #888;\">（两种插入消息队列的方式）</p>\n</div>\n<p>这也主要是宏任务和微任务的区别，在任务执行过程中：</p>\n<ul>\n<li>产生的宏任务直接插入消息队列尾部依次执行。</li>\n<li>产生的微任务直接插入当前宏任务的微任务队列中，在此宏任务执行完成后，直接执行此宏任务的微任务队列。</li>\n</ul>\n<p>可以看出<strong>微任务在时效性和效率之间实现了一个有效的权衡</strong>。</p>\n<ul>\n<li>时效性方面，微任务归根结底还是异步执行的代码，所以它一定还是比同步代码要慢。</li>\n<li>效率方面，微任务的代码纯粹就是为了异步操作，并没有任何延时需要，所以它又是异步代码中最快的。</li>\n</ul>\n<p>而微任务的快体现在：它会在 DOM 重新渲染 + 宏任务执行之前，所以有这样一个结论：</p>\n<ul>\n<li><strong>微任务在 DOM 渲染前触发</strong></li>\n<li><strong>宏任务在 DOM 渲染后触发</strong></li>\n</ul>\n<h2 id=\"代码示例\"> 代码示例</h2>\n<p>我们执行如下一段代码，用上面的思路执行，看一下结果是否和预期的一致。</p>\n<div><pre><code>console<span>.</span><span>log</span><span>(</span><span>'script start'</span><span>)</span>\n\n<span>// 宏任务</span>\n<span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'setTimeout'</span><span>)</span>\n<span>}</span><span>,</span> <span>0</span><span>)</span>\n\n<span>// 微任务 跟在当前宏任务后面</span>\n<span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'new Promise'</span><span>)</span>\n  <span>resolve</span><span>(</span><span>)</span>\n  console<span>.</span><span>log</span><span>(</span><span>'promise body'</span><span>)</span>\n<span>}</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'promise.then 1'</span><span>)</span>\n<span>}</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'promise.then 2'</span><span>)</span>\n<span>}</span><span>)</span>\n\nconsole<span>.</span><span>log</span><span>(</span><span>'script end'</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>按照上面的思路，我们来理一下，预测一下执行结果，看看实际效果是否是这样的。</p>\n<p>执行流程：</p>\n<ul>\n<li>第一次事件循环\n<ul>\n<li>首先这一整段 JavaScript 代码作为一个宏任务先被执行</li>\n<li>遇到 <code>console.log('script start')</code>，打印出 <code>&quot;script start&quot;</code>；</li>\n<li>遇到 <code>setTimeout</code>，回调函数作为宏任务压入到宏任务队列中，此时宏任务队列：<code>[setTimeout]</code>；</li>\n<li>遇到 <code>new Promise</code>，由于 <code>new</code> 一个对象是瞬间执行的，不是异步，所以打印出 <code>&quot;new Promise&quot;</code>；</li>\n<li>继续执行，由于 Promise 中的异步逻辑在 <code>then</code> 里面，在 <code>then</code> 之前的都不是异步，所以打印出 <code>&quot;promise body&quot;</code>；</li>\n<li>遇到了第一个 <code>.then</code>，它是个微任务，将它放入微任务队列，跟在当前宏任务（整体代码）后面，此时微任务队列：<code>[promise 1]</code>；</li>\n<li>Promise 的第一个 <code>.then</code> 还没执行，只是排好队伍了，因此继续往后，遇到 <code>console.log('script end')</code>，打印出 <code>&quot;script end&quot;</code>。</li>\n<li>执行第一个宏任务后的微任务</li>\n<li>执行 Promise 的第一个 <code>.then</code>，打印出 <code>&quot;promise 1&quot;</code>，，此时微任务队列：<code>[]</code>；</li>\n<li>又遇到 <code>.then</code>，它是个微任务，将它放入微任务队列，跟在当前宏任务（整体代码）后面，此时微任务队列：<code>[promise 2]</code>；</li>\n<li>执行 Promise 的第二个 <code>.then</code>，打印出 <code>&quot;promise 2&quot;</code>，此时微任务队列：<code>[]</code>；</li>\n<li>整体代码执行完，微任务队列也执行完，当前的事件循环结束。</li>\n</ul>\n</li>\n<li>第二次事件循环\n<ul>\n<li>执行 <code>setTimeout</code> 的回调，打印出 <code>&quot;setTimeout&quot;</code>。</li>\n</ul>\n</li>\n</ul>\n<p>预测打印结果：</p>\n<div><pre><code>&quot;script start&quot;\n&quot;new Promise&quot;\n&quot;promise body&quot;\n&quot;script end&quot;\n&quot;promise.then 1&quot;\n&quot;promise.then 2&quot;\n&quot;setTimeout&quot;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>执行代码后可以发现，实际打印结果和预测一致。</p>\n<h2 id=\"复杂情况\"> 复杂情况</h2>\n<p>如果遇到更复杂的场景，比如当前微任务里有微任务，微任务里有宏任务，多层嵌套的情况，只需记住一句话：<strong>微任务跟在当前宏任务后面，执行完当前宏任务，微任务就跟上，然后再执行下一个宏任务</strong>。</p>\n<h2 id=\"应用场景\"> 应用场景</h2>\n<p>除了在前端面试中，会问到关于事件循环、执行栈的问题，了解 JavaScript 事件循环机制有没有实质的作用呢？</p>\n<ul>\n<li>以后我们在代码中使用 <code>Promise</code>，<code>setTimeout</code> 时，思路将更加清晰，用起来更佳得心应手。</li>\n<li>不要在 <code>.then()</code> 中写耗时的循环，会影响后续 DOM 渲染以及宏任务的释放。</li>\n<li>在阅读一些源码时，对于一些 <code>setTimeout</code> 相关的骚操作可以理解的更加深入。</li>\n<li>理解 JavaScript 中的任务执行流程，加深对异步流程的理解，少犯错误。</li>\n</ul>\n<h2 id=\"总结\"> 总结</h2>\n<ul>\n<li>JavaScript 事件循环总是从一个宏任务开始执行。</li>\n<li>一个事件循环过程中，只执行一个宏任务，但是可能执行多个微任务。</li>\n<li>执行栈中的任务产生的微任务会在当前事件循环内执行。</li>\n<li>执行栈中的任务产生的宏任务要在下一次事件循环才会执行。</li>\n</ul>\n<p>最后的最后，记住，JavaScript 是一门单线程语言，异步操作都是放到事件循环队列里面，等待主执行栈来执行的，并没有专门的异步执行线程。</p>\n<p>（完）</p>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2022-01-07T03:16:30.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "执行上下文和调用栈",
      "url": "https://www.fedbook.cn/frontend-knowledge/javascript/execution-context/",
      "id": "https://www.fedbook.cn/frontend-knowledge/javascript/execution-context/",
      "content_html": "<h1 id=\"执行上下文和调用栈\"> 执行上下文和调用栈</h1>\n<h2 id=\"执行上下文的分类\"> 执行上下文的分类</h2>\n<p>执行上下文是 JavaScript 执行一段代码时的运行环境，它一共有三种：</p>\n<ul>\n<li><strong>全局执行上下文</strong>：一个程序只有一个全局对象即 <code>window</code> 对象（浏览器的情况下），全局对象所处的执行上下文就是全局执行上下文。</li>\n<li><strong>函数执行上下文</strong>：每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。</li>\n<li><strong>Eval 函数执行上下文</strong>：执行在 <code>eval</code> 函数内部的代码也会有它属于自己的执行上下文（永远不要使用 <code>eval</code>！—— <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval\" title=\"eval() - JavaScript | MDN\" target=\"_blank\" rel=\"noopener noreferrer\">MDN</a>）。</li>\n</ul>\n<h2 id=\"执行上下文的产生\"> 执行上下文的产生</h2>\n<p>执行上下文的产生涉及两个阶段：</p>\n<ul>\n<li>JS 代码的编译阶段：创建全局执行上下文</li>\n<li>JS 代码的执行阶段：函数被调用时创建函数执行上下文</li>\n</ul>\n<h2 id=\"js-代码的编译阶段\"> JS 代码的编译阶段</h2>\n<p>一段 JavaScript 代码在执行之前需要被编译，编译完成之后，才会进入执行阶段。</p>\n<p>从 JavaScript 层面来讲，输入一段代码，经过编译后，会生成两部分内容：<strong>执行上下文</strong>（Execution Context）和可执行代码。</p>\n<div style=\"text-align: center;\">\n  <svg id=\"SvgjsSvg1006\" width=\"748.71875\" height=\"287\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><defs id=\"SvgjsDefs1007\"><marker id=\"SvgjsMarker1028\" markerWidth=\"16\" markerHeight=\"12\" refX=\"11\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1029\" d=\"M0,0 L16,6 L0,12 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1032\" markerWidth=\"16\" markerHeight=\"12\" refX=\"11\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1033\" d=\"M0,0 L16,6 L0,12 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker></defs><g id=\"SvgjsG1008\" transform=\"translate(25.006696428571445,116)\"><path id=\"SvgjsPath1009\" d=\"M 0 0L 120 0L 120 66L 0 66Z\" stroke=\"rgba(138,138,138,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1010\"><text id=\"SvgjsText1011\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"100px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"13.75\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1012\" dy=\"17\" x=\"60\"><tspan id=\"SvgjsTspan1013\" style=\"text-decoration:;\">输入一段</tspan></tspan><tspan id=\"SvgjsTspan1014\" dy=\"17\" x=\"60\"><tspan id=\"SvgjsTspan1015\" style=\"text-decoration:;\">JavaScript 代码</tspan></tspan></text></g></g><g id=\"SvgjsG1016\" transform=\"translate(220.578125,25)\"><path id=\"SvgjsPath1017\" d=\"M 0 0L 354 0L 354 237L 0 237Z\" stroke=\"rgba(138,138,138,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1018\"><text id=\"SvgjsText1019\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"334px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"108.875\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1020\" transform=\"translate(646.7209821428573,116)\"><path id=\"SvgjsPath1021\" d=\"M 0 0L 77 0L 77 66L 0 66Z\" stroke=\"rgba(138,138,138,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1022\"><text id=\"SvgjsText1023\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"57px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"22.25\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1024\" dy=\"17\" x=\"38.5\"><tspan id=\"SvgjsTspan1025\" style=\"text-decoration:;\">输出结果</tspan></tspan></text></g></g><g id=\"SvgjsG1026\"><path id=\"SvgjsPath1027\" d=\"M145.578125 151L180.578125 151L180.578125 151L215.578125 151\" stroke=\"#323232\" stroke-width=\"3\" fill=\"none\" marker-end=\"url(#SvgjsMarker1028)\"></path></g><g id=\"SvgjsG1030\"><path id=\"SvgjsPath1031\" d=\"M575.8638392857143 151L609.3638392857143 151L609.3638392857143 151L642.8638392857143 151\" stroke=\"#323232\" stroke-width=\"3\" fill=\"none\" marker-end=\"url(#SvgjsMarker1032)\"></path></g><g id=\"SvgjsG1034\" transform=\"translate(228.578125,36)\"><path id=\"SvgjsPath1035\" d=\"M 0 0L 338 0L 338 122L 0 122Z\" stroke=\"rgba(207,207,207,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1036\"><text id=\"SvgjsText1037\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"318px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"51.375\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1038\" transform=\"translate(340.578125,36)\"><path id=\"SvgjsPath1039\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1040\"><text id=\"SvgjsText1041\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"18px\" width=\"120px\" fill=\"#ff6666\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"18px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"6.25\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1042\" dy=\"22\" x=\"60\"><tspan id=\"SvgjsTspan1043\" style=\"text-decoration:;\">执行上下文</tspan></tspan></text></g></g><g id=\"SvgjsG1044\" transform=\"translate(234.078125,81)\"><path id=\"SvgjsPath1045\" d=\"M 0 0L 165.5 0L 165.5 64L 0 64Z\" stroke=\"rgba(138,138,138,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#66b2ff\"></path><g id=\"SvgjsG1046\"><text id=\"SvgjsText1047\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"146px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"12.75\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1048\" dy=\"17\" x=\"83\"><tspan id=\"SvgjsTspan1049\" style=\"text-decoration:;\">变量环境</tspan></tspan><tspan id=\"SvgjsTspan1050\" dy=\"17\" x=\"83\"><tspan id=\"SvgjsTspan1051\" style=\"text-decoration:;\">Variable Environment</tspan></tspan></text></g></g><g id=\"SvgjsG1052\" transform=\"translate(404.078125,81)\"><path id=\"SvgjsPath1053\" d=\"M 0 0L 157.5 0L 157.5 64L 0 64Z\" stroke=\"rgba(138,138,138,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ebebeb\"></path><g id=\"SvgjsG1054\"><text id=\"SvgjsText1055\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"138px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"12.75\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1056\" dy=\"17\" x=\"79\"><tspan id=\"SvgjsTspan1057\" style=\"text-decoration:;\">词法环境</tspan></tspan><tspan id=\"SvgjsTspan1058\" dy=\"17\" x=\"79\"><tspan id=\"SvgjsTspan1059\" style=\"text-decoration:;\">Lexical Environment</tspan></tspan></text></g></g><g id=\"SvgjsG1060\" transform=\"translate(228.578125,169)\"><path id=\"SvgjsPath1061\" d=\"M 0 0L 338 0L 338 80L 0 80Z\" stroke=\"rgba(138,138,138,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#66b2ff\"></path><g id=\"SvgjsG1062\"><text id=\"SvgjsText1063\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"318px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"29.25\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1064\" dy=\"17\" x=\"169\"><tspan id=\"SvgjsTspan1065\" style=\"text-decoration:;\">可执行代码</tspan></tspan></text></g></g><g id=\"SvgjsG1066\" transform=\"translate(118.578125,112)\"><path id=\"SvgjsPath1067\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1068\"><text id=\"SvgjsText1069\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"120px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"9.25\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1070\" dy=\"17\" x=\"60\"><tspan id=\"SvgjsTspan1071\" style=\"text-decoration:;\">编译代码</tspan></tspan></text></g></g><g id=\"SvgjsG1072\" transform=\"translate(549.578125,112)\"><path id=\"SvgjsPath1073\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1074\"><text id=\"SvgjsText1075\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"120px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"9.25\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1076\" dy=\"17\" x=\"60\"><tspan id=\"SvgjsTspan1077\" style=\"text-decoration:;\">执行代码</tspan></tspan></text></g></g></svg>\n  <p style=\"text-align: center; color: #888;\">（JavaScript 代码编译过程）</p>\n</div>\n<p>由上图可知，执行上下文在创建过程中还创建了两个对象：</p>\n<ul>\n<li>词法环境（Lexical Environment）</li>\n<li>变量环境（Viriable Environment）</li>\n</ul>\n<p>所以执行上下文可以用伪代码表示如下:</p>\n<div><pre><code>ExecutionContext <span>=</span> <span>{</span>\n  LexicalEnvironment <span>=</span> <span>&lt;</span>ref<span>.</span> to LexicalEnvironment <span>in</span> memory<span>></span><span>,</span>\n  VariableEnvironment <span>=</span> <span>&lt;</span>ref<span>.</span> to VariableEnvironment <span>in</span>  memory<span>></span><span>,</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"词法环境-lexical-environment\"> 词法环境（Lexical Environment）</h3>\n<h4 id=\"_1-定义\"> 1）定义</h4>\n<p>词法环境是一个包含<strong>标识符变量映射</strong>的结构。</p>\n<ul>\n<li>标识符：变量/函数的名字</li>\n<li>变量：对实际对象或原始数据的引用</li>\n</ul>\n<h4 id=\"_2-结构\"> 2）结构</h4>\n<p>词法环境由两个部分组成：</p>\n<ul>\n<li><strong>环境记录</strong>（enviroment record）：存储变量和函数声明，它分为两种：\n<ul>\n<li><strong>声明式环境记录</strong>（主要用于函数环境）：存储变量、函数和参数，主要用于函数。（函数环境下会存储 <code>arguments</code> 的值，形式 <code>{idx1:val1, idx2:val2, ..., length:num}</code>）</li>\n<li><strong>对象环境记录</strong>（主要用于全局环境）：除了变量和函数声明，还存储了一个全局对象 <code>window</code>（浏览器中）以及该全局对象提供的属性和方法。</li>\n</ul>\n</li>\n<li><strong>对外部环境的引用</strong>（outer）：可以通过它访问外部词法环境（也就是作用域链的原理）。</li>\n<li><strong>This 绑定</strong>：\n<ul>\n<li>全局执行上下文中，<code>this</code> 值指向全局变量（浏览器中是 <code>window</code> 对象）</li>\n<li>函数执行上下文中，<code>this</code> 的值的指向取决于函数的调用方式\n<ul>\n<li>被对象调用：<code>this</code>＝对象</li>\n<li>否则：<code>this</code>=全局对象（非严格模式），<code>this</code>=<code>undefined</code>（严格模式）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"_3-类型\"> 3）类型</h4>\n<p>词法环境有两种类型：</p>\n<ul>\n<li>全局环境：在全局执行上下文中。\n<ul>\n<li>拥有内建的 Object、Array 等。</li>\n<li>在环境记录内还有任何用户定义的全局变量和函数。</li>\n<li>外部环境引用是 <code>null</code>。</li>\n<li><code>this</code> 指向全局对象。</li>\n</ul>\n</li>\n<li>函数环境：在函数执行上下文中。\n<ul>\n<li>用户在函数内部定义的变量储存在环境记录中。</li>\n<li>对外部环境的引用可以是全局环境，也可以是任何包含此内部函数的外部函数。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"_4-特点\"> 4）特点</h4>\n<p>通过 <code>let</code> 和 <code>const</code> 声明的变量，在编译阶段会被存放到词法环境中。</p>\n<p>注意「<a href=\"https://es6.ruanyifeng.com/#docs/let\" target=\"_blank\" rel=\"noopener noreferrer\">暂时性死区</a>」问题：在代码块内，使用 <code>let</code> 命令声明变量之前，该变量都是不可用的（哪怕存在同名全局变量）。</p>\n<h3 id=\"变量环境-viriable-environment\"> 变量环境（Viriable Environment）</h3>\n<h4 id=\"_1-定义-2\"> 1）定义</h4>\n<p>变量环境也是词法环境，它具有上面定义的词法环境的所有属性和组件，主要的区别在于：</p>\n<p>在 ES6 中的区别：</p>\n<ul>\n<li>词法环境（Lexical Environment）用于存储函数声明和变量（通过 <code>let</code> 和 <code>const</code> 声明的变量）。</li>\n<li>变量环境（Variable Environment）仅用于存储变量（通过 <code>var</code> 声明的变量）。</li>\n</ul>\n<h4 id=\"_2-特点\"> 2）特点</h4>\n<p>在编译阶段，会声明所有 <code>var</code> 变量（初始值设为 <code>undefined</code>），然后将这些变量存放到变量环境中。</p>\n<p>这也是<strong>变量提升</strong>现象产生的原因：在一个变量定义之前使用它，不会报错，但是该变量的值此时为 <code>undefined</code>，而不是定义时的值。</p>\n<details><summary>变量提升</summary>\n<p>所谓变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的「行为」。变量被提升后，会给变量设置默认值 <code>undefined</code>。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/declaration-and-assignment-of-variables.png\" alt=\"变量的声明和赋值\" style=\"width: 550px;\">\n  <p style=\"text-align: center; color: #888;\">（变量的声明和赋值，图片来源于网络）</p>\n</div>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/declaration-and-assignment-of-functions.png\" alt=\"函数的声明和赋值\" style=\"width: 550px;\">\n  <p style=\"text-align: center; color: #888;\">（函数的声明和赋值，图片来源于网络）</p>\n</div>\n</details>\n<h2 id=\"js-代码的执行阶段\"> JS 代码的执行阶段</h2>\n<p>JavaScript 引擎按照顺序逐行执行编译生成的可执行代码。</p>\n<p>对所有变量的分配（赋值）也是在这个过程按照一行一行的执行顺序完成的。</p>\n<h3 id=\"调用栈-用来管理执行上下文\"> 调用栈：用来管理执行上下文</h3>\n<p>调用栈，也叫执行栈，它是<strong>一种用来管理执行上下文的数据结构</strong>，存储了在代码执行期间创建的所有执行上下文。因为是栈，所以遵循 LIFO（后进先出）的原则。</p>\n<p>当 JavaScript 引擎第一次遇到 JS 脚本时，它会创建一个全局的执行上下文并且压入当前调用栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。</p>\n<p>引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。</p>\n<h3 id=\"调用栈运行过程\"> 调用栈运行过程</h3>\n<ul>\n<li>首先创建全局执行上下文，压入栈底。</li>\n<li>每当调用一个函数时，创建函数的函数执行上下文，并且压入栈顶。</li>\n<li>当函数执行完成后，会从调用栈中弹出，JS 引擎继续执栈顶的函数。</li>\n<li>程序执行结束时，全局执行上下文弹出调用栈。</li>\n</ul>\n<p>以如下代码为例：</p>\n<div><pre><code><span>function</span> <span>foo</span><span>(</span><span>i</span><span>)</span> <span>{</span>\n  <span>if</span> <span>(</span>i <span>&lt;</span> <span>0</span><span>)</span> <span>return</span><span>;</span>\n  console<span>.</span><span>log</span><span>(</span><span>'begin:'</span> <span>+</span> i<span>)</span><span>;</span>\n  <span>foo</span><span>(</span>i <span>-</span> <span>1</span><span>)</span><span>;</span>\n  console<span>.</span><span>log</span><span>(</span><span>'end:'</span> <span>+</span> i<span>)</span><span>;</span>\n<span>}</span>\n<span>foo</span><span>(</span><span>2</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>当 JavaScript 引擎首次读取该脚本时，它会创建一个全局执行上下文并将其推入当前的调用栈底部。当调用一个函数时，引擎会为该函数创建一个新的执行上下文并将其推到当前调用栈的顶端。</p>\n<p>在新的执行上下文中，如果继续发生一个新函数调用，则继续创建新的执行上下文并推到当前调用栈的顶端，直到再无新函数调用。</p>\n<p>引擎会运行执行上下文在调用栈顶端的函数，当此函数运行完成后，其对应的执行上下文将会从调用栈中弹出，上下文控制权将移到当前调用栈的下一个执行上下文，直到全局执行上下文。</p>\n<p>当程序或浏览器关闭时，全局执行上下文也将退出并销毁。</p>\n<div style=\"text-align: center;\">\n  <svg id=\"SvgjsSvg1264\" width=\"815.875\" height=\"201.25\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><defs id=\"SvgjsDefs1265\"><marker id=\"SvgjsMarker1378\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1379\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1382\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1383\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1386\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1387\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1390\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1391\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1394\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1395\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1398\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1399\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker></defs><g id=\"SvgjsG1266\" transform=\"translate(25,138.25)\"><path id=\"SvgjsPath1267\" d=\"M 0 0L 99.11918274687855 0L 99.11918274687855 37.75L 0 37.75Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1268\"><text id=\"SvgjsText1269\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"80px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"0.925\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1270\" dy=\"16\" x=\"50\"><tspan id=\"SvgjsTspan1271\" style=\"text-decoration:;\">全局</tspan></tspan><tspan id=\"SvgjsTspan1272\" dy=\"16\" x=\"50\"><tspan id=\"SvgjsTspan1273\" style=\"text-decoration:;\">执行上下文</tspan></tspan></text></g></g><g id=\"SvgjsG1274\" transform=\"translate(136.2917139614075,138.25)\"><path id=\"SvgjsPath1275\" d=\"M 0 0L 99.11918274687855 0L 99.11918274687855 37.75L 0 37.75Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1276\"><text id=\"SvgjsText1277\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"80px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"0.925\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1278\" dy=\"16\" x=\"50\"><tspan id=\"SvgjsTspan1279\" style=\"text-decoration:;\">全局</tspan></tspan><tspan id=\"SvgjsTspan1280\" dy=\"16\" x=\"50\"><tspan id=\"SvgjsTspan1281\" style=\"text-decoration:;\">执行上下文</tspan></tspan></text></g></g><g id=\"SvgjsG1282\" transform=\"translate(246.71396140749152,138.25)\"><path id=\"SvgjsPath1283\" d=\"M 0 0L 99.11918274687855 0L 99.11918274687855 37.75L 0 37.75Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1284\"><text id=\"SvgjsText1285\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"80px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"0.925\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1286\" dy=\"16\" x=\"50\"><tspan id=\"SvgjsTspan1287\" style=\"text-decoration:;\">全局</tspan></tspan><tspan id=\"SvgjsTspan1288\" dy=\"16\" x=\"50\"><tspan id=\"SvgjsTspan1289\" style=\"text-decoration:;\">执行上下文</tspan></tspan></text></g></g><g id=\"SvgjsG1290\" transform=\"translate(357.1362088535755,138.25)\"><path id=\"SvgjsPath1291\" d=\"M 0 0L 99.11918274687855 0L 99.11918274687855 37.75L 0 37.75Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1292\"><text id=\"SvgjsText1293\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"80px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"0.925\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1294\" dy=\"16\" x=\"50\"><tspan id=\"SvgjsTspan1295\" style=\"text-decoration:;\">全局</tspan></tspan><tspan id=\"SvgjsTspan1296\" dy=\"16\" x=\"50\"><tspan id=\"SvgjsTspan1297\" style=\"text-decoration:;\">执行上下文</tspan></tspan></text></g></g><g id=\"SvgjsG1298\" transform=\"translate(468.427922814983,138.25)\"><path id=\"SvgjsPath1299\" d=\"M 0 0L 99.11918274687855 0L 99.11918274687855 37.75L 0 37.75Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1300\"><text id=\"SvgjsText1301\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"80px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"0.925\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1302\" dy=\"16\" x=\"50\"><tspan id=\"SvgjsTspan1303\" style=\"text-decoration:;\">全局</tspan></tspan><tspan id=\"SvgjsTspan1304\" dy=\"16\" x=\"50\"><tspan id=\"SvgjsTspan1305\" style=\"text-decoration:;\">执行上下文</tspan></tspan></text></g></g><g id=\"SvgjsG1306\" transform=\"translate(579.7196367763905,138.25)\"><path id=\"SvgjsPath1307\" d=\"M 0 0L 99.11918274687855 0L 99.11918274687855 37.75L 0 37.75Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1308\"><text id=\"SvgjsText1309\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"80px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"0.925\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1310\" dy=\"16\" x=\"50\"><tspan id=\"SvgjsTspan1311\" style=\"text-decoration:;\">全局</tspan></tspan><tspan id=\"SvgjsTspan1312\" dy=\"16\" x=\"50\"><tspan id=\"SvgjsTspan1313\" style=\"text-decoration:;\">执行上下文</tspan></tspan></text></g></g><g id=\"SvgjsG1314\" transform=\"translate(691.8808172531214,138.25)\"><path id=\"SvgjsPath1315\" d=\"M 0 0L 99.11918274687855 0L 99.11918274687855 37.75L 0 37.75Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1316\"><text id=\"SvgjsText1317\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"80px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"0.925\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1318\" dy=\"16\" x=\"50\"><tspan id=\"SvgjsTspan1319\" style=\"text-decoration:;\">全局</tspan></tspan><tspan id=\"SvgjsTspan1320\" dy=\"16\" x=\"50\"><tspan id=\"SvgjsTspan1321\" style=\"text-decoration:;\">执行上下文</tspan></tspan></text></g></g><g id=\"SvgjsG1322\" transform=\"translate(136.2917139614075,100.5)\"><path id=\"SvgjsPath1323\" d=\"M 0 0L 99.11918274687855 0L 99.11918274687855 37.75L 0 37.75Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1324\"><text id=\"SvgjsText1325\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"80px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.925\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1326\" dy=\"16\" x=\"50\"><tspan id=\"SvgjsTspan1327\" style=\"text-decoration:;\">foo(2)</tspan></tspan></text></g></g><g id=\"SvgjsG1328\" transform=\"translate(246.71396140749152,100.5)\"><path id=\"SvgjsPath1329\" d=\"M 0 0L 99.11918274687855 0L 99.11918274687855 37.75L 0 37.75Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1330\"><text id=\"SvgjsText1331\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"80px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.925\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1332\" dy=\"16\" x=\"50\"><tspan id=\"SvgjsTspan1333\" style=\"text-decoration:;\">foo(2)</tspan></tspan></text></g></g><g id=\"SvgjsG1334\" transform=\"translate(357.1362088535755,100.5)\"><path id=\"SvgjsPath1335\" d=\"M 0 0L 99.11918274687855 0L 99.11918274687855 37.75L 0 37.75Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1336\"><text id=\"SvgjsText1337\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"80px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.925\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1338\" dy=\"16\" x=\"50\"><tspan id=\"SvgjsTspan1339\" style=\"text-decoration:;\">foo(2)</tspan></tspan></text></g></g><g id=\"SvgjsG1340\" transform=\"translate(468.427922814983,100.5)\"><path id=\"SvgjsPath1341\" d=\"M 0 0L 99.11918274687855 0L 99.11918274687855 37.75L 0 37.75Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1342\"><text id=\"SvgjsText1343\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"80px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.925\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1344\" dy=\"16\" x=\"50\"><tspan id=\"SvgjsTspan1345\" style=\"text-decoration:;\">foo(2)</tspan></tspan></text></g></g><g id=\"SvgjsG1346\" transform=\"translate(579.7196367763905,100.5)\"><path id=\"SvgjsPath1347\" d=\"M 0 0L 99.11918274687855 0L 99.11918274687855 37.75L 0 37.75Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1348\"><text id=\"SvgjsText1349\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"80px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.925\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1350\" dy=\"16\" x=\"50\"><tspan id=\"SvgjsTspan1351\" style=\"text-decoration:;\">foo(2)</tspan></tspan></text></g></g><g id=\"SvgjsG1352\" transform=\"translate(246.71396140749152,62.75)\"><path id=\"SvgjsPath1353\" d=\"M 0 0L 99.11918274687855 0L 99.11918274687855 37.75L 0 37.75Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1354\"><text id=\"SvgjsText1355\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"80px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.925\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1356\" dy=\"16\" x=\"50\"><tspan id=\"SvgjsTspan1357\" style=\"text-decoration:;\">foo(1)</tspan></tspan></text></g></g><g id=\"SvgjsG1358\" transform=\"translate(357.1362088535755,62.75)\"><path id=\"SvgjsPath1359\" d=\"M 0 0L 99.11918274687855 0L 99.11918274687855 37.75L 0 37.75Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1360\"><text id=\"SvgjsText1361\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"80px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.925\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1362\" dy=\"16\" x=\"50\"><tspan id=\"SvgjsTspan1363\" style=\"text-decoration:;\">foo(1)</tspan></tspan></text></g></g><g id=\"SvgjsG1364\" transform=\"translate(468.427922814983,62.75)\"><path id=\"SvgjsPath1365\" d=\"M 0 0L 99.11918274687855 0L 99.11918274687855 37.75L 0 37.75Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1366\"><text id=\"SvgjsText1367\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"80px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.925\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1368\" dy=\"16\" x=\"50\"><tspan id=\"SvgjsTspan1369\" style=\"text-decoration:;\">foo(1)</tspan></tspan></text></g></g><g id=\"SvgjsG1370\" transform=\"translate(357.1362088535755,25)\"><path id=\"SvgjsPath1371\" d=\"M 0 0L 99.11918274687855 0L 99.11918274687855 37.75L 0 37.75Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1372\"><text id=\"SvgjsText1373\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"80px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.925\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1374\" dy=\"16\" x=\"50\"><tspan id=\"SvgjsTspan1375\" style=\"text-decoration:;\">foo(0)</tspan></tspan></text></g></g><g id=\"SvgjsG1376\"><path id=\"SvgjsPath1377\" d=\"M74.55959137343928 138.25L74.55959137343928 119.375L136.2917139614075 119.375\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1378)\"></path></g><g id=\"SvgjsG1380\"><path id=\"SvgjsPath1381\" d=\"M185.85130533484678 100.5L185.85130533484678 81.625L246.71396140749152 81.625\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1382)\"></path></g><g id=\"SvgjsG1384\"><path id=\"SvgjsPath1385\" d=\"M296.27355278093086 62.75L296.27355278093086 43.875L357.1362088535755 43.875\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1386)\"></path></g><g id=\"SvgjsG1388\"><path id=\"SvgjsPath1389\" d=\"M456.2553916004541 43.875L517.9875141884223 43.875L517.9875141884223 62.75\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1390)\"></path></g><g id=\"SvgjsG1392\"><path id=\"SvgjsPath1393\" d=\"M567.5471055618616 81.625L629.2792281498299 81.625L629.2792281498299 100.5\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1394)\"></path></g><g id=\"SvgjsG1396\"><path id=\"SvgjsPath1397\" d=\"M678.8388195232691 119.375L741.4404086265608 119.375L741.4404086265608 138.25\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1398)\"></path></g></svg>\n  <p style=\"text-align: center; color: #888;\">（JavaScript 调用栈运行过程）</p>\n</div>\n<p>最后输出结果：</p>\n<div><pre><code><span>\"begin:2\"</span>\n<span>\"begin:1\"</span>\n<span>\"begin:0\"</span>\n<span>\"end:0\"</span>\n<span>\"end:1\"</span>\n<span>\"end:2\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"调用栈大小\"> 调用栈大小</h3>\n<p>调用栈是有大小的，当入栈的执行上下文超过一定数目，或达到最大调用深度，就会出现栈溢出（Stack Overflow）的问题，这在递归代码中很容易出现。</p>\n<p>如下代码所示，会抛出错误信息：超过了最大栈调用大小（Maximum call stack size exceeded）。</p>\n<div><pre><code><span>function</span> <span>division</span><span>(</span><span>a<span>,</span>b</span><span>)</span><span>{</span>\n  <span>return</span> <span>division</span><span>(</span>a<span>,</span>b<span>)</span><span>;</span>\n<span>}</span>\nconsole<span>.</span><span>log</span><span>(</span><span>division</span><span>(</span><span>1</span><span>,</span><span>2</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div style=\"text-align: center;\">\n  <svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"408\" height=\"221\" viewBox=\"0 0 408 221\">\n    <image id=\"wenyuan_maximum-call-stack-size-exceeded\" data-name=\"wenyuan_maximum-call-stack-size-exceeded\" width=\"408\" height=\"221\" xlink:href=\"data:img/png;base64,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\"/>\n  </svg>\n  <p style=\"text-align: center; color: #888;\">（JavaScript 栈溢出错误）</p>\n</div>\n<p>那为什么会出现这个问题呢？这是因为当 JavaScript 引擎开始执行这段代码时，它首先调用函数 <code>division</code>，并创建执行环境，压入栈中；然而，这个函数是递归的，并且没有任何终止条件，所以它会一直创建新的函数执行环境，并反复将其压入栈中，但栈是有容量限制的，超过最大数量后就会出现栈溢出的错误。</p>\n<p>理解了栈溢出原因后，你就可以使用一些方法来避免或者解决栈溢出的问题，比如把递归调用的形式改造成其他形式，或者使用加入定时器的方法来把当前任务拆分为其他很多小任务。</p>\n<h2 id=\"伪代码演示全过程\"> 伪代码演示全过程</h2>\n<p>以执行下面这段代码为例，用伪代码来模拟从编译到执行全过程中，全局执行上下文和函数执行上下文的结构变化：</p>\n<div><pre><code><span>let</span> a <span>=</span> <span>20</span><span>;</span>\n<span>const</span> b <span>=</span> <span>30</span><span>;</span>\n<span>var</span> c<span>;</span>\n\n<span>function</span> <span>multiply</span><span>(</span><span>e<span>,</span> f</span><span>)</span> <span>{</span>\n <span>var</span> g <span>=</span> <span>20</span><span>;</span>\n <span>return</span> e <span>*</span> f <span>*</span> g<span>;</span>\n<span>}</span>\n\nc <span>=</span> <span>multiply</span><span>(</span><span>20</span><span>,</span> <span>30</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>首先，上述代码在执行之前需要被编译，编译完成之后的全局执行上下文看起来像这样：</p>\n<div><pre><code><span>// 全局执行上下文</span>\nGlobalExectionContext <span>=</span> <span>{</span>\n  <span>// 词法环境</span>\n  LexicalEnvironment<span>:</span> <span>{</span>\n    <span>// 对象环境记录(注意 Type 属性)</span>\n    EnvironmentRecord<span>:</span> <span>{</span>\n      Type<span>:</span> <span>\"Object\"</span><span>,</span>\n      <span>// 在这里绑定标识符,</span>\n      <span>// 注意到 let 和 const 声明的变量此时并没有任何初始值</span>\n      a<span>:</span> <span>&lt;</span> uninitialized <span>></span><span>,</span>\n      b<span>:</span> <span>&lt;</span> uninitialized <span>></span><span>,</span>\n      multiply<span>:</span> <span>&lt;</span> func <span>></span>\n    <span>}</span>\n    <span>// 外部引用</span>\n    outer<span>:</span> <span>&lt;</span><span>null</span><span>></span><span>,</span>\n    <span>// this 绑定</span>\n    ThisBinding<span>:</span> <span>&lt;</span>Global Object<span>></span>\n  <span>}</span><span>,</span>\n  <span>// 变量环境</span>\n  VariableEnvironment<span>:</span> <span>{</span>\n    <span>// 对象环境记录(注意 Type 属性)</span>\n    EnvironmentRecord<span>:</span> <span>{</span>\n      Type<span>:</span> <span>\"Object\"</span><span>,</span>\n      <span>// 在这里绑定标识符</span>\n      <span>// 注意到 var 声明的变量此时被设置了初始值 undefined</span>\n      c<span>:</span> <span>undefined</span><span>,</span>\n    <span>}</span>\n    <span>// 外部引用</span>\n    outer<span>:</span> <span>&lt;</span><span>null</span><span>></span><span>,</span>\n    <span>// this 绑定</span>\n    ThisBinding<span>:</span> <span>&lt;</span>Global Object<span>></span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>在执行阶段，完成变量赋值。因此，在执行阶段，全局执行上下文看起来像这样：</p>\n<div><pre><code>GlobalExectionContext <span>=</span> <span>{</span>\n  LexicalEnvironment<span>:</span> <span>{</span>\n    EnvironmentRecord<span>:</span> <span>{</span>\n      Type<span>:</span> <span>\"Object\"</span><span>,</span>\n      <span>// 此时 let 和 const 声明的变量可以被访问了</span>\n      a<span>:</span> <span>20</span><span>,</span>\n      b<span>:</span> <span>30</span><span>,</span>\n      multiply<span>:</span> <span>&lt;</span> func <span>></span>\n    <span>}</span>\n    outer<span>:</span> <span>&lt;</span><span>null</span><span>></span><span>,</span>\n    ThisBinding<span>:</span> <span>&lt;</span>Global Object<span>></span>\n  <span>}</span><span>,</span>\n  VariableEnvironment<span>:</span> <span>{</span>\n    EnvironmentRecord<span>:</span> <span>{</span>\n      Type<span>:</span> <span>\"Object\"</span><span>,</span>\n      c<span>:</span> <span>undefined</span><span>,</span>\n    <span>}</span>\n    outer<span>:</span> <span>&lt;</span><span>null</span><span>></span><span>,</span>\n    ThisBinding<span>:</span> <span>&lt;</span>Global Object<span>></span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>当函数 <code>multiply(20,30)</code> 被调用时，将创建一个新的函数执行上下文来执行函数代码。因此，在这个阶段函数执行上下文看起来像这样：</p>\n<div><pre><code><span>// 函数执行上下文</span>\nFunctionExectionContext <span>=</span> <span>{</span>\n  <span>// 词法环境</span>\n  LexicalEnvironment<span>:</span> <span>{</span>\n    <span>// 声明式环境记录(注意 Type 属性)</span>\n    EnvironmentRecord<span>:</span> <span>{</span>\n      Type<span>:</span> <span>\"Declarative\"</span><span>,</span>\n      <span>// 在这里绑定标识符</span>\n      <span>// 函数的词法环境中必然会存在一个 arguments 对象</span>\n      Arguments<span>:</span> <span>{</span><span>0</span><span>:</span> <span>20</span><span>,</span> <span>1</span><span>:</span> <span>30</span><span>,</span> length<span>:</span> <span>2</span><span>}</span><span>,</span>\n    <span>}</span><span>,</span>\n    <span>// 外部引用</span>\n    outer<span>:</span> <span>&lt;</span>GlobalLexicalEnvironment<span>></span><span>,</span>\n    <span>// this 绑定</span>\n    ThisBinding<span>:</span> <span>&lt;</span>Global Object or <span>undefined</span><span>></span><span>,</span>\n  <span>}</span><span>,</span>\n  <span>// 变量环境</span>\n  VariableEnvironment<span>:</span> <span>{</span>\n    <span>// 声明式环境记录(注意 Type 属性)</span>\n    EnvironmentRecord<span>:</span> <span>{</span>\n      Type<span>:</span> <span>\"Declarative\"</span><span>,</span>\n      <span>// 在这里绑定标识符</span>\n      <span>// 注意到 var 声明的变量此时被设置了初始值 undefined</span>\n      g<span>:</span> <span>undefined</span>\n    <span>}</span><span>,</span>\n    <span>// 外部引用</span>\n    outer<span>:</span> <span>&lt;</span>GlobalLexicalEnvironment<span>></span><span>,</span>\n    <span>// this 绑定</span>\n    ThisBinding<span>:</span> <span>&lt;</span>Global Object or <span>undefined</span><span>></span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>在此之后，执行上下文将经历执行阶段，这意味着完成对函数内变量的赋值。所以在执行阶段，函数执行上下文看起来像这样：</p>\n<div><pre><code>FunctionExectionContext <span>=</span> <span>{</span>\n  LexicalEnvironment<span>:</span> <span>{</span>\n    EnvironmentRecord<span>:</span> <span>{</span>\n      Type<span>:</span> <span>\"Declarative\"</span><span>,</span>\n      Arguments<span>:</span> <span>{</span><span>0</span><span>:</span> <span>20</span><span>,</span> <span>1</span><span>:</span> <span>30</span><span>,</span> length<span>:</span> <span>2</span><span>}</span><span>,</span>\n    <span>}</span><span>,</span>\n    outer<span>:</span> <span>&lt;</span>GlobalLexicalEnvironment<span>></span><span>,</span>\n    ThisBinding<span>:</span> <span>&lt;</span>Global Object or <span>undefined</span><span>></span><span>,</span>\n  <span>}</span><span>,</span>\n  VariableEnvironment<span>:</span> <span>{</span>\n    EnvironmentRecord<span>:</span> <span>{</span>\n      Type<span>:</span> <span>\"Declarative\"</span><span>,</span>\n      <span>// 注意到 var 声明的变量此时被赋值了</span>\n      g<span>:</span> <span>20</span>\n    <span>}</span><span>,</span>\n    outer<span>:</span> <span>&lt;</span>GlobalLexicalEnvironment<span>></span><span>,</span>\n    ThisBinding<span>:</span> <span>&lt;</span>Global Object or <span>undefined</span><span>></span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>函数完成后，返回值存储在 <code>c</code> 中。因此，更新全局词法环境。之后，全局代码完成，程序结束。</p>\n<p><strong>注意</strong>：</p>\n<ul>\n<li>只有在调用函数 <code>multiply</code> 时，函数执行上下文才会被创建。</li>\n<li>在代码编译后执行前，<code>let</code> 和 <code>const</code> 定义的变量并没有关联任何值，但 <code>var</code> 定义的变量被设成了 <code>undefined</code>。\n<ul>\n<li>这是因为在创建阶段时，JS 引擎检查代码找出变量和函数声明，虽然函数声明完全存储在环境中，但是变量最初设置为 <code>undefined</code>（<code>var</code> 情况下），或者未初始化（<code>let</code> 和 <code>const</code> 情况下）。</li>\n<li>这就是为什么你可以在声明之前访问 <code>var</code> 定义的变量（虽然是 <code>undefined</code>），但是在声明之前访问 <code>let</code> 和 <code>const</code> 的变量会得到一个引用错误。</li>\n<li>这就是我们说的<strong>变量声明提升</strong>和<strong>暂时性死区</strong>。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"曾经的-vo-ao\"> 曾经的 VO/AO</h2>\n<p>VO（变量对象）和 AO（活动对象）的概念是 ES3 提出的老概念，从 ES5 开始就用词法环境和变量环境替代了。</p>\n<p>虽然是过时的知识点，但也需要整理一下，因为不仅仅是换了个名字，功能和执行过程也是不一样的。</p>\n<h3 id=\"vo-变量对象\"> VO 变量对象</h3>\n<ul>\n<li>在 JS 代码执行前，全局执行上下文进入调用栈底，此时会生成一个全局对象（<code>window</code>），它就是一个 VO（全局变量对象）。\n<ul>\n<li>该对象所有的作用域（scope）都可以访问。</li>\n<li>里面会包含 Date、Array、String、Number、setTimeout、setInterval 等等。</li>\n<li>其中还有一个 <code>window</code> 属性指向自己。</li>\n<li>全局定义的变量、函数等也在这个 VO 中，但是并不会赋值 —— 变量提升。</li>\n</ul>\n</li>\n<li>在 JS 代码执行时，每一个函数执行上下文中都有一个自己的 VO（函数上下文中的变量对象）。\n<ul>\n<li>VO 用于存放当前上下文中（即当前函数中）定义的参数列表、内部变量和内部函数。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ao-活动对象\"> AO 活动对象</h3>\n<ul>\n<li>未进入执行阶段前，VO 中的属性不能直接访问。进入执行阶段后，AO 被创建并扮演 VO 的角色。\n<ul>\n<li>函数上下文中，活动对象 AO 作为变量对象 VO 使用。</li>\n<li>AO 中包含 VO、函数的形参、arguments</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"备注\"> 备注</h2>\n<p>这篇文章参考了很多资料，包括但不仅限于《JavaScript高级程序设计（第3版）》、《浏览器工作原理与实践》、《[译] 理解 JavaScript 中的执行上下文和执行栈》和国内众多文章。</p>\n<p>但在执行上下文那一块，我发现很多国内发表的文章都是一个模子，均是翻译自一篇国外的文章《<a href=\"https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0\" target=\"_blank\" rel=\"noopener noreferrer\">Understanding Execution Context and Execution Stack in Javascript</a>》，而现在原作者已经重新修改了文章内容，换言之<strong>国内的这些译文都已经过时了</strong>。同时网课里也有部分配图是绘制有误的，容易产生误导。</p>\n<p>（完）</p>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T07:36:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "数组遍历的几种方式",
      "url": "https://www.fedbook.cn/frontend-knowledge/javascript/array-iteration/",
      "id": "https://www.fedbook.cn/frontend-knowledge/javascript/array-iteration/",
      "content_html": "<h1 id=\"数组遍历的几种方式\"> 数组遍历的几种方式</h1>\n<h2 id=\"原生的-for-循环\"> 原生的 for 循环</h2>\n<p>最简单的一种循环遍历方法，也是使用频率最高的一种。</p>\n<div><pre><code><span>let</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>]</span><span>;</span>\n<span>for</span><span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>arr<span>[</span>i<span>]</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>有一种说法是，通过使用临时变量，将长度缓存起来，避免重复获取数组长度，这样当数组较大时能产生比较明显的优化效果，如下代码所示：</p>\n<div><pre><code><span>let</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>]</span><span>;</span>\n<span>for</span><span>(</span><span>let</span> i <span>=</span> <span>0</span><span>,</span> len <span>=</span> arr<span>.</span>length<span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>arr<span>[</span>i<span>]</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>但我查阅了很多资料，发现这已经是一种过时的优化方案了。随着浏览器解释器的不断改进，现在不再需要手动来优化，像 Chrome 的 V8 引擎就会把能确定不变的代码移到循环外。</p>\n<h2 id=\"for-in\"> for...in...</h2>\n<p>这个循环用的人也很多，但是效率最低（输出的 <code>key</code> 是数组索引）。</p>\n<div><pre><code><span>let</span> arr <span>=</span> <span>[</span><span>'我'</span><span>,</span> <span>'是'</span><span>,</span> <span>'谁'</span><span>,</span> <span>'我'</span><span>,</span> <span>'在'</span><span>,</span> <span>'哪'</span><span>]</span><span>;</span>\n<span>for</span><span>(</span><span>let</span> key <span>in</span> arr<span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>key<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"for-of-es6\"> for...of...（ES6）</h2>\n<p>虽然性能要好于 <code>for...in...</code>，但仍然比不上普通的 for 循环（不能循环对象）。</p>\n<div><pre><code><span>let</span> arr <span>=</span> <span>[</span><span>'我'</span><span>,</span> <span>'是'</span><span>,</span> <span>'谁'</span><span>,</span> <span>'我'</span><span>,</span> <span>'在'</span><span>,</span> <span>'哪'</span><span>]</span><span>;</span>\n<span>for</span><span>(</span><span>let</span> key <span>of</span> arr<span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>key<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"foreach\"> forEach</h2>\n<p>执行时，数组里的元素个数有几个，该方法里的回调就会执行几次。其中第一个参数是数组里的元素，第二个参数为数组里元素的索引，第三个参数则是数组自己。</p>\n<p>该方法是数组自带的遍历方法，虽然使用频率略高，但是性能仍然比普通循环略低。</p>\n<div><pre><code><span>let</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>]</span><span>;</span>\narr<span>.</span><span>forEach</span><span>(</span><span>function</span> <span>(</span><span>item<span>,</span> index<span>,</span> array</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>item<span>)</span><span>;</span>\n  console<span>.</span><span>log</span><span>(</span>array<span>)</span><span>;</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"map\"> map</h2>\n<p>遍历每一个元素并且返回对应的元素（可以返回处理后的元素），返回的新数组和旧数组的长度是一样的</p>\n<p>该方法使用比较广泛，但其性能还不如 forEach。</p>\n<div><pre><code><span>let</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>]</span><span>;</span>\n<span>let</span> newArr <span>=</span> arr<span>.</span><span>map</span><span>(</span><span>function</span> <span>(</span><span>item<span>,</span> index</span><span>)</span> <span>{</span>\n  <span>return</span> item <span>*</span> item<span>;</span>\n<span>}</span><span>)</span>\n\nconsole<span>.</span><span>log</span><span>(</span>newArr<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id=\"filter\"> filter</h2>\n<p>遍历数组，过滤出符合条件的元素并返回一个新数组。</p>\n<div><pre><code><span>let</span> arr <span>=</span> <span>[</span>\n  <span>{</span> id<span>:</span> <span>1</span><span>,</span> name<span>:</span> <span>'买笔'</span><span>,</span> done<span>:</span> <span>true</span> <span>}</span><span>,</span>\n  <span>{</span> id<span>:</span> <span>2</span><span>,</span> name<span>:</span> <span>'买笔记本'</span><span>,</span> done<span>:</span> <span>true</span> <span>}</span><span>,</span>\n  <span>{</span> id<span>:</span> <span>3</span><span>,</span> name<span>:</span> <span>'练字'</span><span>,</span> done<span>:</span> <span>false</span> <span>}</span>\n<span>]</span>\n    \n<span>let</span> newArr <span>=</span> arr<span>.</span><span>filter</span><span>(</span><span>function</span> <span>(</span><span>item<span>,</span> index</span><span>)</span> <span>{</span>\n  <span>return</span> item<span>.</span>done<span>;</span>\n<span>}</span><span>)</span>\n\nconsole<span>.</span><span>log</span><span>(</span>newArr<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id=\"some\"> some</h2>\n<p>遍历数组，只要有一个以上的元素满足条件就返回 <code>true</code>，否则返回 <code>false</code>。</p>\n<div><pre><code><span>let</span> arr <span>=</span> <span>[</span>\n  <span>{</span> id<span>:</span> <span>1</span><span>,</span> name<span>:</span> <span>'买笔'</span><span>,</span> done<span>:</span> <span>true</span> <span>}</span><span>,</span>\n  <span>{</span> id<span>:</span> <span>2</span><span>,</span> name<span>:</span> <span>'买笔记本'</span><span>,</span> done<span>:</span> <span>true</span> <span>}</span><span>,</span>\n  <span>{</span> id<span>:</span> <span>3</span><span>,</span> name<span>:</span> <span>'练字'</span><span>,</span> done<span>:</span> <span>false</span> <span>}</span>\n<span>]</span>\n\n<span>let</span> bool <span>=</span> arr<span>.</span><span>some</span><span>(</span><span>function</span> <span>(</span><span>item<span>,</span> index</span><span>)</span> <span>{</span>\n  <span>return</span> item<span>.</span>done<span>;</span>\n<span>}</span><span>)</span>\n\nconsole<span>.</span><span>log</span><span>(</span>bool<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id=\"every\"> every</h2>\n<p>遍历数组，每一个元素都满足条件 则返回 <code>true</code>，否则返回 <code>false</code></p>\n<div><pre><code><span>let</span> arr <span>=</span> <span>[</span>\n  <span>{</span> id<span>:</span> <span>1</span><span>,</span> name<span>:</span> <span>'买笔'</span><span>,</span> done<span>:</span> <span>true</span> <span>}</span><span>,</span>\n  <span>{</span> id<span>:</span> <span>2</span><span>,</span> name<span>:</span> <span>'买笔记本'</span><span>,</span> done<span>:</span> <span>true</span> <span>}</span><span>,</span>\n  <span>{</span> id<span>:</span> <span>3</span><span>,</span> name<span>:</span> <span>'练字'</span><span>,</span> done<span>:</span> <span>false</span> <span>}</span>\n<span>]</span>\n\n<span>let</span> bool <span>=</span> arr<span>.</span><span>every</span><span>(</span><span>function</span> <span>(</span><span>item<span>,</span> index</span><span>)</span> <span>{</span>\n  <span>return</span> item<span>.</span>done<span>;</span>\n<span>}</span><span>)</span>\n\nconsole<span>.</span><span>log</span><span>(</span>bool<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id=\"find-es6\"> find（ES6）</h2>\n<p>遍历数组，返回符合条件的第一个元素，如果没有符合条件的元素则返回 <code>undefined</code>。</p>\n<div><pre><code><span>let</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>]</span><span>;</span>\n\n<span>let</span> num <span>=</span> arr<span>.</span><span>find</span><span>(</span><span>function</span> <span>(</span><span>item<span>,</span> index</span><span>)</span> <span>{</span>\n  <span>return</span> item <span>===</span> <span>3</span><span>;</span>\n<span>}</span><span>)</span>\n\nconsole<span>.</span><span>log</span><span>(</span>num<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"findindex-es6\"> findIndex（ES6）</h2>\n<p>遍历数组，返回符合条件的第一个元素的索引，如果没有符合条件的元素则返回 <code>-1</code>。</p>\n<div><pre><code><span>let</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>]</span><span>;</span>\n\n<span>let</span> num <span>=</span> arr<span>.</span><span>findIndex</span><span>(</span><span>function</span> <span>(</span><span>item</span><span>)</span> <span>{</span>\n  <span>return</span> item <span>===</span> <span>3</span><span>;</span>\n<span>}</span><span>)</span>\n\nconsole<span>.</span><span>log</span><span>(</span>num<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"reduce、reduceright\"> reduce、reduceRight</h2>\n<p><code>reduce</code> 方法接收两个参数，第一个参数是回调函数（<code>callback</code>） ，第二个参数是初始值（<code>initialValue</code>）。</p>\n<p><code>reduceRight</code> 方法除了与 <code>reduce</code> 执行方向相反外（从右往左），其他完全与其一致。</p>\n<p>回调函数接收四个参数：</p>\n<ul>\n<li>accumulator：MDN 上解释为累计器，但我觉得不恰当，按我的理解它应该是截至当前元素，之前所有的数组元素被回调函数处理累计的结果。</li>\n<li>current：当前被执行的数组元素。</li>\n<li>currentIndex：当前被执行的数组元素索引。</li>\n<li>sourceArray：原数组，也就是调用 <code>reduce</code> 方法的数组。</li>\n</ul>\n<blockquote>\n<p>如果不传入初始值，reduce 方法会从索引 1 开始执行回调函数，如果传入初始值，将从索引 0 开始、并从初始值的基础上累计执行回调。</p>\n</blockquote>\n<h3 id=\"计算对象数组某一属性的总和\"> 计算对象数组某一属性的总和</h3>\n<div><pre><code><span>const</span> list  <span>=</span> <span>[</span>\n  <span>{</span> name<span>:</span> <span>'left'</span><span>,</span> width<span>:</span> <span>20</span> <span>}</span><span>,</span>\n  <span>{</span> name<span>:</span> <span>'center'</span><span>,</span> width<span>:</span> <span>70</span> <span>}</span><span>,</span>\n  <span>{</span> name<span>:</span> <span>'right'</span><span>,</span> width<span>:</span> <span>10</span> <span>}</span><span>,</span>\n<span>]</span><span>;</span>\n<span>const</span> total <span>=</span> list<span>.</span><span>reduce</span><span>(</span><span>(</span><span>currentTotal<span>,</span> item</span><span>)</span> <span>=></span> <span>{</span>\n  <span>return</span> currentTotal <span>+</span> item<span>.</span>width<span>;</span>\n<span>}</span><span>,</span> <span>0</span><span>)</span><span>;</span>\n<span>// total: 100</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"对象数组的去重-并统计每一项重复次数\"> 对象数组的去重，并统计每一项重复次数</h3>\n<div><pre><code><span>const</span> list  <span>=</span> <span>[</span>\n  <span>{</span> name<span>:</span> <span>'left'</span><span>,</span> width<span>:</span> <span>20</span> <span>}</span><span>,</span>\n  <span>{</span> name<span>:</span> <span>'right'</span><span>,</span> width<span>:</span> <span>10</span> <span>}</span><span>,</span>\n  <span>{</span> name<span>:</span> <span>'center'</span><span>,</span> width<span>:</span> <span>70</span> <span>}</span><span>,</span>\n  <span>{</span> name<span>:</span> <span>'right'</span><span>,</span> width<span>:</span> <span>10</span> <span>}</span><span>,</span>\n  <span>{</span> name<span>:</span> <span>'left'</span><span>,</span> width<span>:</span> <span>20</span> <span>}</span><span>,</span>\n  <span>{</span> name<span>:</span> <span>'right'</span><span>,</span> width<span>:</span> <span>10</span> <span>}</span><span>,</span>\n<span>]</span><span>;</span>\n<span>const</span> repeatTime <span>=</span> <span>{</span><span>}</span><span>;</span>\n<span>const</span> result <span>=</span> list<span>.</span><span>reduce</span><span>(</span><span>(</span><span>array<span>,</span> item</span><span>)</span> <span>=></span> <span>{</span>\n  <span>if</span> <span>(</span>repeatTime<span>[</span>item<span>.</span>name<span>]</span><span>)</span> <span>{</span>\n    repeatTime<span>[</span>item<span>.</span>name<span>]</span><span>++</span><span>;</span>\n    <span>return</span> array<span>;</span>\n  <span>}</span>\n  repeatTime<span>[</span>item<span>.</span>name<span>]</span> <span>=</span> <span>1</span><span>;</span>\n  <span>return</span> <span>[</span><span>...</span>array<span>,</span> item<span>]</span><span>;</span>\n<span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span>\n<span>// repeatTime: { left: 2, right: 3, center: 1 }</span>\n<span>// result: [</span>\n<span>//   { name: 'left', width: 20 },</span>\n<span>//   { name: 'right', width: 10 },</span>\n<span>//   { name: 'center', width: 70 },</span>\n<span>// ]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h3 id=\"对象数组最大-最小值获取\"> 对象数组最大/最小值获取</h3>\n<div><pre><code><span>const</span> list  <span>=</span> <span>[</span>\n  <span>{</span> name<span>:</span> <span>'left'</span><span>,</span> width<span>:</span> <span>20</span> <span>}</span><span>,</span>\n  <span>{</span> name<span>:</span> <span>'right'</span><span>,</span> width<span>:</span> <span>30</span> <span>}</span><span>,</span>\n  <span>{</span> name<span>:</span> <span>'center'</span><span>,</span> width<span>:</span> <span>70</span> <span>}</span><span>,</span>\n  <span>{</span> name<span>:</span> <span>'top'</span><span>,</span> width<span>:</span> <span>40</span> <span>}</span><span>,</span>\n  <span>{</span> name<span>:</span> <span>'bottom'</span><span>,</span> width<span>:</span> <span>20</span> <span>}</span><span>,</span>\n<span>]</span><span>;</span>\n<span>const</span> max <span>=</span> list<span>.</span><span>reduce</span><span>(</span><span>(</span><span>curItem<span>,</span> item</span><span>)</span> <span>=></span> <span>{</span>\n  <span>return</span> curItem<span>.</span>width <span>>=</span> item<span>.</span>width <span>?</span> curItem <span>:</span> item<span>;</span>\n<span>}</span><span>)</span><span>;</span>\n<span>const</span> min <span>=</span> list<span>.</span><span>reduce</span><span>(</span><span>(</span><span>curItem<span>,</span> item</span><span>)</span> <span>=></span> <span>{</span>\n  <span>return</span> curItem<span>.</span>width <span>&lt;=</span> item<span>.</span>width <span>?</span> curItem <span>:</span> item<span>;</span>\n<span>}</span><span>)</span><span>;</span>\n<span>// max: { name: \"center\", width: 70 }</span>\n<span>// min: { name: \"left\", width: 20 }</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><code>reduce</code> 很强大，更多奇技淫巧推荐查看这篇《<a href=\"https://juejin.cn/post/6844904063729926152\" target=\"_blank\" rel=\"noopener noreferrer\">25个你不得不知道的数组reduce高级用法</a>》</p>\n<h2 id=\"总结\"> 总结</h2>\n<h3 id=\"性能对比\"> 性能对比</h3>\n<p>说了这么多，那这些遍历方法， 在性能上有什么差异呢？我们在 Chrome 浏览器中尝试。我采用每个循环执行 10 次，去除最大、最小值，取平均数，降低误差。</p>\n<div><pre><code><span>var</span> list <span>=</span> <span>Array</span><span>(</span><span>100000</span><span>)</span><span>.</span><span>fill</span><span>(</span><span>1</span><span>)</span>\n\nconsole<span>.</span><span>time</span><span>(</span><span>'for'</span><span>)</span><span>;</span>\n<span>for</span> <span>(</span><span>let</span> index <span>=</span> <span>0</span><span>,</span> len <span>=</span> list<span>.</span>length<span>;</span> index <span>&lt;</span> len<span>;</span> index<span>++</span><span>)</span> <span>{</span>\n<span>}</span>\nconsole<span>.</span><span>timeEnd</span><span>(</span><span>'for'</span><span>)</span><span>;</span>\n<span>// for: 2.427642822265625 ms</span>\n\nconsole<span>.</span><span>time</span><span>(</span><span>'every'</span><span>)</span><span>;</span>\nlist<span>.</span><span>every</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span> <span>return</span> <span>true</span> <span>}</span><span>)</span>\nconsole<span>.</span><span>timeEnd</span><span>(</span><span>'every'</span><span>)</span>\n<span>// some: 2.751708984375 ms</span>\n\nconsole<span>.</span><span>time</span><span>(</span><span>'some'</span><span>)</span><span>;</span>\nlist<span>.</span><span>some</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span> <span>return</span> <span>false</span> <span>}</span><span>)</span>\nconsole<span>.</span><span>timeEnd</span><span>(</span><span>'some'</span><span>)</span>\n<span>// some: 2.786590576171875 ms</span>\n\nconsole<span>.</span><span>time</span><span>(</span><span>'foreach'</span><span>)</span><span>;</span>\nlist<span>.</span><span>forEach</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span><span>}</span><span>)</span>\nconsole<span>.</span><span>timeEnd</span><span>(</span><span>'foreach'</span><span>)</span><span>;</span>\n<span>// foreach: 3.126708984375 ms</span>\n\nconsole<span>.</span><span>time</span><span>(</span><span>'map'</span><span>)</span><span>;</span>\nlist<span>.</span><span>map</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span><span>}</span><span>)</span>\nconsole<span>.</span><span>timeEnd</span><span>(</span><span>'map'</span><span>)</span><span>;</span>\n<span>// map: 3.743743896484375 ms</span>\n\nconsole<span>.</span><span>time</span><span>(</span><span>'for...of...'</span><span>)</span><span>;</span>\n<span>for</span> <span>(</span><span>let</span> index <span>of</span> list<span>)</span> <span>{</span>\n<span>}</span>\nconsole<span>.</span><span>timeEnd</span><span>(</span><span>'for...of...'</span><span>)</span>\n<span>// forof: 6.33380126953125 ms</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>从打印结果可以看出，原生 <code>for</code> 循环的速度最快，<code>for...of...</code> 循环最慢。</p>\n<h3 id=\"终止遍历的支持度、性能对比\"> 终止遍历的支持度、性能对比</h3>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>是否可终止</th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n<td><b>break</b></td>\n<td><b>continue</b></td>\n<td><b>return</b></td>\n<td><b>性能（ms）</b></td>\n</tr>\n<tr>\n<td>for</td>\n<td>终止 ✔️</td>\n<td>跳出本次循环✔️</td>\n<td>❌</td>\n<td>2.42</td>\n</tr>\n<tr>\n<td>forEach</td>\n<td>❌      ️</td>\n<td>❌</td>\n<td>❌</td>\n<td>3.12</td>\n</tr>\n<tr>\n<td>map</td>\n<td>❌      ️</td>\n<td>❌</td>\n<td>❌</td>\n<td>3.74</td>\n</tr>\n<tr>\n<td>for...of...</td>\n<td>终止 ✔️</td>\n<td>跳出本次循环 ✔️</td>\n<td>❌</td>\n<td>6.33</td>\n</tr>\n<tr>\n<td>some</td>\n<td>❌️</td>\n<td>❌</td>\n<td>return true ✔️</td>\n<td>2.78</td>\n</tr>\n<tr>\n<td>every</td>\n<td>❌️</td>\n<td>❌</td>\n<td>return false ✔️</td>\n<td>2.75</td>\n</tr>\n</tbody>\n</table>\n<p>注意：不同浏览器内核会有些差异，具体情况需另行测试。</p>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/6973942/is-optimizing-javascript-for-loops-really-necessary\" title=\"Is optimizing JavaScript for loops really necessary?\" target=\"_blank\" rel=\"noopener noreferrer\">Is optimizing JavaScript for loops really necessary?</a></li>\n<li><a href=\"https://www.zhihu.com/question/29714976\" title=\"JavaScript 有必要缓存 for 循环中的 Array.length 吗？\" target=\"_blank\" rel=\"noopener noreferrer\">JavaScript 有必要缓存 for 循环中的 Array.length 吗？</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T07:36:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "声明函数的六种方式",
      "url": "https://www.fedbook.cn/frontend-knowledge/javascript/function-declare/",
      "id": "https://www.fedbook.cn/frontend-knowledge/javascript/function-declare/",
      "content_html": "<h1 id=\"声明函数的六种方式\"> 声明函数的六种方式</h1>\n<h2 id=\"前言\"> 前言</h2>\n<p>在 JavaScript 中，函数由许多组件组成并受它们影响：</p>\n<ul>\n<li>函数体的代码</li>\n<li>参数列表</li>\n<li>可以从词法作用域访问的变量</li>\n<li>返回值</li>\n<li>调用该函数时的上下文 <code>this</code></li>\n<li>命名函数或匿名函数</li>\n<li>保存函数对象的变量</li>\n<li>arguments 对象（在箭头函数中没有）</li>\n</ul>\n<p>本文介绍六种声明 JavaScript 函数的方式，分别介绍他们的声明语法、示例和常见的陷阱。并总结在特定的情况下何时使用特定的函数类型。</p>\n<h2 id=\"函数声明\"> 函数声明</h2>\n<h3 id=\"基本语法\"> 基本语法</h3>\n<p>函数声明由 <code>function</code> 关键字、必需的函数名、一对括号中的参数列表 <code>(param1, …, paramN)</code> 和一对包裹着主体代码的花括号 <code>{ … }</code> 组成。</p>\n<p>示例：</p>\n<div><pre><code><span>function</span> <span>name</span><span>(</span><span>param1<span>,</span> …<span>,</span> paramN</span><span>)</span> <span>{</span>\n  statements\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>\n<li><strong>name</strong>：函数名，必须有。</li>\n<li><strong>param</strong>：要传递给函数的参数的名称。不同引擎中的最大参数数量不同。</li>\n<li><strong>statements</strong>：包含函数体的语句。</li>\n</ul>\n<h3 id=\"变量提升\"> 变量提升</h3>\n<p>函数声明会在当前作用域内创建一个变量，它的标识符就是函数名，它的值就是函数对象。</p>\n<p>我们都知道变量提升，对于函数而言，它会被提升到当前作用域的顶层，因此在编写代码时，可以在函数声明前就进行调用。</p>\n<p>函数声明的一个重要特性是它的变量提升机制，也就是同一作用域内允许在声明之前被调用。</p>\n<p>变量提升在某些场景下是很有用的。例如，你想在一个 JavaScript 脚本的开头就知道某个函数是如何被调用的，并不关心这个函数的具体实现。那么就可以把函数具体实现放在文件的下面，这样在阅读时不用滚到底部查看。</p>\n<p>此时创建的函数是一个具名函数，函数对象的 <code>name</code> 属性值就是它的名称。当你需要查看堆栈信息进行调试和查错时，该属性会非常有用。</p>\n<p>可以通过下面的例子来理解：</p>\n<div><pre><code><span>// 变量提升</span>\nconsole<span>.</span><span>log</span><span>(</span><span>hello</span><span>(</span><span>'Aliens'</span><span>)</span><span>)</span><span>;</span> <span>// \"Hello Aliens!\"</span>\n<span>// 命名的函数</span>\nconsole<span>.</span><span>log</span><span>(</span>hello<span>.</span>name<span>)</span><span>;</span>      <span>// \"hello\"</span>\n<span>// 变量保存了函数对象</span>\nconsole<span>.</span><span>log</span><span>(</span><span>typeof</span> hello<span>)</span><span>;</span>    <span>// \"function\"</span>\n\n<span>function</span> <span>hello</span><span>(</span><span>name</span><span>)</span> <span>{</span>\n  <span>return</span> <span><span>`</span><span>Hello </span><span><span>${</span>name<span>}</span></span><span>!</span><span>`</span></span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"适用场景\"> 适用场景</h3>\n<p>函数声明适用于常规函数：即某个函数你只需声明一次，并在多个地方调用它。</p>\n<p>示例：</p>\n<div><pre><code><span>function</span> <span>sum</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>{</span>\n  <span>return</span> a <span>+</span> b<span>;</span>\n<span>}</span>\n\n<span>sum</span><span>(</span><span>5</span><span>,</span> <span>6</span><span>)</span><span>;</span>           <span>// 11</span>\n<span>(</span><span>[</span><span>3</span><span>,</span> <span>7</span><span>]</span><span>)</span><span>.</span><span>reduce</span><span>(</span>sum<span>)</span> <span>// 10</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>由于函数声明在当前作用域中创建了一个变量，同时还是一个常规函数调用，所以它对于递归或分发事件监听器非常有用。与函数表达式或箭头函数相反，它不通过函数变量的名称创建绑定。</p>\n<p>例如，要递归计算阶乘，就必须访问的函数：</p>\n<div><pre><code><span>function</span> <span>factorial</span><span>(</span><span>n</span><span>)</span> <span>{</span>\n  <span>if</span> <span>(</span>n <span>===</span> <span>0</span><span>)</span> <span>{</span>\n    <span>return</span> <span>1</span><span>;</span>\n  <span>}</span>\n  <span>return</span> n <span>*</span> <span>factorial</span><span>(</span>n <span>-</span> <span>1</span><span>)</span><span>;</span>\n<span>}</span>\n<span>factorial</span><span>(</span><span>4</span><span>)</span><span>;</span> <span>// 24</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>在 <code>factorial()</code> 函数内部通过再次使用函数变量名 <code>factorial(n - 1)</code> 实现递归调用。</p>\n<p>上述需求也可以通过把一个函数表达式赋值给一个常规变量实现，例如：</p>\n<div><pre><code><span>const</span> <span>factorial</span> <span>=</span> <span>function</span><span>(</span><span>n</span><span>)</span> <span>{</span> … <span>}</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>但是函数声明 <code>function factorial(n)</code> 更简洁，因为不需要写 <code>const</code> 和 <code>=</code>。</p>\n<h3 id=\"和函数表达式的区别\"> 和函数表达式的区别</h3>\n<p>函数声明和函数表达式很容易混淆。它们看起来非常相似，但产生的函数具有不同的属性。</p>\n<p>一个容易记住的规则：函数声明总是以关键字 <code>function</code> 开头，否则它就是一个函数表达式。</p>\n<p>下面的示例是一个函数声明，它的语句以 <code>function</code> 关键字开头：</p>\n<div><pre><code><span>// 函数声明: 以 \"function\" 开始</span>\n<span>function</span> <span>isNil</span><span>(</span><span>value</span><span>)</span> <span>{</span>\n  <span>return</span> value <span>==</span> <span>null</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>在使用函数表达式的情况下，JavaScript 语句不以 <code>function</code> 关键字开头（它出现在语句代码的中间）：</p>\n<div><pre><code><span>// 函数表达式: 以\"const\"开头</span>\n<span>const</span> <span>isTruthy</span> <span>=</span> <span>function</span><span>(</span><span>value</span><span>)</span> <span>{</span>\n  <span>return</span> <span>!</span><span>!</span>value<span>;</span>\n<span>}</span><span>;</span>\n<span>// 函数表达式作为.filter()的参数</span>\n<span>const</span> numbers <span>=</span> <span>(</span><span>[</span><span>1</span><span>,</span> <span>false</span><span>,</span> <span>5</span><span>]</span><span>)</span><span>.</span><span>filter</span><span>(</span><span>function</span><span>(</span><span>item</span><span>)</span> <span>{</span>\n  <span>return</span> <span>typeof</span> item <span>===</span> <span>'number'</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n<span>// 函数表达式(IIFE): 以 \"(\"开头</span>\n<span>(</span><span>function</span> <span>messageFunction</span><span>(</span><span>message</span><span>)</span> <span>{</span>\n  <span>return</span> message <span>+</span> <span>' World!'</span><span>;</span>\n<span>}</span><span>)</span><span>(</span><span>'Hello'</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id=\"条件语句中的函数声明\"> 条件语句中的函数声明</h3>\n<p>一些 JavaScript 环境在调用一个出现在 <code>{ … }</code> 的 <code>if</code>、<code>for</code> 或 <code>while</code> 语句中的声明时会抛出异常。</p>\n<p>让我们启用严格模式，看看当一个函数声明在条件语句中：</p>\n<div><pre><code><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>\n  <span>'use strict'</span><span>;</span>\n  <span>if</span> <span>(</span><span>true</span><span>)</span> <span>{</span>\n    <span>function</span> <span>ok</span><span>(</span><span>)</span> <span>{</span>\n      <span>return</span> <span>'true ok'</span><span>;</span>\n    <span>}</span>\n  <span>}</span> <span>else</span> <span>{</span>\n    <span>function</span> <span>ok</span><span>(</span><span>)</span> <span>{</span>\n      <span>return</span> <span>'false ok'</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n  console<span>.</span><span>log</span><span>(</span><span>typeof</span> ok <span>===</span> <span>'undefined'</span><span>)</span><span>;</span> <span>// => true</span>\n  console<span>.</span><span>log</span><span>(</span><span>ok</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// Throws \"ReferenceError: ok is not defined\"</span>\n<span>}</span><span>)</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>当调用 <code>ok()</code> 时，JavaScript 抛出 <code>ReferenceError: ok is not defined</code>，因为函数声明在一个条件块中。</p>\n<p>条件语句中的函数声明在非严格模式下是允许的，但这使得代码很混乱。</p>\n<p>作为这些情况的一般规则，当函数应该在某些条件下才创建时，我们可以使用函数表达式。让我们看看如何处理：</p>\n<div><pre><code><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>\n  <span>'use strict'</span><span>;</span>\n  <span>let</span> ok<span>;</span>\n  <span>if</span> <span>(</span><span>true</span><span>)</span> <span>{</span>\n    <span>ok</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n      <span>return</span> <span>'true ok'</span><span>;</span>\n    <span>}</span><span>;</span>\n  <span>}</span> <span>else</span> <span>{</span>\n    <span>ok</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n      <span>return</span> <span>'false ok'</span><span>;</span>\n    <span>}</span><span>;</span>\n  <span>}</span>\n  console<span>.</span><span>log</span><span>(</span><span>typeof</span> ok <span>===</span> <span>'function'</span><span>)</span><span>;</span> <span>// true</span>\n  console<span>.</span><span>log</span><span>(</span><span>ok</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// \"true ok\"</span>\n<span>}</span><span>)</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>因为函数是一个常规对象，所以根据条件将它赋给一个变量。调用 <code>ok()</code> 工作正常，没有错误。</p>\n<h2 id=\"函数表达式\"> 函数表达式</h2>\n<h3 id=\"基本语法-2\"> 基本语法</h3>\n<p>函数表达式由 <code>function</code> 关键字、可选的函数名、一对括号中的参数列表 <code>(param1, …, paramN)</code> 和一对包裹着主体代码的花括号 <code>{ … }</code> 组成。</p>\n<p>示例：</p>\n<div><pre><code><span>let</span> <span>function_expression</span> <span>=</span> <span>function</span> <span>[</span>name<span>]</span><span>(</span><span>param1<span>,</span> …<span>,</span> paramN<span>]</span></span><span>)</span> <span>{</span>\n   statements\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>\n<li><strong>function_expression</strong>：被赋值的变量名。</li>\n<li><strong>name</strong>：函数名称，可被省略，此种情况下的函数是匿名函数（anonymous）。函数名称只是函数体中的一个本地变量。</li>\n<li><strong>statements</strong>：包含函数体的语句。</li>\n</ul>\n<h3 id=\"变量提升-2\"> 变量提升</h3>\n<div><p>注意</p>\n<p>没有变量提升</p>\n</div>\n<p>JavaScript 中的函数表达式没有提升，不像函数声明，你在定义函数表达式之前不能使用函数表达式。</p>\n<p>示例：</p>\n<div><pre><code><span>notHoisted</span><span>(</span><span>)</span><span>;</span> <span>// TypeError: notHoisted is not a function</span>\n\n<span>var</span> <span>notHoisted</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'bar'</span><span>)</span><span>;</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"适用场景-2\"> 适用场景</h3>\n<p>函数表达式创建了一个可以在不同情况下使用的函数对象：</p>\n<ul>\n<li>作为对象赋值给变量 <code>count = function(…){…}</code></li>\n<li>在对象上创建一个方法 <code>sum: function(){…}</code></li>\n<li>使用函数作为回调 <code>reduce(function(…){…})</code></li>\n<li>在函数体内部引用当前函数（递归调用），此时一定要是一个命名函数表达式</li>\n</ul>\n<div><pre><code><span>// 作为对象赋值给变量 </span>\n<span>const</span> <span>count</span> <span>=</span> <span>function</span><span>(</span><span>array</span><span>)</span> <span>{</span>\n  <span>return</span> array<span>.</span>length<span>;</span>\n<span>}</span><span>;</span>\n\n<span>const</span> methods <span>=</span> <span>{</span>\n  numbers<span>:</span> <span>[</span><span>1</span><span>,</span> <span>5</span><span>,</span> <span>8</span><span>]</span><span>,</span>\n  <span>sum</span><span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span> <span>// 在对象上创建一个方法</span>\n    <span>return</span> <span>this</span><span>.</span>numbers<span>.</span><span>reduce</span><span>(</span><span>function</span><span>(</span><span>acc<span>,</span> num</span><span>)</span> <span>{</span> <span>// 使用函数作为回调</span>\n      <span>return</span> acc <span>+</span> num<span>;</span>\n    <span>}</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span><span>;</span>\n\n<span>var</span> math <span>=</span> <span>{</span>\n  <span>'factorial'</span><span>:</span> <span>function</span> <span>factorial</span><span>(</span><span>n</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>n <span>&lt;=</span> <span>1</span><span>)</span>\n      <span>return</span> <span>1</span><span>;</span>\n    <span>return</span> n <span>*</span> <span>factorial</span><span>(</span>n <span>-</span> <span>1</span><span>)</span><span>;</span> <span>// 在函数体内部引用当前函数</span>\n  <span>}</span>\n<span>}</span><span>;</span>\n\n<span>count</span><span>(</span><span>[</span><span>5</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>]</span><span>)</span><span>;</span> <span>// 3</span>\nmethods<span>.</span><span>sum</span><span>(</span><span>)</span><span>;</span>    <span>// 14</span>\nmath<span>.</span><span>factorial</span><span>(</span><span>3</span><span>)</span><span>;</span> <span>// 6</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>函数表达式是 JavaScript 中最常用的部分，通常情况下，如果你喜欢简短的语法和词法上下文，就能经常看到函数表达式和箭头函数。</p>\n<h3 id=\"匿名函数表达式\"> 匿名函数表达式</h3>\n<p>函数表达式中，当它没有函数名称的时侯，则称为匿名函数（平时所说的匿名函数就属于函数表达式），此时 <code>name</code> 属性是一个空字符 <code>''</code>。</p>\n<p>示例：</p>\n<div><pre><code><span>(</span>\n  <span>function</span><span>(</span><span>variable</span><span>)</span> <span>{</span><span>return</span> <span>typeof</span> variable<span>;</span> <span>}</span>\n<span>)</span><span>.</span>name<span>;</span> <span>// ''</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>被函数表达式赋值的那个变量会有一个 <code>name</code> 属性，如果你把这个变量赋值给另一个变量的话，这个 <code>name</code> 属性的值也不会改变。</p>\n<p>如果函数是一个匿名函数，那 <code>name</code> 属性的值就是被赋值的变量的名称（隐式命名）。如果函数不是匿名的话，那 <code>name</code> 属性的值就是这个函数的名称（显式命名）。这对于箭头函数也同样适用（箭头函数没有名字，所以 <code>name</code> 属性的值就是被赋值的变量的名称）。</p>\n<p>示例：</p>\n<div><pre><code><span>var</span> <span>foo</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span><span>}</span>\nfoo<span>.</span>name <span>// \"foo\"</span>\n\n<span>var</span> bar <span>=</span> foo\nbar<span>.</span>name <span>// \"foo\"</span>\n\nconsole<span>.</span><span>log</span><span>(</span>foo <span>===</span> bar<span>)</span><span>;</span> <span>//true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"命名函数表达式\"> 命名函数表达式</h3>\n<p>当表达式指定了名称时，就是命名函数表达式。与简单的函数表达式相比，它有一些额外的特点：</p>\n<ul>\n<li><code>name</code> 属性就是函数名。</li>\n<li>在函数体内部，与函数同名的变量指向函数对象。</li>\n<li>在命名函数表达式中，函数名称可以在函数作用域内访问，但不能在外部访问。</li>\n</ul>\n<div><pre><code><span>var</span> <span>bar</span> <span>=</span> <span>function</span> <span>foo</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n\nconsole<span>.</span><span>log</span><span>(</span><span>typeof</span> foo<span>)</span> <span>// \"undefined\"</span>\nconsole<span>.</span><span>log</span><span>(</span>foo<span>.</span>name<span>)</span> <span>// ReferenceError: foo is not defined</span>\n\nconsole<span>.</span><span>log</span><span>(</span><span>typeof</span> bar<span>)</span> <span>// \"function\"</span>\nconsole<span>.</span><span>log</span><span>(</span>bar<span>.</span>name<span>)</span> <span>// \"foo\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>推荐命名函数和避免匿名函数可以获得以下好处：</p>\n<ul>\n<li>显式指定函数名时，错误消息和调用堆栈显示更详细的信息。</li>\n<li>通过减少匿名堆栈名称的数量，使调试更加舒适。</li>\n<li>从函数名可以看出函数的作用。</li>\n<li>可以在函数的作用域内访问函数，以进行递归调用或分发事件侦听器。</li>\n</ul>\n<h2 id=\"方法的定义\"> 方法的定义</h2>\n<p>从 ECMAScript 2015 开始，在对象初始化中引入了一种更简短定义方法的语法，这是一种把方法名直接赋给函数的简写方式，可用于对象常量和 ES2015 类的方法声明。</p>\n<h3 id=\"基本语法-3\"> 基本语法</h3>\n<p>你可以使用函数名来定义它们，后面跟着一对括号中的参数列表 <code>(param1, …, paramN)</code> 和一对包裹着主体代码的花括号 <code>{ … }</code>。</p>\n<p>示例：</p>\n<div><pre><code><span>const</span> obj <span>=</span> <span>{</span>\n  <span>foo</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>'bar'</span><span>;</span>\n  <span>}</span>\n<span>}</span><span>;</span>\n\nconsole<span>.</span><span>log</span><span>(</span>obj<span>.</span><span>foo</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// \"bar\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"适用场景-3\"> 适用场景</h3>\n<p><strong>封装对象方法</strong>：</p>\n<div><pre><code><span>const</span> collection <span>=</span> <span>{</span>\n  items<span>:</span> <span>[</span><span>]</span><span>,</span>\n  <span>add</span><span>(</span><span><span>...</span>items</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>items<span>.</span><span>push</span><span>(</span><span>...</span>items<span>)</span><span>;</span>\n  <span>}</span><span>,</span>\n  <span>get</span><span>(</span>index<span>)</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span>items<span>[</span>index<span>]</span><span>;</span>\n  <span>}</span>\n<span>}</span><span>;</span>\ncollection<span>.</span><span>add</span><span>(</span><span>'C'</span><span>,</span> <span>'Java'</span><span>,</span> <span>'PHP'</span><span>)</span><span>;</span>\ncollection<span>.</span><span>get</span><span>(</span><span>1</span><span>)</span> <span>// \"Java\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><code>collection</code> 对象中的 <code>add()</code> 和 <code>get()</code> 方法是使用简短的方法定义进行定义的。这些方法像常规方法这样调用：<code>collection.add(…)</code> 和 <code>collection.get(…)</code>。</p>\n<p>与传统的属性定义方法相比，使用名称、冒号和函数表达式 <code>add: function(…){…}</code> 这种简短方法定义的方法有以下几个优点:</p>\n<ul>\n<li>更短的语法更容易理解</li>\n<li>与函数表达式相反，简写方法定义创建一个指定的函数，这对调试很有用。</li>\n</ul>\n<p><strong>类方法的声明</strong>：</p>\n<div><pre><code><span>class</span> <span>Star</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>name</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n  <span>}</span>\n  <span>getMessage</span><span>(</span><span>message</span><span>)</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span>name <span>+</span> message<span>;</span>\n  <span>}</span>\n<span>}</span>\n<span>const</span> sun <span>=</span> <span>new</span> <span>Star</span><span>(</span><span>'Sun'</span><span>)</span><span>;</span>\nsun<span>.</span><span>getMessage</span><span>(</span><span>' is shining'</span><span>)</span> <span>// \"Sun is shining\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"计算得到的属性名和方法\"> 计算得到的属性名和方法</h3>\n<p>ECMAScript 2015 增加了一个很好的特性：在对象字面量和类中计算属性名。</p>\n<p>计算属性使用稍微不同的语法 <code>[methodName](){…}</code>，则方法定义如下:</p>\n<div><pre><code><span>const</span> addMethod <span>=</span> <span>'add'</span><span>,</span>\n  getMethod <span>=</span> <span>'get'</span><span>;</span>\n<span>const</span> collection <span>=</span> <span>{</span>\n  items<span>:</span> <span>[</span><span>]</span><span>,</span>\n  <span>[</span>addMethod<span>]</span><span>(</span><span><span>...</span>items</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>items<span>.</span><span>push</span><span>(</span><span>...</span>items<span>)</span><span>;</span>\n  <span>}</span><span>,</span>\n  <span>[</span>getMethod<span>]</span><span>(</span><span>index</span><span>)</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span>items<span>[</span>index<span>]</span><span>;</span>\n  <span>}</span>\n<span>}</span><span>;</span>\ncollection<span>[</span>addMethod<span>]</span><span>(</span><span>'C'</span><span>,</span> <span>'Java'</span><span>,</span> <span>'PHP'</span><span>)</span><span>;</span>\ncollection<span>[</span>getMethod<span>]</span><span>(</span><span>1</span><span>)</span> <span>// \"Java\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><code>[addMethod] (…) {…}</code> 和 <code>[getMethod](…){…}</code> 是具有计算属性名的简写方法声明。</p>\n<h2 id=\"箭头函数\"> 箭头函数</h2>\n<h3 id=\"基本语法-4\"> 基本语法</h3>\n<p>箭头函数表达式的语法比函数表达式更简洁，它是用一对括号定义的，其中包含参数列表 <code>(param1, param2, ……, paramN)</code>，然后是一个胖箭头 <code>=&gt;</code> 和一对包裹着主体代码的花括号 <code>{ … }</code>。</p>\n<p>并且没有自己的 <code>this</code>，<code>arguments</code>，<code>super</code> 或 <code>new.target</code>。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。</p>\n<p>当箭头函数只有一个参数时，可以省略括号。当它包含一个语句时，花括号也可以省略。</p>\n<p>示例：</p>\n<div><pre><code><span>const</span> <span>absValue</span> <span>=</span> <span>(</span><span>number</span><span>)</span> <span>=></span> <span>{</span>\n  <span>if</span> <span>(</span>number <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>\n    <span>return</span> <span>-</span>number<span>;</span>\n  <span>}</span>\n  <span>return</span> number<span>;</span>\n<span>}</span><span>;</span>\n<span>absValue</span><span>(</span><span>-</span><span>10</span><span>)</span><span>;</span> <span>// 10</span>\n<span>absValue</span><span>(</span><span>5</span><span>)</span><span>;</span>   <span>// 5</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><code>absValue</code> 是一个计算数字绝对值的箭头函数。</p>\n<h3 id=\"上下文透明性\"> 上下文透明性</h3>\n<p><code>this</code> 关键字是 JavaScript 的一个令人困惑的方面。因为函数创建自己的执行上下文，所以通常很难判断 <code>this</code> 的值。</p>\n<p>ECMAScript 2015 通过引入箭头函数改进了 <code>this</code> 的用法，该函数按词法获取上下文（或者直接使用外部域的 <code>this</code>）。这种方式很好，因为当函数需要获取它的封闭上下文的 <code>this</code> 时，不必使用 <code>.bind(this)</code> 或存储上下文 <code>var self = this</code>。</p>\n<p>让我们看看如何从外部函数继承 <code>this</code>：</p>\n<div><pre><code><span>class</span> <span>Numbers</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>array</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>array <span>=</span> array<span>;</span>\n  <span>}</span>\n  <span>addNumber</span><span>(</span><span>number</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>number <span>!==</span> <span>undefined</span><span>)</span> <span>{</span>\n       <span>this</span><span>.</span>array<span>.</span><span>push</span><span>(</span>number<span>)</span><span>;</span>\n    <span>}</span> \n    <span>return</span> <span>(</span><span>number</span><span>)</span> <span>=></span> <span>{</span> \n      console<span>.</span><span>log</span><span>(</span><span>this</span> <span>===</span> numbersObject<span>)</span><span>;</span> <span>// true</span>\n      <span>this</span><span>.</span>array<span>.</span><span>push</span><span>(</span>number<span>)</span><span>;</span>\n    <span>}</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n<span>const</span> numbersObject <span>=</span> <span>new</span> <span>Numbers</span><span>(</span><span>[</span><span>]</span><span>)</span><span>;</span>\n<span>const</span> addMethod <span>=</span> numbersObject<span>.</span><span>addNumber</span><span>(</span><span>)</span><span>;</span>\n\n<span>addMethod</span><span>(</span><span>1</span><span>)</span><span>;</span>\n<span>addMethod</span><span>(</span><span>5</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>numbersObject<span>.</span>array<span>)</span><span>;</span> <span>// [1, 5]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p><code>Numbers</code> 类有一个数字数组，并提供 <code>addNumber()</code> 方法来插入新数值。</p>\n<p>当在不提供参数的情况下调用 <code>addNumber()</code> 时，返回一个允许插入数字的闭包。这个闭包是一个 <code>this</code> 等于 <code>numbersObject</code> 实例的箭头函数，因为上下文是从 <code>addNumbers()</code> 方法按词法获取的。</p>\n<p>如果没有箭头函数，就必须手动指定上下文，使用像 <code>.bind()</code> 这样的方式进行变通：</p>\n<div><pre><code><span>//...</span>\n    <span>return</span> <span>function</span><span>(</span><span>number</span><span>)</span> <span>{</span> \n      console<span>.</span><span>log</span><span>(</span><span>this</span> <span>===</span> numbersObject<span>)</span><span>;</span> <span>// true</span>\n      <span>this</span><span>.</span>array<span>.</span><span>push</span><span>(</span>number<span>)</span><span>;</span>\n    <span>}</span><span>.</span><span>bind</span><span>(</span><span>this</span><span>)</span><span>;</span>\n<span>//...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>或将上下文存储到一个单独的变量 <code>var self = this</code>：</p>\n<div><pre><code><span>//...</span>\n    <span>const</span> self <span>=</span> <span>this</span><span>;</span>\n    <span>return</span> <span>function</span><span>(</span><span>number</span><span>)</span> <span>{</span> \n      console<span>.</span><span>log</span><span>(</span>self <span>===</span> numbersObject<span>)</span><span>;</span> <span>// true</span>\n      self<span>.</span>array<span>.</span><span>push</span><span>(</span>number<span>)</span><span>;</span>\n    <span>}</span><span>;</span>\n<span>//...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>当我们希望从封闭上下文中获取 <code>this</code> 时，就可以利用箭头函数的这种上下文透明性。</p>\n<h3 id=\"特点\"> 特点</h3>\n<p>箭头函数具有以下特点：</p>\n<ul>\n<li>箭头函数不会创建它的执行上下文，而是按词法处理它（与函数表达式或函数声明相反，它们根据调用创建自己的 <code>this</code>）。</li>\n<li>箭头函数是匿名的。但是，可以从保存函数的变量推断出它的名称。</li>\n<li><code>arguments</code> 对象在箭头函数中不可用（与提供 <code>arguments</code> 对象的其他声明类型相反）。但是，您可以自由地使用 <code>rest</code> 参数 <code>(param1, param2, ...rest) =&gt; { statements }</code>。</li>\n</ul>\n<h3 id=\"短语法\"> 短语法</h3>\n<p>在创建箭头函数时，对于单个参数和单个主体语句，括号对和花括号是可选的。这有助于创建非常简洁的回调函数。</p>\n<p>让我们创建一个函数找出包含 0 的数组：</p>\n<div><pre><code><span>const</span> numbers <span>=</span> <span>[</span><span>1</span><span>,</span> <span>5</span><span>,</span> <span>10</span><span>,</span> <span>0</span><span>]</span><span>;</span>\nnumbers<span>.</span><span>some</span><span>(</span><span>item</span> <span>=></span> item <span>===</span> <span>0</span><span>)</span><span>;</span> <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>但要注意，嵌套的短箭头函数很难理解，推荐的短语法使用场景是单个回调（不嵌套）。</p>\n<h2 id=\"生成器函数\"> 生成器函数</h2>\n<p>JavaScript 中的生成器函数返回生成器对象。它的语法类似于函数表达式、函数声明或方法声明，只是它需要一个星号 <code>*</code>。</p>\n<p>这里简单介绍一下，更推荐阅读阮一峰老师编写的《ES6标准入门（第3版）》中 <a href=\"https://es6.ruanyifeng.com/#docs/generator\" title=\"Generator - ECMAScript 6入门\" target=\"_blank\" rel=\"noopener noreferrer\">Generator</a> 相关的两个章节。</p>\n<p>生成器函数的声明形式如下：</p>\n<ul>\n<li>a. 函数声明形式 <code>function* &lt;name&gt;()</code></li>\n</ul>\n<div><pre><code><span>function</span><span>*</span> <span>indexGenerator</span><span>(</span><span>)</span><span>{</span>\n  <span>var</span> index <span>=</span> <span>0</span><span>;</span>\n  <span>while</span><span>(</span><span>true</span><span>)</span> <span>{</span>\n    <span>yield</span> index<span>++</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n<span>const</span> g <span>=</span> <span>indexGenerator</span><span>(</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>g<span>.</span><span>next</span><span>(</span><span>)</span><span>.</span>value<span>)</span><span>;</span> <span>// 0</span>\nconsole<span>.</span><span>log</span><span>(</span>g<span>.</span><span>next</span><span>(</span><span>)</span><span>.</span>value<span>)</span><span>;</span> <span>// 1</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ul>\n<li>b. 函数表达式形式 <code>function* ()</code></li>\n</ul>\n<div><pre><code><span>const</span> <span>indexGenerator</span> <span>=</span> <span>function</span><span>*</span> <span>(</span><span>)</span> <span>{</span>\n  <span>let</span> index <span>=</span> <span>0</span><span>;</span>\n  <span>while</span><span>(</span><span>true</span><span>)</span> <span>{</span>\n    <span>yield</span> index<span>++</span><span>;</span>\n  <span>}</span>\n<span>}</span><span>;</span>\n<span>const</span> g <span>=</span> <span>indexGenerator</span><span>(</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>g<span>.</span><span>next</span><span>(</span><span>)</span><span>.</span>value<span>)</span><span>;</span> <span>// 0</span>\nconsole<span>.</span><span>log</span><span>(</span>g<span>.</span><span>next</span><span>(</span><span>)</span><span>.</span>value<span>)</span><span>;</span> <span>// 1</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ul>\n<li>c. 简写方法定义形式 <code>*&lt;name&gt;()</code></li>\n</ul>\n<div><pre><code><span>const</span> obj <span>=</span> <span>{</span>\n  <span>*</span><span>indexGenerator</span><span>(</span><span>)</span> <span>{</span>\n    <span>var</span> index <span>=</span> <span>0</span><span>;</span>\n    <span>while</span><span>(</span><span>true</span><span>)</span> <span>{</span>\n      <span>yield</span> index<span>++</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span><span>;</span>\n<span>const</span> g <span>=</span> obj<span>.</span><span>indexGenerator</span><span>(</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>g<span>.</span><span>next</span><span>(</span><span>)</span><span>.</span>value<span>)</span><span>;</span> <span>// 0</span>\nconsole<span>.</span><span>log</span><span>(</span>g<span>.</span><span>next</span><span>(</span><span>)</span><span>.</span>value<span>)</span><span>;</span> <span>// 1</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>三种生成器函数都返回生成器对象 <code>g</code>，之后 <code>g</code> 用于生成一系列自增数字。</p>\n<h2 id=\"构造函数\"> 构造函数</h2>\n<h3 id=\"基本语法-5\"> 基本语法</h3>\n<div><pre><code><span>new</span> <span>Function</span> <span>(</span>param1<span>,</span> …<span>,</span> paramN<span>,</span>  functionBody<span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li><strong>param1, …, paramN</strong>：被函数使用的参数的名称，形式是一个有效的 JavaScript 标识符的字符串，或者一个用逗号分隔的有效字符串的列表。</li>\n<li><strong>functionBody</strong>：一个含有包括函数定义的 JavaScript 语句的字符串。</li>\n</ul>\n<h3 id=\"实例用法\"> 实例用法</h3>\n<p>上面介绍的五种声明方法，本质上创建了相同的函数对象类型。我们来看一个例子：</p>\n<div><pre><code><span>function</span> <span>sum1</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>{</span>\n  <span>return</span> a <span>+</span> b<span>;</span>\n<span>}</span>\n<span>const</span> <span>sum2</span> <span>=</span> <span>function</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>{</span>\n  <span>return</span> a <span>+</span> b<span>;</span>\n<span>}</span><span>;</span>\n<span>const</span> <span>sum3</span> <span>=</span> <span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> a <span>+</span> b<span>;</span>\nconsole<span>.</span><span>log</span><span>(</span><span>typeof</span> sum1 <span>===</span> <span>'function'</span><span>)</span><span>;</span> <span>// true</span>\nconsole<span>.</span><span>log</span><span>(</span><span>typeof</span> sum2 <span>===</span> <span>'function'</span><span>)</span><span>;</span> <span>// true</span>\nconsole<span>.</span><span>log</span><span>(</span><span>typeof</span> sum3 <span>===</span> <span>'function'</span><span>)</span><span>;</span> <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>函数对象类型有一个构造函数：<code>Function</code>。</p>\n<p>当 <code>Function</code> 被作为构造函数调用时，<code>new Function(param1, param2, …, paramN, bodyString)</code>，将创建一个新函数。参数 <code>param1, param2, …, paramN</code> 传递给构造函数成为新函数的参数名，最后一个参数 <code>bodyString</code> 用作函数体代码。</p>\n<p>让我们创建一个函数，两个数字的和：</p>\n<div><pre><code><span>const</span> numberA <span>=</span> <span>'numberA'</span><span>,</span> numberB <span>=</span> <span>'numberB'</span><span>;</span>\n<span>const</span> sumFunction <span>=</span> <span>new</span> <span>Function</span><span>(</span>numberA<span>,</span> numberB<span>,</span> \n   <span>'return numberA + numberB'</span>\n<span>)</span><span>;</span>\n<span>sumFunction</span><span>(</span><span>10</span><span>,</span> <span>15</span><span>)</span> <span>// 25</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>使用 <code>Function</code> 构造函数调用创建的 <code>sumFunction</code> 具有参数 <code>numberA</code> 和 <code>numberB</code>，并且主体返回 <code>numberA + numberB</code>。</p>\n<p>以这种方式创建的函数不能访问当前作用域，因此无法创建闭包，因此它们总是在全局域内创建。</p>\n<p>在浏览器或 Node.js 脚本中访问全局对象的更好方式是 <code>new Function</code> 的应用：</p>\n<div><pre><code><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>\n  <span>'use strict'</span><span>;</span>\n  <span>const</span> global <span>=</span> <span>new</span> <span>Function</span><span>(</span><span>'return this'</span><span>)</span><span>(</span><span>)</span><span>;</span>\n  console<span>.</span><span>log</span><span>(</span>global <span>===</span> window<span>)</span><span>;</span> <span>// true</span>\n  console<span>.</span><span>log</span><span>(</span><span>this</span> <span>===</span> window<span>)</span><span>;</span>   <span>// false</span>\n<span>}</span><span>)</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>请记住，几乎不应该使用 <code>new Function()</code> 来声明函数。因为函数体是在运行时执行的，所以这种方法继承了许多 <code>eval()</code> 使用问题：安全风险、更难调试、无法应用引擎优化、没有编辑器自动补全。</p>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function\" title=\"function declaration\" target=\"_blank\" rel=\"noopener noreferrer\">MDN - Function declaration</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function\" title=\"Function expression\" target=\"_blank\" rel=\"noopener noreferrer\">MDN - Function expression</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions\" title=\"Method definitions\" target=\"_blank\" rel=\"noopener noreferrer\">MDN - Method definitions</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\" title=\"Arrow function\" target=\"_blank\" rel=\"noopener noreferrer\">MDN - Arrow function</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction\" title=\"Generator function\" target=\"_blank\" rel=\"noopener noreferrer\">MDN - Generator function</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function\" title=\"Function constructor\" target=\"_blank\" rel=\"noopener noreferrer\">MDN - Function constructor</a></li>\n<li><a href=\"https://dmitripavlutin.com/6-ways-to-declare-javascript-functions/\" title=\"6 Ways to Declare JavaScript Functions\" target=\"_blank\" rel=\"noopener noreferrer\">6 Ways to Declare JavaScript Functions</a>（酌情翻译）</li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T07:36:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "调用函数的四种方式",
      "url": "https://www.fedbook.cn/frontend-knowledge/javascript/function-invocation/",
      "id": "https://www.fedbook.cn/frontend-knowledge/javascript/function-invocation/",
      "content_html": "<h1 id=\"调用函数的四种方式\"> 调用函数的四种方式</h1>\n<h2 id=\"前言\"> 前言</h2>\n<p>函数定义从 <code>function</code> 关键字开始，构成函数主体的 JavaScript 代码在定义之时并不会执行，只有调用该函数时，它们才会执行。</p>\n<blockquote>\n<p>关于变量提升：var 只有变量声明提前，变量的初始化代码仍然在原来的位置；然而 function 则会使函数名称和函数体均提前。</p>\n</blockquote>\n<p>函数调用方式共有四种：</p>\n<ul>\n<li>作为函数调用</li>\n<li>作为方法调用</li>\n<li>作为构造函数调用（<code>new</code> 调用）</li>\n<li>上下文调用（<code>call</code>、<code>apply</code>、<code>bind</code>）</li>\n</ul>\n<p>在 ECMAScript 2015（ES6）之前，函数内部的 <code>this</code> 指向是由该函数的调用方式决定的。</p>\n<h2 id=\"作为函数调用\"> 作为函数调用</h2>\n<p>对于普通的函数调用，如果该函数没有指定返回值，返回值就是 <code>undefined</code>；如果该函数指定了返回值（有 <code>return</code>），返回值就是 <code>return</code> 之后的表达式的值；如果 <code>return</code> 语句没有值，则返回 <code>undefined</code>。</p>\n<p>如果函数是声明在 window 对象中全局函数，非严格模式下的调用上下文（<code>this</code> 的值）是全局对象，严格模式 <code>this</code> 为 <code>undefined</code>。</p>\n<p>基本模式：</p>\n<div><pre><code><span>function</span> <span>foo</span><span>(</span><span>)</span> <span>{</span>\n  <span>return</span> <span>this</span><span>;</span>\n<span>}</span>\n<span>foo</span><span>(</span><span>)</span><span>;</span> <span>// 返回 window 对象</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"作为方法调用\"> 作为方法调用</h2>\n<p>方法指该 JavaScript 函数是一个对象的属性。函数本身就是一个属性访问表达式，这意味着该函数被当做一个方法，而不是一个普通函数来调用。其返回值的处理方式，和普通函数调用完全一致。</p>\n<p>调用上下文为当前对象，即 <code>this</code> 指向当前对象。</p>\n<p>基本模式：</p>\n<div><pre><code><span>var</span> calculator <span>=</span> <span>{</span>\n  value1<span>:</span> <span>1</span><span>,</span>\n  value2<span>:</span> <span>1</span><span>,</span>\n  <span>add</span><span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    <span>// this 指代当前对象</span>\n    <span>this</span><span>.</span>result <span>=</span> <span>this</span><span>.</span>value1 <span>+</span> <span>this</span><span>.</span>value2<span>;</span>\n  <span>}</span>\n<span>}</span><span>;</span>\n\ncalculator<span>.</span><span>add</span><span>(</span><span>)</span><span>;</span> <span>// 调用 add 方法结算结果</span>\ncalculator<span>.</span>result<span>;</span> <span>// => 2</span>\n\n<span>// 方括号（属性访问表达式）进行属性访问操作</span>\ncalculator<span>[</span><span>\"add\"</span><span>]</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>和变量不同，关键字 <code>this</code> 没有作用域的限制，嵌套的函数不会从调用它的函数中继承 <code>this</code>。如果嵌套函数作为方法调用，其 <code>this</code> 的值指向调用它的对象。如果嵌套函数作为函数调用，其 <code>this</code> 值不是全局对象（非严格模式下）就是 <code>undefined</code>（严格模式下）。</p>\n<p>因此若想访问外部函数的 <code>this</code> 值，那么就需要将 <code>this</code> 保存在变量中（变量具有作用域）。</p>\n<p>示例：</p>\n<div><pre><code><span>var</span> o <span>=</span> <span>{</span>\n  <span>m</span><span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    <span>let</span> self <span>=</span> <span>this</span><span>;</span>            <span>// 将this 的值进行保存</span>\n    console<span>.</span><span>log</span><span>(</span><span>this</span> <span>===</span> o<span>)</span><span>;</span>    <span>// true</span>\n    <span>f</span><span>(</span><span>)</span><span>;</span>                        <span>// 调用嵌套函数f()</span>\n        \n    <span>function</span> <span>f</span><span>(</span><span>)</span> <span>{</span>\n      console<span>.</span><span>log</span><span>(</span><span>this</span> <span>===</span> o<span>)</span><span>;</span>  <span>// false：this 的值为全局对象或 undefined</span>\n      console<span>.</span><span>log</span><span>(</span>self <span>===</span> o<span>)</span><span>;</span>  <span>// true：self 指向外部函数 this 的值</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id=\"作为构造函数调用\"> 作为构造函数调用</h2>\n<p>如果函数或者方法调用之前带有关键字 <code>new</code>，它就构成构造函数调用。</p>\n<p>基本模式：</p>\n<div><pre><code><span>let</span> person <span>=</span> <span>new</span> <span>People</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>构造函数调用会创建一个新的空对象，并初始化这个新创建的对象，将这个对象用作其调用上下文。因此构造函数中 <code>this</code> 关键字指向这个新创建的对象。</p>\n<p>如下示例代码，尽管构造函数看起来像一个方法调用，但它依然会使用 <code>new</code> 出来的新对象作为调用上下文。也就是说，在表达式 <code>new o.m()</code> 中，调用上下文并不是 <code>o</code>。</p>\n<div><pre><code><span>let</span> o <span>=</span> <span>{</span>\n  <span>m</span><span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>1</span><span>;</span>\n  <span>}</span>\n<span>}</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span><span>new</span> <span>o<span>.</span>m</span><span>(</span><span>)</span> <span>===</span> <span>1</span><span>)</span><span>;</span> <span>// false</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>构造函数通常不使用 <code>return</code> 关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会显式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值。然而如果构造函数显式地使用 <code>return</code> 语句返回一个对象，那么调用表达式的值就是这个对象。如果构造函数使用 <code>return</code> 语句但是没有指定返回值，或者返回一个原始值，那么这时将忽略返回值，同时使用这个新对象作为返回结果。</p>\n<div><p>提示</p>\n<p>特别提醒一下，<strong><code>new</code> 调用时的返回值，如果没有显式返回对象或者函数</strong>（包含 <code>Functoin</code>，<code>Array</code>，<code>Date</code>，<code>RegExg</code>，<code>Error</code>），<strong>才是返回生成的新对象</strong>。\n虽然实际使用时不会显示返回，但面试官可能会问到。</p>\n</div>\n<h2 id=\"上下文调用\"> 上下文调用</h2>\n<p>上下文调用方式有三种，<code>call</code>、<code>apply</code>、<code>bind</code>，这是一种很强大的调用方式。</p>\n<h3 id=\"call-和-apply\"> call 和 apply</h3>\n<p>JavaScript 中的函数也是对象，函数对象也可以包含方法。其中 <code>call()</code> 和 <code>apply()</code> 就是预定义的函数方法。</p>\n<p>这两个方法可用于间接地调用函数，它们都允许显式指定调用所需的 <code>this</code> 值。也就是说，任何函数都可以作为任何对象的方法来调用，使得关键字 <code>this</code> 指向该对象，哪怕这个函数不是该对象的方法。</p>\n<p>两个方法的第一个参数是要调用函数的母对象，它是调用上下文。</p>\n<p>基本模式：</p>\n<div><pre><code><span>// call()</span>\n<span>// obj: 这个对象将代替 func 里 this 对象</span>\n<span>// param1 ~ paramN: 这是一个参数列表</span>\n<span>func</span><span>.</span><span>call</span><span>(</span>obj<span>,</span> <span>'param1'</span><span>,</span> <span>'param2'</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code><span>// apply() </span>\n<span>// 该方法能接收两个参数</span>\n<span>// obj: 这个对象将代替 func 里 this 对象</span>\n<span>// args: 这是一个数组，它将作为参数传给 func（args --> arguments）</span>\n<span>func</span><span>.</span><span>apply</span><span>(</span>obj<span>,</span> <span>[</span><span>'param1'</span><span>,</span> <span>'param2'</span><span>]</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>注意：</p>\n<ul>\n<li><code>call</code> 和 <code>apply</code> 区别在于第二个参数：<code>apply</code> 传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，而 <code>call</code> 从第二个参数开始都是参数。</li>\n<li>在严格模式下，在调用函数时第一个参数会成为 <code>this</code> 的值，即使该参数不是一个对象。</li>\n<li>在非严格模下，如果第一个参数的值是 <code>null</code> 或 <code>undefined</code>，它将使用全局对象替代。</li>\n</ul>\n<h3 id=\"bind\"> bind</h3>\n<p><code>bind</code> 方式一般人用的比较少，但有的时候具有一些举足轻重的作用。</p>\n<p>不同的是，<code>call</code>、<code>apply</code> 是立刻执行了这个函数，并且执行过程中绑定了 <code>this</code> 的值；<code>bind</code> 并没有立刻执行这个函数，而是创建了一个新的函数，新函数绑定了 <code>this</code> 的值，如果要执行还得在后面加个 <code>()</code>。</p>\n<p>基本模式：</p>\n<div><pre><code><span>// bind() </span>\n<span>// 该方法能接收两个参数</span>\n<span>// obj: 这个对象将代替 func 里 this 对象</span>\n<span>// param1 ~ paramN: 这是一个参数列表</span>\n<span>func</span><span>.</span><span>bind</span><span>(</span>obj<span>,</span> <span>'param1'</span><span>,</span> <span>'param2'</span><span>)</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>bind 函数在对象中：</p>\n<div><pre><code><span>let</span> obj <span>=</span> <span>{</span>\n  name<span>:</span> <span>\"西瓜\"</span><span>,</span>\n  drink<span>:</span> <span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>name<span>)</span><span>;</span>\n    console<span>.</span><span>log</span><span>(</span>obj<span>.</span>name<span>)</span><span>;</span>\n  <span>}</span><span>)</span><span>.</span><span>bind</span><span>(</span><span>{</span>name<span>:</span> <span>\"橙汁\"</span><span>}</span><span>)</span>\n<span>}</span>\nobj<span>.</span><span>drink</span><span>(</span><span>)</span><span>;</span>\n\n<span>// \"橙汁\"</span>\n<span>// \"西瓜\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>bind 函数在定时器中：</p>\n<div><pre><code><span>let</span> obj <span>=</span> <span>{</span>\n  name<span>:</span> <span>\"西瓜\"</span><span>,</span>\n  <span>drink</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n    <span>setTimeout</span><span>(</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>\n      console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>name<span>)</span><span>;</span>\n    <span>}</span><span>)</span><span>.</span><span>bind</span><span>(</span><span>this</span><span>)</span><span>,</span> <span>100</span><span>)</span>\n  <span>}</span>\n<span>}</span><span>;</span>\nobj<span>.</span><span>drink</span><span>(</span><span>)</span><span>;</span>\n\n<span>// \"西瓜\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"call、apply、bind-小结\"> call、apply、bind 小结</h3>\n<p>通过 <code>call</code>、<code>apply</code>、<code>bind</code> 方法把对象绑定到 <code>this</code> 上，叫做显式绑定。对于被调用的函数来说，叫做间接调用。</p>\n<ul>\n<li><code>call</code>、<code>apply</code>、<code>bind</code> 三者的第一个参数都是 <code>this</code> 要指向的对象。</li>\n<li><code>bind</code> 只是返回函数，还未调用，所以如果要执行还得在后面加个 <code>()</code>；<code>call</code>、<code>apply</code> 是立即执行函数。</li>\n<li>三者后面都可以带参数\n<ul>\n<li><code>call</code> 后面的参数用逗号隔开：<code>func.call(obj, value1, value2);</code></li>\n<li><code>apply</code> 后面的参数以数组的形式传入：<code>func.apply(obj, [value1, value2]);</code></li>\n<li><code>bind</code> 可以在指定对象的时候传参（同 <code>call</code>），以逗号隔开；也可以在执行的时候传参，写到后面的括号中：<code>func.bind(obj,value1,value2)();</code>  或 <code>func.bind(obj)(value1,value2);</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions\" title=\"函数\" target=\"_blank\" rel=\"noopener noreferrer\">MDN - 函数</a></p>\n<p>（完）</p>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T07:36:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "闭包",
      "url": "https://www.fedbook.cn/frontend-knowledge/javascript/closure/",
      "id": "https://www.fedbook.cn/frontend-knowledge/javascript/closure/",
      "content_html": "<h1 id=\"闭包\"> 闭包</h1>\n<h2 id=\"闭包的定义\"> 闭包的定义</h2>\n<blockquote>\n<ul>\n<li>红宝书（第3版）：闭包是指有权访问另一个函数作用域中的变量的函数。（P178）</li>\n<li>小黄书（上）：当函数可以记住并访问所在的词法作用域时，就产生了闭包。（P44）</li>\n<li>MDN：闭包可以让你从内部函数访问外部函数作用域。（<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures\" title=\"闭包- JavaScript | MDN\" target=\"_blank\" rel=\"noopener noreferrer\">原链接</a>）</li>\n<li>大部分文章：当函数嵌套时，内层函数引用了外层函数作用域下的变量，并且内层函数在全局作用域下可访问时，就形成了闭包。</li>\n</ul>\n</blockquote>\n<p><strong>概括一下：</strong></p>\n<p>在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为（该外部函数的）闭包。</p>\n<h2 id=\"闭包的表现形式\"> 闭包的表现形式</h2>\n<ul>\n<li>返回一个函数</li>\n<li>作为函数参数传递</li>\n<li>回调函数</li>\n<li>非典型闭包<code>IIFE</code>（立即执行函数表达式）</li>\n</ul>\n<h3 id=\"返回一个函数\"> 返回一个函数</h3>\n<p>这种形式的闭包在 JavaScript 中非常常见。</p>\n<div><pre><code><span>var</span> a <span>=</span> <span>1</span><span>;</span>\n<span>function</span> <span>foo</span><span>(</span><span>)</span> <span>{</span>\n  <span>var</span> a <span>=</span> <span>2</span><span>;</span>\n  <span>// 这就是闭包</span>\n  <span>return</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span>a<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>var</span> bar <span>=</span> <span>foo</span><span>(</span><span>)</span><span>;</span>\n<span>bar</span><span>(</span><span>)</span><span>;</span> <span>// 输出2，而不是1</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"作为函数参数传递\"> 作为函数参数传递</h3>\n<p>无论通过何种手段将内部函数传递到它所在词法作用域之外，它都会持有对原始作用域的引用，无论在何处执行这个函数，都会产生闭包。</p>\n<div><pre><code><span>var</span> a <span>=</span> <span>1</span><span>;</span>\n<span>function</span> <span>foo</span><span>(</span><span>)</span> <span>{</span>\n  <span>var</span> a <span>=</span> <span>2</span><span>;</span>\n  <span>function</span> <span>baz</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span>a<span>)</span><span>;</span>\n  <span>}</span>\n  <span>bar</span><span>(</span>baz<span>)</span><span>;</span>\n<span>}</span>\n<span>function</span> <span>bar</span><span>(</span><span>fn</span><span>)</span> <span>{</span>\n  <span>// 这就是闭包</span>\n  <span>fn</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>foo</span><span>(</span><span>)</span><span>;</span> <span>// 输出2，而不是1</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id=\"回调函数\"> 回调函数</h3>\n<p>在定时器、事件监听、Ajax 请求、跨窗口通信、Web Workers 或者任何异步中，只要使用了回调函数，实际上就是在使用闭包</p>\n<div><pre><code><span>// 定时器</span>\n<span>setTimeout</span><span>(</span><span>function</span> <span>timeHandler</span><span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'timer'</span><span>)</span><span>;</span>\n<span>}</span><span>,</span> <span>100</span><span>)</span><span>;</span>\n\n<span>// 事件监听</span>\n<span>$</span><span>(</span><span>'#container'</span><span>)</span><span>.</span><span>click</span><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'DOM Listener'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"iife-立即执行函数表达式\"> IIFE（立即执行函数表达式）</h3>\n<p>IIFE（立即执行函数表达式）并不是一个典型的闭包，但它确实创建了一个闭包。</p>\n<div><pre><code><span>var</span> a <span>=</span> <span>2</span><span>;</span>\n<span>(</span><span>function</span> <span>IIFE</span><span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>a<span>)</span><span>;</span> <span>// 输出2</span>\n<span>}</span><span>)</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"闭包的作用\"> 闭包的作用</h2>\n<ul>\n<li>模块化（利用闭包的原理，将一个大的系统放在一个自调用函数中）</li>\n<li>防止变量被破坏（封装私有变量，保护函数内的变量安全）</li>\n<li>利用闭包实现结果缓存（备忘模式）</li>\n</ul>\n<p>如下代码所示，在开发一些组件的时候，要实现模块化就可以使用闭包：</p>\n<div><pre><code><span>var</span> common <span>=</span> <span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>\n  <span>return</span> <span>{</span>\n    <span>isStr</span><span>:</span><span>function</span><span>(</span><span>)</span> <span>{</span>\n      ……\n    <span>}</span><span>,</span>\n    <span>isNumber</span><span>:</span><span>function</span><span>(</span><span>)</span> <span>{</span>\n      ……\n    <span>}</span>\n  <span>}</span>\n<span>}</span><span>)</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>备忘模式就是应用闭包的特点的一个典型应用。比如有个函数：</p>\n<div><pre><code><span>function</span> <span>add</span><span>(</span><span>a</span><span>)</span> <span>{</span>\n  <span>return</span> a <span>+</span> <span>1</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>多次运行 <code>add()</code> 时，每次得到的结果都是重新计算得到的，如果是开销很大的计算操作的话就比较消耗性能了，这里可以对已经计算过的输入做一个缓存。</p>\n<p>所以这里可以利用闭包的特点来实现一个简单的缓存，在函数内部用一个对象存储输入的参数，如果下次再输入相同的参数，那就比较一下对象的属性，如果有缓存，就直接把值从这个对象里面取出来。</p>\n<div><pre><code><span>/* 备忘函数 */</span>\n<span>function</span> <span>memorize</span><span>(</span><span>fn</span><span>)</span> <span>{</span>\n  <span>var</span> cache <span>=</span> <span>{</span><span>}</span><span>;</span>\n  <span>return</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    <span>var</span> args <span>=</span> <span>Array</span><span>.</span>prototype<span>.</span><span>slice</span><span>.</span><span>call</span><span>(</span>arguments<span>)</span><span>;</span>\n    <span>var</span> key <span>=</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span>args<span>)</span><span>;</span>\n    <span>return</span> cache<span>[</span>key<span>]</span> <span>||</span> <span>(</span>cache<span>[</span>key<span>]</span> <span>=</span> <span>fn</span><span>.</span><span>apply</span><span>(</span>fn<span>,</span> args<span>)</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* 复杂计算函数 */</span>\n<span>function</span> <span>add</span><span>(</span><span>a</span><span>)</span> <span>{</span>\n  <span>return</span> a <span>+</span> <span>1</span><span>;</span>\n<span>}</span>\n\n<span>var</span> adder <span>=</span> <span>memorize</span><span>(</span>add<span>)</span><span>;</span>\n\n<span>adder</span><span>(</span><span>1</span><span>)</span><span>;</span> <span>// 输出: 2    当前: cache: { '[1]': 2 }</span>\n<span>adder</span><span>(</span><span>1</span><span>)</span><span>;</span> <span>// 输出: 2    当前: cache: { '[1]': 2 }</span>\n<span>adder</span><span>(</span><span>2</span><span>)</span><span>;</span> <span>// 输出: 3    当前: cache: { '[1]': 2, '[2]': 3 }</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>使用 ES6 的方式会更优雅一些：</p>\n<div><pre><code><span>/* 备忘函数 */</span>\n<span>function</span> <span>memorize</span><span>(</span><span>fn</span><span>)</span> <span>{</span>\n  <span>const</span> cache <span>=</span> <span>{</span><span>}</span><span>;</span>\n  <span>return</span> <span>function</span><span>(</span><span><span>...</span>args</span><span>)</span> <span>{</span>\n    <span>const</span> key <span>=</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span>args<span>)</span><span>;</span>\n    <span>return</span> cache<span>[</span>key<span>]</span> <span>||</span> <span>(</span>cache<span>[</span>key<span>]</span> <span>=</span> <span>fn</span><span>.</span><span>apply</span><span>(</span>fn<span>,</span> args<span>)</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* 复杂计算函数 */</span>\n<span>function</span> <span>add</span><span>(</span><span>a</span><span>)</span> <span>{</span>\n  <span>return</span> a <span>+</span> <span>1</span><span>;</span>\n<span>}</span>\n\n<span>const</span> adder <span>=</span> <span>memorize</span><span>(</span>add<span>)</span><span>;</span>\n\n<span>adder</span><span>(</span><span>1</span><span>)</span><span>;</span> <span>// 输出: 2    当前: cache: { '[1]': 2 }</span>\n<span>adder</span><span>(</span><span>1</span><span>)</span><span>;</span> <span>// 输出: 2    当前: cache: { '[1]': 2 }</span>\n<span>adder</span><span>(</span><span>2</span><span>)</span><span>;</span> <span>// 输出: 3    当前: cache: { '[1]': 2, '[2]': 3 }</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>稍微解释一下：</p>\n<p>备忘函数中用 <code>JSON.stringify</code> 把传给 <code>adder</code> 函数的参数序列化成字符串，把它当做 <code>cache</code> 的索引，将 <code>add</code> 函数运行的结果当做索引的值传递给 <code>cache</code>，这样 <code>adder</code> 运行的时候如果传递的参数之前传递过，那么就返回缓存好的计算结果，不用再计算了，如果传递的参数没计算过，则计算并缓存 <code>fn.apply(fn, args)</code>，再返回计算的结果。</p>\n<p>当然这里的实现如果要实际应用的话，还需要继续改进一下，比如：</p>\n<ul>\n<li>缓存不可以永远扩张下去，这样太耗费内存资源，我们可以只缓存最新传入的 n 个。</li>\n<li>在浏览器中使用的时候，我们可以借助浏览器的持久化手段，来进行缓存的持久化，比如 cookie、localStorage 等。</li>\n</ul>\n<p>这里的复杂计算函数可以是过去的某个状态，比如对某个目标的操作，这样把过去的状态缓存起来，方便地进行状态回退。</p>\n<p>复杂计算函数也可以是一个返回时间比较慢的异步操作，这样如果把结果缓存起来，下次就可以直接从本地获取，而不是重新进行异步请求。</p>\n<div><p>注意</p>\n<p>cache 不可以是 <code>Map</code>，因为 <code>Map</code> 的键是使用 <code>===</code> 比较的，因此当传入引用类型值作为键时，虽然它们看上去是相等的，但实际并不是，比如 <code>[1]!==[1]</code>，所以还是被存为不同的键。</p>\n</div>\n<div><pre><code><span>//  X 错误示范</span>\n<span>function</span> <span>memorize</span><span>(</span><span>fn</span><span>)</span> <span>{</span>\n  <span>const</span> cache <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span><span>;</span>\n  <span>return</span> <span>function</span><span>(</span><span><span>...</span>args</span><span>)</span> <span>{</span>\n    <span>return</span> cache<span>.</span><span>get</span><span>(</span>args<span>)</span> <span>||</span> cache<span>.</span><span>set</span><span>(</span>args<span>,</span> <span>fn</span><span>.</span><span>apply</span><span>(</span>fn<span>,</span> args<span>)</span><span>)</span><span>.</span><span>get</span><span>(</span>args<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>function</span> <span>add</span><span>(</span><span>a</span><span>)</span> <span>{</span>\n  <span>return</span> a <span>+</span> <span>1</span><span>;</span>\n<span>}</span>\n\n<span>const</span> adder <span>=</span> <span>memorize</span><span>(</span>add<span>)</span><span>;</span>\n\n<span>adder</span><span>(</span><span>1</span><span>)</span><span>;</span> <span>// 2    cache: { [ 1 ] => 2 }</span>\n<span>adder</span><span>(</span><span>1</span><span>)</span><span>;</span> <span>// 2    cache: { [ 1 ] => 2, [ 1 ] => 2 }</span>\n<span>adder</span><span>(</span><span>2</span><span>)</span><span>;</span> <span>// 3    cache: { [ 1 ] => 2, [ 1 ] => 2, [ 2 ] => 3 }</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id=\"闭包内存释放\"> 闭包内存释放</h2>\n<p>如果闭包使用不正确，会很容易造成内存泄漏，因此关注闭包是如何回收的能让你正确地使用闭包。</p>\n<ul>\n<li><strong>如果引用闭包的函数是一个全局变量</strong>，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。</li>\n<li><strong>如果引用闭包的函数是一个局部变量</strong>，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。</li>\n</ul>\n<p>所以在使用闭包的时候，要尽量注意一个原则：<strong>如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。</strong></p>\n<p>当然了，如果想释放以全局变量形式存在的闭包，也可以用下面这种方式：</p>\n<div><pre><code><span>function</span> <span>foo</span><span>(</span><span>)</span> <span>{</span>\n  <span>var</span> a <span>=</span> <span>5</span><span>;</span>\n  <span>return</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    a<span>++</span><span>;</span>\n    console<span>.</span><span>log</span><span>(</span>a<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n<span>var</span> bar <span>=</span> <span>foo</span><span>(</span><span>)</span><span>;</span>\n\n<span>// 要想释放 bar 里面保存的 a，只能通过释放 bar</span>\nbar <span>=</span> <span>null</span><span>;</span> <span>// 或者 bar = undefined</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>（完）</p>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2022-03-31T11:07:01.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "高阶函数",
      "url": "https://www.fedbook.cn/frontend-knowledge/javascript/higher-order-function/",
      "id": "https://www.fedbook.cn/frontend-knowledge/javascript/higher-order-function/",
      "content_html": "<h1 id=\"高阶函数\"> 高阶函数</h1>\n<h2 id=\"前言\"> 前言</h2>\n<p>「JavaScript 中，函数是一等公民」，在各种书籍和文章中我们总能看到这句话。</p>\n<p>通俗地解释就是：JS 中的函数也是对象，可以有属性，可以赋值给一个变量，可以放在数组里作为元素，可以作为其他对象的属性，普通对象能做的它能做，普通对象不能做的它也能做。</p>\n<p>而所谓的高阶函数（Higher-order function），就是输入参数里有函数，或者输出是函数的函数。</p>\n<p>最常见的高阶函数有 <code>map()</code>、<code>reduce()</code>、<code>filter()</code>、<code>sort()</code>、<code>setTimeout</code>、<code>setInterval</code> 和 ajax 请求，我们称之为回调函数，因为它将函数作为参数传递给另一个函数。</p>\n<p>另一个经常看到的高阶函数的场景是在一个函数内部输出另一个函数，比如闭包，还有接下来要讲的柯里化、反柯里化和偏函数。</p>\n<h2 id=\"柯里化\"> 柯里化</h2>\n<h3 id=\"定义\"> 定义</h3>\n<blockquote>\n<ul>\n<li>红宝书（第3版）：用于创建已经设置好了一个或多个参数的函数。基本方法是使用一个闭包返回一个函数。（P604）</li>\n<li>维基百科：柯里化（英语：Currying），是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。（<a href=\"https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96\" target=\"_blank\" rel=\"noopener noreferrer\">原链接</a>）</li>\n<li>柯里化的原理就是利用闭包，可以形成一个不销毁的私有作用域，把预先处理的内容都存在这个不销毁的作用域里面，并且返回一个函数，以后要执行的就是这个函数。</li>\n</ul>\n</blockquote>\n<p>官方解释看得有点懵，大白话概括一下：</p>\n<p><strong>柯里化</strong>（Currying）又称部分求值（Partial Evaluation），是把接受多个参数的原函数变换成接受一个单一参数（原函数的第一个参数）的函数，并且返回一个新函数，新函数能够接受余下的参数，最后返回同原函数一样的结果。</p>\n<p>核心思想是把多参数传入的函数拆成单（或部分）参数函数，内部再返回调用下一个单（或部分）参数函数，依次处理剩余的参数。</p>\n<h3 id=\"应用\"> 应用</h3>\n<p>柯里化有 3 个常见应用：</p>\n<ul>\n<li>参数复用 – 当在多次调用同一个函数，并且传递的参数绝大多数是相同的，那么该函数可能是一个很好的柯里化候选</li>\n<li>提前返回 – 多次调用多次内部判断，可以直接把第一次判断的结果返回外部接收</li>\n<li>延迟计算/运行 – 避免重复的去执行程序，等真正需要结果的时候再执行</li>\n</ul>\n<h3 id=\"通用实现\"> 通用实现</h3>\n<div><pre><code><span>// ES5 方式</span>\n<span>function</span> <span>currying</span><span>(</span><span>fn</span><span>)</span> <span>{</span>\n  <span>var</span> rest1 <span>=</span> <span>Array</span><span>.</span>prototype<span>.</span><span>slice</span><span>.</span><span>call</span><span>(</span>arguments<span>)</span>\n  rest1<span>.</span><span>shift</span><span>(</span><span>)</span>\n  <span>return</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    <span>var</span> rest2 <span>=</span> <span>Array</span><span>.</span>prototype<span>.</span><span>slice</span><span>.</span><span>call</span><span>(</span>arguments<span>)</span>\n    <span>return</span> <span>fn</span><span>.</span><span>apply</span><span>(</span><span>null</span><span>,</span> rest1<span>.</span><span>concat</span><span>(</span>rest2<span>)</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// ES6 方式</span>\n<span>function</span> <span>currying</span><span>(</span><span>fn<span>,</span> <span>...</span>rest1</span><span>)</span> <span>{</span>\n  <span>return</span> <span>function</span><span>(</span><span><span>...</span>rest2</span><span>)</span> <span>{</span>\n    <span>return</span> <span>fn</span><span>.</span><span>apply</span><span>(</span><span>null</span><span>,</span> rest1<span>.</span><span>concat</span><span>(</span>rest2<span>)</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>用它将一个 <code>sayHello</code> 函数柯里化试试：</p>\n<div><pre><code><span>// 接上面</span>\n<span>function</span> <span>sayHello</span><span>(</span><span>name<span>,</span> age<span>,</span> fruit</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span><span>`</span><span>我叫 </span><span><span>${</span>name<span>}</span></span><span>,我 </span><span><span>${</span>age<span>}</span></span><span> 岁了, 我喜欢吃 </span><span><span>${</span>fruit<span>}</span></span><span>`</span></span><span>)</span>\n<span>}</span>\n\n<span>var</span> curryingShowMsg1 <span>=</span> <span>currying</span><span>(</span>sayHello<span>,</span> <span>'小明'</span><span>)</span>\n<span>curryingShowMsg1</span><span>(</span><span>22</span><span>,</span> <span>'苹果'</span><span>)</span>           <span>// 输出: 我叫 小明,我 22 岁了, 我喜欢吃 苹果</span>\n\n<span>var</span> curryingShowMsg2 <span>=</span> <span>currying</span><span>(</span>sayHello<span>,</span> <span>'小衰'</span><span>,</span> <span>20</span><span>)</span>\n<span>curryingShowMsg2</span><span>(</span><span>'西瓜'</span><span>)</span>               <span>// 输出: 我叫 小衰,我 20 岁了, 我喜欢吃 西瓜</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"应用一-参数复用\"> 应用一：参数复用</h3>\n<p>如下名为 <code>uri</code> 的函数，接收 3 个参数，函数的作用是返回三个参数拼接的字符串。</p>\n<div><pre><code><span>function</span> <span>uri</span><span>(</span><span>protocol<span>,</span> hostname<span>,</span> pathname</span><span>)</span> <span>{</span>\n  <span>return</span> <span><span>`</span><span><span>${</span>protocol<span>}</span></span><span><span>${</span>hostname<span>}</span></span><span><span>${</span>pathname<span>}</span></span><span>`</span></span><span>;</span>\n<span>}</span>\n\n<span>// 测试一下</span>\n<span>const</span> uri1 <span>=</span> <span>url</span><span>(</span><span>'https://'</span><span>,</span> <span>'www.fedbook.cn'</span><span>,</span> <span>'/function-curring/'</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>uri1<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面这种写法的弊端是：当我们有很多网址时，会导致非常多重复的参数（比如 <code>https://</code> 就是重复的参数，我们在浏览器里面输入网址也不需要输入 http 或者 https）。</p>\n<p>利用柯里化实现参数复用的思路：</p>\n<ul>\n<li>原函数（称为函数 A）只设置一个参数（接收协议这个参数）；</li>\n<li>在函数内部再创建一个函数（称为函数 B），函数 B 把刚才剩余的两个参数给补上，并返回字符串形式的 url；</li>\n<li>函数 A 返回函数 B。</li>\n</ul>\n<div><pre><code><span>function</span> <span>uri_curring</span><span>(</span><span>protocol</span><span>)</span> <span>{</span>\n  <span>return</span> <span>function</span><span>(</span><span>hostname<span>,</span> pathname</span><span>)</span> <span>{</span>\n    <span>return</span> <span><span>`</span><span><span>${</span>protocol<span>}</span></span><span><span>${</span>hostname<span>}</span></span><span><span>${</span>pathname<span>}</span></span><span>`</span></span><span>;</span> \n  <span>}</span>\n<span>}</span>\n\n<span>// 测试一下</span>\n<span>const</span> uri_https <span>=</span> <span>uri_curring</span><span>(</span><span>'https://'</span><span>)</span><span>;</span>\n\n<span>const</span> uri1 <span>=</span> <span>uri_https</span><span>(</span><span>'www.fedbook.cn'</span><span>,</span> <span>'/frontend-knowledge/javascript/function-currying/'</span><span>)</span><span>;</span>\n<span>const</span> uri2 <span>=</span> <span>uri_https</span><span>(</span><span>'www.fedbook.cn'</span><span>,</span> <span>'/handwritten/javascript/10-实现bind方法/'</span><span>)</span><span>;</span>\n<span>const</span> uri3 <span>=</span> <span>uri_https</span><span>(</span><span>'www.wenyuanblog.com'</span><span>,</span> <span>'/'</span><span>)</span><span>;</span>\n\nconsole<span>.</span><span>log</span><span>(</span>uri1<span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>uri2<span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>uri3<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id=\"应用二-兼容性检测\"> 应用二：兼容性检测</h3>\n<div><p>注意</p>\n<p>以下代码为了编写方便，会使用 ES6 的语法。实际生产环境中如果要做兼容性检测功能，需要转换成 ES5 语法。</p>\n</div>\n<p>因为浏览器的发展和各种原因，有些函数和方法是不被部分浏览器支持的，此时需要提前进行判断，从而确定用户的浏览器是否支持相应的方法。</p>\n<p>以事件监听为例，IE（IE9 之前） 支持的是 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener\" target=\"_blank\" rel=\"noopener noreferrer\"><code>attachEvent</code></a> 方法，其它主流浏览器支持的是 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener\" target=\"_blank\" rel=\"noopener noreferrer\"><code>addEventListener</code></a> 方法，我们需要创建一个新的函数来进行两者的判断。</p>\n<div><pre><code><span>const</span> <span>addEvent</span>  <span>=</span> <span>function</span><span>(</span><span>element<span>,</span> type<span>,</span> listener<span>,</span> useCapture</span><span>)</span> <span>{</span>\n  <span>if</span><span>(</span>window<span>.</span>addEventListener<span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'判断为其它浏览器'</span><span>)</span>\n    <span>// 和原生 addEventListener 一样的函数</span>\n    <span>// element: 需要添加事件监听的元素</span>\n    <span>// type: 为元素添加什么类型的事件</span>\n    <span>// listener: 执行的回调函数</span>\n    <span>// useCapture: 要进行事件冒泡或者事件捕获的选择</span>\n    element<span>.</span><span>addEventListener</span><span>(</span>type<span>,</span> <span>function</span><span>(</span><span>e</span><span>)</span> <span>{</span>\n      <span>// 为了规避 this 指向问题，用 call 进行 this 的绑定</span>\n      <span>listener</span><span>.</span><span>call</span><span>(</span>element<span>,</span> e<span>)</span><span>;</span>\n    <span>}</span><span>,</span> useCapture<span>)</span><span>;</span>\n  <span>}</span> <span>else</span> <span>if</span><span>(</span>window<span>.</span>attachEvent<span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'判断为 IE9 以下浏览器'</span><span>)</span>\n    <span>// 原生的 attachEvent 函数</span>\n    <span>// 不需要第四个参数，因为 IE 支持的是事件冒泡</span>\n    <span>// 多拼接一个 on，这样就可以使用统一书写形式的事件类型了</span>\n    element<span>.</span><span>attachEvent</span><span>(</span><span>'on'</span> <span>+</span> type<span>,</span> <span>function</span><span>(</span><span>e</span><span>)</span> <span>{</span>\n      <span>listener</span><span>.</span><span>call</span><span>(</span>element<span>,</span> e<span>)</span><span>;</span>\n    <span>}</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 测试一下</span>\n<span>let</span> div <span>=</span> document<span>.</span><span>querySelector</span><span>(</span><span>'div'</span><span>)</span><span>;</span>\n<span>let</span> p <span>=</span> document<span>.</span><span>querySelector</span><span>(</span><span>'p'</span><span>)</span><span>;</span>\n<span>let</span> span <span>=</span> document<span>.</span><span>querySelector</span><span>(</span><span>'span'</span><span>)</span><span>;</span>\n\n<span>addEvent</span><span>(</span>div<span>,</span> <span>'click'</span><span>,</span> <span>(</span><span>e</span><span>)</span> <span>=></span> <span>{</span>console<span>.</span><span>log</span><span>(</span><span>'点击了 div'</span><span>)</span><span>;</span><span>}</span><span>,</span> <span>true</span><span>)</span><span>;</span>\n<span>addEvent</span><span>(</span>p<span>,</span> <span>'click'</span><span>,</span> <span>(</span><span>e</span><span>)</span> <span>=></span> <span>{</span>console<span>.</span><span>log</span><span>(</span><span>'点击了 p'</span><span>)</span><span>;</span><span>}</span><span>,</span> <span>true</span><span>)</span><span>;</span>\n<span>addEvent</span><span>(</span>span<span>,</span> <span>'click'</span><span>,</span> <span>(</span><span>e</span><span>)</span> <span>=></span> <span>{</span>console<span>.</span><span>log</span><span>(</span><span>'点击了 span'</span><span>)</span><span>;</span><span>}</span><span>,</span> <span>true</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>上面这种封装的弊端是：每次写监听事件的时候调用 <code>addEvent</code> 函数，都会进行 <code>if...else...</code> 的兼容性判断。事实上在代码中只需要执行一次兼容性判断就可以了，把根据一次判定之后的结果动态生成新的函数，以后就不必重新计算。</p>\n<p>那么怎么用函数柯里化优化这个封装函数？</p>\n<div><pre><code><span>// 使用立即执行函数，当我们把这个函数放在文件的头部，就可以先进行执行判断</span>\n<span>const</span> addEvent  <span>=</span> <span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>\n  <span>if</span><span>(</span>window<span>.</span>addEventListener<span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'判断为其它浏览器'</span><span>)</span>\n    <span>return</span> <span>function</span><span>(</span><span>element<span>,</span> type<span>,</span> listener<span>,</span> useCapture</span><span>)</span> <span>{</span>\n      element<span>.</span><span>addEventListener</span><span>(</span>type<span>,</span> <span>function</span><span>(</span><span>e</span><span>)</span> <span>{</span>\n        <span>listener</span><span>.</span><span>call</span><span>(</span>element<span>,</span> e<span>)</span><span>;</span>\n      <span>}</span><span>,</span> useCapture<span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span> <span>else</span> <span>if</span><span>(</span>window<span>.</span>attachEvent<span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'判断为 IE9 以下浏览器'</span><span>)</span>\n    <span>return</span> <span>function</span><span>(</span><span>element<span>,</span> type<span>,</span> handler</span><span>)</span> <span>{</span>\n      element<span>.</span><span>attachEvent</span><span>(</span><span>'on'</span><span>+</span>type<span>,</span> <span>function</span><span>(</span><span>e</span><span>)</span> <span>{</span>\n        <span>handler</span><span>.</span><span>call</span><span>(</span>element<span>,</span> e<span>)</span><span>;</span>\n      <span>}</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span><span>)</span> <span>(</span><span>)</span><span>;</span>\n\n<span>// 测试一下</span>\n<span>let</span> div <span>=</span> document<span>.</span><span>querySelector</span><span>(</span><span>'div'</span><span>)</span><span>;</span>\n<span>let</span> p <span>=</span> document<span>.</span><span>querySelector</span><span>(</span><span>'p'</span><span>)</span><span>;</span>\n<span>let</span> span <span>=</span> document<span>.</span><span>querySelector</span><span>(</span><span>'span'</span><span>)</span><span>;</span>\n\n<span>addEvent</span><span>(</span>div<span>,</span> <span>'click'</span><span>,</span> <span>(</span><span>e</span><span>)</span> <span>=></span> <span>{</span>console<span>.</span><span>log</span><span>(</span><span>'点击了 div'</span><span>)</span><span>;</span><span>}</span><span>,</span> <span>true</span><span>)</span><span>;</span>\n<span>addEvent</span><span>(</span>p<span>,</span> <span>'click'</span><span>,</span> <span>(</span><span>e</span><span>)</span> <span>=></span> <span>{</span>console<span>.</span><span>log</span><span>(</span><span>'点击了 p'</span><span>)</span><span>;</span><span>}</span><span>,</span> <span>true</span><span>)</span><span>;</span>\n<span>addEvent</span><span>(</span>span<span>,</span> <span>'click'</span><span>,</span> <span>(</span><span>e</span><span>)</span> <span>=></span> <span>{</span>console<span>.</span><span>log</span><span>(</span><span>'点击了 span'</span><span>)</span><span>;</span><span>}</span><span>,</span> <span>true</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>上述封装因为立即执行函数的原因，触发多次事件也依旧只会触发一次 if 条件判断。</p>\n<p>这里使用了函数柯里化的两个特点：提前返回和延迟执行。</p>\n<h3 id=\"应用三-实现一个-add-函数\"> 应用三：实现一个 add 函数</h3>\n<p>这是一道经典面试题，要求我们实现一个 add 函数，可以实现以下计算结果：</p>\n<div><pre><code><span>add</span><span>(</span><span>1</span><span>)</span><span>(</span><span>2</span><span>)</span><span>(</span><span>3</span><span>)</span> <span>=</span> <span>6</span><span>;</span>\n<span>add</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>(</span><span>4</span><span>)</span> <span>=</span> <span>10</span><span>;</span>\n<span>add</span><span>(</span><span>1</span><span>)</span><span>(</span><span>2</span><span>)</span><span>(</span><span>3</span><span>)</span><span>(</span><span>4</span><span>)</span><span>(</span><span>5</span><span>)</span> <span>=</span> <span>15</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>通过这道题正好可以解释柯里化的延迟执行，直接上代码：</p>\n<div><pre><code><span>function</span> <span>add</span><span>(</span><span>)</span> <span>{</span>\n  <span>// 将传入的不定参数转为数组对象</span>\n  <span>let</span> args <span>=</span> <span>Array</span><span>.</span>prototype<span>.</span><span>slice</span><span>.</span><span>call</span><span>(</span>arguments<span>)</span><span>;</span>\n\n  <span>// 递归：内部函数里面进行自己调用自己</span>\n  <span>// 当 add 函数不断调用时，把第 N+1 个括号的参数加入到第 N 个括号的参数里面</span>\n  <span>let</span> <span>inner</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    args<span>.</span><span>push</span><span>(</span><span>...</span>arguments<span>)</span><span>;</span>\n    <span>return</span> inner<span>;</span>\n  <span>}</span>\n  \n  inner<span>.</span><span>toString</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    <span>// args 里的值不断累加</span>\n    <span>return</span> args<span>.</span><span>reduce</span><span>(</span><span>function</span><span>(</span><span>prev<span>,</span> cur</span><span>)</span> <span>{</span>\n      <span>return</span> prev <span>+</span> cur<span>;</span>  \n    <span>}</span><span>)</span><span>;</span>\n  <span>}</span><span>;</span>\n\n  <span>return</span> inner<span>;</span>\n<span>}</span>\n\n<span>// 测试一下</span>\n<span>let</span> result <span>=</span> <span>add</span><span>(</span><span>1</span><span>)</span><span>(</span><span>2</span><span>)</span><span>(</span><span>3</span><span>)</span><span>(</span><span>4</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>result<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>解释几个关键点：</p>\n<p><strong>1）不定参数 <code>arguments</code> 需要转为数组对象：</strong></p>\n<p>因为 <code>arguments</code> 并不是真正的数组，而是与数组类似对象，<code>Array.prototype.slice.call(arguments)</code> 能将具有 <code>length</code> 属性的对象转成数组。</p>\n<p><strong>2）<code>toString</code> 隐形转换的特性：</strong></p>\n<p>对于 <code>add(1)(2)(3)(4)</code>，执行每个括号的时候都返回 <code>inner</code> 函数，不断自己调用自己，每次内部函数返回的都是内部函数。</p>\n<p>如果打印函数执行的最终返回结果，可以发现返回了一个字符串（原本的函数被转换为字符串返回了），这即是发生了隐式转换，而发生隐式转换是因为调用了内部的 <code>toString</code> 方法。</p>\n<p>知道了这一点，我们就可以利用这个特性自定义返回的内容：重写 <code>inner</code> 函数的 <code>toString</code> 方法，在里面实现参数相加的执行代码。</p>\n<p>值得一提的是，这种处理后能够返回正确的累加结果，但返回的结果是个函数类型（<code>function</code>），这是因为我们在用递归返回函数，内部函数在被隐式转换为字符串之前本来就是一个函数。</p>\n<h2 id=\"反柯里化\"> 反柯里化</h2>\n<h3 id=\"定义-2\"> 定义</h3>\n<p>柯里化是固定部分参数，返回一个接受剩余参数的函数，也称为部分计算函数，目的是为了缩小适用范围，创建一个针对性更强的函数。核心思想是把多参数传入的函数拆成单参数（或部分）函数，内部再返回调用下一个单参数（或部分）函数，依次处理剩余的参数。</p>\n<p>而<strong>反柯里化</strong>，从字面讲，意义和用法跟函数柯里化相比正好相反，扩大适用范围，创建一个应用范围更广的函数。使本来只有特定对象才适用的方法，扩展到更多的对象。</p>\n<h3 id=\"通用实现-2\"> 通用实现</h3>\n<div><pre><code><span>// ES5 方式</span>\n<span>Function</span><span>.</span>prototype<span>.</span><span>unCurrying</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n  <span>var</span> self <span>=</span> <span>this</span>\n  <span>return</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    <span>var</span> rest <span>=</span> <span>Array</span><span>.</span>prototype<span>.</span><span>slice</span><span>.</span><span>call</span><span>(</span>arguments<span>)</span>\n    <span>return</span> <span>Function</span><span>.</span>prototype<span>.</span><span>call</span><span>.</span><span>apply</span><span>(</span>self<span>,</span> rest<span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// ES6 方式</span>\n<span>Function</span><span>.</span>prototype<span>.</span><span>unCurrying</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n  <span>const</span> self <span>=</span> <span>this</span>\n  <span>return</span> <span>function</span><span>(</span><span><span>...</span>rest</span><span>)</span> <span>{</span>\n    <span>return</span> <span>Function</span><span>.</span>prototype<span>.</span><span>call</span><span>.</span><span>apply</span><span>(</span>self<span>,</span> rest<span>)</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>如果觉得把函数放在 Function 的原型上不太好，也可以这样：</p>\n<div><pre><code><span>// ES5 方式</span>\n<span>function</span> <span>unCurrying</span><span>(</span><span>fn</span><span>)</span> <span>{</span>\n  <span>return</span> <span>function</span> <span>(</span><span>tar</span><span>)</span> <span>{</span>\n    <span>var</span> rest <span>=</span> <span>Array</span><span>.</span>prototype<span>.</span><span>slice</span><span>.</span><span>call</span><span>(</span>arguments<span>)</span>\n    rest<span>.</span><span>shift</span><span>(</span><span>)</span>\n    <span>return</span> <span>fn</span><span>.</span><span>apply</span><span>(</span>tar<span>,</span> rest<span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// ES6 方式</span>\n<span>function</span> <span>unCurrying</span><span>(</span><span>fn</span><span>)</span> <span>{</span>\n  <span>return</span> <span>function</span><span>(</span><span>tar<span>,</span> <span>...</span>argu</span><span>)</span> <span>{</span>\n    <span>return</span> <span>fn</span><span>.</span><span>apply</span><span>(</span>tar<span>,</span> argu<span>)</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>下面简单试用一下反柯里化通用实现，我们将 Array 上的 <code>push</code> 方法借出来给 arguments 这样的类数组增加一个元素：</p>\n<div><pre><code><span>// 接上面</span>\n<span>var</span> push <span>=</span> <span>unCurrying</span><span>(</span><span>Array</span><span>.</span>prototype<span>.</span>push<span>)</span>\n\n<span>function</span> <span>execPush</span><span>(</span><span>)</span> <span>{</span>\n  <span>push</span><span>(</span>arguments<span>,</span> <span>4</span><span>)</span>\n  console<span>.</span><span>log</span><span>(</span>arguments<span>)</span>\n<span>}</span>\n\n<span>execPush</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span>    <span>// 输出: [1, 2, 3, 4]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"区别\"> 区别</h3>\n<p>简单说，函数柯里化就是对高阶函数的降阶处理，缩小适用范围，创建一个针对性更强的函数。</p>\n<div><pre><code><span>function</span><span>(</span><span>arg1<span>,</span> arg2</span><span>)</span>              <span>// => function(arg1)(arg2)</span>\n<span>function</span><span>(</span><span>arg1<span>,</span> arg2<span>,</span> arg3</span><span>)</span>        <span>// => function(arg1)(arg2)(arg3)</span>\n<span>function</span><span>(</span><span>arg1<span>,</span> arg2<span>,</span> arg3<span>,</span> arg4</span><span>)</span>  <span>// => function(arg1)(arg2)(arg3)(arg4)</span>\n<span>function</span><span>(</span><span>arg1<span>,</span> arg2<span>,</span> <span>...</span><span>,</span> argn</span><span>)</span>   <span>// => function(arg1)(arg2)…(argn)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>而反柯里化就是反过来，增加适用范围，让方法使用场景更大。使用反柯里化，可以把原生方法借出来，让任何对象拥有原生对象的方法。</p>\n<div><pre><code>obj<span>.</span><span>func</span><span>(</span>arg1<span>,</span> arg2<span>)</span>        <span>// => func(obj, arg1, arg2)</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>可以这样理解柯里化和反柯里化的区别：</p>\n<ul>\n<li>柯里化是在运算前提前传参，可以传递多个参数。</li>\n<li>反柯里化是延迟传参，在运算时把原来已经固定的参数或者 this 上下文等当作参数延迟到未来传递。</li>\n</ul>\n<h2 id=\"偏函数\"> 偏函数</h2>\n<p>偏函数是创建一个调用另外一个部分（参数或变量已预制的函数）的函数，函数可以根据传入的参数来生成一个真正执行的函数。其本身不包括我们真正需要的逻辑代码，只是根据传入的参数返回其他的函数，返回的函数中才有真正的处理逻辑比如：</p>\n<div><pre><code><span>var</span> <span>isType</span> <span>=</span> <span>function</span><span>(</span><span>type</span><span>)</span> <span>{</span>\n  <span>return</span> <span>function</span><span>(</span><span>obj</span><span>)</span> <span>{</span>\n    <span>return</span> <span>Object</span><span>.</span>prototype<span>.</span><span>toString</span><span>.</span><span>call</span><span>(</span>obj<span>)</span> <span>===</span> <span><span>`</span><span>[object </span><span><span>${</span>type<span>}</span></span><span>]</span><span>`</span></span>\n  <span>}</span>\n<span>}</span>\n\n<span>var</span> isString <span>=</span> <span>isType</span><span>(</span><span>'String'</span><span>)</span>\n<span>var</span> isFunction <span>=</span> <span>isType</span><span>(</span><span>'Function'</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>这样就用偏函数快速创建了一组判断对象类型的方法。</p>\n<p>偏函数和柯里化的区别：</p>\n<ul>\n<li><strong>柯里化</strong>是把一个接受 n 个参数的函数，由原本的一次性传递所有参数并执行变成了可以分多次接受参数再执行，例如：<code>add = (x, y, z) =&gt; x + y + z→curryAdd = x =&gt; y =&gt; z =&gt; x + y + z</code>。</li>\n<li><strong>偏函数</strong>固定了函数的某个部分，通过传入的参数或者方法返回一个新的函数来接受剩余的参数，数量可能是一个也可能是多个</li>\n</ul>\n<p>当一个柯里化函数只接受两次参数时，比如 <code>curry()()</code>，这时的柯里化函数和偏函数概念类似，可以认为偏函数是柯里化函数的退化版。</p>\n<p>（完）</p>\n",
      "date_published": "2022-04-01T10:46:10.000Z",
      "date_modified": "2022-04-01T10:46:10.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "对象遍历的几种方式",
      "url": "https://www.fedbook.cn/frontend-knowledge/javascript/object-iteration/",
      "id": "https://www.fedbook.cn/frontend-knowledge/javascript/object-iteration/",
      "content_html": "<h1 id=\"对象遍历的几种方式\"> 对象遍历的几种方式</h1>\n<h2 id=\"for-in\"> for...in...</h2>\n<p>要使用 <code>(const i in obj)</code> 而不是 <code>(i in obj)</code>，因为后者将会创建一个全局变量。</p>\n<div><pre><code><span>// Object 原型链上扩展的方法也会被遍历出来</span>\n<span>Object</span><span>.</span>prototype<span>.</span><span>fun</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span><span>}</span><span>;</span>\n<span>const</span> obj <span>=</span> <span>{</span> name<span>:</span> <span>'zhangsan'</span><span>,</span> age<span>:</span> <span>13</span> <span>}</span><span>;</span>\n<span>for</span> <span>(</span><span>const</span> i <span>in</span> obj<span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>i<span>,</span> <span>':'</span><span>,</span> obj<span>[</span>i<span>]</span><span>)</span><span>;</span>\n<span>}</span> \n<span>// name : zhangsan</span>\n<span>// age : 13</span>\n<span>// fun : () => {}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>使用 <code>for...in...</code> 循环时，返回的是所有能够通过对象访问的、可枚举的属性，既包括存在于实例中的属性，也包括存在于原型中的实例。如果只需要获取对象的实例属性，可以使用 <code>hasOwnProperty</code> 进行过滤。</p>\n<div><pre><code><span>// 不属于自身的属性将被 hasOwnProperty 过滤</span>\n<span>Object</span><span>.</span>prototype<span>.</span><span>fun</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span><span>}</span><span>;</span>\n<span>const</span> obj <span>=</span> <span>{</span> name<span>:</span> <span>'zhangsan'</span><span>,</span> age<span>:</span> <span>13</span> <span>}</span><span>;</span>\n<span>for</span> <span>(</span><span>const</span> i <span>in</span> obj<span>)</span> <span>{</span>\n  <span>if</span> <span>(</span><span>Object</span><span>.</span>prototype<span>.</span><span>hasOwnProperty</span><span>.</span><span>call</span><span>(</span>obj<span>,</span> i<span>)</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span>i<span>,</span> <span>':'</span><span>,</span> obj<span>[</span>i<span>]</span><span>)</span><span>;</span>    \n  <span>}</span>\n<span>}</span>\n<span>// name : zhangsan</span>\n<span>// age : 13</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><code>for...in...</code> 的循环顺序，参考《JavaScript 权威指南（第7版）》6.6.1。</p>\n<ul>\n<li>先列出名字为非负整数的字符串属性，按照数值顺序从最小到最大。这条规则意味着数组和类数组对象的属性会按照顺序被枚举。</li>\n<li>在列出类数组索引的所有属性之后，在列出所有剩下的字符串名字（包括看起来像整负数或浮点数的名字）的属性。这些属性按照它们添加到对象的先后顺序列出。对于在对象字面量中定义的属性，按照他们在字面量中出现的顺序列出。</li>\n<li>最后，名字为符号对象的属性按照它们添加到对象的先后顺序列出。</li>\n</ul>\n<h2 id=\"object-keys\"> Object.keys</h2>\n<p>用于获取对象自身所有的可枚举的属性值，但不包括原型中的属性，然后返回一个由<strong>属性名</strong>组成的数组。</p>\n<div><pre><code><span>Object</span><span>.</span>prototype<span>.</span><span>fun</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span><span>}</span><span>;</span>\n\n<span>const</span> str <span>=</span> <span>'helloworld'</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>Object<span>.</span><span>keys</span><span>(</span>str<span>)</span><span>)</span><span>;</span>\n<span>// [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]</span>\n\n<span>const</span> arr <span>=</span> <span>[</span><span>'a'</span><span>,</span> <span>'b'</span><span>,</span> <span>'c'</span><span>]</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>Object<span>.</span><span>keys</span><span>(</span>arr<span>)</span><span>)</span><span>;</span>\n<span>// [\"0\", \"1\", \"2\"]</span>\n\n<span>const</span> obj <span>=</span> <span>{</span> name<span>:</span> <span>'zhangsan'</span><span>,</span> age<span>:</span> <span>13</span> <span>}</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>Object<span>.</span><span>keys</span><span>(</span>obj<span>)</span><span>)</span><span>;</span>\n<span>// [\"name\", \"age\"]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id=\"object-values\"> Object.values</h2>\n<p>用于获取对象自身所有的可枚举的属性值，但不包括原型中的属性，然后返回一个由<strong>属性值</strong>组成的数组。</p>\n<div><pre><code><span>Object</span><span>.</span>prototype<span>.</span><span>fun</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span><span>}</span><span>;</span>\n\n<span>const</span> str <span>=</span> <span>'helloworld'</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>Object<span>.</span><span>values</span><span>(</span>str<span>)</span><span>)</span><span>;</span>\n<span>// [\"h\", \"e\", \"l\", \"l\", \"o\", \"w\", \"o\", \"r\", \"l\", \"d\"]</span>\n\n<span>const</span> arr <span>=</span> <span>[</span><span>'a'</span><span>,</span> <span>'b'</span><span>,</span> <span>'c'</span><span>]</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>Object<span>.</span><span>values</span><span>(</span>arr<span>)</span><span>)</span><span>;</span>\n<span>// [\"a\", \"b\", \"c\"]</span>\n\n<span>const</span> obj <span>=</span> <span>{</span> name<span>:</span> <span>'zhangsan'</span><span>,</span> age<span>:</span> <span>13</span> <span>}</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>Object<span>.</span><span>values</span><span>(</span>obj<span>)</span><span>)</span><span>;</span>\n<span>// [\"zhangsan\", 13]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id=\"object-entries\"> Object.entries</h2>\n<p>用于获取对象自身所有的可枚举的属性值，但不包括原型中的属性，然后返回二维数组。每一个子数组由对象的属性名、属性值组成。</p>\n<p>是一种可以同时拿到属性名与属性值的方法。</p>\n<div><pre><code><span>const</span> str <span>=</span> <span>'hello'</span><span>;</span>\n<span>for</span> <span>(</span><span>const</span> <span>[</span>key<span>,</span> value<span>]</span> <span>of</span> Object<span>.</span><span>entries</span><span>(</span>str<span>)</span><span>)</span> <span>{</span>    \n  console<span>.</span><span>log</span><span>(</span><span><span>`</span><span><span>${</span>key<span>}</span></span><span>: </span><span><span>${</span>value<span>}</span></span><span>`</span></span><span>)</span><span>;</span>\n<span>}</span>\n<span>// 0: h</span>\n<span>// 1: e</span>\n<span>// 2: l</span>\n<span>// 3: l</span>\n<span>// 4: o</span>\n\n<span>const</span> arr <span>=</span> <span>[</span><span>'a'</span><span>,</span> <span>'b'</span><span>,</span> <span>'c'</span><span>]</span><span>;</span>\n<span>for</span> <span>(</span><span>const</span> <span>[</span>key<span>,</span> value<span>]</span> <span>of</span> Object<span>.</span><span>entries</span><span>(</span>arr<span>)</span><span>)</span> <span>{</span>    \n  console<span>.</span><span>log</span><span>(</span><span><span>`</span><span><span>${</span>key<span>}</span></span><span>: </span><span><span>${</span>value<span>}</span></span><span>`</span></span><span>)</span><span>;</span>\n<span>}</span>\n<span>// 0: a</span>\n<span>// 1: b</span>\n<span>// 2: c</span>\n\n<span>const</span> obj <span>=</span> <span>{</span> name<span>:</span> <span>'zhangsan'</span><span>,</span> age<span>:</span> <span>13</span> <span>}</span><span>;</span>\n<span>for</span> <span>(</span><span>const</span> <span>[</span>key<span>,</span> value<span>]</span> <span>of</span> Object<span>.</span><span>entries</span><span>(</span>obj<span>)</span><span>)</span> <span>{</span>    \n  console<span>.</span><span>log</span><span>(</span><span><span>`</span><span><span>${</span>key<span>}</span></span><span>: </span><span><span>${</span>value<span>}</span></span><span>`</span></span><span>)</span><span>;</span>\n<span>}</span>\n<span>// name: zhangsan</span>\n<span>// age: 13</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h2 id=\"object-getownpropertynames\"> Object.getOwnPropertyNames</h2>\n<p>用于获取对象自身所有的可枚举的属性值（不包括 Symbol 值作为名称的属性），但不包括原型中的属性，然后返回一个由<strong>属性名</strong>组成的数组。</p>\n<div><pre><code><span>Object</span><span>.</span>prototype<span>.</span><span>fun</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span><span>}</span><span>;</span>\n<span>Array</span><span>.</span>prototype<span>.</span><span>fun</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span><span>}</span><span>;</span>\n\n<span>const</span> str <span>=</span> <span>'hello'</span>\nconsole<span>.</span><span>log</span><span>(</span>Object<span>.</span><span>getOwnPropertyNames</span><span>(</span>str<span>)</span><span>)</span><span>;</span>\n<span>// [\"0\", \"1\", \"2\", \"3\", \"4\", \"length\"]</span>\n\n<span>const</span> arr <span>=</span> <span>[</span><span>'a'</span><span>,</span> <span>'b'</span><span>,</span> <span>'c'</span><span>]</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>Object<span>.</span><span>getOwnPropertyNames</span><span>(</span>arr<span>)</span><span>)</span><span>;</span>\n<span>// [\"0\", \"1\", \"2\", \"length\"]</span>\n\n<span>const</span> obj <span>=</span> <span>{</span> name<span>:</span> <span>'zhangsan'</span><span>,</span> age<span>:</span> <span>13</span> <span>}</span><span>;</span>\n<span>const</span> symbol1 <span>=</span> <span>Symbol</span><span>(</span><span>'symbol1'</span><span>)</span>\n<span>const</span> symbol2 <span>=</span> <span>Symbol</span><span>(</span><span>'symbol2'</span><span>)</span>\nobj<span>[</span>symbol1<span>]</span> <span>=</span> <span>'hello'</span>\nobj<span>[</span>symbol2<span>]</span> <span>=</span> <span>'world'</span>\nconsole<span>.</span><span>log</span><span>(</span>Object<span>.</span><span>getOwnPropertyNames</span><span>(</span>obj<span>)</span><span>)</span><span>;</span>\n<span>// [\"name\", \"age\"]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id=\"object-getownpropertysymbols\"> Object.getOwnPropertySymbols()</h2>\n<p>用于获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p>\n<div><pre><code><span>const</span> obj <span>=</span> <span>{</span> name<span>:</span> <span>'zhangsan'</span><span>,</span> age<span>:</span> <span>13</span> <span>}</span><span>;</span>\n<span>const</span> symbol1 <span>=</span> <span>Symbol</span><span>(</span><span>'symbol1'</span><span>)</span>\n<span>const</span> symbol2 <span>=</span> <span>Symbol</span><span>(</span><span>'symbol2'</span><span>)</span>\nobj<span>[</span>symbol1<span>]</span> <span>=</span> <span>'hello'</span>\nobj<span>[</span>symbol2<span>]</span> <span>=</span> <span>'world'</span>\nconsole<span>.</span><span>log</span><span>(</span>Object<span>.</span><span>getOwnPropertySymbols</span><span>(</span>obj<span>)</span><span>)</span><span>;</span>\n<span>// [Symbol(symbol1), Symbol(symbol2)]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"reflect-ownkeys\"> Reflect.ownKeys()</h2>\n<p>返回一个数组，包含对象自身的所有属性，不管是属性名是 Symbol 或字符串，也不管是否可枚举。</p>\n<div><pre><code><span>const</span> obj <span>=</span> <span>{</span> name<span>:</span> <span>'zhangsan'</span><span>,</span> age<span>:</span> <span>13</span> <span>}</span><span>;</span>\n<span>const</span> symbol1 <span>=</span> <span>Symbol</span><span>(</span><span>'symbol1'</span><span>)</span>\n<span>const</span> symbol2 <span>=</span> <span>Symbol</span><span>(</span><span>'symbol2'</span><span>)</span>\nobj<span>[</span>symbol1<span>]</span> <span>=</span> <span>'hello'</span>\nobj<span>[</span>symbol2<span>]</span> <span>=</span> <span>'world'</span>\nconsole<span>.</span><span>log</span><span>(</span>Reflect<span>.</span><span>ownKeys</span><span>(</span>obj<span>)</span><span>)</span><span>;</span>\n<span>// [\"name\", \"age\", Symbol(symbol1), Symbol(symbol2)]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>（完）</p>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T07:36:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "垃圾回收",
      "url": "https://www.fedbook.cn/frontend-knowledge/javascript/gc/",
      "id": "https://www.fedbook.cn/frontend-knowledge/javascript/gc/",
      "content_html": "<h1 id=\"垃圾回收\"> 垃圾回收</h1>\n<h2 id=\"前置概念\"> 前置概念</h2>\n<p><strong>内存管理</strong></p>\n<p>内存管理指申请内存空间、使用内存空间和释放内存空间的这一系列步骤。</p>\n<p>JavaScript 不能像 C 或 C++ 那样由开发者主动调用 API 来完成内存管理，而是使用垃圾回收机制来自动管理内存，其好处是可以大幅简化程序的内存管理代码，降低程序员的负担，减少因长时间运转而带来的内存泄露问题。</p>\n<p><strong>何为垃圾</strong></p>\n<p>在 JavaScript 中以下两种对象数据被定义为垃圾：</p>\n<ul>\n<li>对象不再被引用时就是垃圾。</li>\n<li>对象不能<strong>从根上访问到</strong>时就是垃圾（对象不是可达对象 = 垃圾）。</li>\n</ul>\n<p><strong>可达对象</strong></p>\n<ul>\n<li>可以访问到的对象就是可达对象（通过引用、作用域链可以查找到）。</li>\n<li>可达的标准就是从根出发是否能够被找到。</li>\n<li>JavaScript 中的根可以理解为是全局变量对象（全局执行上下文）。</li>\n</ul>\n<h2 id=\"gc-算法\"> GC 算法</h2>\n<h3 id=\"gc-里的垃圾\"> GC 里的垃圾</h3>\n<p>GC（Garbage Collection）是垃圾回收机制的简写，它可以查找内存中的垃圾、释放空间和回收空间。在 GC 中，有两种判定为垃圾的标准（当作垃圾 ≠ 被回收）：</p>\n<ul>\n<li>程序中不再需要使用的对象</li>\n</ul>\n<div><pre><code><span>function</span> <span>func</span><span>(</span><span>)</span> <span>{</span>\n  <span>// 没有声明变量的关键字，name 被挂载在当前的 window 对象下</span>\n  name <span>=</span> <span>'peter'</span><span>;</span>\n  <span>return</span> <span><span>`</span><span><span>${</span>name<span>}</span></span><span> is a dog.</span><span>`</span></span><span>;</span>\n<span>}</span>\n\n<span>func</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>\n<li>程序中不能再访问到的对象</li>\n</ul>\n<div><pre><code><span>function</span> <span>func</span><span>(</span><span>)</span> <span>{</span>\n  <span>// 增加声明变量的关键字，当函数调用结束后，在外部空间就不能访问到 name 了</span>\n  <span>const</span> name <span>=</span> <span>'peter'</span><span>;</span>\n  <span>return</span> <span><span>`</span><span><span>${</span>name<span>}</span></span><span> is a dog.</span><span>`</span></span><span>;</span>\n<span>}</span>\n\n<span>func</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>在垃圾回收器进行工作的时候，如何查找垃圾、怎样释放空间、回收空间时如何进行分配，这一系列过程中遵循的规则，就是 GC 算法。</p>\n<p>常见的 GC 算法有：</p>\n<ul>\n<li><strong>引用计数</strong>：通过一个数字判断当前对象是不是垃圾。</li>\n<li><strong>标记清除</strong>：在 GC 工作时给活动对象添加一个标记，来判断它是否是一个垃圾。</li>\n<li><strong>标记整理</strong>：同标记清除，但在后续回收过程中可以做一些不同的事情。</li>\n<li><strong>分代回收</strong>：V8 中的回收机制。</li>\n</ul>\n<h3 id=\"引用计数算法实现原理\"> 引用计数算法实现原理</h3>\n<p><strong>核心思想</strong>：在内部通过一个引用计数器，维护当前对象的引用数。在引用关系改变时修改引用计数器的数字。当这个数值为 0 的时候，GC 开始工作，将其所在的对象空间进行回收和释放。</p>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>可以即时回收垃圾对象</li>\n<li>最大限度减少程序卡顿时间（能尽可能保证内存不会有占满的时候）</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>无法回收循环引用的对象<div><pre><code><span>function</span> <span>fn</span><span>(</span><span>)</span> <span>{</span>\n  <span>const</span> obj1 <span>=</span> <span>{</span><span>}</span><span>;</span>\n  <span>const</span> obj2 <span>=</span> <span>{</span><span>}</span><span>;</span>\n  obj1<span>.</span>name <span>=</span> obj2<span>;</span>\n  obj2<span>.</span>name <span>=</span> obj1<span>;</span>\n  <span>return</span> <span>'peter is a dog.'</span><span>;</span>\n<span>}</span>\n\n<span>// 函数调用完后，虽然全局作用域内找不到 obj1 和 obj2</span>\n<span>// 但由于他们两者之间有互相指引关系，所以引用计数器数值不为 0，因此空间无法回收</span>\n<span>fn</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></li>\n<li>资源消耗较大（需要时刻监控当前对象的引用数值）</li>\n</ul>\n<h3 id=\"标记清除算法实现原理\"> 标记清除算法实现原理</h3>\n<p><strong>核心思想</strong>：将整个垃圾回收操作分成「标记」和「清除」二个阶段完成。</p>\n<p>第一个阶段会遍历所有对象，找出活动对象（可达对象）并标记。第二个阶段仍是遍历所有对象，清除没有标记的对象，同时消除在第一阶段设置的标记，便于 GC 下一次的正常工作。</p>\n<p>经过两个阶段的遍历行为，可以回收相应的空间，交给空闲列表维护以供后续的程序代码使用。</p>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>可以回收循环引用的对象（例如函数局部作用域内互相引用的变量，当函数调用结束之后，局部空间的变量失去了与全局空间在作用域上的连接，成为了不可达对象，在标记阶段就无法完成标记，在清除阶段会被清除）</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>容易产生碎片化空间，浪费空间（由于当前所回收的垃圾对象在地址上本身是不连续的，在回收之后它们会分散在各个角落，后续使用的时候如果新的生成空间刚好大小匹配就可以直接用，如果多了或者少了就不太适合使用了）</li>\n<li>不会立即回收垃圾对象</li>\n</ul>\n<h3 id=\"标记整理算法实现原理\"> 标记整理算法实现原理</h3>\n<p><strong>核心思想</strong>：标记整理可以看作是标记清除的增强。标记阶段的操作和标记清除一致，清除阶段会先执行整理，移动对象位置（让它们在地址上产生连续）。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/gc-mark-compact.png\" alt=\"标记整理算法图示\" style=\"width: 480px;\">\n  <p style=\"text-align: center; color: #888\">（标记整理算法图示）</p>\n</div>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>减少碎片化空间</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>不会立即回收垃圾对象</li>\n</ul>\n<h2 id=\"v8-垃圾回收\"> V8 垃圾回收</h2>\n<h3 id=\"v8-内存分配\"> V8 内存分配</h3>\n<p>V8 对所能使用的总内存空间进行了上限约束：64 位系统是 1.5GB，32 位系统是 800MB。</p>\n<details><summary>为什么是 1.5GB 这个数值？</summary>\n<ul>\n<li>\n<p>V8 最初是作为浏览器的 JavaScript 引擎而设计，所以对网页应用来说不太可能遇到大量内存的场景。</p>\n</li>\n<li>\n<p>V8 内部实现的垃圾回收机制，也决定了这个数值设定比较合理：V8 在执行垃圾回收时会阻塞 JavaScript应用逻辑，经官方测试，当垃圾内存达到 1.5GB 时，采用增量标记算法进行垃圾回收需要消耗 50ms，采用非增量标记算法进行垃圾回收需要消耗 1s，这样浏览器将在 1s 内失去对用户的响应，造成假死现象。</p>\n</li>\n</ul>\n</details>\n<p>V8 将内存（堆）空间一分为二，其中小空间用于存储新生代对象（64 位是 32MB，32 位是 16MB），另一部分较大空间用于存储老生代对象（64 位是 1.4GB，32 位是 700MB）。</p>\n<div><p>解释</p>\n<p>新生代对象指的是存活时间较短的对象（例如局部作用域中的变量）。<br>\n老生代对象指的是存活时间较长的对象（例如全局作用域下的变量、闭包中放置的变量）。</p>\n</div>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/v8-memory-allocation.png\" alt=\"V8 内存分配\">\n  <p style=\"text-align: center; color: #888\">（V8 内存分配）</p>\n</div>\n<h3 id=\"v8-垃圾回收策略\"> V8 垃圾回收策略</h3>\n<p>在 JavaScript 中的数据，分为基本数据类型和引用数据类型两种：</p>\n<ul>\n<li><strong>基本数据类型</strong>：存储在栈空间中，由程序语言自身进行控制。\n<ul>\n<li>JavaScript 引擎会通过向下移动 ESP（记录当前执行状态的指针）来销毁该函数保存在栈中的执行上下文。</li>\n</ul>\n</li>\n<li><strong>引用数据类型</strong>：存储在堆空间中，V8 所进行的垃圾回收操作主要针对存在堆内存中的引用数据类型。\n<ul>\n<li>副垃圾回收器：主要负责新生代的垃圾回收。</li>\n<li>主垃圾回收器：主要负责老生代的垃圾回收。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"_1-副垃圾回收器-新生代垃圾回收\"> 1）副垃圾回收器：新生代垃圾回收</h4>\n<p><strong>复制算法 + 标记整理算法</strong>：</p>\n<ul>\n<li>新生代内存区分为两个大小相等的空间：使用空间为 From，空闲空间为 To。</li>\n<li>每当有新生对象诞生，就会在 From 空间出现。</li>\n<li>一旦 From 空间被占满，就触发 GC。</li>\n<li>对 From 空间的活动对象进行标记整理，然后将它们整个拷贝至 To。</li>\n<li>清空 From 空间 （这样就可以实现把不活跃的对象给回收掉）。</li>\n<li>From 与 To 交换空间，开始下一轮循环。</li>\n</ul>\n<p><strong>注意点</strong>：</p>\n<ul>\n<li>拷贝过程中可能出现晋升：将新生代对象移动至老生代存储区。</li>\n<li>一轮 GC 结束还存活的新生代对象需要晋升。</li>\n<li>拷贝时发现 To 空间的使用率超过 25%，则将本次拷贝对象直接移动至老生代存储区（25%：防止交换空间后，From 空间直接爆满，新的活动对象存不进去）。</li>\n</ul>\n<h4 id=\"_2-主垃圾回收器-老生代垃圾回收\"> 2）主垃圾回收器：老生代垃圾回收</h4>\n<p><strong>标记清除、标记整理、增量标记算法</strong>：</p>\n<ul>\n<li>首先使用标记清除完成垃圾空间的回收（相对于空间碎片的问题，能够明显提升速度）。</li>\n<li>采用标记整理进行空间优化（新生代对象晋升时，如果老生代存储区空间不够，就触发标记整理）。</li>\n<li>采用增量标记进行效率优化。</li>\n</ul>\n<p><strong>细节对比</strong>：</p>\n<ul>\n<li>新生代区域垃圾回收使用空间换时间（复制算法导致每时每刻都会存在一个空闲空间）</li>\n<li>老生代区域垃圾回收不适合用复制算法（老生代存储空间较大，如果一分为二会浪费太多空间。且老生代存储空间会存储较多对象数据，如果进行复制操作会消耗过多时间。）</li>\n</ul>\n<p><strong>增量标记算法如何优化垃圾回收</strong>：</p>\n<p>当垃圾回收开始工作的时候，会阻塞当前 JavaScript 程序的执行，于是就会产生「空档期」。增量标记算法能够将原本一整段的垃圾回收操作拆分成多个小步骤，从而替代原先一口气完成的垃圾回收操作，这样做可以让垃圾回收与程序执行交替工作。</p>\n<p>如下图所示，当程序运行到某个时刻，触发垃圾回收机制。首先对老生代存储区的对象数据进行遍历，先找到第一层的可达对象，然后程序继续执行，接着对子元素（第二层可达对象）进行标记操作，接着程序继续执行，以此循环直到标记过程结束，最后完成垃圾回收操作后，程序继续执行。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/incremental-marking.png\" alt=\"增量标记算法如何优化垃圾回收\">\n  <p style=\"text-align: center; color: #888\">（增量标记算法如何优化垃圾回收）</p>\n</div>\n<p>上述这个过程看似程序停顿了很多次，但整个 V8 最大的垃圾回收（达到 1.5GB）即使采用非增量标记的方式去回收也不会超过 1s。</p>\n<h2 id=\"内存问题\"> 内存问题</h2>\n<h3 id=\"内存泄漏和内存溢出\"> 内存泄漏和内存溢出</h3>\n<h4 id=\"_1-内存泄漏\"> 1）内存泄漏</h4>\n<p>内存泄漏是指程序执行时，一些变量没有及时释放，一直占用着内存，而这种占用内存的行为就叫做内存泄漏。</p>\n<p>作为一般的用户，根本感觉不到内存泄漏的存在。真正有危害的是内存泄漏的堆积，这会最终消耗尽系统所有的内存。从这个角度来说，内存泄漏如果一直堆积，最终会导致内存溢出问题。</p>\n<h4 id=\"_2-内存溢出\"> 2）内存溢出</h4>\n<p>执行程序时，程序会向系统申请一定大小的内存，当系统现在的实际内存少于需要的内存时，就会造成内存溢出。内存溢出造成的结果是先前保存的数据会被覆盖或者后来的数据会没地方存。</p>\n<p>最简单的就是写一个千万级别的循环，然后用浏览器打开，浏览器会非常卡，甚至直接报错内存不足，崩溃了。不同浏览器会有不同的表现。</p>\n<p>在 JavaScript 中，内存溢出一般是内存泄漏造成的，占用的内存不需要用到了但是没有及时释放，内存泄漏积累的多了轻的话影响系统性能，严重直接引起内存溢出系统崩溃。</p>\n<p>在浏览器执行以下代码就会造成内存溢出（执行后需要等待一段时间）：</p>\n<div><pre><code>console<span>.</span><span>log</span><span>(</span><span>'begin'</span><span>)</span>\n<span>var</span> obj <span>=</span> <span>{</span><span>}</span><span>;</span>\n<span>for</span> <span>(</span><span>var</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>100000</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n  obj<span>[</span>i<span>]</span> <span>=</span> <span>new</span> <span>Array</span><span>(</span><span>10000000</span><span>)</span><span>;</span>\n<span>}</span>\nconsole<span>.</span><span>log</span><span>(</span><span>'end'</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"内存问题的体现\"> 内存问题的体现</h3>\n<p>首先，如果界面出现延迟加载或者经常性的暂停，排除完网络环境的问题，这种情况一般都会判定内存存在问题，而且与频繁的垃圾回收操作有关，即代码中存在瞬间让内存爆炸的逻辑。</p>\n<p>其次，如果界面出现持续性的糟糕性能表现，排除完网络环境的问题，这种情况一般会认为存在内存溢出。内存溢出是一种程序运行出现的错误，当程序运行需要的内存超过了剩余的内存时，就抛出内存溢出的错误。</p>\n<p>最后，如果界面随着使用时间的增长表现出性能越来越差的现象，这个过程就伴随着内存泄露，因为在这种情况下刚开始的时候是没有问题的，由于某些代码的出现，随着时间的增长让内存空间越来越少。</p>\n<h3 id=\"监控内存的几种方式\"> 监控内存的几种方式</h3>\n<p>在排查内存问题的时候，可以借助浏览器所提供的几个工具：</p>\n<ul>\n<li>浏览器所带的任务管理器：可以直接以数值的方式将当前应用程序在执行过程中内存的变化体现出来。</li>\n<li>Timeline 时序图：可以直接把应用程序执行过程中所有内存的走势以时间点的方式呈现出来。</li>\n<li>浏览器中的堆快照功能：可以很有针对性的查找界面对象中是否存在一些分离的 DOM，因为分离 DOM 的存在也就是一种内存上的泄露。</li>\n</ul>\n<p>至于怎样判断界面是否存在着频繁的垃圾回收，这就需要借助于不同的工具来获取当前内存的走势图，然后进行一个时间段的分析，从而得出判断。</p>\n<h2 id=\"容易导致内存泄露的场景\"> 容易导致内存泄露的场景</h2>\n<h4 id=\"_1-意外的全局变量\"> 1）意外的全局变量</h4>\n<p>全局变量的生命周期最长，直到页面关闭前，它都存活着，所以全局变量上的内存一直都不会被回收。当全局变量使用不当，没有及时回收（手动赋值 <code>null</code>），或者拼写错误等将某个变量挂载到全局变量时，也就发生内存泄漏了。</p>\n<ul>\n<li>未声明变量</li>\n</ul>\n<div><pre><code><span>function</span> <span>foo</span><span>(</span><span>)</span> <span>{</span>\n  <span>// 不小心没有 var 定义，这时候 name 变量是全局的</span>\n  name <span>=</span> <span>'global variable'</span><span>;</span>\n<span>}</span>\n<span>fn</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>\n<li>使用 <code>this</code> 创建的变量（this 的指向是 window）</li>\n</ul>\n<div><pre><code><span>function</span> <span>foo</span><span>(</span><span>)</span> <span>{</span>\n  <span>// name 变量挂载到了全局</span>\n  <span>this</span><span>.</span>name <span>=</span> <span>'global variable'</span><span>;</span>\n<span>}</span>\n<span>fn</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>解决方法：</p>\n<ul>\n<li>尽量避免创建全局变量。</li>\n<li>使用严格模式，在 JavaScript 文件头部或者函数的顶部加上 <code>use strict</code>。</li>\n</ul>\n<h4 id=\"_2-遗漏的-dom-元素\"> 2）遗漏的 DOM 元素</h4>\n<p>DOM 元素的生命周期正常是取决于是否挂载在 DOM 树上，当从 DOM 树上移除时，也就可以被销毁回收了。</p>\n<p>但如果某个 DOM 元素，在 JavaScript 代码中也持有它的引用，那么它的生命周期就由 JS 代码和是否在 DOM 树上两者决定了，在移除时，两个地方都需要去清理才能正常回收它。</p>\n<p>如下代码：虽然别的地方删除了，但是对象中还存在对 dom 的引用。</p>\n<div><pre><code><span>// 在对象中引用 DOM</span>\n<span>var</span> elements <span>=</span> <span>{</span>\n  btn<span>:</span> document<span>.</span><span>getElementById</span><span>(</span><span>'btn'</span><span>)</span><span>,</span>\n<span>}</span>\n<span>function</span> <span>doSomeThing</span><span>(</span><span>)</span> <span>{</span>\n  elements<span>.</span>btn<span>.</span><span>click</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>function</span> <span>removeBtn</span><span>(</span><span>)</span> <span>{</span>\n  <span>// 将 body 中的 btn 移除, 也就是移除 DOM 树中的 btn</span>\n  document<span>.</span>body<span>.</span><span>removeChild</span><span>(</span>document<span>.</span><span>getElementById</span><span>(</span><span>'btn'</span><span>)</span><span>)</span><span>;</span>\n  <span>// 但是此时全局变量 elements 还是保留了对 btn 的引用, btn 还是存在于内存中, 不能被 GC 回收</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>解决方法：</p>\n<ul>\n<li>手动设置空指针移除：<code>elements.btn = null</code></li>\n</ul>\n<h4 id=\"_3-被遗忘的计时器或回调函数\"> 3）被遗忘的计时器或回调函数</h4>\n<div><p>结论</p>\n<p>现代浏览器更先进的垃圾回收算法已经可以正确的检测及处理了。</p>\n</div>\n<p><code>setTimeout</code> 和 <code>setInterval</code> 是由浏览器专门线程来维护它的生命周期，所以当在某个页面使用了计时器，即使该页面销毁时，没有手动去释放清理这些计时器的话，那么这些计时器还是存活着的。</p>\n<p>也就是说，计时器的生命周期并不挂靠在页面上，所以当在当前页面的 JavaScript 代码里通过计时器注册了某个回调函数，而该回调函数内又持有当前页面某个变量或某些 DOM 元素时，就会导致即使页面销毁了，由于计时器持有该页面部分引用而造成页面无法正常被回收，从而导致内存泄漏了。</p>\n<p>如果此时再次打开同个页面，内存中其实是有双份页面数据的，如果多次关闭、打开，那么内存泄漏会越来越严重。</p>\n<p>而且这种场景很容易出现，因为使用计时器的人很容易遗忘清除。</p>\n<p>如下代码：计时器中有 DOM 元素的引用，即使在 DOM 树中将元素删除了，但是计时器还在，所以内存中还是有这个 DOM 元素。</p>\n<div><pre><code><span>// 定时器</span>\n<span>var</span> serverData <span>=</span> <span>loadData</span><span>(</span><span>)</span>\n<span>setInterval</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>\n  <span>var</span> renderer <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'renderer'</span><span>)</span><span>;</span>\n  <span>if</span> <span>(</span>renderer<span>)</span> <span>{</span>\n    renderer<span>.</span>innerHTML <span>=</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span>serverData<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span><span>,</span> <span>5000</span><span>)</span>\n\n<span>// 观察者模式</span>\n<span>var</span> btn <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'btn'</span><span>)</span><span>;</span>\n<span>function</span> <span>onClick</span><span>(</span><span>element</span><span>)</span> <span>{</span>\n  element<span>.</span>innerHTMl <span>=</span> <span>\"I'm innerHTML\"</span><span>;</span>\n<span>}</span>\nbtn<span>.</span><span>addEventListener</span><span>(</span><span>'click'</span><span>,</span> onClick<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>解决方法（<strong>除了现代新浏览器的垃圾回收算法可以移除，建议还是把它写上为好</strong>）：</p>\n<ul>\n<li>手动删除计时器和 DOM（如果有 DOM）：<code>clearInterval(id_of_setinterval)</code> 或 <code>clearTimeout(id_of_settimeout)</code></li>\n<li>removeEventListener 移除事件监听：<code>btn.removeEventListener('click', onClick)</code></li>\n</ul>\n<h4 id=\"_4-闭包与内存泄漏\"> 4）闭包与内存泄漏</h4>\n<div><p>提示</p>\n<p>为什么把这一条放到最后呢，那是因为闭包和内存泄漏之间的微妙关系在现代并不是网传的那样，继续往下看就是了。</p>\n</div>\n<p>函数本身会持有它定义时所在的词法环境的引用，通常情况下，使用完函数后，该函数所申请的内存就会被回收了。</p>\n<p>但当函数内再返回一个函数时，由于返回的函数持有其外部函数的词法环境，而返回的函数又被其他生命周期东西所持有，导致外部函数虽然执行完了，但内存却无法被回收。</p>\n<p>所以，返回的函数，它的生命周期应尽量不宜过长，方便该闭包能够及时被回收。</p>\n<p>解决办法：及时释放</p>\n<div><pre><code><span>function</span> <span>fn1</span><span>(</span><span>)</span> <span>{</span>\n  <span>var</span> arr <span>=</span> <span>new</span> <span>Array</span><span>[</span><span>100000</span><span>]</span><span>;</span>\n  <span>function</span> <span>fn2</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span>arr<span>.</span>length<span>)</span><span>;</span>\n  <span>}</span>\n  <span>return</span> fn2<span>;</span>\n<span>}</span>\n<span>var</span> f <span>=</span> <span>fn1</span><span>(</span><span>)</span><span>;</span>\n<span>f</span><span>(</span><span>)</span><span>;</span>\n<span>f</span><span>(</span><span>)</span><span>;</span>\nf <span>=</span> <span>null</span> <span>// 让内部函数成为垃圾对象, 释放闭包</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><p>误解</p>\n<p>闭包会造成内存泄漏。（❌）<br>\n闭包不会造成内存泄漏，程序写错了才会造成内存泄漏。（✔️）</p>\n</div>\n<p>网传的那句「闭包会造成内存泄漏」其实是基于旧版本 IE 的 bug 得出的结论。当时由于 IE9 之前的版本中，BOM 和 DOM 中的对象是使用 C++ 以 COM 对象的方式实现的，而 COM 对象的垃圾收集机制采用的是引用计数算法。在基于引用计数算法的垃圾回收机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收。具体来说，如果闭包的作用域链中保存着一个 HTML 元素，那么就意味着该元素将无法被销毁。（—— 引用自《JavaScript设计模式与开发实践》第 3 章。）</p>\n<p>例如下面的代码，btn 元素本身存在于 DOM 中，是一个引用的存在；<code>foo</code> 函数内部的 <code>el</code> 也是对该节点的一个引用。如果未来某个时候该节点从 DOM 中被移除了，DOM 中的引用不存在了，但只要匿名函数存在，<code>el</code> 的引用数至少也是 1，因此它所占用的内存就永远不会被回收。但循环引用造成的内存泄露在本质上也不是闭包造成的。</p>\n<div><pre><code><span>function</span> <span>foo</span><span>(</span><span>)</span> <span>{</span>\n  <span>var</span> el <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'btn'</span><span>)</span><span>;</span>\n  el<span>.</span><span>onclick</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span>el<span>.</span>id<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>foo</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>解决的方法也很简单，只需要把循环引用中的变量设为 <code>null</code> 即可。这意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。</p>\n<div><pre><code><span>function</span> <span>foo</span><span>(</span><span>)</span> <span>{</span>\n  <span>var</span> el <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'btn'</span><span>)</span><span>;</span>\n  el<span>.</span><span>onclick</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span>el<span>.</span>id<span>)</span><span>;</span>\n  <span>}</span>\n\n  el <span>=</span> <span>null</span><span>;</span>\n<span>}</span>\n\n<span>foo</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>正常来说，闭包并不是内存泄漏，因为这种持有外部函数词法环境本就是闭包的特性，闭包就是为了让这块内存不被回收，从而方便我们在未来还能继续用到，但这无疑会造成内存的消耗，所以，不宜烂用就是了。</p>\n<h2 id=\"实战中解决内存泄漏\"> 实战中解决内存泄漏</h2>\n<h3 id=\"vue-中容易出现内存泄露的几种情况\"> Vue 中容易出现内存泄露的几种情况</h3>\n<p>使用 Vue 开发单页应用（SPA）时，更要当心内存泄漏的问题。因为在 SPA 的设计中，用户使用它时是不需要刷新浏览器的，所以 JavaScript 应用需要自行清理组件来确保垃圾回收以预期的方式生效。因此开发过程中，你需要时刻警惕内存泄漏的问题。</p>\n<h4 id=\"_1-全局变量造成的内存泄露\"> 1）全局变量造成的内存泄露</h4>\n<p>声明的全局变量在切换页面的时候没有清空。</p>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>\"</span>home<span>\"</span></span><span>></span></span>这里是首页<span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n  <span>export</span> <span>default</span> <span>{</span>\n    <span>mounted</span><span>(</span><span>)</span> <span>{</span>\n      window<span>.</span>test <span>=</span> <span>{</span>\n        <span>// 此处在全局 window 对象中引用了本页面的 dom 对象</span>\n        name<span>:</span> <span>'home'</span><span>,</span>\n        node<span>:</span> document<span>.</span><span>getElementById</span><span>(</span><span>'home'</span><span>)</span><span>,</span>\n      <span>}</span>\n    <span>}</span><span>,</span>\n  <span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>解决方案：在页面卸载的时候顺便处理掉该引用。</p>\n<div><pre><code>destroyed () {\n  window.test = null // 页面卸载的时候解除引用\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id=\"_2-监听在-window-body-等的事件没有解绑\"> 2）监听在 window/body 等的事件没有解绑</h4>\n<p>特别注意 <code>window.addEventListener</code> 之类的时间监听。</p>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>\"</span>home<span>\"</span></span><span>></span></span>这里是首页<span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n  <span>export</span> <span>default</span> <span>{</span>\n    <span>mounted</span> <span>(</span><span>)</span> <span>{</span>\n      window<span>.</span><span>addEventListener</span><span>(</span><span>'resize'</span><span>,</span> <span>this</span><span>.</span>func<span>)</span> <span>// window对象引用了home页面的方法</span>\n    <span>}</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>解决方法：在页面销毁的时候，顺便解除引用，释放内存。</p>\n<div><pre><code>mounted () {\n  window.addEventListener('resize', this.func)\n},\nbeforeDestroy () {\n  window.removeEventListener('resize', this.func)\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id=\"_3-绑在-eventbus-的事件没有解绑\"> 3）绑在 EventBus 的事件没有解绑</h4>\n<p>举个例子：</p>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>\"</span>home<span>\"</span></span><span>></span></span>这里是首页<span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>export</span> <span>default</span> <span>{</span>\n  <span>mounted</span> <span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>$EventBus<span>.</span><span>$on</span><span>(</span><span>'homeTask'</span><span>,</span> <span>res</span> <span>=></span> <span>this</span><span>.</span><span>func</span><span>(</span>res<span>)</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>解决方法：在页面卸载的时候也可以考虑解除引用。</p>\n<div><pre><code>mounted () {\n  this.$EventBus.$on('homeTask', res => this.func(res))\n},\ndestroyed () {\n  this.$EventBus.$off()\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id=\"_4-echarts\"> 4）Echarts</h4>\n<p>每一个图例在没有数据的时候它会创建一个定时器去渲染气泡，页面切换后，Echarts 图例是销毁了，但是这个 Echarts 的实例还在内存当中，同时它的气泡渲染定时器还在运行。这就导致 Echarts 占用 CPU 高，导致浏览器卡顿，当数据量比较大时甚至浏览器崩溃。</p>\n<p>解决方法：加一个 <code>beforeDestroy()</code> 方法释放该页面的 <code>chart</code> 资源，我也试过使用 <code>dispose()</code> 方法，但是 dispose 销毁这个图例，图例是不存在了，但图例的 <code>resize()</code> 方法会启动，则会报没有 resize 这个方法，而 <code>clear()</code> 方法则是清空图例数据，不影响图例的 resize，而且能够释放内存，切换的时候就很顺畅了。</p>\n<div><pre><code>beforeDestroy () {\n  this.chart.clear()\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id=\"_5-v-if-指令产生的内存泄露\"> 5）v-if 指令产生的内存泄露</h4>\n<p><code>v-if</code> 绑定到 <code>false</code> 的值，但是实际上 Dom 元素在隐藏的时候没有被真实的释放掉。</p>\n<p>比如下面的示例中，我们加载了一个带有非常多选项的选择框，然后我们用到了一个显示/隐藏按钮，通过一个 <code>v-if</code> 指令从虚拟 DOM 中添加或移除它。这个示例的问题在于这个 <code>v-if</code> 指令会从 DOM 中移除父级元素，但是我们并没有清除由 <code>Choices.js</code> 新添加的 DOM 片段，从而导致了内存泄漏。</p>\n<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>\"</span>app<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>button</span> <span>v-if</span><span><span>=</span><span>\"</span>showChoices<span>\"</span></span> <span>@click</span><span><span>=</span><span>\"</span>hide<span>\"</span></span><span>></span></span>Hide<span><span><span>&lt;/</span>button</span><span>></span></span>\n  <span><span><span>&lt;</span>button</span> <span>v-if</span><span><span>=</span><span>\"</span>!showChoices<span>\"</span></span> <span>@click</span><span><span>=</span><span>\"</span>show<span>\"</span></span><span>></span></span>Show<span><span><span>&lt;/</span>button</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>v-if</span><span><span>=</span><span>\"</span>showChoices<span>\"</span></span><span>></span></span>\n    <span><span><span>&lt;</span>select</span> <span>id</span><span><span>=</span><span>\"</span>choices-single-default<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>select</span><span>></span></span>\n  <span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n  <span>export</span> <span>default</span> <span>{</span>\n    <span>data</span><span>(</span><span>)</span> <span>{</span>\n      <span>return</span> <span>{</span>\n        showChoices<span>:</span> <span>true</span><span>,</span>\n      <span>}</span>\n    <span>}</span><span>,</span>\n    <span>mounted</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n      <span>this</span><span>.</span><span>initializeChoices</span><span>(</span><span>)</span>\n    <span>}</span><span>,</span>\n    methods<span>:</span> <span>{</span>\n      <span>initializeChoices</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n        <span>let</span> list <span>=</span> <span>[</span><span>]</span>\n        <span>// 我们来为选择框载入很多选项，这样的话它会占用大量的内存</span>\n        <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>1000</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n          list<span>.</span><span>push</span><span>(</span><span>{</span>\n            label<span>:</span> <span>'Item '</span> <span>+</span> i<span>,</span>\n            value<span>:</span> i<span>,</span>\n          <span>}</span><span>)</span>\n        <span>}</span>\n        <span>new</span> <span>Choices</span><span>(</span><span>'#choices-single-default'</span><span>,</span> <span>{</span>\n          searchEnabled<span>:</span> <span>true</span><span>,</span>\n          removeItemButton<span>:</span> <span>true</span><span>,</span>\n          choices<span>:</span> list<span>,</span>\n        <span>}</span><span>)</span>\n      <span>}</span><span>,</span>\n      <span>show</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span>showChoices <span>=</span> <span>true</span>\n        <span>this</span><span>.</span><span>$nextTick</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n          <span>this</span><span>.</span><span>initializeChoices</span><span>(</span><span>)</span>\n        <span>}</span><span>)</span>\n      <span>}</span><span>,</span>\n      <span>hide</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span>showChoices <span>=</span> <span>false</span>\n      <span>}</span><span>,</span>\n    <span>}</span><span>,</span>\n  <span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><p>在上述的示例中，我们可以用 <code>hide()</code> 方法在将选择框从 DOM 中移除之前做一些清理工作，来解决内存泄露问题。为了做到这一点，我们会在 Vue 实例的数据对象中保留一个属性，并会使用 Choices API 中的 <code>destroy()</code> 方法将其清除。</p>\n<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>\"</span>app<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>button</span> <span>v-if</span><span><span>=</span><span>\"</span>showChoices<span>\"</span></span> <span>@click</span><span><span>=</span><span>\"</span>hide<span>\"</span></span><span>></span></span>Hide<span><span><span>&lt;/</span>button</span><span>></span></span>\n  <span><span><span>&lt;</span>button</span> <span>v-if</span><span><span>=</span><span>\"</span>!showChoices<span>\"</span></span> <span>@click</span><span><span>=</span><span>\"</span>show<span>\"</span></span><span>></span></span>Show<span><span><span>&lt;/</span>button</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>v-if</span><span><span>=</span><span>\"</span>showChoices<span>\"</span></span><span>></span></span>\n    <span><span><span>&lt;</span>select</span> <span>id</span><span><span>=</span><span>\"</span>choices-single-default<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>select</span><span>></span></span>\n  <span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n  <span>export</span> <span>default</span> <span>{</span>\n    <span>data</span><span>(</span><span>)</span> <span>{</span>\n      <span>return</span> <span>{</span>\n        showChoices<span>:</span> <span>true</span><span>,</span>\n        choicesSelect<span>:</span> <span>null</span>\n      <span>}</span>\n    <span>}</span><span>,</span>\n    <span>mounted</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n      <span>this</span><span>.</span><span>initializeChoices</span><span>(</span><span>)</span>\n    <span>}</span><span>,</span>\n    methods<span>:</span> <span>{</span>\n      <span>initializeChoices</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n        <span>let</span> list <span>=</span> <span>[</span><span>]</span>\n        <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>1000</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n          list<span>.</span><span>push</span><span>(</span><span>{</span>\n            label<span>:</span> <span>'Item '</span> <span>+</span> i<span>,</span>\n            value<span>:</span> i<span>,</span>\n          <span>}</span><span>)</span>\n        <span>}</span>\n         <span>// 在我们的 Vue 实例的数据对象中设置一个 `choicesSelect` 的引用</span>\n        <span>this</span><span>.</span>choicesSelect <span>=</span> <span>new</span> <span>Choices</span><span>(</span><span>\"#choices-single-default\"</span><span>,</span> <span>{</span>\n          searchEnabled<span>:</span> <span>true</span><span>,</span>\n          removeItemButton<span>:</span> <span>true</span><span>,</span>\n          choices<span>:</span> list<span>,</span>\n        <span>}</span><span>)</span>\n      <span>}</span><span>,</span>\n      <span>show</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span>showChoices <span>=</span> <span>true</span>\n        <span>this</span><span>.</span><span>$nextTick</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n          <span>this</span><span>.</span><span>initializeChoices</span><span>(</span><span>)</span>\n        <span>}</span><span>)</span>\n      <span>}</span><span>,</span>\n      <span>hide</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n        <span>// 现在我们可以让 Choices 使用这个引用，从 DOM 中移除这些元素之前进行清理工作</span>\n        <span>this</span><span>.</span>choicesSelect<span>.</span><span>destroy</span><span>(</span><span>)</span>\n        <span>this</span><span>.</span>showChoices <span>=</span> <span>false</span>\n      <span>}</span><span>,</span>\n    <span>}</span><span>,</span>\n  <span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><h3 id=\"es6-防止内存泄漏\"> ES6 防止内存泄漏</h3>\n<p>前面说过，及时清除引用非常重要。但是，你不可能记得那么多，有时候一疏忽就忘了，所以才有那么多内存泄漏。</p>\n<p>ES6 考虑到这点，推出了两种新的数据结构：weakset 和 weakmap。他们对值的引用都是不计入垃圾回收机制的，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存。</p>\n<div><pre><code><span>const</span> wm <span>=</span> <span>new</span> <span>WeakMap</span><span>(</span><span>)</span>\n<span>const</span> element <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'example'</span><span>)</span>\nvm<span>.</span><span>set</span><span>(</span>element<span>,</span> <span>'something'</span><span>)</span>\nvm<span>.</span><span>get</span><span>(</span>element<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对 element 的引用就是弱引用，不会被计入垃圾回收机制。</p>\n<p>注册监听事件的 listener 对象很适合用 WeakMap 来实现。</p>\n<div><pre><code><span>// 代码 1</span>\nele<span>.</span><span>addEventListener</span><span>(</span><span>'click'</span><span>,</span> handler<span>,</span> <span>false</span><span>)</span>\n\n<span>// 代码 2</span>\n<span>const</span> listener <span>=</span> <span>new</span> <span>WeakMap</span><span>(</span><span>)</span>\nlistener<span>.</span><span>set</span><span>(</span>ele<span>,</span> handler<span>)</span>\nele<span>.</span><span>addEventListener</span><span>(</span><span>'click'</span><span>,</span> listener<span>.</span><span>get</span><span>(</span>ele<span>)</span><span>,</span> <span>false</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码 2 比起代码 1 的好处是：由于监听函数是放在 WeakMap 里面，一旦 Dom 对象 ele 消失，与它绑定的监听函数 handler 也会自动消失。</p>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://blog.csdn.net/arv002/article/details/109818109\" target=\"_blank\" rel=\"noopener noreferrer\">浅析Chrome V8引擎中的垃圾回收机制和内存泄露优化策略</a>（分代回收算法那块写的比我详细）</li>\n<li><a href=\"https://github.com/woshidasusu/Doc/blob/master/%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F.md\" target=\"_blank\" rel=\"noopener noreferrer\">js 内存泄漏场景、如何监控以及分析</a>（如何分析内存泄漏写的比较好）</li>\n<li><a href=\"https://juejin.cn/post/6844903917986267143\" target=\"_blank\" rel=\"noopener noreferrer\">彻底掌握js内存泄漏以及如何避免</a>（引用 MDN 上的例子演示了垃圾回收算法）</li>\n<li>《JavaScript 设计模式与开发实践 》（讲了「闭包会造成内存泄漏」这一说法的历史背景）</li>\n</ul>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2022-01-06T09:06:13.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "继承的八种方式",
      "url": "https://www.fedbook.cn/frontend-knowledge/javascript/inheritance/",
      "id": "https://www.fedbook.cn/frontend-knowledge/javascript/inheritance/",
      "content_html": "<h1 id=\"继承的八种方式\"> 继承的八种方式</h1>\n<h2 id=\"前言\"> 前言</h2>\n<p>在编写代码时，有些对象会有方法（函数），如果把这些方法都放在构造函数中声明就会导致内存的浪费。</p>\n<p>如下，通过调用构造函数的方式来创建对象，<code>Person</code> 是 <code>p1</code>、<code>p2</code> 的构造函数。所有的 <code>Person</code> 对象都有 <code>say</code> 方法，并且功能相似，但是他们占据了不同的内存，会导致内存浪费（内存泄露）。</p>\n<div><pre><code><span>function</span> <span>Person</span><span>(</span><span>)</span> <span>{</span>\n  <span>this</span><span>.</span><span>say</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>\"你好\"</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>var</span> p1 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>\n<span>var</span> p2 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>p1<span>.</span>say <span>===</span> p2<span>.</span>say<span>)</span><span>;</span> <span>// false</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>于是，我们就需要用到<strong>继承</strong>。</p>\n<blockquote>\n<p>通过某种方式让一个对象可以访问到另一个对象中的属性和方法，我们把这种方式称之为继承。</p>\n</blockquote>\n<p>在 JavaScript 中，继承的方式有很多种，外界对此也没有准确的认定到底有多少种方式，褒贬不一，主流通常有 8 种方式：</p>\n<ul>\n<li>原型链继承</li>\n<li>借用构造函数继承</li>\n<li>组合模式继承</li>\n<li>共享原型继承</li>\n<li>原型式继承</li>\n<li>寄生式继承</li>\n<li>寄生组合式继承</li>\n<li>ES6 中 class 的继承（新）</li>\n</ul>\n<h2 id=\"原型链继承\"> 原型链继承</h2>\n<p>通过实例化一个新的函数，子类的原型指向了父类的实例，子类就可以调用其父类原型对象上的私有属性和公有方法。（本质就是重写了子类的原型对象）</p>\n<p>代码示例：</p>\n<div><pre><code><span>function</span> <span>Parent</span><span>(</span><span>)</span> <span>{</span>\n  <span>this</span><span>.</span>parentName <span>=</span> <span>'父类'</span><span>;</span>\n<span>}</span>\n<span>Parent</span><span>.</span>prototype<span>.</span><span>getParentName</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n  <span>return</span> <span>this</span><span>.</span>parentName<span>;</span>\n<span>}</span><span>;</span>\n\n<span>function</span> <span>Child</span><span>(</span><span>)</span> <span>{</span>\n  <span>this</span><span>.</span>childName <span>=</span> <span>'子类'</span><span>;</span>\n<span>}</span>\n<span>Child</span><span>.</span>prototype <span>=</span> <span>new</span> <span>Parent</span><span>(</span><span>)</span><span>;</span>\n<span>Child</span><span>.</span>prototype<span>.</span><span>getChildName</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n  <span>return</span> <span>this</span><span>.</span>childName\n<span>}</span><span>;</span>\n\n<span>var</span> c <span>=</span> <span>new</span> <span>Child</span><span>(</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>c<span>.</span><span>getParentName</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// '父类'</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h4 id=\"注意点\"> 注意点</h4>\n<p><strong>1）别忘记默认的类型</strong></p>\n<p>所有的引用类型都继承了 <code>Object</code>，而这个继承也是通过原型链实现的。因此所有的对象都拥有 <code>Object</code> 的一些默认的方法。如：<code>hasOwnProperty()</code>、<code>propertyIsEnumerable()</code>、<code>toLocaleString()</code>、<code>toString()</code> 和 <code>valueOf()</code>。</p>\n<p><strong>2）确定原型和实例的关系</strong></p>\n<p>可以通过两种方式来确定原型和实例之间的关系。</p>\n<ul>\n<li>第一种：使用 <code>instanceof</code> 操作符。用这个操作符检测实例，只要是原型链中出现过的构造函数，结果就会返回 <code>true</code>。</li>\n<li>第二种：使用 <code>isPrototypeOf()</code> 方法。只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型，因此该方法也会返回 <code>true</code>。</li>\n</ul>\n<p>对于前面创建的类和实例，尝试打印一些比对关系：</p>\n<div><pre><code>console<span>.</span><span>log</span><span>(</span>c <span>instanceof</span> <span>Object</span><span>)</span><span>;</span> <span>//true</span>\nconsole<span>.</span><span>log</span><span>(</span>c <span>instanceof</span> <span>Parent</span><span>)</span><span>;</span> <span>//true</span>\nconsole<span>.</span><span>log</span><span>(</span>c <span>instanceof</span> <span>Child</span><span>)</span><span>;</span>  <span>//true</span>\n\nconsole<span>.</span><span>log</span><span>(</span><span>Object</span><span>.</span>prototype<span>.</span><span>isPrototypeOf</span><span>(</span>c<span>)</span><span>)</span><span>;</span> <span>//true</span>\nconsole<span>.</span><span>log</span><span>(</span><span>Parent</span><span>.</span>prototype<span>.</span><span>isPrototypeOf</span><span>(</span>c<span>)</span><span>)</span><span>;</span> <span>//true</span>\nconsole<span>.</span><span>log</span><span>(</span><span>Child</span><span>.</span>prototype<span>.</span><span>isPrototypeOf</span><span>(</span>c<span>)</span><span>)</span><span>;</span>  <span>//true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><strong>3）子类要在继承后定义新方法</strong></p>\n<p>因为，原型链继承实质上是重写子类的原型对象。所以，如果在继承前就在子类的 <code>prototype</code> 上定义了一些方法和属性，那么继承后，子类的这些属性和方法将会被覆盖。</p>\n<p><strong>4）不能使用对象字面量创建原型方法</strong></p>\n<p>这个的原理跟上一条的实际上是一样的。当你使用对象字面量创建原型方法重写原型的时候，实质上相当于重写了原型链，所以原来的原型链就被切断了。</p>\n<p>代码示例：</p>\n<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br></div><pre><code><span>function</span> <span>Parent</span><span>(</span><span>)</span> <span>{</span>\n  <span>this</span><span>.</span>parentName <span>=</span> <span>'父类'</span><span>;</span>\n<span>}</span>\n<span>Parent</span><span>.</span>prototype<span>.</span><span>getParentName</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n  <span>return</span> <span>this</span><span>.</span>parentName<span>;</span>\n<span>}</span><span>;</span>\n\n<span>function</span> <span>Child</span><span>(</span><span>)</span> <span>{</span>\n  <span>this</span><span>.</span>childName <span>=</span> <span>'子类'</span><span>;</span>\n<span>}</span>\n<span>// 继承 Parent</span>\n<span>Child</span><span>.</span>prototype <span>=</span> <span>new</span> <span>Parent</span><span>(</span><span>)</span><span>;</span>\n<span>// 使用对象字面量添加新方法, 会导致上一行代码无效</span>\n<span>Child</span><span>.</span>prototype <span>=</span> <span>{</span>\n  <span>getChildName</span><span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span>childName<span>;</span>\n  <span>}</span><span>,</span>\n  <span>someOtherMethod</span><span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>false</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>var</span> c <span>=</span> <span>new</span> <span>Child</span><span>(</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>c<span>.</span>getParentName<span>)</span> <span>// undefined</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p><strong>5）注意父类包含引用类型的情况</strong></p>\n<p>代码示例：</p>\n<div><pre><code><span>function</span> <span>Parent</span><span>(</span><span>)</span> <span>{</span>\n  <span>this</span><span>.</span>name <span>=</span> <span>\"父类\"</span><span>;</span>\n  <span>this</span><span>.</span>hobbies <span>=</span> <span>[</span><span>\"sing\"</span><span>,</span> <span>\"dance\"</span><span>,</span> <span>\"rap\"</span><span>]</span><span>;</span>\n<span>}</span>\n<span>function</span> <span>Child</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n<span>// 继承 Parent</span>\n<span>Child</span><span>.</span>prototype <span>=</span> <span>new</span> <span>Parent</span><span>(</span><span>)</span><span>;</span>\n\n<span>var</span> c1 <span>=</span> <span>new</span> <span>Child</span><span>(</span><span>)</span><span>;</span>\nc1<span>.</span>name <span>=</span> <span>\"c1\"</span><span>;</span>\nc1<span>.</span>hobbies<span>.</span><span>push</span><span>(</span><span>\"coding\"</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>c1<span>.</span>name<span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>c1<span>.</span>hobbies<span>)</span><span>;</span>\n\n<span>var</span> c2 <span>=</span> <span>new</span> <span>Child</span><span>(</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>c2<span>.</span>name<span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>c2<span>.</span>hobbies<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>上述代码执行后，输出结果为：</p>\n<div><pre><code><span>\"c1\"</span>\n<span>[</span><span>\"sing\"</span>, <span>\"dance\"</span>, <span>\"rap\"</span>, <span>\"coding\"</span><span>]</span>\n<span>\"父类\"</span>\n<span>[</span><span>\"sing\"</span>, <span>\"dance\"</span>, <span>\"rap\"</span>, <span>\"coding\"</span><span>]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这个例子中的 <code>Parent</code> 构造函数定义了一个 <code>hobbies</code> 属性，该属性包含一个数组（引用类型值）。<code>Parent</code> 的每个实例都会有各自包含自己数组的 <code>hobbies</code> 属性。当 <code>Child</code> 通过原型链继承了 <code>Parent</code> 之后，<code>Child.prototype</code> 就变成了 <code>Parent</code> 的一个实例，因此它也拥有了一个它自己的 <code>hobbies</code> 属性 —— 就跟专门创建了一个 <code>Child.prototype.hobbies</code> 属性一样。但结果是什么呢？结果是 <code>Child</code> 的所有实例都会共享这一个 <code>hobbies</code> 属性。而我们对 <code>c1.hobbies</code> 的修改能够通过 <code>c2.hobbies</code> 反映出来。也就是说，这样的修改会影响各个实例。</p>\n<h4 id=\"优点\"> 优点</h4>\n<ul>\n<li>简单，易实现</li>\n<li>父类新增原型方法/原型属性，子类都能访问</li>\n</ul>\n<h4 id=\"缺点\"> 缺点</h4>\n<ul>\n<li>无法实现多继承</li>\n<li>引用类型的值会被实例共享</li>\n<li>子类型无法给超类型传递参数</li>\n</ul>\n<p>鉴于这些缺点，实践中很少会单独使用原型链继承。</p>\n<h2 id=\"借用构造函数继承-对象冒充\"> 借用构造函数继承（对象冒充）</h2>\n<p>在解决原型链继承中包含引用类型值所带来问题的过程中，开发人员开始使用一种叫做借用构造函数（constructor stealing）的技术。</p>\n<p>这种技术的基本思想，是通过 <code>call</code> 或者 <code>apply</code>，把父类中通过 <code>this</code> 指定的属性和方法复制（借用）到子类创建的实例中，从而达到隔离的效果。</p>\n<div><pre><code><span>function</span> <span>Parent</span><span>(</span><span>name</span><span>)</span> <span>{</span>\n  <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n  <span>this</span><span>.</span>hobbies <span>=</span> <span>[</span><span>\"sing\"</span><span>,</span> <span>\"dance\"</span><span>,</span> <span>\"rap\"</span><span>]</span><span>;</span>\n<span>}</span>\n\n<span>function</span> <span>Child</span><span>(</span><span>name</span><span>)</span> <span>{</span>\n  <span>Parent</span><span>.</span><span>call</span><span>(</span><span>this</span><span>,</span> name<span>)</span><span>;</span>\n  <span>this</span><span>.</span>age <span>=</span> <span>24</span>\n<span>}</span>\n\n<span>var</span> c1 <span>=</span> <span>new</span> <span>Child</span><span>(</span><span>'c1'</span><span>)</span><span>;</span>\n<span>var</span> c2 <span>=</span> <span>new</span> <span>Child</span><span>(</span><span>'c2'</span><span>)</span><span>;</span>\nc1<span>.</span>hobbies<span>.</span><span>push</span><span>(</span><span>'coding'</span><span>)</span><span>;</span>\n\nconsole<span>.</span><span>log</span><span>(</span>c1<span>.</span>hobbies<span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>c2<span>.</span>hobbies<span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>c1 <span>instanceof</span> <span>Parent</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>c1 <span>instanceof</span> <span>Child</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>上述代码执行后，输出结果为：</p>\n<div><pre><code><span>[</span><span>\"sing\"</span>, <span>\"dance\"</span>, <span>\"rap\"</span>, <span>\"coding\"</span><span>]</span>\n<span>[</span><span>\"sing\"</span>, <span>\"dance\"</span>, <span>\"rap\"</span><span>]</span>\n<span>false</span>\n<span>true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>因为 <code>this</code> 对象是在运行时基于函数的执行环境绑定的。也就是说，在全局中，<code>this</code> 等于 <code>window</code>，而当函数被作为某个对象的方法调用时，<code>this</code> 等于那个对象。<code>call</code>、<code>apply</code> 方法可将一个函数的对象上下文从初始的上下文改变为由第一个参数指定的新对象。</p>\n<p>所以，这个借用构造函数就是，<code>new</code> 对象的时候（注意，<code>new</code> 操作符与直接调用是不同的，以函数的方式直接调用的时候，<code>this</code> 指向 <code>window</code>，<code>new</code> 创建的时候，<code>this</code> 指向创建的这个实例），创建了一个新的实例对象，并且执行 <code>Child</code> 里面的代码，里面用 <code>call</code> 调用了 <code>Parent</code>，由于这里的 <code>this</code> 指向是新的实例而不是 <code>Child</code>，所以就会把 <code>Parent</code> 里面的 <code>this</code> 相关属性和方法赋值到新的实例上，而不是赋值到 <code>Child</code> 上面。因此，所有实例各自拥有父类定义的这些 <code>this</code> 的属性和方法。</p>\n<h4 id=\"优点-2\"> 优点</h4>\n<ul>\n<li>解决了引用类型的值被实例共享的问题</li>\n<li>可以向超类传递参数</li>\n<li>可以实现多继承（call 若干个超类）</li>\n</ul>\n<h4 id=\"缺点-2\"> 缺点</h4>\n<ul>\n<li>不能继承超类原型上的属性和方法</li>\n<li>无法实现函数复用，由于 call 有多个父类实例的副本，性能损耗。</li>\n<li>原型链丢失</li>\n</ul>\n<h2 id=\"组合模式继承\"> 组合模式继承</h2>\n<p>组合继承（combination inheritance），有时候也叫做伪经典继承。是将原型链继承和借用构造函数继承的技术组合到一块，从而发挥二者之长的一种继承模式。</p>\n<div><pre><code><span>function</span> <span>Parent</span><span>(</span><span>name</span><span>)</span><span>{</span>\n  <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n  <span>this</span><span>.</span>hobbies <span>=</span> <span>[</span><span>\"sing\"</span><span>,</span> <span>\"dance\"</span><span>,</span> <span>\"rap\"</span><span>]</span><span>;</span>\n<span>}</span>\n<span>Parent</span><span>.</span>prototype<span>.</span><span>getName</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span>\n  <span>return</span> <span>this</span><span>.</span>name\n<span>}</span>\n<span>function</span> <span>Child</span><span>(</span><span>name</span><span>)</span><span>{</span>\n  <span>Parent</span><span>.</span><span>call</span><span>(</span><span>this</span><span>,</span> name<span>)</span><span>;</span>\n  <span>this</span><span>.</span>age <span>=</span> <span>24</span>\n<span>}</span>\n\n<span>Child</span><span>.</span>prototype <span>=</span> <span>new</span> <span>Parent</span><span>(</span><span>'父类'</span><span>)</span>\n<span>var</span> c1 <span>=</span> <span>new</span> <span>Child</span><span>(</span><span>'c1'</span><span>)</span><span>;</span>\n<span>var</span> c2 <span>=</span> <span>new</span> <span>Child</span><span>(</span><span>'c2'</span><span>)</span><span>;</span>\n\nconsole<span>.</span><span>log</span><span>(</span>c1<span>.</span><span>hasOwnProperty</span><span>(</span><span>'name'</span><span>)</span><span>)</span><span>;</span> <span>// true</span>\nconsole<span>.</span><span>log</span><span>(</span>c1<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>              <span>// \"c1\"</span>\n\nc1<span>.</span>hobbies<span>.</span><span>push</span><span>(</span><span>'coding'</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>c1<span>.</span>hobbies<span>)</span><span>;</span>                <span>// [\"sing\", \"dance\", \"rap\", \"coding\"]</span>\nconsole<span>.</span><span>log</span><span>(</span>c2<span>.</span>hobbies<span>)</span><span>;</span>                <span>// [\"sing\", \"dance\", \"rap\"]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>这种继承方式看起来似乎没有问题，但是它却调用了 2 次超类型构造函数：一次在子类构造函数内，另一次是将子类的原型指向父类构造的实例，导致生成了 2 次 <code>name</code> 和 <code>hobbies</code>，只不过实例屏蔽了原型上的（<code>console.log(c1)</code>）。虽然达成了目的，却不是我们最想要的。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/combination-inheritance_c1.png\" alt=\"实例和原型上的属性值不一样\" style=\"width: 450px;\">\n  <p style=\"text-align: center; color: #888;\">（实例和原型上的属性值不一样）</p>\n</div>\n<p>这个问题将在寄生组合式继承里得到解决。</p>\n<h2 id=\"共享原型继承\"> 共享原型继承</h2>\n<p>这种方式下子类和父类共享一个原型。</p>\n<div><pre><code><span>function</span> <span>Parent</span><span>(</span><span>)</span><span>{</span><span>}</span>\n<span>Parent</span><span>.</span>prototype<span>.</span>hobbies <span>=</span> <span>[</span><span>\"sing\"</span><span>,</span> <span>\"dance\"</span><span>,</span> <span>\"rap\"</span><span>]</span><span>;</span>\n\n<span>function</span> <span>Child</span><span>(</span><span>name<span>,</span> age</span><span>)</span><span>{</span>\n  <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n  <span>this</span><span>.</span>age <span>=</span> age<span>;</span>\n<span>}</span>\n<span>Child</span><span>.</span>prototype <span>=</span> <span>Parent</span><span>.</span>prototype<span>;</span>\n\n<span>var</span> c1 <span>=</span> <span>new</span> <span>Child</span><span>(</span><span>\"c1\"</span><span>,</span> <span>20</span><span>)</span><span>;</span>\n<span>var</span> c2 <span>=</span> <span>new</span> <span>Child</span><span>(</span><span>\"c2\"</span><span>,</span> <span>24</span><span>)</span><span>;</span>\n\nc1<span>.</span>hobbies<span>.</span><span>push</span><span>(</span><span>\"coding\"</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>c1<span>.</span>hobbies<span>)</span><span>;</span> <span>// [\"sing\", \"dance\", \"rap\", \"coding\"]</span>\nconsole<span>.</span><span>log</span><span>(</span>c2<span>.</span>hobbies<span>)</span><span>;</span> <span>// [\"sing\", \"dance\", \"rap\", \"coding\"]</span>\nconsole<span>.</span><span>log</span><span>(</span>c1<span>.</span>name<span>)</span><span>;</span>    <span>// \"c1\"</span>\nconsole<span>.</span><span>log</span><span>(</span>c2<span>.</span>name<span>)</span><span>;</span>    <span>// \"c2\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h4 id=\"优点-3\"> 优点</h4>\n<ul>\n<li>简单</li>\n</ul>\n<h4 id=\"缺点-3\"> 缺点</h4>\n<ul>\n<li>只能继承父类原型属性方法，不能继承构造函数属性方法</li>\n<li>与原型链继承一样，存在引用类型问题</li>\n</ul>\n<h2 id=\"原型式继承\"> 原型式继承</h2>\n<p>这种继承方式普遍用于<strong>基于当前已有对象创建新对象</strong>的场景。</p>\n<p>ES5 之前的实现方法：</p>\n<div><pre><code><span>function</span> <span>createAnother</span><span>(</span><span>o</span><span>)</span> <span>{</span>\n  <span>function</span> <span>F</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n  <span>F</span><span>.</span>prototype <span>=</span> o<span>;</span>\n  <span>return</span> <span>new</span> <span>F</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>var</span> o1 <span>=</span> <span>{</span>\n  name<span>:</span> <span>'父对象'</span><span>,</span>\n  <span>say</span><span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n<span>}</span>\n\n<span>var</span> o2 <span>=</span> <span>createAnother</span><span>(</span>o1<span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>o2<span>.</span>name<span>)</span><span>;</span> <span>// \"父对象\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>ES5 之后的实现方法：</p>\n<p>新增了 <code>Object.create()</code> 方法规范化了原型式继承，如下代码所示：</p>\n<div><pre><code><span>// 用法一: 创建一个纯洁的对象: 对象什么属性都没有</span>\nObject<span>.</span><span>create</span><span>(</span><span>null</span><span>)</span><span>;</span>\n\n<span>// 用法二: 创建一个子对象, 它继承自某个父对象</span>\n<span>var</span> o1 <span>=</span> <span>{</span>\n  name<span>:</span> <span>'父对象'</span><span>,</span>\n  <span>say</span><span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n<span>}</span>\n<span>var</span> o2 <span>=</span> Object<span>.</span><span>create</span><span>(</span>o1<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h4 id=\"优点-4\"> 优点</h4>\n<ul>\n<li>简单</li>\n</ul>\n<h4 id=\"缺点-4\"> 缺点</h4>\n<ul>\n<li>包含引用类型的属性值始终都会共享相应的值（和原型链继承一样）</li>\n<li>无法实现复用（新实例属性都是后面添加的）</li>\n</ul>\n<h2 id=\"寄生式继承\"> 寄生式继承</h2>\n<p>寄生式继承是原型式继承的加强版，它结合原型式继承和工厂模式，创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后返回对象。</p>\n<div><pre><code><span>function</span> <span>createAnother</span><span>(</span><span>origin</span><span>)</span> <span>{</span>\n  <span>var</span> clone <span>=</span> Object<span>.</span><span>create</span><span>(</span>origin<span>)</span><span>;</span> <span>// 通过调用函数创建一个新对象</span>\n  clone<span>.</span><span>sayHi</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>         <span>// 以某种方式来增强这个对象</span>\n    <span>alert</span><span>(</span><span>\"Hi\"</span><span>)</span><span>;</span>\n  <span>}</span><span>;</span>\n  <span>return</span> clone<span>;</span>                      <span>// 返回这个对象</span>\n<span>}</span>\n\n<span>var</span> o1 <span>=</span> <span>{</span>\n  name<span>:</span> <span>\"父对象\"</span><span>,</span>\n  hobbies<span>:</span> <span>[</span><span>\"sing\"</span><span>,</span> <span>\"dance\"</span><span>,</span> <span>\"rap\"</span><span>]</span>\n<span>}</span><span>;</span>\n<span>var</span> o2 <span>=</span> <span>createAnother</span><span>(</span>o1<span>)</span><span>;</span>\no2<span>.</span><span>sayHi</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>在上述例子中，<code>createAnother</code> 函数接收了一个参数，也就是将要被继承的对象。</p>\n<p><code>o2</code> 是基于 <code>o1</code> 创建的一个新对象，新对象不仅具有 <code>o1</code> 的所有属性和方法，还有自己的 <code>sayHi()</code> 方法。</p>\n<p>简单而言，寄生式继承在产生了这个继承父类的对象之后，为这个对象添加了一些增强方法。</p>\n<h4 id=\"优点-5\"> 优点</h4>\n<ul>\n<li>没啥优点</li>\n</ul>\n<h4 id=\"缺点-5\"> 缺点</h4>\n<ul>\n<li>原型式继承有的缺点它都有，只是外面装个壳，就演化成了另一种继承模式。</li>\n</ul>\n<h2 id=\"寄生组合式继承\"> 寄生组合式继承</h2>\n<p>顾名思义，寄生式 + 组合式。它是寄生式继承的加强版。这也是为了避免组合继承中无可避免地要调用两次父类构造函数的最佳方案。</p>\n<p><strong>开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式</strong>。</p>\n<p>基本写法：</p>\n<div><pre><code><span>/**\n * 寄生式组合继承的核心逻辑\n * @param {string} subClass: 子类构造函数\n * @param {string} superClass: 父类构造函数\n*/</span>\n<span>function</span> <span>inheritPrototype</span><span>(</span><span>subClass<span>,</span> superClass</span><span>)</span> <span>{</span>\n  <span>let</span> prototype <span>=</span> Object<span>.</span><span>create</span><span>(</span>superClass<span>.</span>prototype<span>)</span><span>;</span> <span>// 创建原型对象(父类构造函数的原型对象的副本)</span>\n  prototype<span>.</span>constructor <span>=</span> subClass<span>;</span>                    <span>// 增强原型对象(解决由于重写原型导致默认 constructor 丢失的问题)</span>\n  subClass<span>.</span>prototype <span>=</span> prototype<span>;</span>                      <span>// 赋值原型对象</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>兼容写法：</p>\n<div><pre><code><span>function</span> <span>object</span><span>(</span><span>o</span><span>)</span> <span>{</span>\n  <span>function</span> <span>W</span><span>(</span><span>)</span> <span>{</span>\n  <span>}</span>\n  <span>W</span><span>.</span>prototype <span>=</span> o<span>;</span>\n  <span>return</span> <span>new</span> <span>W</span><span>;</span>\n<span>}</span>\n<span>function</span> <span>inheritPrototype</span><span>(</span><span>subClass<span>,</span> superClass</span><span>)</span> <span>{</span>\n  <span>var</span> prototype<span>;</span>\n  <span>if</span> <span>(</span><span>typeof</span> Object<span>.</span>create <span>===</span> <span>'function'</span><span>)</span> <span>{</span>\n    prototype <span>=</span> Object<span>.</span><span>create</span><span>(</span>superClass<span>.</span>prototype<span>)</span><span>;</span>\n  <span>}</span> <span>else</span> <span>{</span>\n    prototype <span>=</span> <span>object</span><span>(</span>superClass<span>.</span>prototype<span>)</span><span>;</span>\n  <span>}</span>         \n  prototype<span>.</span>constructor <span>=</span> subClass<span>;</span>\n  subClass<span>.</span>prototype <span>=</span> prototype<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>本质是子类的原型继承自父类的原型，申明一个用于继承原型的 <code>inheritPrototype</code> 方法，通过这个方法我们能够将子类的原型指向超类的原型，从而避免超类二次实例化。</p>\n<p>实例代码：这里只调用了一次 <code>Parent</code> 构造函数，避免了 <code>Child.prototype</code> 上不必要也用不到的属性，因此可以说这个例子的效率更高，而且原型链仍然保持不变。</p>\n<div><pre><code><span>function</span> <span>Parent</span><span>(</span><span>name</span><span>)</span> <span>{</span>\n  <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n  <span>this</span><span>.</span>hobbies <span>=</span> <span>[</span><span>\"sing\"</span><span>,</span> <span>\"dance\"</span><span>,</span> <span>\"rap\"</span><span>]</span><span>;</span>\n<span>}</span>\n<span>Parent</span><span>.</span>prototype<span>.</span><span>getHobbies</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span>\n  <span>return</span> <span>this</span><span>.</span>hobbies\n<span>}</span>\n\n<span>function</span> <span>Child</span><span>(</span><span>name<span>,</span> age</span><span>)</span> <span>{</span>\n  <span>Parent</span><span>.</span><span>call</span><span>(</span><span>this</span><span>,</span> name<span>)</span><span>;</span>  <span>// 组合式继承的优点: 解决引用类型值被实例共享的问题</span>\n  <span>this</span><span>.</span>age <span>=</span> age\n<span>}</span>\n<span>inheritPrototype</span><span>(</span>Child<span>,</span> Parent<span>)</span><span>;</span>\n<span>// 注意: 一定要在继承后, 补充该原型方法, 否则会被覆盖</span>\n<span>Child</span><span>.</span>prototype<span>.</span><span>getAge</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n  <span>return</span> <span>this</span><span>.</span>age\n<span>}</span><span>;</span>\n\n<span>// 测试结果</span>\n<span>var</span> c1 <span>=</span> <span>new</span> <span>Child</span><span>(</span><span>'c1'</span><span>,</span> <span>12</span><span>)</span><span>;</span>\n<span>var</span> c2 <span>=</span> <span>new</span> <span>Child</span><span>(</span><span>'c2'</span><span>,</span> <span>13</span><span>)</span><span>;</span>\n\nconsole<span>.</span><span>log</span><span>(</span>c1 <span>instanceof</span> <span>Child</span><span>)</span><span>;</span>  <span>// true</span>\nconsole<span>.</span><span>log</span><span>(</span>c1 <span>instanceof</span> <span>Parent</span><span>)</span><span>;</span> <span>// true</span>\nconsole<span>.</span><span>log</span><span>(</span>c1<span>.</span>constructor<span>)</span><span>;</span>       <span>// Child</span>\nconsole<span>.</span><span>log</span><span>(</span><span>Child</span><span>.</span>prototype<span>.</span>__proto__ <span>===</span> <span>Parent</span><span>.</span>prototype<span>)</span><span>;</span>  <span>// true</span>\nconsole<span>.</span><span>log</span><span>(</span><span>Parent</span><span>.</span>prototype<span>.</span>__proto__ <span>===</span> <span>Object</span><span>.</span>prototype<span>)</span><span>;</span> <span>// true</span>\n\nc1<span>.</span>hobbies<span>.</span><span>push</span><span>(</span><span>'coding'</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>c1<span>.</span><span>getHobbies</span><span>(</span><span>)</span><span>)</span><span>;</span>     <span>// [\"sing\", \"dance\", \"rap\", \"coding\"]</span>\nconsole<span>.</span><span>log</span><span>(</span>c2<span>.</span><span>getHobbies</span><span>(</span><span>)</span><span>)</span><span>;</span>     <span>// [\"sing\", \"dance\", \"rap\"]</span>\nconsole<span>.</span><span>log</span><span>(</span>c1<span>.</span><span>getAge</span><span>(</span><span>)</span><span>)</span><span>;</span>         <span>// 12</span>\nconsole<span>.</span><span>log</span><span>(</span>c2<span>.</span><span>getAge</span><span>(</span><span>)</span><span>)</span><span>;</span>         <span>// 13</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>这也是目前最完美的继承方案，它与 ES6 的 class 实现方式最为接近。</p>\n<h4 id=\"优点-6\"> 优点</h4>\n<ul>\n<li>堪称完美</li>\n</ul>\n<h4 id=\"缺点-6\"> 缺点</h4>\n<ul>\n<li>代码多</li>\n</ul>\n<h2 id=\"class-继承\"> class 继承</h2>\n<p>ES6 中，通过 <code>class</code> 关键字来定义类，子类可以通过 <code>extends</code> 继承父类。</p>\n<p>代码示例：</p>\n<div><pre><code><span>class</span> <span>Parent</span><span>{</span>\n  <span>constructor</span><span>(</span><span>name</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n    <span>this</span><span>.</span>hobbies <span>=</span> <span>[</span><span>\"sing\"</span><span>,</span> <span>\"dance\"</span><span>,</span> <span>\"rap\"</span><span>]</span><span>;</span>\n  <span>}</span>\n  <span>getHobbies</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span>hobbies<span>;</span>\n  <span>}</span>\n  <span>static</span> <span>getCurrent</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>this</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>Child</span> <span>extends</span> <span>Parent</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>name</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span>name<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>var</span> c1 <span>=</span> <span>new</span> <span>Child</span><span>(</span><span>'c1'</span><span>)</span><span>;</span>\n<span>var</span> c2 <span>=</span> <span>new</span> <span>Child</span><span>(</span><span>'c2'</span><span>)</span><span>;</span>\n\nconsole<span>.</span><span>log</span><span>(</span>c1 <span>instanceof</span> <span>Child</span><span>)</span><span>;</span>  <span>// true</span>\nconsole<span>.</span><span>log</span><span>(</span>c1 <span>instanceof</span> <span>Parent</span><span>)</span><span>;</span> <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h4 id=\"要点\"> 要点</h4>\n<ul>\n<li><code>constructor</code> 为构造函数，即使未定义也会自动创建。</li>\n<li>在父类构造函数内 <code>this</code> 定义的都是实例属性和方法，其他方法包括 <code>constructor</code>、<code>getHobbies</code> 都是原型方法。</li>\n<li><code>static</code> 关键字定义的静态方法都必须通过类名调用，其 <code>this</code> 指向调用者而并非实例。</li>\n<li>通过 <code>extends</code> 可以继承父类的所有原型属性及 <code>static</code> 类方法，子类 <code>constructor</code> 调用 <code>super</code> 父类构造函数实现实例属性和方法的继承。</li>\n</ul>\n<h4 id=\"对比\"> 对比</h4>\n<ul>\n<li>ES5 的继承，实质是先创造子类的实例对象 <code>this</code>，然后再将父类的方法添加到 <code>this</code> 上面（<code>Parent.apply(this)</code>）。</li>\n<li>ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到 <code>this</code> 上面（所以必须先调用 <code>super</code> 方法），然后再用子类的构造函数修改 <code>this</code>。</li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T07:36:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "作用域",
      "url": "https://www.fedbook.cn/frontend-knowledge/javascript/scope/",
      "id": "https://www.fedbook.cn/frontend-knowledge/javascript/scope/",
      "content_html": "<h1 id=\"作用域\"> 作用域</h1>\n<h2 id=\"作用域定义\"> 作用域定义</h2>\n<p>作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。</p>\n<p>通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。</p>\n<h2 id=\"作用域的分类\"> 作用域的分类</h2>\n<p>JavaScript 一共有三种作用域：</p>\n<ul>\n<li>全局作用域</li>\n<li>函数作用域</li>\n<li>块级作用域</li>\n</ul>\n<h3 id=\"全局作用域和函数作用域\"> 全局作用域和函数作用域</h3>\n<p>在 ES6 之前，ES 的作用域只有两种：全局作用域和函数作用域。（ES3 开始，<code>try /catch</code> 分句结构和 <code>with</code> 中也具有块作用域，这里不讨论）</p>\n<ul>\n<li><strong>全局作用域</strong> 中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。</li>\n<li><strong>函数作用域</strong> 就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。</li>\n</ul>\n<p>在 ES6 之前，JavaScript 只支持这两种作用域，相较而言，其他语言则都普遍支持<strong>块级作用域</strong>。块级作用域就是使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句，甚至单独的一个 <code>{}</code> 都可以被看作是一个块级作用域。</p>\n<p>简单来讲，<strong>如果一种语言支持块级作用域</strong>，那么其代码块内部定义的变量在代码块外部是访问不到的，并且等该代码块中的代码执行完成之后，代码块中定义的变量会被销毁。</p>\n<p>遗憾的是，JavaScript 在 ES6 之前是不支持块级作用域的。没有块级作用域，对作者当时设计 JavaScript 来说会比较简单快速，但这也直接导致了「<strong>变量提升</strong>」的问题。</p>\n<h3 id=\"块级作用域\"> 块级作用域</h3>\n<p>为了解决变量提升带来的一系列问题，ES6 引入了 <code>let</code> 和 <code>const</code> 关键字，从而<strong>使 JavaScript 也能像其他语言一样拥有块级作用域</strong>。</p>\n<p>需要注意的是，只有 <code>let</code>，<code>const</code> + 大括号（<code>{}</code>）才能构成块级作用域，否则单纯的大括号（<code>{}</code>）只是用作代码分割，让代码阅读起来更简单轻快一点，纯粹代码维护上的需求。</p>\n<p>通过 <code>let</code> 或者 <code>const</code> 声明的变量会在进入块级作用域的时候被创建，但是在该变量没有赋值之前，引用该变量 JavaScript 引擎会抛出错误，这就是「<strong>暂时性死区</strong>」。</p>\n<h2 id=\"词法作用域\"> 词法作用域</h2>\n<p><strong>词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。</strong>（标识符：在 JS 中所有可以由我们自主命名的都可以称为是标识符，例如：变量名、函数名、属性名都属于标识符）<br>\n—— 出自《你不知道的JavaScript（上）》</p>\n<h2 id=\"作用域链\"> 作用域链</h2>\n<p>作用域链也称词法作用域链，顾名思义，它跟词法作用域有关。</p>\n<p>作用域链本质上就是查找变量的链条（确定变量来自于哪里，变量是否可以访问，或者说，确定一个变量来自于哪个作用域）。</p>\n<p>查找作用域链的步骤如下：</p>\n<ul>\n<li>查看当前作用域，如果当前作用域声明了这个变量，就确定结果。</li>\n<li>查找当前作用域的上级作用域，也就是当前函数的上级函数，看看上级函数中有没有声明。</li>\n<li>再查找上级函数的上级函数，直到全局作用域为止。</li>\n<li>如果全局作用域中也没有，我们就认为这个变量未声明（抛出异常：<code>xxx is not defined</code>）。</li>\n</ul>\n<p><strong>重点：词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系</strong>。</p>\n<p>举个例子：</p>\n<div><pre><code><span>function</span> <span>innerFunction</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span>myName<span>)</span><span>;</span>\n<span>}</span>\n<span>function</span> <span>outerFunction</span><span>(</span><span>)</span> <span>{</span>\n    <span>var</span> myName <span>=</span> <span>\"函数作用域\"</span><span>;</span>\n    <span>innerFunction</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>var</span> myName <span>=</span> <span>\"全局作用域\"</span><span>;</span>\n<span>outerFunction</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>从代码中可以看出，全局执行上下文和 <code>outerFunction</code> 函数的执行上下文中都包含变量 <code>myName</code>，那 <code>innerFunction</code> 函数里面 <code>myName</code> 的值到底该选择哪个？</p>\n<p>根据上面提到的查找顺序，如下：</p>\n<ul>\n<li>查看当前作用域，<code>innerFunction</code> 函数里面不存在变量 <code>myName</code>。</li>\n<li><code>innerFunction</code> 函数中使用了外部变量，向上级查找。</li>\n<li>重点来了，由于 <code>innerFunction</code> 函数里面不存在变量 <code>myName</code> ，此时 JavaScript 引擎会去全局执行上下文中查找，而不是它的调用方 <code>outerFunction</code> 函数的执行上下文。这是因为<strong>在 JavaScript 执行过程中，其作用域链是由词法作用域决定的，而词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系</strong>。</li>\n</ul>\n<p>既然如此，根据词法作用域，<code>outerFunction</code> 和 <code>innerFunction</code> 的上级作用域都是全局作用域，所以如果这两个函数使用了一个它们没有定义的变量，那么它们会到全局作用域去查找。</p>\n<p>（完）</p>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T07:36:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "栈空间和堆空间",
      "url": "https://www.fedbook.cn/frontend-knowledge/javascript/stack-and-heap/",
      "id": "https://www.fedbook.cn/frontend-knowledge/javascript/stack-and-heap/",
      "content_html": "<h1 id=\"栈空间和堆空间\"> 栈空间和堆空间</h1>\n<h2 id=\"数据类型\"> 数据类型</h2>\n<p>目前 JavaScript 中的数据类型一共有 8 种，它们分别是：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Boolean</td>\n<td>只有 <code>true</code> 和 <code>false</code> 两个值。</td>\n</tr>\n<tr>\n<td>Null</td>\n<td>只有一个值 <code>null</code>。</td>\n</tr>\n<tr>\n<td>Undefined</td>\n<td>一个没有被赋值的变量会有个默认值 <code>undefined</code>，变量提升时的默认值也是 <code>undefined</code>。</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>根据 ECMAScript 标准，JavaScript 中只有一种数字类型。</td>\n</tr>\n<tr>\n<td>BigInt</td>\n<td>ES11 引入的一种新的数字类型，可以用任意精度表示整数。使用 BigInt，即使超出 Number 的安全整数范围限制，也可以安全地存储和操作。</td>\n</tr>\n<tr>\n<td>String</td>\n<td>用于表示文本数据。不同于类 C 语言，JavaScript 的字符串是不可更改的。</td>\n</tr>\n<tr>\n<td>Symbol</td>\n<td>ES6 引入的一种新的类型，表示唯一的并且是不可修改的，通常用来作为 Object 的 key。</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>在 JavaScript 里，对象可以被看作是一组属性的集合。</td>\n</tr>\n</tbody>\n</table>\n<p>有三个注意点：</p>\n<ul>\n<li>使用 <code>typeof</code> 检测 Null 类型时，返回的是 <code>object</code>。这是当初 JavaScript 语言的一个 Bug，一直保留至今，之所以一直没修改过来，主要是为了兼容老的代码。\n<blockquote>\n<p>在 Javascript 中二进制前三位都为 <code>0</code> 的话会被判断为 Object 类型，<code>null</code> 的二进制表示全 <code>0</code>，因此执行 <code>typeof null</code> 时返回 <code>object</code> —— 《你不知道的JavaScript（上）》</p>\n</blockquote>\n</li>\n<li>Object 是由 key-value 组成的，其中的 value 可以是任何类型，包括函数，这也就意味着你可以通过 Object 来存储函数，Object 中的函数又称为方法。</li>\n<li>前面的 7 种数据类型称为<strong>原始类型</strong>，最后一个对象类型称为<strong>引用类型</strong>，这两种不同的类型在内存中存放的位置不一样。</li>\n</ul>\n<h2 id=\"内存空间\"> 内存空间</h2>\n<p>在 JavaScript 的执行过程中，主要有三种类型内存空间，分别是<strong>代码空间</strong>、<strong>栈空间</strong>和<strong>堆空间</strong>。</p>\n<p>其中的代码空间主要是存储可执行代码的，这里主要分析栈空间和堆空间。</p>\n<h3 id=\"栈空间\"> 栈空间</h3>\n<p>栈空间就是经常说的调用栈，用来存储执行上下文。</p>\n<p>原始类型的数据值都是直接保存在栈空间中的。</p>\n<h3 id=\"堆空间\"> 堆空间</h3>\n<p>对象类型是存放在堆空间的，在栈空间中只是保留了对象的引用地址，当 JavaScript 需要访问该数据的时候，是通过栈中的引用地址来访问的。</p>\n<h2 id=\"为什么分两种空间\"> 为什么分两种空间</h2>\n<p><strong>栈空间</strong>主要用来存放一些原始类型的小数据，通常都不会设置太大，因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。</p>\n<details><summary>执行上下文的切换</summary>\n<p>例如 foo 函数执行结束了，JavaScript 引擎需要离开当前的执行上下文，只需要将指针下移到上个执行上下文的地址就可以了，foo 函数执行上下文栈区空间全部回收，如下图所示：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/switch-execution-context-state-in-the-call-stack.png\" alt=\"调用栈中切换执行上下文状态\">\n  <p style=\"text-align: center; color: #888;\">（调用栈中切换执行上下文状态，图片来源于网络）</p>\n</div>\n</details>\n<p><strong>堆空间</strong>主要用来存放引用类型的数据，这类数据占用的空间都比较大，所以堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。</p>\n<h2 id=\"不同数据类型赋值操作的区别\"> 不同数据类型赋值操作的区别</h2>\n<p>在 JavaScript 中，原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。</p>\n<p>例如下面代码：</p>\n<div><pre><code><span>function</span> <span>foo</span><span>(</span><span>)</span><span>{</span>\n  <span>var</span> a <span>=</span> <span>\"极客时间\"</span>\n  <span>var</span> b <span>=</span> a\n  <span>var</span> c <span>=</span> <span>{</span>name<span>:</span><span>\"极客时间\"</span><span>}</span>\n  <span>var</span> d <span>=</span> c\n<span>}</span>\n<span>foo</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>在该代码的执行过程中，变量 a 和变量 b 的值都是存放在栈中的，变量 c 和变量 d 都指向了同一个堆中的对象（因此会有一个变另一个跟着变的现象）。</p>\n<p>其内存示意图如下图所示：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/memory-allocation.png\" alt=\"内存示意图\" style=\"width: 600px;\">\n  <p style=\"text-align: center; color: #888;\">（内存示意图，图片来源于网络）</p>\n</div>\n<p>（完）</p>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T07:36:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "浅克隆与深克隆",
      "url": "https://www.fedbook.cn/frontend-knowledge/javascript/shallow-clone-and-deep-clone/",
      "id": "https://www.fedbook.cn/frontend-knowledge/javascript/shallow-clone-and-deep-clone/",
      "content_html": "<h1 id=\"浅克隆与深克隆\"> 浅克隆与深克隆</h1>\n<h2 id=\"前言\"> 前言</h2>\n<p><strong>浅克隆</strong>：浅克隆只是拷贝基本类型数据。对于引用类型数据，是将栈内存中的引用复制一份，赋给一个新的变量，本质上两个指向堆内存中的同一地址，内容也相同，其中一个变化另一个内容也会变化。</p>\n<p><strong>深克隆</strong>：就是创建一个新的空对象，开辟一块内存，然后将原对象中的数据全部复制过去，完全切断两个对象间的联系。新对象跟原对象不共享内存，修改新对象不会改到原对象。</p>\n<p><strong>区别</strong>：浅克隆和深克隆最大的区别就是对引用值的处理了，即浅克隆之后<strong>你改我也改</strong>，深克隆之后<strong>你改我不改</strong>。</p>\n<p><strong>基本类型数据</strong>：保存在栈（stack）内存。</p>\n<p><strong>引用类型数据</strong>：保存在堆（heap）内存。</p>\n<h2 id=\"浅克隆概念\"> 浅克隆概念</h2>\n<p>在浅克隆中，原始值的克隆没问题，只是值的拷贝，不会出现你改我改的问题。但是引用值的克隆，就会出现你改我也改的问题，因为浅层克隆的是地址，即指向的是同一空间。</p>\n<p><a href=\"/handwritten/javascript/实现浅克隆-shallow-clone/\">手写实现浅克隆</a></p>\n<h2 id=\"深克隆概念\"> 深克隆概念</h2>\n<p>进行深克隆之后，对于引用值的克隆问题就能解决了，因为在深克隆之后，值各自独立，互不影响。</p>\n<p><a href=\"/handwritten/javascript/实现深克隆-deep-clone/\">手写实现深克隆</a></p>\n<h2 id=\"应用实例\"> 应用实例</h2>\n<h3 id=\"浅克隆方法\"> 浅克隆方法</h3>\n<ul>\n<li>\n<p>直接赋值</p>\n</li>\n<li>\n<p>手写（只拷贝对象或数组的第一层内容）</p>\n</li>\n<li>\n<p>数组的 <code>Array.concat()</code>：</p>\n</li>\n</ul>\n<div><pre><code><span>let</span> oldArr <span>=</span> <span>[</span><span>'one'</span><span>,</span> <span>'two'</span><span>,</span> <span>'three'</span><span>]</span><span>;</span>\n<span>let</span> newArr <span>=</span> oldArr<span>.</span><span>concat</span><span>(</span><span>)</span><span>;</span>\nnewArr<span>.</span><span>push</span><span>(</span><span>'four'</span><span>)</span><span>;</span>\n\nconsole<span>.</span><span>log</span><span>(</span>oldArr<span>)</span><span>;</span> <span>// [\"one\", \"two\", \"three\"]</span>\nconsole<span>.</span><span>log</span><span>(</span>newArr<span>)</span><span>;</span> <span>// [\"one\", \"two\", \"three\", \"four\"]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>\n<li>数组的 <code>Array.slice()</code>：</li>\n</ul>\n<div><pre><code><span>let</span> oldArr <span>=</span> <span>[</span><span>'one'</span><span>,</span> <span>'two'</span><span>,</span> <span>'three'</span><span>]</span><span>;</span>\n<span>let</span> newArr <span>=</span> oldArr<span>.</span><span>slice</span><span>(</span><span>)</span><span>;</span>\nnewArr<span>.</span><span>push</span><span>(</span><span>'four'</span><span>)</span><span>;</span>\n\nconsole<span>.</span><span>log</span><span>(</span>oldArr<span>)</span><span>;</span> <span>// [\"one\", \"two\", \"three\"]</span>\nconsole<span>.</span><span>log</span><span>(</span>newArr<span>)</span><span>;</span> <span>// [\"one\", \"two\", \"three\", \"four\"]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>\n<li>对象的 <code>Object.assign()</code>：</li>\n</ul>\n<div><pre><code><span>let</span> oldObj <span>=</span> <span>{</span>\n  a<span>:</span> <span>'one'</span><span>,</span>\n  b<span>:</span> <span>'two'</span><span>,</span>\n  c<span>:</span> <span>'three'</span>\n<span>}</span><span>;</span>\n\n<span>let</span> newObj <span>=</span> Object<span>.</span><span>assign</span><span>(</span><span>{</span><span>}</span><span>,</span> oldObj<span>)</span><span>;</span>\nnewObj<span>.</span>d <span>=</span> <span>'four'</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>oldObj<span>)</span><span>;</span> <span>// {a: \"one\", b: \"two\", c: \"three\"}</span>\nconsole<span>.</span><span>log</span><span>(</span>newObj<span>)</span><span>;</span> <span>// {a: \"one\", b: \"two\", c: \"three\", d: \"four\"}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ul>\n<li>数组和对象的解构赋值：</li>\n</ul>\n<div><pre><code><span>let</span> oldObj <span>=</span> <span>{</span>\n  a<span>:</span> <span>'one'</span><span>,</span>\n  b<span>:</span> <span>'two'</span><span>,</span>\n  c<span>:</span> <span>'three'</span>\n<span>}</span><span>;</span>\n\n<span>let</span> newObj <span>=</span> <span>{</span><span>...</span>oldObj<span>}</span><span>;</span>\nnewObj<span>.</span>d <span>=</span> <span>'four'</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>oldObj<span>)</span><span>;</span> <span>// {a: \"one\", b: \"two\", c: \"three\"}</span>\nconsole<span>.</span><span>log</span><span>(</span>newObj<span>)</span><span>;</span> <span>// {a: \"one\", b: \"two\", c: \"three\", d: \"four\"}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"深克隆方法\"> 深克隆方法</h3>\n<ul>\n<li>\n<p>手写（层层拷贝对象或数组的每一层内容）</p>\n</li>\n<li>\n<p>将数组和对象转成 JSON 字符串再转回来（<code>JSON.parse(JSON.stringify())</code>）：</p>\n<ul>\n<li><code>JSON.stringify() 的局限性</code>：对于 RegExp 类型和 Function 类型无法完全满足，而且不支持有循环引用的对象。(<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#%E6%8F%8F%E8%BF%B0\" target=\"_blank\" rel=\"noopener noreferrer\">MDN</a>)</li>\n</ul>\n</li>\n</ul>\n<div><pre><code><span>let</span> oldObj <span>=</span> <span>{</span>\n  a<span>:</span> <span>'one'</span><span>,</span>\n  b<span>:</span> <span>{</span> bb<span>:</span> <span>{</span> bbb<span>:</span> <span>'two'</span> <span>}</span><span>}</span><span>,</span>\n  c<span>:</span> <span>[</span><span>'three'</span><span>]</span>\n<span>}</span><span>;</span>\n\n<span>let</span> newObj <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>oldObj<span>)</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>oldObj<span>.</span>b<span>.</span>bb <span>===</span> newObj<span>.</span>b<span>.</span>bb<span>)</span><span>;</span> <span>// false</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ul>\n<li>jQuery 有提供一个 <code>$.extend</code> 可以用来做深克隆：</li>\n</ul>\n<div><pre><code><span>let</span> $ <span>=</span> <span>require</span><span>(</span><span>'jquery'</span><span>)</span><span>;</span>\n<span>let</span> oldObj <span>=</span> <span>{</span>\n  a<span>:</span> <span>'one'</span><span>,</span>\n  b<span>:</span> <span>{</span> bb<span>:</span> <span>{</span> bbb<span>:</span> <span>'two'</span> <span>}</span><span>}</span><span>,</span>\n  c<span>:</span> <span>[</span><span>'three'</span><span>]</span>\n<span>}</span><span>;</span>\n\n<span>let</span> newObj <span>=</span> $<span>.</span><span>extend</span><span>(</span><span>true</span><span>,</span> <span>{</span><span>}</span><span>,</span> oldObj<span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>oldObj<span>.</span>b<span>.</span>bb <span>===</span> newObj<span>.</span>b<span>.</span>bb<span>)</span><span>;</span> <span>// false</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ul>\n<li>函数库 Lodash，有提供 <code>_.cloneDeep</code> 用来做深克隆：</li>\n</ul>\n<div><pre><code><span>let</span> _ <span>=</span> <span>require</span><span>(</span><span>'lodash'</span><span>)</span><span>;</span>\n<span>let</span> oldObj <span>=</span> <span>{</span>\n  a<span>:</span> <span>'one'</span><span>,</span>\n  b<span>:</span> <span>{</span> bb<span>:</span> <span>{</span> bbb<span>:</span> <span>'two'</span> <span>}</span><span>}</span><span>,</span>\n  c<span>:</span> <span>[</span><span>'three'</span><span>]</span>\n<span>}</span><span>;</span>\n\n<span>let</span> newObj <span>=</span> _<span>.</span><span>cloneDeep</span><span>(</span>oldObj<span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>oldObj<span>.</span>b<span>.</span>bb <span>===</span> newObj<span>.</span>b<span>.</span>bb<span>)</span><span>;</span> <span>// false</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>（完）</p>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T07:36:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "原型与原型链",
      "url": "https://www.fedbook.cn/frontend-knowledge/javascript/prototype-and-prototype-chain/",
      "id": "https://www.fedbook.cn/frontend-knowledge/javascript/prototype-and-prototype-chain/",
      "content_html": "<h1 id=\"原型与原型链\"> 原型与原型链</h1>\n<h2 id=\"前言\"> 前言</h2>\n<p>网上有句话：JavaScript 中万物皆对象，对象皆出自构造函数（这里的万物主要指引用类型）。</p>\n<p>比如下面代码：</p>\n<div><pre><code><span>function</span> <span>Foo</span><span>(</span><span>)</span> <span>{</span>\n\n<span>}</span>\n<span>var</span> foo <span>=</span> <span>new</span> <span>Foo</span><span>(</span><span>)</span><span>;</span>\nfoo<span>.</span>name <span>=</span> <span>'hello'</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>person<span>.</span>name<span>)</span> <span>// hello</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>在这个例子中，<code>Foo</code> 就是一个构造函数，我们使用 <code>new</code> 创建了一个实例对象 <code>foo</code>。</p>\n<h2 id=\"函数对象和普通对象\"> 函数对象和普通对象</h2>\n<p>在 ES6 以前没有 class 关键字，所以 JavaScript 用函数来模拟的类实现，也就是函数对象。因此 JavaScript 的对象分为函数对象和普通对象。</p>\n<div><pre><code><span>// 函数对象: typeof 打印出来是 function</span>\nObject\nFunction\n<span>function</span> <span>fun1</span><span>(</span><span>)</span><span>{</span><span>}</span><span>;</span>\n<span>const</span> <span>fun2</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span><span>}</span><span>;</span>\n<span>const</span> fun3 <span>=</span> <span>new</span> <span>Function</span><span>(</span><span>'name'</span><span>,</span><span>'console.log(name)'</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code><span>// 普通对象: typeof 打印出来是 object</span>\n<span>const</span> obj1 <span>=</span> <span>{</span><span>}</span><span>;</span>\n<span>const</span> obj2 <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>\n<span>const</span> obj3 <span>=</span> <span>new</span> <span>fun1</span><span>(</span><span>)</span><span>;</span>\n<span>const</span> obj4 <span>=</span> <span>new</span> <span>new</span> <span>Function</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"三大属性\"> 三大属性</h2>\n<ul>\n<li>\n<p>对象独有的属性：</p>\n<ul>\n<li><code>__proto__</code></li>\n<li><code>constructor</code></li>\n</ul>\n</li>\n<li>\n<p>函数独有的属性（函数也是对象）：</p>\n<ul>\n<li><code>prototype</code></li>\n<li><code>__proto__</code></li>\n<li><code>constructor</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"prototype\"> <code>prototype</code></h3>\n<p>又称显式原型，每个函数在创建之后都会拥有一个 <code>prototype</code> 属性，它指向函数的原型对象（又称：它指向以当前函数作为构造函数构造出来的对象的原型对象）。</p>\n<div style=\"text-align: center;\">\n  <svg id=\"SvgjsSvg1034\" width=\"496\" height=\"130.5\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><defs id=\"SvgjsDefs1035\"><marker id=\"SvgjsMarker1054\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1055\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker></defs><g id=\"SvgjsG1036\" transform=\"translate(25,64.5)\"><path id=\"SvgjsPath1037\" d=\"M 0 0L 100 0L 100 41L 0 41Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1038\"><text id=\"SvgjsText1039\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"100px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"-1.5\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1040\" dy=\"20\" x=\"50\"><tspan id=\"SvgjsTspan1041\" style=\"text-decoration:;\">Foo</tspan></tspan><tspan id=\"SvgjsTspan1042\" dy=\"20\" x=\"50\"><tspan id=\"SvgjsTspan1043\" style=\"text-decoration:;\">（构造函数）</tspan></tspan></text></g></g><g id=\"SvgjsG1044\" transform=\"translate(292,64.5)\"><path id=\"SvgjsPath1045\" d=\"M 0 0L 179 0L 179 41L 0 41Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1046\"><text id=\"SvgjsText1047\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"179px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"-1.5\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1048\" dy=\"20\" x=\"89.5\"><tspan id=\"SvgjsTspan1049\" style=\"text-decoration:;\">Foo.prototype</tspan></tspan><tspan id=\"SvgjsTspan1050\" dy=\"20\" x=\"89.5\"><tspan id=\"SvgjsTspan1051\" style=\"text-decoration:;\">（构造函数的原型对象）</tspan></tspan></text></g></g><g id=\"SvgjsG1052\"><path id=\"SvgjsPath1053\" d=\"M125.92247253012533 84.6139372704285C 192 56 222 55 288.6726069710271 83.6257890879699\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1054)\"></path></g><g id=\"SvgjsG1056\" transform=\"translate(147.5,25)\"><path id=\"SvgjsPath1057\" d=\"M 0 0L 120 0L 120 41L 0 41Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1058\"><text id=\"SvgjsText1059\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"120px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"9.75\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1060\" dy=\"17\" x=\"60\"><tspan id=\"SvgjsTspan1061\" style=\"text-decoration:;\">prototype</tspan></tspan></text></g></g></svg>\n  <p style=\"text-align: center; color: #888;\">（prototype 指向函数的原型对象）</p>\n</div>\n<p>作用：给其它对象提供共享属性，用来实现基于原型的继承与属性的共享。</p>\n<p>ECMAScript 规范约定了访问和操作 <code>prototype</code> 属性的 API：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf\" target=\"_blank\" rel=\"noopener noreferrer\">Object.getPrototypeOf(obj)</a>：可以返回指定对象的 <code>prototype</code> 对象。</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf\" target=\"_blank\" rel=\"noopener noreferrer\">Object.setPrototypeOf(obj, anotherObj)</a>：可以设置指定对象的 <code>prototype</code> 对象。</li>\n</ul>\n<h3 id=\"proto\"> <code>__proto__</code></h3>\n<p>又称隐式原型，是每个对象（除了 <code>null</code>）都具有的属性，它指向该对象的原型。</p>\n<div style=\"text-align: center;\">\n  <svg id=\"SvgjsSvg1114\" width=\"497.5\" height=\"235\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><defs id=\"SvgjsDefs1115\"><marker id=\"SvgjsMarker1136\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1137\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1154\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1155\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1164\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1165\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker></defs><g id=\"SvgjsG1116\" transform=\"translate(25,67)\"><path id=\"SvgjsPath1117\" d=\"M 0 0L 100 0L 100 42L 0 42Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1118\"><text id=\"SvgjsText1119\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"100px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"-1\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1120\" dy=\"20\" x=\"50\"><tspan id=\"SvgjsTspan1121\" style=\"text-decoration:;\">Foo</tspan></tspan><tspan id=\"SvgjsTspan1122\" dy=\"20\" x=\"50\"><tspan id=\"SvgjsTspan1123\" style=\"text-decoration:;\">（构造函数）</tspan></tspan></text></g></g><g id=\"SvgjsG1124\" transform=\"translate(294.5,55)\"><path id=\"SvgjsPath1125\" d=\"M 0 0L 178.5 0L 178.5 66L 0 66Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1126\"><text id=\"SvgjsText1127\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"179px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"1\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1128\" dy=\"20\" x=\"89.5\"><tspan id=\"SvgjsTspan1129\" style=\"text-decoration:;\">Foo.prototype</tspan></tspan><tspan id=\"SvgjsTspan1130\" dy=\"20\" x=\"89.5\"><tspan id=\"SvgjsTspan1131\" style=\"text-decoration:;\">（构造函数的原型对象、</tspan></tspan><tspan id=\"SvgjsTspan1132\" dy=\"20\" x=\"89.5\"><tspan id=\"SvgjsTspan1133\" style=\"text-decoration:;font-size: inherit;\">实例的原型）</tspan></tspan></text></g></g><g id=\"SvgjsG1134\"><path id=\"SvgjsPath1135\" d=\"M125.90840661856316 87.58191219181779C 187 58 232 56 291.2580309350393 86.43486850972903\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1136)\"></path></g><g id=\"SvgjsG1138\" transform=\"translate(149.75,25)\"><path id=\"SvgjsPath1139\" d=\"M 0 0L 120 0L 120 42L 0 42Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1140\"><text id=\"SvgjsText1141\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"120px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"10.25\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1142\" dy=\"17\" x=\"60\"><tspan id=\"SvgjsTspan1143\" style=\"text-decoration:;\">prototype</tspan></tspan></text></g></g><g id=\"SvgjsG1144\" transform=\"translate(25,168)\"><path id=\"SvgjsPath1145\" d=\"M 0 0L 100 0L 100 42L 0 42Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1146\"><text id=\"SvgjsText1147\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"100px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"-1\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1148\" dy=\"20\" x=\"50\"><tspan id=\"SvgjsTspan1149\" style=\"text-decoration:;\">foo</tspan></tspan><tspan id=\"SvgjsTspan1150\" dy=\"20\" x=\"50\"><tspan id=\"SvgjsTspan1151\" style=\"text-decoration:;\">（实例对象）</tspan></tspan></text></g></g><g id=\"SvgjsG1152\"><path id=\"SvgjsPath1153\" d=\"M75 110L75 164.39999999999998\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1154)\"></path></g><g id=\"SvgjsG1156\" transform=\"translate(149.75,153)\"><path id=\"SvgjsPath1157\" d=\"M 0 0L 120 0L 120 42L 0 42Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1158\"><text id=\"SvgjsText1159\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"120px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"10.25\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1160\" dy=\"17\" x=\"60\"><tspan id=\"SvgjsTspan1161\" style=\"text-decoration:;\">__proto__</tspan></tspan></text></g></g><g id=\"SvgjsG1162\"><path id=\"SvgjsPath1163\" d=\"M125.9999922331748 189.00394126757556C 232.01443827820617 189 363 200 382.5873258109997 124.40707920809487\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1164)\"></path></g></svg>\n  <p style=\"text-align: center; color: #888;\">（__proto__ 指向对象的原型）</p>\n</div>\n<div><pre><code><span>// 实例对象的 __proto__  = 实例对象的构造函数的 prototype</span>\nfoo<span>.</span>__proto__ <span>===</span> <span>Foo</span><span>.</span>prototype<span>;</span>      <span>// true</span>\n\n<span>// 构造函数(也是个对象)的 __proto__ = Function 的 prototype</span>\nFoo<span>.</span>__proto__ <span>===</span> <span>Function</span><span>.</span>prototype<span>;</span> <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>为什么叫隐式原型呢？因为这个 <code>__proto__</code> 是一个隐藏的属性，它只是开发者工具方便开发者查看原型而故意渲染出来的一个虚拟节点，实则并不存在于该对象上。这其实是一个历史问题，当时一些浏览器私自实现了<code>__proto__</code> 这个属性（后被 ES5 纳入规范），使得可以通过 <code>obj.__proto__</code> 来访问对象的原型。</p>\n<p>特点：</p>\n<ul>\n<li><code>__proto__</code> 属性既不能被 <code>for in</code> 遍历出来，也不能被 <code>Object.keys(obj)</code> 查找出来。</li>\n<li>访问对象的 <code>obj.__proto__</code> 属性，默认走的是 <code>Object.prototype</code> 对象上 <code>__proto__</code> 属性的 get/set 方法。</li>\n</ul>\n<div><pre><code>Object<span>.</span><span>defineProperty</span><span>(</span><span>Object</span><span>.</span>prototype<span>,</span> <span>'__proto__'</span><span>,</span> <span>{</span>\n  <span>get</span><span>(</span><span>)</span><span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'get'</span><span>)</span>\n  <span>}</span>\n<span>}</span><span>)</span><span>;</span>\n\n<span>(</span><span>{</span><span>}</span><span>)</span><span>.</span>__proto__<span>;</span>\nconsole<span>.</span><span>log</span><span>(</span><span>(</span><span>new</span> <span>Object</span><span>(</span><span>)</span><span>)</span><span>.</span>__proto__<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>作用：<code>__proto__</code> 的本质是一个对象指向另一个对象（可以理解为父类对象），有了它，当访问一个对象属性的时候，如果该对象内部不存在这个属性，那么就会去它的 <code>__proto__</code> 所指向的对象（父类对象）上查找，如此一层层往上查找，直到找到 <code>null</code>。所以可以说，<code>__proto__</code> 构成了<strong>原型链</strong>，同样用于实现基于原型的继承。</p>\n<div><p>提示</p>\n<p>有时候还会看到一个 <code>[[prototype]]</code>，它和 <code>__proto__</code> 意义相同，均表示对象的内部属性，其值指向对象原型。前者在一些书籍、规范中表示一个对象的原型属性，默认情况下是不可以再被外部访问的，估计是会被一些内部方法使用的，例如用 <code>for in</code> 来遍历原型链上可以被枚举的属性的时候，就需要通过这个指针找到当前对象所继承的对象；后者则是在浏览器实现中支持的一个属性，用于指向对象的原型。</p>\n</div>\n<h3 id=\"constructor\"> <code>constructor</code></h3>\n<p>每个原型对象都有一个 <code>constructor</code> 属性指向关联的构造函数。</p>\n<div style=\"text-align: center;\">\n  <svg id=\"SvgjsSvg1166\" width=\"497.5\" height=\"255\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><defs id=\"SvgjsDefs1167\"><marker id=\"SvgjsMarker1188\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1189\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1206\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1207\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1216\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1217\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1220\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1221\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker></defs><g id=\"SvgjsG1168\" transform=\"translate(25,67)\"><path id=\"SvgjsPath1169\" d=\"M 0 0L 100 0L 100 42L 0 42Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1170\"><text id=\"SvgjsText1171\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"100px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"-1\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1172\" dy=\"20\" x=\"50\"><tspan id=\"SvgjsTspan1173\" style=\"text-decoration:;\">Foo</tspan></tspan><tspan id=\"SvgjsTspan1174\" dy=\"20\" x=\"50\"><tspan id=\"SvgjsTspan1175\" style=\"text-decoration:;\">（构造函数）</tspan></tspan></text></g></g><g id=\"SvgjsG1176\" transform=\"translate(294.5,55)\"><path id=\"SvgjsPath1177\" d=\"M 0 0L 178.5 0L 178.5 66L 0 66Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1178\"><text id=\"SvgjsText1179\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"179px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"1\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1180\" dy=\"20\" x=\"89.5\"><tspan id=\"SvgjsTspan1181\" style=\"text-decoration:;\">Foo.prototype</tspan></tspan><tspan id=\"SvgjsTspan1182\" dy=\"20\" x=\"89.5\"><tspan id=\"SvgjsTspan1183\" style=\"text-decoration:;\">（构造函数的原型对象、</tspan></tspan><tspan id=\"SvgjsTspan1184\" dy=\"20\" x=\"89.5\"><tspan id=\"SvgjsTspan1185\" style=\"text-decoration:;font-size: inherit;\">实例的原型）</tspan></tspan></text></g></g><g id=\"SvgjsG1186\"><path id=\"SvgjsPath1187\" d=\"M125.90840661856316 87.58191219181779C 187 58 232 56 291.2580309350393 86.43486850972903\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1188)\"></path></g><g id=\"SvgjsG1190\" transform=\"translate(149.75,25)\"><path id=\"SvgjsPath1191\" d=\"M 0 0L 120 0L 120 42L 0 42Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1192\"><text id=\"SvgjsText1193\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"120px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"10.25\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1194\" dy=\"17\" x=\"60\"><tspan id=\"SvgjsTspan1195\" style=\"text-decoration:;\">prototype</tspan></tspan></text></g></g><g id=\"SvgjsG1196\" transform=\"translate(25,188)\"><path id=\"SvgjsPath1197\" d=\"M 0 0L 100 0L 100 42L 0 42Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1198\"><text id=\"SvgjsText1199\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"100px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"-1\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1200\" dy=\"20\" x=\"50\"><tspan id=\"SvgjsTspan1201\" style=\"text-decoration:;\">foo</tspan></tspan><tspan id=\"SvgjsTspan1202\" dy=\"20\" x=\"50\"><tspan id=\"SvgjsTspan1203\" style=\"text-decoration:;\">（实例对象）</tspan></tspan></text></g></g><g id=\"SvgjsG1204\"><path id=\"SvgjsPath1205\" d=\"M75 110L75 184.39999999999998\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1206)\"></path></g><g id=\"SvgjsG1208\" transform=\"translate(149.75,173)\"><path id=\"SvgjsPath1209\" d=\"M 0 0L 120 0L 120 42L 0 42Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1210\"><text id=\"SvgjsText1211\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"120px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"10.25\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1212\" dy=\"17\" x=\"60\"><tspan id=\"SvgjsTspan1213\" style=\"text-decoration:;\">__proto__</tspan></tspan></text></g></g><g id=\"SvgjsG1214\"><path id=\"SvgjsPath1215\" d=\"M125.99998846679 209.00480273745103C 234.32195570881447 209 375 223 383.2199569322993 124.56076597748046\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1216)\"></path></g><g id=\"SvgjsG1218\"><path id=\"SvgjsPath1219\" d=\"M293 100C 242 126 177 128 126.28799558594005 101.5401283852448\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1220)\"></path></g><g id=\"SvgjsG1222\" transform=\"translate(149.75,117)\"><path id=\"SvgjsPath1223\" d=\"M 0 0L 120 0L 120 42L 0 42Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1224\"><text id=\"SvgjsText1225\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"120px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"10.25\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1226\" dy=\"17\" x=\"60\"><tspan id=\"SvgjsTspan1227\" style=\"text-decoration:;\">constructor</tspan></tspan></text></g></g></svg>\n  <p style=\"text-align: center; color: #888;\">（原型对象的 constructor 指向构造函数）</p>\n</div>\n<div><pre><code><span>// 原型对象的 constructor 指向关联的构造函数</span>\n<span>Foo</span><span>.</span>prototype<span>.</span>constructor <span>===</span> Foo<span>;</span>                <span>// true</span>\n<span>// ES5 提供的 API</span>\nObject<span>.</span><span>getPrototypeOf</span><span>(</span>foo<span>)</span> <span>===</span> <span>Foo</span><span>.</span>prototype<span>;</span>     <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>换言之：只有原型对象（prototype 对象）才有这个属性。但对于通过函数创建的实例对象，虽然没有这个属性，也能通过 <code>__proto__</code> 获取原型对象然后间接找到这个属性。</p>\n<div><pre><code><span>// 通过 __proto__ 获取原型对象, 然后间接找到它的构造函数</span>\nfoo<span>.</span><span>__proto__</span><span>.</span>constructor <span>===</span> <span>Foo</span><span>.</span>prototype<span>.</span>constructor<span>;</span> <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>所以任何对象最终都可以找到其对应的构造函数。</p>\n<h2 id=\"理清错综复杂的关系\"> 理清错综复杂的关系</h2>\n<h3 id=\"区分-proto-和-prototype\"> 区分：<code>__proto__</code> 和 <code>prototype</code></h3>\n<ul>\n<li><code>__proto__</code> 指向的是当前对象（实例对象、函数对象）的原型对象。</li>\n<li><code>prototype</code> 指向以当前函数作为构造函数构造出来的对象的原型对象。</li>\n</ul>\n<div><p>重要结论</p>\n<p><strong>实例的 <code>__proto__</code> = 它的构造函数的 <code>prototype</code></strong>。</p>\n</div>\n<p>基于这个结论，可以推导出几个公式：</p>\n<ul>\n<li>如果 <code>__proto__</code> 作用在实例对象上，<code>prototype</code> 作用在该实例对象的构造函数上，那么得到的结果是一个东西：</li>\n</ul>\n<div><pre><code>foo<span>.</span>__proto__ <span>===</span> <span>Foo</span><span>.</span>prototype<span>;</span>            <span>// true</span>\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li>如果 <code>__proto__</code> 作用在构造函数上，那么：</li>\n</ul>\n<div><pre><code><span>// JS 中所有函数都是 Function 的实例(函数也是对象 => 可以看成实例对象), 此时又回归了上一条公式</span>\nFoo<span>.</span>__proto__ <span>===</span> <span>Function</span><span>.</span>prototype<span>;</span>       <span>// true</span>\n\n<span>// 由此可以类推内置函数, 因为它们也是由 Function 构造出来的</span>\nObject<span>.</span>__proto__ <span>===</span> <span>Function</span><span>.</span>prototype<span>;</span>    <span>// true</span>\nNumber<span>.</span>__proto__ <span>===</span> <span>Function</span><span>.</span>prototype<span>;</span>    <span>// true</span>\nBoolean<span>.</span>__proto__ <span>===</span> <span>Function</span><span>.</span>prototype<span>;</span>   <span>// true</span>\nString<span>.</span>__proto__ <span>===</span> <span>Function</span><span>.</span>prototype<span>;</span>    <span>// true</span>\nArray<span>.</span>__proto__ <span>===</span> <span>Function</span><span>.</span>prototype<span>;</span>     <span>// true</span>\nRegExp<span>.</span>__proto__ <span>===</span> <span>Function</span><span>.</span>prototype<span>;</span>    <span>// true</span>\nError<span>.</span>__proto__ <span>===</span> <span>Function</span><span>.</span>prototype<span>;</span>     <span>// true</span>\nDate<span>.</span>__proto__ <span>===</span> <span>Function</span><span>.</span>prototype<span>;</span>      <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><ul>\n<li><code>Function</code> 是老祖宗，它是它自己的构造函数：</li>\n</ul>\n<div><pre><code>Function<span>.</span>__proto__ <span>===</span> <span>Function</span><span>.</span>prototype<span>;</span>  <span>// true</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"区分-object-和-function\"> 区分：Object 和 Function</h3>\n<p><code>Function</code> 和 <code>Object</code> 都是构造函数，构造函数都有 <code>prototype</code>。</p>\n<p>所以它们的关系就比较绕了，但是只要记住几个最根本的结论，一切就可以慢慢推导了：</p>\n<ul>\n<li>JS 中所有函数都是 <code>Function</code> 的实例，所以：</li>\n</ul>\n<div><pre><code><span>// JS 中所有函数都是 Function 的实例 (重要的结论 again)</span>\n<span>// 实例的 __proto__ = 它的构造函数的 prototype (重要的结论 again)</span>\nObject<span>.</span>__proto__ <span>===</span> <span>Function</span><span>.</span>prototype<span>;</span>         <span>// true</span>\nFunction<span>.</span>__proto__ <span>===</span> <span>Function</span><span>.</span>prototype<span>;</span>       <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>\n<li>万物皆对象，原型对象也是对象，对象的构造函数是 <code>Object</code>，所以：</li>\n</ul>\n<div><pre><code><span>// 构造函数的原型对象 => 是个对象 => 是 Object 构造函数的实例对象</span>\n<span>// 实例的 __proto__ = 它的构造函数的 prototype (重要的结论 again)</span>\n<span>Foo</span><span>.</span>prototype<span>.</span>__proto__<span>==</span><span>Object</span><span>.</span>prototype<span>;</span>        <span>// true</span>\n\n<span>// 由此可以类推内置函数, 因为它们的原型对象的构造函数都是 Object</span>\n<span>Function</span><span>.</span>prototype<span>.</span>__proto__<span>==</span><span>Object</span><span>.</span>prototype<span>;</span>   <span>// true</span>\n<span>Object</span><span>.</span>prototype<span>.</span>__proto__ <span>===</span> <span>Object</span><span>.</span>prototype<span>;</span>  <span>// true</span>\n<span>Number</span><span>.</span>prototype<span>.</span>__proto__ <span>===</span> <span>Object</span><span>.</span>prototype<span>;</span>  <span>// true</span>\n<span>Boolean</span><span>.</span>prototype<span>.</span>__proto__ <span>===</span> <span>Object</span><span>.</span>prototype<span>;</span> <span>// true</span>\n<span>String</span><span>.</span>prototype<span>.</span>__proto__ <span>===</span> <span>Object</span><span>.</span>prototype<span>;</span>  <span>// true</span>\n<span>Array</span><span>.</span>prototype<span>.</span>__proto__ <span>===</span> <span>Object</span><span>.</span>prototype<span>;</span>   <span>// true</span>\n<span>RegExp</span><span>.</span>prototype<span>.</span>__proto__ <span>===</span> <span>Object</span><span>.</span>prototype<span>;</span>  <span>// true</span>\n<span>Error</span><span>.</span>prototype<span>.</span>__proto__ <span>===</span> <span>Object</span><span>.</span>prototype<span>;</span>   <span>// true</span>\n<span>Date</span><span>.</span>prototype<span>.</span>__proto__ <span>===</span> <span>Object</span><span>.</span>prototype<span>;</span>    <span>// true</span>\n\n<span>// Object.prototype 是所有对象的顶层</span>\n<span>// 或者说 Object.prototype 没有原型，原型链的尽头是 null</span>\n<span>Object</span><span>.</span>prototype<span>.</span>__proto__ <span>===</span> <span>null</span><span>;</span>              <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id=\"原型链\"> 原型链</h2>\n<p>原型链是 JavaScript 作者为了继承而设计的，简单理解就是从实例对象开始，通过 <code>__proto__</code> 链接子父类对象，一层层查找对象自身拥有或继承的属性和方法，直到找到 <code>null</code>。</p>\n<p>整个查找的过程就像产生了一个链条，如下图所示:</p>\n<div style=\"text-align: center;\">\n  <svg id=\"SvgjsSvg1006\" width=\"208.5\" height=\"392.4375\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><defs id=\"SvgjsDefs1007\"><marker id=\"SvgjsMarker1022\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1023\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1038\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1039\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1054\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1055\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker></defs><g id=\"SvgjsG1008\" transform=\"translate(25,25)\"><path id=\"SvgjsPath1009\" d=\"M 0 0L 138 0L 138 30L 0 30Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1010\"><text id=\"SvgjsText1011\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"138px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"3\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1012\" dy=\"20\" x=\"69\"><tspan id=\"SvgjsTspan1013\" style=\"text-decoration:;\">foo</tspan></tspan></text></g></g><g id=\"SvgjsG1014\" transform=\"translate(25,129.3125)\"><path id=\"SvgjsPath1015\" d=\"M 0 0L 138 0L 138 30L 0 30Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1016\"><text id=\"SvgjsText1017\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"138px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"3\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1018\" dy=\"20\" x=\"69\"><tspan id=\"SvgjsTspan1019\" style=\"text-decoration:;\">Foo.prototype</tspan></tspan></text></g></g><g id=\"SvgjsG1020\"><path id=\"SvgjsPath1021\" d=\"M94 56L94 92.15625L94 92.15625L94 125.7125\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1022)\"></path></g><g id=\"SvgjsG1024\" transform=\"translate(108.5,72.75)\"><path id=\"SvgjsPath1025\" d=\"M 0 0L 75 0L 75 21L 0 21Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1026\"><text id=\"SvgjsText1027\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"75px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"-0.25\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1028\" dy=\"17\" x=\"37.5\"><tspan id=\"SvgjsTspan1029\" style=\"text-decoration:;\">__proto__</tspan></tspan></text></g></g><g id=\"SvgjsG1030\" transform=\"translate(25,233.125)\"><path id=\"SvgjsPath1031\" d=\"M 0 0L 138 0L 138 30L 0 30Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1032\"><text id=\"SvgjsText1033\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"138px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"3\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1034\" dy=\"20\" x=\"69\"><tspan id=\"SvgjsTspan1035\" style=\"text-decoration:;\">Object.prototype</tspan></tspan></text></g></g><g id=\"SvgjsG1036\"><path id=\"SvgjsPath1037\" d=\"M94 160.3125L94 195.96875L94 195.96875L94 229.52499999999998\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1038)\"></path></g><g id=\"SvgjsG1040\" transform=\"translate(108.5,178.25)\"><path id=\"SvgjsPath1041\" d=\"M 0 0L 75 0L 75 21L 0 21Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1042\"><text id=\"SvgjsText1043\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"75px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"-0.25\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1044\" dy=\"17\" x=\"37.5\"><tspan id=\"SvgjsTspan1045\" style=\"text-decoration:;\">__proto__</tspan></tspan></text></g></g><g id=\"SvgjsG1046\" transform=\"translate(25,337.4375)\"><path id=\"SvgjsPath1047\" d=\"M 0 0L 138 0L 138 30L 0 30Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1048\"><text id=\"SvgjsText1049\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"138px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"3\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1050\" dy=\"20\" x=\"69\"><tspan id=\"SvgjsTspan1051\" style=\"text-decoration:;\">null</tspan></tspan></text></g></g><g id=\"SvgjsG1052\"><path id=\"SvgjsPath1053\" d=\"M94 264.125L94 300.28125L94 300.28125L94 333.8375\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1054)\"></path></g><g id=\"SvgjsG1056\" transform=\"translate(108.5,283.75)\"><path id=\"SvgjsPath1057\" d=\"M 0 0L 75 0L 75 21L 0 21Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1058\"><text id=\"SvgjsText1059\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"75px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"-0.25\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1060\" dy=\"17\" x=\"37.5\"><tspan id=\"SvgjsTspan1061\" style=\"text-decoration:;\">__proto__</tspan></tspan></text></g></g></svg>\n  <p style=\"text-align: center; color: #888;\">（原型链）</p>\n</div>\n<p>由图可知，查找属性的时候查到 <code>Object.prototype</code> 就可以停止查找了。</p>\n<h2 id=\"一张图回顾\"> 一张图回顾</h2>\n<p>下面这张图通过 <code>__proto__</code> 和 <code>prototype</code> 把实例对象、构造函数、Object 和 Function 这些概念关联起来，乍一看很绕，但是如果能看懂，那么原型的这块知识就算理解了。</p>\n<div><p>原型的核心还是那句话</p>\n<p><strong>实例的 <code>__proto__</code> = 它的构造函数的 <code>prototype</code></strong>。</p>\n</div>\n<div style=\"text-align: center;\">\n  <svg id=\"SvgjsSvg1006\" width=\"887.3375549316406\" height=\"562.5750198364258\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><defs id=\"SvgjsDefs1007\"><marker id=\"SvgjsMarker1044\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1045\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#ae5d66\" stroke=\"#ae5d66\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1052\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1053\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#ae5d66\" stroke=\"#ae5d66\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1060\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1061\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#ae5d66\" stroke=\"#ae5d66\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1092\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1093\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#ae5d66\" stroke=\"#ae5d66\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1100\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1101\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#ae5d66\" stroke=\"#ae5d66\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1108\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1109\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#ae5d66\" stroke=\"#ae5d66\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1116\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1117\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#ae5d66\" stroke=\"#ae5d66\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1136\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1137\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#ae5d66\" stroke=\"#ae5d66\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1144\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1145\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#9e9e9e\" stroke=\"#9e9e9e\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1152\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1153\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#388e3c\" stroke=\"#388e3c\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1160\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1161\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#9e9e9e\" stroke=\"#9e9e9e\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1168\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1169\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#9e9e9e\" stroke=\"#9e9e9e\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1176\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1177\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#9e9e9e\" stroke=\"#9e9e9e\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1184\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1185\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#388e3c\" stroke=\"#388e3c\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1192\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1193\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#388e3c\" stroke=\"#388e3c\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1200\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1201\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#388e3c\" stroke=\"#388e3c\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1208\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1209\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#388e3c\" stroke=\"#388e3c\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1216\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1217\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#388e3c\" stroke=\"#388e3c\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1224\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1225\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#388e3c\" stroke=\"#388e3c\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1232\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1233\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#388e3c\" stroke=\"#388e3c\" stroke-width=\"1\"></path></marker></defs><g id=\"SvgjsG1008\" transform=\"translate(25.000015258789062,106.94999504089355)\"><path id=\"SvgjsPath1009\" d=\"M 0 0L 191.5 0L 191.5 386L 0 386Z\" stroke-dasharray=\"10,6\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1010\"><text id=\"SvgjsText1011\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"172px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"183.375\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1012\" transform=\"translate(59.75001525878906,487.94999504089355)\"><path id=\"SvgjsPath1013\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1014\"><text id=\"SvgjsText1015\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"120px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1016\" dy=\"20\" x=\"60\"><tspan id=\"SvgjsTspan1017\" style=\"text-decoration:;\">原型链</tspan></tspan></text></g></g><g id=\"SvgjsG1018\" transform=\"translate(80.75001525878906,134.94999504089355)\"><path id=\"SvgjsPath1019\" d=\"M 0 0L 78 0L 78 28L 0 28Z\" stroke=\"rgba(128,130,255,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#8082ff\"></path><g id=\"SvgjsG1020\"><text id=\"SvgjsText1021\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"58px\" fill=\"#ffffff\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"2\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1022\" dy=\"20\" x=\"39\"><tspan id=\"SvgjsTspan1023\" style=\"text-decoration:;\">foo</tspan></tspan></text></g></g><g id=\"SvgjsG1024\" transform=\"translate(44.50001525878906,232.44999504089355)\"><path id=\"SvgjsPath1025\" d=\"M 0 0L 153 0L 153 33L 0 33Z\" stroke=\"rgba(128,130,255,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#8082ff\"></path><g id=\"SvgjsG1026\"><text id=\"SvgjsText1027\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"133px\" fill=\"#ffffff\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"4.5\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1028\" dy=\"20\" x=\"76.5\"><tspan id=\"SvgjsTspan1029\" style=\"text-decoration:;\">Foo.prototype</tspan></tspan></text></g></g><g id=\"SvgjsG1030\" transform=\"translate(44.50001525878906,332.44999504089355)\"><path id=\"SvgjsPath1031\" d=\"M 0 0L 153 0L 153 33L 0 33Z\" stroke=\"rgba(128,130,255,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#8082ff\"></path><g id=\"SvgjsG1032\"><text id=\"SvgjsText1033\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"133px\" fill=\"#ffffff\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"4.5\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1034\" dy=\"20\" x=\"76.5\"><tspan id=\"SvgjsTspan1035\" style=\"text-decoration:;\">Object.prototype</tspan></tspan></text></g></g><g id=\"SvgjsG1036\" transform=\"translate(80.75001525878906,435.19999504089355)\"><path id=\"SvgjsPath1037\" d=\"M 0 0L 78 0L 78 28L 0 28Z\" stroke=\"rgba(128,130,255,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#8082ff\"></path><g id=\"SvgjsG1038\"><text id=\"SvgjsText1039\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"58px\" fill=\"#ffffff\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"2\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1040\" dy=\"20\" x=\"39\"><tspan id=\"SvgjsTspan1041\" style=\"text-decoration:;\">null</tspan></tspan></text></g></g><g id=\"SvgjsG1042\"><path id=\"SvgjsPath1043\" d=\"M121.00001525878906 163.94999504089355L121.00001525878906 197.69999504089355L121.00001525878906 197.69999504089355L121.00001525878906 228.84999504089353\" stroke=\"#ae5d66\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1044)\"></path><rect id=\"SvgjsRect1046\" width=\"62\" height=\"18\" x=\"88.00001525878906\" y=\"180.94999504089355\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1047\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"62px\" fill=\"#ae5d66\" font-weight=\"400\" align=\"top\" lineHeight=\"18px\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"179.19999504089355\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1048\" dy=\"17\" x=\"119.00001525878906\"><tspan id=\"SvgjsTspan1049\" style=\"text-decoration:;\">__proto__</tspan></tspan></text></g><g id=\"SvgjsG1050\"><path id=\"SvgjsPath1051\" d=\"M121.00001525878906 266.44999504089355L121.00001525878906 298.71562004089355L121.00001525878906 298.71562004089355L121.00001525878906 328.84999504089353\" stroke=\"#ae5d66\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1052)\"></path><rect id=\"SvgjsRect1054\" width=\"62\" height=\"18\" x=\"88.00001525878906\" y=\"285.94999504089355\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1055\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"62px\" fill=\"#ae5d66\" font-weight=\"400\" align=\"top\" lineHeight=\"18px\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"284.19999504089355\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1056\" dy=\"17\" x=\"119.00001525878906\"><tspan id=\"SvgjsTspan1057\" style=\"text-decoration:;\">__proto__</tspan></tspan></text></g><g id=\"SvgjsG1058\"><path id=\"SvgjsPath1059\" d=\"M119.75001525878906 366.44999504089355L119.75001525878906 400.43437004089355L119.75001525878906 400.43437004089355L119.75001525878906 431.59999504089353\" stroke=\"#ae5d66\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1060)\"></path><rect id=\"SvgjsRect1062\" width=\"62\" height=\"18\" x=\"88.00001525878906\" y=\"388.94999504089355\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1063\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"62px\" fill=\"#ae5d66\" font-weight=\"400\" align=\"top\" lineHeight=\"18px\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"387.19999504089355\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1064\" dy=\"17\" x=\"119.00001525878906\"><tspan id=\"SvgjsTspan1065\" style=\"text-decoration:;\">__proto__</tspan></tspan></text></g><g id=\"SvgjsG1066\" transform=\"translate(408.50001525878906,134.94999504089355)\"><path id=\"SvgjsPath1067\" d=\"M 0 0L 95 0L 95 28L 0 28Z\" stroke=\"rgba(252,133,250,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#fc85fa\"></path><g id=\"SvgjsG1068\"><text id=\"SvgjsText1069\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"75px\" fill=\"#ffffff\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"2\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1070\" dy=\"20\" x=\"47.5\"><tspan id=\"SvgjsTspan1071\" style=\"text-decoration:;\">Foo</tspan></tspan></text></g></g><g id=\"SvgjsG1072\" transform=\"translate(370.00001525878906,232.44999504089355)\"><path id=\"SvgjsPath1073\" d=\"M 0 0L 172 0L 172 33L 0 33Z\" stroke=\"rgba(128,130,255,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#8082ff\"></path><g id=\"SvgjsG1074\"><text id=\"SvgjsText1075\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"152px\" fill=\"#ffffff\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"4.5\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1076\" dy=\"20\" x=\"86\"><tspan id=\"SvgjsTspan1077\" style=\"text-decoration:;\">Function.prototype</tspan></tspan></text></g></g><g id=\"SvgjsG1078\" transform=\"translate(408.50001525878906,334.94999504089355)\"><path id=\"SvgjsPath1079\" d=\"M 0 0L 95 0L 95 28L 0 28Z\" stroke=\"rgba(252,133,250,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#fc85fa\"></path><g id=\"SvgjsG1080\"><text id=\"SvgjsText1081\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"75px\" fill=\"#ffffff\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"2\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1082\" dy=\"20\" x=\"47.5\"><tspan id=\"SvgjsTspan1083\" style=\"text-decoration:;\">Object</tspan></tspan></text></g></g><g id=\"SvgjsG1084\" transform=\"translate(700.7500152587891,134.94999504089355)\"><path id=\"SvgjsPath1085\" d=\"M 0 0L 95 0L 95 28L 0 28Z\" stroke=\"rgba(252,133,250,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#fc85fa\"></path><g id=\"SvgjsG1086\"><text id=\"SvgjsText1087\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"75px\" fill=\"#ffffff\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"2\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1088\" dy=\"20\" x=\"47.5\"><tspan id=\"SvgjsTspan1089\" style=\"text-decoration:;\">Function</tspan></tspan></text></g></g><g id=\"SvgjsG1090\"><path id=\"SvgjsPath1091\" d=\"M396.0461717379952 263.25029911652285L179.68385193364696 331.368900368628\" stroke=\"#ae5d66\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1092)\"></path><rect id=\"SvgjsRect1094\" width=\"62\" height=\"18\" x=\"266.00001525878906\" y=\"284.94999504089355\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1095\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"62px\" fill=\"#ae5d66\" font-weight=\"400\" align=\"top\" lineHeight=\"18px\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"283.19999504089355\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1096\" dy=\"17\" x=\"297.00001525878906\"><tspan id=\"SvgjsTspan1097\" style=\"text-decoration:;\">__proto__</tspan></tspan></text></g><g id=\"SvgjsG1098\"><path id=\"SvgjsPath1099\" d=\"M456.00001525878906 163.94999504089355L456.00001525878906 228.84999504089353\" stroke=\"#ae5d66\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1100)\"></path><rect id=\"SvgjsRect1102\" width=\"62\" height=\"18\" x=\"423.00001525878906\" y=\"183.94999504089355\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1103\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"62px\" fill=\"#ae5d66\" font-weight=\"400\" align=\"top\" lineHeight=\"18px\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"182.19999504089355\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1104\" dy=\"17\" x=\"454.00001525878906\"><tspan id=\"SvgjsTspan1105\" style=\"text-decoration:;\">__proto__</tspan></tspan></text></g><g id=\"SvgjsG1106\"><path id=\"SvgjsPath1107\" d=\"M455.97537485507735 333.9502986617339L454.33872071215114 267.54890200586834\" stroke=\"#ae5d66\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1108)\"></path><rect id=\"SvgjsRect1110\" width=\"62\" height=\"18\" x=\"423.00001525878906\" y=\"292.94999504089355\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1111\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"62px\" fill=\"#ae5d66\" font-weight=\"400\" align=\"top\" lineHeight=\"18px\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"291.19999504089355\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1112\" dy=\"17\" x=\"454.00001525878906\"><tspan id=\"SvgjsTspan1113\" style=\"text-decoration:;\">__proto__</tspan></tspan></text></g><g id=\"SvgjsG1114\"><path id=\"SvgjsPath1115\" d=\"M721.051905351349 163.26793780840666L518.1632109255735 231.3054010778464\" stroke=\"#ae5d66\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1116)\"></path><rect id=\"SvgjsRect1118\" width=\"62\" height=\"18\" x=\"607.2875152587891\" y=\"185.22499504089356\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1119\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"62px\" fill=\"#ae5d66\" font-weight=\"400\" align=\"top\" lineHeight=\"18px\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"183.47499504089356\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1120\" dy=\"17\" x=\"638.2875152587891\"><tspan id=\"SvgjsTspan1121\" style=\"text-decoration:;\">__proto__</tspan></tspan></text></g><g id=\"SvgjsG1122\" transform=\"translate(711.5000152587891,458.94999504089355)\"><path id=\"SvgjsPath1123\" d=\"M 0 0L 95 0L 95 28L 0 28Z\" stroke=\"rgba(252,133,250,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#fc85fa\"></path><g id=\"SvgjsG1124\"><text id=\"SvgjsText1125\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"75px\" fill=\"#ffffff\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"2\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1126\" dy=\"20\" x=\"47.5\"><tspan id=\"SvgjsTspan1127\" style=\"text-decoration:;\">函数</tspan></tspan></text></g></g><g id=\"SvgjsG1128\" transform=\"translate(711.5000152587891,503.94999504089355)\"><path id=\"SvgjsPath1129\" d=\"M 0 0L 95 0L 95 28L 0 28Z\" stroke=\"rgba(128,130,255,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#8082ff\"></path><g id=\"SvgjsG1130\"><text id=\"SvgjsText1131\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"75px\" fill=\"#ffffff\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"2\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1132\" dy=\"20\" x=\"47.5\"><tspan id=\"SvgjsTspan1133\" style=\"text-decoration:;\">对象</tspan></tspan></text></g></g><g id=\"SvgjsG1134\"><path id=\"SvgjsPath1135\" d=\"M700.7500152587891 374.69999504089355L814.7500152587891 374.69999504089355\" stroke=\"#ae5d66\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1136)\"></path><rect id=\"SvgjsRect1138\" width=\"58\" height=\"16\" x=\"722.7500152587891\" y=\"366.69999504089355\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1139\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"58px\" fill=\"#ae5d66\" font-weight=\"400\" align=\"top\" lineHeight=\"16px\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"365.07499504089355\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1140\" dy=\"16\" x=\"751.7500152587891\"><tspan id=\"SvgjsTspan1141\" style=\"text-decoration:;\">__proto__</tspan></tspan></text></g><g id=\"SvgjsG1142\"><path id=\"SvgjsPath1143\" d=\"M700.7500152587891 404.69999504089355L814.7500152587891 404.69999504089355\" stroke=\"#9e9e9e\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1144)\"></path><rect id=\"SvgjsRect1146\" width=\"62\" height=\"16\" x=\"720.7500152587891\" y=\"396.69999504089355\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1147\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"62px\" fill=\"#9e9e9e\" font-weight=\"400\" align=\"top\" lineHeight=\"16px\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"395.07499504089355\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1148\" dy=\"16\" x=\"751.7500152587891\"><tspan id=\"SvgjsTspan1149\" style=\"text-decoration:;\">prototype</tspan></tspan></text></g><g id=\"SvgjsG1150\"><path id=\"SvgjsPath1151\" d=\"M700.7500152587891 434.69999504089355L814.7500152587891 434.69999504089355\" stroke-dasharray=\"8,5\" stroke=\"#388e3c\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1152)\"></path><rect id=\"SvgjsRect1154\" width=\"71\" height=\"16\" x=\"722.2500152587891\" y=\"426.69999504089355\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1155\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"71px\" fill=\"#388e3c\" font-weight=\"400\" align=\"top\" lineHeight=\"16px\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"425.07499504089355\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1156\" dy=\"16\" x=\"757.7500152587891\"><tspan id=\"SvgjsTspan1157\" style=\"text-decoration:;\">constructor</tspan></tspan></text></g><g id=\"SvgjsG1158\"><path id=\"SvgjsPath1159\" d=\"M407.5000392569747 350.41181714111684L200.09992886532086 348.97493548008975\" stroke=\"#9e9e9e\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1160)\"></path><rect id=\"SvgjsRect1162\" width=\"66\" height=\"18\" x=\"270.79998406114777\" y=\"340.6933763106033\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1163\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"66px\" fill=\"#9e9e9e\" font-weight=\"400\" align=\"top\" lineHeight=\"18px\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"338.9433763106033\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1164\" dy=\"17\" x=\"303.79998406114777\"><tspan id=\"SvgjsTspan1165\" style=\"text-decoration:;\">prototype</tspan></tspan></text></g><g id=\"SvgjsG1166\"><path id=\"SvgjsPath1167\" d=\"M407.5399476593866 163.22976316734415L173.45625861663774 231.4428297856714\" stroke=\"#9e9e9e\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1168)\"></path><rect id=\"SvgjsRect1170\" width=\"66\" height=\"18\" x=\"267.00001525878906\" y=\"183.94999504089355\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1171\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"66px\" fill=\"#9e9e9e\" font-weight=\"400\" align=\"top\" lineHeight=\"18px\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"182.19999504089355\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1172\" dy=\"17\" x=\"300.00001525878906\"><tspan id=\"SvgjsTspan1173\" style=\"text-decoration:;\">prototype</tspan></tspan></text></g><g id=\"SvgjsG1174\"><path id=\"SvgjsPath1175\" d=\"M734.9276804415553 133.95261463492213C 735.0000152587891 25.000734015636993 563.0000152587891 107.94999504089355 481.09451662982667 229.52201553162075\" stroke=\"#9e9e9e\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1176)\"></path><rect id=\"SvgjsRect1178\" width=\"66\" height=\"18\" x=\"589.0000152587891\" y=\"93.94999504089355\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1179\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"66px\" fill=\"#9e9e9e\" font-weight=\"400\" align=\"top\" lineHeight=\"18px\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"92.19999504089355\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1180\" dy=\"17\" x=\"622.0000152587891\"><tspan id=\"SvgjsTspan1181\" style=\"text-decoration:;\">prototype</tspan></tspan></text></g><g id=\"SvgjsG1182\"><path id=\"SvgjsPath1183\" d=\"M159.75001525878906 148.94999504089355C 258.40001525878904 148.94999504089355 308.1000152587891 148.94999504089355 404.90001525878904 148.94999504089355\" stroke-dasharray=\"8,5\" stroke=\"#388e3c\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1184)\"></path><rect id=\"SvgjsRect1186\" width=\"77\" height=\"18\" x=\"255.50001525878906\" y=\"139.94999504089355\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1187\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"77px\" fill=\"#388e3c\" font-weight=\"400\" align=\"top\" lineHeight=\"18px\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"138.19999504089355\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1188\" dy=\"17\" x=\"294.00001525878906\"><tspan id=\"SvgjsTspan1189\" style=\"text-decoration:;\">constructor</tspan></tspan></text></g><g id=\"SvgjsG1190\"><path id=\"SvgjsPath1191\" d=\"M198.49959846301044 248.92112606379862C 303.00001525878906 246.94999504089355 371.00001525878906 224.94999504089355 424.5514856584232 164.5890673771762\" stroke-dasharray=\"8,5\" stroke=\"#388e3c\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1192)\"></path><rect id=\"SvgjsRect1194\" width=\"77\" height=\"18\" x=\"268.50001525878906\" y=\"225.94999504089355\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1195\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"77px\" fill=\"#388e3c\" font-weight=\"400\" align=\"top\" lineHeight=\"18px\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"224.19999504089355\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1196\" dy=\"17\" x=\"307.00001525878906\"><tspan id=\"SvgjsTspan1197\" style=\"text-decoration:;\">constructor</tspan></tspan></text></g><g id=\"SvgjsG1198\"><path id=\"SvgjsPath1199\" d=\"M155.9231372056966 365.8345023504959C 327.00001525878906 440.94999504089355 413.00001525878906 385.94999504089355 443.00001525878906 364.94999504089355\" stroke-dasharray=\"8,5\" stroke=\"#388e3c\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1200)\"></path><rect id=\"SvgjsRect1202\" width=\"77\" height=\"18\" x=\"266.50001525878906\" y=\"393.94999504089355\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1203\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"77px\" fill=\"#388e3c\" font-weight=\"400\" align=\"top\" lineHeight=\"18px\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"392.19999504089355\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1204\" dy=\"17\" x=\"305.00001525878906\"><tspan id=\"SvgjsTspan1205\" style=\"text-decoration:;\">constructor</tspan></tspan></text></g><g id=\"SvgjsG1206\"><path id=\"SvgjsPath1207\" d=\"M478.84364461024654 334.41306905217687L745.2129495935421 164.8829286002737\" stroke-dasharray=\"8,5\" stroke=\"#388e3c\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1208)\"></path><rect id=\"SvgjsRect1210\" width=\"77\" height=\"18\" x=\"516.3125152587891\" y=\"282.94999504089355\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1211\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"77px\" fill=\"#388e3c\" font-weight=\"400\" align=\"top\" lineHeight=\"18px\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"281.19999504089355\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1212\" dy=\"17\" x=\"554.8125152587891\"><tspan id=\"SvgjsTspan1213\" style=\"text-decoration:;\">constructor</tspan></tspan></text></g><g id=\"SvgjsG1214\"><path id=\"SvgjsPath1215\" d=\"M543.0000006649819 248.95539757745127C 638.6269589817824 248.94999504089355 771.5000152587891 261.8269387638869 771.2553065736315 166.5416684196139\" stroke-dasharray=\"8,5\" stroke=\"#388e3c\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1216)\"></path><rect id=\"SvgjsRect1218\" width=\"77\" height=\"18\" x=\"711.6297576224348\" y=\"230.13072722273364\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1219\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"77px\" fill=\"#388e3c\" font-weight=\"400\" align=\"top\" lineHeight=\"18px\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"228.38072722273364\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1220\" dy=\"17\" x=\"750.1297576224348\"><tspan id=\"SvgjsTspan1221\" style=\"text-decoration:;\">constructor</tspan></tspan></text></g><g id=\"SvgjsG1222\"><path id=\"SvgjsPath1223\" d=\"M796.3747503523527 155.39270113463448C 862.0000152587891 88.94999504089355 816.0000152587891 86.94999504089355 751.3476626466601 133.11571571090698\" stroke-dasharray=\"8,5\" stroke=\"#388e3c\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1224)\"></path><rect id=\"SvgjsRect1226\" width=\"77\" height=\"18\" x=\"784.2153130689684\" y=\"93.02604838636286\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1227\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"77px\" fill=\"#388e3c\" font-weight=\"400\" align=\"top\" lineHeight=\"18px\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"91.27604838636286\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1228\" dy=\"17\" x=\"822.7153130689684\"><tspan id=\"SvgjsTspan1229\" style=\"text-decoration:;\">constructor</tspan></tspan></text></g><g id=\"SvgjsG1230\"><path id=\"SvgjsPath1231\" d=\"M504.50001525878906 148.94999504089355L697.150015258789 148.94999504089355\" stroke-dasharray=\"8,5\" stroke=\"#388e3c\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1232)\"></path><rect id=\"SvgjsRect1234\" width=\"77\" height=\"18\" x=\"572.5000152587891\" y=\"139.94999504089355\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1235\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"77px\" fill=\"#388e3c\" font-weight=\"400\" align=\"top\" lineHeight=\"18px\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"138.19999504089355\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1236\" dy=\"17\" x=\"611.0000152587891\"><tspan id=\"SvgjsTspan1237\" style=\"text-decoration:;\">constructor</tspan></tspan></text></g><g id=\"SvgjsG1238\" transform=\"translate(495.50001525878906,478.57499504089355)\"><path id=\"SvgjsPath1239\" d=\"M 0 0L 172 0L 172 58.75L 0 58.75Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1240\"><text id=\"SvgjsText1241\" font-family=\"微软雅黑\" text-anchor=\"start\" font-size=\"14px\" width=\"172px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"start\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"10.125\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1242\" dy=\"17\" x=\"0\"><tspan id=\"SvgjsTspan1243\" style=\"text-decoration:;\">function Foo(){...};</tspan></tspan><tspan id=\"SvgjsTspan1244\" dy=\"17\" x=\"0\"><tspan id=\"SvgjsTspan1245\" style=\"text-decoration:;\">let foo = new Foo();</tspan></tspan></text></g></g></svg>\n  <p style=\"text-align: center; color: #888;\">（原型关系图）</p>\n</div>\n<p>（完）</p>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T07:36:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "同步与异步",
      "url": "https://www.fedbook.cn/frontend-knowledge/javascript/sync-and-async/",
      "id": "https://www.fedbook.cn/frontend-knowledge/javascript/sync-and-async/",
      "content_html": "<h1 id=\"同步与异步\"> 同步与异步</h1>\n<blockquote>\n<p>在 ES5 中，异步编程的传统解决方案是通过回调函数或事件监听。<br>\n在 ES6 中，Promise 成为了异步编程的一种更合理更强大的解决方案。<br>\n在 ES7 中，async/await 优化了 ES6 异步编程的解决方案，比 Promise 更加优美。</p>\n</blockquote>\n<h2 id=\"同步与异步概念\"> 同步与异步概念</h2>\n<h3 id=\"代码举例\"> 代码举例</h3>\n<p><strong>同步</strong>：同步就是后一个任务等待前一个任务执行完毕后，再执行，执行顺序和任务的排列顺序一致。<br>\n<strong>异步</strong>：异步是非阻塞的，异步逻辑与主逻辑相互独立，主逻辑不需要等待异步逻辑完成，而是可以立刻继续下去。</p>\n<p>举个例子：</p>\n<div><pre><code>console<span>.</span><span>log</span><span>(</span><span>'a'</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span><span>'b'</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span><span>'c'</span><span>)</span><span>;</span>\n\n<span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>console<span>.</span><span>log</span><span>(</span><span>'我是一段异步操作'</span><span>)</span><span>}</span><span>,</span> <span>2000</span><span>)</span><span>;</span>\n\nconsole<span>.</span><span>log</span><span>(</span><span>'d'</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span><span>'e'</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>从以上代码的输出结果可以看出，异步函数的好处是<strong>不会阻塞主任务</strong>。</p>\n<p>再举个例子：</p>\n<div><pre><code>console<span>.</span><span>log</span><span>(</span><span>'a'</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span><span>'b'</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span><span>'c'</span><span>)</span><span>;</span>\n\n<span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>console<span>.</span><span>log</span><span>(</span><span>'我是写在前面的异步操作'</span><span>)</span><span>}</span><span>,</span> <span>2000</span><span>)</span><span>;</span>\n\n<span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>console<span>.</span><span>log</span><span>(</span><span>'我是写在后面的异步操作'</span><span>)</span><span>}</span><span>,</span> <span>500</span><span>)</span><span>;</span>\n\nconsole<span>.</span><span>log</span><span>(</span><span>'d'</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span><span>'e'</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>上述代码的执行结果表明：当有多个异步函数时，跟书写顺序无关，<strong>谁先返回，就先执行谁的回调</strong>。</p>\n<h3 id=\"过程分析\"> 过程分析</h3>\n<p>运行以下 JavaScript，猜想控制台会输出什么内容，并分析执行过程是怎样的：</p>\n<div><pre><code><span>const</span> <span>foo</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> console<span>.</span><span>log</span><span>(</span><span>\"First\"</span><span>)</span><span>;</span>\n<span>const</span> <span>bar</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> console<span>.</span><span>log</span><span>(</span><span>\"Second\"</span><span>)</span><span>,</span> <span>500</span><span>)</span><span>;</span>\n<span>const</span> <span>baz</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> console<span>.</span><span>log</span><span>(</span><span>\"Third\"</span><span>)</span><span>;</span>\n\n<span>bar</span><span>(</span><span>)</span>\n<span>foo</span><span>(</span><span>)</span>\n<span>baz</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>分析执行过程（其中 4、5 两个步骤的先后顺序不绝对，主要看倒计时多久）：</p>\n<ul>\n<li>调用 <code>bar</code> 函数，它进入调用栈；<code>bar</code> 返回一个 <code>setTimeout</code> 函数，也进入调用栈执行。</li>\n<li><code>setTimeout</code> 开启定时器后，它的回调进入 Web API。于此同时，执行完成的 <code>setTimeout</code> 函数和 <code>bar</code> 从调用堆栈中弹出。</li>\n<li>定时器开始倒计时，同时 <code>foo</code> 函数调用并打印出字符串 <code>&quot;First&quot;</code>，然后返回执行结果（<code>undefined</code>）。</li>\n<li><code>baz</code> 函数被调用。</li>\n<li>定时器倒计时结束，回调函数添加到消息队列中。</li>\n<li><code>baz</code> 函数打印出字符串 <code>&quot;Third&quot;</code>，然后返回执行结果（<code>undefined</code>）。</li>\n<li><code>baz</code> 指行完成后，事件循环看到调用栈为空，从消息队列中取出回调函数，将其添加到调用栈。</li>\n<li>回调函数打印出字符串 <code>&quot;Second&quot;</code>。</li>\n<li>全部执行完毕。</li>\n</ul>\n<p>动图演示执行过程：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/event-loop-visualized.gif\" alt=\"代码执行过程\">\n  <p style=\"text-align: center; color: #888;\">（代码执行过程，图来源于网络 - 文末已附原文链接）</p>\n</div>\n<p>在这个过程中，需要引入三个概念：<strong>调用栈</strong>，<strong>事件循环</strong>，<strong>消息队列</strong>。</p>\n<ul>\n<li><strong>调用栈</strong>：每次执行任务时，任务（以同步模式执行的代码）进入调用栈并执行，执行完后任务弹出调用栈。</li>\n<li><strong>事件循环（Event Loop）</strong>：它只做一件事：负责监听调用栈和消息队列，一旦调用栈中所有的任务都结束了，事件循环就从消息队列中取出第一个回调函数，将它压入调用栈；如果消息队列中暂时是空的，事件循环就会先暂停，等回函数调进消息队列（如果有）。</li>\n<li><strong>消息队列</strong>：存放异步任务的回调，先进先出。</li>\n</ul>\n<blockquote>\n<p>补充：任务进入消息队列的顺序由<a href=\"/frontend-knowledge/javascript/event-loop/\">宏任务与微任务</a>的时序决定，参考下一章的知识点，本文先不考虑。</p>\n</blockquote>\n<p>下面这张图可以很清晰的表达出同步任务和异步任务的执行顺序：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/sync-and-async-timeline.svg\" height=\"480\" alt=\"同步任务和异步任务的执行时间线\">\n  <p style=\"text-align: center; color: #888;\">（同步任务和异步任务的执行时间线）</p>\n</div>\n<p>我们可以根据这张图归纳出一般的执行流程：</p>\n<ul>\n<li>JavaScript 线程依次执行每行代码。对于同步代码，将它放到调用栈中执行，执行完后然后弹出调用栈（例如 <code>console.log()</code>）。</li>\n<li>某个时刻，JavaScript 线程发起了一个异步调用（例如 <code>setTimeout</code>）。\n<ul>\n<li><code>setTimeout</code> 函数进入调用栈，开启倒计时器，然后 <code>setTimeout</code> 函数弹出调用栈。</li>\n<li>JavaScript 线程继续往后执行。</li>\n</ul>\n</li>\n<li>异步线程（Web API）单独执行这个异步任务（倒计时器），执行完这个任务之后，将任务的回调放到消息队列。</li>\n<li>JavaScript 主线程完成所有的同步任务后，此时调用栈清空状态。</li>\n<li>接下来，如果倒计时结束，回调函数就会被放入消息队列；否则事件循环继续保持等待状态。</li>\n<li>事件循环依次从消息队列中取出任务，将它压入调用栈并执行，执行方式相当于开启了新一轮的执行，与上面相同。</li>\n<li>最后，调用栈和消息队列中都没有需要执行的任务了，整体代码结束。</li>\n</ul>\n<blockquote>\n<ul>\n<li>众所周知，JavaScript 是单线程的，但浏览器不是单线程的，例如上面使用的倒计时器 <code>setTimeout</code>，浏览器内部就会有一个单独的线程去负责倒数，等时间到了就将回调放入消息队列。</li>\n<li>平时所说的 JavaScript 单线程，是指执行我们代码的是一个线程，而其它一些内部的 API（例如 <code>setTimeout</code>）会用单独的线程去执行。所以这里的同步与异步，指的是运行环境提供的 API 是以同步模式还是异步模式的方式去工作。</li>\n</ul>\n</blockquote>\n<h2 id=\"回调函数\"> 回调函数</h2>\n<p>所有异步编程方案的根基都是回调函数。</p>\n<p>回调函数：由调用者定义，交给执行者执行的函数。回调函数一个很明显的特点是「由我们定义，我们不去调用，但最后执行了」。</p>\n<div><pre><code><span>// callback 就是回调函数</span>\n<span>// 就是把函数作为参数传递，缺点是不利于阅读，执行顺序混乱。</span>\n<span>function</span> <span>foo</span><span>(</span><span>callback</span><span>)</span> <span>{</span>\n  <span>setTimeout</span><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>\n    <span>callback</span><span>(</span><span>)</span>\n  <span>}</span><span>,</span> <span>3000</span><span>)</span>\n<span>}</span>\n\n<span>foo</span><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'这就是一个回调函数'</span><span>)</span>\n  console<span>.</span><span>log</span><span>(</span><span>'调用者定义这个函数，执行者执行这个函数'</span><span>)</span>\n  console<span>.</span><span>log</span><span>(</span><span>'其实就是调用者告诉执行者异步任务结束后应该做什么'</span><span>)</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>除了传递回调函数参数这种方式，还有其他的一些实现异步的方式，例如：事件机制和发布订阅。这些也都是基于回调函数基础之上的变体。</p>\n<p>下面介绍几种使用回调方式来完成异步流程的方案。</p>\n<h2 id=\"ajax-jquery\"> ajax（jQuery）</h2>\n<p><code>$.ajax</code> 是 jQuery 中一个异步请求的方法，它的用法如下代码所示：</p>\n<div><pre><code>console<span>.</span><span>log</span><span>(</span><span>1</span><span>)</span><span>;</span>\n\n$<span>.</span><span>ajax</span><span>(</span><span>{</span>\n  type<span>:</span> <span>\"get\"</span><span>,</span>\n  url<span>:</span> <span>\"https://www.fedbook.cn/apis/articles/list/\"</span><span>,</span>\n  <span>success</span><span>:</span> <span>function</span><span>(</span><span>res</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span>res<span>)</span>\n  <span>}</span>\n<span>}</span><span>)</span><span>;</span>\n\nconsole<span>.</span><span>log</span><span>(</span><span>2</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上述代码是一种传统异步编程的解决方案：通过回调函数实现。但它有一个致命的缺点，就是容易写出<strong>回调地狱</strong>。</p>\n<p>假设多个请求存在依赖性，你可能就会写出如下代码：</p>\n<div><pre><code><span>ajax</span><span>(</span>url<span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>// 处理逻辑</span>\n  <span>ajax</span><span>(</span>url1<span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n    <span>// 处理逻辑</span>\n    <span>ajax</span><span>(</span>url2<span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n      <span>// 处理逻辑</span>\n    <span>}</span><span>)</span>\n  <span>}</span><span>)</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id=\"promise\"> Promise</h2>\n<p>Promise 是 ES6 中异步编程的一种解决方案，比传统的解决方案（回调函数或事件监听）更合理且更强大。</p>\n<p>它有三个状态：</p>\n<ul>\n<li>pending：初始状态</li>\n<li>fulfilled：操作成功</li>\n<li>rejected：操作失败</li>\n</ul>\n<p>当 promise 状态发生改变，就会触发 <code>then()</code> 里的响应函数处理后续步骤。</p>\n<p>状态改变，只有两种可能：</p>\n<ul>\n<li>从 pending 变为 fulfilled</li>\n<li>从 pending 变为 rejected</li>\n</ul>\n<h3 id=\"基础用法\"> 基础用法</h3>\n<p>下述代码演示了 Promise 基础用法：</p>\n<div><pre><code><span>const</span> promise <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>function</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>{</span>\n  <span>if</span> <span>(</span><span>true</span><span>)</span> <span>{</span>\n    <span>resolve</span><span>(</span><span>'success'</span><span>)</span><span>;</span> <span>// 异步请求成功，将请求结果 resolve 出去</span>\n  <span>}</span> <span>else</span> <span>{</span>\n    <span>reject</span><span>(</span><span>'fail'</span><span>)</span><span>;</span>     <span>// 异步请求失败，将错误信息 reject 出去</span>\n  <span>}</span>\n<span>}</span><span>)</span><span>;</span>\n\npromise<span>.</span><span>then</span><span>(</span><span>res</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>res<span>)</span><span>;</span>   <span>// 成功 resolve('success')</span>\n<span>}</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>error</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>error<span>)</span><span>;</span> <span>// 失败 reject('fail')</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>从上面的代码可以看出，Promise 本质上也是使用回调函数去定义异步任务结束后所需要执行的任务。这里的回调函数是通过 then 方法传递的，且 Promise 将回调分成了两种，分别是成功后的回调和失败后的回调。</p>\n<h3 id=\"promise-使用案例\"> Promise 使用案例</h3>\n<p>下面演示一个用 Promise 封装 Ajax 请求的例子：</p>\n<div><pre><code><span>/**\n * Ajax Demo\n * @param {string} get 请求的 url\n * @return {Promise}\n */</span>\n<span>function</span> <span>ajax</span><span>(</span><span>url</span><span>)</span> <span>{</span>\n  <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>function</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>{</span>\n    <span>let</span> xhr <span>=</span> <span>new</span> <span>XMLHttpRequest</span><span>(</span><span>)</span><span>;</span>\n    xhr<span>.</span><span>open</span><span>(</span><span>'GET'</span><span>,</span> url<span>)</span><span>;</span>\n    xhr<span>.</span>responseType <span>=</span> <span>'json'</span><span>;</span>\n    xhr<span>.</span><span>onload</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n      <span>if</span> <span>(</span><span>this</span><span>.</span>status <span>===</span> <span>200</span><span>)</span> <span>{</span>\n        <span>resolve</span><span>(</span><span>this</span><span>.</span>response<span>)</span><span>;</span>\n      <span>}</span> <span>else</span> <span>{</span>\n        <span>reject</span><span>(</span><span>new</span> <span>Error</span><span>(</span><span>this</span><span>.</span>statusText<span>)</span><span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span><span>;</span>\n    xhr<span>.</span><span>send</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span><span>)</span>\n<span>}</span><span>;</span>\n\n<span>ajax</span><span>(</span><span>'/api/users.json'</span><span>)</span><span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>res</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>res<span>)</span><span>;</span>\n<span>}</span><span>,</span> <span>function</span><span>(</span><span>error</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>error<span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>上面代码中，ajax 是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP GET 请求，并且返回一个 Promise 对象。需要注意的是，在 ajax 内部，resolve 函数和 reject 函数调用时，都带有参数。</p>\n<h3 id=\"promise-链式调用\"> Promise 链式调用</h3>\n<ul>\n<li>Promise 对象的 then 方法会返回一个全新的 Promise 对象。</li>\n<li>后面的 then 方法就是在为上一个 then 返回的 Promise 注册回调。</li>\n<li>前面 then 方法中回调函数的返回值会作为后面 then 方法回调的参数，如果没有返回值，默认返回 undefined。</li>\n<li>如果回调中返回的是 Promise，那后面 then 方法的回调会等待它的结束（也就是后面这个 then 方法在为我们返回的 Promise 注册回调）。</li>\n</ul>\n<div><pre><code><span>ajax</span><span>(</span><span>'/api/users.json'</span><span>)</span>\n  <span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>value</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>1</span><span>)</span>\n    <span>return</span> <span>ajax</span><span>(</span><span>'/api/urls.json'</span><span>)</span>\n  <span>}</span><span>)</span>\n  <span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>value</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>2</span><span>)</span>\n    console<span>.</span><span>log</span><span>(</span>value<span>)</span>\n  <span>}</span><span>)</span>\n  <span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>value</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>3</span><span>)</span>\n  <span>}</span><span>)</span>\n  <span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>value</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>4</span><span>)</span>\n    <span>return</span> <span>'hello'</span>\n  <span>}</span><span>)</span>\n  <span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>value</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>5</span><span>)</span>\n    console<span>.</span><span>log</span><span>(</span>value<span>)</span>\n  <span>}</span><span>)</span>\n\n<span>// 输出结果</span>\n<span>1</span>\n<span>2</span>\n<span>[</span><span>{</span>name<span>:</span> <span>'前端修炼小册'</span><span>,</span> url<span>:</span> <span>\"www.fedbook.cn\"</span><span>}</span><span>,</span> <span>{</span>name<span>:</span> <span>'百度'</span><span>,</span> url<span>:</span> <span>\"www.baidu.com\"</span><span>}</span><span>]</span>\n<span>3</span>\n<span>4</span>\n<span>5</span>\n<span>\"hello\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h3 id=\"promise-异常处理\"> Promise 异常处理</h3>\n<h4 id=\"_1-应该总是使用-catch-方法来捕获-promise-异常。\"> 1）应该总是使用 catch 方法来捕获 Promise 异常。</h4>\n<p>我们知道，有两种方法可以捕获 Promise 对象抛出的异常：</p>\n<ul>\n<li><code>then()</code> 方法的第二个参数指定 <code>rejected</code> 状态的回调函数</li>\n<li><code>catch</code> 方法指定发生错误时的回调函数</li>\n</ul>\n<p>一般来说，应该总是使用 catch 方法来捕获 Promise 异常。</p>\n<p>原因是 catch 方法不但可以捕获异步操作抛出的错误（即状态为 rejected 时），而且 then 方法指定的回调函数中如果抛出错误，也会被 catch 方法捕获。</p>\n<div><pre><code><span>// bad</span>\n<span>ajax</span><span>(</span><span>'/api/users.json'</span><span>)</span>\n  <span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>data</span><span>)</span> <span>{</span>\n    <span>// success</span>\n  <span>}</span><span>,</span> <span>function</span><span>(</span><span>err</span><span>)</span> <span>{</span>\n    <span>// error</span>\n  <span>}</span><span>)</span><span>;</span>\n\n<span>// good</span>\n<span>ajax</span><span>(</span><span>'/api/users.json'</span><span>)</span>\n  <span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>data</span><span>)</span> <span>{</span>\n    <span>// success</span>\n  <span>}</span><span>)</span>\n  <span>.</span><span>catch</span><span>(</span><span>function</span><span>(</span><span>err</span><span>)</span> <span>{</span>\n    <span>// error</span>\n  <span>}</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>在链式调用中，每个 then 方法都会返回一个全新的 Promise 对象。也就是说链式调用中的 catch 其实是给它前面一个 then 方法返回的 Promise 对象指定失败回调，并不是直接给第一个 Promise 对象指定的。</p>\n<p>但由于在同一个 Promise 链中，Promise 对象的错误具有「冒泡」性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个 catch 语句捕获。（通过 then 方法的第二个参数来捕获异常的话，不具有这种功能）</p>\n<div><pre><code><span>ajax</span><span>(</span><span>'/api/users.json'</span><span>)</span>\n  <span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>value</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>1</span><span>)</span>\n  <span>}</span><span>)</span>\n  <span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>value</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>2</span><span>)</span>\n  <span>}</span><span>)</span>\n  <span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>value</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>3</span><span>)</span>\n  <span>}</span><span>)</span>\n  <span>.</span><span>catch</span><span>(</span><span>function</span><span>(</span><span>error</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'error:'</span><span>,</span> error<span>)</span>\n  <span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>但这种写法也有个问题，就是链路中间但凡有一个方法中抛出异常被 catch 了，那么这个链路下面的 catch 就都不会捕捉到了。</p>\n<p>所以 catch 要控制好，必要的话可以在链路中间单独 catch（一个 Promise 异常会被就近的 catch 捕捉）。</p>\n<p>如下链式调用代码，先请求登录接口，然后请求保存接口：</p>\n<div><pre><code><span>// 情形一</span>\n<span>// 登录接口设置了捕获错误函数，保存接口没有设置</span>\n<span>// 则先捕获登录接口中的错误，如果登录接口没有抛出错误，则捕获保存接口中的错误</span>\n<span>ajax</span><span>(</span><span>'/api/login'</span><span>)</span>\n  <span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>value</span><span>)</span> <span>{</span>\n    <span>return</span> <span>ajax</span><span>(</span><span>'/api/save'</span><span>)</span>\n  <span>}</span><span>)</span>\n  <span>.</span><span>catch</span><span>(</span><span>function</span><span>(</span><span>error</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'error:'</span><span>,</span> error<span>)</span>\n  <span>}</span><span>)</span>\n\n<span>// 情形二</span>\n<span>// 登录接口和保存接口都设置了捕获错误函数</span>\n<span>// 则各自捕获各自的错误</span>\n<span>ajax</span><span>(</span><span>'/api/login'</span><span>)</span>\n  <span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>value</span><span>)</span> <span>{</span>\n    <span>return</span> <span>ajax</span><span>(</span><span>'/api/save'</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>function</span><span>(</span><span>error</span><span>)</span> <span>{</span> console<span>.</span><span>log</span><span>(</span><span>'error in save:'</span><span>,</span> error<span>)</span> <span>}</span><span>)</span>\n  <span>}</span><span>)</span>\n  <span>.</span><span>catch</span><span>(</span><span>function</span><span>(</span><span>error</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'error in login:'</span><span>,</span> error<span>)</span>\n  <span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h4 id=\"_2-try-catch-无法捕获异步异常。\"> 2）try/catch 无法捕获异步异常。</h4>\n<p>try/catch 能捕获到的仅仅是 try 模块内执行的同步方法的异常，异步方法所产生的异常（例如 Ajax 请求、定时器），都无法被捕获到。</p>\n<div><pre><code><span>try</span> <span>{</span>\n  <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>'同步方法的异常'</span><span>)</span>\n<span>}</span> <span>catch</span> <span>(</span>error<span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>error<span>)</span>\n<span>}</span>\n\n<span>try</span> <span>{</span>\n  <span>setTimeout</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>\n    <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>'异步方法的异常'</span><span>)</span>\n  <span>}</span><span>,</span> <span>500</span><span>)</span>\n<span>}</span> <span>catch</span> <span>(</span>error<span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>error<span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div style=\"text-align: center;\">\n  <img src=\"./assets/try-catch-uncaught-error.png\" alt=\"try/catch 无法捕获异步异常\">\n  <p style=\"text-align: center; color: #888;\">（try/catch 无法捕获异步异常）</p>\n</div>\n<p>要捕获异步异常，就需要借助 Promise 了：</p>\n<div><pre><code><span>const</span> promise <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>function</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>{</span>\n  <span>setTimeout</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>\n    <span>reject</span><span>(</span><span>'异步方法的异常'</span><span>)</span>\n  <span>}</span><span>,</span> <span>500</span><span>)</span>\n<span>}</span><span>)</span>\n\npromise<span>.</span><span>then</span><span>(</span><span>value</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>value<span>)</span>\n<span>}</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>error</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>error<span>)</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"promise-静态方法\"> Promise 静态方法</h3>\n<h4 id=\"promise-resolve\"> Promise.resolve()</h4>\n<p>该方法用于把一个值转换为 Promise 对象。</p>\n<div><pre><code><span>// 将字符串转换为 Promise 对象后，在 fulfilled（操作成功）中可以拿到这个字符串</span>\nPromise<span>.</span><span>resolve</span><span>(</span><span>'foo'</span><span>)</span>\n  <span>.</span><span>then</span><span>(</span><span>function</span> <span>(</span><span>value</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span>value<span>)</span>  <span>// \"foo\"</span>\n  <span>}</span><span>)</span>\n\n<span>// 等价于</span>\n<span>new</span> <span>Promise</span><span>(</span><span>function</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>{</span>\n  <span>resolve</span><span>(</span><span>'foo'</span><span>)</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span>// 如果参数是另一个 Promise 对象，则该 Promise 对象会被原样返回</span>\n<span>const</span> p1 <span>=</span> <span>ajax</span><span>(</span><span>'/api/users.json'</span><span>)</span>\n<span>const</span> p2 <span>=</span> Promise<span>.</span><span>resolve</span><span>(</span>p1<span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>p1 <span>===</span> p2<span>)</span>  <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id=\"promise-reject\"> Promise.reject()</h4>\n<p>该方法用于创建一个「失败」的 Promise 对象。</p>\n<div><pre><code><span>// 无论传入什么数据，它都会成为 rejected（操作失败）的理由</span>\nPromise<span>.</span><span>reject</span><span>(</span><span>new</span> <span>Error</span><span>(</span><span>'rejected'</span><span>)</span><span>)</span>\n  <span>.</span><span>catch</span><span>(</span><span>function</span><span>(</span><span>error</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span>error<span>)</span>  <span>// Error: rejected</span>\n  <span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"promise-并行执行\"> Promise 并行执行</h3>\n<h4 id=\"promise-all\"> Promise.all</h4>\n<p><code>Promise.all</code> 可以将多个 Promise 实例（假定为 <code>p1</code>、<code>p2</code>、<code>p3</code>）包装成一个新的 Promise 实例（假定为 <code>p</code>），适用于同时请求多个接口（相互间没有依赖）的场景。</p>\n<p>成功和失败分成两种情况。</p>\n<ul>\n<li>全部成功：<code>p</code> 的状态变为成功，此时 <code>p1</code>、<code>p2</code>、<code>p3</code> 的返回值组成一个数组（数组中元素顺序就是就是 <code>p1</code>、<code>p2</code>、<code>p3</code> 传入时的顺序），传递给 <code>p</code> 的回调函数。</li>\n<li>只要有一个失败：<code>p</code> 的状态就变为失败，此时第一个被 <code>reject</code> 的实例的返回值，会传递给 <code>p</code> 的回调函数。</li>\n</ul>\n<p>下述代码演示了 <code>Promise.all</code> 的用法：</p>\n<div><pre><code><span>const</span> p1 <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>resolve</span><span>(</span><span>'success 1'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n<span>const</span> p2 <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>resolve</span><span>(</span><span>'success 2'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n<span>const</span> p3 <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>reject</span><span>(</span><span>'fail'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n\n<span>const</span> p <span>=</span> Promise<span>.</span><span>all</span><span>(</span><span>[</span>p1<span>,</span> p2<span>]</span><span>)</span><span>.</span><span>then</span><span>(</span><span>result</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>result<span>)</span><span>;</span>\n<span>}</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>error</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>error<span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n<span>// ['success 1'. 'success 2']</span>\n\nPromise<span>.</span><span>all</span><span>(</span><span>[</span>p1<span>,</span> p2<span>,</span> p3<span>]</span><span>)</span><span>.</span><span>then</span><span>(</span><span>result</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>result<span>)</span><span>;</span>\n<span>}</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>error</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>error<span>)</span><span>;</span>\n<span>}</span><span>)</span>\n<span>// 'fail'</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h4 id=\"promise-race\"> Promise.race</h4>\n<p>顾名思义，<code>Promise.race</code> 就是赛跑的意思，意思就是说，<code>Promise.race([p1, p2, p3])</code> 里面<strong>哪个结果获得的快</strong>，就返回那个结果，不管结果本身时成功状态还是失败状态。</p>\n<p>下述代码演示了 <code>Promise.race</code> 的用法：</p>\n<div><pre><code><span>let</span> p1 <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n    <span>resolve</span><span>(</span><span>'success'</span><span>)</span><span>;</span>\n  <span>}</span><span>,</span> <span>1000</span><span>)</span>\n<span>}</span><span>)</span><span>;</span>\n<span>let</span> p2 <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n  <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n    <span>reject</span><span>(</span><span>'fail'</span><span>)</span><span>;</span>\n  <span>}</span><span>,</span> <span>500</span><span>)</span>\n<span>}</span><span>)</span><span>;</span>\n\nPromise<span>.</span><span>race</span><span>(</span><span>[</span>p1<span>,</span> p2<span>]</span><span>)</span><span>.</span><span>then</span><span>(</span><span>result</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>result<span>)</span><span>;</span>\n<span>}</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>error</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>error<span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n<span>// 'fail'</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id=\"async-await\"> async/await</h2>\n<p>async/await 是 ES7 的新标准，也是用来处理异步的，是目前异步的终极解决方案。它其实是 Generator 函数的改进，背后原理就是 Promise。</p>\n<p><strong>async 意义</strong>：</p>\n<ol>\n<li>在函数前加上 async，函数的任何返回值都会被包装成 Promise</li>\n<li>函数内部引入了 await，如果不用 async 会报错</li>\n</ol>\n<p><strong>await 意义</strong>：</p>\n<ol>\n<li>求值关键字，计算返回的 Promise 中的值，或者表达式（<code>await 100*100</code>）</li>\n<li>阻塞当前线程</li>\n</ol>\n<h3 id=\"基础用法-2\"> 基础用法</h3>\n<p>下述代码演示了 async/await 基础用法：</p>\n<p>这段代码主要体现了：await 会阻塞后面的代码，等主程序执行完，再回来执行。</p>\n<p>此外，await 后面既可以是一个 async 函数（返回 Promise 对象），也可以是一个正常函数。</p>\n<div><pre><code><span>async</span> <span>function</span> <span>f1</span><span>(</span><span>)</span> <span>{</span>\n  <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n    <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span><span>resolve</span><span>(</span><span>'world'</span><span>)</span><span>}</span><span>,</span> <span>2000</span><span>)</span><span>;</span>\n  <span>}</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>async</span> <span>function</span> <span>f2</span><span>(</span><span>)</span> <span>{</span>\n  <span>var</span> result <span>=</span> <span>await</span> <span>f1</span><span>(</span><span>)</span><span>;</span>\n  <span>// 阻塞</span>\n  console<span>.</span><span>log</span><span>(</span><span>'hello'</span><span>)</span><span>;</span>\n  console<span>.</span><span>log</span><span>(</span>result<span>)</span><span>;</span>\n<span>}</span>\n\n<span>f2</span><span>(</span><span>)</span><span>;</span>\n<span>// 等待两秒后，才依次打印出 'hello'，'world'</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id=\"错误处理\"> 错误处理</h3>\n<p>async/await 中的错误处理需要通过 try/catch 来实现，否则一旦 <code>reject</code>，会直接抛出错误（<code>Uncaught (in promise) xxx</code>），后面的代码就都不会执行了。</p>\n<p>async/await 结合 try/catch 的代码如下所示：</p>\n<div><pre><code><span>async</span> <span>function</span> <span>f1</span><span>(</span><span>)</span> <span>{</span>\n  <span>return</span> Promise<span>.</span><span>reject</span><span>(</span><span>'fail'</span><span>)</span><span>;</span>\n  <span>// 与下面代码等价</span>\n  <span>// return new Promise((resolve, reject) => {reject('fail')})</span>\n<span>}</span>\n\n<span>async</span> <span>function</span> <span>f2</span><span>(</span><span>)</span> <span>{</span>\n  <span>try</span> <span>{</span>\n    <span>let</span> result <span>=</span> <span>await</span> <span>f1</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span>e<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>f2</span><span>(</span><span>)</span><span>;</span>\n<span>// 'fail'</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id=\"总结\"> 总结</h2>\n<p>本文简单介绍了 Promise 与 async/await 的用法，如果需要了解更多，可以阅读阮一峰老师编写的《ES6标准入门（第3版）》中 <a href=\"https://es6.ruanyifeng.com/#docs/promise\" title=\"Promise 对象 - ECMAScript 6入门\" target=\"_blank\" rel=\"noopener noreferrer\">Promise 对象</a> 和 <a href=\"https://es6.ruanyifeng.com/#docs/async\" title=\"async 函数 - ECMAScript 6入门\" target=\"_blank\" rel=\"noopener noreferrer\">async 函数</a> 两个章节。</p>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li>《ES6标准入门（第3版）》</li>\n<li><a href=\"https://dev.to/lydiahallie/javascript-visualized-event-loop-3dif\" target=\"_blank\" rel=\"noopener noreferrer\">JavaScript Visualized: Event Loop</a>（很赞）</li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2022-01-06T09:06:13.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "未完待续",
      "url": "https://www.fedbook.cn/frontend-knowledge/javascript/to-be-continued/",
      "id": "https://www.fedbook.cn/frontend-knowledge/javascript/to-be-continued/",
      "content_html": "<h1 id=\"未完待续\"> 未完待续</h1>\n<h2 id=\"知识点正在火速整理中\"> 知识点正在火速整理中</h2>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T07:36:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "TypeScript",
      "url": "https://www.fedbook.cn/frontend-knowledge/typescript/",
      "id": "https://www.fedbook.cn/frontend-knowledge/typescript/",
      "content_html": "<h1 id=\"typescript\"> TypeScript</h1>\n<p><strong>什么是 TypeScript（What）</strong>：</p>\n<p>TypeScript 是 JavaScript 的超集，它不仅包含了 JavaScript 当前主流的 ES5 标准，还包含了 ES6/7/8 等未来的标准以及一些处于实验阶段的语法（例如 decorator 装饰器）。</p>\n<p>TypeScript 为 JavaScript 带来了<strong>强类型</strong>的定义。</p>\n<hr>\n<p><strong>为什么要使用 TypeScript（Why）</strong>：</p>\n<p>TypeScript 强类型的特点可以带来一些好处，它能够：</p>\n<ul>\n<li>规范我们的代码</li>\n<li>代码编译阶段就能及时发现错误</li>\n</ul>\n<hr>\n<p><strong>如何使用 TypeScript（How）</strong>：</p>\n<p>TypeScript 的命令行工具安装方法如下：</p>\n<div><pre><code><span>npm</span> <span>install</span> -g typescript\n</code></pre>\n<div><span>1</span><br></div></div><p>以上命令会在全局环境下安装 <code>tsc</code> 命令，安装完成之后，我们就可以在任何地方执行 <code>tsc</code> 命令了。</p>\n<p>TypeScript 无法直接在浏览器中运行，所以我们需要将它编译为 JavaScript，编译一个 TypeScript 文件很简单：</p>\n<div><pre><code>tsc hello.ts\n</code></pre>\n<div><span>1</span><br></div></div><p>执行完上述命令后，会在当前目录生成一个 <code>hello.js</code> 文件，然后就可以使用命令 <code>node hello.js</code> 来执行该文件。</p>\n<p>官方也提供了一个在线开发 TypeScript 的云环境 —— Playground：</p>\n<ul>\n<li><a href=\"https://www.typescriptlang.org/zh/play\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看中文版地址</a></li>\n<li><a href=\"https://www.typescriptlang.org/play/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看英文版地址</a></li>\n</ul>\n<blockquote>\n<p>我们约定使用 TypeScript 编写的文件以 .ts 为后缀，用 TypeScript 编写 React 时，以 .tsx 为后缀。</p>\n</blockquote>\n<hr>\n<p>关于 TypeScript 的知识点，主要参考：</p>\n<ul>\n<li>《<a href=\"http://ts.xcatliu.com/\" target=\"_blank\" rel=\"noopener noreferrer\">TypeScript 入门教程（网友学习笔记）</a>》</li>\n<li>《<a href=\"https://zhongsp.gitbooks.io/typescript-handbook/content/\" target=\"_blank\" rel=\"noopener noreferrer\">TypeScript Handbook（非官方中文版）</a>》</li>\n<li>《<a href=\"https://www.typescriptlang.org/\" target=\"_blank\" rel=\"noopener noreferrer\">TypeScript（官方手册）</a>》</li>\n</ul>\n<div style=\"text-align: right\">\n  <svg t=\"1625995741539\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"3370\" width=\"64\" height=\"64\"><path d=\"M94.208 94.208v835.584h835.584V94.208H94.208z m634.92096 405.85216v0.012288c8.011776 0.024576 17.119232 0.436224 23.967744 1.179648 27.891712 3.016704 49.6128 15.050752 68.091904 37.715968 9.201664 11.290624 12.34944 16.2304 11.679744 18.343936-0.432128 1.363968-6.746112 5.885952-26.820608 19.21024-19.720192 13.092864-26.07104 17.014784-27.5456 17.014784-1.497088 0-4.614144-3.207168-9.105408-9.365504-8.6528-11.855872-17.485824-17.266688-31.13984-19.070976-14.68416-1.9456-27.856896 2.68288-34.308096 12.058624-5.515264 8.011776-6.3488 20.901888-1.96608 30.26944 5.07904 10.848256 14.270464 16.846848 49.494016 32.290816 40.624128 17.813504 61.210624 30.005248 76.204032 45.13792 16.146432 16.293888 24.326144 35.106816 26.83904 61.718528 1.226752 12.972032-0.272384 28.34432-3.98336 40.843264-9.10336 30.640128-33.66912 53.075968-69.67296 63.635456-9.95328 2.9184-19.214336 4.661248-28.37504 5.332992-13.985792 1.030144-34.002944 0.462848-46.051328-1.29024-30.482432-4.442112-64.892928-22.17984-82.051072-42.2912-8.423424-9.873408-19.177472-26.12224-19.177472-28.9792 0-1.380352 0.684032-2.164736 3.391488-3.885056 8.032256-5.103616 54.054912-31.412224 54.94784-31.412224 0.540672 0 2.945024 2.832384 5.341184 6.295552 5.429248 7.839744 18.78016 21.313536 25.567232 25.808896 5.543936 3.672064 12.634112 6.619136 21.051392 8.747008 4.820992 1.202176 7.3728 1.417216 17.891328 1.417216 10.747904-0.004096 12.951552-0.18432 17.760256-1.476608 12.71808-3.422208 22.644736-10.50624 26.851328-19.156992 1.8432-3.7376 1.880064-4.204544 1.880064-13.27104v-9.40032l-2.260992-4.48512c-5.474304-10.866688-17.270784-18.323456-54.56896-34.47808-17.13152-7.421952-38.11328-17.885184-46.30528-23.0912-18.696192-11.880448-31.653888-25.462784-40.157184-42.088448-8.45824-16.533504-9.71776-22.687744-9.73824-47.548416-0.02048-19.462144-0.053248-19.222528 3.975168-31.643648 3.65568-11.272192 11.139072-23.863296 19.400704-32.64512 16.4864-17.524736 40.577024-28.788736 66.367488-31.029248 3.29728-0.313344 7.716864-0.434176 12.52352-0.41984z m-221.92128 3.844096h0.008192c49.670144 0.024576 78.143488 0.196608 78.600192 0.483328 0.86016 0.53248 0.968704 4.855808 0.968704 32.444416v31.827968l-49.563648 0.180224-49.563648 0.180224v140.724224c0 77.400064-0.157696 141.185024-0.372736 141.748224-0.350208 0.948224-4.163584 1.019904-36.41344 1.019904h-36.018176l-0.372736-1.45408c-0.239616-0.79872-0.415744-64.587776-0.41984-141.750272l-0.012288-140.296192-49.5616-0.176128-49.565696-0.180224v-31.451136c0-24.94464 0.172032-31.625216 0.837632-32.288768 0.681984-0.702464 25.976832-0.882688 134.967296-0.991232 21.01248-0.02048 39.92576-0.03072 56.48384-0.02048z\" fill=\"#0288D1\" p-id=\"3371\"></path></svg>\n</div>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2022-04-12T09:36:50.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "this 指向",
      "url": "https://www.fedbook.cn/frontend-knowledge/javascript/this-keyword/",
      "id": "https://www.fedbook.cn/frontend-knowledge/javascript/this-keyword/",
      "content_html": "<h1 id=\"this-指向\"> this 指向</h1>\n<h2 id=\"this-的定义\"> this 的定义</h2>\n<blockquote>\n<ul>\n<li>红宝书（第3版）：this 对象是在运行时基于函数的执行环境绑定的：在全局函数中，this 等于 window，而当函数被作为某个对象的方法调用时，this 等于那个对象。（P182）</li>\n<li>小黄书（上）：this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this 既不指向函数自身也不指向函数的词法作用域（P80）</li>\n<li>MDN：在绝大多数情况下，函数的调用方式决定了 this 的值。（<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this\" title=\"this- JavaScript | MDN\" target=\"_blank\" rel=\"noopener noreferrer\">原链接</a>）</li>\n</ul>\n</blockquote>\n<p>概括一下：</p>\n<p><code>this</code> 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。<code>this</code> 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</p>\n<p>当一个函数被调用时，会创建一个执行上下文。这个执行上下文会包含函数在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。<code>this</code> 就是这个执行上下文的一个属性，会在函数执行的过程中用到。</p>\n<h2 id=\"this-的作用\"> this 的作用</h2>\n<p><code>this</code> 的诞生主要是因为<strong>在对象内部的方法中使用对象内部的属性是一个非常普遍的需求</strong>。</p>\n<p>举个例子来说明：</p>\n<div><pre><code><span>var</span> mySite <span>=</span> <span>{</span> \n  name<span>:</span> <span>\"www.fedbook.cn\"</span><span>,</span>\n  <span>printName</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span>name<span>)</span><span>;</span>\n  <span>}</span>    \n<span>}</span><span>;</span>\n\n<span>let</span> name <span>=</span> <span>\"前端修炼小册\"</span><span>;</span>\nmySite<span>.</span><span>printName</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><details><summary>输出结果</summary>\n<div><pre><code><span>\"前端修炼小册\"</span>\n</code></pre>\n<div><span>1</span><br></div></div></details>\n<details><summary>代码分析</summary>\n<p>由于 <code>mySite</code> 不是一个函数，因此 <code>mySite</code> 当中的 <code>printName</code> 其实是一个全局声明的函数，<code>mySite</code> 当中声明的 <code>name</code> 只是对象的一个属性，也和 <code>printName</code> 没有联系。因此，<code>printName</code> 会通过词法作用域链去它声明的环境（也就是全局环境）中查找 <code>name</code>。</p>\n</details>\n<p>不过按照常理来说，调用 <code>mySite.printName</code> 方法时，方法内部的变量 <code>name</code> 应该使用 <code>mySite</code> 对象中的，因为它们是一个整体，事实上大多数面向对象语言都是这样设计的。</p>\n<p>基于这个需求，JavaScript 就搞出来一套 <code>this</code> 机制。在 JavaScript 中可以使用 <code>this</code> 实现在 <code>printName</code> 函数中访问到 <code>mySite</code> 对象的 <code>name</code> 属性了。</p>\n<p>调整后的代码，如下所示：</p>\n<div><div><br><br><br><div>&nbsp;</div><br><br><br><br><br><br></div><pre><code><span>var</span> mySite <span>=</span> <span>{</span> \n  name<span>:</span> <span>\"www.fedbook.cn\"</span><span>,</span>\n  <span>printName</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>name<span>)</span><span>;</span> <span>// 修改了这一行</span>\n  <span>}</span>    \n<span>}</span>\n\n<span>let</span> name <span>=</span> <span>\"前端修炼小册\"</span><span>;</span>\nmySite<span>.</span><span>printName</span><span>(</span><span>)</span><span>;</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><details><summary>输出结果</summary>\n<div><pre><code><span>\"www.fedbook.cn\"</span>\n</code></pre>\n<div><span>1</span><br></div></div></details>\n<p>接下来进一步学习 <code>this</code>，不过在这之前需要强调一句，作用域链和 <code>this</code> 是两套不同的系统，它们之间基本没太多联系。明确了这点，可以避免你在学习 <code>this</code> 的过程中，和作用域产生一些不必要的关联。</p>\n<h2 id=\"寻找函数的调用位置\"> 寻找函数的调用位置</h2>\n<p>既然 <code>this</code> 的指向完全取决于函数在哪里被调用，就要先寻找函数的调用位置，再去判断函数在执行过程中会如何绑定 <code>this</code>。</p>\n<h3 id=\"通过浏览器调试工具查找\"> 通过浏览器调试工具查找</h3>\n<p>最简单的方法是，通过浏览器的调试工具查看调用栈：给目标函数的第一行代码设置断点，或者直接在目标函数的第一行代码之前插入一条 <code>debugger</code> 语句。运行代码时，调试器会在那个位置暂停，同时会展示当前位置的函数调用列表，这就是你的调用栈，然后找到<strong>栈中第二个元素</strong>，这就是真正的调用位置。</p>\n<p>举个例子，见下方代码，我们要寻找 <code>foo</code> 函数的调用位置。</p>\n<div><div><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br></div><pre><code><span>function</span> <span>baz</span><span>(</span><span>)</span> <span>{</span> \n  console<span>.</span><span>log</span><span>(</span><span>\"baz\"</span><span>)</span><span>;</span>\n  <span>bar</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n<span>function</span> <span>bar</span><span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>\"bar\"</span><span>)</span><span>;</span>\n  <span>foo</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n<span>function</span> <span>foo</span><span>(</span><span>)</span> <span>{</span>\n  <span>debugger</span><span>;</span>\n  console<span>.</span><span>log</span><span>(</span><span>\"foo\"</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>baz</span><span>(</span><span>)</span><span>;</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>使用浏览器的调试工具来查找 <code>foo</code> 函数的调用位置，如下图所示：</p>\n<div style=\"text-align: center;\">\n  <svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"524\" height=\"235\" viewBox=\"0 0 524 235\">\n    <image id=\"find-where-the-function-is-called\" data-name=\"find-where-the-function-is-called\" width=\"524\" height=\"235\" xlink:href=\"data:img/png;base64,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\"/>\n  </svg>\n  <p style=\"text-align: center; color: #888;\">（寻找 foo 函数的调用位置）</p>\n</div>\n<h3 id=\"通过分析代码查找\"> 通过分析代码查找</h3>\n<p>也可以通过阅读代码进行分析，方法是把调用栈想象成一个函数调用链。只不过这种方法非常麻烦并且容易出错，下面的代码演示了这种分析过程。</p>\n<div><pre><code><span>function</span> <span>baz</span><span>(</span><span>)</span> <span>{</span>\n  <span>// 当前的调用栈是：baz</span>\n  <span>// 因此，当前调用位置是全局作用域</span>\n  console<span>.</span><span>log</span><span>(</span><span>\"baz\"</span><span>)</span><span>;</span>\n  <span>bar</span><span>(</span><span>)</span><span>;</span> <span>// &lt;-- bar 的调用位置</span>\n<span>}</span>\n\n<span>function</span> <span>bar</span><span>(</span><span>)</span> <span>{</span>\n  <span>// 当前的调用栈是：baz -> bar</span>\n  <span>// 因此，当前调用位置在 baz 中</span>\n  console<span>.</span><span>log</span><span>(</span><span>\"bar\"</span><span>)</span><span>;</span>\n  <span>foo</span><span>(</span><span>)</span><span>;</span> <span>// &lt;-- foo 的调用位置</span>\n<span>}</span>\n\n<span>function</span> <span>foo</span><span>(</span><span>)</span> <span>{</span>\n  <span>// 当前的调用栈是：baz -> bar -> foo</span>\n  <span>// 因此，当前调用位置在 bar 中</span>\n  <span>debugger</span><span>;</span>\n  console<span>.</span><span>log</span><span>(</span><span>\"foo\"</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>baz</span><span>(</span><span>)</span><span>;</span> <span>// &lt;-- baz 的调用位置</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h2 id=\"在调用位置查找-this-绑定对象\"> 在调用位置查找 this 绑定对象</h2>\n<p>找到函数的调用位置后，按照下面的步骤，就可以判断出 <code>this</code> 的绑定对象。</p>\n<h3 id=\"new-绑定\"> new 绑定</h3>\n<ul>\n<li>Step1 函数是否在 <code>new</code> 中调用（<code>new</code> 绑定）？如果是的话 <code>this</code> 绑定的是新创建的对象。</li>\n</ul>\n<div><pre><code><span>var</span> bar <span>=</span> <span>new</span> <span>foo</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"显式绑定\"> 显式绑定</h3>\n<ul>\n<li>Step2 函数是否通过 <code>call</code>、<code>apply</code>、<code>bind</code>（显式绑定）调用？如果是的话 <code>this</code> 绑定的是指定的对象。</li>\n</ul>\n<div><pre><code><span>var</span> bar <span>=</span> <span>foo</span><span>.</span><span>call</span><span>(</span>obj<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"隐式绑定\"> 隐式绑定</h3>\n<ul>\n<li>Step3 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话 <code>this</code> 绑定的是那个上下文对象。</li>\n</ul>\n<div><pre><code><span>var</span> bar <span>=</span> obj<span>.</span><span>foo</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"默认绑定\"> 默认绑定</h3>\n<ul>\n<li>Step4 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 <code>undefined</code>，否则绑定到全局对象。</li>\n</ul>\n<div><pre><code><span>var</span> bar <span>=</span> <span>foo</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"例外情况\"> 例外情况</h3>\n<p>还有两种例外情况：</p>\n<ul>\n<li>箭头函数不使用 <code>this</code> 的四种标准规则，而是根据外层（函数或者全局）作用域来决定 <code>this</code>。</li>\n<li>非严格模式下的显示绑定，如果你把 <code>null</code> 或者 <code>undefined</code> 作为 <code>this</code> 的绑定对象传入 <code>call</code>、<code>apply</code> 或者 <code>bind</code>，这些值在调用时会被忽略，实际应用的是默认绑定规则。</li>\n</ul>\n<h2 id=\"this-的缺陷以及应对方案\"> this 的缺陷以及应对方案</h2>\n<p><code>this</code> 在使用过程中存在着非常多的坑，下面举两个例子。</p>\n<h3 id=\"嵌套函数中的-this-不会从外层函数中继承\"> 嵌套函数中的 this 不会从外层函数中继承</h3>\n<p>先看下面一段代码，试分析两次 <code>this</code> 打印出来是什么？</p>\n<div><div><br><br><br><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br></div><pre><code><span>var</span> mySite <span>=</span> <span>{</span>\n  name <span>:</span> <span>\"www.fedbook.cn\"</span><span>,</span> \n  <span>showThis</span><span>:</span> <span>function</span><span>(</span><span>)</span><span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>this</span><span>)</span><span>;</span>\n    <span>function</span> <span>printName</span><span>(</span><span>)</span><span>{</span> console<span>.</span><span>log</span><span>(</span><span>this</span><span>)</span> <span>}</span><span>;</span>\n    <span>printName</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span><span>;</span>\nmySite<span>.</span><span>showThis</span><span>(</span><span>)</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><details><summary>输出结果</summary>\n<div><pre><code>▸ <span>{</span>name<span>:</span> <span>\"www.fedbook.cn\"</span><span>,</span> showThis<span>:</span> ƒ<span>}</span>\n▸ Window <span>{</span>parent<span>:</span> Window<span>,</span> opener<span>:</span> <span>null</span><span>,</span> top<span>:</span> Window<span>,</span> length<span>:</span> <span>0</span><span>,</span> frames<span>:</span> Window<span>,</span> …<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div></details>\n<p>执行这段代码后，会发现函数 <code>printName</code> 中的 <code>this</code> 指向的是全局 <code>window</code> 对象，而函数 <code>showThis</code> 中的 <code>this</code> 指向的是 <code>mySite</code> 对象。这就是 JavaScript 中非常容易让人迷惑的地方之一，在实际项目开发中也是很多问题的源头。</p>\n<p>要解决这个问题，可以有两种思路：</p>\n<ul>\n<li>第一种：把 <code>this</code> 保存为一个 <code>self</code> 变量，再利用变量的作用域机制传递给嵌套函数。</li>\n<li>第二种：继续使用 <code>this</code>，但是要把嵌套函数改为箭头函数，因为箭头函数没有自己的执行上下文，所以箭头函数的 <code>this</code> 就是它外层函数的 <code>this</code>。</li>\n</ul>\n<h3 id=\"普通函数中的-this-默认指向全局对象-window\"> 普通函数中的 this 默认指向全局对象 window</h3>\n<p>在默认情况下调用一个函数，其执行上下文中的 <code>this</code> 是默认指向全局对象 window 的。</p>\n<p>不过在实际工作中，有时候我们并不希望函数执行上下文中的 <code>this</code> 默认指向全局对象，因为这样会打破数据的边界，造成一些误操作。如果要让函数执行上下文中的 <code>this</code> 指向某个对象，最好的方式是通过 <code>call</code> 方法来显示调用。</p>\n<p>这个问题也可以通过设置 JavaScript 的「严格模式」来解决。在严格模式下，默认执行一个函数，其函数的执行上下文中的 <code>this</code> 值是 <code>undefined</code>，这就解决上面的问题了。</p>\n<h2 id=\"总结-如何判断-this-指向谁\"> 总结：如何判断 this 指向谁</h2>\n<p>如果要判断一个运行中函数的 <code>this</code> 绑定， 就需要找到这个函数的直接调用位置。找到之后就可以顺序应用下面这四条规则来判断 <code>this</code> 的绑定对象。</p>\n<ul>\n<li><code>new</code> 调用：绑定到新创建的对象。</li>\n<li><code>call</code>、<code>apply</code>、<code>bind</code> 调用：\n<ul>\n<li>严格模式下，绑定到指定的第一个参数。</li>\n<li>非严格模式下，传入 <code>null</code> 和 <code>undefined</code> 时，<code>this</code> 会指向全局对象（浏览器中是 window）；传入原始值（数字，字符串，布尔值）时，<code>this</code> 会指向该原始值的自动包装对象。</li>\n</ul>\n</li>\n<li>对象上的函数调用：绑定到那个对象。</li>\n<li>普通函数调用：在严格模式下绑定到 <code>undefined</code>，否则绑定到全局对象 window。</li>\n</ul>\n<p>ES6 中的箭头函数：不会使用上面这四条绑定规则，而是根据当前的词法作用域来决定 <code>this</code>。具体来说，箭头函数会继承外层函数调用的 <code>this</code> 绑定（ 无论 <code>this</code> 绑定到什么），没有外层函数的情况下则是绑定到全局对象（浏览器中是 window）。</p>\n<p>（完）</p>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T07:36:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "类类型",
      "url": "https://www.fedbook.cn/frontend-knowledge/typescript/class/",
      "id": "https://www.fedbook.cn/frontend-knowledge/typescript/class/",
      "content_html": "<h1 id=\"类类型\"> 类类型</h1>\n<p>ES6 引入 <code>class</code> 关键字后，TypeScript 作为 JavaScript 的超集，也支持了 class 的全部特性，并且还可以对类的属性、方法等进行静态类型检测。</p>\n<h2 id=\"类\"> 类</h2>\n<p>如果使用传统的 JavaScript 代码定义类，我们需要使用函数+原型链的形式进行模拟，如下代码所示：</p>\n<div><pre><code><span>function</span> <span>Dog</span><span>(</span>name<span>:</span> <span>string</span><span>)</span> <span>{</span>\n  <span>this</span><span>.</span>name <span>=</span> name<span>;</span> <span>// ts(2683) 'this' implicitly has type 'any' because it does not have a type annotation.</span>\n<span>}</span>\nDog<span>.</span>prototype<span>.</span><span>bark</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n  <span>console</span><span>.</span><span>log</span><span>(</span><span>'Woof! Woof!'</span><span>)</span><span>;</span>\n<span>}</span><span>;</span>\n\n<span>const</span> dog <span>=</span> <span>new</span> <span>Dog</span><span>(</span><span>'Q'</span><span>)</span><span>;</span> <span>// ts(7009) 'new' expression, whose target lacks a construct signature, implicitly has an 'any' type.</span>\ndog<span>.</span><span>bark</span><span>(</span><span>)</span><span>;</span> <span>// => 'Woof! Woof!'</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>在第 1～ 3 行，我们定义了 <code>Dog</code> 类的构造函数，并在构造函数内部定义了 <code>name</code> 属性，再在第 4 行通过 <code>Dog</code> 的原型链添加 <code>bark</code> 方法。</p>\n<p>如果使用 <code>class</code> 方式定义类，会很方便：</p>\n<div><pre><code><span>class</span> <span>Dog</span> <span>{</span>\n  name<span>:</span> <span>string</span><span>;</span>\n  <span>constructor</span><span>(</span>name<span>:</span> <span>string</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n  <span>}</span>\n\n  <span>bark</span><span>(</span><span>)</span> <span>{</span>\n    <span>console</span><span>.</span><span>log</span><span>(</span><span>'Woof! Woof!'</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>const</span> dog <span>=</span> <span>new</span> <span>Dog</span><span>(</span><span>'Q'</span><span>)</span><span>;</span>\ndog<span>.</span><span>bark</span><span>(</span><span>)</span><span>;</span> <span>// => 'Woof! Woof!'</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id=\"继承\"> 继承</h2>\n<h3 id=\"extend-关键字\"> extend 关键字</h3>\n<p>在 TypeScript 中，使用 <code>extends</code> 关键字就能很方便地定义类继承的抽象模式，如下代码所示：</p>\n<div><pre><code><span>class</span> <span>Animal</span> <span>{</span>\n  type <span>=</span> <span>'Animal'</span><span>;</span>\n  <span>say</span><span>(</span>name<span>:</span> <span>string</span><span>)</span> <span>{</span>\n    <span>console</span><span>.</span><span>log</span><span>(</span><span><span>`</span><span>I'm </span><span><span>${</span>name<span>}</span></span><span>!</span><span>`</span></span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>Dog</span> <span>extends</span> <span>Animal</span> <span>{</span>\n  <span>bark</span><span>(</span><span>)</span> <span>{</span>\n    <span>console</span><span>.</span><span>log</span><span>(</span><span>'Woof! Woof!'</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>const</span> dog <span>=</span> <span>new</span> <span>Dog</span><span>(</span><span>)</span><span>;</span>\ndog<span>.</span><span>bark</span><span>(</span><span>)</span><span>;</span>   <span>// => 'Woof! Woof!'</span>\ndog<span>.</span><span>say</span><span>(</span><span>'Q'</span><span>)</span><span>;</span> <span>// => I'm Q!</span>\ndog<span>.</span>type<span>;</span>     <span>// => Animal</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id=\"super-方法\"> super() 方法</h3>\n<p>TypeScript 规定，如果子类包含一个构造函数，则必须在构造函数中调用 <code>super()</code> 方法，否则会抛出  ts(2377) 的错误。</p>\n<div><div><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br></div><pre><code><span>class</span> <span>Animal</span> <span>{</span>\n  type <span>=</span> <span>'Animal'</span><span>;</span>\n  <span>say</span><span>(</span>name<span>:</span> <span>string</span><span>)</span> <span>{</span>\n    <span>console</span><span>.</span><span>log</span><span>(</span><span><span>`</span><span>I'm </span><span><span>${</span>name<span>}</span></span><span>!</span><span>`</span></span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>Dog</span> <span>extends</span> <span>Animal</span> <span>{</span>\n  name<span>:</span> <span>string</span><span>;</span>\n  <span>constructor</span><span>(</span>name<span>:</span> <span>string</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span><span>)</span><span>;</span> <span>// 添加 super 方法</span>\n    <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n  <span>}</span>\n\n  <span>bark</span><span>(</span><span>)</span> <span>{</span>\n    <span>console</span><span>.</span><span>log</span><span>(</span><span>'Woof! Woof!'</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>super 函数实际上就是调用父类的构造函数，因此如果父类的构造函数要求必须传入参数，那么子类构造函数的 <code>super()</code> 方法也必须传入对应个数和类型的参数，否则也会抛出错误提示：</p>\n<div><div><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br></div><pre><code><span>class</span> <span>Animal</span> <span>{</span>\n  weight<span>:</span> <span>number</span><span>;</span>\n  type <span>=</span> <span>'Animal'</span><span>;</span>\n  <span>constructor</span><span>(</span>weight<span>:</span> <span>number</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>weight <span>=</span> weight<span>;</span>\n  <span>}</span>\n  <span>say</span><span>(</span>name<span>:</span> <span>string</span><span>)</span> <span>{</span>\n    <span>console</span><span>.</span><span>log</span><span>(</span><span><span>`</span><span>I'm </span><span><span>${</span>name<span>}</span></span><span>!</span><span>`</span></span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>Dog</span> <span>extends</span> <span>Animal</span> <span>{</span>\n  name<span>:</span> <span>string</span><span>;</span>\n  <span>constructor</span><span>(</span>name<span>:</span> <span>string</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span><span>20</span><span>)</span><span>;</span>\n    <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n  <span>}</span>\n\n  <span>bark</span><span>(</span><span>)</span> <span>{</span>\n    <span>console</span><span>.</span><span>log</span><span>(</span><span>'Woof! Woof!'</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h2 id=\"公共、私有与受保护的修饰符\"> 公共、私有与受保护的修饰符</h2>\n<p>类属性和方法除了可以通过 <code>extends</code> 被继承之外，还可以通过修饰符控制可访问性。</p>\n<p>在 TypeScript 中就支持 3 种访问修饰符，分别是 <code>public</code>、<code>private</code>、<code>protected</code>。</p>\n<ul>\n<li>public 修饰的是在任何地方可见、公有的属性或方法。</li>\n<li>private 修饰的是仅在同一类中可见、私有的属性或方法。</li>\n<li>protected 修饰的是仅在类自身及子类中可见、受保护的属性或方法。</li>\n</ul>\n<h3 id=\"private-修饰符\"> private 修饰符</h3>\n<p>如果类的属性和方法没有添加访问修饰符，默认都是 <code>public</code>。如果想让有些属性对外不可见，那么可以使用 <code>private</code> 进行设置，如下所示：</p>\n<div><pre><code><span>class</span> <span>Son</span> <span>{</span>\n  <span>public</span> firstName<span>:</span> <span>string</span><span>;</span>\n  <span>private</span> lastName<span>:</span> <span>string</span> <span>=</span> <span>'Stark'</span><span>;</span>\n  <span>constructor</span><span>(</span>firstName<span>:</span> <span>string</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>firstName <span>=</span> firstName<span>;</span>\n    <span>this</span><span>.</span>lastName<span>;</span> <span>// ok</span>\n  <span>}</span>\n<span>}</span>\n\n<span>const</span> son <span>=</span> <span>new</span> <span>Son</span><span>(</span><span>'Tony'</span><span>)</span><span>;</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>son<span>.</span>firstName<span>)</span><span>;</span> <span>//  => \"Tony\"</span>\nson<span>.</span>firstName <span>=</span> <span>'Jack'</span><span>;</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>son<span>.</span>firstName<span>)</span><span>;</span> <span>//  => \"Jack\"</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>son<span>.</span>lastName<span>)</span><span>;</span> <span>// ts(2341) Property 'lastName' is private and only accessible within class 'Son'.</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>对于 <code>private</code> 修饰的私有属性，只可以在类的内部可见，即使是类的实例也不能访问。</p>\n<div><p>注意</p>\n<p>TypeScript 中定义类的私有属性仅仅代表静态类型检测层面的私有。如果我们强制忽略 TypeScript 类型的检查错误，转译且运行 JavaScript 时依旧可以获取到 lastName 属性，这是因为 JavaScript 并不支持真正意义上的私有属性。</p>\n</div>\n<p>目前，JavaScript 类支持 <code>private</code> 修饰符的提案已经到 stage 3 了。或许在不久的将来，私有属性在类型检测和运行阶段都可以被限制为仅在类的内部可见 —— <a href=\"https://github.com/tc39/proposal-private-methods?fileGuid=KLALBzHdpAQfyj7n\" target=\"_blank\" rel=\"noopener noreferrer\">proposal-private-methods</a></p>\n<h3 id=\"protected-修饰符\"> protected 修饰符</h3>\n<p><code>private</code> 是只有类自己内部可见，如果想让子类也可见，可以使用 <code>protected</code> 修饰符，如下所示：</p>\n<div><pre><code><span>class</span> <span>Son</span> <span>{</span>\n  <span>public</span> firstName<span>:</span> <span>string</span><span>;</span>\n  <span>protected</span> lastName<span>:</span> <span>string</span> <span>=</span> <span>'Stark'</span><span>;</span>\n  <span>constructor</span><span>(</span>firstName<span>:</span> <span>string</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>firstName <span>=</span> firstName<span>;</span>\n    <span>this</span><span>.</span>lastName<span>;</span> <span>// ok</span>\n  <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>GrandSon</span> <span>extends</span> <span>Son</span> <span>{</span>\n  <span>constructor</span><span>(</span>firstName<span>:</span> <span>string</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span>firstName<span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>public</span> <span>getMyLastName</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span>lastName<span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>const</span> grandSon <span>=</span> <span>new</span> <span>GrandSon</span><span>(</span><span>'Tony'</span><span>)</span><span>;</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>grandSon<span>.</span><span>getMyLastName</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// => \"Stark\"</span>\ngrandSon<span>.</span>lastName<span>;</span> <span>// ts(2445) Property 'lastName' is protected and only accessible within class 'Son' and its subclasses.</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>我们不能通过子类的实例直接访问父类中 <code>protected</code> 修饰的属性和方法，但是可以通过子类的实例方法进行访问。</p>\n<h2 id=\"只读修饰符\"> 只读修饰符</h2>\n<p><code>public</code> 修饰的属性既公开可见，又可以更改值，如果我们不希望类的属性被更改，则可以使用 <code>readonly</code> 只读修饰符声明类的属性，如下代码所示：</p>\n<div><pre><code><span>class</span> <span>Son</span> <span>{</span>\n  <span>public</span> <span>readonly</span> firstName<span>:</span> <span>string</span><span>;</span>\n  <span>constructor</span><span>(</span>firstName<span>:</span> <span>string</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>firstName <span>=</span> firstName<span>;</span>\n  <span>}</span>\n<span>}</span>\n<span>const</span> son <span>=</span> <span>new</span> <span>Son</span><span>(</span><span>'Tony'</span><span>)</span><span>;</span>\nson<span>.</span>firstName <span>=</span> <span>'Jack'</span><span>;</span> <span>// ts(2540) Cannot assign to 'firstName' because it is a read-only property.</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>注意：如果只读修饰符和可见性修饰符同时出现，我们需要将只读修饰符写在可见修饰符后面。</p>\n<h2 id=\"存取器\"> 存取器</h2>\n<p>除了上边提到的修饰符之外，在 TypeScript 中还可以通过 <code>getter</code>、<code>setter</code> 截取对类成员的读写访问。</p>\n<p>通过对类属性访问的截取，我们可以实现一些特定的访问控制逻辑。如下代码所示：</p>\n<div><div><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br></div><pre><code><span>class</span> <span>Son</span> <span>{</span>\n  <span>public</span> firstName<span>:</span> <span>string</span><span>;</span>\n  <span>protected</span> lastName<span>:</span> <span>string</span> <span>=</span> <span>'Stark'</span><span>;</span>\n  <span>constructor</span><span>(</span>firstName<span>:</span> <span>string</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>firstName <span>=</span> firstName<span>;</span>\n  <span>}</span>\n<span>}</span>\n<span>class</span> <span>GrandSon</span> <span>extends</span> <span>Son</span> <span>{</span>\n  <span>constructor</span><span>(</span>firstName<span>:</span> <span>string</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span>firstName<span>)</span><span>;</span>\n  <span>}</span>\n  <span>get</span> <span>myLastName</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span>lastName<span>;</span>\n  <span>}</span>\n  <span>set</span> <span>myLastName</span><span>(</span>name<span>:</span> <span>string</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>this</span><span>.</span>firstName <span>===</span> <span>'Tony'</span><span>)</span> <span>{</span>\n      <span>this</span><span>.</span>lastName <span>=</span> name<span>;</span> <span>// 只有 firstName 为 tony 时才能修改 lastName</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      <span>console</span><span>.</span><span>error</span><span>(</span><span>'Unable to change myLastName'</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n<span>const</span> grandSon <span>=</span> <span>new</span> <span>GrandSon</span><span>(</span><span>'Tony'</span><span>)</span><span>;</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>grandSon<span>.</span>myLastName<span>)</span><span>;</span> <span>// => \"Stark\"</span>\ngrandSon<span>.</span>myLastName <span>=</span> <span>'Rogers'</span><span>;</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>grandSon<span>.</span>myLastName<span>)</span><span>;</span> <span>// => \"Rogers\"</span>\n<span>const</span> grandSon1 <span>=</span> <span>new</span> <span>GrandSon</span><span>(</span><span>'Tony1'</span><span>)</span><span>;</span>\ngrandSon1<span>.</span>myLastName <span>=</span> <span>'Rogers'</span><span>;</span>  <span>// => \"Unable to change myLastName\"</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>我们可以像访问类属性一样访问 <code>getter</code>，同时也可以像更改属性值一样给 <code>setter</code> 赋值，并执行一些自定义逻辑（<code>.</code> 语法）。</p>\n<h2 id=\"静态属性\"> 静态属性</h2>\n<p>以上介绍的关于类的所有属性和方法，只有类在实例化时才会被初始化。实际上，我们也可以给类定义静态属性和方法。</p>\n<p>因为这些属性存在于类这个特殊的对象上，而不是类的实例上，所以我们可以直接通过类访问静态属性，如下代码所示：</p>\n<div><div><br><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br></div><pre><code><span>class</span> <span>MyArray</span> <span>{</span>\n  <span>static</span> displayName <span>=</span> <span>'MyArray'</span><span>;</span>\n  <span>static</span> <span>isArray</span><span>(</span>obj<span>:</span> <span>unknown</span><span>)</span> <span>{</span>\n    <span>return</span> Object<span>.</span>prototype<span>.</span><span>toString</span><span>.</span><span>call</span><span>(</span>obj<span>)</span><span>.</span><span>slice</span><span>(</span><span>8</span><span>,</span> <span>-</span><span>1</span><span>)</span> <span>===</span> <span>'Array'</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>MyArray<span>.</span>displayName<span>)</span><span>;</span> <span>// => \"MyArray\"</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>MyArray<span>.</span><span>isArray</span><span>(</span><span>[</span><span>]</span><span>)</span><span>)</span><span>;</span> <span>// => true</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>MyArray<span>.</span><span>isArray</span><span>(</span><span>{</span><span>}</span><span>)</span><span>)</span><span>;</span> <span>// => false</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>在第 2～3 行，通过 <code>static</code> 修饰符，我们给 <code>MyArray</code> 类分别定义了一个静态属性 <code>displayName</code> 和静态方法 <code>isArray</code>。之后，我们无须实例化 <code>MyArray</code> 就可以直接访问类上的静态属性和方法了。</p>\n<p>基于静态属性的特性，我们往往会把与类相关的常量、不依赖实例 <code>this</code> 上下文的属性和方法定义为静态属性，从而避免数据冗余，进而提升运行性能。</p>\n<div><p>注意</p>\n<p>上边我们提到了不依赖实例 <code>this</code> 上下文的方法就可以定义成静态方法，这就意味着需要显式注解 <code>this</code> 类型才可以在静态方法中使用 <code>this</code>；非静态方法则不需要显式注解 <code>this</code> 类型，因为 <code>this</code> 的指向默认是类的实例。</p>\n</div>\n<h2 id=\"抽象类\"> 抽象类</h2>\n<p>抽象类是一种不能被实例化仅能被子类继承的特殊类，它使用 <code>abstract</code> 关键字修饰。</p>\n<p>可以使用抽象类定义派生类需要实现的属性和方法，同时也可以定义其他被继承的默认属性和方法，如下代码所示：</p>\n<div><pre><code><span>abstract</span> <span>class</span> <span>Adder</span> <span>{</span>\n  <span>abstract</span> x<span>:</span> <span>number</span><span>;</span>\n  <span>abstract</span> y<span>:</span> <span>number</span><span>;</span>\n  <span>abstract</span> <span>add</span><span>(</span><span>)</span><span>:</span> <span>number</span><span>;</span>\n  displayName <span>=</span> <span>'Adder'</span><span>;</span>\n  <span>addTwice</span><span>(</span><span>)</span><span>:</span> <span>number</span> <span>{</span>\n    <span>return</span> <span>(</span><span>this</span><span>.</span>x <span>+</span> <span>this</span><span>.</span>y<span>)</span> <span>*</span> <span>2</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n<span>class</span> <span>NumAdder</span> <span>extends</span> <span>Adder</span> <span>{</span>\n  x<span>:</span> <span>number</span><span>;</span>\n  y<span>:</span> <span>number</span><span>;</span>\n  <span>constructor</span><span>(</span>x<span>:</span> <span>number</span><span>,</span> y<span>:</span> <span>number</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span><span>)</span><span>;</span>\n    <span>this</span><span>.</span>x <span>=</span> x<span>;</span>\n    <span>this</span><span>.</span>y <span>=</span> y<span>;</span>\n  <span>}</span>\n  <span>add</span><span>(</span><span>)</span><span>:</span> <span>number</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span>x <span>+</span> <span>this</span><span>.</span>y<span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>const</span> numAdder <span>=</span> <span>new</span> <span>NumAdder</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span><span>;</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>numAdder<span>.</span>displayName<span>)</span><span>;</span> <span>// => \"Adder\"</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>numAdder<span>.</span><span>add</span><span>(</span><span>)</span><span>)</span><span>;</span>       <span>// => 3</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>numAdder<span>.</span><span>addTwice</span><span>(</span><span>)</span><span>)</span><span>;</span>  <span>// => 6</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>抽象类本身使用 <code>abstract</code> 关键字修饰，而抽象类里面的抽象属性和抽象方法也使用 <code>abstract</code> 关键字修饰。一旦属性或方法被定义为抽象，它们就必须在子类中全部被实现，否则缺少任意一个都会抛出 ts(2515) 错误。</p>\n<p>同时，在抽象类中也可以定义非抽象属性和非抽象方法，它们会被子类继承，并可以被子类的实例获取。</p>\n<p>因为抽象类不能被实例化，并且子类必须实现继承自抽象类上的抽象属性和方法定义，所以抽象类的作用其实就是对基础逻辑的封装和抽象。</p>\n<p>实际上，我们也可以定义一个描述对象结构的接口类型（后面会讲）抽象类的结构，并通过 <code>implements</code> 关键字约束类的实现。</p>\n<p>使用接口与使用抽象类相比，区别在于接口只能定义类成员的类型，如下代码所示：</p>\n<div><pre><code><span>interface</span> <span>IAdder</span> <span>{</span>\n  x<span>:</span> <span>number</span><span>;</span>\n  y<span>:</span> <span>number</span><span>;</span>\n  <span>add</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>number</span><span>;</span>\n<span>}</span>\n<span>class</span> <span>NumAdder</span> <span>implements</span> <span>IAdder</span> <span>{</span>\n  x<span>:</span> <span>number</span><span>;</span>\n  y<span>:</span> <span>number</span><span>;</span>\n  <span>constructor</span><span>(</span>x<span>:</span> <span>number</span><span>,</span> y<span>:</span> <span>number</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>x <span>=</span> x<span>;</span>\n    <span>this</span><span>.</span>y <span>=</span> y<span>;</span>\n  <span>}</span>\n  <span>add</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span>x <span>+</span> <span>this</span><span>.</span>y<span>;</span>\n  <span>}</span>\n  <span>addTwice</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>(</span><span>this</span><span>.</span>x <span>+</span> <span>this</span><span>.</span>y<span>)</span> <span>*</span> <span>2</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>上述代码中，子类中拥有接口约定的 <code>x</code>、<code>y</code> 属性和 <code>add</code> 方法，以及接口未约定的 <code>addTwice</code> 方法。</p>\n<h2 id=\"类的类型\"> 类的类型</h2>\n<p>类的类型和函数类似，即在声明类的时候，其实也同时声明了一个特殊的类型（确切地讲是一个接口类型），这个类型的名字就是类名，表示类实例的类型；在定义类的时候，我们声明的除构造函数外所有属性、方法的类型就是这个特殊类型的成员。如下代码所示：</p>\n<div><pre><code><span>class</span> <span><span>A</span></span> <span>{</span>\n  name<span>:</span> <span>string</span><span>;</span>\n  <span>constructor</span><span>(</span>name<span>:</span> <span>string</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n  <span>}</span>\n<span>}</span>\n<span>const</span> a1<span>:</span> <span>A</span> <span>=</span> <span>{</span><span>}</span><span>;</span> <span>// ts(2741) Property 'name' is missing in type '{}' but required in type 'A'.</span>\n<span>const</span> a2<span>:</span> <span>A</span> <span>=</span> <span>{</span> name<span>:</span> <span>'a2'</span> <span>}</span><span>;</span> <span>// ok</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>上述代码中，定义类 <code>A</code> 的同时也相当于同时定义了一个包含字符串属性 <code>name</code> 的同名接口类型 <code>A</code>。因此，把一个空对象赋值给类型是 <code>A</code> 的变量 <code>a1</code> 时，就会因为缺少 <code>name</code> 属性而抛出一个 ts(2741) 的错误提示。</p>\n<p>（完）</p>\n",
      "date_published": "2022-04-12T09:36:50.000Z",
      "date_modified": "2022-04-12T09:36:50.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "基础类型",
      "url": "https://www.fedbook.cn/frontend-knowledge/typescript/basic-types/",
      "id": "https://www.fedbook.cn/frontend-knowledge/typescript/basic-types/",
      "content_html": "<h1 id=\"基础类型\"> 基础类型</h1>\n<p>在 TypeScript 语法中，类型的标注主要通过类型后置语法来实现，即用 <code>:</code> 作为分割变量和类型的分隔符。而缺省类型注解的 TypeScript 与 JavaScript 完全一致，因此可以把 TypeScript 代码的编写看作是为 JavaScript 代码添加类型注解。</p>\n<h2 id=\"简单基础类型\"> 简单基础类型</h2>\n<h3 id=\"数值-number\"> 数值（Number）</h3>\n<p>使用 <code>number</code> 类型表示 JavaScript 已经支持或者即将支持的十进制整数、浮点数，以及二进制数、八进制数、十六进制数：</p>\n<div><pre><code><span>let</span> a<span>:</span> <span>number</span> <span>=</span> <span>123</span><span>;</span>        <span>// 十进制整数</span>\n\n<span>let</span> b<span>:</span> <span>number</span> <span>=</span> <span>Number</span><span>(</span><span>42</span><span>)</span><span>;</span> <span>// 十进制整数</span>\n\n<span>let</span> c<span>:</span> <span>number</span> <span>=</span> <span>3.14</span><span>;</span>       <span>// 十进制浮点数</span>\n\n<span>let</span> d<span>:</span> <span>number</span> <span>=</span> <span>0b1010101</span><span>;</span>  <span>// 二进制</span>\n\n<span>let</span> e<span>:</span> <span>number</span> <span>=</span> <span>0o75</span><span>;</span>       <span>// 八进制</span>\n\n<span>let</span> f<span>:</span> <span>number</span> <span>=</span> <span>0xA12</span><span>;</span>      <span>// 十六进制</span>\n\n<span>let</span> g<span>:</span> <span>number</span> <span>=</span> <span>NaN</span><span>;</span>        <span>// 非数字</span>\n\n<span>let</span> h<span>:</span> <span>number</span> <span>=</span> <span>Infinity</span><span>;</span>   <span>// 正无穷大的数值</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>如果需要大整数，那么可以使用 <code>bigint</code> 类型来表示：</p>\n<div><pre><code><span>let</span> big<span>:</span> bigint <span>=</span> <span>100n</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>注意：虽然 <code>number</code> 和 <code>bigint</code> 都表示数字，但是这两个类型不兼容，如果混用会抛出一个类型不兼容的 ts(2322) 错误。</p>\n<h3 id=\"字符串-string\"> 字符串（String）</h3>\n<p>使用 <code>string</code> 表示 JavaScript 中任意的字符串（包括模板字符串）：</p>\n<div><pre><code><span>let</span> firstname<span>:</span> <span>string</span> <span>=</span> <span>'Captain'</span><span>;</span>    <span>// 字符串字面量</span>\n\n<span>let</span> familyname<span>:</span> <span>string</span> <span>=</span> <span>String</span><span>(</span><span>'S'</span><span>)</span><span>;</span> <span>// 显式类型转换</span>\n\n<span>let</span> fullname<span>:</span> <span>string</span> <span>=</span> <span><span>`</span><span>my name is </span><span><span>${</span>firstname<span>}</span></span><span>.</span><span><span>${</span>familyname<span>}</span></span><span>`</span></span><span>;</span> <span>// 模板字符串</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"布尔-boolean\"> 布尔（Boolean）</h3>\n<p>使用 <code>boolean</code> 表示 True 或者 False：</p>\n<div><pre><code><span>const</span> flag1<span>:</span> <span>boolean</span> <span>=</span> <span>true</span><span>;</span>\n\n<span>const</span> flag2<span>:</span> <span>boolean</span> <span>=</span> <span>false</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"symbol\"> Symbol</h3>\n<p>ES6 开始，TypeScript 也支持了新的 <code>Symbol</code> 原始类型，即我们可以通过 <code>Symbol</code> 构造函数，创建一个独一无二的标记。同时还可以使用 <code>symbol</code> 表示这个变量的类型：</p>\n<div><pre><code><span>let</span> sym1<span>:</span> <span>symbol</span> <span>=</span> <span>Symbol</span><span>(</span><span>)</span><span>;</span>\n\n<span>let</span> sym2<span>:</span> <span>symbol</span> <span>=</span> <span>Symbol</span><span>(</span><span>'42'</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"复杂基础类型\"> 复杂基础类型</h2>\n<h3 id=\"数组-array\"> 数组（Array）</h3>\n<p>可以直接使用 <code>[]</code> 的形式定义数组类型：</p>\n<div><pre><code><span>let</span> arrayOfNumber<span>:</span> <span>number</span><span>[</span><span>]</span> <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>;</span>       <span>// 子元素是数字类型的数组</span>\n\n<span>let</span> arrayOfString<span>:</span> <span>string</span><span>[</span><span>]</span> <span>=</span> <span>[</span><span>'x'</span><span>,</span> <span>'y'</span><span>,</span> <span>'z'</span><span>]</span><span>;</span> <span>// 子元素是字符串类型的数组</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>也可以使用 Array 泛型定义数组类型：</p>\n<div><pre><code><span>let</span> arrayOfNumber<span>:</span> <span>Array</span><span>&lt;</span><span>number</span><span>></span> <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>;</span>       <span>// 子元素是数字类型的数组</span>\n\n<span>let</span> arrayOfString<span>:</span> <span>Array</span><span>&lt;</span><span>string</span><span>></span> <span>=</span> <span>[</span><span>'x'</span><span>,</span> <span>'y'</span><span>,</span> <span>'z'</span><span>]</span><span>;</span> <span>// 子元素是字符串类型的数组</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>以上两种方式，更推荐使用 <code>[]</code> 这种形式来定义。<strong>一方面可以避免与 JSX 的语法冲突，另一方面可以减少不少代码量</strong>。</p>\n<h3 id=\"元祖-tuple\"> 元祖（Tuple）</h3>\n<p>TypeScript 的数组和元组转译为 JavaScript 后都是数组，但元组最重要的特性是可以限制数组元素的个数和类型，它特别适合用来实现多值返回。</p>\n<p>在写法上，元祖类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同：</p>\n<div><pre><code><span>const</span> arr1<span>:</span> <span>[</span><span>number</span><span>,</span> <span>string</span><span>]</span> <span>=</span> <span>[</span><span>100</span><span>,</span> <span>'hello'</span><span>]</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>在 JavaScript 中并没有元组的概念，作为一门动态类型语言，它的优势是<strong>天然支持多类型元素数组</strong>。</p>\n<h2 id=\"特殊基础类型\"> 特殊基础类型</h2>\n<h3 id=\"any\"> any</h3>\n<p>any 指的是一个任意类型，它是官方提供的一个选择性绕过静态类型检测的作弊方式。</p>\n<p>我们可以对被注解为 <code>any</code> 类型的变量进行任何操作，包括获取事实上并不存在的属性、方法，并且 TypeScript 还无法检测其属性是否存在、类型是否正确。</p>\n<p>比如可以把任何类型的值赋值给 any 类型的变量，也可以把 any 类型的值赋值给任意类型（除 never 以外）的变量：</p>\n<div><pre><code><span>let</span> val<span>:</span> <span>any</span> <span>=</span> <span>{</span><span>}</span><span>;</span>\n\nval<span>.</span><span>doAnything</span><span>(</span><span>)</span><span>;</span> <span>// 不会提示错误</span>\n\nval <span>=</span> <span>1</span><span>;</span>          <span>// 不会提示错误</span>\n\nval <span>=</span> <span>'x'</span><span>;</span>        <span>// 不会提示错误</span>\n\n<span>let</span> num<span>:</span> <span>number</span> <span>=</span> val<span>;</span> <span>// 不会提示错误</span>\n\n<span>let</span> str<span>:</span> <span>string</span> <span>=</span> val<span>;</span> <span>// 不会提示错误</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>如果我们不想花费过高的成本为复杂的数据添加类型注解，或者已经引入了缺少类型注解的第三方组件库，这时就可以把这些值全部注解为 any 类型，并告诉 TypeScript 选择性地忽略静态类型检测。</p>\n<p>尤其是在将一个基于 JavaScript 的应用改造成 TypeScript 的过程中，我们不得不借助 any 来选择性添加和忽略对某些 JavaScript 模块的静态类型检测，直至逐步替换掉所有的 JavaScript。</p>\n<p>any 类型会在对象的调用链中进行传导，即所有 any 类型的任意属性的类型都是 any：</p>\n<div><pre><code><span>let</span> anything<span>:</span> <span>any</span> <span>=</span> <span>{</span><span>}</span><span>;</span>\n\n<span>let</span> z <span>=</span> anything<span>.</span>x<span>.</span>y<span>.</span>z<span>;</span> <span>// z 类型是 any，不会提示错误</span>\n\n<span>z</span><span>(</span><span>)</span><span>;</span> <span>// 不会提示错误</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>但是从长远来看，使用 any 绝对是一个坏习惯。如果一个 TypeScript 应用中充满了 any，此时静态类型检测基本起不到任何作用，也就是说与直接使用 JavaScript 没有任何区别。<strong>因此，除非有充足的理由，否则我们应该尽量避免使用 any ，并且开启禁用隐式 any 的设置</strong>。</p>\n<h3 id=\"unknown\"> unknown</h3>\n<p>unknown 是 TypeScript 3.0 中添加的一个类型，它主要用来描述类型并不确定的变量。</p>\n<p>比如在多个 if else 条件分支场景下，它可以用来接收不同条件下类型各异的返回值的临时变量：</p>\n<div><pre><code><span>let</span> result<span>:</span> <span>unknown</span><span>;</span>\n<span>if</span> <span>(</span>x<span>)</span> <span>{</span>\n  result <span>=</span> <span>x</span><span>(</span><span>)</span><span>;</span>\n<span>}</span> <span>else</span> <span>if</span> <span>(</span>y<span>)</span> <span>{</span>\n  result <span>=</span> <span>y</span><span>(</span><span>)</span><span>;</span>\n<span>}</span> <span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>与 any 不同的是，unknown 在类型上更安全。比如我们可以将任意类型的值赋值给 unknown，但 unknown 类型的值只能赋值给 unknown 或 any，否则会抛出一个 ts(2322) 错误：</p>\n<div><pre><code><span>let</span> result<span>:</span> <span>unknown</span><span>;</span>\n<span>let</span> num<span>:</span> <span>number</span> <span>=</span> result<span>;</span>   <span>// 提示 ts(2322)</span>\n<span>let</span> anything<span>:</span> <span>any</span> <span>=</span> result<span>;</span> <span>// 不会提示错误</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>使用 unknown 后，TypeScript 会对它做类型检测。但是，如果不缩小类型（Type Narrowing），我们对 unknown 执行的任何操作都会出现如下所示错误：</p>\n<div><pre><code><span>let</span> result<span>:</span> <span>unknown</span><span>;</span>\nresult<span>.</span><span>toFixed</span><span>(</span><span>)</span><span>;</span> <span>// 提示 ts(2571)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p><strong>而所有的类型缩小手段对 unknown 都有效</strong>，例如：</p>\n<div><pre><code><span>let</span> result<span>:</span> <span>unknown</span><span>;</span>\n<span>if</span> <span>(</span><span>typeof</span> result <span>===</span> <span>'number'</span><span>)</span> <span>{</span>\n  result<span>.</span><span>toFixed</span><span>(</span><span>)</span><span>;</span> <span>// 此处 hover result 提示类型是 number，不会提示错误</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"空值-void\"> 空值（void）</h3>\n<p>void 类型在某种程度上来说像是与 any 类型相反，它表示没有任何类型。仅适用于表示没有返回值的函数。即如果该函数没有返回值，那它的类型就是 void。</p>\n<p>声明一个 void 类型的变量几乎没有任何实际用处，因为我们不能把 void 类型的变量值再赋值给除了 any 和 unknown 之外的任何类型变量，且它只能被赋值为 <code>undefined</code>。</p>\n<div><pre><code><span>function</span> <span>foo</span><span>(</span><span>)</span><span>:</span><span>void</span> <span>{</span>\n  <span>console</span><span>.</span><span>log</span><span>(</span><span>'hello word'</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>const</span> result<span>:</span> <span>void</span> <span>=</span> <span>undefined</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"undefined-和-null\"> undefined 和 null</h3>\n<p>这两个是 TypeScript 值与类型关键字同名的唯二例外：</p>\n<div><pre><code><span>let</span> undeclared<span>:</span> <span>undefined</span> <span>=</span> <span>undefined</span><span>;</span> <span>// undefined 类型只能赋值为 undefined</span>\n<span>let</span> nullable<span>:</span> <span>null</span> <span>=</span> <span>null</span><span>;</span>             <span>// null 类型只能赋值为 null</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>单纯声明 undefined 或者 null 类型的变量是比较鸡肋的。</p>\n<p>undefined 的最大价值主要体现在接口类型（后面会单独整理这个知识点）上，它表示一个可缺省、未定义的属性。</p>\n<p>在 TS 中有个比较费解的设计：<strong>我们可以把 undefined 值或类型是 undefined 的变量赋值给 void 类型变量，反过来，类型是 void 但值是 undefined 的变量不能赋值给 undefined 类型</strong>。</p>\n<div><pre><code><span>const</span> userInfo<span>:</span> <span>{</span>\n  id<span>?</span><span>:</span> <span>number</span><span>;</span>\n<span>}</span> <span>=</span> <span>{</span><span>}</span><span>;</span>\n<span>let</span> undeclared<span>:</span> <span>undefined</span> <span>=</span> <span>undefined</span><span>;</span>\n<span>let</span> unusable<span>:</span> <span>void</span> <span>=</span> <span>undefined</span><span>;</span>\nunusable <span>=</span> undeclared<span>;</span> <span>// ok</span>\nundeclared <span>=</span> unusable<span>;</span> <span>// ts(2322)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>而 null 的价值主要体现在接口制定上，它表明对象或属性可能是空值。尤其是在前后端交互的接口，比如 Java Restful、Graphql，任何涉及查询的属性、对象都可能是 null 空对象，如下代码所示：</p>\n<div><pre><code><span>const</span> userInfo<span>:</span> <span>{</span>\n  name<span>:</span> <span>null</span> <span>|</span> <span>string</span>\n<span>}</span> <span>=</span> <span>{</span> name<span>:</span> <span>null</span> <span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>除此之外，undefined 和 null 类型还具备警示意义，它们可以提醒我们针对可能操作这两种（类型）值的情况做容错处理。</p>\n<p>我们需要类型守卫（后面会单独整理这个知识点）在操作之前判断值的类型是否支持当前的操作。类型守卫既能通过类型缩小影响 TypeScript 的类型检测，也能保障 JavaScript 运行时的安全性，如下代码所示：</p>\n<div><pre><code><span>const</span> userInfo<span>:</span> <span>{</span>\n  id<span>?</span><span>:</span> <span>number</span><span>;</span>\n  name<span>?</span><span>:</span> <span>null</span> <span>|</span> <span>string</span>\n<span>}</span> <span>=</span> <span>{</span> id<span>:</span> <span>1</span><span>,</span> name<span>:</span> <span>'Captain'</span> <span>}</span><span>;</span>\n<span>if</span> <span>(</span>userInfo<span>.</span>id <span>!==</span> <span>undefined</span><span>)</span> <span>{</span> <span>// Type Guard</span>\n  userInfo<span>.</span>id<span>.</span><span>toFixed</span><span>(</span><span>)</span><span>;</span> <span>// id 的类型缩小成 number</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>不建议随意使用非空断言（参见类型断言中的内容）来排除值可能为 null 或 undefined 的情况，因为这样很不安全。</p>\n<div><pre><code>userInfo<span>.</span>id<span>!</span><span>.</span><span>toFixed</span><span>(</span><span>)</span><span>;</span> <span>// ok，但不建议</span>\nuserInfo<span>.</span>name<span>!</span><span>.</span><span>toLowerCase</span><span>(</span><span>)</span> <span>// ok，但不建议</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>比非空断言更安全、类型守卫更方便的做法是使用单问号（Optional Chain）、双问号（空值合并），我们可以使用它们来保障代码的安全性，如下代码所示：</p>\n<div><pre><code>userInfo<span>.</span>id<span>?.</span><span>toFixed</span><span>(</span><span>)</span><span>;</span> <span>// Optional Chain</span>\n<span>const</span> myName <span>=</span> userInfo<span>.</span>name<span>??</span> <span><span>`</span><span>my name is </span><span><span>${</span>info<span>.</span>name<span>}</span></span><span>`</span></span><span>;</span> <span>// 空值合并</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"never\"> never</h3>\n<p>never 类型表示的是那些永不存在的值的类型。例如，never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。变量也可能是 never 类型，当他们被用不为真的类型保护所约束时。</p>\n<p>例如，定义一个统一抛出错误的函数，代码示例如下（圆括号后 <code>:</code> + 类型注解，表示函数返回值的类型）：</p>\n<div><pre><code><span>function</span> <span>ThrowError</span><span>(</span>msg<span>:</span> <span>string</span><span>)</span><span>:</span> <span>never</span> <span>{</span>\n  <span>throw</span> <span>Error</span><span>(</span>msg<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>以上函数因为永远不会有返回值，所以它的返回值类型就是 <code>never</code>。</p>\n<p>同样，如果函数代码中是一个死循环，那么这个函数的返回值类型也是 never，如下代码所示：</p>\n<div><pre><code><span>function</span> <span>InfiniteLoop</span><span>(</span><span>)</span><span>:</span> <span>never</span> <span>{</span>\n  <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span><span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>never 是所有类型的子类型，它可以给所有类型赋值，如下代码所示：</p>\n<div><pre><code><span>let</span> Unreachable<span>:</span> <span>never</span> <span>=</span> <span>1</span><span>;</span>      <span>// ts(2322)</span>\nUnreachable <span>=</span> <span>'string'</span><span>;</span>          <span>// ts(2322)</span>\nUnreachable <span>=</span> <span>true</span><span>;</span>              <span>// ts(2322)</span>\n<span>let</span> num<span>:</span> <span>number</span> <span>=</span> Unreachable<span>;</span>   <span>// ok</span>\n<span>let</span> str<span>:</span> <span>string</span> <span>=</span> Unreachable<span>;</span>   <span>// ok</span>\n<span>let</span> bool<span>:</span> <span>boolean</span> <span>=</span> Unreachable<span>;</span> <span>// ok</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>但是反过来，除了 never 自身以外，其他类型（包括 any 在内的类型）都不能为 never 类型赋值。</p>\n<p>在恒为 false 的类型守卫条件判断下，变量的类型将缩小为 never（never 是所有其他类型的子类型，所以是类型缩小为 never，而不是变成 never）。因此，条件判断中的相关操作始终会报无法更正的错误（我们可以把这理解为一种基于静态类型检测的 Dead Code 检测机制），如下代码所示：</p>\n<div><pre><code><span>const</span> str<span>:</span> <span>string</span> <span>=</span> <span>'string'</span><span>;</span>\n<span>if</span> <span>(</span><span>typeof</span> str <span>===</span> <span>'number'</span><span>)</span> <span>{</span>\n  str<span>.</span><span>toLowerCase</span><span>(</span><span>)</span><span>;</span> <span>// Property 'toLowerCase' does not exist on type 'never'.ts(2339)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>基于 never 的特性，我们还可以使用 never 实现一些有意思的功能。比如我们可以把 never 作为接口类型下的属性类型，用来禁止写接口下特定的属性，示例代码如下：</p>\n<div><pre><code><span>const</span> props<span>:</span> <span>{</span>\n  id<span>:</span> <span>number</span><span>,</span>\n  name<span>?</span><span>:</span> <span>never</span>\n<span>}</span> <span>=</span> <span>{</span>\n  id<span>:</span> <span>1</span>\n<span>}</span>\nprops<span>.</span>name <span>=</span> <span>null</span><span>;</span>  <span>// ts(2322))</span>\nprops<span>.</span>name <span>=</span> <span>'str'</span><span>;</span> <span>// ts(2322)</span>\nprops<span>.</span>name <span>=</span> <span>1</span><span>;</span>     <span>// ts(2322)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>此时，无论我们给 <code>props.name</code> 赋什么类型的值，它都会提示类型错误，实际效果等同于 <code>name</code> 只读。</p>\n<h3 id=\"object\"> object</h3>\n<p>object 类型表示非原始类型的类型，即非 number、string、boolean、bigint、symbol、null、undefined 的类型。然而，它也是个没有什么用武之地的类型，如下所示的一个应用场景是用来表示 <code>Object.create</code> 的类型。</p>\n<div><pre><code><span>declare</span> <span>function</span> <span>create</span><span>(</span>o<span>:</span> object <span>|</span> <span>null</span><span>)</span><span>:</span> <span>any</span><span>;</span>\n<span>create</span><span>(</span><span>{</span><span>}</span><span>)</span><span>;</span>         <span>// ok</span>\n<span>create</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>null</span><span>)</span><span>;</span> <span>// ok</span>\n<span>create</span><span>(</span><span>2</span><span>)</span><span>;</span>          <span>// ts(2345)</span>\n<span>create</span><span>(</span><span>'string'</span><span>)</span><span>;</span>   <span>// ts(2345)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"类型断言-type-assertion\"> 类型断言（Type Assertion）</h2>\n<h3 id=\"是什么\"> 是什么</h3>\n<p>类型断言，用于告诉 TypeScript 某个值你非常确定是你断言的类型，而不是 TS 推测出来的类型。</p>\n<p>例如下面的场景：</p>\n<div><pre><code><span>const</span> arrayNumber<span>:</span> <span>number</span><span>[</span><span>]</span> <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>]</span><span>;</span>\n<span>const</span> greaterThan2<span>:</span> <span>number</span> <span>=</span> arrayNumber<span>.</span><span>find</span><span>(</span>num <span>=></span> num <span>></span> <span>2</span><span>)</span><span>;</span> <span>// 提示 ts(2322)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>其中，greaterThan2 一定是一个数字（确切地讲是 3），因为 arrayNumber 中明显有大于 2 的元素，但静态类型对运行时的逻辑无能为力。</p>\n<p>在 TypeScript 看来，greaterThan2 的类型既可能是数字，也可能是 undefined，所以上面的示例中提示了一个 ts(2322) 错误，此时我们不能把类型 undefined 分配给类型 number。</p>\n<p>不过，我们可以使用一种笃定的方式 —— <strong>类型断言</strong>（类似仅作用在类型层面的强制类型转换）告诉 TypeScript 按照我们的方式做类型检查。</p>\n<p>比如，我们可以使用 as 语法做类型断言，如下代码所示：</p>\n<div><pre><code><span>const</span> arrayNumber<span>:</span> <span>number</span><span>[</span><span>]</span> <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>]</span><span>;</span>\n<span>const</span> greaterThan2<span>:</span> <span>number</span> <span>=</span> arrayNumber<span>.</span><span>find</span><span>(</span>num <span>=></span> num <span>></span> <span>2</span><span>)</span> <span>as</span> <span>number</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>又或者是使用尖括号 + 类型的格式做类型断言，如下代码所示：</p>\n<div><pre><code><span>const</span> arrayNumber<span>:</span> <span>number</span><span>[</span><span>]</span> <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>]</span><span>;</span>\n<span>const</span> greaterThan2<span>:</span> <span>number</span> <span>=</span> <span>&lt;</span><span>number</span><span>></span>arrayNumber<span>.</span><span>find</span><span>(</span>num <span>=></span> num <span>></span> <span>2</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>以上两种方式虽然没有任何区别，但是尖括号格式会与 JSX 产生语法冲突，因此更推荐使用 as 语法。</p>\n<h3 id=\"需要满足约束关系\"> 需要满足约束关系</h3>\n<p>类型断言的操作对象必须满足某些约束关系，否则我们将得到一个 ts(2352) 错误，即从类型「源类型」到类型「目标类型」的转换是错误的，因为这两种类型不能充分重叠。</p>\n<p>通俗的说，这种约束关系就是我们不能「指鹿为马」。但可以「指白马为马」或「指马为白马」，这可以很贴切地体现类型断言的约束条件：父子、子父类型之间可以使用类型断言进行转换。</p>\n<div><p>注意</p>\n<p>这个结论完全适用于复杂类型。同时对于 number、string、boolean 原始类型来说，不仅父子类型可以相互断言，父类型相同的类型也可以相互断言，比如 <code>1 as 2</code>、<code>'a' as 'b'</code>、<code>true as false</code>，只不过这样的断言没有任何意义。</p>\n</div>\n<p>另外，any 和 unknown 这两个特殊类型属于万金油，因为它们既可以被断言成任何类型，反过来任何类型也都可以被断言成 any 或 unknown。</p>\n<p>除了可以把特定类型断言成符合约束添加的其他类型之外，还可以使用「字面量值 + as const」语法结构进行常量断言，如下所示：</p>\n<div><pre><code><span>let</span> str <span>=</span> <span>'str'</span> <span>as</span> <span>const</span><span>;</span> <span>// str 类型是 '\"str\"'</span>\n\n<span>const</span> readOnlyArr <span>=</span> <span>[</span><span>0</span><span>,</span> <span>1</span><span>]</span> <span>as</span> <span>const</span><span>;</span> <span>// readOnlyArr 类型是 'readonly [0, 1]'</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"非空断言\"> 非空断言</h3>\n<p>还有一种非空断言，即在值（变量、属性）的后边添加 <code>!</code> 断言操作符，它可以用来排除值为 null、undefined 的情况：</p>\n<div><pre><code><span>let</span> mayNullOrUndefinedOrString<span>:</span> <span>null</span> <span>|</span> <span>undefined</span> <span>|</span> <span>string</span><span>;</span>\nmayNullOrUndefinedOrString<span>!</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span> <span>// ok</span>\nmayNullOrUndefinedOrString<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span> <span>// ts(2531)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>但应该尽量少用，因为无法保证之前一定非空的值，且这种错误只会在运行环境中抛出，静态类型检测是发现不了的。非空断言的替代方案是类型守卫（后面会讲）：</p>\n<div><pre><code><span>let</span> mayNullOrUndefinedOrString<span>:</span> <span>null</span> <span>|</span> <span>undefined</span> <span>|</span> <span>string</span><span>;</span>\n<span>if</span> <span>(</span><span>typeof</span> mayNullOrUndefinedOrString <span>===</span> <span>'string'</span><span>)</span> <span>{</span>\n  mayNullOrUndefinedOrString<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span> <span>// ok</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"应用场景\"> 应用场景</h3>\n<p>比如在获取一个 DOM 元素时，推断出来的类型是 <code>xxElement | null</code>，但是你非常笃定元素一定存在，这个时候就可以使用类型断言，<code>as xxElement</code>。</p>\n<p>（完）</p>\n",
      "date_published": "2022-04-04T13:21:14.000Z",
      "date_modified": "2022-04-04T13:21:14.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "枚举",
      "url": "https://www.fedbook.cn/frontend-knowledge/typescript/enum/",
      "id": "https://www.fedbook.cn/frontend-knowledge/typescript/enum/",
      "content_html": "<h1 id=\"枚举\"> 枚举</h1>\n<h2 id=\"简单例子\"> 简单例子</h2>\n<p>枚举类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。</p>\n<p>格式是 <code>enum</code> + 枚举名字 + 一对花括弧，花括弧里则是被命名了的常量成员。</p>\n<p>比如用枚举类型来实现星期：</p>\n<div><pre><code><span>enum</span> Days <span>{</span>Sun<span>,</span> Mon<span>,</span> Tue<span>,</span> Wed<span>,</span> Thu<span>,</span> Fri<span>,</span> Sat<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>枚举成员会被赋值为从 <code>0</code> 开始递增的数字，同时也会对枚举值到枚举名进行反向映射：</p>\n<div><pre><code><span>enum</span> Days <span>{</span>Sun<span>,</span> Mon<span>,</span> Tue<span>,</span> Wed<span>,</span> Thu<span>,</span> Fri<span>,</span> Sat<span>}</span><span>;</span>\n\n<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>\"Sun\"</span><span>]</span> <span>===</span> <span>0</span><span>)</span><span>;</span> <span>// true</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>\"Mon\"</span><span>]</span> <span>===</span> <span>1</span><span>)</span><span>;</span> <span>// true</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>\"Tue\"</span><span>]</span> <span>===</span> <span>2</span><span>)</span><span>;</span> <span>// true</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>\"Sat\"</span><span>]</span> <span>===</span> <span>6</span><span>)</span><span>;</span> <span>// true</span>\n\n<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>0</span><span>]</span> <span>===</span> <span>\"Sun\"</span><span>)</span><span>;</span> <span>// true</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>1</span><span>]</span> <span>===</span> <span>\"Mon\"</span><span>)</span><span>;</span> <span>// true</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>2</span><span>]</span> <span>===</span> <span>\"Tue\"</span><span>)</span><span>;</span> <span>// true</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>6</span><span>]</span> <span>===</span> <span>\"Sat\"</span><span>)</span><span>;</span> <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>在上述示例中，<code>Days</code> 既可以表示集合，也可以表示集合的类型，所有成员（enum member）的类型都是 <code>Days</code> 的子类型。</p>\n<p>事实上，上面的例子会被编译为：</p>\n<div><pre><code><span>var</span> Days<span>;</span>\n<span>(</span><span>function</span> <span>(</span>Days<span>)</span> <span>{</span>\n  Days<span>[</span>Days<span>[</span><span>\"Sun\"</span><span>]</span> <span>=</span> <span>0</span><span>]</span> <span>=</span> <span>\"Sun\"</span><span>;</span>\n  Days<span>[</span>Days<span>[</span><span>\"Mon\"</span><span>]</span> <span>=</span> <span>1</span><span>]</span> <span>=</span> <span>\"Mon\"</span><span>;</span>\n  Days<span>[</span>Days<span>[</span><span>\"Tue\"</span><span>]</span> <span>=</span> <span>2</span><span>]</span> <span>=</span> <span>\"Tue\"</span><span>;</span>\n  Days<span>[</span>Days<span>[</span><span>\"Wed\"</span><span>]</span> <span>=</span> <span>3</span><span>]</span> <span>=</span> <span>\"Wed\"</span><span>;</span>\n  Days<span>[</span>Days<span>[</span><span>\"Thu\"</span><span>]</span> <span>=</span> <span>4</span><span>]</span> <span>=</span> <span>\"Thu\"</span><span>;</span>\n  Days<span>[</span>Days<span>[</span><span>\"Fri\"</span><span>]</span> <span>=</span> <span>5</span><span>]</span> <span>=</span> <span>\"Fri\"</span><span>;</span>\n  Days<span>[</span>Days<span>[</span><span>\"Sat\"</span><span>]</span> <span>=</span> <span>6</span><span>]</span> <span>=</span> <span>\"Sat\"</span><span>;</span>\n<span>}</span><span>)</span><span>(</span>Days <span>||</span> <span>(</span>Days <span>=</span> <span>{</span><span>}</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>可以看到 <code>Days.Sun</code> 被赋予 <code>0</code> 作为值，<code>Days.Sat</code> 被赋予 <code>6</code> 作为值。</p>\n<p>没错，在 TypeScript 中，可以通过「枚举名字.常量命名」的格式获取枚举集合里的成员。</p>\n<h2 id=\"手动赋值\"> 手动赋值</h2>\n<p>我们也可以给枚举项手动赋值：</p>\n<div><pre><code><span>enum</span> Days <span>{</span>Sun <span>=</span> <span>7</span><span>,</span> Mon <span>=</span> <span>1</span><span>,</span> Tue<span>,</span> Wed<span>,</span> Thu<span>,</span> Fri<span>,</span> Sat<span>}</span><span>;</span>\n\n<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>\"Sun\"</span><span>]</span> <span>===</span> <span>7</span><span>)</span><span>;</span> <span>// true</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>\"Mon\"</span><span>]</span> <span>===</span> <span>1</span><span>)</span><span>;</span> <span>// true</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>\"Tue\"</span><span>]</span> <span>===</span> <span>2</span><span>)</span><span>;</span> <span>// true</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>\"Sat\"</span><span>]</span> <span>===</span> <span>6</span><span>)</span><span>;</span> <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面的例子中，未手动赋值的枚举项会接着上一个枚举项递增。</p>\n<p>如果未手动赋值的枚举项与手动赋值的重复了，TypeScript 是不会察觉到这一点的：</p>\n<div><pre><code><span>enum</span> Days <span>{</span>Sun <span>=</span> <span>3</span><span>,</span> Mon <span>=</span> <span>1</span><span>,</span> Tue<span>,</span> Wed<span>,</span> Thu<span>,</span> Fri<span>,</span> Sat<span>}</span><span>;</span>\n\n<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>\"Sun\"</span><span>]</span> <span>===</span> <span>3</span><span>)</span><span>;</span> <span>// true</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>\"Wed\"</span><span>]</span> <span>===</span> <span>3</span><span>)</span><span>;</span> <span>// true</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>3</span><span>]</span> <span>===</span> <span>\"Sun\"</span><span>)</span><span>;</span> <span>// false</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>3</span><span>]</span> <span>===</span> <span>\"Wed\"</span><span>)</span><span>;</span> <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面的例子中，递增到 <code>3</code> 的时候与前面的 <code>Sun</code> 的取值重复了，但是 TypeScript 并没有报错，导致 <code>Days[3]</code> 的值先是 <code>Sun</code>，而后又被 <code>Wed</code> 覆盖了。编译的结果是：</p>\n<div><pre><code><span>var</span> Days<span>;</span>\n<span>(</span><span>function</span> <span>(</span><span>Days</span><span>)</span> <span>{</span>\n  Days<span>[</span>Days<span>[</span><span>\"Sun\"</span><span>]</span> <span>=</span> <span>3</span><span>]</span> <span>=</span> <span>\"Sun\"</span><span>;</span>\n  Days<span>[</span>Days<span>[</span><span>\"Mon\"</span><span>]</span> <span>=</span> <span>1</span><span>]</span> <span>=</span> <span>\"Mon\"</span><span>;</span>\n  Days<span>[</span>Days<span>[</span><span>\"Tue\"</span><span>]</span> <span>=</span> <span>2</span><span>]</span> <span>=</span> <span>\"Tue\"</span><span>;</span>\n  Days<span>[</span>Days<span>[</span><span>\"Wed\"</span><span>]</span> <span>=</span> <span>3</span><span>]</span> <span>=</span> <span>\"Wed\"</span><span>;</span>\n  Days<span>[</span>Days<span>[</span><span>\"Thu\"</span><span>]</span> <span>=</span> <span>4</span><span>]</span> <span>=</span> <span>\"Thu\"</span><span>;</span>\n  Days<span>[</span>Days<span>[</span><span>\"Fri\"</span><span>]</span> <span>=</span> <span>5</span><span>]</span> <span>=</span> <span>\"Fri\"</span><span>;</span>\n  Days<span>[</span>Days<span>[</span><span>\"Sat\"</span><span>]</span> <span>=</span> <span>6</span><span>]</span> <span>=</span> <span>\"Sat\"</span><span>;</span>\n<span>}</span><span>)</span><span>(</span>Days <span>||</span> <span>(</span>Days <span>=</span> <span>{</span><span>}</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>所以使用的时候需要注意，最好不要出现这种覆盖的情况。</p>\n<p>手动赋值的枚举项可以不是数字，此时需要使用类型断言来让 tsc 无视类型检查（编译出的 js 仍然是可用的）：</p>\n<div><pre><code><span>enum</span> Days <span>{</span>Sun <span>=</span> <span>7</span><span>,</span> Mon<span>,</span> Tue<span>,</span> Wed<span>,</span> Thu<span>,</span> Fri<span>,</span> Sat <span>=</span> <span>&lt;</span><span>any</span><span>></span><span>\"S\"</span><span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><div><pre><code><span>var</span> Days<span>;</span>\n<span>(</span><span>function</span> <span>(</span><span>Days</span><span>)</span> <span>{</span>\n  Days<span>[</span>Days<span>[</span><span>\"Sun\"</span><span>]</span> <span>=</span> <span>7</span><span>]</span> <span>=</span> <span>\"Sun\"</span><span>;</span>\n  Days<span>[</span>Days<span>[</span><span>\"Mon\"</span><span>]</span> <span>=</span> <span>8</span><span>]</span> <span>=</span> <span>\"Mon\"</span><span>;</span>\n  Days<span>[</span>Days<span>[</span><span>\"Tue\"</span><span>]</span> <span>=</span> <span>9</span><span>]</span> <span>=</span> <span>\"Tue\"</span><span>;</span>\n  Days<span>[</span>Days<span>[</span><span>\"Wed\"</span><span>]</span> <span>=</span> <span>10</span><span>]</span> <span>=</span> <span>\"Wed\"</span><span>;</span>\n  Days<span>[</span>Days<span>[</span><span>\"Thu\"</span><span>]</span> <span>=</span> <span>11</span><span>]</span> <span>=</span> <span>\"Thu\"</span><span>;</span>\n  Days<span>[</span>Days<span>[</span><span>\"Fri\"</span><span>]</span> <span>=</span> <span>12</span><span>]</span> <span>=</span> <span>\"Fri\"</span><span>;</span>\n  Days<span>[</span>Days<span>[</span><span>\"Sat\"</span><span>]</span> <span>=</span> <span>\"S\"</span><span>]</span> <span>=</span> <span>\"Sat\"</span><span>;</span>\n<span>}</span><span>)</span><span>(</span>Days <span>||</span> <span>(</span>Days <span>=</span> <span>{</span><span>}</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>当然，手动赋值的枚举项也可以为小数或负数，此时后续未手动赋值的项的递增步长仍为 1：</p>\n<div><pre><code><span>enum</span> Days <span>{</span>Sun <span>=</span> <span>7</span><span>,</span> Mon <span>=</span> <span>1.5</span><span>,</span> Tue<span>,</span> Wed<span>,</span> Thu<span>,</span> Fri<span>,</span> Sat<span>}</span><span>;</span>\n\n<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>\"Sun\"</span><span>]</span> <span>===</span> <span>7</span><span>)</span><span>;</span>   <span>// true</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>\"Mon\"</span><span>]</span> <span>===</span> <span>1.5</span><span>)</span><span>;</span> <span>// true</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>\"Tue\"</span><span>]</span> <span>===</span> <span>2.5</span><span>)</span><span>;</span> <span>// true</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>\"Sat\"</span><span>]</span> <span>===</span> <span>6.5</span><span>)</span><span>;</span> <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id=\"常数项和计算所得项\"> 常数项和计算所得项</h2>\n<p>枚举项有两种类型：常数项（constant member）和计算所得项（computed member）。</p>\n<p>前面我们所举的例子都是常数项，一个典型的计算所得项的例子：</p>\n<div><pre><code><span>enum</span> Color <span>{</span>Red<span>,</span> Green<span>,</span> Blue <span>=</span> <span>\"blue\"</span><span>.</span>length<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>上面的例子中，<code>&quot;blue&quot;.length</code> 就是一个计算所得项。</p>\n<p>上面的例子不会报错，但是<strong>如果紧接在计算所得项后面的是未手动赋值的项，那么它就会因为无法获得初始值而报错</strong>：</p>\n<div><pre><code><span>enum</span> Color <span>{</span>Red <span>=</span> <span>\"red\"</span><span>.</span>length<span>,</span> Green<span>,</span> Blue<span>}</span><span>;</span>\n\n<span>// error: Enum member must have initializer.</span>\n<span>// error: Enum member must have initializer.</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>下面是常数项和计算所得项的完整定义，部分引用自<a href=\"https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Enums.html\" target=\"_blank\" rel=\"noopener noreferrer\">中文手册 - 枚举</a>：</p>\n<p>当满足以下条件时，枚举成员被当作是常数：</p>\n<ul>\n<li>不具有初始化函数并且之前的枚举成员是常数。在这种情况下，当前枚举成员的值为上一个枚举成员的值加 <code>1</code>。但第一个枚举元素是个例外。如果它没有初始化方法，那么它的初始值为 <code>0</code>。</li>\n<li>枚举成员使用常数枚举表达式初始化。常数枚举表达式是 TypeScript 表达式的子集，它可以在编译阶段求值。当一个表达式满足下面条件之一时，它就是一个常数枚举表达式：\n<ul>\n<li>数字字面量</li>\n<li>引用之前定义的常数枚举成员（可以是在不同的枚举类型中定义的）如果这个成员是在同一个枚举类型中定义的，可以使用非限定名来引用</li>\n<li>带括号的常数枚举表达式</li>\n<li><code>+</code>，<code>-</code>，<code>~</code> 一元运算符应用于常数枚举表达式</li>\n<li><code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>%</code>，<code>&lt;&lt;</code>，<code>&gt;&gt;</code>，<code>&gt;&gt;&gt;</code>，<code>&amp;</code>，<code>|</code>，<code>^</code> 二元运算符，常数枚举表达式做为其一个操作对象。若常数枚举表达式求值后为 <code>NaN</code> 或 <code>Infinity</code>，则会在编译阶段报错</li>\n</ul>\n</li>\n</ul>\n<p>所有其它情况的枚举成员被当作是需要计算得出的值。</p>\n<h2 id=\"常数枚举\"> 常数枚举</h2>\n<p>常数枚举是使用 <code>const enum</code> 定义的枚举类型：</p>\n<div><pre><code><span>const</span> <span>enum</span> Directions <span>{</span>\n  Up<span>,</span>\n  Down<span>,</span>\n  Left<span>,</span>\n  Right\n<span>}</span>\n\n<span>let</span> directions <span>=</span> <span>[</span>Directions<span>.</span>Up<span>,</span> Directions<span>.</span>Down<span>,</span> Directions<span>.</span>Left<span>,</span> Directions<span>.</span>Right<span>]</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。</p>\n<p>上例的编译结果是：</p>\n<div><pre><code><span>var</span> directions <span>=</span> <span>[</span><span>0</span> <span>/* Up */</span><span>,</span> <span>1</span> <span>/* Down */</span><span>,</span> <span>2</span> <span>/* Left */</span><span>,</span> <span>3</span> <span>/* Right */</span><span>]</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>假如包含了计算成员，则会在编译阶段报错：</p>\n<div><pre><code><span>const</span> <span>enum</span> Color <span>{</span>Red<span>,</span> Green<span>,</span> Blue <span>=</span> <span>\"blue\"</span><span>.</span>length<span>}</span><span>;</span>\n\n<span>// error: In 'const' enum declarations member initializer must be constant expression.</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"外部枚举\"> 外部枚举</h2>\n<p>外部枚举（Ambient Enums）是使用 <code>declare enum</code> 定义的枚举类型：</p>\n<div><pre><code><span>declare</span> <span>enum</span> Directions <span>{</span>\n  Up<span>,</span>\n  Down<span>,</span>\n  Left<span>,</span>\n  Right\n<span>}</span>\n\n<span>let</span> directions <span>=</span> <span>[</span>Directions<span>.</span>Up<span>,</span> Directions<span>.</span>Down<span>,</span> Directions<span>.</span>Left<span>,</span> Directions<span>.</span>Right<span>]</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>之前提到过，<code>declare</code> 定义的类型只会用于编译时的检查，编译结果中会被删除。</p>\n<p>上例的编译结果是：</p>\n<div><pre><code><span>var</span> directions <span>=</span> <span>[</span>Directions<span>.</span>Up<span>,</span> Directions<span>.</span>Down<span>,</span> Directions<span>.</span>Left<span>,</span> Directions<span>.</span>Right<span>]</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>外部枚举与声明语句一样，常出现在声明文件中。</p>\n<p>同时使用 <code>declare</code> 和 <code>const</code> 也是可以的：</p>\n<div><pre><code><span>declare</span> <span>const</span> <span>enum</span> Directions <span>{</span>\n  Up<span>,</span>\n  Down<span>,</span>\n  Left<span>,</span>\n  Right\n<span>}</span>\n\n<span>let</span> directions <span>=</span> <span>[</span>Directions<span>.</span>Up<span>,</span> Directions<span>.</span>Down<span>,</span> Directions<span>.</span>Left<span>,</span> Directions<span>.</span>Right<span>]</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>编译结果：</p>\n<div><pre><code><span>var</span> directions <span>=</span> <span>[</span><span>0</span> <span>/* Up */</span><span>,</span> <span>1</span> <span>/* Down */</span><span>,</span> <span>2</span> <span>/* Left */</span><span>,</span> <span>3</span> <span>/* Right */</span><span>]</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>（完）</p>\n",
      "date_published": "2022-04-12T09:36:50.000Z",
      "date_modified": "2022-04-12T09:36:50.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "泛型",
      "url": "https://www.fedbook.cn/frontend-knowledge/typescript/generics/",
      "id": "https://www.fedbook.cn/frontend-knowledge/typescript/generics/",
      "content_html": "<h1 id=\"泛型\"> 泛型</h1>\n<p>泛型指的是类型参数化，即将原来某种具体的类型进行参数化。和定义函数参数一样，我们可以给泛型定义若干个类型参数，并在调用时给泛型传入明确的类型参数。</p>\n<p>设计泛型的目的在于有效约束类型成员之间的关系，比如函数参数和返回值、类或者接口成员和方法之间的关系。</p>\n<h2 id=\"泛型类型参数\"> 泛型类型参数</h2>\n<p>泛型最常用的场景是用来约束函数参数的类型，我们可以给函数定义若干个被调用时才会传入明确类型的参数。</p>\n<p>比如以下定义的一个 <code>reflect</code> 函数，要求能接收一个任意类型的参数并原封不动地返回参数的值：</p>\n<div><pre><code><span>function</span> <span>reflect</span><span>(</span>param<span>:</span> <span>unknown</span><span>)</span> <span>{</span>\n  <span>return</span> param<span>;</span>\n<span>}</span>\n<span>const</span> str <span>=</span> <span>reflect</span><span>(</span><span>'string'</span><span>)</span><span>;</span> <span>// str 类型是 unknown</span>\n<span>const</span> num <span>=</span> <span>reflect</span><span>(</span><span>1</span><span>)</span><span>;</span> <span>// num 类型 unknown</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>但是这样写以后，无论入参是什么类型，返回值的类型一律都是 <code>unknown</code>。如果希望返回值类型与入参类型一一对应，就需要用到泛型。</p>\n<p>首先用尖括号 <code>&lt;&gt;</code> 给函数定义一个泛型参数 <code>P</code>，然后指定 <code>param</code> 参数的类型为 <code>P</code>。</p>\n<div><pre><code><span>function</span> <span><span>reflect</span><span><span>&lt;</span><span>P</span><span>></span></span></span><span>(</span>param<span>:</span> <span>P</span><span>)</span> <span>{</span>\n  <span>return</span> param<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>然后在调用函数时，通过 <code>&lt;&gt;</code> 语法指定入参类型，如下代码所示：</p>\n<div><pre><code><span>const</span> str <span>=</span> <span><span>reflect</span><span><span>&lt;</span><span>string</span><span>></span></span></span><span>(</span><span>'string'</span><span>)</span><span>;</span> <span>// str 类型是 string</span>\n<span>const</span> num <span>=</span> <span><span>reflect</span><span><span>&lt;</span><span>number</span><span>></span></span></span><span>(</span><span>1</span><span>)</span><span>;</span> <span>// num 类型 number</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>也可以使用泛型显式地注解返回值的类型，比如调用如下所示的 <code>reflect</code> 时，我们可以通过尖括号 <code>&lt;&gt;</code> 语法给泛型参数 <code>P</code> 显式地传入一个明确的类型。</p>\n<div><pre><code><span>function</span> <span><span>reflect</span><span><span>&lt;</span><span>P</span><span>></span></span></span><span>(</span>param<span>:</span> <span>P</span><span>)</span><span>:</span><span>P</span> <span>{</span>\n  <span>return</span> param<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>另外，如果调用泛型函数时受泛型约束的参数有传值，泛型参数的入参可以从参数的类型中进行推断，而无须再显式指定类型（可缺省），既调用的代码可以写成这样：</p>\n<div><pre><code><span>const</span> str <span>=</span> <span>reflect</span><span>(</span><span>'string'</span><span>)</span><span>;</span> <span>// str 类型是 string</span>\n<span>const</span> num <span>=</span> <span>reflect</span><span>(</span><span>1</span><span>)</span><span>;</span> <span>// num 类型 number</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>泛型不仅可以约束函数整个参数的类型，还可以约束参数属性、成员的类型，比如参数的类型可以是数组、对象，如下示例：</p>\n<div><pre><code><span>function</span> <span><span>reflectArray</span><span><span>&lt;</span><span>P</span><span>></span></span></span><span>(</span>param<span>:</span> <span>P</span><span>[</span><span>]</span><span>)</span> <span>{</span>\n  <span>return</span> param<span>;</span>\n<span>}</span>\n<span>const</span> arr <span>=</span> <span>reflectArray</span><span>(</span><span>[</span><span>1</span><span>,</span> <span>'1'</span><span>]</span><span>)</span><span>;</span> <span>// arr 是 (string | number)[]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这里我们约束了 <code>param</code> 的类型是数组，数组的元素类型是泛型入参。</p>\n<p>通过泛型，我们可以约束函数参数和返回值的类型关系。并且可以给函数定义任意个数的泛型入参，如下代码所示：</p>\n<div><pre><code><span>function</span> <span><span>reflectExtraParams</span><span><span>&lt;</span><span>P</span><span>,</span> <span>Q</span><span>></span></span></span><span>(</span>p1<span>:</span> <span>P</span><span>,</span> p2<span>:</span> <span>Q</span><span>)</span><span>:</span> <span>[</span><span>P</span><span>,</span> <span>Q</span><span>]</span> <span>{</span>\n  <span>return</span> <span>[</span>p1<span>,</span> p2<span>]</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>在上述代码中，我们定义了一个拥有两个泛型入参（<code>P</code> 和 <code>Q</code>）的函数 <code>reflectExtraParams</code>，并通过 <code>P</code> 和 <code>Q</code> 约束函数参数 <code>p1</code>、<code>p2</code> 和返回值的类型。</p>\n<h2 id=\"泛型类\"> 泛型类</h2>\n<p>在类的定义中，我们还可以使用泛型用来约束构造函数、属性、方法的类型，如下代码所示：</p>\n<div><pre><code><span>class</span> <span>Memory<span>&lt;</span><span>S</span><span>></span></span> <span>{</span>\n  store<span>:</span> <span>S</span><span>;</span>\n  <span>constructor</span><span>(</span>store<span>:</span> <span>S</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>store <span>=</span> store<span>;</span>\n  <span>}</span>\n  <span>set</span><span>(</span>store<span>:</span> <span>S</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>store <span>=</span> store<span>;</span>\n  <span>}</span>\n  <span>get</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span>store<span>;</span>\n  <span>}</span>\n<span>}</span>\n<span>const</span> numMemory <span>=</span> <span>new</span> <span>Memory<span>&lt;</span><span>number</span><span>></span></span><span>(</span><span>1</span><span>)</span><span>;</span> <span>// &lt;number> 可缺省</span>\n<span>const</span> getNumMemory <span>=</span> numMemory<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>    <span>// 类型是 number</span>\nnumMemory<span>.</span><span>set</span><span>(</span><span>2</span><span>)</span><span>;</span> <span>// 只能写入 number 类型</span>\n\n<span>const</span> strMemory <span>=</span> <span>new</span> <span>Memory</span><span>(</span><span>''</span><span>)</span><span>;</span>        <span>// 缺省 &lt;string></span>\n<span>const</span> getStrMemory <span>=</span> strMemory<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>    <span>// 类型是 string</span>\nstrMemory<span>.</span><span>set</span><span>(</span><span>'string'</span><span>)</span><span>;</span> <span>// 只能写入 string 类型</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>首先，定义了一个支持读写的寄存器类 <code>Memory</code>，并使用泛型约束了 <code>Memory</code> 类的构造器函数、<code>set</code> 和 <code>get</code> 方法形参的类型，最后实例化了泛型入参分别是 <code>number</code> 和 <code>string</code> 类型的两种寄存器。</p>\n<p>泛型类和泛型函数类似的地方在于，在创建类实例时，如果受泛型约束的参数传入了明确值，则泛型入参（确切地说是传入的类型）可缺省。</p>\n<h2 id=\"泛型类型\"> 泛型类型</h2>\n<p>在 TypeScript 中，类型本身就可以被定义为拥有不明确的类型参数的泛型，并且可以接收明确类型作为入参，从而衍生出更具体的类型，比如使用 <code>Array&lt;类型&gt;</code> 的语法来定义数组（子元素）类型，这里的 <code>Array</code> 本身就是一种类型。</p>\n<p>再如下代码所示，为变量 <code>reflectFn</code> 显式添加了泛型类型注解，并将 <code>reflect</code> 函数作为值赋给了它：</p>\n<div><pre><code><span>const</span> reflectFn<span>:</span> <span>&lt;</span><span>P</span><span>></span><span>(</span>param<span>:</span> <span>P</span><span>)</span> <span>=></span> <span>P</span> <span>=</span> reflect<span>;</span> <span>// ok</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>也可以把 <code>reflectFn</code> 的类型注解提取为一个能被复用的类型别名或者接口，如下代码所示：</p>\n<div><pre><code><span>type</span> <span>ReflectFuncton</span> <span>=</span> <span>&lt;</span><span>P</span><span>></span><span>(</span>param<span>:</span> <span>P</span><span>)</span> <span>=></span> <span>P</span><span>;</span> <span>// 类型别名</span>\n<span>interface</span> <span>IReflectFuncton</span> <span>{</span>               <span>// 接口</span>\n  <span>&lt;</span><span>P</span><span>></span><span>(</span>param<span>:</span> <span>P</span><span>)</span><span>:</span> <span>P</span>\n<span>}</span>\n<span>const</span> reflectFn2<span>:</span> ReflectFuncton <span>=</span> reflect<span>;</span>\n<span>const</span> reflectFn3<span>:</span> IReflectFuncton <span>=</span> reflect<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>将类型入参的定义移动到类型别名或接口名称后，此时定义的一个接收具体类型入参后返回一个新类型的类型就是泛型类型。</p>\n<p>如下示例中，定义了两个可以接收入参 <code>P</code> 的泛型类型（<code>GenericReflectFunction</code> 和 <code>IGenericReflectFunction</code> ）。</p>\n<div><pre><code><span>type</span> <span>GenericReflectFunction<span>&lt;</span><span>P</span><span>></span></span> <span>=</span> <span>(</span>param<span>:</span> <span>P</span><span>)</span> <span>=></span> <span>P</span><span>;</span>\n<span>interface</span> <span>IGenericReflectFunction<span>&lt;</span><span>P</span><span>></span></span> <span>{</span>\n  <span>(</span>param<span>:</span> <span>P</span><span>)</span><span>:</span> <span>P</span><span>;</span>\n<span>}</span>\n<span>const</span> reflectFn4<span>:</span> GenericReflectFunction<span>&lt;</span><span>string</span><span>></span> <span>=</span> reflect<span>;</span>  <span>// 具象化泛型</span>\n<span>const</span> reflectFn5<span>:</span> IGenericReflectFunction<span>&lt;</span><span>number</span><span>></span> <span>=</span> reflect<span>;</span> <span>// 具象化泛型</span>\n<span>const</span> reflectFn3Return <span>=</span> <span>reflectFn4</span><span>(</span><span>'string'</span><span>)</span><span>;</span> <span>// 入参和返回值都必须是 string 类型</span>\n<span>const</span> reflectFn4Return <span>=</span> <span>reflectFn5</span><span>(</span><span>1</span><span>)</span><span>;</span> <span>// 入参和返回值都必须是 number 类型</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>在泛型定义中，甚至可以使用一些类型操作符进行运算表达，使得泛型可以根据入参的类型衍生出各异的类型，如下代码所示：</p>\n<div><pre><code><span>type</span> <span>StringOrNumberArray<span>&lt;</span><span>E</span><span>></span></span> <span>=</span> <span>E</span> <span>extends</span> <span><span>string</span></span> <span>|</span> <span>number</span> <span>?</span> <span>E</span><span>[</span><span>]</span> <span>:</span> <span>E</span><span>;</span>\n<span>type</span> <span>StringArray</span> <span>=</span> StringOrNumberArray<span>&lt;</span><span>string</span><span>></span><span>;</span> <span>// 类型是 string[]</span>\n<span>type</span> <span>NumberArray</span> <span>=</span> StringOrNumberArray<span>&lt;</span><span>number</span><span>></span><span>;</span> <span>// 类型是 number[]</span>\n<span>type</span> <span>NeverGot</span> <span>=</span> StringOrNumberArray<span>&lt;</span><span>boolean</span><span>></span><span>;</span>   <span>// 类型是 boolean</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这里使用三目表达式定义了一个泛型，如果入参是 <code>number | string</code> 就会生成一个数组类型，否则就生成入参类型。</p>\n<h2 id=\"泛型约束\"> 泛型约束</h2>\n<p>泛型就像是类型的函数，它可以抽象、封装并接收（类型）入参，而泛型的入参也拥有类似函数入参的特性。因此，我们可以把泛型入参限定在一个相对更明确的集合内，以便对入参进行约束。</p>\n<p>比如最前边提到的原封不动返回参数的 <code>reflect</code> 函数，如果希望把接收参数的类型限定在几种原始类型的集合中，此时就可以使用「泛型入参名 extends 类型」语法达到这个目的，如下代码所示：</p>\n<div><pre><code><span>function</span> <span><span>reflectSpecified</span><span><span>&lt;</span><span>P</span> <span>extends</span> <span>number</span> <span>|</span> <span>string</span> <span>|</span> <span>boolean</span><span>></span></span></span><span>(</span>param<span>:</span> <span>P</span><span>)</span><span>:</span><span>P</span> <span>{</span>\n  <span>return</span> param<span>;</span>\n<span>}</span>\n<span>reflectSpecified</span><span>(</span><span>'string'</span><span>)</span><span>;</span> <span>// ok</span>\n<span>reflectSpecified</span><span>(</span><span>1</span><span>)</span><span>;</span>    <span>// ok</span>\n<span>reflectSpecified</span><span>(</span><span>true</span><span>)</span><span>;</span> <span>// ok</span>\n<span>reflectSpecified</span><span>(</span><span>null</span><span>)</span><span>;</span> <span>// ts(2345) 'null' 不能赋予类型 'number | string | boolean'</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>在上述示例中，我们限定了泛型入参只能是 <code>number | string | boolean</code> 的子集。</p>\n<p>同样，我们也可以把接口泛型入参约束在特定的范围内，如下代码所示：</p>\n<div><pre><code><span>interface</span> <span>ReduxModelSpecified<span>&lt;</span>State <span>extends</span> <span>{</span> id<span>:</span> <span>number</span><span>;</span> name<span>:</span> <span>string</span> <span>}</span><span>></span></span> <span>{</span>\n  state<span>:</span> State\n<span>}</span>\n<span>type</span> <span>ComputedReduxModel1</span> <span>=</span> ReduxModelSpecified<span>&lt;</span><span>{</span> id<span>:</span> <span>number</span><span>;</span> name<span>:</span> <span>string</span><span>;</span> <span>}</span><span>></span><span>;</span> <span>// ok</span>\n<span>type</span> <span>ComputedReduxModel2</span> <span>=</span> ReduxModelSpecified<span>&lt;</span><span>{</span> id<span>:</span> <span>number</span><span>;</span> name<span>:</span> <span>string</span><span>;</span> age<span>:</span> <span>number</span><span>;</span> <span>}</span><span>></span><span>;</span> <span>// ok</span>\n<span>type</span> <span>ComputedReduxModel3</span> <span>=</span> ReduxModelSpecified<span>&lt;</span><span>{</span> id<span>:</span> <span>string</span><span>;</span> name<span>:</span> <span>number</span><span>;</span> <span>}</span><span>></span><span>;</span> <span>// ts(2344)</span>\n<span>type</span> <span>ComputedReduxModel4</span> <span>=</span> ReduxModelSpecified<span>&lt;</span><span>{</span> id<span>:</span> <span>number</span><span>;</span><span>}</span><span>></span><span>;</span> <span>// ts(2344)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>在上述示例中，<code>ReduxModelSpecified</code> 泛型仅接收 <code>{ id: number; name: string }</code> 接口类型的子类型作为入参。</p>\n<p>还可以在多个不同的泛型入参之间设置约束关系，如下代码所示：</p>\n<div><pre><code><span>interface</span> <span>ObjSetter</span> <span>{</span>\n  <span>&lt;</span><span>O</span> <span>extends</span> <span>{</span><span>}</span><span>,</span> <span>K</span> <span>extends</span> <span>keyof</span> <span>O</span><span>,</span> <span>V</span> <span>extends</span> <span><span>O</span></span><span>[</span><span>K</span><span>]</span><span>></span><span>(</span>obj<span>:</span> <span>O</span><span>,</span> key<span>:</span> <span>K</span><span>,</span> value<span>:</span> <span>V</span><span>)</span><span>:</span> <span>V</span><span>;</span> \n<span>}</span>\n<span>const</span> setValueOfObj<span>:</span> <span>ObjSetter</span> <span>=</span> <span>(</span>obj<span>,</span> key<span>,</span> value<span>)</span> <span>=></span> <span>(</span>obj<span>[</span>key<span>]</span> <span>=</span> value<span>)</span><span>;</span>\n<span>setValueOfObj</span><span>(</span><span>{</span> id<span>:</span> <span>1</span><span>,</span> name<span>:</span> <span>'name'</span> <span>}</span><span>,</span> <span>'id'</span><span>,</span> <span>2</span><span>)</span><span>;</span>   <span>// ok</span>\n<span>setValueOfObj</span><span>(</span><span>{</span> id<span>:</span> <span>1</span><span>,</span> name<span>:</span> <span>'name'</span> <span>}</span><span>,</span> <span>'name'</span><span>,</span> <span>'new name'</span><span>)</span><span>;</span> <span>// ok</span>\n<span>setValueOfObj</span><span>(</span><span>{</span> id<span>:</span> <span>1</span><span>,</span> name<span>:</span> <span>'name'</span> <span>}</span><span>,</span> <span>'age'</span><span>,</span> <span>2</span><span>)</span><span>;</span>  <span>// ts(2345)</span>\n<span>setValueOfObj</span><span>(</span><span>{</span> id<span>:</span> <span>1</span><span>,</span> name<span>:</span> <span>'name'</span> <span>}</span><span>,</span> <span>'id'</span><span>,</span> <span>'2'</span><span>)</span><span>;</span> <span>// ts(2345)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>在设置对象属性值的函数类型时，它拥有 3 个泛型入参：第 1 个是对象，第 2 个是第 1 个入参属性名集合的子集，第 3 个是指定属性类型的子类型（这里使用了 <code>keyof</code> 操作符）。</p>\n<p>另外，泛型入参与函数入参还有一个相似的地方在于，它也可以给泛型入参指定默认值（默认类型），且语法和指定函数默认参数完全一致，如下代码所示：</p>\n<div><pre><code><span>interface</span> <span>ReduxModelSpecified2<span>&lt;</span>State <span>=</span> <span>{</span> id<span>:</span> <span>number</span><span>;</span> name<span>:</span> <span>string</span> <span>}</span><span>></span></span> <span>{</span>\n  state<span>:</span> State\n<span>}</span>\n<span>type</span> <span>ComputedReduxModel5</span> <span>=</span> ReduxModelSpecified2<span>;</span> <span>// ok</span>\n<span>type</span> <span>ComputedReduxModel6</span> <span>=</span> ReduxModelSpecified2<span>&lt;</span><span>{</span> id<span>:</span> <span>number</span><span>;</span> name<span>:</span> <span>string</span><span>;</span> <span>}</span><span>></span><span>;</span> <span>// ok</span>\n<span>type</span> <span>ComputedReduxModel7</span> <span>=</span> ReduxModelSpecified<span>;</span>  <span>// ts(2314) 缺少一个类型参数</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>在上述示例中，我们定义了入参有默认类型的泛型 <code>ReduxModelSpecified2</code>，因此使用 <code>ReduxModelSpecified2</code> 时类型入参可缺省。而 <code>ReduxModelSpecified</code> 的入参没有默认值，所以缺省入参时会提示一个类型错误。</p>\n<p>泛型入参的约束与默认值还可以组合使用，如下代码所示：</p>\n<div><pre><code><span>interface</span> <span>ReduxModelMixed<span>&lt;</span>State <span>extends</span> <span>{</span><span>}</span> <span>=</span> <span>{</span> id<span>:</span> <span>number</span><span>;</span> name<span>:</span> <span>string</span> <span>}</span><span>></span></span> <span>{</span>\n  state<span>:</span> State\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这里我们限定了泛型 <code>ReduxModelMixed</code> 入参 <code>State</code> 必须是 <code>{}</code> 类型的子类型，同时也指定了入参缺省时的默认类型是接口类型 <code>{ id: number; name: string; }</code>。</p>\n<p>（完）</p>\n",
      "date_published": "2022-04-12T09:36:50.000Z",
      "date_modified": "2022-04-13T03:45:28.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "函数类型",
      "url": "https://www.fedbook.cn/frontend-knowledge/typescript/function/",
      "id": "https://www.fedbook.cn/frontend-knowledge/typescript/function/",
      "content_html": "<h1 id=\"函数类型\"> 函数类型</h1>\n<h2 id=\"定义函数\"> 定义函数</h2>\n<p>在 JavaScript 中，有两种常见的定义函数的方式 —— 函数声明（Function Declaration）和函数表达式（Function Expression）：</p>\n<div><pre><code><span>// 函数声明</span>\n<span>function</span> <span>sum</span><span>(</span><span>x<span>,</span> y</span><span>)</span> <span>{</span>\n  <span>return</span> x <span>+</span> y<span>;</span>\n<span>}</span>\n\n<span>// 函数表达式</span>\n<span>let</span> <span>mySum</span> <span>=</span> <span>function</span> <span>(</span><span>x<span>,</span> y</span><span>)</span> <span>{</span>\n  <span>return</span> x <span>+</span> y<span>;</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"函数声明\"> 函数声明</h3>\n<p>在 TypeScript 中，函数声明的类型定义较简单：</p>\n<div><pre><code><span>function</span> <span>sum</span><span>(</span>x<span>:</span> <span>number</span><span>,</span> y<span>:</span> <span>number</span><span>)</span><span>:</span> <span>number</span> <span>{</span>\n  <span>return</span> x <span>+</span> y<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>输入多余的（或者少于要求的）参数，是不被允许的：</p>\n<div><pre><code><span>function</span> <span>sum</span><span>(</span>x<span>:</span> <span>number</span><span>,</span> y<span>:</span> <span>number</span><span>)</span><span>:</span> <span>number</span> <span>{</span>\n  <span>return</span> x <span>+</span> y<span>;</span>\n<span>}</span>\n<span>sum</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>;</span>\n\n<span>// error: Expected 2 arguments, but got 3.</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code><span>function</span> <span>sum</span><span>(</span>x<span>:</span> <span>number</span><span>,</span> y<span>:</span> <span>number</span><span>)</span><span>:</span> <span>number</span> <span>{</span>\n  <span>return</span> x <span>+</span> y<span>;</span>\n<span>}</span>\n<span>sum</span><span>(</span><span>1</span><span>)</span><span>;</span>\n\n<span>// error: Expected 2 arguments, but got 1.</span>\n<span>// An argument for 'y' was not provided.</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"函数表达式\"> 函数表达式</h3>\n<p>在 TypeScript 中，函数表达式的类型定义是这样的：</p>\n<div><pre><code><span>let</span> <span>mySum</span> <span>=</span> <span>function</span> <span>(</span>x<span>:</span> <span>number</span><span>,</span> y<span>:</span> <span>number</span><span>)</span><span>:</span> <span>number</span> <span>{</span>\n  <span>return</span> x <span>+</span> y<span>;</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 <code>mySum</code>，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 <code>mySum</code> 添加类型，则应该是这样：</p>\n<div><pre><code><span>let</span> <span>mySum</span><span>:</span> <span>(</span>x<span>:</span> <span>number</span><span>,</span> y<span>:</span> <span>number</span><span>)</span> <span>=></span> <span>number</span> <span>=</span> <span>function</span> <span>(</span>x<span>:</span> <span>number</span><span>,</span> y<span>:</span> <span>number</span><span>)</span><span>:</span> <span>number</span> <span>{</span>\n  <span>return</span> x <span>+</span> y<span>;</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>注意不要混淆了 TypeScript 中的 <code>=&gt;</code> 和 ES6 中的 <code>=&gt;</code>：</p>\n<ul>\n<li>在 TypeScript 的类型定义中，<code>=&gt;</code> 用来表示函数的定义，左边是函数的参数类型，需要用括号括起来，右边是函数的返回值类型。</li>\n<li>在 ES6 中，<code>=&gt;</code> 叫做<a href=\"https://es6.ruanyifeng.com/#docs/function#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0\" target=\"_blank\" rel=\"noopener noreferrer\">箭头函数</a>，是函数的具体实现。</li>\n</ul>\n<h2 id=\"返回值类型\"> 返回值类型</h2>\n<h3 id=\"没有返回值\"> 没有返回值</h3>\n<p>使用 <code>void</code> 类型来表示函数没有返回值的类型，即函数没有显式 <code>return</code>，此时函数的返回值应该是 <code>undefined</code>：</p>\n<div><pre><code><span>function</span> <span>fn1</span><span>(</span><span>)</span><span>:</span> <span>void</span> <span>{</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"可缺省和可推断的返回值类型\"> 可缺省和可推断的返回值类型</h3>\n<p>函数返回值的类型可以在 TypeScript 中被推断出来，即可缺省。</p>\n<p>示例如下：</p>\n<div><pre><code><span>function</span> <span>computeTypes</span><span>(</span>one<span>:</span> <span>string</span><span>,</span> two<span>:</span> <span>number</span><span>)</span> <span>{</span>\n  <span>const</span> nums <span>=</span> <span>[</span>two<span>]</span><span>;</span>\n  <span>const</span> strs <span>=</span> <span>[</span>one<span>]</span>\n  <span>return</span> <span>{</span>\n    nums<span>,</span>\n    strs\n  <span>}</span> <span>// 返回 { nums: number[]; strs: string[] } 的类型 </span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>一般情况下，TypeScript 中的函数返回值类型是可以缺省和推断出来的，但是有些特例需要我们显式声明返回值类型，比如 Generator 函数的返回值。</p>\n<h3 id=\"generator-函数的返回值\"> Generator 函数的返回值</h3>\n<p>ES6 中新增的 Generator 函数在 TypeScript 中也有对应的类型定义。</p>\n<p>Generator 函数返回的是一个 Iterator 迭代器对象，我们可以使用 Generator 的同名接口泛型或者 Iterator 的同名接口泛型表示返回值的类型（Generator 类型继承了 Iterator 类型），示例如下：</p>\n<div><pre><code><span>type</span> <span>AnyType</span> <span>=</span> <span>boolean</span><span>;</span>\n<span>type</span> <span>AnyReturnType</span> <span>=</span> <span>string</span><span>;</span>\n<span>type</span> <span>AnyNextType</span> <span>=</span> <span>number</span><span>;</span>\n<span>function</span> <span>*</span><span>gen</span><span>(</span><span>)</span><span>:</span> Generator<span>&lt;</span>AnyType<span>,</span> AnyReturnType<span>,</span> AnyNextType<span>></span> <span>{</span>\n  <span>const</span> nextValue <span>=</span> <span>yield</span> <span>true</span><span>;</span> <span>// nextValue 类型是 number，yield 后必须是 boolean 类型</span>\n  <span>return</span> <span><span>`</span><span><span>${</span>nextValue<span>}</span></span><span>`</span></span><span>;</span> <span>// 必须返回 string 类型</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"参数类型\"> 参数类型</h2>\n<h3 id=\"可选参数\"> 可选参数</h3>\n<p>前面提到，输入多余的（或者少于要求的）参数，是不允许的。那么如何定义可选的参数呢？</p>\n<p>通过在类型标注的 <code>:</code> 前添加 <code>?</code> 表示该参数是可缺省的：</p>\n<div><pre><code><span>function</span> <span>log</span><span>(</span>x<span>?</span><span>:</span> <span>string</span><span>)</span> <span>{</span>\n  <span>return</span> x<span>;</span>\n<span>}</span>\n\n<span>log</span><span>(</span><span>)</span><span>;</span> <span>// => undefined</span>\n<span>log</span><span>(</span><span>'hello world'</span><span>)</span><span>;</span> <span>// => hello world</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>需要注意的是，<strong>可选参数必须接在必需参数后面。换句话说，可选参数后面不允许再出现必需参数了</strong>。</p>\n<h3 id=\"默认参数\"> 默认参数</h3>\n<p>TypeScript 会根据函数的默认参数的类型来推断函数参数的类型，示例如下：</p>\n<div><pre><code><span>function</span> <span>log</span><span>(</span>x <span>=</span> <span>'hello'</span><span>)</span> <span>{</span>\n  <span>console</span><span>.</span><span>log</span><span>(</span>x<span>)</span><span>;</span>\n<span>}</span>\n\n<span>log</span><span>(</span><span>)</span><span>;</span> <span>// => 'hello'</span>\n<span>log</span><span>(</span><span>'hi'</span><span>)</span><span>;</span> <span>// => 'hi'</span>\n<span>log</span><span>(</span><span>1</span><span>)</span><span>;</span> <span>// ts(2345) Argument of type '1' is not assignable to parameter of type 'string | undefined'</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上述示例中，根据函数的默认参数 <code>'hello'</code> ，TypeScript 会推断出 <code>x</code> 的类型为 <code>string | undefined</code>。</p>\n<p>TypeScript 也可以显式声明默认参数的类型：</p>\n<div><pre><code><span>function</span> <span>log</span><span>(</span>x<span>:</span> <span>string</span> <span>=</span> <span>'hello'</span><span>)</span> <span>{</span>\n  <span>console</span><span>.</span><span>log</span><span>(</span>x<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>对于默认参数，需要注意的是 TypeScript 会将添加了默认值的参数识别为可选参数，但此时就不受「可选参数必须接在必需参数后面」的限制了：</p>\n<div><pre><code><span>function</span> <span>log</span><span>(</span>x<span>:</span> <span>string</span> <span>=</span> <span>'hello'</span><span>,</span> y<span>:</span> <span>string</span><span>)</span> <span>{</span>\n  <span>console</span><span>.</span><span>log</span><span>(</span>x <span>+</span> <span>' '</span> <span>+</span> y<span>)</span><span>;</span>\n<span>}</span>\n\n<span>log</span><span>(</span><span>'hello'</span><span>,</span> <span>'world'</span><span>)</span><span>;</span>\n<span>log</span><span>(</span><span>undefined</span><span>,</span> <span>'world'</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"剩余参数\"> 剩余参数</h3>\n<p>ES6 中，可以使用 <code>...rest</code> 的方式获取函数中的剩余参数（rest 参数）：</p>\n<div><pre><code><span>function</span> <span>push</span><span>(</span>array<span>,</span> <span>...</span>items<span>)</span> <span>{</span>\n  items<span>.</span><span>forEach</span><span>(</span><span>function</span><span>(</span>item<span>)</span> <span>{</span>\n    array<span>.</span><span>push</span><span>(</span>item<span>)</span><span>;</span>\n  <span>}</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>let</span> a<span>:</span> <span>any</span><span>[</span><span>]</span> <span>=</span> <span>[</span><span>]</span><span>;</span>\n<span>push</span><span>(</span>a<span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>事实上，<code>items</code> 是一个数组。所以我们可以用数组的类型来定义它：</p>\n<div><pre><code><span>function</span> <span>push</span><span>(</span>array<span>:</span> <span>any</span><span>[</span><span>]</span><span>,</span> <span>...</span>items<span>:</span> <span>any</span><span>[</span><span>]</span><span>)</span> <span>{</span>\n  items<span>.</span><span>forEach</span><span>(</span><span>function</span><span>(</span>item<span>)</span> <span>{</span>\n    array<span>.</span><span>push</span><span>(</span>item<span>)</span><span>;</span>\n  <span>}</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>let</span> a <span>=</span> <span>[</span><span>]</span><span>;</span>\n<span>push</span><span>(</span>a<span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>注意，rest 参数只能是最后一个参数，关于 rest 参数，可以参考 <a href=\"https://es6.ruanyifeng.com/#docs/function#rest%E5%8F%82%E6%95%B0\" target=\"_blank\" rel=\"noopener noreferrer\">ES6 中的 rest 参数</a>。</p>\n<h2 id=\"this\"> this</h2>\n<p>在 JavaScript 中，函数 this 的指向一直是一个令人头痛的问题。因为 this 的值需要等到函数被调用时才能被确定，而且还能通过一些方法来可以改变 this 的指向。也就是说 this 的类型不固定，它取决于执行时的上下文。</p>\n<p>但是，使用了 TypeScript 后，我们就不用担心这个问题了。通过指定 this 的类型（严格模式下，必须显式指定 this 的类型），当我们错误使用了 this，TypeScript 就会提示我们，如下代码所示：</p>\n<div><pre><code><span>function</span> <span>say</span><span>(</span><span>)</span> <span>{</span>\n  <span>console</span><span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>name<span>)</span><span>;</span> <span>// ts(2683) 'this' implicitly has type 'any' because it does not have a type annotation</span>\n<span>}</span>\n<span>say</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>在上述代码中，如果我们直接调用 say 函数，this 应该指向全局 window 或 global（Node 中）。但是，在 strict 模式下的 TypeScript 中，它会提示 this 的类型是 any，此时就需要我们手动显式指定类型了。</p>\n<p>那么，在 TypeScript 中，我们应该如何声明 this 的类型呢？</p>\n<p>在 TypeScript 中，我们只需要在函数的第一个参数中声明 this 指代的对象（即函数被调用的方式）即可，比如最简单的作为对象的方法的 this 指向，如下代码所示：</p>\n<div><pre><code><span>function</span> <span>say</span><span>(</span><span>this</span><span>:</span> Window<span>,</span> name<span>:</span> <span>string</span><span>)</span> <span>{</span>\n  <span>console</span><span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>name<span>)</span><span>;</span>\n<span>}</span>\nwindow<span>.</span>say <span>=</span> say<span>;</span>\nwindow<span>.</span><span>say</span><span>(</span><span>'hi'</span><span>)</span><span>;</span>\n<span>const</span> obj <span>=</span> <span>{</span>\n  say\n<span>}</span><span>;</span>\nobj<span>.</span><span>say</span><span>(</span><span>'hi'</span><span>)</span><span>;</span> <span>// ts(2684) The 'this' context of type '{ say: (this: Window, name: string) => void; }' is not assignable to method's 'this' of type 'Window'.</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>在上述代码中，我们在 window 对象上增加 say 的属性为函数 say。那么调用 <code>window.say()</code> 时，this 指向即为 window 对象。</p>\n<p>调用 <code>obj.say()</code> 后，此时 TypeScript 检测到 this 的指向不是 window，于是抛出了一个 ts(2684) 错误。</p>\n<p>需要注意的是，如果我们直接调用 <code>say()</code>，this 实际上应该指向全局变量 window，但是因为 TypeScript 无法确定 say 函数被谁调用，所以将 this 的指向默认为 void，也就提示了一个 ts(2684) 错误。</p>\n<div><pre><code><span>say</span><span>(</span><span>'captain'</span><span>)</span><span>;</span> <span>// ts(2684) The 'this' context of type 'void' is not assignable to method's 'this' of type 'Window'</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>此时，我们可以通过调用 <code>window.say()</code> 来避免这个错误，这也是一个安全的设计。因为在 JavaScript 的严格模式下，全局作用域函数中 this 的指向是 undefined。</p>\n<p>同样，定义对象的函数属性时，只要实际调用中 this 的指向与指定的 this 指向不同，TypeScript 就能发现 this 指向的错误，示例代码如下：</p>\n<div><pre><code><span>interface</span> <span>Person</span> <span>{</span>\n  name<span>:</span> <span>string</span><span>;</span>\n  <span>say</span><span>(</span><span>this</span><span>:</span> Person<span>)</span><span>:</span> <span>void</span><span>;</span>\n<span>}</span>\n<span>const</span> person<span>:</span> Person <span>=</span> <span>{</span>\n  name<span>:</span> <span>'captain'</span><span>,</span>\n  <span>say</span><span>(</span><span>)</span> <span>{</span>\n    <span>console</span><span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>name<span>)</span><span>;</span>\n  <span>}</span><span>,</span>\n<span>}</span><span>;</span>\n<span>const</span> fn <span>=</span> person<span>.</span>say<span>;</span>\n<span>fn</span><span>(</span><span>)</span><span>;</span> <span>// ts(2684) The 'this' context of type 'void' is not assignable to method's 'this' of type 'Person'</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><strong>注意：显式注解函数中的 this 类型，它表面上占据了第一个形参的位置，但并不意味着函数真的多了一个参数，因为 TypeScript 转译为 JavaScript 后，「伪形参」this 会被抹掉，这算是 TypeScript 为数不多的特有语法。</strong></p>\n<p>同样，我们也可以显式限定类（class）函数属性中的 this 类型，TypeScript 也能检查出错误的使用方式，如下代码所示：</p>\n<div><pre><code><span>class</span> <span>Component</span> <span>{</span>\n  <span>onClick</span><span>(</span><span>this</span><span>:</span> Component<span>)</span> <span>{</span><span>}</span>\n<span>}</span>\n<span>const</span> component <span>=</span> <span>new</span> <span>Component</span><span>(</span><span>)</span><span>;</span>\n<span>interface</span> <span><span>UI</span></span> <span>{</span>\n  <span>addClickListener</span><span>(</span><span>onClick</span><span>:</span> <span>(</span><span>this</span><span>:</span> <span>void</span><span>)</span> <span>=></span> <span>void</span><span>)</span><span>:</span> <span>void</span><span>;</span>\n<span>}</span>\n<span>const</span> ui<span>:</span> <span>UI</span> <span>=</span> <span>{</span>\n  <span>addClickListener</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n<span>}</span><span>;</span>\nui<span>.</span><span>addClickListener</span><span>(</span><span>new</span> <span>Component</span><span>(</span><span>)</span><span>.</span>onClick<span>)</span><span>;</span> <span>// ts(2345)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面示例中，我们定义的 Component 类的 onClick 函数属性（方法）显式指定了 this 类型是 Component，在第 6 行作为入参传递给 ui 的 addClickListener 方法中，它指定的 this 类型是 void，两个 this 类型不匹配，所以抛出了一个 ts(2345) 错误。</p>\n<p>此外，在链式调用风格的库中，使用 this 也可以很方便地表达出其类型，如下代码所示：</p>\n<div><pre><code><span>class</span> <span>Container</span> <span>{</span>\n  <span>private</span> val<span>:</span> <span>number</span><span>;</span>\n  <span>constructor</span><span>(</span>val<span>:</span> <span>number</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>val <span>=</span> val<span>;</span>\n  <span>}</span>\n  <span>map</span><span>(</span><span>cb</span><span>:</span> <span>(</span>x<span>:</span> <span>number</span><span>)</span> <span>=></span> <span>number</span><span>)</span><span>:</span> <span>this</span> <span>{</span>\n    <span>this</span><span>.</span>val <span>=</span> <span>cb</span><span>(</span><span>this</span><span>.</span>val<span>)</span><span>;</span>\n    <span>return</span> <span>this</span><span>;</span>\n  <span>}</span>\n  <span>log</span><span>(</span><span>)</span><span>:</span> <span>this</span> <span>{</span>\n    <span>console</span><span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>val<span>)</span><span>;</span>\n    <span>return</span> <span>this</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n<span>const</span> instance <span>=</span> <span>new</span> <span>Container</span><span>(</span><span>1</span><span>)</span>\n  <span>.</span><span>map</span><span>(</span><span>(</span>x<span>)</span> <span>=></span> x <span>+</span> <span>1</span><span>)</span>\n  <span>.</span><span>log</span><span>(</span><span>)</span> <span>// => 2</span>\n  <span>.</span><span>map</span><span>(</span><span>(</span>x<span>)</span> <span>=></span> x <span>*</span> <span>3</span><span>)</span>\n  <span>.</span><span>log</span><span>(</span><span>)</span><span>;</span> <span>// => 6  </span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>因为 Container 类中 map、log 等函数属性（方法）未显式指定 this 类型，默认类型是 Container，所以以上方法在被调用时返回的类型也是 Container，this 指向一直是类的实例，它可以一直无限地被链式调用。</p>\n<h2 id=\"函数重载\"> 函数重载</h2>\n<p>JavaScript 是一门动态语言，针对同一个函数，它可以有多种不同类型的参数与返回值，这就是函数的多态。</p>\n<p>而在 TypeScript 中，也可以相应地表达不同类型的参数和返回值的函数，如下代码所示：</p>\n<div><pre><code><span>function</span> <span>convert</span><span>(</span>x<span>:</span> <span>string</span> <span>|</span> <span>number</span> <span>|</span> <span>null</span><span>)</span><span>:</span> <span>string</span> <span>|</span> <span>number</span> <span>|</span> <span>-</span><span>1</span> <span>{</span>\n  <span>if</span> <span>(</span><span>typeof</span> x <span>===</span> <span>'string'</span><span>)</span> <span>{</span>\n    <span>return</span> <span>Number</span><span>(</span>x<span>)</span><span>;</span>\n  <span>}</span>\n  <span>if</span> <span>(</span><span>typeof</span> x <span>===</span> <span>'number'</span><span>)</span> <span>{</span>\n    <span>return</span> <span>String</span><span>(</span>x<span>)</span><span>;</span>\n  <span>}</span>\n  <span>return</span> <span>-</span><span>1</span><span>;</span>\n<span>}</span>\n<span>const</span> x1 <span>=</span> <span>convert</span><span>(</span><span>'1'</span><span>)</span><span>;</span>  <span>// => string | number</span>\n<span>const</span> x2 <span>=</span> <span>convert</span><span>(</span><span>1</span><span>)</span><span>;</span>    <span>// => string | number</span>\n<span>const</span> x3 <span>=</span> <span>convert</span><span>(</span><span>null</span><span>)</span><span>;</span> <span>// => string | number</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>在上述代码中，我们把 <code>convert</code> 函数的 <code>string</code> 类型的值转换为 <code>number</code> 类型，<code>number</code> 类型转换为 <code>string</code> 类型，而将 <code>null</code> 类型转换为数字 <code>-1</code>。此时，<code>x1</code>、<code>x2</code>、<code>x3</code> 的返回值类型都会被推断成 <code>string | number</code>。</p>\n<p>那么，有没有一种办法可以更精确地描述参数与返回值类型约束关系的函数类型呢？有，这就是函数重载（Function Overload），如下示例中 1~3 行定义了三种各不相同的函数类型列表，并描述了不同的参数类型对应不同的返回值类型，而从第 4 行开始才是函数的实现。</p>\n<div><pre><code><span>function</span> <span>convert</span><span>(</span>x<span>:</span> <span>string</span><span>)</span><span>:</span> <span>number</span><span>;</span>\n<span>function</span> <span>convert</span><span>(</span>x<span>:</span> <span>number</span><span>)</span><span>:</span> <span>string</span><span>;</span>\n<span>function</span> <span>convert</span><span>(</span>x<span>:</span> <span>null</span><span>)</span><span>:</span> <span>-</span><span>1</span><span>;</span>\n<span>function</span> <span>convert</span><span>(</span>x<span>:</span> <span>string</span> <span>|</span> <span>number</span> <span>|</span> <span>null</span><span>)</span><span>:</span> <span>any</span> <span>{</span>\n  <span>if</span> <span>(</span><span>typeof</span> x <span>===</span> <span>'string'</span><span>)</span> <span>{</span>\n    <span>return</span> <span>Number</span><span>(</span>x<span>)</span><span>;</span>\n  <span>}</span>\n  <span>if</span> <span>(</span><span>typeof</span> x <span>===</span> <span>'number'</span><span>)</span> <span>{</span>\n    <span>return</span> <span>String</span><span>(</span>x<span>)</span><span>;</span>\n  <span>}</span>\n  <span>return</span> <span>-</span><span>1</span><span>;</span>\n<span>}</span>\n<span>const</span> x1 <span>=</span> <span>convert</span><span>(</span><span>'1'</span><span>)</span><span>;</span>  <span>// => number</span>\n<span>const</span> x2 <span>=</span> <span>convert</span><span>(</span><span>1</span><span>)</span><span>;</span>    <span>// => string</span>\n<span>const</span> x3 <span>=</span> <span>convert</span><span>(</span><span>null</span><span>)</span><span>;</span> <span>// -1</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><blockquote>\n<p>注意：函数重载列表的各个成员（即示例中的 1 ~ 3 行）必须是函数实现（即示例中的第 4 行）的子集</p>\n</blockquote>\n<p>在 convert 函数被调用时，TypeScript 会从上到下查找函数重载列表中与入参类型匹配的类型，并优先使用第一个匹配的重载定义。因此，我们需要把最精确的函数重载放到前面。例如我们在第 13 行传入了字符串 <code>'1'</code>，查找到第 1 行即匹配，而第 14 行传入了数字 <code>1</code>，则查找到第 2 行匹配。</p>\n<h2 id=\"类型谓词-is\"> 类型谓词（is）</h2>\n<p>在 TypeScript 中，函数还支持另外一种特殊的类型描述，如下示例 ：</p>\n<div><pre><code><span>function</span> <span>isString</span><span>(</span>s<span>)</span><span>:</span> s <span>is</span> <span>string</span> <span>{</span> <span>// 类型谓词</span>\n  <span>return</span> <span>typeof</span> s <span>===</span> <span>'string'</span><span>;</span>\n<span>}</span>\n<span>function</span> <span>isNumber</span><span>(</span>n<span>:</span> <span>number</span><span>)</span> <span>{</span>\n  <span>return</span> <span>typeof</span> n <span>===</span> <span>'number'</span><span>;</span>\n<span>}</span>\n<span>function</span> <span>operator</span><span>(</span>x<span>:</span> <span>unknown</span><span>)</span> <span>{</span>\n  <span>if</span><span>(</span><span>isString</span><span>(</span>x<span>)</span><span>)</span> <span>{</span>  <span>// ok x 类型缩小为 string</span>\n  <span>}</span>\n  <span>if</span> <span>(</span><span>isNumber</span><span>(</span>x<span>)</span><span>)</span> <span>{</span> <span>// ts(2345) unknown 不能赋值给 number</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>在上述代码中，在添加返回值类型的地方，我们通过「参数名 + is + 类型」的格式明确表明了参数的类型，进而引起类型缩小，所以类型谓词函数的一个重要的应用场景是实现自定义类型守卫。</p>\n<p>（完）</p>\n",
      "date_published": "2022-04-12T09:36:50.000Z",
      "date_modified": "2022-04-12T09:36:50.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "接口类型与类型别名",
      "url": "https://www.fedbook.cn/frontend-knowledge/typescript/interface-and-type/",
      "id": "https://www.fedbook.cn/frontend-knowledge/typescript/interface-and-type/",
      "content_html": "<h1 id=\"接口类型与类型别名\"> 接口类型与类型别名</h1>\n<p>前面的 TypeScript 基础类型、函数类型和类类型，在 JavaScript 中都有对应的语法。而接口类型与类型别名是 TS 新增的特性，它们能用于描述较为复杂的数据结构，就像代码的文档和注释一样。</p>\n<h2 id=\"interface-接口类型\"> Interface 接口类型</h2>\n<h3 id=\"介绍\"> 介绍</h3>\n<p>TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。</p>\n<h3 id=\"简单的例子\"> 简单的例子</h3>\n<div><pre><code><span>interface</span> <span>Person</span> <span>{</span>\n  name<span>:</span> <span>string</span><span>;</span>\n  age<span>:</span> <span>number</span><span>;</span>\n<span>}</span>\n\n<span>let</span> p1<span>:</span> Person <span>=</span> <span>{</span>\n  name<span>:</span> <span>'p1'</span><span>,</span>\n  age<span>:</span> <span>13</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面的例子中，我们定义了一个接口 <code>Person</code>，接着定义了一个变量 <code>p1</code>，它的类型是 <code>Person</code>。这样，我们就约束了 <code>p1</code> 的形状必须和接口 <code>Person</code> 一致。</p>\n<p>接口一般首字母大写。有的编程语言中会建议接口的名称加上 <code>I</code> 前缀。</p>\n<p>定义的变量比接口少了一些属性是不允许的：</p>\n<div><pre><code><span>interface</span> <span>Person</span> <span>{</span>\n  name<span>:</span> <span>string</span><span>;</span>\n  age<span>:</span> <span>number</span><span>;</span>\n<span>}</span>\n  \n<span>let</span> p1<span>:</span> Person <span>=</span> <span>{</span>\n  name<span>:</span> <span>'p1'</span>\n<span>}</span><span>;</span>\n\n<span>// error: Property 'age' is missing in type '{ name: string; }' but required in type 'Person'.</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>多一些属性也是不允许的：</p>\n<div><pre><code><span>interface</span> <span>Person</span> <span>{</span>\n  name<span>:</span> <span>string</span><span>;</span>\n  age<span>:</span> <span>number</span><span>;</span>\n<span>}</span>\n  \n<span>let</span> p1<span>:</span> Person <span>=</span> <span>{</span>\n  name<span>:</span> <span>'p1'</span><span>,</span>\n  age<span>:</span> <span>13</span><span>,</span>\n  gender<span>:</span> <span>'male'</span>\n<span>}</span><span>;</span>\n\n<span>// error: Type '{ name: string; age: number; gender: string; }' is not assignable to type 'Person'.</span>\n<span>//   Object literal may only specify known properties, and 'gender' does not exist in type 'Person'.</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>可见，<strong>赋值的时候，变量的形状必须和接口的形状保持一致</strong>。</p>\n<h3 id=\"可选属性\"> 可选属性</h3>\n<p>有时我们希望不要完全匹配一个形状，那么可以用可选属性：</p>\n<div><pre><code><span>interface</span> <span>Person</span> <span>{</span>\n  name<span>:</span> <span>string</span><span>;</span>\n  age<span>?</span><span>:</span> <span>number</span><span>;</span>\n<span>}</span>\n\n<span>let</span> p1<span>:</span> Person <span>=</span> <span>{</span>\n  name<span>:</span> <span>'p1'</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>可选属性的含义是该属性可以不存在。</p>\n<p>这时<strong>仍然不允许添加未定义的属性</strong>：</p>\n<div><pre><code><span>interface</span> <span>Person</span> <span>{</span>\n  name<span>:</span> <span>string</span><span>;</span>\n  age<span>?</span><span>:</span> <span>number</span><span>;</span>\n<span>}</span>\n\n<span>let</span> p1<span>:</span> Person <span>=</span> <span>{</span>\n  name<span>:</span> <span>'p1'</span><span>,</span>\n  age<span>:</span> <span>13</span><span>,</span>\n  gender<span>:</span> <span>'male'</span>\n<span>}</span><span>;</span>\n\n<span>// error: Type '{ name: string; age: number; gender: string; }' is not assignable to type 'Person'.</span>\n<span>//   Object literal may only specify known properties, and 'gender' does not exist in type 'Person'.</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id=\"索引签名\"> 索引签名</h3>\n<p>索引签名的思想是在只知道键和值类型的情况下对结构未知的对象进行类型划分。</p>\n<p>它的语法相当简单，只需在方括号内写上键的类型，而不是具体的某个属性名：</p>\n<ul>\n<li><code>{ [key: KeyType]: ValueType }</code>。</li>\n</ul>\n<p>例如下面的代码：</p>\n<div><pre><code><span>interface</span> <span>Person</span> <span>{</span>\n  name<span>:</span> <span>string</span><span>;</span>\n  age<span>?</span><span>:</span> <span>number</span><span>;</span>\n  <span>[</span>propName<span>:</span> <span>string</span><span>]</span><span>:</span> <span>any</span><span>;</span>\n<span>}</span>\n\n<span>let</span> p1<span>:</span> Person <span>=</span> <span>{</span>\n  name<span>:</span> <span>'p1'</span><span>,</span>\n  gender<span>:</span> <span>'male'</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><code>[propName: string]: any</code> 是索引签名，它定义了任意键只要是 <code>string</code> 类型时，值就为 <code>any</code> 类型。</p>\n<p><strong>需要注意的是，签名的键只能是一个 <code>string</code>、<code>number</code> 或 <code>symbol</code>，其他类型是不允许的</strong>。</p>\n<p>数字作为对象索引时，它的类型既可以与数字兼容，也可以与字符串兼容，这与 JavaScript 的行为一致。因此，使用 <code>0</code> 或 <code>'0'</code> 索引对象时，这两者等价，如下代码所示：</p>\n<div><pre><code><span>interface</span> <span>LanguageRankInterface</span> <span>{</span>\n  <span>[</span>rank<span>:</span> <span>number</span><span>]</span><span>:</span> <span>string</span><span>;</span>\n<span>}</span>\n<span>interface</span> <span>LanguageYearInterface</span> <span>{</span>\n  <span>[</span>name<span>:</span> <span>string</span><span>]</span><span>:</span> <span>number</span><span>;</span>\n<span>}</span>\n\n<span>// 测试</span>\n<span>let</span> LanguageRankMap<span>:</span> LanguageRankInterface <span>=</span> <span>{</span>\n  <span>1</span><span>:</span> <span>'TypeScript'</span><span>,</span> <span>// ok</span>\n  <span>2</span><span>:</span> <span>'JavaScript'</span><span>,</span> <span>// ok</span>\n  <span>'WrongIndex'</span><span>:</span> <span>'2012'</span> <span>// ts(2322) 不存在的属性名</span>\n<span>}</span><span>;</span>\n  \n<span>let</span> LanguageMap<span>:</span> LanguageYearInterface <span>=</span> <span>{</span>\n  TypeScript<span>:</span> <span>2012</span><span>,</span> <span>// ok</span>\n  JavaScript<span>:</span> <span>1995</span><span>,</span> <span>// ok</span>\n  <span>1</span><span>:</span> <span>1970</span> <span>// ok</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>同样，可以使用 <code>readonly</code> 注解索引签名，此时将对应属性设置为只读就行，如下代码所示：</p>\n<div><pre><code><span>interface</span> <span>LanguageRankInterface</span> <span>{</span>\n  <span>readonly</span> <span>[</span>rank<span>:</span> <span>number</span><span>]</span><span>:</span> <span>string</span><span>;</span>\n<span>}</span>\n\n<span>interface</span> <span>LanguageYearInterface</span> <span>{</span>\n  <span>readonly</span> <span>[</span>name<span>:</span> <span>string</span><span>]</span><span>:</span> <span>number</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>一旦定义了索引签名，那么确定属性和可选属性的类型都必须是它的类型的子集：</p>\n<div><pre><code><span>interface</span> <span>Person</span> <span>{</span>\n  name<span>:</span> <span>string</span><span>;</span>\n  age<span>?</span><span>:</span> <span>number</span><span>;</span> <span>// ts(2411) age 属性的 number 类型不能赋值给字符串索引类型 string</span>\n  <span>[</span>propName<span>:</span> <span>string</span><span>]</span><span>:</span> <span>string</span><span>;</span>\n<span>}</span>\n\n<span>let</span> p1<span>:</span> Person <span>=</span> <span>{</span>\n  name<span>:</span> <span>'p1'</span><span>,</span>\n  age<span>:</span> <span>13</span><span>,</span>\n  gender<span>:</span> <span>'male'</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上例中，索引签名的值允许是 <code>string</code>，但是可选属性 <code>age</code> 的值却是 <code>number</code>，<code>number</code> 不是 <code>string</code> 的子属性，所以报错了。</p>\n<p>一个接口中只能定义一个索引签名。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型：</p>\n<div><pre><code><span>interface</span> <span>Person</span> <span>{</span>\n  name<span>:</span> <span>string</span><span>;</span>\n  age<span>?</span><span>:</span> <span>number</span><span>;</span>\n  <span>[</span>propName<span>:</span> <span>string</span><span>]</span><span>:</span> <span>string</span> <span>|</span> <span>number</span><span>;</span>\n<span>}</span>\n\n<span>let</span> p1<span>:</span> Person <span>=</span> <span>{</span>\n  name<span>:</span> <span>'p1'</span><span>,</span>\n  age<span>:</span> <span>13</span><span>,</span>\n  gender<span>:</span> <span>'male'</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>用联合类型改写后，现在代码就不报错了。</p>\n<h3 id=\"只读属性\"> 只读属性</h3>\n<p>有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 <code>readonly</code> 定义只读属性：</p>\n<div><pre><code><span>interface</span> <span>Person</span> <span>{</span>\n  <span>readonly</span> id<span>:</span> <span>number</span><span>;</span>\n  name<span>:</span> <span>string</span><span>;</span>\n  age<span>?</span><span>:</span> <span>number</span><span>;</span>\n  <span>[</span>propName<span>:</span> <span>string</span><span>]</span><span>:</span> <span>any</span><span>;</span>\n<span>}</span>\n\n<span>let</span> p1<span>:</span> Person <span>=</span> <span>{</span>\n  id<span>:</span> <span>1</span><span>,</span>\n  name<span>:</span> <span>'p1'</span><span>,</span>\n  gender<span>:</span> <span>'male'</span>\n<span>}</span><span>;</span>\n\np1<span>.</span>id <span>=</span> <span>2</span><span>;</span>\n\n<span>// error: Cannot assign to 'id' because it is a read-only property.</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>上例中，使用 <code>readonly</code> 定义的属性 <code>id</code> 初始化后，又被赋值了，所以报错了。</p>\n<p>注意，<strong>只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候</strong>：</p>\n<div><pre><code><span>interface</span> <span>Person</span> <span>{</span>\n  <span>readonly</span> id<span>:</span> <span>number</span><span>;</span>\n  name<span>:</span> <span>string</span><span>;</span>\n  age<span>?</span><span>:</span> <span>number</span><span>;</span>\n  <span>[</span>propName<span>:</span> <span>string</span><span>]</span><span>:</span> <span>any</span><span>;</span>\n<span>}</span>\n\n<span>let</span> p1<span>:</span> Person <span>=</span> <span>{</span>\n  name<span>:</span> <span>'p1'</span><span>,</span>\n  gender<span>:</span> <span>'male'</span>\n<span>}</span><span>;</span>\n\np1<span>.</span>id <span>=</span> <span>2</span><span>;</span>\n\n<span>// error: Property 'id' is missing in type '{ name: string; gender: string; }' but required in type 'Person'.</span>\n<span>// error: Cannot assign to 'id' because it is a read-only property.</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>上例中，报错信息有两处，第一处是在对 <code>p1</code> 进行赋值的时候，没有给 <code>id</code> 赋值。</p>\n<p>第二处是在给 <code>p1.id</code> 赋值的时候，由于它是只读属性，所以报错了。</p>\n<h2 id=\"type-类型别名\"> Type 类型别名</h2>\n<p>接口类型的一个作用是将内联类型抽离出来，从而实现类型可复用。其实，我们也可以使用类型别名接收抽离出来的内联类型实现复用。</p>\n<p>此时，我们可以通过如下所示「<code>type</code> 别名名字 = 类型定义」的格式来定义类型别名。</p>\n<div><pre><code><span>/* 类型别名 */</span>\n<span>type</span> <span>LanguageType</span> <span>=</span> <span>{</span>\n  <span>/* 以下是接口属性 */</span>\n  <span>/* 姓名 */</span>\n  name<span>:</span> <span>string</span><span>;</span> \n  <span>/* 年龄 */</span>\n  <span>age</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>number</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>此外，针对接口类型无法覆盖的场景，比如组合类型、交叉类型，我们只能使用类型别名来接收，如下代码所示：</p>\n<div><pre><code><span>/* 联合 */</span>\n<span>type</span> <span>MixedType</span> <span>=</span> <span>string</span> <span>|</span> <span>number</span><span>;</span>\n<span>/* 交叉 */</span>\n<span>type</span> <span>IntersectionType</span> <span>=</span> <span>{</span> id<span>:</span> <span>number</span><span>;</span> name<span>:</span> <span>string</span><span>;</span> <span>}</span>\n  <span>&amp;</span> <span>{</span> age<span>:</span> <span>number</span><span>;</span> name<span>:</span> <span>string</span> <span>}</span><span>;</span>\n<span>/* 提取接口属性类型 */</span>\n<span>type</span> <span>AgeType</span> <span>=</span> ProgramLanguage<span>[</span><span>'age'</span><span>]</span><span>;</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>在上述代码中，我们定义了一个 IntersectionType 类型别名，表示两个匿名接口类型交叉出的类型；同时定义了一个 AgeType 类型别名，表示抽取的 ProgramLanguage age 属性的类型。</p>\n<div><p>注意</p>\n<p>类型别名，诚如其名，即我们仅仅是给类型取了一个新的名字，并不是创建了一个新的类型。</p>\n</div>\n<h2 id=\"interface-与-type-的区别\"> Interface 与 Type 的区别</h2>\n<p>在大多数的情况下使用接口类型和类型别名的效果等价，但是在某些特定的场景下这两者还是存在很大区别。比如，重复定义的接口类型，它的属性会叠加，这个特性使得我们可以极其方便地对全局变量、第三方库的类型做扩展，如下代码所示：</p>\n<div><pre><code><span>interface</span> <span>Language</span> <span>{</span>\n  id<span>:</span> <span>number</span><span>;</span>\n<span>}</span>\n\n<span>interface</span> <span>Language</span> <span>{</span>\n  name<span>:</span> <span>string</span><span>;</span>\n<span>}</span>\n<span>let</span> lang<span>:</span> Language <span>=</span> <span>{</span>\n  id<span>:</span> <span>1</span><span>,</span> <span>// ok</span>\n  name<span>:</span> <span>'name'</span> <span>// ok</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>在上述代码中，先后定义的两个 Language 接口属性被叠加在了一起，此时我们可以赋值给 lang 变量一个同时包含 id 和 name 属性的对象。</p>\n<p>不过，如果我们重复定义类型别名，如下代码所示，则会提示一个 ts(2300) 错误。</p>\n<div><pre><code><span>/* ts(2300) 重复的标志 */</span>\n<span>type</span> <span>Language</span> <span>=</span> <span>{</span>\n  id<span>:</span> <span>number</span><span>;</span>\n<span>}</span>\n\n<span>/* ts(2300) 重复的标志 */</span>\n<span>type</span> <span>Language</span> <span>=</span> <span>{</span>\n  name<span>:</span> <span>string</span><span>;</span>\n<span>}</span>\n<span>let</span> lang<span>:</span> Language <span>=</span> <span>{</span>\n  id<span>:</span> <span>1</span><span>,</span>\n  name<span>:</span> <span>'name'</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>在上述代码中，我们重复定义了一个类型别名 Language ，此时就提示了一个错误。</p>\n<p>（完）</p>\n",
      "date_published": "2022-04-09T14:58:24.000Z",
      "date_modified": "2022-04-11T07:22:33.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "未完待续",
      "url": "https://www.fedbook.cn/frontend-knowledge/typescript/to-be-continued/",
      "id": "https://www.fedbook.cn/frontend-knowledge/typescript/to-be-continued/",
      "content_html": "<h1 id=\"未完待续\"> 未完待续</h1>\n<h2 id=\"知识点正在火速整理中\"> 知识点正在火速整理中</h2>\n",
      "date_published": "2021-12-26T07:36:03.000Z",
      "date_modified": "2021-12-26T07:36:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "字面量类型",
      "url": "https://www.fedbook.cn/frontend-knowledge/typescript/literal/",
      "id": "https://www.fedbook.cn/frontend-knowledge/typescript/literal/",
      "content_html": "<h1 id=\"字面量类型\"> 字面量类型</h1>\n<h2 id=\"类型推断\"> 类型推断</h2>\n<p>在 TypeScript 中，类型标注声明是在变量之后（即类型后置），它不像 Java 语言一样，先声明变量的类型，再声明变量的名称。</p>\n<div><pre><code><span>// Java 声明并初始化字符串 str</span>\n<span>String</span> str<span>=</span><span>\"Hello World\"</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>使用类型标注后置的好处是编译器可以通过代码所在的上下文推导其对应的类型，无须再声明变量类型，示例如下：</p>\n<div><pre><code><span>let</span> x1 <span>=</span> <span>42</span><span>;</span>         <span>// 推断出 x1 的类型是 number</span>\n<span>let</span> x2<span>:</span> <span>number</span> <span>=</span> x1<span>;</span> <span>// ok</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>在上述代码中，<code>x1</code> 的类型被推断为 <code>number</code>，将变量赋值给 <code>number</code> 类型的变量 <code>x2</code> 后，不会出现任何错误。</p>\n<p>在 TypeScript 中，具有初始化值的变量、有默认值的函数参数、函数返回的类型都可以根据上下文推断出来。比如我们能根据 <code>return</code> 语句推断函数返回的类型，如下代码所示：</p>\n<div><pre><code><span>/** 根据参数的类型，推断出返回值的类型也是 number */</span>\n<span>function</span> <span>add1</span><span>(</span>a<span>:</span> <span>number</span><span>,</span> b<span>:</span> <span>number</span><span>)</span> <span>{</span>\n  <span>return</span> a <span>+</span> b<span>;</span>\n<span>}</span>\n<span>const</span> x1<span>=</span> <span>add1</span><span>(</span><span>1</span><span>,</span> <span>1</span><span>)</span><span>;</span> <span>// 推断出 x1 的类型也是 number</span>\n\n<span>/** 推断参数 b 的类型是数字或者 undefined，返回值的类型也是数字 */</span>\n<span>function</span> <span>add2</span><span>(</span>a<span>:</span> <span>number</span><span>,</span> b <span>=</span> <span>1</span><span>)</span> <span>{</span>\n  <span>return</span> a <span>+</span> b<span>;</span>\n<span>}</span>\n<span>const</span> x2 <span>=</span> <span>add2</span><span>(</span><span>1</span><span>)</span><span>;</span>\n<span>const</span> x3 <span>=</span> <span>add2</span><span>(</span><span>1</span><span>,</span> <span>'1'</span><span>)</span><span>;</span> <span>// ts(2345) Argument of type '\"1\"' is not assignable to parameter of type 'number | undefined</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id=\"上下文推断\"> 上下文推断</h2>\n<p>变量的类型除了可以通过被赋值的值进行推断之外，在某些特定的情况下，也可以通过变量所在的上下文环境推断变量的类型，示例如下：</p>\n<div><pre><code><span>type</span> <span>Adder</span> <span>=</span> <span>(</span>a<span>:</span> <span>number</span><span>,</span> b<span>:</span> <span>number</span><span>)</span> <span>=></span> <span>number</span><span>;</span>\n<span>const</span> add<span>:</span> <span>Adder</span> <span>=</span> <span>(</span>a<span>,</span> b<span>)</span> <span>=></span> <span>{</span>\n  <span>return</span> a <span>+</span> b<span>;</span>\n<span>}</span>\n<span>const</span> x1 <span>=</span> <span>add</span><span>(</span><span>1</span><span>,</span> <span>1</span><span>)</span><span>;</span> <span>// 推断出 x1 类型是 number</span>\n<span>const</span> x2 <span>=</span> <span>add</span><span>(</span><span>1</span><span>,</span> <span>'1'</span><span>)</span><span>;</span>  <span>// ts(2345) Argument of type '\"1\"' is not assignable to parameter of type 'number</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>这里先定义了一个实现加法功能的函数类型 <code>Adder</code>，然后声明了 <code>add</code> 变量的类型为 <code>Adder</code> 并赋值一个匿名箭头函数，箭头函数参数 <code>a</code> 和 <code>b</code> 的类型以及返回类型都没有显式声明。</p>\n<p>TypeScript 通过 <code>add</code> 的类型 <code>Adder</code> 反向（通过变量类型推断出值的相关类型）推断出箭头函数参数及返回值的类型，也就是说函数参数 <code>a</code>、<code>b</code>，以及返回类型在这个变量的声明上下文中被确定了。</p>\n<p>正是得益于 TypeScript 这种类型推导机制和能力，使得我们无须显式声明，即可直接通过上下文环境推断出变量的类型，也就是说此时类型可缺省。</p>\n<h2 id=\"字面量类型-2\"> 字面量类型</h2>\n<blockquote>\n<ul>\n<li>字面量就是跟变量相对的，直接写在代码里的值，一般除去表达式，给变量赋值时，等号右边都可以认为是字面量。</li>\n<li>字面量类型表示特定数据就是变量的类型。</li>\n</ul>\n</blockquote>\n<h3 id=\"介绍\"> 介绍</h3>\n<p>在 TypeScript 中，字面量不仅可以表示值，还可以表示类型，即所谓的字面量类型。</p>\n<p>目前，TypeScript 支持 3 种字面量类型：字符串字面量类型、数字字面量类型、布尔字面量类型，对应的字符串字面量、数字字面量、布尔字面量分别拥有<strong>与其值一样的字面量类型</strong>，具体示例如下：</p>\n<div><pre><code><span>let</span> specifiedStr<span>:</span> <span>'this is string'</span> <span>=</span> <span>'this is string'</span><span>;</span>\n<span>let</span> specifiedNum<span>:</span> <span>1</span> <span>=</span> <span>1</span><span>;</span>\n<span>let</span> specifiedBoolean<span>:</span> <span>true</span> <span>=</span> <span>true</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"应用\"> 应用</h3>\n<p>定义单个的字面量类型一般没有太大的用处，它真正的应用场景是可以把多个字面量类型组合成一个联合类型，用来描述拥有明确成员的实用的集合。</p>\n<p>比如声明如下所示的一个类型 Config：</p>\n<div><pre><code><span>interface</span> <span>Config</span> <span>{</span>\n  size<span>:</span> <span>'small'</span> <span>|</span> <span>'big'</span><span>;</span>\n  isEnable<span>:</span>  <span>true</span> <span>|</span> <span>false</span><span>;</span>\n  margin<span>:</span> <span>0</span> <span>|</span> <span>2</span> <span>|</span> <span>4</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>在上述代码中，我们限定了 <code>size</code> 属性为字符串字面量类型 <code>'small' | 'big'</code>，<code>isEnable</code> 属性为布尔字面量类型 <code>true | false</code>（布尔字面量只有这两个值，所以跟直接使用 <code>boolean</code> 没有区别），<code>margin</code> 属性为数字字面量类型 <code>0 | 2 | 4</code>。</p>\n<h3 id=\"字面量类型拓宽\"> 字面量类型拓宽</h3>\n<p>字面量类型拓宽（Literal Widening）：所有通过 <code>let</code> 或 <code>var</code> 定义的变量、函数的形参、对象的非只读属性，如果满足指定了初始值且未显式添加类型注解的条件，那么它们推断出来的类型就是指定的初始值字面量类型拓宽后的类型。</p>\n<p>比如下面的例子：</p>\n<div><pre><code><span>let</span> str <span>=</span> <span>'this is string'</span><span>;</span>                   <span>// 类型是 string</span>\n<span>let</span> strFun <span>=</span> <span>(</span>str <span>=</span> <span>'this is string'</span><span>)</span> <span>=></span> str<span>;</span> <span>// 形参类型是 string</span>\n<span>const</span> specifiedStr <span>=</span> <span>'this is string'</span><span>;</span>        <span>// 类型是 'this is string'</span>\n<span>let</span> str2 <span>=</span> specifiedStr<span>;</span>                      <span>// 类型是 string</span>\n<span>let</span> <span>strFun2</span> <span>=</span> <span>(</span>str <span>=</span> specifiedStr<span>)</span> <span>=></span> str<span>;</span>    <span>// 形参类型是 string</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>\n<li>第 1~2 行满足了 let、形参且未显式声明类型注解的条件，所以变量、形参的类型拓宽为 <code>string</code>（形参类型确切地讲是 <code>string | undefined</code>）。</li>\n<li>第 3 行的常量不可变更，类型没有拓宽，所以 specifiedStr 的类型是 <code>'this is string'</code> 字面量类型。</li>\n<li>第 4~5 行，因为赋予的值 <code>specifiedStr</code> 的类型是字面量类型，且没有显式类型注解，所以变量、形参的类型也被拓宽了。</li>\n</ul>\n<p>基于字面量类型拓宽的条件，我们可以通过添加显示类型注解来控制类型拓宽行为：</p>\n<div><pre><code><span>const</span> specifiedStr<span>:</span> <span>'this is string'</span> <span>=</span> <span>'this is string'</span><span>;</span> <span>// 类型是 '\"this is string\"'</span>\n<span>let</span> str2 <span>=</span> specifiedStr<span>;</span> <span>// 即便使用 let 定义，类型是 'this is string'</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"其他类型拓宽\"> 其他类型拓宽</h3>\n<p>除了字面量类型拓宽之外，TypeScript 对某些特定类型值也有类似类型拓宽（Type Widening）的设计，比如对 <code>null</code> 和 <code>undefined</code> 的类型进行拓宽，通过 <code>let</code>、<code>var</code> 定义的变量如果满足未显式声明类型注解且被赋予了 <code>null</code> 或 <code>undefined</code> 值，则推断出这些变量的类型是 <code>any</code>：</p>\n<div><pre><code><span>let</span> x <span>=</span> <span>null</span><span>;</span>      <span>// 类型拓宽成 any</span>\n<span>let</span> y <span>=</span> <span>undefined</span><span>;</span> <span>// 类型拓宽成 any</span>\n<span>/** -----分界线------- */</span>\n<span>const</span> z <span>=</span> <span>null</span><span>;</span>    <span>// 类型是 null</span>\n<span>/** -----分界线------- */</span>\n<span>let</span> <span>anyFun</span> <span>=</span> <span>(</span>param <span>=</span> <span>null</span><span>)</span> <span>=></span> param<span>;</span> <span>// 形参类型是 null</span>\n<span>let</span> z2 <span>=</span> z<span>;</span> <span>// 类型是 null</span>\n<span>let</span> x2 <span>=</span> x<span>;</span> <span>// 类型是 null</span>\n<span>let</span> y2 <span>=</span> y<span>;</span> <span>// 类型是 undefined</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面的第 6~9 行的类型推断行为是因为开启了 <code>strictNullChecks=true</code>（严格模式）。</p>\n<h3 id=\"类型缩小\"> 类型缩小</h3>\n<p>类型缩小（Type Narrowing）：可以通过某些操作将变量的类型由一个较为宽泛的集合缩小到相对较小、较明确的集合。</p>\n<p>比如可以使用类型守卫将函数参数的类型从 <code>any</code> 缩小到明确的类型，示例如下：</p>\n<div><pre><code><span>let</span> <span>func</span> <span>=</span> <span>(</span>anything<span>:</span> <span>any</span><span>)</span> <span>=></span> <span>{</span>\n  <span>if</span> <span>(</span><span>typeof</span> anything <span>===</span> <span>'string'</span><span>)</span> <span>{</span>\n    <span>return</span> anything<span>;</span> <span>// 类型是 string </span>\n  <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>typeof</span> anything <span>===</span> <span>'number'</span><span>)</span> <span>{</span>\n    <span>return</span> anything<span>;</span> <span>// 类型是 number</span>\n  <span>}</span>\n  <span>return</span> <span>null</span><span>;</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>同样，也可以使用类型守卫将联合类型缩小到明确的子类型，示例如下：</p>\n<div><pre><code><span>let</span> <span>func</span> <span>=</span> <span>(</span>anything<span>:</span> <span>string</span> <span>|</span> <span>number</span><span>)</span> <span>=></span> <span>{</span>\n  <span>if</span> <span>(</span><span>typeof</span> anything <span>===</span> <span>'string'</span><span>)</span> <span>{</span>\n    <span>return</span> anything<span>;</span> <span>// 类型是 string </span>\n  <span>}</span> <span>else</span> <span>{</span>\n    <span>return</span> anything<span>;</span> <span>// 类型是 number</span>\n  <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>当然，也可以通过字面量类型等值判断（<code>===</code>）或其他控制流语句（包括但不限于 if、三目运算符、switch 分支）将联合类型收敛为更具体的类型，示例如下：</p>\n<div><pre><code><span>type</span> <span>Goods</span> <span>=</span> <span>'pen'</span> <span>|</span> <span>'pencil'</span> <span>|</span><span>'ruler'</span><span>;</span>\n<span>const</span> getPenCost <span>=</span> <span>(</span>item<span>:</span> <span>'pen'</span><span>)</span> <span>=></span> <span>2</span><span>;</span>\n<span>const</span> getPencilCost <span>=</span> <span>(</span>item<span>:</span> <span>'pencil'</span><span>)</span> <span>=></span> <span>4</span><span>;</span>\n<span>const</span> getRulerCost <span>=</span> <span>(</span>item<span>:</span> <span>'ruler'</span><span>)</span> <span>=></span> <span>6</span><span>;</span>\n<span>const</span> <span>getCost</span> <span>=</span> <span>(</span>item<span>:</span> Goods<span>)</span> <span>=></span>  <span>{</span>\n  <span>if</span> <span>(</span>item <span>===</span> <span>'pen'</span><span>)</span> <span>{</span>\n    <span>return</span> <span>getPenCost</span><span>(</span>item<span>)</span><span>;</span>    <span>// item => 'pen'</span>\n  <span>}</span> <span>else</span> <span>if</span> <span>(</span>item <span>===</span> <span>'pencil'</span><span>)</span> <span>{</span>\n    <span>return</span> <span>getPencilCost</span><span>(</span>item<span>)</span><span>;</span> <span>// item => 'pencil'</span>\n  <span>}</span> <span>else</span> <span>{</span>\n    <span>return</span> <span>getRulerCost</span><span>(</span>item<span>)</span><span>;</span>  <span>// item => 'ruler'</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>在上述 <code>getCost</code> 函数中，接受的参数类型是字面量类型的联合类型，函数内包含了 if 语句的 3 个流程分支，其中每个流程分支调用的函数的参数都是具体独立的字面量类型。</p>\n<p><code>getPenCost</code>、<code>getPencilCost</code> 和 <code>getRulerCost</code> 三个函数只接受单一特定字面量类型的参数，但在每个流程分支中，编译器可以知道流程分支中的 item 类型是什么（类型会被收缩为特定字面量类型）。</p>\n<p>事实上，如果我们将上面的示例去掉中间的流程分支，编译器也可以推断出收敛后的类型，如下代码所示：</p>\n<div><pre><code><span>type</span> <span>Goods</span> <span>=</span> <span>'pen'</span> <span>|</span> <span>'pencil'</span> <span>|</span><span>'ruler'</span><span>;</span>\n<span>const</span> <span>getCost</span> <span>=</span> <span>(</span>item<span>:</span> Goods<span>)</span> <span>=></span>  <span>{</span>\n  <span>if</span> <span>(</span>item <span>===</span> <span>'pen'</span><span>)</span> <span>{</span>\n    item<span>;</span> <span>// item => 'pen'</span>\n  <span>}</span> <span>else</span> <span>{</span>\n    item<span>;</span> <span>// => 'pencil' | 'ruler'</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>（完）</p>\n",
      "date_published": "2022-04-12T09:36:50.000Z",
      "date_modified": "2022-04-12T09:36:50.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "类型守卫",
      "url": "https://www.fedbook.cn/frontend-knowledge/typescript/type-guard/",
      "id": "https://www.fedbook.cn/frontend-knowledge/typescript/type-guard/",
      "content_html": "<h1 id=\"类型守卫\"> 类型守卫</h1>\n<p>类型守卫是一种机制，在参数、值的类型是联合类型或枚举类型的时候，它通过触发类型缩小，来确保本次传入的参数、值在允许类型的范围内，并且根据具体的类型进行不同的业务处理。</p>\n<h2 id=\"如何区分联合类型\"> 如何区分联合类型</h2>\n<p>使用类型守卫来区分联合类型的不同成员时，常用的类型守卫包括 <code>switch</code>、字面量恒等、<code>typeof</code>、<code>instanceof</code>、<code>in</code> 和自定义类型守卫这几种。</p>\n<h3 id=\"switch\"> switch</h3>\n<p>通过 <code>switch</code> 类型守卫来处理联合类型中成员或者成员属性可枚举的场景，即字面量值的集合，如下所示：</p>\n<div><pre><code><span>const</span> convert <span>=</span> <span>(</span>c<span>:</span> <span>'a'</span> <span>|</span> <span>1</span><span>)</span> <span>=></span> <span>{</span>\n  <span>switch</span> <span>(</span>c<span>)</span> <span>{</span>\n    <span>case</span> <span>1</span><span>:</span>\n      <span>return</span> c<span>.</span><span>toFixed</span><span>(</span><span>)</span><span>;</span> <span>// c is 1</span>\n    <span>case</span> <span>'a'</span><span>:</span>\n      <span>return</span> c<span>.</span><span>toLowerCase</span><span>(</span><span>)</span><span>;</span> <span>// c is 'a'</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"字面量恒等\"> 字面量恒等</h3>\n<p><code>switch</code> 适用的场景往往也可以直接使用字面量恒等比较进行替换，如下所示：</p>\n<div><pre><code><span>const</span> convert <span>=</span> <span>(</span>c<span>:</span> <span>'a'</span> <span>|</span> <span>1</span><span>)</span> <span>=></span> <span>{</span>\n  <span>if</span> <span>(</span>c <span>===</span> <span>1</span><span>)</span> <span>{</span>\n    <span>return</span> c<span>.</span><span>toFixed</span><span>(</span><span>)</span><span>;</span> <span>// c is 1</span>\n  <span>}</span> <span>else</span> <span>if</span> <span>(</span>c <span>===</span> <span>'a'</span><span>)</span> <span>{</span>\n    <span>return</span> c<span>.</span><span>toLowerCase</span><span>(</span><span>)</span><span>;</span> <span>// c is 'a'</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>建议：一般来说，如果可枚举的值和条件分支越多，那么使用 <code>switch</code> 就会让代码逻辑更简洁、更清晰；反之，则推荐使用字面量恒等进行判断。</p>\n<h3 id=\"typeof\"> typeof</h3>\n<p>当联合类型的成员不可枚举，比如说是字符串、数字等原子类型组成的集合，这个时候就需要使用 <code>typeof</code>。</p>\n<div><pre><code><span>const</span> convert <span>=</span> <span>(</span>c<span>:</span> <span>'a'</span> <span>|</span> <span>1</span><span>)</span> <span>=></span> <span>{</span>\n  <span>if</span> <span>(</span><span>typeof</span> c <span>===</span> <span>'number'</span><span>)</span> <span>{</span>\n    <span>return</span> c<span>.</span><span>toFixed</span><span>(</span><span>)</span><span>;</span> <span>// c is 1</span>\n  <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>typeof</span> c <span>===</span> <span>'string'</span><span>)</span> <span>{</span>\n    <span>return</span> c<span>.</span><span>toLowerCase</span><span>(</span><span>)</span><span>;</span> <span>// c is 'a'</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><code>typeof</code> 类型保护只支持两种形式：typeof x === typename 和 typeof v !== typename，其中 typename 必须是 <code>&quot;number&quot;</code>，<code>&quot;string&quot;</code>，<code>&quot;boolean&quot;</code> 或 <code>&quot;symbol&quot;</code>。</p>\n<p>但是 TypeScript 并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护。</p>\n<h3 id=\"instanceof\"> instanceof</h3>\n<p>联合类型的成员还可以是类，此时就需要使用 <code>instanceof</code> 来判断具体属于哪个类，如下所示：</p>\n<div><pre><code><span>class</span> <span>Dog</span> <span>{</span>\n  wang <span>=</span> <span>'wangwang'</span><span>;</span>\n<span>}</span>\n<span>class</span> <span>Cat</span> <span>{</span>\n  miao <span>=</span> <span>'miaomiao'</span><span>;</span>\n<span>}</span>\n<span>const</span> <span>getName</span> <span>=</span> <span>(</span>animal<span>:</span> Dog <span>|</span> Cat<span>)</span> <span>=></span> <span>{</span>\n  <span>if</span> <span>(</span>animal <span>instanceof</span> <span>Dog</span><span>)</span> <span>{</span>\n    <span>return</span> animal<span>.</span>wang<span>;</span>\n  <span>}</span> <span>else</span> <span>if</span> <span>(</span>animal <span>instanceof</span> <span>Cat</span><span>)</span> <span>{</span>\n    <span>return</span> animal<span>.</span>miao<span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id=\"in\"> in</h3>\n<p>当联合类型的成员包含接口类型（对象），并且接口之间的属性不同，我们就不能直接通过 <code>.</code> 操作符获取属性来判断：</p>\n<div><pre><code><span>interface</span> <span>Dog</span> <span>{</span>\n  wang<span>:</span> <span>string</span><span>;</span>\n<span>}</span>\n<span>interface</span> <span>Cat</span> <span>{</span>\n  miao<span>:</span> <span>string</span><span>;</span>\n<span>}</span>\n<span>const</span> <span>getName</span> <span>=</span> <span>(</span>animal<span>:</span> Dog <span>|</span> Cat<span>)</span> <span>=></span> <span>{</span>\n  <span>if</span> <span>(</span><span>typeof</span> animal<span>.</span>wang <span>==</span> <span>'string'</span><span>)</span> <span>{</span> <span>// ts(2339)</span>\n   <span>return</span> animal<span>.</span>wang<span>;</span> <span>// ts(2339)</span>\n  <span>}</span> <span>else</span> <span>if</span> <span>(</span>animal<span>.</span>miao<span>)</span> <span>{</span> <span>// ts(2339)</span>\n   <span>return</span> animal<span>.</span>miao<span>;</span> <span>// ts(2339)</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>而是需要使用 <code>in</code> 操作符：</p>\n<div><pre><code><span>interface</span> <span>Dog</span> <span>{</span>\n  wang<span>:</span> <span>string</span><span>;</span>\n<span>}</span>\n<span>interface</span> <span>Cat</span> <span>{</span>\n  miao<span>:</span> <span>string</span><span>;</span>\n<span>}</span>\n<span>const</span> <span>getName</span> <span>=</span> <span>(</span>animal<span>:</span> Dog <span>|</span> Cat<span>)</span> <span>=></span> <span>{</span>\n  <span>if</span> <span>(</span><span>'wang'</span> <span>in</span> animal<span>)</span> <span>{</span> <span>// ok</span>\n    <span>return</span> animal<span>.</span>wang<span>;</span> <span>// ok</span>\n  <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>'miao'</span> <span>in</span> animal<span>)</span> <span>{</span> <span>// ok</span>\n    <span>return</span> animal<span>.</span>miao<span>;</span> <span>// ok</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id=\"自定义类型守卫\"> 自定义类型守卫</h3>\n<p>自定义类型守卫，确切地讲是自定义函数，需要用到类型谓词 <code>is</code>。</p>\n<p>比如封装一个 <code>isDog</code> 函数来区分 <code>Dog</code> 和 <code>Cat</code>，如下代码所示：</p>\n<div><pre><code><span>const</span> <span>isDog</span> <span>=</span> <span>function</span> <span>(</span>animal<span>:</span> Dog <span>|</span> Cat<span>)</span><span>:</span> animal <span>is</span> Dog <span>{</span>\n  <span>return</span> <span>'wang'</span> <span>in</span> animal<span>;</span>\n<span>}</span>\n<span>const</span> <span>getName</span> <span>=</span> <span>(</span>animal<span>:</span> Dog <span>|</span> Cat<span>)</span> <span>=></span> <span>{</span>\n  <span>if</span> <span>(</span><span>isDog</span><span>(</span>animal<span>)</span><span>)</span> <span>{</span>\n    <span>return</span> animal<span>.</span>wang<span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><code>isDog</code> 将 <code>animal</code> 的类型缩小为 <code>Dog</code>，这样就可以直接获取 <code>wang</code> 属性，而不会提示一个 ts(2339) 的错误了。</p>\n<h2 id=\"如何区分枚举类型\"> 如何区分枚举类型</h2>\n<p>首先枚举类型有以下特性：</p>\n<ul>\n<li>特性 1：枚举和其他任何枚举、类型都不可比较，除了数字枚举可以与数字类型比较之外。</li>\n<li>特性 2：数字枚举极其不稳定（枚举默认的值自递增，给部分数字类型的枚举成员显式指定数值，容易出现逻辑错误）。</li>\n</ul>\n<p>这就可以得出一个结论：最佳实践时，我们永远不要拿枚举和除了自身之外的任何枚举、类型进行比较。</p>\n<div><pre><code><span>enum</span> <span>A</span> <span>{</span>\n  one<span>,</span>\n  two\n<span>}</span>\n<span>enum</span> <span>B</span> <span>{</span>\n  one<span>,</span>\n  two\n<span>}</span>\n<span>const</span> <span>cpWithNumber</span> <span>=</span> <span>(</span>param<span>:</span> <span>A</span><span>)</span> <span>=></span> <span>{</span>\n  <span>if</span> <span>(</span>param <span>===</span> <span>1</span><span>)</span> <span>{</span> <span>// bad</span>\n    <span>return</span> param<span>;</span>\n  <span>}</span>\n<span>}</span>\n<span>const</span> <span>cpWithOtherEnum</span> <span>=</span> <span>(</span>param<span>:</span> <span>A</span><span>)</span> <span>=></span> <span>{</span>\n  <span>if</span> <span>(</span>param <span>===</span> <span>B</span><span>.</span>two <span>as</span> <span>unknown</span> <span>as</span> <span>A</span><span>)</span> <span>{</span> <span>// ALERT bad</span>\n    <span>return</span> param<span>;</span>\n  <span>}</span>\n<span>}</span>\n<span>const</span> <span>cpWithSelf</span> <span>=</span> <span>(</span>param<span>:</span> <span>A</span><span>)</span> <span>=></span> <span>{</span>\n  <span>if</span> <span>(</span>param <span>===</span> <span>A</span><span>.</span>two<span>)</span> <span>{</span> <span>// good</span>\n    <span>return</span> param<span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>上述代码中：</p>\n<ul>\n<li><code>cpWithNumber</code> 函数里将类型是枚举 <code>A</code> 的入参 <code>param</code> 和数字字面量 <code>1</code> 进行比较，因为数字枚举不稳定，默认情况下 <code>A.two</code> 为真，但如果给枚举 <code>A</code> 的成员 <code>one</code> 指定初始值 <code>1</code>，结果就又不一样了。</li>\n<li><code>cpWithOtherEnum</code> 函数里使用了双重类型断言将枚举类型 <code>B</code> 转换为 <code>A</code>，主要是为了避免出现一个 ts(2367) 错误。但一旦 <code>A</code> 和 <code>B</code> 的结构出现了任何差异（比如给成员指定了不同的初始值、改变了成员的顺序或者个数），都会导致这一行的条件判断逻辑真假不固定。</li>\n<li><code>cpWithSelf</code> 函数中是最安全的区分枚举成员的判断方式。</li>\n</ul>\n<blockquote>\n<p>通常情况下，A 不能直接断言成 B，就需要用到双重断言。</p>\n</blockquote>\n<h2 id=\"失效的类型守卫\"> 失效的类型守卫</h2>\n<p>失效的类型守卫指的是某些类型守卫应用在泛型函数中时不能缩小类型，即失效了。比如我们改造了一个可以接受泛型入参的 <code>getName</code> 函数，如下代码所示：</p>\n<div><pre><code><span>const</span> getName <span>=</span> <span>&lt;</span><span>T</span> <span>extends</span> <span>Dog</span> <span>|</span> Cat<span>></span><span>(</span>animal<span>:</span> <span>T</span><span>)</span> <span>=></span> <span>{</span>\n  <span>if</span> <span>(</span><span>'wang'</span> <span>in</span> animal<span>)</span> <span>{</span>\n    <span>return</span> animal<span>.</span>wang<span>;</span> <span>// ts(2339)</span>\n  <span>}</span>\n  <span>return</span> animal<span>.</span>miao<span>;</span> <span>// ts(2339)</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面的代码中虽然使用了 <code>in</code> 类型守卫，但是它并没有让 <code>animal</code> 的类型如预期那样缩小为 <code>Dog</code> 的子类型，所以无法准确判断出 <code>T</code> 类型上没有 <code>wang</code> 属性，提示了一个 ts(2339) 的错误。后来的判断也就会跟着出错，从而也会提示一个 ts(2339) 的错误。</p>\n<p>可一旦我们把 <code>in</code> 操作换成自定义类型守卫 <code>isDog</code> 或者使用 <code>instanceOf</code>，<code>animal</code> 的类型就会缩小成了 <code>Dog</code> 的子类型（T &amp; Dog），就不会出错了。由此可见，<code>in</code> 和 <code>instanceOf</code>、类型谓词在泛型类型缩小上是有区别的。</p>\n<p>需要注意，TypeScript 4.3.2 版本以前的 <code>else</code> 分支无法把 <code>animal</code> 的类型缩小成 <code>Cat</code> 的子类型，所以这个分支依旧会报错，需要使用类型断言来把 <code>animal</code> 的类型断言为 <code>Cat</code>，并获取了它的 <code>miao</code> 属性，最终代码如下所示：</p>\n<div><pre><code><span>const</span> getName <span>=</span> <span>&lt;</span><span>T</span> <span>extends</span> <span>Dog</span> <span>|</span> Cat<span>></span><span>(</span>animal<span>:</span> <span>T</span><span>)</span> <span>=></span> <span>{</span>\n  <span>if</span> <span>(</span><span>isDog</span><span>(</span>animal<span>)</span><span>)</span> <span>{</span> <span>// instanceOf 亦可</span>\n    <span>return</span> animal<span>.</span>wang<span>;</span> <span>// ok</span>\n  <span>}</span>\n  <span>return</span> <span>(</span>animal <span>as</span> Cat<span>)</span><span>.</span>miao<span>;</span> <span>// 类型断言</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>（完）</p>\n",
      "date_published": "2022-04-13T06:56:23.000Z",
      "date_modified": "2022-04-13T06:56:23.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "联合类型与交叉类型",
      "url": "https://www.fedbook.cn/frontend-knowledge/typescript/union-and-intersection/",
      "id": "https://www.fedbook.cn/frontend-knowledge/typescript/union-and-intersection/",
      "content_html": "<h1 id=\"联合类型与交叉类型\"> 联合类型与交叉类型</h1>\n<p>前面介绍的基础类型、字面量类型、函数类型及接口类型，它们都是单一、原子的类型元素。在一些稍微复杂、实际编程场景中，我们还需要通过组合/结合单一、原子类型构造更复杂的类型，以此描述更复杂的数据和结构。于是引入了联合和交叉类型。</p>\n<h2 id=\"联合类型\"> 联合类型</h2>\n<p>联合类型表示取值可以为多种类型中的一种，通过 <code>|</code> 操作符分隔类型的语法来表示联合类型。</p>\n<div><pre><code><span>let</span> myFavoriteNumber<span>:</span> <span>string</span> <span>|</span> <span>number</span><span>;</span>\nmyFavoriteNumber <span>=</span> <span>'seven'</span><span>;</span>\nmyFavoriteNumber <span>=</span> <span>7</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型里共有的属性或方法</strong>：</p>\n<div><pre><code><span>function</span> <span>getLength</span><span>(</span>something<span>:</span> <span>string</span> <span>|</span> <span>number</span><span>)</span><span>:</span> <span>number</span> <span>{</span>\n  <span>return</span> something<span>.</span>length<span>;</span>\n<span>}</span>\n\n<span>// error: Property 'length' does not exist on type 'string | number'.</span>\n<span>//   Property 'length' does not exist on type 'number'.</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上例中，<code>length</code> 不是 <code>string</code> 和 <code>number</code> 的共有属性，所以会报错。</p>\n<p>访问 <code>string</code> 和 <code>number</code> 的共有属性是没问题的：</p>\n<div><pre><code><span>function</span> <span>getString</span><span>(</span>something<span>:</span> <span>string</span> <span>|</span> <span>number</span><span>)</span><span>:</span> <span>string</span> <span>{</span>\n  <span>return</span> something<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>联合类型的变量在被赋值的时候，会根据<strong>类型推论</strong>的规则推断出一个类型：</p>\n<div><pre><code><span>let</span> myFavoriteNumber<span>:</span> <span>string</span> <span>|</span> <span>number</span><span>;</span>\nmyFavoriteNumber <span>=</span> <span>'seven'</span><span>;</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>myFavoriteNumber<span>.</span>length<span>)</span><span>;</span> <span>// 5</span>\nmyFavoriteNumber <span>=</span> <span>7</span><span>;</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>myFavoriteNumber<span>.</span>length<span>)</span><span>;</span> <span>// 编译时报错</span>\n\n<span>// error: Property 'length' does not exist on type 'number'.</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上例中，第二行的 <code>myFavoriteNumber</code> 被推断成了 <code>string</code>，访问它的 <code>length</code> 属性不会报错。</p>\n<p>而第四行的 <code>myFavoriteNumber</code> 被推断成了 <code>number</code>，访问它的 <code>length</code> 属性时就报错了。</p>\n<blockquote>\n<p>类型推论：如果没有明确的指定类型，那么 TypeScript 会依照类型推论的规则推断出一个类型。</p>\n<ul>\n<li>TypeScript 会在没有明确的指定类型的时候，根据定义时的赋值，推测出一个类型，这就是类型推论。</li>\n<li>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 <code>any</code> 类型而完全不被类型检查。</li>\n</ul>\n</blockquote>\n<h2 id=\"交叉类型\"> 交叉类型</h2>\n<p>交叉类型可以把多个类型合并成一个类型，合并后的类型将拥有所有成员类型的特性。通过 <code>&amp;</code> 操作符来声明交叉类型。</p>\n<div><pre><code><span>type</span> <span>Useless</span> <span>=</span> <span>string</span> <span>&amp;</span> <span>number</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>显然，如果仅仅把原始类型、字面量类型、函数类型等原子类型合并成交叉类型，是没有任何用处的，因为任何类型都不能满足同时属于多种原子类型，比如既是 <code>string</code> 类型又是 <code>number</code> 类型。因此，在上述的代码中，类型别名 <code>Useless</code> 的类型就是个 <code>never</code>。</p>\n<h3 id=\"合并接口类型\"> 合并接口类型</h3>\n<p>联合类型真正的用武之地就是将多个接口类型合并成一个类型，从而实现等同接口继承的效果，也就是所谓的合并接口类型，如下代码所示：</p>\n<div><pre><code><span>type</span> <span>IntersectionType</span> <span>=</span> <span>{</span> id<span>:</span> <span>number</span><span>;</span> name<span>:</span> <span>string</span><span>;</span> <span>}</span> \n  <span>&amp;</span> <span>{</span> age<span>:</span> <span>number</span> <span>}</span><span>;</span>\n<span>const</span> mixed<span>:</span> IntersectionType <span>=</span> <span>{</span>\n  id<span>:</span> <span>1</span><span>,</span>\n  name<span>:</span> <span>'name'</span><span>,</span>\n  age<span>:</span> <span>18</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>在上述示例中，我们通过交叉类型，使得 <code>IntersectionType</code> 同时拥有了 <code>id</code>、<code>name</code>、<code>age</code> 所有属性，这里我们可以试着将合并接口类型理解为求并集。</p>\n<p><strong>如果合并的多个接口类型存在同名属性会是什么效果呢</strong>？</p>\n<ul>\n<li>如果同名属性的类型不兼容（一个是 <code>number</code>，另一个是 <code>string</code>），合并后就是交叉类型，即 <code>never</code>。</li>\n<li>如果同名属性的类型兼容（一个是 <code>number</code>，另一个是 <code>number</code> 的子类型、数字字面量类型），合并后就是两者中的子类型。</li>\n</ul>\n<h3 id=\"合并联合类型\"> 合并联合类型</h3>\n<p>可以合并联合类型为一个交叉类型，这个交叉类型需要同时满足不同的联合类型限制，也就是提取了所有联合类型的相同类型成员。</p>\n<p><strong>可以将合并联合类型理解为求交集</strong>。</p>\n<p>在如下示例中，两个联合类型交叉出来的类型 IntersectionUnion 其实等价于 <code>'em' | 'rem'</code>，所以只能把 <code>'em'</code> 或者 <code>'rem'</code> 字符串赋值给 IntersectionUnion 类型的变量。</p>\n<div><pre><code><span>type</span> <span>UnionA</span> <span>=</span> <span>'px'</span> <span>|</span> <span>'em'</span> <span>|</span> <span>'rem'</span> <span>|</span> <span>'%'</span><span>;</span>\n<span>type</span> <span>UnionB</span> <span>=</span> <span>'vh'</span> <span>|</span> <span>'em'</span> <span>|</span> <span>'rem'</span> <span>|</span> <span>'pt'</span><span>;</span>\n<span>type</span> <span>IntersectionUnion</span> <span>=</span> UnionA <span>&amp;</span> UnionB<span>;</span>\n<span>const</span> intersectionA<span>:</span> IntersectionUnion <span>=</span> <span>'em'</span><span>;</span> <span>// ok</span>\n<span>const</span> intersectionB<span>:</span> IntersectionUnion <span>=</span> <span>'rem'</span><span>;</span> <span>// ok</span>\n<span>const</span> intersectionC<span>:</span> IntersectionUnion <span>=</span> <span>'px'</span><span>;</span> <span>// ts(2322)</span>\n<span>const</span> intersectionD<span>:</span> IntersectionUnion <span>=</span> <span>'pt'</span><span>;</span> <span>// ts(2322)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>既然是求交集，如果多个联合类型中没有相同的类型成员，交叉出来的类型自然就是 <code>never</code> 了，如下代码所示：</p>\n<div><pre><code><span>type</span> <span>UnionC</span> <span>=</span> <span>'em'</span> <span>|</span> <span>'rem'</span><span>;</span>\n<span>type</span> <span>UnionD</span> <span>=</span> <span>'px'</span> <span>|</span> <span>'pt'</span><span>;</span>\n<span>type</span> <span>IntersectionUnionE</span> <span>=</span> UnionC <span>&amp;</span> UnionD<span>;</span>\n<span>const</span> intersectionE<span>:</span> IntersectionUnionE <span>=</span> <span>'any'</span> <span>as</span> <span>any</span><span>;</span> <span>// ts(2322) 不能赋予 'never' 类型</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>在上述示例中，因为 UnionC 和 UnionD 没有交集，交叉出来的类型 IntersectionUnionE 就是 <code>never</code>，所以我们不能把任何类型的值赋予 IntersectionUnionE 类型的变量。</p>\n<h2 id=\"联合、交叉组合\"> 联合、交叉组合</h2>\n<p>当联合、交叉类型直接组合使用时，联合操作符 <code>|</code> 的优先级低于交叉操作符 <code>&amp;</code>。</p>\n<div><pre><code><span>// 交叉操作符优先级高于联合操作符</span>\n<span>type</span> <span>UnionIntersectionA</span> <span>=</span> <span>{</span> id<span>:</span> <span>number</span><span>;</span> <span>}</span> <span>&amp;</span> <span>{</span> name<span>:</span> <span>string</span><span>;</span> <span>}</span> <span>|</span> <span>{</span> id<span>:</span> <span>string</span><span>;</span> <span>}</span> <span>&amp;</span> <span>{</span> name<span>:</span> <span>number</span><span>;</span> <span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>可以通过使用小括弧 <code>()</code> 来调整操作符的优先级。</p>\n<div><pre><code><span>// 调整优先级</span>\n<span>type</span> <span>UnionIntersectionB</span> <span>=</span> <span>(</span><span>'px'</span> <span>|</span> <span>'em'</span> <span>|</span> <span>'rem'</span> <span>|</span> <span>'%'</span><span>)</span> <span>|</span> <span>(</span><span>'vh'</span> <span>|</span> <span>'em'</span> <span>|</span> <span>'rem'</span> <span>|</span> <span>'pt'</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>接下来，就可以把数学中的分配率、交换律等基本规则引入类型组合中，然后优化出更简洁、清晰的类型，如下代码所示：</p>\n<div><pre><code><span>// 原类型</span>\n<span>type</span> <span>UnionIntersectionC</span> <span>=</span> <span>(</span><span>{</span> id<span>:</span> <span>number</span><span>;</span> <span>}</span> <span>&amp;</span> <span>{</span> name<span>:</span> <span>string</span><span>;</span> <span>}</span> <span>|</span> <span>{</span> id<span>:</span> <span>string</span><span>;</span> <span>}</span><span>)</span> <span>&amp;</span> <span>{</span> name<span>:</span> <span>number</span><span>;</span> <span>}</span><span>;</span>\n\n<span>// 展开：满足分配率</span>\n<span>type</span> <span>UnionIntersectionD</span> <span>=</span> <span>{</span> id<span>:</span> <span>number</span><span>;</span> <span>}</span> <span>&amp;</span> <span>{</span> name<span>:</span> <span>string</span><span>;</span> <span>}</span> <span>&amp;</span> <span>{</span> name<span>:</span> <span>number</span><span>;</span> <span>}</span> <span>|</span> <span>{</span> id<span>:</span> <span>string</span><span>;</span> <span>}</span> <span>&amp;</span> <span>{</span> name<span>:</span> <span>number</span><span>;</span> <span>}</span><span>;</span>\n\n<span>// 调整顺序：满足交换律</span>\n<span>type</span> <span>UnionIntersectionE</span> <span>=</span> <span>(</span><span>{</span> id<span>:</span> <span>string</span><span>;</span> <span>}</span> <span>|</span> <span>{</span> id<span>:</span> <span>number</span><span>;</span> <span>}</span> <span>&amp;</span> <span>{</span> name<span>:</span> <span>string</span><span>;</span> <span>}</span><span>)</span> <span>&amp;</span> <span>{</span> name<span>:</span> <span>number</span><span>;</span> <span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"类型缩减\"> 类型缩减</h2>\n<p>如果将 <code>string</code> 原始类型和「string 字面量类型」组合成联合类型，效果就是类型缩减成 <code>string</code> 了。</p>\n<p>同样，对于 <code>number</code>、<code>boolean</code>、枚举类型也是一样的缩减逻辑。</p>\n<div><pre><code><span>type</span> <span>URStr</span> <span>=</span> <span>'string'</span> <span>|</span> <span>string</span><span>;</span> <span>// 类型是 string</span>\n<span>type</span> <span>URNum</span> <span>=</span> <span>2</span> <span>|</span> <span>number</span><span>;</span>        <span>// 类型是 number</span>\n<span>type</span> <span>URBoolen</span> <span>=</span> <span>true</span> <span>|</span> <span>boolean</span><span>;</span> <span>// 类型是 boolean</span>\n<span>enum</span> EnumUR <span>{</span>\n  <span>ONE</span><span>,</span>\n  <span>TWO</span>\n<span>}</span>\n<span>type</span> <span><span>URE</span></span> <span>=</span> EnumUR<span>.</span><span>ONE</span> <span>|</span> EnumUR<span>;</span> <span>// 类型是 EnumUR</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>TypeScript 对这样的场景做了缩减，它把字面量类型、枚举成员类型缩减掉，只保留原始类型、枚举类型等父类型，这是合理的「优化」。</p>\n<p>可是这个缩减，却极大地削弱了 IDE 自动补全的能力，也就是使用如下定义的类型来声明和赋值变量时，由于类型被缩减成 <code>string</code> 了，IDE 也就没法联想出这些字符串字面量作为赋值可选值。</p>\n<div><pre><code><span>// 类型缩减成 string</span>\n<span>type</span> <span>BorderColor</span> <span>=</span> <span>'black'</span> <span>|</span> <span>'red'</span> <span>|</span> <span>'green'</span> <span>|</span> <span>'yellow'</span> <span>|</span> <span>'blue'</span> <span>|</span> <span>string</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>不过 TypeScript 官方也提供了一个黑魔法，它可以让类型缩减被控制。如下代码所示，我们只需要给父类型添加「&amp; {}」即可。</p>\n<div><pre><code><span>// 字面类型都被保留</span>\n<span>type</span> <span>BorderColor</span> <span>=</span> <span>'black'</span> <span>|</span> <span>'red'</span> <span>|</span> <span>'green'</span> <span>|</span> <span>'yellow'</span> <span>|</span> <span>'blue'</span> <span>|</span> <span>string</span> <span>&amp;</span> <span>{</span><span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><div style=\"text-align: center;\">\n  <img src=\"./assets/vscode-automatically-prompts.png\" alt=\"VS Code 自动提示效果图\">\n  <p style=\"text-align: center; color: #888;\">（VS Code 自动提示效果图）</p>\n</div>\n<p>此外，当联合类型的成员是接口类型，如果满足其中一个接口的属性是另外一个接口属性的子集，这个属性也会类型缩减，如下代码所示：</p>\n<div><pre><code><span>type</span> <span>UnionInterce</span> <span>=</span>\n<span>|</span> <span>{</span>\n    age<span>:</span> <span>'1'</span><span>;</span>\n  <span>}</span>\n<span>|</span> <span>(</span><span>{</span>\n    age<span>:</span> <span>'1'</span> <span>|</span> <span>'2'</span><span>;</span>\n    <span>[</span>key<span>:</span> <span>string</span><span>]</span><span>:</span> <span>string</span><span>;</span>\n  <span>}</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>这里因为 <code>'1'</code> 是 <code>'1' | '2'</code> 的子集，所以 <code>age</code> 的属性变成 <code>'1' | '2'</code>。</p>\n<h3 id=\"高级用法\"> 高级用法</h3>\n<p>如何定义如下所示 <code>age</code> 属性是数字类型，而其他不确定的属性是字符串类型的数据结构的对象？</p>\n<div><pre><code><span>{</span>\n  age<span>:</span> <span>1</span><span>,</span> <span>// 数字类型</span>\n  anyProperty<span>:</span> <span>'str'</span><span>,</span> <span>// 其他不确定的属性都是字符串类型</span>\n  <span>...</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>思路肯定是用到两个接口的联合类型及类型缩减。这个问题的核心在于找到一个既是 <code>number</code> 的子类型，这样 <code>age</code> 类型缩减之后的类型就是 <code>number</code>；同时也是 <code>string</code> 的子类型，这样才能满足属性和 <code>string</code> 索引类型的约束关系。</p>\n<p>哪个类型满足这个条件呢？</p>\n<p>特殊类型 <code>never</code> —— 它是所有类型的子类型。答案如下：</p>\n<div><pre><code><span>type</span> <span>UnionInterce</span> <span>=</span>\n<span>|</span> <span>{</span>\n    age<span>:</span> <span>number</span><span>;</span>\n  <span>}</span>\n<span>|</span> <span>(</span><span>{</span>\n    age<span>:</span> <span>never</span><span>;</span>\n    <span>[</span>key<span>:</span> <span>string</span><span>]</span><span>:</span> <span>string</span><span>;</span>\n  <span>}</span><span>)</span><span>;</span>\n<span>const</span> <span>O</span><span>:</span> UnionInterce <span>=</span> <span>{</span>\n  age<span>:</span> <span>2</span><span>,</span>\n  <span>string</span><span>:</span> <span>'string'</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>在上述代码中，我们在第 3 行定义了 number 类型的 age 属性，第 6 行定义了 never 类型的 age 属性，等价于 age 属性的类型是由 number 和 never 类型组成的联合类型，所以我们可以把 number 类型的值（比如说数字字面量 1）赋予 age 属性；但是不能把其他任何类型的值（比如说字符串字面量 'string' ）赋予 age。</p>\n<p>同时，我们在第 5 行~第 8 行定义的接口类型中，还额外定义了 string 类型的字符串索引签名。因为 never 同时又是 string 类型的子类型，所以 age 属性的类型和字符串索引签名类型不冲突。如第 9 行~第 12 行所示，我们可以把一个 age 属性是 2、string 属性是 'string' 的对象字面量赋值给 UnionInterce 类型的变量 O。</p>\n<p>（完）</p>\n",
      "date_published": "2022-04-12T09:36:50.000Z",
      "date_modified": "2022-04-12T09:36:50.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "更新日志",
      "url": "https://www.fedbook.cn/history/",
      "id": "https://www.fedbook.cn/history/",
      "content_html": "<h1 id=\"更新日志\"> 更新日志</h1>\n<p>记录走过的每一步……</p>\n<h2 id=\"前端知识-html\"> 前端知识 - HTML</h2>\n<ul>\n<li>2020.07.17   添加《HTML 基本结构》章节。</li>\n<li>2020.07.12   添加《语义类标签》章节。</li>\n</ul>\n<h2 id=\"前端知识-css\"> 前端知识 - CSS</h2>\n<ul>\n<li>2020.11.01   添加《经典布局》章节。</li>\n<li>2020.10.28   添加《Flexbox 布局》章节。</li>\n<li>2020.10.20   添加《浮动（float）》章节。</li>\n<li>2020.09.17   添加《伪元素和伪类》章节。</li>\n<li>2020.07.26   添加《定位（position）》章节，《盒模型》章节增加「边距和边框」的内容。</li>\n<li>2020.07.23   添加《盒模型》章节。</li>\n<li>2020.07.19   添加《选择器与样式优先级》、《长度和单位》章节。</li>\n<li>2020.07.18   添加《CSS 引入方式》章节。</li>\n</ul>\n<h2 id=\"前端知识-javascript\"> 前端知识 - JavaScript</h2>\n<ul>\n<li>2021.10.28   添加《垃圾回收》章节。</li>\n<li>2021.05.31   添加《对象遍历的几种方式》章节。</li>\n<li>2021.03.19   添加《数组遍历的几种方式》章节。</li>\n<li>2021.03.07   添加《函数柯里化》章节。</li>\n<li>2021.03.06   添加《浅克隆与深克隆》章节。</li>\n<li>2020.09.14   添加《同步与异步》章节。</li>\n<li>2020.09.13   添加《事件循环机制》章节。</li>\n<li>2020.09.11   添加《声明函数的六种方式》章节。</li>\n<li>2020.09.08   更新《数据类型》章节，增加 Symbol（ECMAScript 2015）和 BigInt（ECMAScript 2020）。</li>\n<li>2020.09.07   添加《调用函数的四种方式》章节。</li>\n<li>2020.08.30   添加《继承的八种实现方式》章节。</li>\n<li>2020.08.25   添加《原型与原型链》章节。</li>\n<li>2020.08.13   添加《this 指向》章节。</li>\n<li>2020.08.13   添加《闭包》章节。</li>\n<li>2020.08.12   添加《作用域》章节。</li>\n<li>2020.08.09   添加《执行上下文》章节。</li>\n<li>2020.08.02   添加《数据类型》章节。</li>\n</ul>\n<h2 id=\"前端知识-typescript\"> 前端知识 - TypeScript</h2>\n<ul>\n<li>2021.07.26   添加《泛型》章节。</li>\n<li>2021.07.21   添加《函数类型》章节。</li>\n<li>2021.07.21   添加《对象类型：接口》章节。</li>\n<li>2021.07.17   添加《空值、未定义和不存在》章节。</li>\n<li>2021.07.15   添加《任意类型与未知类型》章节。</li>\n<li>2021.07.14   添加《枚举》章节。</li>\n<li>2021.07.13   添加《联合和字面量》章节。</li>\n<li>2021.07.12   添加《数据类型简介》、《布尔、数值与字符串》、《数组和元组》章节。</li>\n</ul>\n<h2 id=\"工程化-vue-js\"> 工程化 - Vue.js</h2>\n<ul>\n<li>2021.05.28   添加《前端路由原理》章节。</li>\n<li>2021.05.25   添加《组件渲染与更新》章节。</li>\n<li>2021.05.24   添加《模板编译》章节。</li>\n<li>2021.05.22   添加《虚拟 DOM 与 diff 算法》章节。</li>\n<li>2021.05.11   添加《响应式原理》章节。</li>\n<li>2021.05.06   添加《高级用法特性》章节。</li>\n<li>2021.04.23   添加《基础用法要点》章节。</li>\n</ul>\n<h2 id=\"工程化-react\"> 工程化 - React</h2>\n<ul>\n<li>2021.08.08   添加《React JSX》章节。</li>\n</ul>\n<h2 id=\"工程化-webpack\"> 工程化 - Webpack</h2>\n<ul>\n<li>2021.06.20   添加《最佳实践 - 通用模板》章节。</li>\n<li>2021.06.15   添加《性能优化 - 产出代码》章节。</li>\n<li>2021.06.13   添加《核心概念》、《性能优化 - 构建速度》章节。</li>\n<li>2021.06.09   添加《高级配置》章节。</li>\n<li>2021.06.06   添加《基本配置》章节。</li>\n</ul>\n<h2 id=\"后端知识-python\"> 后端知识 - Python</h2>\n<ul>\n<li>2021.07.30   添加《使用 xlrd 处理旧版本 Excel》章节。</li>\n<li>2021.07.29   添加《使用 openpyxl 处理新版本 Excel》章节。</li>\n<li>2021.07.27   添加《使用 smtplib 发送电子邮件》章节。</li>\n<li>2021.07.15   添加《使用 subprocess 执行 cmd》章节。</li>\n<li>2021.07.14   添加《使用 Fabric 执行 SSH》章节。</li>\n<li>2021.07.13   添加《使用 telnetlib 执行 Telnet》、《使用 Paramiko 执行 SSH》章节。</li>\n<li>2021.01.16   添加《编译器与解释器》章节。</li>\n<li>2021.01.13   添加《类成员保护》章节。</li>\n<li>2021.01.12   添加《类和实例》、《类的继承》章节。</li>\n<li>2021.01.11   添加《函数装饰器》、《面向对象编程》章节。</li>\n<li>2021.01.09   添加《变量与常量》、《数据类型》、《函数参数》章节。</li>\n<li>2021.01.06   添加《语法规范》章节。</li>\n</ul>\n<h2 id=\"必知必会-nginx\"> 必知必会 - Nginx</h2>\n<ul>\n<li>2021.07.22   添加《Nginx 限流常用模块》章节。</li>\n<li>2021.07.11   添加《Nginx 部署前后端分离项目》章节。</li>\n<li>2021.07.10   添加《Nginx 安全访问控制》、《Nginx 文件列表功能》、《Nginx 页面安全认证》、《Nginx 部署 Https 安全认证》章节。</li>\n<li>2021.07.04   添加《Nginx 配置文件详解》、《Nginx 配置文件模板》章节。</li>\n<li>2021.07.03   添加《Nginx 设置开机自启》章节。</li>\n<li>2021.07.02   添加《Nginx 的安装》、《Nginx 的卸载》、《Nginx 常用命令》章节。</li>\n<li>2021.07.01   添加《负载均衡》章节。</li>\n<li>2021.06.30   添加《正向代理与反向代理》章节。</li>\n</ul>\n<h2 id=\"深入学习-数据结构与算法\"> 深入学习 - 数据结构与算法</h2>\n<ul>\n<li>2021.04.11   添加《数据结构之链表》章节。</li>\n<li>2021.04.03   添加《数据结构之数组》章节。</li>\n<li>2021.03.30   添加《复杂度分析》章节。</li>\n</ul>\n<h2 id=\"深入学习-源码阅读与学习\"> 深入学习 - 源码阅读与学习</h2>\n<ul>\n<li>时间待定   添加《Vue3 源码中的基础工具函数》章节。</li>\n</ul>\n<h2 id=\"手写系列-javascript-手写函数\"> 手写系列 - JavaScript 手写函数</h2>\n<ul>\n<li>2021.03.02   添加《实现 apply 方法》、《实现 bind 方法》章节。</li>\n<li>2021.03.01   添加《实现 call 方法》章节。</li>\n<li>2021.02.28   添加《实现 new 运算符》章节。</li>\n<li>2021.02.27   添加《实现浅克隆（shallowClone）》、《实现深克隆（deepClone）》、《实现 instanceof 运算符》、《实现 Object.create 方法》章节。</li>\n<li>2021.02.26   添加《实现防抖函数（debounce）》、《实现节流函数（throttle）》章节。</li>\n</ul>\n<h2 id=\"面试相关\"> 面试相关</h2>\n<ul>\n<li>2020.10.07   添加《CSS 问题》章节。</li>\n<li>2020.10.03   添加《HTML 问题》章节。</li>\n</ul>\n<h2 id=\"维护\"> 维护</h2>\n<ul>\n<li>2021.07.16   升级 vuepress-theme-hope 主题至最新版本（1.19.0），并删除/覆盖一些样式。</li>\n<li>2021.01.09   升级 vuepress-theme-hope 主题至最新版本（1.8.1），并覆盖一些过于酷炫的样式。</li>\n<li>2020.10.26   移除 vuepress-plugin-demo-block 插件，改用 CodePen。</li>\n<li>2020.10.11   使用 <a href=\"https://daxigua.me/vuepress-plugin-demo-block/zh/\" title=\"vuepress-plugin-demo-block\" target=\"_blank\" rel=\"noopener noreferrer\">vuepress-plugin-demo-block</a> 插件。\n<ul>\n<li>让 Demo 演示框（主要是 CSS 知识点中的代码）更直观，方便调试。</li>\n</ul>\n</li>\n<li>2020.09.27   使用 <a href=\"https://vuepress-theme-hope.github.io/\" title=\"vuepress-theme-hope\" target=\"_blank\" rel=\"noopener noreferrer\">vuepress-theme-hope</a> 主题。\n<ul>\n<li>在内容页，左侧展示文章标题列表、右侧展示当前文章的子标题，这样的排版可读性较好。</li>\n</ul>\n</li>\n<li>2020.08.17   服务方不稳定，新增多线路切换访问。</li>\n<li>2020.07.26   购买域名，部署上线。</li>\n<li>2020.07.11   使用 VuePress 搭建小册。</li>\n</ul>\n",
      "date_published": "2020-08-08T09:13:58.000Z",
      "date_modified": "2022-02-28T14:35:04.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "数据结构与算法",
      "url": "https://www.fedbook.cn/in-depth-learning/algorithm/",
      "id": "https://www.fedbook.cn/in-depth-learning/algorithm/",
      "content_html": "<h1 id=\"数据结构与算法\"> 数据结构与算法</h1>\n<p><strong>为什么要学习数据结构与算法（Why）</strong>：</p>\n<ul>\n<li>我本科读的非科班，靠自学入的行，因此这块知识需要补齐。</li>\n<li>掌握了数据结构与算法，平时能有意识和能力写出性能更优的代码。</li>\n<li>长期来看，拥有算法思维能有效训练自己大脑的思考能力，对工作和生活都有益。</li>\n<li>现在大厂都喜欢考算法，这已经成了敲门砖。</li>\n</ul>\n<hr>\n<p><strong>什么是数据结构与算法（What）</strong>：</p>\n<p>从广义上讲，数据结构就是指一组数据的存储结构；算法就是操作数据的一组方法。<br>\n从狭义上讲，数据结构就是指队列、栈、堆等；算法就是指二分查找、动态规划等。</p>\n<p>之所以把两者放在一起，是因为数据结构和算法是相辅相成的。数据结构是为算法服务的，算法要作用在特定的数据结构之上。因此，我们无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构。</p>\n<hr>\n<p><strong>怎么学数据结构与算法（How）</strong>：</p>\n<p>作为一名前端开发工程师，我主要学习一些基础且重点的部分，这样有针对性地学习，效果会更好，也不容易被劝退。</p>\n<p>主要有：</p>\n<ul>\n<li>10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树。</li>\n<li>10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。</li>\n</ul>\n<p>前期学习过程中主要用 JavaScript 语言来实现一遍，后期学习完 TypeScript 后会抽时间用 TypeScript 再实现一遍。如果有必要也会用 Python 来实现一遍。</p>\n<div style=\"text-align: right\">\n  <svg t=\"1607526012170\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"10484\" width=\"64\" height=\"64\"><path d=\"M737.6 356.608a8.96 8.96 0 0 1 12.096-1.472l235.712 175.36a18.688 18.688 0 0 1 2.88 2.688v0.064a15.808 15.808 0 0 1-2.88 23.04l-235.712 175.36c0 2.56-1.28 4.928-3.328 6.464a8.96 8.96 0 0 1-12.096-1.472 7.936 7.936 0 0 1 1.536-11.456v-83.2c0-2.56 1.28-4.928 3.328-6.464l123.776-92.16-123.776-92.096a7.808 7.808 0 0 1-3.328-6.4V361.6c0-1.792 0.64-3.584 1.792-4.992z m-458.112-3.2c4.736-0.064 8.64 3.584 8.64 8.128v83.2c0 2.56-1.28 4.864-3.328 6.4L161.024 543.36l123.776 92.16c2.112 1.472 3.328 3.84 3.328 6.272v83.328c0 1.792-0.64 3.584-1.792 4.992a8.96 8.96 0 0 1-12.096 1.472L38.528 556.16a15.872 15.872 0 0 1 0-25.792l235.712-175.296a8.704 8.704 0 0 1 5.248-1.728z\" fill=\"#101A33\" p-id=\"10485\"></path><path d=\"M672.576 192H599.936a8.704 8.704 0 0 0-8.192 5.44v0.064L342.72 885.184a8.128 8.128 0 0 0 5.312 10.368c0.96 0.32 1.92 0.448 2.88 0.448h72.96a8.704 8.704 0 0 0 8.192-5.44v-0.064l0.768-2.176 248.064-685.44a8.192 8.192 0 0 0-5.504-10.432A9.28 9.28 0 0 0 672.64 192z\" fill=\"#107CEE\" p-id=\"10486\"></path></svg>\n</div>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2022-03-30T06:40:43.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "未完待续",
      "url": "https://www.fedbook.cn/in-depth-learning/algorithm/to-be-continued/",
      "id": "https://www.fedbook.cn/in-depth-learning/algorithm/to-be-continued/",
      "content_html": "<h1 id=\"未完待续\"> 未完待续</h1>\n<h2 id=\"知识点正在火速整理中\"> 知识点正在火速整理中</h2>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2021-11-19T03:27:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "设计模式简介",
      "url": "https://www.fedbook.cn/in-depth-learning/design-patterns/23-patterns/",
      "id": "https://www.fedbook.cn/in-depth-learning/design-patterns/23-patterns/",
      "content_html": "<h1 id=\"设计模式简介\"> 设计模式简介</h1>\n<p>一共有 23 种设计模式，它们分为三种类型。</p>\n<blockquote>\n<p>对于前端开发来说，并不是所有设计模式都是适合 JavaScript 的，需要重点的是工厂模式、单例模式、观察者模式。</p>\n<p>因此，对于一些不那么常用的模式，了解一下，知道其主要思想即可。下面加粗的是前端常用的设计模式，未加粗的是前端不常用的设计模式。</p>\n</blockquote>\n<h2 id=\"创建型模式\"> 创建型模式</h2>\n<p>创建型模式关注<strong>如何创建对象</strong>，主要特点是将对象的创建和使用分离。一般抽象了对象实例化的过程，用来帮助创建对象的实例。</p>\n<ul>\n<li><strong>工厂模式</strong>（Factory Pattern）\n<ul>\n<li>工厂方法模式（Factory Method Pattern）：根据输入的不同返回不同类的实例，一般用来创建同一类对象。</li>\n<li>抽象工厂模式（Abstract Factory Pattern）：通过对类的工厂抽象，使其业务用于对产品类簇的创建。</li>\n<li>建造者模式（Builder Pattern）：分步构建一个复杂对象，使得同样的构建过程可以采用不同的表示。</li>\n</ul>\n</li>\n<li><strong>单例模式</strong>（Singleton Pattern）：保证一个类只有一个实例，并提供一个访问它的全局访问点。</li>\n<li>原型模式（Prototype Pattern）：已经在 JavaScript 内建的一种模式。</li>\n</ul>\n<h2 id=\"结构型模式\"> 结构型模式</h2>\n<p>结构型模式关注如何<strong>将对象按某种布局组成更大的结构</strong>。</p>\n<ul>\n<li><strong>适配器模式</strong>（Adapter Pattern）： 解决两个软件实体间接口不兼容的问题。</li>\n<li><strong>装饰器模式</strong>（Decorator Pattern）：向一个现有的对象添加新的功能，同时又不改变其结构。</li>\n<li><strong>代理模式</strong>（Proxy pattern）：为目标对象创造一个代理对象，以控制对目标对象的访问。</li>\n<li><strong>外观模式</strong>（Facade Pattern）：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li>\n<li>桥接模式（Bridge Pattern）：将类的抽象部分与实现部分分离，使它们可以独立地变化。</li>\n<li>组合模式（Composite Pattern）：用小的子对象构建更大的对象，使得对单个对象和组合对象具有一致的访问性。</li>\n<li>享元模式（Flyweight Pattern）：运用共享技术来有效地支持大量细粒度对象的复用，减少创建的对象的数量。</li>\n</ul>\n<h2 id=\"行为型模式\"> 行为型模式</h2>\n<p>行为型模式关注<strong>对象之间的通信</strong>，描述对象之间怎样相互协作，以及怎样分配职责。</p>\n<ul>\n<li><strong>观察者模式</strong>（Observer Pattern）：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li>\n<li><strong>迭代器模式</strong>（Iterator Pattern）：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li>\n<li><strong>状态模式</strong>（State Pattern）：允许一个对象在其内部状态发生改变时改变其行为能力。</li>\n<li>策略模式（Strategy Pattern）：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换。</li>\n<li>模板方法模式（Template Method Pattern）：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</li>\n<li>职责链模式（Chain of Responsibility Pattern）：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。</li>\n<li>命令模式（Command Pattern）：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</li>\n<li>备忘录模式（Memento Pattern）：用于随时记录一个对象的状态变化，随时可以恢复之前的某个状态（如撤销功能）。</li>\n<li>中介者模式（Mediator Pattern）：定义一个中介对象来简化原有对象之间的复杂耦合关系。</li>\n<li>访问者模式（Visitor Pattern）：用于将数据操作和数据结构进行分离。</li>\n<li>解释器模式（Interpreter Pattern）：用于描述语言语法如何定义，如何解释和编译</li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-03-20T03:41:40.000Z",
      "date_modified": "2022-03-30T15:28:58.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "复杂度分析",
      "url": "https://www.fedbook.cn/in-depth-learning/algorithm/complexity-analysis/",
      "id": "https://www.fedbook.cn/in-depth-learning/algorithm/complexity-analysis/",
      "content_html": "<h1 id=\"复杂度分析\"> 复杂度分析</h1>\n<h2 id=\"复杂度是什么\"> 复杂度是什么</h2>\n<p>数据结构和算法解决的是如何让代码运行得更快，如何让代码更省存储空间。</p>\n<p>因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能，这两个维度的性能指标分别用<strong>时间复杂度</strong>和<strong>空间复杂度</strong>两个概念来描述，二者统称为<strong>复杂度</strong>。</p>\n<h2 id=\"复杂度表示法\"> 复杂度表示法</h2>\n<p>复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系，通常采用大 O 表示法。</p>\n<h2 id=\"时间复杂度\"> 时间复杂度</h2>\n<p>算法的执行效率，粗略地讲，就是算法代码执行的时间。由于我们只是粗略估算，所以可以假定每行代码的执行时间都是一样的，表示一个单位时间：<code>unit_time</code>。</p>\n<p>例如下面这段伪代码，作用是求 <code>1, 2, 3 ... n</code> 的累加和：</p>\n<div><pre><code><span>int</span> <span>cal</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>\n  <span>int</span> sum <span>=</span> <span>0</span><span>;</span>            <span>// unit_time</span>\n  <span>int</span> i <span>=</span> <span>1</span><span>;</span>              <span>// unit_time</span>\n  <span>for</span> <span>(</span><span>;</span> i <span>&lt;=</span> n<span>;</span> <span>++</span>i<span>)</span> <span>{</span>   <span>// n * unit_time</span>\n    sum <span>=</span> sum <span>+</span> i<span>;</span>        <span>// n * unit_time</span>\n  <span>}</span>\n  <span>return</span> sum<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>第 2、3 行代码分别需要 1 个 <code>unit_time</code> 的执行时间，第 4、5 行都运行了 n 遍，所以需要 <code>2n * unit_time</code> 的执行时间。</p>\n<p>这段代码总的执行时间就是 <code>(2n + 2) * unit_time</code>。可以看出来，<strong>所有代码的执行时间 T(n) 与每行代码的执行次数 f(n) 成正比</strong>。</p>\n<div><pre><code><span>T</span><span>(</span>n<span>)</span> <span>=</span> <span>O</span><span>(</span><span>f</span><span>(</span>n<span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>其中，T(n) 表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。</p>\n<p>所以，上面的伪代码示例中 <code>T(n) = O(2n + 2)</code>，这就是<strong>大 O 时间复杂度表示法</strong>。大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong>，所以，也叫作<strong>渐进时间复杂度</strong>，简称<strong>时间复杂度</strong>。</p>\n<h2 id=\"时间复杂度分析\"> 时间复杂度分析</h2>\n<p>有三个比较实用的方法可以用来分析一段代码的时间复杂度。</p>\n<h3 id=\"_1-只关注循环执行次数最多的一段代码\"> 1）只关注循环执行次数最多的一段代码</h3>\n<p>当有嵌套循环的时候，例如：</p>\n<div><pre><code><span>int</span> <span>cal</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>\n  <span>int</span> sum <span>=</span> <span>0</span><span>;</span>             <span>// unit_time</span>\n  <span>int</span> i <span>=</span> <span>1</span><span>;</span>               <span>// unit_time</span>\n  <span>int</span> j <span>=</span> <span>1</span><span>;</span>               <span>// unit_time</span>\n  <span>for</span> <span>(</span><span>;</span> i <span>&lt;=</span> n<span>;</span> <span>++</span>i<span>)</span> <span>{</span>    <span>// n * unit_time</span>\n    j <span>=</span> <span>1</span><span>;</span>                 <span>// n * unit_time</span>\n    <span>for</span> <span>(</span><span>;</span> j <span>&lt;=</span> n<span>;</span> <span>++</span>j<span>)</span> <span>{</span>  <span>// n^2 * unit_time</span>\n      sum <span>=</span> sum <span>+</span>  i <span>*</span> j<span>;</span>  <span>// n^2 * unit_time</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上述伪代码的执行时间可以表示为：<code>T(n) = (2n<sup>2</sup> + 2n + 3) * unit_time</code>。前面说过，大 O 这种复杂度表示方法只是表示一种变化趋势，当 n 很大时，公式中的低阶、常量、系数三部分并不左右增长趋势，都可以忽略。我们只需要记录一个最大阶的量级就可以了，上述伪代码的时间复杂度可以表示为：<code>T(n) = O(n<sup>2</sup>)</code>。</p>\n<p>所以，<strong>我们在分析一个算法、一段代码的时间复杂度的时候，只关注循环执行次数最多的那一段代码就可以了</strong>。这段核心代码执行次数的 n 的量级，就是整段要分析代码的时间复杂度。</p>\n<h3 id=\"_2-加法法则-总复杂度等于量级最大的那段代码的复杂度\"> 2）加法法则：总复杂度等于量级最大的那段代码的复杂度</h3>\n<p>如果一段代码由多个代码块组成，例如下述伪代码：</p>\n<div><pre><code><span>int</span> <span>cal</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>\n  <span>int</span> sum_1 <span>=</span> <span>0</span><span>;</span>\n  <span>int</span> p <span>=</span> <span>1</span><span>;</span>\n  <span>for</span> <span>(</span><span>;</span> p <span>&lt;</span> <span>100</span><span>;</span> <span>++</span>p<span>)</span> <span>{</span>\n    sum_1 <span>=</span> sum_1 <span>+</span> p<span>;</span>\n  <span>}</span>\n\n  <span>int</span> sum_2 <span>=</span> <span>0</span><span>;</span>\n  <span>int</span> q <span>=</span> <span>1</span><span>;</span>\n  <span>for</span> <span>(</span><span>;</span> q <span>&lt;</span> n<span>;</span> <span>++</span>q<span>)</span> <span>{</span>\n    sum_2 <span>=</span> sum_2 <span>+</span> q<span>;</span>\n  <span>}</span>\n \n  <span>int</span> sum_3 <span>=</span> <span>0</span><span>;</span>\n  <span>int</span> i <span>=</span> <span>1</span><span>;</span>\n  <span>int</span> j <span>=</span> <span>1</span><span>;</span>\n  <span>for</span> <span>(</span><span>;</span> i <span>&lt;=</span> n<span>;</span> <span>++</span>i<span>)</span> <span>{</span>\n    j <span>=</span> <span>1</span><span>;</span> \n    <span>for</span> <span>(</span><span>;</span> j <span>&lt;=</span> n<span>;</span> <span>++</span>j<span>)</span> <span>{</span>\n      sum_3 <span>=</span> sum_3 <span>+</span>  i <span>*</span> j<span>;</span>\n    <span>}</span>\n  <span>}</span>\n \n  <span>return</span> sum_1 <span>+</span> sum_2 <span>+</span> sum_3<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>这个代码分为三部分，分别是求 sum_1、sum_2、sum_3。我们可以分别分析每一部分的时间复杂度，然后把它们放到一块儿，再取一个量级最大（项的次数最高）的作为整段代码的复杂度：</p>\n<ul>\n<li>第一段代码循环执行了 100 次，是一个常量的执行时间，跟 n 的规模无关，时间复杂度可以忽略。</li>\n<li>第二段代码循环了 n 次，时间复杂度是 <code>O(n)</code>。</li>\n<li>第三段代码嵌套循环，内外层都循环了 n 次，时间复杂度是 <code>O(n<sup>2</sup>)</code>。</li>\n<li>综合这三段代码的时间复杂度，我们取其中最大的量级，整段代码的时间复杂度就为 <code>O(n<sup>2</sup>)</code>。</li>\n</ul>\n<p><strong>总的时间复杂度就等于量级最大的那段代码的时间复杂度</strong>，抽象成公式就是：</p>\n<p>如果 <code>T1(n) = O(f(n))</code>，<code>T2(n) = O(g(n))</code>，那么 <code>T(n) = T1(n) + T2(n) = max(O(f(n)), O(g(n))) = O(max(f(n), g(n)))</code>。</p>\n<h3 id=\"_3-乘法法则-嵌套代码的复杂度等于嵌套内外代码复杂度的乘积\"> 3）乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</h3>\n<p>类比加法法则，乘法法则的公式就是：</p>\n<p>如果 <code>T1(n) = O(f(n))</code>，<code>T2(n) = O(g(n))</code>，那么 <code>T(n) = T1(n) * T2(n) = O(f(n)) * O(g(n)) = O(f(n)*g(n))</code>。</p>\n<p>假设 <code>T1(n) = O(n)</code>，<code>T2(n) = O(n<sup>2</sup>)</code>，则 <code>T1(n) * T2(n) = O(n<sup>3</sup>)</code>。</p>\n<p>落实到具体的代码上，乘法法则就是运用于<strong>嵌套函数/嵌套循环</strong>。</p>\n<h2 id=\"时间复杂度实例\"> 时间复杂度实例</h2>\n<h3 id=\"_1-o-1\"> 1）O(1)</h3>\n<p><code>O(1)</code> 是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如一段代码有 3 行，它的时间复杂度也是 <code>O(1)</code>，而不是 <code>O(3)</code>。</p>\n<p>只要代码的执行时间不随 n 的增大而增长，那么时间复杂度都记作 <code>O(1)</code>。一般情况下，只要算法中不存在循环语句（指未明确指定循环次数的情况）、递归语句，即使有成千上万行的代码，其时间复杂度也是 <code>Ο(1)</code>。</p>\n<h3 id=\"_2-o-logn\"> 2）O(logn)</h3>\n<p>对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。看下面的一个例子：</p>\n<div><pre><code>i<span>=</span><span>1</span><span>;</span>\n<span>while</span> <span>(</span>i <span>&lt;=</span> n<span>)</span>  <span>{</span>\n  i <span>=</span> i <span>*</span> <span>2</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>根据前面讲的复杂度分析方法，第 3 行代码是循环执行次数最多的。所以，只要计算出这行代码被执行了多少次，就能知道整段代码的时间复杂度。</p>\n<p>从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束。变量 i 的取值就像一个等比数列：<code>2<sup>0</sup> 2<sup>1</sup> 2<sup>2</sup> ... 2<sup>x</sup></code>，其中 <code>2<sup>x</sup> &lt;= n</code>。</p>\n<p>所以只要知道 x 的值是多少，就能知道这行代码执行的次数是多少。通过 <code>2<sup>x</sup> = n</code> 可得 <code>x = log<sub>2</sub>n</code>。</p>\n<div><p>结论</p>\n<p>实际上，在对数阶时间复杂度中，不管是以 2 为底，还是以 3 为底，甚至以 10 为底，我们都可以把所有对数阶的时间复杂度都记为 <code>O(logn)</code>。</p>\n</div>\n<p>理由：<code>log<sub>3</sub>n = log<sub>3</sub>2 * log<sub>2</sub>n</code>，所以 <code>O(log<sub>3</sub>n) = O(C * log<sub>2</sub>n)</code>，其中 <code>C = log<sub>3</sub>2</code> 是一个常量，<strong>在采用大 O 标记复杂度的时候，可以忽略系数，即 <code>O(Cf(n)) = O(f(n))</code></strong>。</p>\n<p>所以 <code>O(log<sub>3</sub>n)</code> 就等于 <code>O(log<sub>2</sub>n)</code>。</p>\n<p>因此，在对数阶时间复杂度的表示方法里，我们忽略对数的「底」，统一表示为 <code>O(logn)</code>。</p>\n<details><summary>换底公式</summary>\n<p>由<a href=\"https://www.baidu.com/s?wd=%E6%8D%A2%E5%BA%95%E5%85%AC%E5%BC%8F\" target=\"_blank\" rel=\"noopener noreferrer\">换底公式</a> <code>log<sub>a</sub>b = log<sub>c</sub>b / log<sub>c</sub>a</code> 可得：</p>\n<p><code>log<sub>2</sub>n = log<sub>3</sub>n / log<sub>3</sub>2</code>，进而可得：<code>log<sub>3</sub>n = log<sub>2</sub>n * log<sub>3</sub>2</code></p>\n</details>\n<h3 id=\"_3-o-nlogn\"> 3）O(nlogn)</h3>\n<p>根据乘法法则，如果一段代码的时间复杂度是上面分析的 <code>O(logn)</code>，循环执行 n 遍，时间复杂度就是 <code>O(nlogn)</code> 了。</p>\n<p>时间复杂度为 <code>O(nlogn)</code> 的常见算法有：归并排序、快速排序。</p>\n<h3 id=\"_4-o-m-n-、o-m-n\"> 4）O(m+n)、O(m*n)</h3>\n<p>这种情况和前面提到的加法法则不一样，如下代码：</p>\n<div><pre><code><span>int</span> <span>cal</span><span>(</span><span>int</span> m<span>,</span> <span>int</span> n<span>)</span> <span>{</span>\n  <span>int</span> sum_1 <span>=</span> <span>0</span><span>;</span>\n  <span>int</span> i <span>=</span> <span>1</span><span>;</span>\n  <span>for</span> <span>(</span><span>;</span> i <span>&lt;</span> m<span>;</span> <span>++</span>i<span>)</span> <span>{</span>\n    sum_1 <span>=</span> sum_1 <span>+</span> i<span>;</span>\n  <span>}</span>\n\n  <span>int</span> sum_2 <span>=</span> <span>0</span><span>;</span>\n  <span>int</span> j <span>=</span> <span>1</span><span>;</span>\n  <span>for</span> <span>(</span><span>;</span> j <span>&lt;</span> n<span>;</span> <span>++</span>j<span>)</span> <span>{</span>\n    sum_2 <span>=</span> sum_2 <span>+</span> j<span>;</span>\n  <span>}</span>\n\n  <span>return</span> sum_1 <span>+</span> sum_2<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>上述代码中，m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以在表示复杂度的时候，就不能简单地利用加法法则省略掉其中一个。因此，上面代码的时间复杂度就是 <code>O(m + n)</code>。</p>\n<p>针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：<br>\n<code>T1(m) + T2(n) = O(f(m) + g(n))</code>。</p>\n<p>但是乘法法则继续有效：<code>T1(m) * T2(n) = O(f(m) * f(n))</code>。</p>\n<h2 id=\"空间复杂度\"> 空间复杂度</h2>\n<p>时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。类比一下，<strong>空间复杂度全称就是渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系</strong>。</p>\n<p>有了时间复杂度分析的基础，空间复杂度分析就非常简单了。以下面这段伪代码作为示例：</p>\n<div><pre><code><span>void</span> <span>print</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>\n  <span>int</span> i <span>=</span> <span>0</span><span>;</span>\n  <span>int</span><span>[</span><span>]</span> a <span>=</span> new <span>int</span><span>[</span>n<span>]</span><span>;</span>\n  <span>for</span> <span>(</span>i<span>;</span> i <span>&lt;</span>n<span>;</span> <span>++</span>i<span>)</span> <span>{</span>\n    a<span>[</span>i<span>]</span> <span>=</span> i <span>*</span> i<span>;</span>\n  <span>}</span>\n\n  <span>for</span> <span>(</span>i <span>=</span> n<span>-</span><span>1</span><span>;</span> i <span>>=</span> <span>0</span><span>;</span> <span>--</span>i<span>)</span> <span>{</span>\n    print out a<span>[</span>i<span>]</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>跟时间复杂度分析一样，第 2 行代码中申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以可以忽略。</p>\n<p>第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 <code>O(n)</code>。</p>\n<p>常见的空间复杂度就是 <code>O(1)</code>、<code>O(n)</code>、<code>O(n<sup>2</sup>)</code>，对数阶复杂度平时都用不到。总的来看，空间复杂度分析比时间复杂度分析要简单很多。</p>\n<p>（完）</p>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2021-11-19T03:27:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "设计原则",
      "url": "https://www.fedbook.cn/in-depth-learning/design-patterns/5-principles/",
      "id": "https://www.fedbook.cn/in-depth-learning/design-patterns/5-principles/",
      "content_html": "<h1 id=\"设计原则\"> 设计原则</h1>\n<h2 id=\"何为设计\"> 何为设计</h2>\n<ul>\n<li>即按照哪一种思路或者标准来实现功能</li>\n<li>功能相同，可以有不同设计方案来实现</li>\n<li>伴随着需求增加，设计的作用才能体现出来</li>\n</ul>\n<h2 id=\"unix-linux-设计哲学\"> UNIX/LINUX 设计哲学</h2>\n<p>《UNIX/LINUX 设计哲学》这是一本书的名字，它里面讲了很多的设计准则。由于 UNIX/LINUX 是比较成功的操作系统，书的作者通过了解这两个操作系统，总结出了设计软件时应该遵循的 10 个设计准则。</p>\n<ul>\n<li>准则 1: 小即是美\n<ul>\n<li>一个系统尽量做得小而精，不要盲目追求大而全</li>\n</ul>\n</li>\n<li>准则 2: 让每个程序只做好一件事\n<ul>\n<li>分割多个子程序，各自负责好自己的功能，让大程序成为多个子程序的集合</li>\n</ul>\n</li>\n<li>准则 3: 快速建立原型\n<ul>\n<li>先搭建能满足用户最基本需求的原型，再根据用户或自己的需求去升级迭代</li>\n</ul>\n</li>\n<li>准则 4: 舍弃高效率而取可移植性\n<ul>\n<li>代码的高效率相对于代码的可移植性和可复用性，优先级放低</li>\n<li>代码的效率问题会随着硬件产品的升级而被抹平</li>\n</ul>\n</li>\n<li>准则 5: 采用纯文本来存储数据\n<ul>\n<li>纯文本比二进制可读性更高</li>\n<li>现在硬盘成本低，效率问题可以通过硬件的升级来解决</li>\n</ul>\n</li>\n<li>准则 6: 充分利用软件的杠杆效应（软件复用）\n<ul>\n<li>写的东西尽可能抽象出来提高复用性，同准则 4</li>\n</ul>\n</li>\n<li>准则 7: 使用 shell 脚本来提高杠杆效应和可移植性\n<ul>\n<li>同准则 4，这是一种具体的解决方案</li>\n</ul>\n</li>\n<li>准则 8: 避免强制性的用户界面\n<ul>\n<li>UNIX/LINUX 默认只有命令行，因为用户界面作为一个单独的软件而存在，不是一个操作系统的必备项</li>\n<li>对于操作系统而言，用户界面会占用很大的内存，用户界面的输入会带来安全问题，用户界面的操作没有命令行高效</li>\n<li>所以对于操作系统，应该避免强制绑定用户界面，把这个功能和系统本身分开</li>\n</ul>\n</li>\n<li>准则 9: 让每个程序都成为过滤器\n<ul>\n<li>每个子程序都是独立的，只做好一件事：就像过滤器一样让数据进来，处理完再出去，结果进入另一个子程序</li>\n<li>举例：<code>ls | grep *.json</code>，管道符作为过滤器，ls 输出的结果通过过滤器过度到 grep 选择器的结果，实现了找到所有 .json 文件的功能</li>\n</ul>\n</li>\n</ul>\n<p>小准则：</p>\n<ul>\n<li>允许用户定制环境\n<ul>\n<li>环境不能限制死，要提供配置文件方便用户进行配置</li>\n</ul>\n</li>\n<li>尽量使操作系统内核小而轻量化\n<ul>\n<li>内核与工具分离：内核只包含最核心的 API，其他的东西通过扩展或插件的形式来增加</li>\n</ul>\n</li>\n<li>使用小写字母并尽量简短\n<ul>\n<li>这是 LINUX 命名规范（list -&gt; ls）</li>\n</ul>\n</li>\n<li>沉默是金\n<ul>\n<li>正例：如果只允许输出数字，遇到结果不是数字的场景，则输出 0 或什么都不输出</li>\n<li>举例：<code>ls | grep *.json | grep 'package'</code>，如果结果中没有关键词 package，就什么都不会输出</li>\n<li>反例：遇到结果不是数字的场景，输出 &quot;这不是一个数字&quot;，那么之后的统计规则就变了，会出现问题</li>\n<li>举例：<code>ls | grep *.json | grep 'package' | wc -l</code> 统计最终输出结果有几行，如果找不到关键词时输出了其它字符串，那么统计行数就会出错了</li>\n</ul>\n</li>\n<li>各部分之和大于整体\n<ul>\n<li>以小的个体来组合成大的整体，遇到改变时就能解耦了</li>\n</ul>\n</li>\n<li>寻求 90% 的解决方案\n<ul>\n<li>一个产品不可能满足所有客户的需求，遵循二八定律即可（花 20% 的成本解决 80% 的需求）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"五大设计原则-solid\"> 五大设计原则：SOLID</h2>\n<h3 id=\"s-单一职责原则-single\"> S - 单一职责原则（single）</h3>\n<ul>\n<li>一个程序只做好一件事</li>\n<li>如果功能过于复杂就拆分开，每个部分保持独立</li>\n</ul>\n<h3 id=\"o-开放封闭原则-open\"> O - 开放封闭原则（open）</h3>\n<ul>\n<li>对扩展开放，对修改封闭</li>\n<li>增加需求时，扩展新代码，而非修改已有代码</li>\n<li>这是软件设计的终极目标</li>\n</ul>\n<h3 id=\"l-李氏置换原则\"> L - 李氏置换原则</h3>\n<ul>\n<li>子类能覆盖父类</li>\n<li>父类能出现的地方子类就能出现</li>\n<li>JS 中使用较少（弱类型 &amp; 继承使用较少）</li>\n</ul>\n<h3 id=\"i-接口独立原则\"> I - 接口独立原则</h3>\n<ul>\n<li>保持接口的单一独立，避免出现「胖接口」\n<ul>\n<li>胖接口：一个接口/函数做了所有事</li>\n<li>慎重使用，并非绝对不能使用，因为外观模式就违背了这一条原则</li>\n</ul>\n</li>\n<li>JS 中没有接口（typescript 例外），使用较少</li>\n<li>类似于单一职责原则，这里更关注接口</li>\n</ul>\n<h3 id=\"d-依赖导致原则\"> D - 依赖导致原则</h3>\n<ul>\n<li>面向接口编程，依赖于抽象而不依赖于具体</li>\n<li>使用方只关注接口而不关注具体类的实现</li>\n<li>JS 中使用较少（没有接口 &amp; 弱类型）</li>\n</ul>\n<p>在 JavaScript 编程中，受限于语言本身的特性，S O 体现较多；L I D 体现较少，但是要了解其用意。</p>\n<p>（完）</p>\n",
      "date_published": "2022-03-20T03:41:40.000Z",
      "date_modified": "2022-03-20T03:41:40.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "数据结构之数组",
      "url": "https://www.fedbook.cn/in-depth-learning/algorithm/array/",
      "id": "https://www.fedbook.cn/in-depth-learning/algorithm/array/",
      "content_html": "<h1 id=\"数据结构之数组\"> 数据结构之数组</h1>\n<h2 id=\"数组的定义\"> 数组的定义</h2>\n<p>数组（Array）是一种线性表数据结构。它用一组<strong>连续的内存空间</strong>，来存储一组具有相同类型的数据。</p>\n<h3 id=\"线性表\"> 线性表</h3>\n<p>线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。</p>\n<p>不仅是数组，链表、队列、栈等也是线性表结构。</p>\n<p>与线性表相对立的概念是非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为在非线性表中，数据之间并不是简单的前后关系。</p>\n<h3 id=\"随机访问\"> 随机访问</h3>\n<p>所谓随机访问，就是指根据下标随机访问数组元素。</p>\n<p>当我们创建一个数组后，计算机会分配给它一块连续内存空间。假定内存块的首地址为 <code>base_address = 1000</code>。当计算机需要随机访问数组中的某个元素时，它会通过下面的寻址公式，计算出该元素存储的内存地址：</p>\n<div><pre><code>a<span>[</span>i<span>]</span>_address <span>=</span> base_address <span>+</span> i <span>*</span> data_type_size\n</code></pre>\n<div><span>1</span><br></div></div><p>其中 <code>i</code> 是数组索引，<code>data_type_size</code> 表示数组中每个元素的大小（例如 int 类型数据的大小为 4 个字节）。</p>\n<h2 id=\"高效的查找操作\"> 高效的查找操作</h2>\n<p>数组和链接最大的区别在于数组的查询效率高，链表的插入和删除效率高。但这里的查询效率高仅是指<strong>根据下标随机访问元素</strong>。</p>\n<p>当我们根据下标随机访问数组元素时，查询的的时间复杂度为 <code>O(1)</code>。</p>\n<p>而当我们要具体查找数组里的某个值时，时间复杂度取决于用什么算法（例如用二分查找查询排好序的数组，时间复杂度是 <code>O(logn)</code>）。</p>\n<h2 id=\"低效的插入和删除操作\"> 低效的插入和删除操作</h2>\n<h3 id=\"插入操作\"> 插入操作</h3>\n<p>假设数组的长度为 n，如果需要将一个数据插入到数组中的第 k 个位置。为了将第 k 个位置腾出来，就需要将第 k～n 这部分的元素都顺序地往后挪一位。</p>\n<p>如果在末尾插入元素，则不需要移动数据，时间复杂度为 <code>O(1)</code>；如果在开头插入元素，时间复杂度为 <code>O(n)</code>。因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 <code>(1+2+...n)/n=O(n)</code>。</p>\n<p><strong>优化</strong>：如果数组中的数据是有序的，就必须要这么操作。但如果数组中的数据是无序的，则可以取巧来优化：直接将第 k 位的数据搬移到数组的最后，把新的元素直接放入第 k 个位置。利用这种处理技巧，在特定场景下，在第 k 个位置插入一个元素的时间复杂度就会降为 <code>O(1)</code>。这个处理思想在快排中也会用到。</p>\n<h3 id=\"删除操作\"> 删除操作</h3>\n<p>跟插入数据类似，如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。</p>\n<p><strong>优化</strong>：在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率就会提高很多。<br>\n例如要依次删除三个元素，为了避免后续数据被搬移三次，可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。这也是 JVM 标记清除垃圾回收算法的核心思想。</p>\n<h2 id=\"支持动态扩容的容器\"> 支持动态扩容的容器</h2>\n<p>数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间。当我们需要插入更多的元素时，需要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。</p>\n<p>我们平时用高级语言编写代码时，往往不需要关心底层的扩容逻辑，因为这些语言都提供了容器类（比如 Java 中的 ArrayList、Python 中的 list），它们将很多数组操作的细节封装起来（在插入、删除数据时的搬移操作），并且还支持动态扩容。</p>\n<p>需要注意的是，因为扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好在创建容器的时候事先指定数据大小。</p>\n<p>对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。</p>\n<p>（完）</p>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2021-11-19T03:27:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "抽象工厂模式",
      "url": "https://www.fedbook.cn/in-depth-learning/design-patterns/abstract-factory-pattern/",
      "id": "https://www.fedbook.cn/in-depth-learning/design-patterns/abstract-factory-pattern/",
      "content_html": "<h1 id=\"抽象工厂模式\"> 抽象工厂模式</h1>\n<h2 id=\"介绍\"> 介绍</h2>\n<p>工厂模式（Factory Pattern），根据输入的不同返回不同类的实例，一般用来创建同一类对象。工厂方式的主要思想是<strong>将对象的创建与对象的实现分离</strong>。</p>\n<p>抽象工厂模式（Abstract Factory Pattern），通过对类的工厂抽象使其业务用于对产品类簇的创建，而不是负责创建某一类产品的实例。关键在于使用抽象类制定了实例的结构，调用者直接面向实例的结构编程，<strong>从实例的具体实现中解耦</strong>。</p>\n<p>我们知道 JavaScript 并不是强面向对象语言，所以使用传统编译型语言比如 JAVA 等实现的设计模式和 JavaScript 不太一样，比如 JavaScript 中没有原生的类和接口等（不过 ES6+ 渐渐提供类似的语法糖），我们可以用变通的方式来解决。最重要的是设计模式背后的核心思想，和它所要解决的问题。</p>\n<h2 id=\"通俗的示例\"> 通俗的示例</h2>\n<p>还是以之前工厂模式中举的 KFC 的例子，之前我们说 KFC 是工厂，汉堡是产品，工厂封装做产品的工作，做好直接给购买者。</p>\n<p>现在进行扩展，汉堡属于一种具体的产品，同样还有薯条、咖啡、牛奶等也都是产品。无论你点哪个产品，他们都具有同样的属性：油炸的都可以吃，冲调的都可以喝。对于工厂也一样，KFC 可以做汉堡、薯条、咖啡、牛奶，麦当劳和华莱士也可以，那么这些工厂就具有同样的功能结构。</p>\n<p>这样的场景就是属于抽象工厂模式的例子：</p>\n<ul>\n<li>食品类属于抽象产品类，制定具体产品类所具备的属性（可以喝、可以吃）。</li>\n<li>具体的汉堡类、薯条类属于产品类，在这里面实现了该产品自身的具体属性值（原材料、口味、佐料）。</li>\n<li>工厂类和之前的工厂模式一样，负责具体生产产品实例。</li>\n</ul>\n<p>访问者通过柜台获取想拿的产品。只要我们点的是冲调产品，即使还没有被做出来，我们就知道是可以喝的。</p>\n<p>推广一下，工厂功能也可以被抽象（抽象工厂类），继承这个类的工厂实例都具有油炸食品和冲调饮品的功能，这样也完成了抽象类对实例的结构约束。</p>\n<p>在类似场景中，这些例子有这样的特点：只要实现了抽象类的实例，都实现了抽象类制定的结构。</p>\n<h2 id=\"抽象工厂模式的通用实现\"> 抽象工厂模式的通用实现</h2>\n<p>我们提炼一下抽象工厂模式，快餐店品牌是抽象工厂类（AbstractFactory），实现抽象工厂类的 KFC 是具体的工厂（Factory），它和麦当劳、华莱士等存在共同的功能结构。食品种类是抽象类（AbstractFactory），而实现抽象类的菜品是具体的产品（Product）。</p>\n<p>总的来说就是一句话：只要这几个平级的类存在共同的功能结构，就可以将共同结构作为抽象类抽象出来。</p>\n<p>通过工厂拿到实现了不同抽象类的产品，这些产品可以根据实现的抽象类被区分为类簇。主要有下面几个概念：</p>\n<ul>\n<li><strong>Factory</strong>：工厂类，负责返回产品实例。</li>\n<li><strong>AbstractFactory</strong>：抽象工厂类，制定工厂实例的结构。</li>\n<li><strong>Product</strong>：产品类，访问者从工厂中拿到的产品实例，实现抽象类。</li>\n<li><strong>AbstractProduct</strong>：产品抽象类，由具体产品实现，制定产品实例的结构。</li>\n</ul>\n<p>结构如下：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/abstract-factory-pattern.jpg\" alt=\"抽象工厂模式结构图\" style=\"width: 640px;\">\n  <p style=\"text-align: center; color: #888;\">（抽象工厂模式结构图）</p>\n</div>\n<p>代码如下：</p>\n<blockquote>\n<p>我们知道 JavaScript 并不强面向对象，也没有提供抽象类（至少目前没有提供），但是可以模拟抽象类。用对 <code>new.target</code> 来判断 <code>new</code> 的类，在父类方法中 <code>throw new Error()</code>，如果子类中没有实现这个方法就会抛错，这样来模拟抽象类。</p>\n</blockquote>\n<div><pre><code><span>/* 工厂 抽象类 */</span>\n<span>class</span> <span>AbstractFactory</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>new</span><span>.</span>target <span>===</span> AbstractFactory<span>)</span>\n      <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>'抽象类不能直接实例化!'</span><span>)</span>\n  <span>}</span>\n\n  <span>/* 抽象方法 */</span>\n  <span>createProduct1</span><span>(</span><span>)</span> <span>{</span> <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>'抽象方法不能调用!'</span><span>)</span> <span>}</span>\n<span>}</span>\n\n<span>/* 具体饭店类 */</span>\n<span>class</span> <span>Factory</span> <span>extends</span> <span>AbstractFactory</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span> <span>super</span><span>(</span><span>)</span> <span>}</span>\n\n  <span>createProduct1</span><span>(</span><span>type</span><span>)</span> <span>{</span>\n    <span>switch</span> <span>(</span>type<span>)</span> <span>{</span>\n      <span>case</span> <span>'Product1'</span><span>:</span>\n        <span>return</span> <span>new</span> <span>Product1</span><span>(</span><span>)</span>\n      <span>case</span> <span>'Product2'</span><span>:</span>\n        <span>return</span> <span>new</span> <span>Product2</span><span>(</span><span>)</span>\n      <span>default</span><span>:</span>\n        <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>'当前没有这个产品 -。-'</span><span>)</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* 抽象产品类 */</span>\n<span>class</span> <span>AbstractProduct</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>new</span><span>.</span>target <span>===</span> AbstractProduct<span>)</span>\n      <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>'抽象类不能直接实例化!'</span><span>)</span>\n    <span>this</span><span>.</span>kind <span>=</span> <span>'抽象产品类1'</span>\n  <span>}</span>\n\n  <span>/* 抽象方法 */</span>\n  <span>operate</span><span>(</span><span>)</span> <span>{</span> <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>'抽象方法不能调用!'</span><span>)</span> <span>}</span>\n<span>}</span>\n\n<span>/* 具体产品类1 */</span>\n<span>class</span> <span>Product1</span> <span>extends</span> <span>AbstractProduct</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span><span>)</span>\n    <span>this</span><span>.</span>type <span>=</span> <span>'Product1'</span>\n  <span>}</span>\n\n  <span>operate</span><span>(</span><span>)</span> <span>{</span> console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>kind <span>+</span> <span>' - '</span> <span>+</span> <span>this</span><span>.</span>type<span>)</span> <span>}</span>\n<span>}</span>\n\n<span>/* 具体产品类2 */</span>\n<span>class</span> <span>Product2</span> <span>extends</span> <span>AbstractProduct</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span><span>)</span>\n    <span>this</span><span>.</span>type <span>=</span> <span>'Product2'</span>\n  <span>}</span>\n\n  <span>operate</span><span>(</span><span>)</span> <span>{</span> console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>kind <span>+</span> <span>' - '</span> <span>+</span> <span>this</span><span>.</span>type<span>)</span> <span>}</span>\n<span>}</span>\n\n\n<span>const</span> factory <span>=</span> <span>new</span> <span>Factory</span><span>(</span><span>)</span>\n\n<span>const</span> prod1 <span>=</span> factory<span>.</span><span>createProduct1</span><span>(</span><span>'Product1'</span><span>)</span>\nprod1<span>.</span><span>operate</span><span>(</span><span>)</span>\t\t\t\t\t\t\t\t\t\t<span>// 输出: 抽象产品类1 - Product1</span>\n<span>const</span> prod2 <span>=</span> factory<span>.</span><span>createProduct1</span><span>(</span><span>'Product3'</span><span>)</span>\t<span>// 输出: Error 当前没有这个产品 -。-</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br></div></div><p>如果希望增加第二个类簇的产品，除了需要改一下对应工厂类之外，还需要增加一个抽象产品类，并在抽象产品类基础上扩展新的产品。</p>\n<p>我们在实际使用的时候不一定需要每个工厂都继承抽象工厂类，比如只有一个工厂的话我们可以直接使用工厂模式，在实战中灵活使用。</p>\n<h2 id=\"设计原则验证\"> 设计原则验证</h2>\n<ul>\n<li>不符合开放封闭原则，因为扩展新类簇时需要同时创建新的抽象类。</li>\n</ul>\n<h2 id=\"抽象工厂模式的优缺点\"> 抽象工厂模式的优缺点</h2>\n<p>优点：</p>\n<ul>\n<li>抽象产品类将产品的结构抽象出来，访问者不需要知道产品的具体实现，只需要面向产品的结构编程即可，<strong>从产品的具体实现中解耦</strong>。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li><strong>扩展新类簇的产品类比较困难</strong>，因为需要创建新的抽象产品类，并且还要修改工厂类，违反开闭原则。</li>\n<li>带来了<strong>系统复杂度</strong>，增加了新的类，和新的继承关系。</li>\n</ul>\n<h2 id=\"抽象工厂模式的适用场景\"> 抽象工厂模式的适用场景</h2>\n<p>如果一组实例都有相同的结构，那么就可以使用抽象工厂模式。</p>\n<h2 id=\"其他相关模式\"> 其他相关模式</h2>\n<h3 id=\"抽象工厂模式与工厂模式\"> 抽象工厂模式与工厂模式</h3>\n<p>工厂模式和抽象工厂模式的区别：</p>\n<ul>\n<li><strong>工厂模式</strong> 主要关注单独的产品实例的创建。</li>\n<li><strong>抽象工厂模式</strong> 主要关注产品类簇实例的创建，如果产品类簇只有一个产品，那么这时的抽象工厂模式就退化为工厂模式了。</li>\n</ul>\n<p>根据场景灵活使用即可。</p>\n<p>（完）</p>\n",
      "date_published": "2022-03-30T08:33:32.000Z",
      "date_modified": "2022-03-30T14:38:57.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "设计模式",
      "url": "https://www.fedbook.cn/in-depth-learning/design-patterns/",
      "id": "https://www.fedbook.cn/in-depth-learning/design-patterns/",
      "content_html": "<h1 id=\"设计模式\"> 设计模式</h1>\n<p><strong>为什么要学习设计模式（Why）</strong>：</p>\n<ul>\n<li>我本科读的非科班，靠自学入的行，因此这块知识需要补齐。</li>\n<li>对于项目技术负责人来说，设计能力是必要基础。</li>\n<li>从写好代码，到做好设计，设计模式是必经之路。</li>\n<li>现在很多框架的源码中大量运用了各种设计模式，想要读懂框架源码，这是前置条件。</li>\n<li>中高级开发工程师的面试也会考察设计能力。</li>\n</ul>\n<hr>\n<p><strong>怎么学设计模式（How）</strong>：</p>\n<p>设计模式拆开来讲就是「设计原则」和「模式」，一共有 5 大设计原则，23 种设计模式。</p>\n<p>值得一提的是，JavaScript 受限于它本身的语言特性，在设计模式上远不如 Java 等后端语言那样发挥空间大，如果将一些传统面向对象语言的设计模式生搬硬套过来反而会有些奇怪。</p>\n<p>因此作为一名前端开发工程师，我主要着眼于 JS 在某种场景下对于设计模式理念的体现和应用。并且在前端领域，其实只需要重点关注部分设计模式即可，这样有针对性地学习，效果会更好，也不容易被劝退。</p>\n<hr>\n<p><strong>怎么用设计模式（How）</strong>：</p>\n<p>设计模式就相当于武功秘籍里面的招式，是先辈们总结出来的最佳实践，如果在合适的场景施展，则事半功倍，以后扩展和阅读都十分舒畅。如果生搬硬套、为了用而用，则会提升代码复杂度，反而让团队其他成员一脸懵，平白增加协作成本。</p>\n<div style=\"text-align: right\">\n  <svg t=\"1607526012170\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"10484\" width=\"64\" height=\"64\"><path d=\"M737.6 356.608a8.96 8.96 0 0 1 12.096-1.472l235.712 175.36a18.688 18.688 0 0 1 2.88 2.688v0.064a15.808 15.808 0 0 1-2.88 23.04l-235.712 175.36c0 2.56-1.28 4.928-3.328 6.464a8.96 8.96 0 0 1-12.096-1.472 7.936 7.936 0 0 1 1.536-11.456v-83.2c0-2.56 1.28-4.928 3.328-6.464l123.776-92.16-123.776-92.096a7.808 7.808 0 0 1-3.328-6.4V361.6c0-1.792 0.64-3.584 1.792-4.992z m-458.112-3.2c4.736-0.064 8.64 3.584 8.64 8.128v83.2c0 2.56-1.28 4.864-3.328 6.4L161.024 543.36l123.776 92.16c2.112 1.472 3.328 3.84 3.328 6.272v83.328c0 1.792-0.64 3.584-1.792 4.992a8.96 8.96 0 0 1-12.096 1.472L38.528 556.16a15.872 15.872 0 0 1 0-25.792l235.712-175.296a8.704 8.704 0 0 1 5.248-1.728z\" fill=\"#101A33\" p-id=\"10485\"></path><path d=\"M672.576 192H599.936a8.704 8.704 0 0 0-8.192 5.44v0.064L342.72 885.184a8.128 8.128 0 0 0 5.312 10.368c0.96 0.32 1.92 0.448 2.88 0.448h72.96a8.704 8.704 0 0 0 8.192-5.44v-0.064l0.768-2.176 248.064-685.44a8.192 8.192 0 0 0-5.504-10.432A9.28 9.28 0 0 0 672.64 192z\" fill=\"#107CEE\" p-id=\"10486\"></path></svg>\n</div>\n",
      "date_published": "2022-03-18T14:11:10.000Z",
      "date_modified": "2022-03-30T06:40:43.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "适配器模式",
      "url": "https://www.fedbook.cn/in-depth-learning/design-patterns/adapter-pattern/",
      "id": "https://www.fedbook.cn/in-depth-learning/design-patterns/adapter-pattern/",
      "content_html": "<h1 id=\"适配器模式\"> 适配器模式</h1>\n<h2 id=\"介绍\"> 介绍</h2>\n<p>适配器模式（Adapter Pattern）又称包装器模式，将一个类（对象）的接口（方法、属性）转化为用户需要的另一个接口，解决类（对象）之间接口不兼容的问题。</p>\n<p>主要功能是进行转换匹配，目的是复用已有的功能，而不是来实现新的接口。也就是说，如果访问者需要的功能应该是已经实现好了的，就不需要适配器模式来实现。适配器模式主要是负责把不兼容的接口转换成访问者期望的格式而已。</p>\n<h2 id=\"通俗的示例\"> 通俗的示例</h2>\n<ul>\n<li>电源接口的转接头、Type-C 转 HDMI 等视频转接头。</li>\n<li>同声传译，充当两国友人互相交流的中间人</li>\n</ul>\n<p>在类似场景中，这些例子有以下特点：</p>\n<ul>\n<li>旧有接口格式已经不满足现在的需要。</li>\n<li>通过增加适配器来更好地使用旧有接口。</li>\n</ul>\n<h2 id=\"适配器模式的通用实现\"> 适配器模式的通用实现</h2>\n<p>传统的工厂模式比较复杂，因为像 Java 等语言中有「接口」的概念。但 JS 中没有接口，即使可以用再加一层父类的形式来代替接口，但「用不同的子类继承父类，从而实现不同子类」的场景比较少，所以我们可以提炼一下工厂模式：</p>\n<p>如果我们希望获得产品，通过工厂类就可以拿到产品实例，不用关注产品实例创建流程。主要有下面几个概念：</p>\n<ul>\n<li><strong>Target</strong>：使用者所期待的类。</li>\n<li><strong>Adapter</strong>：需要适配的类（旧的类）。</li>\n</ul>\n<p>结构如下：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/adapter-pattern.jpg\" alt=\"适配器模式结构图\" style=\"width: 640px;\">\n  <p style=\"text-align: center; color: #888;\">（适配器模式结构图）</p>\n</div>\n<p>代码如下：</p>\n<blockquote>\n<p>以下代码模拟实现了电源适配器的例子，通过电源转换器，将德国标准的插头转换成中国标准的插头。</p>\n<p><code>request</code> 是我们预期需要的接口，<code>specificRequest</code> 是需要适配的类里的接口。</p>\n</blockquote>\n<div><pre><code><span>class</span> <span>Adapter</span> <span>{</span>\n  <span>specificRequest</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>'德国标准的插头'</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>Target</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>adapter <span>=</span> <span>new</span> <span>Adapter</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n  <span>request</span><span>(</span><span>)</span> <span>{</span>\n    <span>let</span> info <span>=</span> <span>this</span><span>.</span>adapter<span>.</span><span>specificRequest</span><span>(</span><span>)</span><span>;</span>\n    <span>return</span> <span><span>`</span><span><span>${</span>info<span>}</span></span><span> -> 转换器 -> 中国标准的插头</span><span>`</span></span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 测试</span>\n<span>let</span> target <span>=</span> <span>new</span> <span>Target</span><span>(</span><span>)</span><span>;</span>\n<span>let</span> res <span>=</span> target<span>.</span><span>request</span><span>(</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>res<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>访问者需要目标对象的某个功能，但是这个对象的接口不是自己期望的，那么通过适配器模式对现有对象的接口进行包装，来获得自己需要的接口格式。</p>\n<h2 id=\"适配器模式的实际应用\"> 适配器模式的实际应用</h2>\n<p>适配器模式在日常开发中还是比较常见的，可能你已经使用了，但因为没有学过设计模式，所以不知道这种实现方式有个叫「适配器模式」的名字。</p>\n<h3 id=\"jquery-ajax-适配-axios\"> jQuery.ajax 适配 Axios</h3>\n<p>有的使用 jQuery 的老项目使用 <code>$.ajax</code> 来发送请求，现在的新项目一般使用 Axios，那么现在有个老项目的代码中全是 <code>$.ajax</code>，如果逐个修改，无疑工作量巨大而且很容易引发各种乱七八糟 bug，这时可以采用适配器模式来将老的使用形式适配到新的技术栈上：</p>\n<div><pre><code><span>/* 适配器 */</span>\n<span>function</span> <span>ajax2AxiosAdapter</span><span>(</span><span>ajaxOptions</span><span>)</span> <span>{</span>\n  <span>return</span> <span>axios</span><span>(</span><span>{</span>\n    url<span>:</span> ajaxOptions<span>.</span>url<span>,</span>\n    method<span>:</span> ajaxOptions<span>.</span>type<span>,</span>\n    responseType<span>:</span> ajaxOptions<span>.</span>dataType<span>,</span>\n    data<span>:</span> ajaxOptions<span>.</span>data\n  <span>}</span><span>)</span>\n    <span>.</span><span>then</span><span>(</span>ajaxOptions<span>.</span>success<span>)</span>\n    <span>.</span><span>catch</span><span>(</span>ajaxOptions<span>.</span>error<span>)</span>\n<span>}</span>\n\n<span>/* 经过适配器包装 */</span>\n$<span>.</span><span>ajax</span> <span>=</span> <span>function</span><span>(</span><span>options</span><span>)</span> <span>{</span>\n  <span>return</span> <span>ajax2AxiosAdapter</span><span>(</span>options<span>)</span><span>;</span>\n<span>}</span>\n\n<span>// 测试：用 jQuery 的方式发送一个 ajax 请求</span>\n$<span>.</span><span>ajax</span><span>(</span><span>{</span>\n  url<span>:</span> <span>'/demo-url'</span><span>,</span>\n  type<span>:</span> <span>'POST'</span><span>,</span>\n  dataType<span>:</span> <span>'json'</span><span>,</span>\n  data<span>:</span> <span>{</span>\n    name<span>:</span> <span>'张三'</span><span>,</span>\n    id<span>:</span> <span>'13'</span>\n  <span>}</span><span>,</span>\n  <span>success</span><span>:</span> <span>function</span><span>(</span><span>data</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'请求成功！'</span><span>)</span>\n  <span>}</span><span>,</span>\n  <span>error</span><span>:</span> <span>function</span><span>(</span><span>err</span><span>)</span> <span>{</span>\n    console<span>.</span><span>error</span><span>(</span><span>'请求失败！'</span><span>)</span>\n  <span>}</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>可以看到老的代码表现形式依然不变，但是真正发送请求是通过新的发送方式来进行的。当然你也可以把 Axios 的请求适配到 <code>$.ajax</code> 上，就看你如何使用适配器了。</p>\n<h3 id=\"业务数据适配\"> 业务数据适配</h3>\n<p>在实际项目中，我们经常会遇到树形数据结构和表形数据结构的转换，比如全国省市区结构、公司组织结构、军队编制结构等等。以公司组织结构为例，在历史代码中，后端给了公司组织结构的树形数据，在以后的业务迭代中，会增加一些要求非树形结构的场景。比如增加了将组织维护起来的功能，因此就需要在新增组织的时候选择上级组织，在某个下拉菜单中选择这个新增组织的上级菜单。或者增加了将人员归属到某一级组织的需求，需要在某个下拉菜单中选择任一级组织。</p>\n<p>在这些业务场景中，都需要将树形结构平铺开，但是我们又不能直接将旧有的树形结构状态进行修改，因为在项目别的地方已经使用了老的树形结构状态，这时我们可以引入适配器来将老的数据结构进行适配：</p>\n<div><pre><code><span>/* 原来的树形结构 */</span>\n<span>const</span> oldTreeData <span>=</span> <span>[</span>\n  <span>{</span>\n    name<span>:</span> <span>'总部'</span><span>,</span>\n    place<span>:</span> <span>'一楼'</span><span>,</span>\n    children<span>:</span> <span>[</span>\n      <span>{</span> name<span>:</span> <span>'财务部'</span><span>,</span> place<span>:</span> <span>'二楼'</span> <span>}</span><span>,</span>\n      <span>{</span> name<span>:</span> <span>'生产部'</span><span>,</span> place<span>:</span> <span>'三楼'</span> <span>}</span><span>,</span>\n      <span>{</span>\n        name<span>:</span> <span>'开发部'</span><span>,</span> place<span>:</span> <span>'三楼'</span><span>,</span> children<span>:</span> <span>[</span>\n          <span>{</span>\n            name<span>:</span> <span>'软件部'</span><span>,</span> place<span>:</span> <span>'四楼'</span><span>,</span> children<span>:</span> <span>[</span>\n              <span>{</span> name<span>:</span> <span>'后端部'</span><span>,</span> place<span>:</span> <span>'五楼'</span> <span>}</span><span>,</span>\n              <span>{</span> name<span>:</span> <span>'前端部'</span><span>,</span> place<span>:</span> <span>'七楼'</span> <span>}</span><span>,</span>\n              <span>{</span> name<span>:</span> <span>'技术支持部'</span><span>,</span> place<span>:</span> <span>'六楼'</span> <span>}</span><span>]</span>\n          <span>}</span><span>,</span> <span>{</span>\n            name<span>:</span> <span>'硬件部'</span><span>,</span> place<span>:</span> <span>'四楼'</span><span>,</span> children<span>:</span> <span>[</span>\n              <span>{</span> name<span>:</span> <span>'DSP部'</span><span>,</span> place<span>:</span> <span>'八楼'</span> <span>}</span><span>,</span>\n              <span>{</span> name<span>:</span> <span>'ARM部'</span><span>,</span> place<span>:</span> <span>'二楼'</span> <span>}</span><span>,</span>\n              <span>{</span> name<span>:</span> <span>'调试部'</span><span>,</span> place<span>:</span> <span>'三楼'</span> <span>}</span><span>]</span>\n          <span>}</span><span>]</span>\n      <span>}</span>\n    <span>]</span>\n  <span>}</span>\n<span>]</span>\n\n<span>/* 树形结构平铺 */</span>\n<span>function</span> <span>treeDataAdapter</span><span>(</span><span>treeData<span>,</span> lastArrayData <span>=</span> <span>[</span><span>]</span></span><span>)</span> <span>{</span>\n  treeData<span>.</span><span>forEach</span><span>(</span><span>item</span> <span>=></span> <span>{</span>\n    <span>if</span> <span>(</span>item<span>.</span>children<span>)</span> <span>{</span>\n      <span>treeDataAdapter</span><span>(</span>item<span>.</span>children<span>,</span> lastArrayData<span>)</span>\n    <span>}</span>\n    <span>const</span> <span>{</span> name<span>,</span> place <span>}</span> <span>=</span> item\n    lastArrayData<span>.</span><span>push</span><span>(</span><span>{</span> name<span>,</span> place <span>}</span><span>)</span>\n  <span>}</span><span>)</span>\n  <span>return</span> lastArrayData\n<span>}</span>\n\n<span>// 测试：返回平铺的组织结构</span>\n<span>treeDataAdapter</span><span>(</span>oldTreeData<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><p>增加适配器后，就可以将原先状态的树形结构转化为所需的结构，而并不改动原先的数据，也不对原来使用旧数据结构的代码有所影响。</p>\n<h3 id=\"vue-计算属性\"> Vue 计算属性</h3>\n<p>Vue 中的计算属性也是一个适配器模式的实例，以官网的例子为例，我们可以一起来理解一下：</p>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>\"</span>example<span>\"</span></span><span>></span></span>\n    <span><span><span>&lt;</span>p</span><span>></span></span>Original message: \"{{ message }}\"<span><span><span>&lt;/</span>p</span><span>></span></span>  <span>&lt;!-- Hello --></span>\n    <span><span><span>&lt;</span>p</span><span>></span></span>Computed reversed message: \"{{ reversedMessage }}\"<span><span><span>&lt;/</span>p</span><span>></span></span>  <span>&lt;!-- olleH --></span>\n  <span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span> <span>type</span><span><span>=</span><span>'</span>text/javascript<span>'</span></span><span>></span></span><span><span>\n  <span>export</span> <span>default</span> <span>{</span>\n    name<span>:</span> <span>'demo'</span><span>,</span>\n    <span>data</span><span>(</span><span>)</span> <span>{</span>\n      <span>return</span> <span>{</span>\n        message<span>:</span> <span>'Hello'</span>\n      <span>}</span>\n    <span>}</span><span>,</span>\n    computed<span>:</span> <span>{</span>\n      <span>reversedMessage</span><span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>this</span><span>.</span>message<span>.</span><span>split</span><span>(</span><span>''</span><span>)</span><span>.</span><span>reverse</span><span>(</span><span>)</span><span>.</span><span>join</span><span>(</span><span>''</span><span>)</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>旧有 data 中的数据不满足当前的要求，通过计算属性的规则来适配成我们需要的格式，对原有数据并没有改变，只改变了原有数据的表现形式。</p>\n<h3 id=\"axios-源码中的适配器模式\"> Axios 源码中的适配器模式</h3>\n<p>Axios 是比较热门的网络请求库，在浏览器中使用的时候，Axios 的用来发送请求的 <code>adapter</code> 本质上是封装浏览器提供的 API <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest\" target=\"_blank\" rel=\"noopener noreferrer\">XMLHttpRequest</a>，我们可以看看源码中是如何封装这个 API 的，为了方便观看，进行了一些省略：</p>\n<div><pre><code>module<span>.</span><span>exports</span> <span>=</span> <span>function</span> <span>xhrAdapter</span><span>(</span><span>config</span><span>)</span> <span>{</span>\n  <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>function</span> <span>dispatchXhrRequest</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>{</span>\n    <span>var</span> requestData <span>=</span> config<span>.</span>data\n    <span>var</span> requestHeaders <span>=</span> config<span>.</span>headers\n\n    <span>var</span> request <span>=</span> <span>new</span> <span>XMLHttpRequest</span><span>(</span><span>)</span>\n\n    <span>// 初始化一个请求</span>\n    request<span>.</span><span>open</span><span>(</span>config<span>.</span>method<span>.</span><span>toUpperCase</span><span>(</span><span>)</span><span>,</span>\n      <span>buildURL</span><span>(</span>config<span>.</span>url<span>,</span> config<span>.</span>params<span>,</span> config<span>.</span>paramsSerializer<span>)</span><span>,</span> <span>true</span><span>)</span>\n\n    <span>// 设置最大超时时间</span>\n    request<span>.</span>timeout <span>=</span> config<span>.</span>timeout\n\n    <span>// readyState 属性发生变化时的回调</span>\n    request<span>.</span><span>onreadystatechange</span> <span>=</span> <span>function</span> <span>handleLoad</span><span>(</span><span>)</span> <span>{</span> <span>...</span> <span>}</span>\n\n    <span>// 浏览器请求退出时的回调</span>\n    request<span>.</span><span>onabort</span> <span>=</span> <span>function</span> <span>handleAbort</span><span>(</span><span>)</span> <span>{</span> <span>...</span> <span>}</span>\n\n    <span>// 当请求报错时的回调</span>\n    request<span>.</span><span>onerror</span> <span>=</span> <span>function</span> <span>handleError</span><span>(</span><span>)</span> <span>{</span> <span>...</span> <span>}</span>\n\n    <span>// 当请求超时调用的回调</span>\n    request<span>.</span><span>ontimeout</span> <span>=</span> <span>function</span> <span>handleTimeout</span><span>(</span><span>)</span> <span>{</span> <span>...</span> <span>}</span>\n\n    <span>// 设置HTTP请求头的值</span>\n    <span>if</span> <span>(</span><span>'setRequestHeader'</span> <span>in</span> request<span>)</span> <span>{</span>\n      request<span>.</span><span>setRequestHeader</span><span>(</span>key<span>,</span> val<span>)</span>\n    <span>}</span>\n\n    <span>// 跨域的请求是否应该使用证书</span>\n    <span>if</span> <span>(</span>config<span>.</span>withCredentials<span>)</span> <span>{</span>\n      request<span>.</span>withCredentials <span>=</span> <span>true</span>\n    <span>}</span>\n\n    <span>// 响应类型</span>\n    <span>if</span> <span>(</span>config<span>.</span>responseType<span>)</span> <span>{</span>\n      request<span>.</span>responseType <span>=</span> config<span>.</span>responseType\n    <span>}</span>\n\n    <span>// 发送请求</span>\n    request<span>.</span><span>send</span><span>(</span>requestData<span>)</span>\n  <span>}</span><span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><p>可以看到这个模块主要是对请求头、请求配置和一些回调的设置，并没有对原生的 API 有改动，所以也可以在其他地方正常使用。这个适配器可以看作是对 <code>XMLHttpRequest</code> 的适配，是用户对 Axios 调用层到原生 <code>XMLHttpRequest</code> 这个 API 之间的适配层。</p>\n<p>源码可以参见 Github 仓库：<a href=\"https://github.com/axios/axios/blob/v0.19.0/lib/adapters/xhr.js\" target=\"_blank\" rel=\"noopener noreferrer\">axios/lib/adapters/xhr.js</a></p>\n<h2 id=\"设计原则验证\"> 设计原则验证</h2>\n<ul>\n<li>将旧接口和使用者进行分离</li>\n<li>符合开放封闭原则</li>\n</ul>\n<h2 id=\"适配器模式的优缺点\"> 适配器模式的优缺点</h2>\n<p>优点：</p>\n<ul>\n<li>已有的功能如果只是接口不兼容，使用适配器适配已有功能，可以使原有逻辑得到<strong>更好的复用</strong>，有助于避免大规模改写现有代码。</li>\n<li><strong>可扩展性良好</strong>，在实现适配器功能的时候，可以调用自己开发的功能，从而方便地扩展系统的功能。</li>\n<li><strong>灵活性好</strong>，因为适配器并没有对原有对象的功能有所影响，如果不想使用适配器了，那么直接删掉即可，不会对使用原有对象的代码有影响。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>会让系统变得零乱，明明调用 A，却被适配到了 B，如果系统中这样的情况很多，那么<strong>对可阅读性不太友好</strong>。如果没必要使用适配器模式的话，可以考虑重构，如果使用的话，可以考虑尽量把文档完善。</li>\n</ul>\n<h2 id=\"适配器模式的适用场景\"> 适配器模式的适用场景</h2>\n<p>当你想用已有对象的功能，却想修改它的接口时，一般可以考虑一下是不是可以应用适配器模式。</p>\n<ul>\n<li>如果你想要使用一个已经存在的对象，但是它的接口不满足需求，那么可以使用适配器模式，把已有的实现转换成你需要的接口。</li>\n<li>如果你想创建一个可以复用的对象，而且确定需要和一些不兼容的对象一起工作，这种情况可以使用适配器模式，然后需要什么就适配什么。</li>\n</ul>\n<h2 id=\"其他相关模式\"> 其他相关模式</h2>\n<h3 id=\"适配器模式与代理模式\"> 适配器模式与代理模式</h3>\n<ul>\n<li><strong>适配器模式</strong>：提供一个不一样的接口，由于原来的接口格式<strong>不能用了</strong>，提供新的接口以满足新场景下的需求。</li>\n<li><strong>代理模式</strong>：提供一模一样的接口，由于不能直接访问目标对象，找个代理来帮忙访问，使用者可以就像访问目标对象一样来访问代理对象。</li>\n</ul>\n<h3 id=\"适配器模式、装饰者模式与代理模式\"> 适配器模式、装饰者模式与代理模式</h3>\n<ul>\n<li><strong>适配器模式</strong>：功能不变，只转换了原有接口访问格式。</li>\n<li><strong>装饰者模式</strong>：扩展功能，原有功能不变且可直接使用。</li>\n<li><strong>代理模式</strong>：原有功能不变，但一般是经过限制访问的。</li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-03-22T15:19:20.000Z",
      "date_modified": "2022-03-25T13:39:23.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "数据结构之链表",
      "url": "https://www.fedbook.cn/in-depth-learning/algorithm/linked-list/",
      "id": "https://www.fedbook.cn/in-depth-learning/algorithm/linked-list/",
      "content_html": "<h1 id=\"数据结构之链表\"> 数据结构之链表</h1>\n<h2 id=\"链表的定义\"> 链表的定义</h2>\n<p>我们知道，数组需要一块<strong>连续的内存空间</strong>来存储，对内存的要求比较高。如果我们申请一个 100MB 大小的数组，当内存中没有连续的、足够大的存储空间时，即便内存的剩余总可用空间大于 100MB，仍然会申请失败。</p>\n<p>而链表（Linked List）恰恰相反，它并不需要一块连续的内存空间，它通过「指针」将一组<strong>零散的内存块</strong>串联起来使用，所以如果我们申请的是 100MB 大小的链表，就不会有问题。</p>\n<h2 id=\"链表的类型\"> 链表的类型</h2>\n<p>链表结构五花八门，最常见的三种链表结构是：单链表、双向链表和循环链表。</p>\n<h3 id=\"单链表\"> 单链表</h3>\n<p>链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表的「<strong>结点</strong>」。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。</p>\n<p>如图所示，我们把这个记录下个结点地址的指针叫作<strong>后继指针 next</strong>。</p>\n<div style=\"text-align: center;\">\n  <svg id=\"SvgjsSvg1006\" width=\"761\" height=\"91\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><defs id=\"SvgjsDefs1007\"><marker id=\"SvgjsMarker1064\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1065\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1068\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1069\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1072\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1073\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1076\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1077\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1080\" markerWidth=\"16\" markerHeight=\"12\" refX=\"0\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1081\" d=\"M15,1.5 L2,6 L15,10.5\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker></defs><g id=\"SvgjsG1008\" transform=\"translate(73,25)\"><path id=\"SvgjsPath1009\" d=\"M 0 0L 56 0L 56 41L 0 41Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ff8000\"></path><g id=\"SvgjsG1010\"><text id=\"SvgjsText1011\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"36px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.1\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1012\" dy=\"20\" x=\"28\"><tspan id=\"SvgjsTspan1013\" style=\"text-decoration:;\">data</tspan></tspan></text></g></g><g id=\"SvgjsG1014\" transform=\"translate(129,25)\"><path id=\"SvgjsPath1015\" d=\"M 0 0L 54 0L 54 41L 0 41Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffff00\"></path><g id=\"SvgjsG1016\"><text id=\"SvgjsText1017\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"34px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.1\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1018\" dy=\"20\" x=\"27\"><tspan id=\"SvgjsTspan1019\" style=\"text-decoration:;\">next</tspan></tspan></text></g></g><g id=\"SvgjsG1020\" transform=\"translate(227,25)\"><path id=\"SvgjsPath1021\" d=\"M 0 0L 56 0L 56 41L 0 41Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ff8000\"></path><g id=\"SvgjsG1022\"><text id=\"SvgjsText1023\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"36px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.1\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1024\" dy=\"20\" x=\"28\"><tspan id=\"SvgjsTspan1025\" style=\"text-decoration:;\">data</tspan></tspan></text></g></g><g id=\"SvgjsG1026\" transform=\"translate(283,25)\"><path id=\"SvgjsPath1027\" d=\"M 0 0L 54 0L 54 41L 0 41Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffff00\"></path><g id=\"SvgjsG1028\"><text id=\"SvgjsText1029\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"34px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.1\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1030\" dy=\"20\" x=\"27\"><tspan id=\"SvgjsTspan1031\" style=\"text-decoration:;\">next</tspan></tspan></text></g></g><g id=\"SvgjsG1032\" transform=\"translate(379,25)\"><path id=\"SvgjsPath1033\" d=\"M 0 0L 56 0L 56 41L 0 41Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ff8000\"></path><g id=\"SvgjsG1034\"><text id=\"SvgjsText1035\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"36px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.1\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1036\" dy=\"20\" x=\"28\"><tspan id=\"SvgjsTspan1037\" style=\"text-decoration:;\">data</tspan></tspan></text></g></g><g id=\"SvgjsG1038\" transform=\"translate(435,25)\"><path id=\"SvgjsPath1039\" d=\"M 0 0L 54 0L 54 41L 0 41Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffff00\"></path><g id=\"SvgjsG1040\"><text id=\"SvgjsText1041\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"34px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.1\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1042\" dy=\"20\" x=\"27\"><tspan id=\"SvgjsTspan1043\" style=\"text-decoration:;\">next</tspan></tspan></text></g></g><g id=\"SvgjsG1044\" transform=\"translate(530,25)\"><path id=\"SvgjsPath1045\" d=\"M 0 0L 56 0L 56 41L 0 41Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ff8000\"></path><g id=\"SvgjsG1046\"><text id=\"SvgjsText1047\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"36px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.1\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1048\" dy=\"20\" x=\"28\"><tspan id=\"SvgjsTspan1049\" style=\"text-decoration:;\">data</tspan></tspan></text></g></g><g id=\"SvgjsG1050\" transform=\"translate(586,25)\"><path id=\"SvgjsPath1051\" d=\"M 0 0L 54 0L 54 41L 0 41Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffff00\"></path><g id=\"SvgjsG1052\"><text id=\"SvgjsText1053\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"34px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.1\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1054\" dy=\"20\" x=\"27\"><tspan id=\"SvgjsTspan1055\" style=\"text-decoration:;\">next</tspan></tspan></text></g></g><g id=\"SvgjsG1056\" transform=\"translate(685,25.5)\"><path id=\"SvgjsPath1057\" d=\"M 0 0L 51 0L 51 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1058\"><text id=\"SvgjsText1059\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"51px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"7.6\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1060\" dy=\"20\" x=\"25.5\"><tspan id=\"SvgjsTspan1061\" style=\"text-decoration:;\">NULL</tspan></tspan></text></g></g><g id=\"SvgjsG1062\"><path id=\"SvgjsPath1063\" d=\"M183 45.5L205 45.5L205 45.5L227 45.5\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1064)\"></path></g><g id=\"SvgjsG1066\"><path id=\"SvgjsPath1067\" d=\"M337 45.5L358 45.5L358 45.5L379 45.5\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1068)\"></path></g><g id=\"SvgjsG1070\"><path id=\"SvgjsPath1071\" d=\"M489 45.5L509.5 45.5L509.5 45.5L530 45.5\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1072)\"></path></g><g id=\"SvgjsG1074\"><path id=\"SvgjsPath1075\" d=\"M640 45.5L662.5 45.5L662.5 45.5L685 45.5\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1076)\"></path></g><g id=\"SvgjsG1078\"><path id=\"SvgjsPath1079\" d=\"M73 45.5L49 45.5L49 45.5L25 45.5\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-start=\"url(#SvgjsMarker1080)\"></path></g></svg>\n  <p style=\"text-align:center; color: #888;\">（单链表）</p>\n</div>\n<p>在单链表中，有两个结点是比较特殊的，它们分别是第一个结点（也叫作<strong>头结点</strong>）和最后一个结点（也叫作<strong>尾结点</strong>）。</p>\n<p>其中，头结点用来记录链表的基地址。有了它，我们可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个<strong>空地址 NUL</strong>L，表示这是链表上最后一个结点。</p>\n<p>我们知道，在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是 <code>O(n)</code>。而在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的，只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 <code>O(1)</code>。</p>\n<p>但是，链表随机访问的性能没有数组好，原因在于链表中的数据并非连续存储的，无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要从头节点开始，根据指针一个结点一个结点地依次遍历，直到找到相应的结点。这个过程需要 <code>O(n)</code> 的时间复杂度。</p>\n<h3 id=\"循环链表\"> 循环链表</h3>\n<p><strong>循环链表是一种特殊的单链表</strong>。它跟单链表唯一的区别就在尾结点：单链表的尾结点指针指向空地址，表示这就是最后的结点了；而循环链表的尾结点指针指向链表的头结点，如下如所示：</p>\n<div style=\"text-align: center;\">\n  <svg id=\"SvgjsSvg1006\" width=\"680\" height=\"141\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><defs id=\"SvgjsDefs1007\"><marker id=\"SvgjsMarker1058\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1059\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1062\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1063\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1066\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1067\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1070\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1071\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker></defs><g id=\"SvgjsG1008\" transform=\"translate(58,75)\"><path id=\"SvgjsPath1009\" d=\"M 0 0L 56 0L 56 41L 0 41Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ff8000\"></path><g id=\"SvgjsG1010\"><text id=\"SvgjsText1011\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"36px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.1\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1012\" dy=\"20\" x=\"28\"><tspan id=\"SvgjsTspan1013\" style=\"text-decoration:;\">data</tspan></tspan></text></g></g><g id=\"SvgjsG1014\" transform=\"translate(114,75)\"><path id=\"SvgjsPath1015\" d=\"M 0 0L 54 0L 54 41L 0 41Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffff00\"></path><g id=\"SvgjsG1016\"><text id=\"SvgjsText1017\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"34px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.1\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1018\" dy=\"20\" x=\"27\"><tspan id=\"SvgjsTspan1019\" style=\"text-decoration:;\">next</tspan></tspan></text></g></g><g id=\"SvgjsG1020\" transform=\"translate(212,75)\"><path id=\"SvgjsPath1021\" d=\"M 0 0L 56 0L 56 41L 0 41Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ff8000\"></path><g id=\"SvgjsG1022\"><text id=\"SvgjsText1023\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"36px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.1\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1024\" dy=\"20\" x=\"28\"><tspan id=\"SvgjsTspan1025\" style=\"text-decoration:;\">data</tspan></tspan></text></g></g><g id=\"SvgjsG1026\" transform=\"translate(268,75)\"><path id=\"SvgjsPath1027\" d=\"M 0 0L 54 0L 54 41L 0 41Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffff00\"></path><g id=\"SvgjsG1028\"><text id=\"SvgjsText1029\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"34px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.1\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1030\" dy=\"20\" x=\"27\"><tspan id=\"SvgjsTspan1031\" style=\"text-decoration:;\">next</tspan></tspan></text></g></g><g id=\"SvgjsG1032\" transform=\"translate(364,75)\"><path id=\"SvgjsPath1033\" d=\"M 0 0L 56 0L 56 41L 0 41Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ff8000\"></path><g id=\"SvgjsG1034\"><text id=\"SvgjsText1035\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"36px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.1\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1036\" dy=\"20\" x=\"28\"><tspan id=\"SvgjsTspan1037\" style=\"text-decoration:;\">data</tspan></tspan></text></g></g><g id=\"SvgjsG1038\" transform=\"translate(420,75)\"><path id=\"SvgjsPath1039\" d=\"M 0 0L 54 0L 54 41L 0 41Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffff00\"></path><g id=\"SvgjsG1040\"><text id=\"SvgjsText1041\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"34px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.1\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1042\" dy=\"20\" x=\"27\"><tspan id=\"SvgjsTspan1043\" style=\"text-decoration:;\">next</tspan></tspan></text></g></g><g id=\"SvgjsG1044\" transform=\"translate(515,75)\"><path id=\"SvgjsPath1045\" d=\"M 0 0L 56 0L 56 41L 0 41Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ff8000\"></path><g id=\"SvgjsG1046\"><text id=\"SvgjsText1047\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"36px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.1\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1048\" dy=\"20\" x=\"28\"><tspan id=\"SvgjsTspan1049\" style=\"text-decoration:;\">data</tspan></tspan></text></g></g><g id=\"SvgjsG1050\" transform=\"translate(571,75)\"><path id=\"SvgjsPath1051\" d=\"M 0 0L 54 0L 54 41L 0 41Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffff00\"></path><g id=\"SvgjsG1052\"><text id=\"SvgjsText1053\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"34px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.1\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1054\" dy=\"20\" x=\"27\"><tspan id=\"SvgjsTspan1055\" style=\"text-decoration:;\">next</tspan></tspan></text></g></g><g id=\"SvgjsG1056\"><path id=\"SvgjsPath1057\" d=\"M168 95.5L190 95.5L190 95.5L212 95.5\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1058)\"></path></g><g id=\"SvgjsG1060\"><path id=\"SvgjsPath1061\" d=\"M322 95.5L343 95.5L343 95.5L364 95.5\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1062)\"></path></g><g id=\"SvgjsG1064\"><path id=\"SvgjsPath1065\" d=\"M474 95.5L494.5 95.5L494.5 95.5L515 95.5\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1066)\"></path></g><g id=\"SvgjsG1068\"><path id=\"SvgjsPath1069\" d=\"M625 95.5L655 95.5L655 25L25 25L25 95.5L58 95.5\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1070)\"></path></g></svg>\n  <p style=\"text-align:center; color: #888;\">（循环链表）</p>\n</div>\n<p>循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就适合采用循环链表。</p>\n<h3 id=\"双向链表\"> 双向链表</h3>\n<p>双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。如下图所示：</p>\n<div style=\"text-align: center;\">\n  <svg id=\"SvgjsSvg1182\" width=\"751.09375\" height=\"91\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><defs id=\"SvgjsDefs1183\"><marker id=\"SvgjsMarker1240\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1241\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1244\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1245\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1248\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1249\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1252\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1253\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1256\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1257\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1260\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1261\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1264\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1265\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1268\" markerWidth=\"16\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 16 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1269\" d=\"M0,2 L14,6 L0,11 L0,2\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"2\"></path></marker></defs><g id=\"SvgjsG1184\" transform=\"translate(133,25)\"><path id=\"SvgjsPath1185\" d=\"M 0 0L 55 0L 55 41L 0 41Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ff8000\"></path><g id=\"SvgjsG1186\"><text id=\"SvgjsText1187\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"35px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.1\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1188\" dy=\"20\" x=\"27.5\"><tspan id=\"SvgjsTspan1189\" style=\"text-decoration:;\">data</tspan></tspan></text></g></g><g id=\"SvgjsG1190\" transform=\"translate(189,25)\"><path id=\"SvgjsPath1191\" d=\"M 0 0L 55 0L 55 41L 0 41Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffff00\"></path><g id=\"SvgjsG1192\"><text id=\"SvgjsText1193\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"35px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.1\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1194\" dy=\"20\" x=\"27.5\"><tspan id=\"SvgjsTspan1195\" style=\"text-decoration:;\">next</tspan></tspan></text></g></g><g id=\"SvgjsG1196\" transform=\"translate(348,25)\"><path id=\"SvgjsPath1197\" d=\"M 0 0L 55 0L 55 41L 0 41Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ff8000\"></path><g id=\"SvgjsG1198\"><text id=\"SvgjsText1199\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"35px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.1\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1200\" dy=\"20\" x=\"27.5\"><tspan id=\"SvgjsTspan1201\" style=\"text-decoration:;\">data</tspan></tspan></text></g></g><g id=\"SvgjsG1202\" transform=\"translate(404,25)\"><path id=\"SvgjsPath1203\" d=\"M 0 0L 55 0L 55 41L 0 41Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffff00\"></path><g id=\"SvgjsG1204\"><text id=\"SvgjsText1205\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"35px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.1\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1206\" dy=\"20\" x=\"27.5\"><tspan id=\"SvgjsTspan1207\" style=\"text-decoration:;\">next</tspan></tspan></text></g></g><g id=\"SvgjsG1208\" transform=\"translate(562,25)\"><path id=\"SvgjsPath1209\" d=\"M 0 0L 55 0L 55 41L 0 41Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ff8000\"></path><g id=\"SvgjsG1210\"><text id=\"SvgjsText1211\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"35px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.1\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1212\" dy=\"20\" x=\"27.5\"><tspan id=\"SvgjsTspan1213\" style=\"text-decoration:;\">data</tspan></tspan></text></g></g><g id=\"SvgjsG1214\" transform=\"translate(618,25)\"><path id=\"SvgjsPath1215\" d=\"M 0 0L 55 0L 55 41L 0 41Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffff00\"></path><g id=\"SvgjsG1216\"><text id=\"SvgjsText1217\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"35px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.1\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1218\" dy=\"20\" x=\"27.5\"><tspan id=\"SvgjsTspan1219\" style=\"text-decoration:;\">next</tspan></tspan></text></g></g><g id=\"SvgjsG1220\" transform=\"translate(79,25)\"><path id=\"SvgjsPath1221\" d=\"M 0 0L 55 0L 55 41L 0 41Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffff00\"></path><g id=\"SvgjsG1222\"><text id=\"SvgjsText1223\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"35px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.1\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1224\" dy=\"20\" x=\"27.5\"><tspan id=\"SvgjsTspan1225\" style=\"text-decoration:;\">prev</tspan></tspan></text></g></g><g id=\"SvgjsG1226\" transform=\"translate(294,25)\"><path id=\"SvgjsPath1227\" d=\"M 0 0L 55 0L 55 41L 0 41Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffff00\"></path><g id=\"SvgjsG1228\"><text id=\"SvgjsText1229\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"35px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.1\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1230\" dy=\"20\" x=\"27.5\"><tspan id=\"SvgjsTspan1231\" style=\"text-decoration:;\">prev</tspan></tspan></text></g></g><g id=\"SvgjsG1232\" transform=\"translate(508,25)\"><path id=\"SvgjsPath1233\" d=\"M 0 0L 55 0L 55 41L 0 41Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffff00\"></path><g id=\"SvgjsG1234\"><text id=\"SvgjsText1235\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"16px\" width=\"35px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" anchor=\"middle\" family=\"微软雅黑\" size=\"16px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.1\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1236\" dy=\"20\" x=\"27.5\"><tspan id=\"SvgjsTspan1237\" style=\"text-decoration:;\">prev</tspan></tspan></text></g></g><g id=\"SvgjsG1238\"><path id=\"SvgjsPath1239\" d=\"M242 34L268 34L268 34L294 34\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1240)\"></path></g><g id=\"SvgjsG1242\"><path id=\"SvgjsPath1243\" d=\"M294 59.22354286469243L268.1894153491444 59.22354286469243L268.1894153491444 59.22354286469243L244 59.22354286469243\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1244)\"></path></g><g id=\"SvgjsG1246\"><path id=\"SvgjsPath1247\" d=\"M457 33L482.5 33L482.5 33L508 33\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1248)\"></path></g><g id=\"SvgjsG1250\"><path id=\"SvgjsPath1251\" d=\"M508 57L483.31261557407333 57L483.31261557407333 57L459 57\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1252)\"></path></g><g id=\"SvgjsG1254\"><path id=\"SvgjsPath1255\" d=\"M25 33.5L51 33.5L51 33.5L77 33.5\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1256)\"></path></g><g id=\"SvgjsG1258\"><path id=\"SvgjsPath1259\" d=\"M79.27660817715599 58.72354286469243L53.18941534914438 58.72354286469243L53.18941534914438 58.72354286469243L27.102222521132774 58.72354286469243\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1260)\"></path></g><g id=\"SvgjsG1262\"><path id=\"SvgjsPath1263\" d=\"M672 32.38822856765378L698 32.38822856765378L698 32.38822856765378L724 32.38822856765378\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1264)\"></path></g><g id=\"SvgjsG1266\"><path id=\"SvgjsPath1267\" d=\"M726.276608177156 57.61177143234622L700.1894153491444 57.61177143234622L700.1894153491444 57.61177143234622L674.1022225211327 57.61177143234622\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1268)\"></path></g></svg>\n  <p style=\"text-align:center; color: #888;\">（双向链表）</p>\n</div>\n<p>由于双向链表需要额外的两个空间来存储后继结点和前驱结点的地址，所以存储同样多的数据时，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。</p>\n<p>从结构上来看，双向链表可以支持 <code>O(1)</code> 时间复杂度的情况下找到前驱结点，正是这样的特点，使得双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。</p>\n<div><p>注意</p>\n<p>单链表的插入、删除操作的时间复杂度已经是 <code>O(1)</code> 了，为什么说双向链表更高效呢？</p>\n</div>\n<p>对于链表的<strong>删除操作</strong>，有两种情况：</p>\n<ul>\n<li>删除结点中「值等于某个给定值」的结点。</li>\n<li>删除给定指针指向的结点。</li>\n</ul>\n<p>对于第一种情况，不管是单链表还是双向链表，都需要先定位到要删除的元素（从头结点开始依次遍历），然后再执行删除操作。定位到要删除的元素的平均时间复杂度为 <code>O(n)</code>，执行删除操作的时间复杂度是 <code>O(1)</code>。根据时间复杂度分析中的加法法则，总时间复杂度为 <code>O(n)</code>。</p>\n<p>对于第二种情况，这种情况不用再去遍历找到被删除元素。在直接删除这个指针指向的元素时，需要知道其前驱结点。单链表不支持直接获取前驱结点，所以还是要从头结点开始遍历链表，直到找到其前驱结点，那么单链表的删除操作则需要 <code>O(n)</code> 的时间复杂度；而双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历，因此时间复杂度为 <code>O(1)</code>。</p>\n<p>对于链表的<strong>插入操作</strong>，同理：双向链表可以在 <code>O(1)</code> 时间复杂度搞定，而单向链表需要 <code>O(n)</code> 的时间复杂度。</p>\n<h3 id=\"双向循环链表\"> 双向循环链表</h3>\n<p>如果把循环链表和双向链表整合在一起就是：<strong>双向循环链表</strong>。</p>\n<h2 id=\"链表-vs-数组\"> 链表 VS 数组</h2>\n<ul>\n<li>\n<p>数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。</p>\n</li>\n<li>\n<p>数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致「内存不足（out of memory）」。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，这也是它与数组最大的区别。</p>\n</li>\n</ul>\n<p>除此之外，如果代码对内存的使用非常苛刻，那数组会更适合。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）。</p>\n<p>（完）</p>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2021-11-19T03:27:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "桥接模式",
      "url": "https://www.fedbook.cn/in-depth-learning/design-patterns/bridge-pattern/",
      "id": "https://www.fedbook.cn/in-depth-learning/design-patterns/bridge-pattern/",
      "content_html": "<h1 id=\"桥接模式\"> 桥接模式</h1>\n<h2 id=\"介绍\"> 介绍</h2>\n<p>桥接模式（Bridge Pattern）又称桥梁模式，将抽象部分与它的实现部分分离，使它们都可以独立地变化。使用组合关系代替继承关系，降低抽象和实现两者间的耦合度。</p>\n<p>抽象部分和实现部分可能不太好理解，举个例子，香蕉、苹果、西瓜，它们共同的抽象部分就是水果，可以吃，实现部分就是不同的水果实体。再比如黑色手提包、红色钱包、蓝色公文包，它们共同的抽象部分是包和颜色，这部分的共性就可以被作为抽象提取出来。</p>\n<h2 id=\"通俗的示例\"> 通俗的示例</h2>\n<p>比如包包，包的种类是一个维度（钱包、书包、手提包），包的尺寸是一个维度（小号、中号、大号），包的颜色又是一个维度。每个维度可以自由变化后组合在一起形成一个包。</p>\n<p>我们在系统设计时，如果给每个种类对应的每个尺寸和颜色都设置一个类，那么系统中的类就会很多。如果根据实际需要对种类、尺寸、颜色这些维度进行组合，那么将大大减少系统中类的个数。</p>\n<p>将抽象和实现分离，互相独立互不影响：</p>\n<ul>\n<li>装饰不影响原有的功能，原有功能可以照常使用。</li>\n<li>产品有多个维度，每个维度都可以独立变化（实例化过程），包包这个例子的维度就是种类、尺寸、颜色，这几个维度可以独立地进行变化，从而组装成不同的包包。</li>\n</ul>\n<h2 id=\"桥接模式的通用实现\"> 桥接模式的通用实现</h2>\n<p>实现一下上面这个包包的例子：</p>\n<div><pre><code><span>/* 包包 */</span>\n<span>class</span> <span>Bag</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>type<span>,</span> size<span>,</span> color</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>type <span>=</span> type<span>;</span>\n    <span>this</span><span>.</span>size <span>=</span> size<span>;</span>\n    <span>this</span><span>.</span>color <span>=</span> color<span>;</span>\n  <span>}</span>\n\n  <span>/* 展示 */</span>\n  <span>show</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span>\n      <span>this</span><span>.</span>color<span>.</span><span>show</span><span>(</span><span>)</span> <span>+</span> <span>this</span><span>.</span>size<span>.</span><span>show</span><span>(</span><span>)</span> <span>+</span> <span>this</span><span>.</span>type<span>.</span><span>show</span><span>(</span><span>)</span>\n    <span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* 皮包类型 */</span>\n<span>class</span> <span>BagType</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>type</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>type <span>=</span> type<span>;</span>\n  <span>}</span>\n\n  <span>show</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span>type<span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* 皮包尺寸 */</span>\n<span>class</span> <span>BagSize</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>size</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>size <span>=</span> size<span>;</span>\n  <span>}</span>\n\n  <span>show</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span>size<span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* 皮包颜色 */</span>\n<span>class</span> <span>BagColor</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>color</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>color <span>=</span> color<span>;</span>\n  <span>}</span>\n\n  <span>show</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span>color<span>;</span>\n  <span>}</span>\n<span>}</span>\n\n\n<span>/* 抽象实例化 */</span>\n<span>const</span> walletType <span>=</span> <span>new</span> <span>BagType</span><span>(</span><span>'钱包'</span><span>)</span><span>;</span>\n<span>const</span> briefcaseType <span>=</span> <span>new</span> <span>BagType</span><span>(</span><span>'手提包'</span><span>)</span><span>;</span>\n<span>const</span> smallSize <span>=</span> <span>new</span> <span>BagSize</span><span>(</span><span>'小号'</span><span>)</span><span>;</span>\n<span>const</span> mediumSize <span>=</span> <span>new</span> <span>BagSize</span><span>(</span><span>'中号'</span><span>)</span><span>;</span>\n<span>const</span> redColor <span>=</span> <span>new</span> <span>BagColor</span><span>(</span><span>'红色'</span><span>)</span><span>;</span>\n<span>const</span> yellowColor <span>=</span> <span>new</span> <span>BagColor</span><span>(</span><span>'黄色'</span><span>)</span><span>;</span>\n\n\n<span>const</span> bagA <span>=</span> <span>new</span> <span>Bag</span><span>(</span>walletType<span>,</span> smallSize<span>,</span> redColor<span>)</span><span>;</span>\nbagA<span>.</span><span>show</span><span>(</span><span>)</span>\n<span>// 输出：红色小号钱包</span>\n\n<span>const</span> bagB <span>=</span> <span>new</span> <span>Bag</span><span>(</span>briefcaseType<span>,</span> mediumSize<span>,</span> yellowColor<span>)</span><span>;</span>\nbagB<span>.</span><span>show</span><span>(</span><span>)</span>\n<span>// 输出：黄色中号手提包</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br></div></div><p>可以看到由于包包的结构被分别抽象为几个部件的组合，部件的实例化是在部件类各自的构造函数中完成，因此部件之间的实例化不会相互影响，新产品的创建也变得容易，这就是桥接模式的好处。</p>\n<h2 id=\"桥接模式的原理\"> 桥接模式的原理</h2>\n<p>我们可以提炼一下桥接模式，包包是产品（Product），种类、尺寸、颜色属于抽象出来的部件种类（Components），也属于独立的维度，而具体的部件钱包、小号、红色等属于部件实例（Instances），这些实例可以沿着各自维度变化，共同组成对应产品。主要有以下几个概念：</p>\n<ul>\n<li><strong>Product</strong>：产品，由多个独立部件组成的产品</li>\n<li><strong>Component</strong>：部件，组成产品的部件类</li>\n<li><strong>Instance</strong>：部件类的实例</li>\n</ul>\n<p>结构如下：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/bridge-pattern.jpg\" alt=\"桥接模式结构图\" style=\"width: 640px;\">\n  <p style=\"text-align: center; color: #888;\">（桥接模式结构图）</p>\n</div>\n<h2 id=\"桥接模式的实际应用\"> 桥接模式的实际应用</h2>\n<p>在某一个开发场景，产品经理提出需求：</p>\n<ul>\n<li>一个按钮的前景色默认为黑色、背景色为浅灰色。</li>\n<li>当光标 <code>mouseover</code> 的时候改变前景色为蓝色、背景色为绿色、尺寸变为 <code>1.5</code> 倍。</li>\n<li>当光标 <code>mouseleave</code> 的时候还原前景色、背景色、尺寸。</li>\n<li>在鼠标按下的时候前景色变为红色、背景色变为紫色、尺寸变为 <code>0.5</code> 倍。</li>\n<li>抬起后恢复原状。</li>\n</ul>\n<p>我们要如何去实现呢？按照通常的思维方式开始码代码：</p>\n<div><pre><code><span>var</span> btn <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'btn'</span><span>)</span>\n\n<span>// 设置监听事件</span>\nbtn<span>.</span><span>addEventListener</span><span>(</span><span>'mouseover'</span><span>,</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n  btn<span>.</span>style<span>.</span><span>setProperty</span><span>(</span><span>'color'</span><span>,</span> <span>'blue'</span><span>)</span><span>;</span>\n  btn<span>.</span>style<span>.</span><span>setProperty</span><span>(</span><span>'background-color'</span><span>,</span> <span>'green'</span><span>)</span><span>;</span>\n  btn<span>.</span>style<span>.</span><span>setProperty</span><span>(</span><span>'transform'</span><span>,</span> <span>'scale(1.5)'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span>\n\nbtn<span>.</span><span>addEventListener</span><span>(</span><span>'mouseleave'</span><span>,</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n  btn<span>.</span>style<span>.</span><span>setProperty</span><span>(</span><span>'color'</span><span>,</span> <span>'black'</span><span>)</span><span>;</span>\n  btn<span>.</span>style<span>.</span><span>setProperty</span><span>(</span><span>'background-color'</span><span>,</span> <span>'lightgray'</span><span>)</span><span>;</span>\n  btn<span>.</span>style<span>.</span><span>setProperty</span><span>(</span><span>'transform'</span><span>,</span> <span>'scale(1)'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span>\n\nbtn<span>.</span><span>addEventListener</span><span>(</span><span>'mousedown'</span><span>,</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n  btn<span>.</span>style<span>.</span><span>setProperty</span><span>(</span><span>'color'</span><span>,</span> <span>'red'</span><span>)</span><span>;</span>\n  btn<span>.</span>style<span>.</span><span>setProperty</span><span>(</span><span>'background-color'</span><span>,</span> <span>'purple'</span><span>)</span><span>;</span>\n  btn<span>.</span>style<span>.</span><span>setProperty</span><span>(</span><span>'transform'</span><span>,</span> <span>'scale(.5)'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span>\n\nbtn<span>.</span><span>addEventListener</span><span>(</span><span>'mouseup'</span><span>,</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n  btn<span>.</span>style<span>.</span><span>setProperty</span><span>(</span><span>'color'</span><span>,</span> <span>'black'</span><span>)</span><span>;</span>\n  btn<span>.</span>style<span>.</span><span>setProperty</span><span>(</span><span>'background-color'</span><span>,</span> <span>'lightgray'</span><span>)</span><span>;</span>\n  btn<span>.</span>style<span>.</span><span>setProperty</span><span>(</span><span>'transform'</span><span>,</span> <span>'scale(1)'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>经理！我搞定了！</p>\n<p>但是我们可以使用桥接模式来改造一下：把 DOM 对象的前景色、背景色作为其外观部件，尺寸属性是另一个尺寸部件，这样的话对各自部件的操作可以作为抽象被提取出来，使得对各自部件可以独立且方便地操作：</p>\n<div><pre><code><span>var</span> btn <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'btn'</span><span>)</span><span>;</span>\n\n<span>/* 设置前景色和背景色 */</span>\n<span>function</span> <span>setColor</span><span>(</span>element<span>,</span> color<span>=</span><span>'black'</span><span>,</span> bgc<span>=</span><span>'lightgray'</span><span>)</span> <span>{</span>\n  element<span>.</span>style<span>.</span><span>setProperty</span><span>(</span><span>'color'</span><span>,</span> color<span>)</span><span>;</span>\n  element<span>.</span>style<span>.</span><span>setProperty</span><span>(</span><span>'background-color'</span><span>,</span> bgc<span>)</span><span>;</span>\n<span>}</span>\n\n<span>/* 设置尺寸 */</span>\n<span>function</span> <span>setSize</span><span>(</span>element<span>,</span> size<span>=</span><span>'1'</span><span>)</span> <span>{</span>\n  element<span>.</span>style<span>.</span><span>setProperty</span><span>(</span><span>'transform'</span><span>,</span> <span><span>`</span><span>scale(</span><span><span>${</span> size <span>}</span></span><span>)</span><span>`</span></span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>// 设置监听事件</span>\nbtn<span>.</span><span>addEventListener</span><span>(</span><span>'mouseover'</span><span>,</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n  <span>setColor</span><span>(</span>btn<span>,</span> <span>'blue'</span><span>,</span> <span>'green'</span><span>)</span><span>;</span>\n  <span>setSize</span><span>(</span>btn<span>,</span> <span>'1.5'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span>\n\nbtn<span>.</span><span>addEventListener</span><span>(</span><span>'mouseleave'</span><span>,</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n  <span>setColor</span><span>(</span>btn<span>)</span><span>;</span>\n  <span>setSize</span><span>(</span>btn<span>)</span><span>;</span>\n<span>}</span><span>)</span>\n\nbtn<span>.</span><span>addEventListener</span><span>(</span><span>'mousedown'</span><span>,</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n  <span>setColor</span><span>(</span>btn<span>,</span> <span>'red'</span><span>,</span> <span>'purple'</span><span>)</span><span>;</span>\n  <span>setSize</span><span>(</span>btn<span>,</span> <span>'.5'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span>\n\nbtn<span>.</span><span>addEventListener</span><span>(</span><span>'mouseup'</span><span>,</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n  <span>setColor</span><span>(</span>btn<span>)</span><span>;</span>\n  <span>setSize</span><span>(</span>btn<span>)</span><span>;</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>是不是看起来清晰多了，这里的 <code>setColor</code>、<code>setSize</code> 就是桥接函数，是将 DOM （产品）及其属性（部件）连接在一起的桥梁，用户只要给桥接函数传递参数即可，十分便捷。其他 DOM 要有类似的对外观部件和尺寸部件的操作，也可以方便地进行复用。</p>\n<h2 id=\"设计原则验证\"> 设计原则验证</h2>\n<ul>\n<li>抽象和实现分离，解耦</li>\n<li>符合开放封闭原则</li>\n</ul>\n<h2 id=\"桥接模式的优缺点\"> 桥接模式的优缺点</h2>\n<p>优点：</p>\n<ul>\n<li>分离了抽象和实现部分，将实现层（DOM 元素事件触发并执行具体修改逻辑）和抽象层（ 元素外观、尺寸部分的修改函数）解耦，<strong>有利于分层</strong>。</li>\n<li>提高了<strong>可扩展性</strong>，多个维度的部件自由组合，避免了类继承带来的强耦合关系，也减少了部件类的数量。</li>\n<li>使用者<strong>不用关心细节的实现</strong>，可以方便快捷地进行使用。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>桥接模式要求两个部件没有耦合关系，否则无法独立地变化，因此要求正确的对系统变化的维度进行识别，使用范围存在局限性。</li>\n<li>桥接模式的引入增加了系统复杂度。</li>\n</ul>\n<h2 id=\"桥接模式的适用场景\"> 桥接模式的适用场景</h2>\n<ul>\n<li>如果产品的部件有独立的变化维度，可以考虑桥接模式。</li>\n<li>不希望使用继承，或因为多层次继承导致系统类的个数急剧增加的系统。</li>\n<li>产品部件的粒度越细，部件复用的必要性越大，可以考虑桥接模式。</li>\n</ul>\n<h2 id=\"其他相关模式\"> 其他相关模式</h2>\n<h3 id=\"桥接模式和策略模式\"> 桥接模式和策略模式</h3>\n<ul>\n<li><strong>桥接模式</strong>：复用部件类，不同部件的实例相互之间无法替换，但是相同部件的实例一般可以替换。</li>\n<li><strong>策略模式</strong>：复用策略类，不同策略之间地位平等，可以相互替换。</li>\n</ul>\n<h3 id=\"桥接模式与模板方法模式\"> 桥接模式与模板方法模式</h3>\n<ul>\n<li><strong>桥接模式</strong>：将组成产品的部件实例的创建，延迟到实例的具体创建过程中。</li>\n<li><strong>模版方法模式</strong>：将创建产品的某一步骤，延迟到子类中实现。</li>\n</ul>\n<h3 id=\"桥接模式与抽象工厂模式\"> 桥接模式与抽象工厂模式</h3>\n<p>这两个模式可以组合使用，比如部件类实例的创建可以结合抽象工厂模式，因为部件类实例也属于一个产品类簇，明显属于抽象工厂模式的适用范围，如果创建的部件类不多，或者比较简单，也可以使用简单工厂模式。</p>\n<p>（完）</p>\n",
      "date_published": "2022-03-28T10:10:03.000Z",
      "date_modified": "2022-03-28T10:10:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "建造者模式",
      "url": "https://www.fedbook.cn/in-depth-learning/design-patterns/builder-pattern/",
      "id": "https://www.fedbook.cn/in-depth-learning/design-patterns/builder-pattern/",
      "content_html": "<h1 id=\"建造者模式\"> 建造者模式</h1>\n<h2 id=\"介绍\"> 介绍</h2>\n<p>建造者模式（Builder Pattern）又称生成器模式，分步构建一个复杂对象，并允许按步骤构造。同样的构建过程可以采用不同的表示，将一个复杂对象的<strong>构建层与其表示层分离</strong>。</p>\n<p>在工厂模式中，创建的结果都是一个完整的个体，我们对创建的过程并不关心，只需了解创建的结果。而在建造者模式中，我们关心的是对象的创建过程，因此我们通常将创建的复杂对象的模块化，使得被创建的对象的每一个子模块都可以得到高质量的复用，当然在灵活的 JavaScript 中我们可以有更灵活的实现。</p>\n<h2 id=\"通俗的示例\"> 通俗的示例</h2>\n<p>假定我们需要建造一个车，车这个产品是由多个部件组成，车身、引擎、轮胎。汽车制造厂一般不会自己完成每个部件的制造，而是把部件的制造交给对应的汽车零部件制造商，自己只进行装配，最后生产出整车。整车的每个部件都是一个相对独立的个体，都具有自己的生产过程，多个部件经过一系列的组装共同组成了一个完整的车。</p>\n<p>类似的场景还有很多，比如生产一个笔记本电脑，由主板、显示器、壳子组成，每个部件都有自己独立的行为和功能，他们共同组成了一个笔记本电脑。笔记本电脑厂从部件制造商处获得制造完成的部件，再由自己完成组装，得到笔记本电脑这个完整的产品。</p>\n<p>在这些场景中，有以下特点：</p>\n<ul>\n<li>整车制造厂（指挥者）无需知道零部件的生产过程，零部件的生产过程一般由零部件厂商（建造者）来完成。</li>\n<li>整车制造厂（指挥者）决定以怎样的装配方式来组装零部件，以得到最终的产品。</li>\n</ul>\n<h2 id=\"建造者模式的通用实现\"> 建造者模式的通用实现</h2>\n<p>我们提炼一下建造者模式，这里的生产汽车的奔驰厂家就相当于指挥者（Director），厂家负责将不同的部件组装成最后的产品（Product），而部件的生产者是部件厂家相当于建造者（Builder），我们通过指挥者就可以获得希望的复杂的产品对象，再通过访问不同指挥者获得装配方式不同的产品。主要有下面几个概念：</p>\n<ul>\n<li><strong>Director</strong>：指挥者，调用建造者中的部件具体实现进行部件装配，相当于整车组装厂，最终返回装配完毕的产品。</li>\n<li><strong>Builder</strong>：建造者，含有不同部件的生产方式给指挥者调用，是部件真正的生产者，但没有部件的装配流程。</li>\n<li><strong>Product</strong>：产品，要返回给访问者的复杂对象。</li>\n</ul>\n<p>建造者模式的主要功能是构建复杂的产品，并且是复杂的、需要分步骤构建的产品，其构建的算法是统一的，构建的过程由指挥者决定，只要配置不同的指挥者，就可以构建出不同的复杂产品来。也就是说，建造者模式<strong>将产品装配的算法和具体部件的实现分离</strong>，这样构建的算法可以扩展和复用，部件的具体实现也可以方便地扩展和复用，从而可以灵活地通过组合来构建出不同的产品对象。</p>\n<p>结构如下：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/builder-pattern.png\" alt=\"建造者模式结构图\" style=\"width: 640px;\">\n  <p style=\"text-align: center; color: #888;\">（建造者模式结构图）</p>\n</div>\n<p>代码如下：</p>\n<div><pre><code><span>// 建造者，部件生产</span>\n<span>class</span> <span>ProductBuilder</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>param</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>param <span>=</span> param\n  <span>}</span>\n\n  <span>/* 生产部件，part1 */</span>\n  <span>buildPart1</span><span>(</span><span>)</span> <span>{</span>\n    <span>// ... Part1 生产过程</span>\n    <span>this</span><span>.</span>part1 <span>=</span> <span>'part1'</span>\n\n  <span>}</span>\n\n  <span>/* 生产部件，part2 */</span>\n  <span>buildPart2</span><span>(</span><span>)</span> <span>{</span>\n    <span>// ... Part2 生产过程</span>\n    <span>this</span><span>.</span>part2 <span>=</span> <span>'part2'</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* 指挥者，负责最终产品的装配 */</span>\n<span>class</span> <span>Director</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>param</span><span>)</span> <span>{</span>\n    <span>const</span> _product <span>=</span> <span>new</span> <span>ProductBuilder</span><span>(</span>param<span>)</span>\n    _product<span>.</span><span>buildPart1</span><span>(</span><span>)</span>\n    _product<span>.</span><span>buildPart2</span><span>(</span><span>)</span>\n    <span>return</span> _product\n  <span>}</span>\n<span>}</span>\n\n<span>// 获得产品实例</span>\n<span>const</span> product <span>=</span> <span>new</span> <span>Director</span><span>(</span><span>'param'</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>结合链模式：</p>\n<div><pre><code><span>// 建造者，汽车部件厂家</span>\n<span>class</span> <span>CarBuilder</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>param</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>param <span>=</span> param\n  <span>}</span>\n\n  <span>/* 生产部件，part1 */</span>\n  <span>buildPart1</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>part1 <span>=</span> <span>'part1'</span>\n    <span>return</span> <span>this</span>\n  <span>}</span>\n\n  <span>/* 生产部件，part2 */</span>\n  <span>buildPart2</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>part2 <span>=</span> <span>'part2'</span>\n    <span>return</span> <span>this</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 汽车装配，获得产品实例</span>\n<span>const</span> benchi1 <span>=</span> <span>new</span> <span>CarBuilder</span><span>(</span><span>'param'</span><span>)</span>\n  <span>.</span><span>buildPart1</span><span>(</span><span>)</span>\n  <span>.</span><span>buildPart2</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>如果希望扩展实例的功能，那么只需要在建造者类的原型上增加一个实例方法，再返回 <code>this</code> 即可。</p>\n<p>值得一提的是，结合链模式的建造者模式中，装配复杂对象的链式装配过程就是指挥者 Director 角色，只不过在链式装配过程中不再封装在具体指挥者中，而是由使用者自己确定装配过程。</p>\n<h2 id=\"建造者模式的实际应用\"> 建造者模式的实际应用</h2>\n<h3 id=\"重构一个具有很多参数的构造函数\"> 重构一个具有很多参数的构造函数</h3>\n<p>有时候你会遇到一个参数很多的构造函数，比如：</p>\n<div><pre><code><span>// 汽车建造者</span>\n<span>class</span> <span>CarBuilder</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>engine<span>,</span> weight<span>,</span> height<span>,</span> color<span>,</span> tyre<span>,</span> name<span>,</span> type</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>engine <span>=</span> engine\n    <span>this</span><span>.</span>weight <span>=</span> weight\n    <span>this</span><span>.</span>height <span>=</span> height\n    <span>this</span><span>.</span>color <span>=</span> color\n    <span>this</span><span>.</span>tyre <span>=</span> tyre\n    <span>this</span><span>.</span>name <span>=</span> name\n    <span>this</span><span>.</span>type <span>=</span> type\n  <span>}</span>\n<span>}</span>\n\n<span>const</span> benchi <span>=</span> <span>new</span> <span>CarBuilder</span><span>(</span><span>'大马力发动机'</span><span>,</span> <span>'2ton'</span><span>,</span> <span>'white'</span><span>,</span> <span>'大号轮胎'</span><span>,</span> <span>'奔驰'</span><span>,</span> <span>'AMG'</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>如果构造函数的参数多于 3 个，在使用的时候就很容易弄不清哪个参数对应的是什么含义，你可以使用对象解构赋值的方式来提高可读性和使用便利性，也可以使用建造者模式的思想来进行属性赋值，这是另一个思路。代码如下：</p>\n<div><pre><code><span>// 汽车建造者</span>\n<span>class</span> <span>CarBuilder</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>engine<span>,</span> weight<span>,</span> height<span>,</span> color<span>,</span> tyre<span>,</span> name<span>,</span> type</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>engine <span>=</span> engine\n    <span>this</span><span>.</span>weight <span>=</span> weight\n    <span>this</span><span>.</span>height <span>=</span> height\n    <span>this</span><span>.</span>color <span>=</span> color\n    <span>this</span><span>.</span>tyre <span>=</span> tyre\n    <span>this</span><span>.</span>name <span>=</span> name\n    <span>this</span><span>.</span>type <span>=</span> type\n  <span>}</span>\n\n  <span>setCarProperty</span><span>(</span><span>key<span>,</span> value</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>Object<span>.</span><span>getOwnPropertyNames</span><span>(</span><span>this</span><span>)</span><span>.</span><span>includes</span><span>(</span>key<span>)</span><span>)</span> <span>{</span>\n      <span>this</span><span>[</span>key<span>]</span> <span>=</span> value\n      <span>return</span> <span>this</span>\n    <span>}</span>\n    <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span><span>`</span><span>Key error : </span><span><span>${</span> key <span>}</span></span><span> 不是本实例上的属性</span><span>`</span></span><span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>const</span> benchi <span>=</span> <span>new</span> <span>CarBuilder</span><span>(</span><span>)</span>\n  <span>.</span><span>setCarProperty</span><span>(</span><span>'engine'</span><span>,</span> <span>'大马力发动机'</span><span>)</span>\n  <span>.</span><span>setCarProperty</span><span>(</span><span>'weight'</span><span>,</span> <span>'2ton'</span><span>)</span>\n  <span>.</span><span>setCarProperty</span><span>(</span><span>'height'</span><span>,</span> <span>'2000mm'</span><span>)</span>\n  <span>.</span><span>setCarProperty</span><span>(</span><span>'color'</span><span>,</span> <span>'white'</span><span>)</span>\n  <span>.</span><span>setCarProperty</span><span>(</span><span>'tyre'</span><span>,</span> <span>'大号轮胎'</span><span>)</span>\n  <span>.</span><span>setCarProperty</span><span>(</span><span>'name'</span><span>,</span> <span>'奔驰'</span><span>)</span>\n  <span>.</span><span>setCarProperty</span><span>(</span><span>'type'</span><span>,</span> <span>'AMG'</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>每个键都是用一个同样的方法来设置，或许你觉得不太直观，我们可以将设置每个属性的操作都单独列为一个方法，这样可读性就更高了：</p>\n<div><pre><code><span>// 汽车建造者</span>\n<span>class</span> <span>CarBuilder</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>engine<span>,</span> weight<span>,</span> height<span>,</span> color<span>,</span> tyre<span>,</span> name<span>,</span> type</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>engine <span>=</span> engine\n    <span>this</span><span>.</span>weight <span>=</span> weight\n    <span>this</span><span>.</span>height <span>=</span> height\n    <span>this</span><span>.</span>color <span>=</span> color\n    <span>this</span><span>.</span>tyre <span>=</span> tyre\n    <span>this</span><span>.</span>name <span>=</span> name\n    <span>this</span><span>.</span>type <span>=</span> type\n  <span>}</span>\n\n  <span>setPropertyFuncChain</span><span>(</span><span>)</span> <span>{</span>\n    Object<span>.</span><span>getOwnPropertyNames</span><span>(</span><span>this</span><span>)</span>\n      <span>.</span><span>forEach</span><span>(</span><span>key</span> <span>=></span> <span>{</span>\n        <span>const</span> funcName <span>=</span> <span>'set'</span> <span>+</span> key<span>.</span><span>replace</span><span>(</span><span><span>/</span><span>^\\w</span><span>/</span><span>g</span></span><span>,</span> <span>str</span> <span>=></span> str<span>.</span><span>toUpperCase</span><span>(</span><span>)</span><span>)</span>\n        <span>this</span><span>[</span>funcName<span>]</span> <span>=</span> <span>value</span> <span>=></span> <span>{</span>\n          <span>this</span><span>[</span>key<span>]</span> <span>=</span> value\n          <span>return</span> <span>this</span>\n        <span>}</span>\n      <span>}</span><span>)</span>\n    <span>return</span> <span>this</span>\n  <span>}</span>\n<span>}</span>\n\n<span>const</span> benchi <span>=</span> <span>new</span> <span>CarBuilder</span><span>(</span><span>)</span><span>.</span><span>setPropertyFuncChain</span><span>(</span><span>)</span>\n  <span>.</span><span>setEngine</span><span>(</span><span>'大马力发动机'</span><span>)</span>\n  <span>.</span><span>setWeight</span><span>(</span><span>'2ton'</span><span>)</span>\n  <span>.</span><span>setHeight</span><span>(</span><span>'2000mm'</span><span>)</span>\n  <span>.</span><span>setColor</span><span>(</span><span>'white'</span><span>)</span>\n  <span>.</span><span>setTyre</span><span>(</span><span>'大号轮胎'</span><span>)</span>\n  <span>.</span><span>setName</span><span>(</span><span>'奔驰'</span><span>)</span>\n  <span>.</span><span>setType</span><span>(</span><span>'AMG'</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>PS：这里用到了点正则的知识。</p>\n<h3 id=\"重构-react-的书写形式\"> 重构 React 的书写形式</h3>\n<div><p>注意</p>\n<p>这个方式不一定推荐，只是用来开阔视野。</p>\n</div>\n<p>当我们写一个 React 组件的时候，一般结构形式如下；</p>\n<div><pre><code><span>class</span> <span>ContainerComponent</span> <span>extends</span> <span>Component</span> <span>{</span>\n  <span>componentDidMount</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>props<span>.</span><span>fetchThings</span><span>(</span><span>)</span>\n  <span>}</span>\n  <span>render</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>&lt;</span>PresentationalComponent <span>{</span><span>...</span><span>this</span><span>.</span>props<span>}</span><span>/</span><span>></span>\n  <span>}</span>\n<span>}</span>\n\nContainerComponent<span>.</span>propTypes <span>=</span> <span>{</span>\n  fetchThings<span>:</span> PropTypes<span>.</span>func<span>.</span>isRequired\n<span>}</span>\n\n<span>const</span> <span>mapStateToProps</span> <span>=</span> <span>state</span> <span>=></span> <span>(</span><span>{</span>\n  things<span>:</span> state<span>.</span>things\n<span>}</span><span>)</span>\n<span>const</span> <span>mapDispatchToProps</span> <span>=</span> <span>dispatch</span> <span>=></span> <span>(</span><span>{</span>\n  <span>fetchThings</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>dispatch</span><span>(</span><span>fetchThings</span><span>(</span><span>)</span><span>)</span><span>,</span>\n  <span>selectThing</span><span>:</span> <span>id</span> <span>=></span> <span>dispatch</span><span>(</span><span>selectThing</span><span>(</span>id<span>)</span><span>)</span><span>,</span>\n  <span>blowShitUp</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>dispatch</span><span>(</span><span>blowShitUp</span><span>(</span><span>)</span><span>)</span>\n<span>}</span><span>)</span>\n\n<span>export</span> <span>default</span> <span>connect</span><span>(</span>\n  mapStateToProps<span>,</span>\n  mapDispatchToProps\n<span>)</span><span>(</span>ContainerComponent<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>通过建造者模式重构，我们可以将组件形式写成如下方式：</p>\n<div><pre><code><span>export</span> <span>default</span> <span>ComponentBuilder</span><span>(</span><span>'ContainerComponent'</span><span>)</span>\n  <span>.</span><span>render</span><span>(</span><span>props</span> <span>=></span> <span>&lt;</span>PresentationalComponent <span>{</span><span>...</span>props<span>}</span><span>/</span><span>></span><span>)</span>\n  <span>.</span><span>componentDidMount</span><span>(</span><span>props</span> <span>=></span> props<span>.</span><span>fetchThings</span><span>(</span><span>)</span><span>)</span>\n  <span>.</span><span>propTypes</span><span>(</span><span>{</span>\n    fetchThings<span>:</span> PropTypes<span>.</span>func<span>.</span>isRequired\n  <span>}</span><span>)</span>\n  <span>.</span><span>mapStateToProps</span><span>(</span><span>state</span> <span>=></span> <span>(</span><span>{</span>\n    things<span>:</span> state<span>.</span>things\n  <span>}</span><span>)</span><span>)</span>\n  <span>.</span><span>mapDispatchToProps</span><span>(</span><span>dispatch</span> <span>=></span> <span>(</span><span>{</span>\n    <span>fetchThings</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>dispatch</span><span>(</span><span>fetchThings</span><span>(</span><span>)</span><span>)</span><span>,</span>\n    <span>selectThing</span><span>:</span> <span>id</span> <span>=></span> <span>dispatch</span><span>(</span><span>selectThing</span><span>(</span>id<span>)</span><span>)</span><span>,</span>\n    <span>blowShitUp</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>dispatch</span><span>(</span><span>blowShitUp</span><span>(</span><span>)</span><span>)</span>\n  <span>}</span><span>)</span><span>)</span>\n  <span>.</span><span>build</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id=\"设计原则验证\"> 设计原则验证</h2>\n<ul>\n<li>将产品的创建算法和产品组成的实现隔离</li>\n<li>符合开放封闭原则</li>\n</ul>\n<h2 id=\"建造者模式的优缺点\"> 建造者模式的优缺点</h2>\n<p>优点：</p>\n<ul>\n<li>使用建造者模式可以<strong>使产品的构建流程和产品的表现分离</strong>，也就是将产品的创建算法和产品组成的实现隔离，访问者不必知道产品部件实现的细节。</li>\n<li><strong>扩展方便</strong>，如果希望生产一个装配顺序或方式不同的新产品，那么直接新建一个指挥者即可，不用修改既有代码，符合开闭原则。</li>\n<li><strong>更好的复用性</strong>，建造者模式将产品的创建算法和产品组成的实现分离，所以产品创建的算法可以复用，产品部件的实现也可以复用，带来很大的灵活性</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>建造者模式一般适用于产品之间组成部件类似的情况，<strong>如果产品之间差异性很大、复用性不高</strong>，那么不要使用建造者模式。</li>\n<li>实例的创建增加了许多额外的结构，无疑增加了许多复杂度，<strong>如果对象粒度不大</strong>，那么我们最好直接创建对象。</li>\n</ul>\n<h2 id=\"建造者模式的适用场景\"> 建造者模式的适用场景</h2>\n<ul>\n<li>相同的方法，不同的执行顺序，产生不一样的产品时，可以采用建造者模式。</li>\n<li>产品的组成部件类似，通过组装不同的组件获得不同产品时，可以采用建造者模式。</li>\n</ul>\n<h2 id=\"其他相关模式\"> 其他相关模式</h2>\n<h3 id=\"建造者模式与工厂模式\"> 建造者模式与工厂模式</h3>\n<p>建造者模式和工厂模式最终都是创建一个完整的产品，但是在建造者模式中我们更关心对象创建的过程，将创建对象的方法模块化，从而更好地复用这些模块。</p>\n<p>当然建造者模式与工厂模式也是可以组合使用的，比如建造者中一般会提供不同的部件实现，那么这里就可以使用工厂模式来提供具体的部件对象，再通过指挥者来进行装配。</p>\n<h3 id=\"建造者模式与模版方法模式\"> 建造者模式与模版方法模式</h3>\n<p>指挥者的实现可以和模版方法模式相结合。也就是说，指挥者中部件的装配过程，可以使用模版方法模式来固定装配算法，把部件实现方法分为模板方法和基本方法，进一步提取公共代码，扩展可变部分。</p>\n<p>是否采用模版方法模式看具体场景，如果产品的部件装配顺序很明确，但是具体的实现是未知的、灵活的，那么你可以适当考虑是否应该将算法骨架提取出来。</p>\n<p>（完）</p>\n",
      "date_published": "2022-03-30T15:28:58.000Z",
      "date_modified": "2022-03-30T15:28:58.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "职责链模式",
      "url": "https://www.fedbook.cn/in-depth-learning/design-patterns/chain-of-responsibility-pattern/",
      "id": "https://www.fedbook.cn/in-depth-learning/design-patterns/chain-of-responsibility-pattern/",
      "content_html": "<h1 id=\"职责链模式\"> 职责链模式</h1>\n<h2 id=\"介绍\"> 介绍</h2>\n<p>职责链模式（Chain of Responsibility Pattern）就是在一步操作可能分为多个职责角色来完成时，把这些角色都分开，然后用一个链串起来，将发起者和各个处理者进行隔离（各个处理者之间也相互隔离）。</p>\n<h2 id=\"通俗的示例\"> 通俗的示例</h2>\n<p>这里举个请假的例子：</p>\n<p>你需要请两天假。首先跟你的小组领导提了一句，小领导说不行呐我只能批半天假，建议找部门经理。于是你来到了部门经理办公室，部门经理说不行呐我只能批一天假，建议找总经理。来到总经理办公室，总经理勉为其难的说，可以，不过要扣你两天工资。于是你请到了两天假。</p>\n<p>当你作为请求者提出请假申请时，这个申请会由小组领导、部门经理、总经理之中的某一位领导来进行处理，但一开始提出申请的时候，并不知道这个申请之后由哪个领导来处理，也许是部门经理，或者是总经理，请求者事先不知道这个申请最后到底应该由哪个领导处理。</p>\n<p>在类似的场景中，这些例子有以下特点：</p>\n<ul>\n<li>请求在一系列对象中传递，形成一条链。</li>\n<li>链中的请求接受者对请求进行分析，要么处理这个请求，要么把这个请求传递给链的下一个接受者。</li>\n</ul>\n<h2 id=\"职责链模式的通用实现\"> 职责链模式的通用实现</h2>\n<p>用 JS 代码实现上面的请假流程，我们很自然地会这么写：</p>\n<div><pre><code><span>var</span> <span>askLeave</span> <span>=</span> <span>function</span><span>(</span><span>duration</span><span>)</span> <span>{</span>\n  <span>if</span> <span>(</span>duration <span>&lt;=</span> <span>0.5</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'小组领导经过一番心理斗争：批准了'</span><span>)</span><span>;</span>\n  <span>}</span> <span>else</span> <span>if</span> <span>(</span>duration <span>&lt;=</span> <span>1</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'部门领导经过一番心理斗争：批准了'</span><span>)</span><span>;</span>\n  <span>}</span> <span>else</span> <span>if</span> <span>(</span>duration <span>&lt;=</span> <span>2</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'总经理经过一番心理斗争：批准了'</span><span>)</span><span>;</span>\n  <span>}</span> <span>else</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'总经理：不准请这么长的假'</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>askLeave</span><span>(</span><span>0.5</span><span>)</span><span>;</span> <span>// 小组领导经过一番心理斗争：批准了</span>\n<span>askLeave</span><span>(</span><span>1</span><span>)</span><span>;</span>   <span>// 部门领导经过一番心理斗争：批准了</span>\n<span>askLeave</span><span>(</span><span>2</span><span>)</span><span>;</span>   <span>// 总经理经过一番心理斗争：批准了</span>\n<span>askLeave</span><span>(</span><span>3</span><span>)</span><span>;</span>   <span>// 总经理：不准请这么长的假</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>这么实现比较直白，但也会有一些问题：处理逻辑比较复杂时，这个 <code>askLeave</code> 方法会变得庞大而臃肿。而且如果中间增加一个新的领导层，那么你就要修改这个庞大的 <code>askLeave</code> 方法，维护工作变得复杂。</p>\n<p>使用职责链模式重构，要求满足下面几个目标：</p>\n<ul>\n<li>将不同领导的处理逻辑（也就是职责节点）提取出来，请假的时候直接找小组领导，如果小组领导处理不好，直接把请求传递给部门领导，部门领导处理不了则传递给总经理。</li>\n<li>遵循开闭原则，增加新的职责节点或删除节点的时候，对原来的代码没有影响。</li>\n</ul>\n<p>代码如下：</p>\n<div><pre><code><span>/* 小组领导 */</span>\n<span>var</span> GroupLeader <span>=</span> <span>{</span>\n  nextLeader<span>:</span> <span>null</span><span>,</span>\n  <span>setNext</span><span>:</span> <span>function</span><span>(</span><span>next</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>nextLeader <span>=</span> next<span>;</span>\n  <span>}</span><span>,</span>\n  <span>handle</span><span>:</span> <span>function</span><span>(</span><span>duration</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>duration <span>&lt;=</span> <span>0.5</span><span>)</span> <span>{</span>\n      console<span>.</span><span>log</span><span>(</span><span>'小组领导经过一番心理斗争：批准了'</span><span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      <span>this</span><span>.</span>nextLeader<span>.</span><span>handle</span><span>(</span>duration<span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* 部门领导 */</span>\n<span>var</span> DepartmentLeader <span>=</span> <span>{</span>\n  nextLeader<span>:</span> <span>null</span><span>,</span>\n  <span>setNext</span><span>:</span> <span>function</span><span>(</span><span>next</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>nextLeader <span>=</span> next<span>;</span>\n  <span>}</span><span>,</span>\n  <span>handle</span><span>:</span> <span>function</span><span>(</span><span>duration</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>duration <span>&lt;=</span> <span>1</span><span>)</span> <span>{</span>\n      console<span>.</span><span>log</span><span>(</span><span>'部门领导经过一番心理斗争：批准了'</span><span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      <span>this</span><span>.</span>nextLeader<span>.</span><span>handle</span><span>(</span>duration<span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* 总经理 */</span>\n<span>var</span> GeneralLeader <span>=</span> <span>{</span>\n  nextLeader<span>:</span> <span>null</span><span>,</span>\n  <span>setNext</span><span>:</span> <span>function</span><span>(</span><span>next</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>nextLeader <span>=</span> next<span>;</span>\n  <span>}</span><span>,</span>\n  <span>handle</span><span>:</span> <span>function</span><span>(</span><span>duration</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>duration <span>&lt;=</span> <span>2</span><span>)</span> <span>{</span>\n      console<span>.</span><span>log</span><span>(</span><span>'总经理经过一番心理斗争：批准了'</span><span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      console<span>.</span><span>log</span><span>(</span><span>'总经理：不准请这么长的假'</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n\nGroupLeader<span>.</span><span>setNext</span><span>(</span>DepartmentLeader<span>)</span><span>;</span>   <span>// 设置小组领导的下一个职责节点为部门领导</span>\nDepartmentLeader<span>.</span><span>setNext</span><span>(</span>GeneralLeader<span>)</span><span>;</span> <span>// 设置部门领导的下一个职责节点为总经理</span>\n\nGroupLeader<span>.</span><span>handle</span><span>(</span><span>0.5</span><span>)</span><span>;</span> <span>// 小组领导经过一番心理斗争：批准了</span>\nGroupLeader<span>.</span><span>handle</span><span>(</span><span>1</span><span>)</span><span>;</span>   <span>// 部门领导经过一番心理斗争：批准了</span>\nGroupLeader<span>.</span><span>handle</span><span>(</span><span>2</span><span>)</span><span>;</span>   <span>// 总经理经过一番心理斗争：批准了</span>\nGroupLeader<span>.</span><span>handle</span><span>(</span><span>3</span><span>)</span><span>;</span>   <span>// 总经理：不准请这么长的假</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br></div></div><p>这样，将职责的链在使用的时候再拼起来，灵活性好，比如如果要在部门领导和总经理中间增加一个新的职责节点，那么在使用时：</p>\n<div><pre><code><span>/* 新领导 */</span>\n<span>var</span> MewLeader <span>=</span> <span>{</span>\n  nextLeader<span>:</span> <span>null</span><span>,</span>\n  <span>setNext</span><span>:</span> <span>function</span><span>(</span><span>next</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>nextLeader <span>=</span> next<span>;</span>\n  <span>}</span><span>,</span>\n  <span>handle</span><span>:</span> <span>function</span><span>(</span><span>duration</span><span>)</span> <span>{</span> <span>...</span> <span>}</span>\n<span>}</span>\n\nGroupLeader<span>.</span><span>setNext</span><span>(</span>DepartmentLeader<span>)</span><span>;</span> <span>// 设置小组领导的下一个职责节点为部门领导</span>\nDepartmentLeader<span>.</span><span>setNext</span><span>(</span>MewLeader<span>)</span><span>;</span>   <span>// 设置部门领导的下一个职责节点为新领导</span>\nMewLeader<span>.</span><span>setNext</span><span>(</span>GeneralLeader<span>)</span><span>;</span>      <span>// 设置新领导的下一个职责节点为总经理</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>删除节点也是类似操作，非常符合开闭原则了，给维护带来很大方便。</p>\n<p>但是我们看到之前的内容有很多重复代码，比如 <code>Leader</code> 对象里的 <code>nextLeader</code>、<code>setNext</code> 里的逻辑就是一样的，可以用继承来避免这部分重复。</p>\n<p>我们使用 ES6 的 <code>class</code> 语法改造一下：</p>\n<div><pre><code><span>/* 领导基类 */</span>\n<span>class</span> <span>Leader</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>nextLeader <span>=</span> <span>null</span><span>;</span>\n  <span>}</span>\n\n  <span>setNext</span><span>(</span><span>next</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>nextLeader <span>=</span> next<span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* 小组领导 */</span>\n<span>class</span> <span>GroupLeader</span> <span>extends</span> <span>Leader</span> <span>{</span>\n  <span>handle</span><span>(</span><span>duration</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>duration <span>&lt;=</span> <span>0.5</span><span>)</span> <span>{</span>\n      console<span>.</span><span>log</span><span>(</span><span>'小组领导经过一番心理斗争：批准了'</span><span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      <span>this</span><span>.</span>nextLeader<span>.</span><span>handle</span><span>(</span>duration<span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* 部门领导 */</span>\n<span>class</span> <span>DepartmentLeader</span> <span>extends</span> <span>Leader</span> <span>{</span>\n  <span>handle</span><span>(</span><span>duration</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>duration <span>&lt;=</span> <span>1</span><span>)</span> <span>{</span>\n      console<span>.</span><span>log</span><span>(</span><span>'部门领导经过一番心理斗争：批准了'</span><span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      <span>this</span><span>.</span>nextLeader<span>.</span><span>handle</span><span>(</span>duration<span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* 总经理 */</span>\n<span>class</span> <span>GeneralLeader</span> <span>extends</span> <span>Leader</span> <span>{</span>\n  <span>handle</span><span>(</span><span>duration</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>duration <span>&lt;=</span> <span>2</span><span>)</span> <span>{</span>\n      console<span>.</span><span>log</span><span>(</span><span>'总经理经过一番心理斗争：批准了'</span><span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      console<span>.</span><span>log</span><span>(</span><span>'总经理：不准请这么长的假'</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n\n<span>const</span> zhangSan <span>=</span> <span>new</span> <span>GroupLeader</span><span>(</span><span>)</span><span>;</span>\n<span>const</span> liSi <span>=</span> <span>new</span> <span>DepartmentLeader</span><span>(</span><span>)</span><span>;</span>\n<span>const</span> wangWu <span>=</span> <span>new</span> <span>GeneralLeader</span><span>(</span><span>)</span><span>;</span>\n\nzhangSan<span>.</span><span>setNext</span><span>(</span>liSi<span>)</span><span>;</span> <span>// 设置小组领导的下一个职责节点为部门领导</span>\nliSi<span>.</span><span>setNext</span><span>(</span>wangWu<span>)</span><span>;</span>   <span>// 设置部门领导的下一个职责节点为总经理</span>\n\nzhangSan<span>.</span><span>handle</span><span>(</span><span>0.5</span><span>)</span><span>;</span> <span>// 小组领导经过一番心理斗争：批准了</span>\nzhangSan<span>.</span><span>handle</span><span>(</span><span>1</span><span>)</span><span>;</span>   <span>// 部门领导经过一番心理斗争：批准了</span>\nzhangSan<span>.</span><span>handle</span><span>(</span><span>2</span><span>)</span><span>;</span>   <span>// 总经理经过一番心理斗争：批准了</span>\nzhangSan<span>.</span><span>handle</span><span>(</span><span>3</span><span>)</span><span>;</span>   <span>// 总经理：不准请这么长的假</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div><p>上面的代码实现，我们可以使用链模式稍加重构，在设置下一个职责节点的方法 <code>setNext</code> 中返回下一个节点实例，使得在职责链的组装过程是一个链的形式，代码结构更加简洁。</p>\n<div><pre><code><span>/* 领导基类 */</span>\n<span>class</span> <span>Leader</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>nextLeader <span>=</span> <span>null</span><span>;</span>\n  <span>}</span>\n\n  <span>setNext</span><span>(</span><span>next</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>nextLeader <span>=</span> next<span>;</span>\n    <span>return</span> next<span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* 小组领导 */</span>\n<span>class</span> <span>GroupLeader</span> <span>extends</span> <span>Leader</span> <span>{</span>\n  <span>handle</span><span>(</span><span>duration</span><span>)</span> <span>{</span> <span>...</span> <span>}</span>\n<span>}</span>\n\n<span>/* 部门领导 */</span>\n<span>class</span> <span>DepartmentLeader</span> <span>extends</span> <span>Leader</span> <span>{</span>\n  <span>handle</span><span>(</span><span>duration</span><span>)</span> <span>{</span> <span>...</span> <span>}</span>\n<span>}</span>\n\n<span>/* 总经理 */</span>\n<span>class</span> <span>GeneralLeader</span> <span>extends</span> <span>Leader</span> <span>{</span>\n  <span>handle</span><span>(</span><span>duration</span><span>)</span> <span>{</span> <span>...</span> <span>}</span>\n<span>}</span>\n\n<span>const</span> zhangSan <span>=</span> <span>new</span> <span>GroupLeader</span><span>(</span><span>)</span><span>;</span>\n<span>const</span> liSi <span>=</span> <span>new</span> <span>DepartmentLeader</span><span>(</span><span>)</span><span>;</span>\n<span>const</span> wangWu <span>=</span> <span>new</span> <span>GeneralLeader</span><span>(</span><span>)</span><span>;</span>\n\n<span>/* 组装职责链 */</span>\nzhangSan\n  <span>.</span><span>setNext</span><span>(</span>liSi<span>)</span>   <span>// 设置小组领导的下一个职责节点为部门领导</span>\n  <span>.</span><span>setNext</span><span>(</span>wangWu<span>)</span> <span>// 设置部门领导的下一个职责节点为总经理</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><h2 id=\"职责链模式的原理\"> 职责链模式的原理</h2>\n<p>职责链模式可能在真实的业务代码中见的不多，但是作用域链、原型链、DOM 事件流的事件冒泡，都有职责链模式的影子：</p>\n<ul>\n<li><strong>作用域链</strong>：查找变量时，先从当前上下文的变量对象中查找，如果没有找到，就会从父级执行上下文的变量对象中查找，一直找到全局上下文的变量对象。</li>\n<li><strong>原型链</strong>：当读取实例的属性时，如果找不到，就会查找当前对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</li>\n<li><strong>事件冒泡</strong>：事件在 DOM 元素上触发后，会从最内层的元素开始发生，一直向外层元素传播，直到全局 <code>document</code> 对象。</li>\n</ul>\n<p>以事件冒泡为例，事件在某元素上触发后，会一级级往外层元素传递事件，如果当前元素没有处理这个事件并阻止冒泡，那么这个事件就会往外层节点传递，就像请求在职责链中的职责节点上传递一样，直到某个元素处理了事件并阻止冒泡。</p>\n<p>事件冒泡示意图如下：：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/event-bubble.jpg\" alt=\"事件冒泡示意图\">\n  <p style=\"text-align: center; color: #888;\">（事件冒泡示意图）</p>\n</div>\n<p>可见虽然某些设计模式我们用的不多，但其实已经默默渗入到我们的日常开发中了。</p>\n<h2 id=\"设计原则验证\"> 设计原则验证</h2>\n<ul>\n<li>发起者与各个处理者进行隔离，各个处理者之间也相互隔离</li>\n<li>符合开放封闭原则</li>\n</ul>\n<h2 id=\"职责链模式的优缺点\"> 职责链模式的优缺点</h2>\n<p>优点：</p>\n<ul>\n<li>和命令模式类似，由于处理请求的职责节点可能是职责链上的任一节点，所以请求的发送者和接受者是解耦的。</li>\n<li>通过改变链内的节点或调整节点次序，可以动态地修改责任链，符合开闭原则。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>并不能保证请求一定会被处理，有可能到最后一个节点还不能处理。</li>\n<li>调试不便，调用层次会比较深，也有可能会导致循环引用。</li>\n</ul>\n<h2 id=\"职责链模式的适用场景\"> 职责链模式的适用场景</h2>\n<ul>\n<li>需要多个对象可以处理同一个请求，具体该请求由哪个对象处理在运行时才确定。</li>\n<li>在不明确指定接收者的情况下，向多个对象中的其中一个提交请求的话，可以使用职责链模式。</li>\n<li>如果想要动态指定处理一个请求的对象集合，可以使用职责链模式。</li>\n</ul>\n<h2 id=\"其他相关模式\"> 其他相关模式</h2>\n<h3 id=\"职责链模式与组合模式\"> 职责链模式与组合模式</h3>\n<p>职责链模式可以和组合模式一起使用，比如把职责节点通过组合模式来组合，从而形成组合起来的树状职责链。</p>\n<h3 id=\"职责链模式与装饰器模式\"> 职责链模式与装饰器模式</h3>\n<p>这两个模式都是在运行期间动态组合，装饰器模式是动态组合装饰器，可以有任意多个对象来装饰功能，而职责链是动态组合职责节点，有一个职责节点处理的话就结束。</p>\n<p>另外他们的目的也不同，装饰器模式为对象添加功能，而职责链模式是要实现发送者和接收者解耦。</p>\n<p>（完）</p>\n",
      "date_published": "2022-03-29T09:35:15.000Z",
      "date_modified": "2022-03-30T05:39:08.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "装饰器模式",
      "url": "https://www.fedbook.cn/in-depth-learning/design-patterns/decorator-pattern/",
      "id": "https://www.fedbook.cn/in-depth-learning/design-patterns/decorator-pattern/",
      "content_html": "<h1 id=\"装饰器模式\"> 装饰器模式</h1>\n<h2 id=\"介绍\"> 介绍</h2>\n<p>装饰器模式（Decorator Pattern）又称装饰者模式，在不改变原对象的基础上，通过对其添加属性或方法来进行包装拓展，使得原有对象可以动态具有更多功能。</p>\n<p>本质是功能<strong>动态组合</strong>，即动态地给一个对象添加额外的职责，就增加功能角度来看，使用装饰器模式比用继承更为灵活。好处是有效地把对象的核心职责和装饰功能区分开，并且通过动态增删装饰去除目标对象中重复的装饰逻辑。</p>\n<h2 id=\"通俗的示例\"> 通俗的示例</h2>\n<p>就像给手机套上手机壳，在不影响手机本来功能的同时，套上壳子可以起到保护手机、美观装饰等作用。</p>\n<p>在类似场景中，这些例子有以下特点：</p>\n<ul>\n<li>装饰不影响原有的功能，原有功能可以照常使用。</li>\n<li>装饰可以增加多个，共同给目标对象添加额外功能。</li>\n</ul>\n<h2 id=\"装饰器模式的通用实现\"> 装饰器模式的通用实现</h2>\n<p>还是由于是在 JS 中应用，所以实现装饰器模式的时候，大可不必走 Java 那一套面向对象花里胡哨的过程（子类实现接口，子类实现接口……）</p>\n<p>结构如下：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/decorator-pattern.jpg\" alt=\"装饰器模式结构图\">\n  <p style=\"text-align: center; color: #888;\">（装饰器模式结构图）</p>\n</div>\n<p>代码如下：</p>\n<blockquote>\n<p>以下代码模拟实现了装修房子的例子，目标对象是个毛坯房，用两个装饰器（墙壁刷漆，搬入家具）去装饰它。</p>\n</blockquote>\n<div><pre><code><span>/* 毛坯房 - 目标对象 */</span>\n<span>class</span> <span>OriginHouse</span> <span>{</span>\n  <span>getDesc</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'毛坯房'</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* 墙壁刷漆 - 装饰者 */</span>\n<span>class</span> <span>Painting</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>house</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>house <span>=</span> house<span>;</span>\n  <span>}</span>\n    \n  <span>getDesc</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>house<span>.</span><span>getDesc</span><span>(</span><span>)</span><span>;</span>\n    console<span>.</span><span>log</span><span>(</span><span>'墙壁刷漆'</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* 搬入家具 - 装饰者 */</span>\n<span>class</span> <span>Furniture</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>house</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>house <span>=</span> house<span>;</span>\n  <span>}</span>\n    \n  <span>getDesc</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>house<span>.</span><span>getDesc</span><span>(</span><span>)</span><span>;</span>\n    console<span>.</span><span>log</span><span>(</span><span>'搬入家具'</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 测试</span>\n<span>let</span> house <span>=</span> <span>new</span> <span>OriginHouse</span><span>(</span><span>)</span><span>;</span>\nhouse <span>=</span> <span>new</span> <span>Furniture</span><span>(</span>house<span>)</span><span>;</span>\nhouse <span>=</span> <span>new</span> <span>Painting</span><span>(</span>house<span>)</span><span>;</span>\n\nhouse<span>.</span><span>getDesc</span><span>(</span><span>)</span>\n<span>// 输出：毛坯房  墙壁刷漆  搬入家具</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><p>在装饰器模式中，一个对象被另一个对象包装起来，形成一条包装链，并增加了原先对象的功能。和适配器模式的区别在于，适配器模式是原有的接口不能用了，所以需要一个新的；而装饰器模式是原有的还要继续用，新增的是来完善和强化的。</p>\n<div><p>值得注意的是</p>\n<p>EcmaScript 标准（ES7）中的 Decorator 提案仍然在 stage-2 且极其不稳定。过去一年内已经经历了两次彻底大改，且和 TS 现有的实现已经完全脱节。— 尤雨溪 2019.6.12</p>\n</div>\n<p>因此本文不准备对 JavaScript 的装饰器 Decorator 进行相关介绍。</p>\n<h2 id=\"装饰器模式的实际应用\"> 装饰器模式的实际应用</h2>\n<p>适配器模式在日常开发中还是比较常见的，可能你已经使用了，但因为没有学过设计模式，所以不知道这种实现方式有个叫「适配器模式」的名字。</p>\n<h3 id=\"给浏览器事件添加新功能\"> 给浏览器事件添加新功能</h3>\n<p>之前介绍的添加装饰器函数的方式，经常被用来给原有浏览器或 DOM 绑定事件上绑定新的功能，比如在 <code>onload</code> 上增加新的事件，或在原来的事件绑定函数上增加新的功能，或者在原本的操作上增加用户行为埋点：</p>\n<div><pre><code>window<span>.</span><span>onload</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'原先的 onload 事件'</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>/* 发送埋点信息 */</span>\n<span>function</span> <span>sendUserOperation</span><span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'埋点：用户当前行为路径为 ...'</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>/* 将新的功能添加到 onload 事件上 */</span>\nwindow<span>.</span><span>onload</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n  <span>let</span> originOnload <span>=</span> window<span>.</span>onload<span>;</span>\n  <span>return</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    originOnload <span>&amp;&amp;</span> <span>originOnload</span><span>(</span><span>)</span><span>;</span>\n    <span>sendUserOperation</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span><span>(</span><span>)</span>\n\n<span>// 输出：原先的 onload 事件</span>\n<span>// 输出：埋点：用户当前行为路径为 ...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>可以看到通过添加装饰函数，为 <code>onload</code> 事件回调增加新的方法，且并不影响原本的功能，我们可以把上面的方法提取出来作为一个工具方法：</p>\n<div><pre><code>window<span>.</span><span>onload</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'原先的 onload 事件'</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>/* 发送埋点信息 */</span>\n<span>function</span> <span>sendUserOperation</span><span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'埋点：用户当前行为路径为 ...'</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>/* 给原生事件添加新的装饰方法 */</span>\n<span>function</span> <span>originDecorateFn</span><span>(</span><span>originObj<span>,</span> originKey<span>,</span> fn</span><span>)</span> <span>{</span>\n  originObj<span>[</span>originKey<span>]</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    <span>let</span> originFn <span>=</span> originObj<span>[</span>originKey<span>]</span><span>;</span>\n    <span>return</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n      originFn <span>&amp;&amp;</span> <span>originFn</span><span>(</span><span>)</span><span>;</span>\n      <span>fn</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span><span>(</span><span>)</span>\n<span>}</span>\n\n<span>// 添加装饰功能</span>\n<span>originDecorateFn</span><span>(</span>window<span>,</span> <span>'onload'</span><span>,</span> sendUserOperation<span>)</span><span>;</span>\n\n<span>// 输出：原先的 onload 事件</span>\n<span>// 输出：埋点：用户当前行为路径为 ...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h3 id=\"typescript-中的装饰器\"> TypeScript 中的装饰器</h3>\n<p>TypeScript 作为 JavaScript 的超集语言，它自带的装饰器和 Java 中的注解 Annotation、Python 中的装饰器 Decorator，有着很大的相似之处。</p>\n<p>TypeScript 中的装饰器可以被附加到类声明、方法、访问符、属性和参数上，装饰器的类型有参数装饰器、方法装饰器、访问器或参数装饰器、参数装饰器。</p>\n<p>TypeScript 中的装饰器使用 <code>@expression</code> 这种形式，<code>expression</code> 求值后为一个函数，它在运行时被调用，被装饰的声明信息会被做为参数传入。</p>\n<p>多个装饰器应用使用在同一个声明上时：</p>\n<ul>\n<li>由上至下依次对装饰器表达式求值。</li>\n<li>求值的结果会被当成函数，<strong>由下至上</strong>依次调用。</li>\n</ul>\n<p>那么使用官网的一个例子：</p>\n<div><pre><code><span>function</span> <span>f</span><span>(</span><span>)</span> <span>{</span>\n  <span>console</span><span>.</span><span>log</span><span>(</span><span>\"f(): evaluated\"</span><span>)</span><span>;</span>\n  <span>return</span> <span>function</span> <span>(</span>target<span>,</span> propertyKey<span>:</span> <span>string</span><span>,</span> descriptor<span>:</span> PropertyDescriptor<span>)</span> <span>{</span>\n    <span>console</span><span>.</span><span>log</span><span>(</span><span>\"f(): called\"</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>function</span> <span>g</span><span>(</span><span>)</span> <span>{</span>\n  <span>console</span><span>.</span><span>log</span><span>(</span><span>\"g(): evaluated\"</span><span>)</span><span>;</span>\n  <span>return</span> <span>function</span> <span>(</span>target<span>,</span> propertyKey<span>:</span> <span>string</span><span>,</span> descriptor<span>:</span> PropertyDescriptor<span>)</span> <span>{</span>\n    <span>console</span><span>.</span><span>log</span><span>(</span><span>\"g(): called\"</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 测试</span>\n<span>class</span> <span><span>C</span></span> <span>{</span>\n  <span><span>@</span><span>f</span></span><span>(</span><span>)</span>\n  <span><span>@</span><span>g</span></span><span>(</span><span>)</span>\n  <span>method</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n<span>}</span>\n\n<span>// f(): evaluated</span>\n<span>// g(): evaluated</span>\n<span>// g(): called</span>\n<span>// f(): called</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>可以看到上面的代码中，高阶函数 <code>f</code> 与 <code>g</code> 返回了另一个函数（装饰器函数），所以 <code>f</code>、<code>g</code> 这里又被称为装饰器工厂，即帮助用户传递可供装饰器使用的参数的工厂。另外注意，演算的顺序是从下到上，执行的时候是从下到上的。</p>\n<h2 id=\"设计原则验证\"> 设计原则验证</h2>\n<ul>\n<li>将现有对象和装饰器进行分离，两者独立存在</li>\n<li>符合开放封闭原则</li>\n</ul>\n<h2 id=\"装饰器模式的优缺点\"> 装饰器模式的优缺点</h2>\n<p>优点：</p>\n<ul>\n<li>我们经常使用继承的方式来实现功能的扩展，但这样会给系统中带来很多的子类和复杂的继承关系，装饰者模式允许用户在不引起子类数量暴增的前提下动态地修饰对象，添加功能，<strong>装饰者和被装饰者之间松耦合</strong>，可维护性好。</li>\n<li>被装饰者可以使用装饰者<strong>动态地增加和撤销功能</strong>，可以在运行时选择不同的装饰器，实现不同的功能，灵活性好。</li>\n<li>装饰者模式把一系列复杂的功能分散到每个装饰器当中，一般一个装饰器只实现一个功能，可以给一个对象增加多个同样的装饰器，也可以把一个装饰器用来装饰不同的对象，<strong>有利于装饰器功能的复用</strong>。</li>\n<li>可以通过选择不同的装饰者的组合，<strong>创造不同行为和功能的结合体</strong>，原有对象的代码无须改变，就可以使得原有对象的功能变得更强大和更多样化，符合开闭原则。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>使用装饰者模式时会产生很多细粒度的装饰者对象，这些装饰者对象由于接口和功能的多样化导致系统复杂度增加，功能越复杂，需要的细粒度对象越多。</li>\n<li>由于更大的灵活性，也就更容易出错，特别是对于多级装饰的场景，错误定位会更加繁琐。</li>\n</ul>\n<h2 id=\"装饰器模式的适用场景\"> 装饰器模式的适用场景</h2>\n<ul>\n<li>如果不希望系统中增加很多子类，那么可以考虑使用装饰者模式。</li>\n<li>需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，这时采用装饰者模式可以很好实现。</li>\n<li>当对象的功能要求可以动态地添加，也可以动态地撤销，可以考虑使用装饰者模式。</li>\n</ul>\n<h2 id=\"其他相关模式\"> 其他相关模式</h2>\n<h3 id=\"装饰器模式与适配器模式\"> 装饰器模式与适配器模式</h3>\n<p>装饰者模式和适配器模式都是属于包装模式，然而他们的意图有些不一样：</p>\n<ul>\n<li><strong>装饰器模式</strong>：扩展功能，原有功能还可以直接使用，一般可以给目标对象多次叠加使用多个装饰者。</li>\n<li><strong>适配器模式</strong>：功能不变，但是转换了原有接口的访问格式，一般只给目标对象使用一次。</li>\n</ul>\n<h3 id=\"装饰器模式与组合模式\"> 装饰器模式与组合模式</h3>\n<p>这两个模式有相似之处，都涉及到对象的递归调用，从某个角度来说，可以把装饰器模式看做是只有一个组件的组合模式。</p>\n<ul>\n<li><strong>装饰器模式</strong>：动态地给对象增加功能。</li>\n<li><strong>组合模式</strong>：管理组合对象和叶子对象，为它们提供一致的操作接口给客户端，方便客户端的使用。</li>\n</ul>\n<h3 id=\"装饰器模式与策略模式\"> 装饰器模式与策略模式</h3>\n<p>装饰器模式和策略模式都包含有许多细粒度的功能模块，但是他们的使用思路不同：</p>\n<ul>\n<li><strong>装饰者模式</strong>：可以递归调用，使用多个功能模式，功能之间可以叠加组合使用。</li>\n<li><strong>策略模式</strong>：只有一层选择，选择某一个功能。</li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-03-24T13:58:55.000Z",
      "date_modified": "2022-04-10T10:08:25.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "命令模式",
      "url": "https://www.fedbook.cn/in-depth-learning/design-patterns/command-pattern/",
      "id": "https://www.fedbook.cn/in-depth-learning/design-patterns/command-pattern/",
      "content_html": "<h1 id=\"命令模式\"> 命令模式</h1>\n<h2 id=\"介绍\"> 介绍</h2>\n<p>命令模式（Command Pattern）又称事务模式，将请求封装成对象，将命令的发送者和接受者解耦。本质上是对<strong>方法调用的封装</strong>。</p>\n<p>通过封装方法调用，也可以做一些有意思的事，例如记录日志，或者重复使用这些封装来实现撤销（undo）、重做（redo）操作。</p>\n<h2 id=\"通俗的示例\"> 通俗的示例</h2>\n<p>比较经典的例子是餐馆订餐，客人需要向厨师发送请求，但是不知道这些厨师的联系方式，也不知道厨师炒菜的流程和步骤，一般是将客人订餐的请求封装成命令对象，也就是订单。这个订单对象可以在程序中被四处传递，就像订单可以被服务员传递到某个厨师手中，客人不需要知道是哪个厨师完成自己的订单，厨师也不需要知道是哪个客户的订单。</p>\n<p>在类似的场景中，这些例子有以下特点：</p>\n<ul>\n<li>命令的发送者和接收者解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。</li>\n<li>对命令还可以进行撤销、排队等操作，比如用户等太久不想等了撤销订单，厨师不够了将订单进行排队，等等操作。</li>\n</ul>\n<h2 id=\"命令模式的通用实现\"> 命令模式的通用实现</h2>\n<p>实现一个控制马里奥上下左右移动的小游戏。</p>\n<h3 id=\"不使用命令模式\"> 不使用命令模式</h3>\n<p>首先我们新建一个移动对象类，在以后的代码中是通用的：</p>\n<div><pre><code><span>var</span> canvas <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'my-canvas'</span><span>)</span>\n<span>var</span> CanvasWidth <span>=</span> <span>400</span>    <span>// 画布宽度</span>\n<span>var</span> CanvasHeight <span>=</span> <span>400</span>   <span>// 画布高度</span>\n<span>var</span> CanvasStep <span>=</span> <span>40</span>      <span>// 动作步长</span>\ncanvas<span>.</span>width <span>=</span> CanvasWidth\ncanvas<span>.</span>height <span>=</span> CanvasHeight\n\n<span>// 移动对象类</span>\n<span>var</span> <span>Role</span> <span>=</span> <span>function</span><span>(</span><span>x<span>,</span> y<span>,</span> imgSrc</span><span>)</span> <span>{</span>\n  <span>this</span><span>.</span>position <span>=</span> <span>{</span> x<span>,</span> y <span>}</span>\n  <span>this</span><span>.</span>canvas <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'my-canvas'</span><span>)</span>\n\n  <span>this</span><span>.</span>ctx <span>=</span> <span>this</span><span>.</span>canvas<span>.</span><span>getContext</span><span>(</span><span>'2d'</span><span>)</span>\n  <span>this</span><span>.</span>img <span>=</span> <span>new</span> <span>Image</span><span>(</span><span>)</span>\n  <span>this</span><span>.</span>img<span>.</span>style<span>.</span>width <span>=</span> CanvasStep\n  <span>this</span><span>.</span>img<span>.</span>style<span>.</span>height <span>=</span> CanvasStep\n  <span>this</span><span>.</span>img<span>.</span>src <span>=</span> imgSrc\n  <span>this</span><span>.</span>img<span>.</span><span>onload</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n    <span>this</span><span>.</span>ctx<span>.</span><span>drawImage</span><span>(</span><span>this</span><span>.</span>img<span>,</span> x<span>,</span> y<span>,</span> CanvasStep<span>,</span> CanvasStep<span>)</span>\n    <span>this</span><span>.</span><span>move</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>Role</span><span>.</span>prototype<span>.</span><span>move</span> <span>=</span> <span>function</span><span>(</span><span>x<span>,</span> y</span><span>)</span> <span>{</span>\n  <span>var</span> pos <span>=</span> <span>this</span><span>.</span>position\n  <span>this</span><span>.</span>ctx<span>.</span><span>clearRect</span><span>(</span>pos<span>.</span>x<span>,</span> pos<span>.</span>y<span>,</span> CanvasStep<span>,</span> CanvasStep<span>)</span>\n  pos<span>.</span>x <span>+=</span> x\n  pos<span>.</span>y <span>+=</span> y\n  <span>this</span><span>.</span>ctx<span>.</span><span>drawImage</span><span>(</span><span>this</span><span>.</span>img<span>,</span> pos<span>.</span>x<span>,</span> pos<span>.</span>y<span>,</span> CanvasStep<span>,</span> CanvasStep<span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>下面如果要实现操控超级玛丽，可以直接：</p>\n<div><pre><code><span>var</span> mario <span>=</span> <span>new</span> <span>Role</span><span>(</span><span>200</span><span>,</span> <span>200</span><span>,</span> <span>'https://i.loli.net/2019/08/09/sqnjmxSZBdPfNtb.jpg'</span><span>)</span>\n\n<span>// 设置按钮回调</span>\n<span>var</span> elementUp <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'up-btn'</span><span>)</span>\nelementUp<span>.</span><span>onclick</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n  mario<span>.</span><span>move</span><span>(</span><span>0</span><span>,</span> <span>-</span>CanvasStep<span>)</span>\n<span>}</span>\n\n<span>var</span> elementDown <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'down-btn'</span><span>)</span>\nelementDown<span>.</span><span>onclick</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n  mario<span>.</span><span>move</span><span>(</span><span>0</span><span>,</span> CanvasStep<span>)</span>\n<span>}</span>\n\n<span>var</span> elementLeft <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'left-btn'</span><span>)</span>\nelementLeft<span>.</span><span>onclick</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n  mario<span>.</span><span>move</span><span>(</span><span>-</span>CanvasStep<span>,</span> <span>0</span><span>)</span>\n<span>}</span>\n\n<span>var</span> elementRight <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'right-btn'</span><span>)</span>\nelementRight<span>.</span><span>onclick</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n  mario<span>.</span><span>move</span><span>(</span>CanvasStep<span>,</span> <span>0</span><span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h3 id=\"使用命令模式\"> 使用命令模式</h3>\n<p>上面的实现逻辑上没有问题，但当我们在页面上点击按钮发送操作请求时，需要向具体负责实现行为的对象发送请求操作，对应上面的例子中的 <code>mario</code>，这些对象就是操作的接受者。也就是说，操作的发送者直接持有操作的接受者，逻辑直接暴露在页面 DOM 的事件回调中，耦合较强。如果要增加新的角色，需要对 DOM 的回调函数进行改动，如果对操作行为进行修改，对应地，也需修改 DOM 回调函数。</p>\n<p>此时，我们可以引入命令模式，以便将操作的发送者和操作的接受者解耦。在这个例子中，我们将操作马里奥的行为包装成命令类，操作的发送者只需要持有对应的命令实例并执行，命令的内容是具体的行为逻辑。</p>\n<p>多说无益，直接看代码：</p>\n<div><pre><code><span>const</span> canvas <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'my-canvas'</span><span>)</span>\n<span>const</span> CanvasWidth <span>=</span> <span>400</span>    <span>// 画布宽度</span>\n<span>const</span> CanvasHeight <span>=</span> <span>400</span>   <span>// 画布高度</span>\n<span>const</span> CanvasStep <span>=</span> <span>40</span>      <span>// 动作步长</span>\ncanvas<span>.</span>width <span>=</span> CanvasWidth\ncanvas<span>.</span>height <span>=</span> CanvasHeight\n\n<span>const</span> btnUp <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'up-btn'</span><span>)</span>\n<span>const</span> btnDown <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'down-btn'</span><span>)</span>\n<span>const</span> btnLeft <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'left-btn'</span><span>)</span>\n<span>const</span> btnRight <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'right-btn'</span><span>)</span>\n\n<span>// 移动对象类</span>\n<span>class</span> <span>Role</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>x<span>,</span> y<span>,</span> imgSrc</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>x <span>=</span> x\n    <span>this</span><span>.</span>y <span>=</span> y\n    <span>this</span><span>.</span>canvas <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'my-canvas'</span><span>)</span>\n    <span>this</span><span>.</span>ctx <span>=</span> <span>this</span><span>.</span>canvas<span>.</span><span>getContext</span><span>(</span><span>'2d'</span><span>)</span>\n    <span>this</span><span>.</span>img <span>=</span> <span>new</span> <span>Image</span><span>(</span><span>)</span>\n    <span>this</span><span>.</span>img<span>.</span>style<span>.</span>width <span>=</span> CanvasStep\n    <span>this</span><span>.</span>img<span>.</span>style<span>.</span>height <span>=</span> CanvasStep\n    <span>this</span><span>.</span>img<span>.</span>src <span>=</span> imgSrc\n    <span>this</span><span>.</span>img<span>.</span><span>onload</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n      <span>this</span><span>.</span>ctx<span>.</span><span>drawImage</span><span>(</span><span>this</span><span>.</span>img<span>,</span> x<span>,</span> y<span>,</span> CanvasStep<span>,</span> CanvasStep<span>)</span>\n      <span>this</span><span>.</span><span>move</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>)</span>\n    <span>}</span>\n  <span>}</span>\n\n  <span>move</span><span>(</span><span>x<span>,</span> y</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>ctx<span>.</span><span>clearRect</span><span>(</span><span>this</span><span>.</span>x<span>,</span> <span>this</span><span>.</span>y<span>,</span> CanvasStep<span>,</span> CanvasStep<span>)</span>\n    <span>this</span><span>.</span>x <span>+=</span> x\n    <span>this</span><span>.</span>y <span>+=</span> y\n    <span>this</span><span>.</span>ctx<span>.</span><span>drawImage</span><span>(</span><span>this</span><span>.</span>img<span>,</span> <span>this</span><span>.</span>x<span>,</span> <span>this</span><span>.</span>y<span>,</span> CanvasStep<span>,</span> CanvasStep<span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 向上移动命令类</span>\n<span>class</span> <span>MoveUpCommand</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>receiver</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>receiver <span>=</span> receiver\n  <span>}</span>\n\n  <span>execute</span><span>(</span><span>role</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>receiver<span>.</span><span>move</span><span>(</span><span>0</span><span>,</span> <span>-</span>CanvasStep<span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 向下移动命令类</span>\n<span>class</span> <span>MoveDownCommand</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>receiver</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>receiver <span>=</span> receiver\n  <span>}</span>\n\n  <span>execute</span><span>(</span><span>role</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>receiver<span>.</span><span>move</span><span>(</span><span>0</span><span>,</span> CanvasStep<span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 向左移动命令类</span>\n<span>class</span> <span>MoveLeftCommand</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>receiver</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>receiver <span>=</span> receiver\n  <span>}</span>\n\n  <span>execute</span><span>(</span><span>role</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>receiver<span>.</span><span>move</span><span>(</span><span>-</span>CanvasStep<span>,</span> <span>0</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 向右移动命令类</span>\n<span>class</span> <span>MoveRightCommand</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>receiver</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>receiver <span>=</span> receiver\n  <span>}</span>\n\n  <span>execute</span><span>(</span><span>role</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>receiver<span>.</span><span>move</span><span>(</span>CanvasStep<span>,</span> <span>0</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 设置按钮命令</span>\n<span>const</span> <span>setCommand</span> <span>=</span> <span>function</span><span>(</span><span>element<span>,</span> command</span><span>)</span> <span>{</span>\n  element<span>.</span><span>onclick</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    command<span>.</span><span>execute</span><span>(</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* ----- 客户端 ----- */</span>\n<span>const</span> mario <span>=</span> <span>new</span> <span>Role</span><span>(</span><span>200</span><span>,</span> <span>200</span><span>,</span> <span>'https://i.loli.net/2019/08/09/sqnjmxSZBdPfNtb.jpg'</span><span>)</span>\n<span>const</span> moveUpCommand <span>=</span> <span>new</span> <span>MoveUpCommand</span><span>(</span>mario<span>)</span>\n<span>const</span> moveDownCommand <span>=</span> <span>new</span> <span>MoveDownCommand</span><span>(</span>mario<span>)</span>\n<span>const</span> moveLeftCommand <span>=</span> <span>new</span> <span>MoveLeftCommand</span><span>(</span>mario<span>)</span>\n<span>const</span> moveRightCommand <span>=</span> <span>new</span> <span>MoveRightCommand</span><span>(</span>mario<span>)</span>\n\n<span>setCommand</span><span>(</span>btnUp<span>,</span> moveUpCommand<span>)</span>\n<span>setCommand</span><span>(</span>btnDown<span>,</span> moveDownCommand<span>)</span>\n<span>setCommand</span><span>(</span>btnLeft<span>,</span> moveLeftCommand<span>)</span>\n<span>setCommand</span><span>(</span>btnRight<span>,</span> moveRightCommand<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br></div></div><p>我们把操作的逻辑分别提取到对应的 <code>Command</code> 类中，并约定 <code>Command</code> 类的 <code>execute</code> 方法存放命令接收者需要执行的逻辑，也就是前面例子中的 <code>onclick</code> 回调方法部分。</p>\n<p>按下操作按钮之后<strong>会发生事情</strong>这个逻辑是不变的，而<strong>具体发生什么事情</strong>的逻辑是可变的，这里我们可以提取出公共逻辑，把一定发生事情这个逻辑提取到 <code>setCommand</code> 方法中，在这里调用命令类实例的 <code>execute</code> 方法，而不同事情具体逻辑的不同体现在各个 <code>execute</code> 方法的不同实现中。</p>\n<p>至此，命令的发送者已经知道自己将会执行一个 <code>Command</code> 类实例的 <code>execute</code> 实例方法，但是具体是哪个操作类的类实例来执行，还不得而知，这时候需要调用 <code>setCommand</code> 方法来告诉命令的发送者，执行的是哪个命令。</p>\n<p>综上，一个命令模式改造后的实例就完成了，但是在 JavaScript 中，命令不一定要使用类的形式：</p>\n<div><pre><code><span>// 前面代码一致</span>\n\n<span>// 向上移动命令对象</span>\n<span>const</span> MoveUpCommand <span>=</span> <span>{</span>\n  <span>execute</span><span>(</span><span>role</span><span>)</span> <span>{</span>\n    role<span>.</span><span>move</span><span>(</span><span>0</span><span>,</span> <span>-</span>CanvasStep<span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 向下移动命令对象</span>\n<span>const</span> MoveDownCommand <span>=</span> <span>{</span>\n  <span>execute</span><span>(</span><span>role</span><span>)</span> <span>{</span>\n    role<span>.</span><span>move</span><span>(</span><span>0</span><span>,</span> CanvasStep<span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 向左移动命令对象</span>\n<span>const</span> MoveLeftCommand <span>=</span> <span>{</span>\n  <span>execute</span><span>(</span><span>role</span><span>)</span> <span>{</span>\n    role<span>.</span><span>move</span><span>(</span><span>-</span>CanvasStep<span>,</span> <span>0</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 向右移动命令对象</span>\n<span>const</span> MoveRightCommand <span>=</span> <span>{</span>\n  <span>execute</span><span>(</span><span>role</span><span>)</span> <span>{</span>\n    role<span>.</span><span>move</span><span>(</span>CanvasStep<span>,</span> <span>0</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 设置按钮命令</span>\n<span>const</span> <span>setCommand</span> <span>=</span> <span>function</span><span>(</span><span>element<span>,</span> role<span>,</span> command</span><span>)</span> <span>{</span>\n  element<span>.</span><span>onclick</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    command<span>.</span><span>execute</span><span>(</span>role<span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* ----- 客户端 ----- */</span>\n<span>const</span> mario <span>=</span> <span>new</span> <span>Role</span><span>(</span><span>200</span><span>,</span> <span>200</span><span>,</span> <span>'https://i.loli.net/2019/08/09/sqnjmxSZBdPfNtb.jpg'</span><span>)</span>\n\n<span>setCommand</span><span>(</span>btnUp<span>,</span> mario<span>,</span> MoveUpCommand<span>)</span>\n<span>setCommand</span><span>(</span>btnDown<span>,</span> mario<span>,</span> MoveDownCommand<span>)</span>\n<span>setCommand</span><span>(</span>btnLeft<span>,</span> mario<span>,</span> MoveLeftCommand<span>)</span>\n<span>setCommand</span><span>(</span>btnRight<span>,</span> mario<span>,</span> MoveRightCommand<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><h3 id=\"命令模式升级\"> 命令模式升级</h3>\n<p>可以对这个项目进行升级，记录这个角色的行动历史，并且提供一个 <code>redo</code>、<code>undo</code> 按钮，撤销和重做角色的操作，可以想象一下如果不使用命令模式，记录的 Log 将比较乱，也不容易进行操作撤销和重做。</p>\n<p>下面我们可以使用命令模式来对上面马里奥的例子进行重构，有下面几个要点：</p>\n<ul>\n<li>命令对象包含有 <code>execute</code> 方法和 <code>undo</code> 方法，前者是执行和重做时执行的方法，后者是撤销时执行的反方法。</li>\n<li>每次执行操作时将当前操作命令推入撤销命令栈，并将当前重做命令栈清空。</li>\n<li>撤销操作时，将撤销命令栈中最后推入的命令取出并执行其 <code>undo</code> 方法，且将该命令推入重做命令栈。</li>\n<li>重做命令时，将重做命令栈中最后推入的命令取出并执行其 <code>execute</code> 方法，且将其推入撤销命令栈。</li>\n</ul>\n<div><pre><code><span>// 向上移动命令对象</span>\n<span>const</span> MoveUpCommand <span>=</span> <span>{</span>\n  <span>execute</span><span>(</span><span>role</span><span>)</span> <span>{</span>\n    role<span>.</span><span>move</span><span>(</span><span>0</span><span>,</span> <span>-</span>CanvasStep<span>)</span>\n  <span>}</span><span>,</span>\n  <span>undo</span><span>(</span><span>role</span><span>)</span> <span>{</span>\n    role<span>.</span><span>move</span><span>(</span><span>0</span><span>,</span> CanvasStep<span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 向下移动命令对象</span>\n<span>const</span> MoveDownCommand <span>=</span> <span>{</span>\n  <span>execute</span><span>(</span><span>role</span><span>)</span> <span>{</span>\n    role<span>.</span><span>move</span><span>(</span><span>0</span><span>,</span> CanvasStep<span>)</span>\n  <span>}</span><span>,</span>\n  <span>undo</span><span>(</span><span>role</span><span>)</span> <span>{</span>\n    role<span>.</span><span>move</span><span>(</span><span>0</span><span>,</span> <span>-</span>CanvasStep<span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 向左移动命令对象</span>\n<span>const</span> MoveLeftCommand <span>=</span> <span>{</span>\n  <span>execute</span><span>(</span><span>role</span><span>)</span> <span>{</span>\n    role<span>.</span><span>move</span><span>(</span><span>-</span>CanvasStep<span>,</span> <span>0</span><span>)</span>\n  <span>}</span><span>,</span>\n  <span>undo</span><span>(</span><span>role</span><span>)</span> <span>{</span>\n    role<span>.</span><span>move</span><span>(</span>CanvasStep<span>,</span> <span>0</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 向右移动命令对象</span>\n<span>const</span> MoveRightCommand <span>=</span> <span>{</span>\n  <span>execute</span><span>(</span><span>role</span><span>)</span> <span>{</span>\n    role<span>.</span><span>move</span><span>(</span>CanvasStep<span>,</span> <span>0</span><span>)</span>\n  <span>}</span><span>,</span>\n  <span>undo</span><span>(</span><span>role</span><span>)</span> <span>{</span>\n    role<span>.</span><span>move</span><span>(</span><span>-</span>CanvasStep<span>,</span> <span>0</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 命令管理者</span>\n<span>const</span> CommandManager <span>=</span> <span>{</span>\n  undoStack<span>:</span> <span>[</span><span>]</span><span>,</span>   <span>// 撤销命令栈</span>\n  redoStack<span>:</span> <span>[</span><span>]</span><span>,</span>   <span>// 重做命令栈</span>\n\n  <span>executeCommand</span><span>(</span><span>role<span>,</span> command</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>redoStack<span>.</span>length <span>=</span> <span>0</span>    <span>// 每次执行清空重做命令栈</span>\n    <span>this</span><span>.</span>undoStack<span>.</span><span>push</span><span>(</span>command<span>)</span> <span>// 推入撤销命令栈</span>\n    command<span>.</span><span>execute</span><span>(</span>role<span>)</span>\n  <span>}</span><span>,</span>\n\n  <span>/* 撤销 */</span>\n  <span>undo</span><span>(</span><span>role</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>this</span><span>.</span>undoStack<span>.</span>length <span>===</span> <span>0</span><span>)</span> <span>return</span>\n    <span>const</span> lastCommand <span>=</span> <span>this</span><span>.</span>undoStack<span>.</span><span>pop</span><span>(</span><span>)</span>\n    lastCommand<span>.</span><span>undo</span><span>(</span>role<span>)</span>\n    <span>this</span><span>.</span>redoStack<span>.</span><span>push</span><span>(</span>lastCommand<span>)</span>  <span>// 放入redo栈中</span>\n  <span>}</span><span>,</span>\n\n  <span>/* 重做 */</span>\n  <span>redo</span><span>(</span><span>role</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>this</span><span>.</span>redoStack<span>.</span>length <span>===</span> <span>0</span><span>)</span> <span>return</span>\n    <span>const</span> lastCommand <span>=</span> <span>this</span><span>.</span>redoStack<span>.</span><span>pop</span><span>(</span><span>)</span>\n    lastCommand<span>.</span><span>execute</span><span>(</span>role<span>)</span>\n    <span>this</span><span>.</span>undoStack<span>.</span><span>push</span><span>(</span>lastCommand<span>)</span>  <span>// 放入undo栈中</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 设置按钮命令</span>\n<span>const</span> <span>setCommand</span> <span>=</span> <span>function</span><span>(</span><span>element<span>,</span> role<span>,</span> command</span><span>)</span> <span>{</span>\n  <span>if</span> <span>(</span><span>typeof</span> command <span>===</span> <span>'object'</span><span>)</span> <span>{</span>\n    element<span>.</span><span>onclick</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n      CommandManager<span>.</span><span>executeCommand</span><span>(</span>role<span>,</span> command<span>)</span>\n    <span>}</span>\n  <span>}</span> <span>else</span> <span>{</span>\n    element<span>.</span><span>onclick</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n      <span>command</span><span>.</span><span>call</span><span>(</span>CommandManager<span>,</span> role<span>)</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* ----- 客户端 ----- */</span>\n<span>const</span> mario <span>=</span> <span>new</span> <span>Role</span><span>(</span><span>200</span><span>,</span> <span>200</span><span>,</span> <span>'https://i.loli.net/2019/08/09/sqnjmxSZBdPfNtb.jpg'</span><span>)</span>\n\n<span>setCommand</span><span>(</span>btnUp<span>,</span> mario<span>,</span> MoveUpCommand<span>)</span>\n<span>setCommand</span><span>(</span>btnDown<span>,</span> mario<span>,</span> MoveDownCommand<span>)</span>\n<span>setCommand</span><span>(</span>btnLeft<span>,</span> mario<span>,</span> MoveLeftCommand<span>)</span>\n<span>setCommand</span><span>(</span>btnRight<span>,</span> mario<span>,</span> MoveRightCommand<span>)</span>\n\n<span>setCommand</span><span>(</span>btnUndo<span>,</span> mario<span>,</span> CommandManager<span>.</span>undo<span>)</span>\n<span>setCommand</span><span>(</span>btnRedo<span>,</span> mario<span>,</span> CommandManager<span>.</span>redo<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br></div></div><p>有了撤销和重做命令之后，做一些小游戏比如围棋、象棋，会很容易就实现悔棋、复盘等功能。</p>\n<h2 id=\"设计原则验证\"> 设计原则验证</h2>\n<ul>\n<li>命令对象与执行对象分开，解耦</li>\n<li>符合开放封闭原则</li>\n</ul>\n<h2 id=\"命令模式的优缺点\"> 命令模式的优缺点</h2>\n<p>优点：</p>\n<ul>\n<li>命令模式将调用命令的请求对象与执行该命令的接收对象解耦，因此系统的可扩展性良好，加入新的命令不影响原有逻辑，所以增加新的命令也很容易。</li>\n<li>命令对象可以被不同的请求者角色重用，方便复用。</li>\n<li>可以将命令记入日志，根据日志可以容易地实现对命令的撤销和重做。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>命令类或者命令对象随着命令的变多而膨胀，如果命令对象很多，那么使用者需要谨慎使用，以免带来不必要的系统复杂度。</li>\n</ul>\n<h2 id=\"命令模式的适用场景\"> 命令模式的适用场景</h2>\n<ul>\n<li>需要将请求调用者和请求的接收者解耦的时候。</li>\n<li>需要将请求排队、记录请求日志、撤销或重做操作时。</li>\n</ul>\n<h2 id=\"其他相关模式\"> 其他相关模式</h2>\n<h3 id=\"命令模式与职责链模式\"> 命令模式与职责链模式</h3>\n<p>命令模式和职责链模式可以结合使用，比如具体命令的执行，就可以引入职责链模式，让命令由职责链中合适的处理者执行。</p>\n<h3 id=\"命令模式与组合模式\"> 命令模式与组合模式</h3>\n<p>命令模式和组合模式可以结合使用，比如不同的命令可以使用组合模式的方法形成一个宏命令，执行完一个命令之后，再继续执行其子命令。</p>\n<h3 id=\"命令模式与工厂模式\"> 命令模式与工厂模式</h3>\n<p>命令模式与工厂模式可以结合使用，比如命令模式中的命令可以由工厂模式来提供。</p>\n<p>（完）</p>\n",
      "date_published": "2022-03-29T09:54:53.000Z",
      "date_modified": "2022-03-29T09:54:53.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "组合模式",
      "url": "https://www.fedbook.cn/in-depth-learning/design-patterns/composite-pattern/",
      "id": "https://www.fedbook.cn/in-depth-learning/design-patterns/composite-pattern/",
      "content_html": "<h1 id=\"组合模式\"> 组合模式</h1>\n<h2 id=\"介绍\"> 介绍</h2>\n<p>组合模式（Composite Pattern）又叫整体-部分模式，它允许你将对象组合成树形结构来表现整体-部分层次结构，让使用者可以以一致的方式处理组合对象以及部分对象。</p>\n<h2 id=\"通俗的示例\"> 通俗的示例</h2>\n<p>电脑里的文件目录结构，文件夹下面可以有子文件夹，也可以有文件，子文件夹下面还可以有文件夹和文件，以此类推，共同组成了一个文件树，结构如下：</p>\n<div><pre><code>Folder 1\n├── Folder 2\n│   ├── File 1.txt\n│   ├── File 2.txt\n│   └── File 3.txt\n└── Folder 3\n    ├── File 4.txt\n    ├── File 5.txt\n    └── File 6.txt\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>文件夹是树形结构的容器节点，容器节点可以继续包含其他容器节点，像树枝上还可以有其他树枝一样；也可以包含文件，不再增加新的层级，就像树的叶子一样处于末端，因此被称为叶节点。本文中，叶节点又称为叶对象，容器节点因为可以包含容器节点和非容器节点，又称为组合对象。</p>\n<p>当我们在某个文件夹下搜索某个文件的时候，通常我们希望搜索的结果包含组合对象的所有子孙对象。</p>\n<p>在类似场景中，这些例子有以下特点：</p>\n<ul>\n<li>结构呈整体-部分的树形关系，整体部分一般称为组合对象，组合对象下还可以有组合对象和叶对象。</li>\n<li>组合对象和叶对象有一致的接口和数据结构，以保证操作一致。</li>\n<li>请求从树的最顶端往下传递，如果当前处理请求的对象是叶对象，叶对象自身会对请求作出相应的处理；如果当前处理的是组合对象，则遍历其下的子节点（叶对象），将请求继续传递给这些子节点。</li>\n</ul>\n<h2 id=\"组合模式的通用实现\"> 组合模式的通用实现</h2>\n<p>我们可以使用 JavaScript 来将之前的文件夹例子实现一下。</p>\n<p>在本地一个「电影」文件夹下有两个子文件夹「漫威英雄电影」和「DC英雄电影」，分别各自有一些电影文件，我们要做的就是在这个电影文件夹里找大于 2G 的电影文件，无论是在这个文件夹下还是在子文件夹下，并输出它的文件名和文件大小。</p>\n<div><pre><code><span>/* 文件夹类 */</span>\n<span>class</span> <span>Folder</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>name<span>,</span> children</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>name <span>=</span> name\n    <span>this</span><span>.</span>children <span>=</span> children\n  <span>}</span>\n\n  <span>/* 在文件夹下增加文件或文件夹 */</span>\n  <span>add</span><span>(</span><span><span>...</span>fileOrFolder</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>children<span>.</span><span>push</span><span>(</span><span>...</span>fileOrFolder<span>)</span>\n    <span>return</span> <span>this</span>\n  <span>}</span>\n\n  <span>/* 扫描方法 */</span>\n  <span>scan</span><span>(</span><span>cb</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>children<span>.</span><span>forEach</span><span>(</span><span>child</span> <span>=></span> child<span>.</span><span>scan</span><span>(</span>cb<span>)</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* 文件类 */</span>\n<span>class</span> <span>File</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>name<span>,</span> size</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>name <span>=</span> name\n    <span>this</span><span>.</span>size <span>=</span> size\n  <span>}</span>\n\n  <span>/* 在文件下增加文件，应报错 */</span>\n  <span>add</span><span>(</span><span><span>...</span>fileOrFolder</span><span>)</span> <span>{</span>\n    <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>'文件下面不能再添加文件'</span><span>)</span>\n  <span>}</span>\n\n  <span>/* 执行扫描方法 */</span>\n  <span>scan</span><span>(</span><span>cb</span><span>)</span> <span>{</span>\n    <span>cb</span><span>(</span><span>this</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>const</span> foldMovies <span>=</span> <span>new</span> <span>Folder</span><span>(</span><span>'电影'</span><span>,</span> <span>[</span>\n  <span>new</span> <span>Folder</span><span>(</span><span>'漫威英雄电影'</span><span>,</span> <span>[</span>\n    <span>new</span> <span>File</span><span>(</span><span>'钢铁侠.mp4'</span><span>,</span> <span>1.9</span><span>)</span><span>,</span>\n    <span>new</span> <span>File</span><span>(</span><span>'蜘蛛侠.mp4'</span><span>,</span> <span>2.1</span><span>)</span><span>,</span>\n    <span>new</span> <span>File</span><span>(</span><span>'金刚狼.mp4'</span><span>,</span> <span>2.3</span><span>)</span><span>,</span>\n    <span>new</span> <span>File</span><span>(</span><span>'黑寡妇.mp4'</span><span>,</span> <span>1.9</span><span>)</span><span>,</span>\n    <span>new</span> <span>File</span><span>(</span><span>'美国队长.mp4'</span><span>,</span> <span>1.4</span><span>)</span><span>]</span><span>)</span><span>,</span>\n  <span>new</span> <span>Folder</span><span>(</span><span>'DC英雄电影'</span><span>,</span> <span>[</span>\n    <span>new</span> <span>File</span><span>(</span><span>'蝙蝠侠.mp4'</span><span>,</span> <span>2.4</span><span>)</span><span>,</span>\n    <span>new</span> <span>File</span><span>(</span><span>'超人.mp4'</span><span>,</span> <span>1.6</span><span>)</span><span>]</span><span>)</span>\n<span>]</span><span>)</span>\n\nconsole<span>.</span><span>log</span><span>(</span><span>'size 大于2G的文件有：'</span><span>)</span>\n\nfoldMovies<span>.</span><span>scan</span><span>(</span><span>item</span> <span>=></span> <span>{</span>\n  <span>if</span> <span>(</span>item<span>.</span>size <span>></span> <span>2</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span><span>`</span><span>name:</span><span><span>${</span> item<span>.</span>name <span>}</span></span><span> size:</span><span><span>${</span> item<span>.</span>size <span>}</span></span><span>GB</span><span>`</span></span><span>)</span>\n  <span>}</span>\n<span>}</span><span>)</span>\n\n<span>// size 大于2G的文件有：</span>\n<span>// name:蜘蛛侠.mp4 size:2.1GB</span>\n<span>// name:金刚狼.mp4 size:2.3GB</span>\n<span>// name:蝙蝠侠.mp4 size:2.4GB</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br></div></div><p>在传统的语言中，为了保证叶对象和组合对象的外观一致，还会让他们实现同一个抽象类或接口。</p>\n<h2 id=\"组合模式的概念\"> 组合模式的概念</h2>\n<p>组合模式定义的包含组合对象和叶对象的层次结构，叶对象可以被组合成更复杂的组合对象，而这个组合对象又可以被组合，这样不断地组合下去。</p>\n<p>在实际使用时，任何用到叶对象的地方都可以使用组合对象了。使用者可以不在意到底处理的节点是叶对象还是组合对象，也就不用写一些判断语句，让客户可以一致地使用组合结构的各节点，这就是所谓<strong>面向接口编程</strong>，从而减少耦合，便于扩展和维护。</p>\n<p>组合模式的示意图如下：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/composite-pattern.png\" alt=\"组合模式示意图\" style=\"width: 640px;\">\n  <p style=\"text-align: center; color: #888;\">（组合模式示意图）</p>\n</div>\n<h2 id=\"组合模式的实际应用\"> 组合模式的实际应用</h2>\n<p>类似于组合模式的结构其实我们经常碰到，比如浏览器的 DOM 树，从 <code>&lt;html/&gt;</code> 根节点到 <code>&lt;head/&gt;</code>、<code>&lt;body/&gt;</code>、<code>&lt;style/&gt;</code> 等节点，而 <code>&lt;body/&gt;</code> 节点又可以有 <code>&lt;div/&gt;</code>、<code>&lt;span/&gt;</code>、<code>&lt;p/&gt;</code>、<code>&lt;a/&gt;</code> 等等节点，这些节点下面还可以有节点，而且这些节点的操作方式有的也比较类似。</p>\n<p>我们可以借用上面示例代码的例子，方便地创建一个 DOM 树，由于浏览器 API 的返回值不太友好，因此我们稍微改造一下；</p>\n<div><pre><code><span>const</span> <span>createElement</span> <span>=</span> <span>(</span><span><span>{</span> tag<span>,</span> attr<span>,</span> children <span>}</span></span><span>)</span> <span>=></span> <span>{</span>\n  <span>const</span> node <span>=</span> tag\n    <span>?</span> document<span>.</span><span>createElement</span><span>(</span>tag<span>)</span>\n    <span>:</span> document<span>.</span><span>createTextNode</span><span>(</span>attr<span>.</span>text<span>)</span>\n  tag <span>&amp;&amp;</span> Object<span>.</span><span>keys</span><span>(</span>attr<span>)</span>\n    <span>.</span><span>forEach</span><span>(</span><span>key</span> <span>=></span> node<span>.</span><span>setAttribute</span><span>(</span>key<span>,</span> attr<span>[</span>key<span>]</span><span>)</span><span>)</span>\n  children <span>&amp;&amp;</span> children\n    <span>.</span><span>forEach</span><span>(</span><span>child</span> <span>=></span>\n      node<span>.</span><span>appendChild</span><span>(</span><span>createElement</span><span>.</span><span>call</span><span>(</span><span>null</span><span>,</span> child<span>)</span><span>)</span><span>)</span>\n  <span>return</span> node\n<span>}</span>\n\n<span>const</span> ulElement <span>=</span> <span>createElement</span><span>(</span><span>{</span>\n  tag<span>:</span> <span>'ul'</span><span>,</span>\n  attr<span>:</span> <span>{</span> id<span>:</span> <span>'data-list'</span> <span>}</span><span>,</span>\n  children<span>:</span> <span>[</span>\n    <span>{</span>\n      tag<span>:</span> <span>'li'</span><span>,</span>\n      attr<span>:</span> <span>{</span> <span>class</span><span>:</span> <span>'data-item'</span> <span>}</span><span>,</span>\n      children<span>:</span> <span>[</span><span>{</span> attr<span>:</span> <span>{</span> text<span>:</span> <span>'li-item 1'</span> <span>}</span> <span>}</span><span>]</span>\n    <span>}</span><span>,</span>\n    <span>{</span>\n      tag<span>:</span> <span>'li'</span><span>,</span>\n      attr<span>:</span> <span>{</span> <span>class</span><span>:</span> <span>'data-item'</span> <span>}</span><span>,</span>\n      children<span>:</span> <span>[</span><span>{</span> attr<span>:</span> <span>{</span> text<span>:</span> <span>'li-item 2'</span> <span>}</span> <span>}</span><span>]</span>\n    <span>}</span><span>,</span>\n    <span>{</span>\n      tag<span>:</span> <span>'li'</span><span>,</span>\n      attr<span>:</span> <span>{</span> <span>class</span><span>:</span> <span>'data-item'</span> <span>}</span><span>,</span>\n      children<span>:</span> <span>[</span><span>{</span> attr<span>:</span> <span>{</span> text<span>:</span> <span>'li-item 3'</span> <span>}</span> <span>}</span><span>]</span>\n    <span>}</span>\n  <span>]</span>\n<span>}</span><span>)</span>\n\n<span>// 输出：</span>\n<span>// &lt;ul id='data-list'></span>\n<span>//     &lt;li class='data-item'>li-item 1&lt;/li></span>\n<span>//     &lt;li class='data-item'>li-item 2&lt;/li></span>\n<span>//     &lt;li class='data-item'>li-item 3&lt;/li></span>\n<span>// &lt;/ul></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><p>另外，之前的代码中添加文件的方式是不是很眼熟？Vue/React 里创建元素节点的方法 <code>createElement</code> 也是类似这样使用，来组装元素节点：</p>\n<div><pre><code><span>// Vue</span>\n<span>createElement</span><span>(</span><span>'h3'</span><span>,</span> <span>{</span> <span>class</span><span>:</span> <span>'main-title'</span> <span>}</span><span>,</span> <span>[</span>\n  <span>createElement</span><span>(</span><span>'img'</span><span>,</span> <span>{</span> <span>class</span><span>:</span> <span>'avatar'</span><span>,</span> attrs<span>:</span> <span>{</span> src<span>:</span> <span>'../avatar.jpg'</span> <span>}</span> <span>}</span><span>)</span><span>,</span>\n  <span>createElement</span><span>(</span><span>'p'</span><span>,</span> <span>{</span> <span>class</span><span>:</span> <span>'user-desc'</span> <span>}</span><span>,</span> <span>'长得帅老的快，长得丑活得久'</span><span>)</span>\n<span>]</span><span>)</span>\n\n<span>// React</span>\nReact<span>.</span><span>createElement</span><span>(</span><span>'h3'</span><span>,</span> <span>{</span> className<span>:</span> <span>'user-info'</span> <span>}</span><span>,</span>\n  React<span>.</span><span>createElement</span><span>(</span><span>'img'</span><span>,</span> <span>{</span> src<span>:</span> <span>'../avatar.jpg'</span><span>,</span> className<span>:</span> <span>'avatar'</span> <span>}</span><span>)</span><span>,</span>\n  React<span>.</span><span>createElement</span><span>(</span><span>'p'</span><span>,</span> <span>{</span> className<span>:</span> <span>'user-desc'</span> <span>}</span><span>,</span> <span>'长得帅老的快，长得丑活得久'</span><span>)</span>\n<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>类似的，Vue 中的虚拟 DOM 树，也是这样的结构：</p>\n<div><pre><code><span>{</span>\n  tagName<span>:</span> <span>'ul'</span><span>,</span>   <span>// 节点标签名</span>\n  props<span>:</span> <span>{</span>         <span>// 属性</span>\n    id<span>:</span> <span>'data-list'</span>\n  <span>}</span><span>,</span>\n  children<span>:</span> <span>[</span>      <span>// 节点的子节点</span>\n    <span>{</span>\n      tagName<span>:</span> <span>'li'</span><span>,</span>\n      props<span>:</span> <span>{</span> <span>class</span><span>:</span> <span>'data-item'</span> <span>}</span><span>,</span>\n      children<span>:</span> <span>[</span><span>'li-item 1'</span><span>]</span>\n    <span>}</span><span>,</span>\n    <span>{</span>\n      tagName<span>:</span> <span>'li'</span><span>,</span>\n      props<span>:</span> <span>{</span> <span>class</span><span>:</span> <span>'data-item'</span> <span>}</span><span>,</span>\n      children<span>:</span> <span>[</span><span>'li-item 2'</span><span>]</span>\n    <span>}</span><span>,</span> <span>{</span>\n      tagName<span>:</span> <span>'li'</span><span>,</span>\n      props<span>:</span> <span>{</span> <span>class</span><span>:</span> <span>'data-item'</span> <span>}</span><span>,</span>\n      children<span>:</span> <span>[</span><span>'li-item 3'</span><span>]</span>\n    <span>}</span><span>]</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>这样的虚拟 DOM 树，会被渲染成：</p>\n<div><pre><code><span><span><span>&lt;</span>ul</span> <span>id</span><span><span>=</span><span>'</span>data-list<span>'</span></span><span>></span></span>\n  <span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>'</span>data-item<span>'</span></span><span>></span></span>li-item 1<span><span><span>&lt;/</span>li</span><span>></span></span>\n  <span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>'</span>data-item<span>'</span></span><span>></span></span>li-item 2<span><span><span>&lt;/</span>li</span><span>></span></span>\n  <span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>'</span>data-item<span>'</span></span><span>></span></span>li-item 3<span><span><span>&lt;/</span>li</span><span>></span></span>\n<span><span><span>&lt;/</span>ul</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>虚拟 DOM 树中的每个虚拟 DOM 都是 <code>VNode</code> 类的实例，因此具有基本统一的外观，在操作时对父节点和子节点的操作是一致的，这也是组合模式的思想。</p>\n<p>浏览器的 DOM 树、Vue 的虚拟 DOM 树等可以说和组织模式形似，也就是具有整体-部分的层次结构，但是在操作传递方面，没有组合模式所定义的特性。</p>\n<p>这个特性就是<strong>职责链模式</strong>的特性，组合模式天生具有职责链，当请求组合模式中的组合对象时，请求会顺着父节点往子节点传递，直到遇到可以处理这个请求的节点，也就是叶节点。</p>\n<h2 id=\"设计原则验证\"> 设计原则验证</h2>\n<ul>\n<li>将整体和单个节点的操作抽象出来</li>\n<li>符合开放封闭原则</li>\n</ul>\n<h2 id=\"组合模式的优缺点\"> 组合模式的优缺点</h2>\n<p>优点：</p>\n<ul>\n<li>由于组合对象和叶对象具有同样的接口，因此调用的是组合对象还是叶对象对使用者来说没有区别，使得使用者<strong>面向接口编程</strong>。</li>\n<li>如果想在组合模式的树中增加一个节点比较容易，在目标组合对象中添加即可，不会影响到其他对象，<strong>对扩展友好，符合开闭原则，利于维护</strong>。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>增加了系统复杂度，如果树中对象不多，则不一定需要使用。</li>\n<li>如果通过组合模式创建了太多的对象，那么这些对象可能会让系统负担不起。</li>\n</ul>\n<h2 id=\"组合模式的适用场景\"> 组合模式的适用场景</h2>\n<ul>\n<li>如果对象组织呈树形结构就可以考虑使用组合模式，特别是如果操作树中对象的方法比较类似时。</li>\n<li>使用者希望统一对待树形结构中的对象，比如用户不想写一堆 if-else 来处理树中的节点时，可以使用组合模式。</li>\n</ul>\n<h2 id=\"其他相关模式\"> 其他相关模式</h2>\n<h3 id=\"组合模式和职责链模式\"> 组合模式和职责链模式</h3>\n<p>正如前文所说，组合模式是天生实现了职责链模式的。</p>\n<ul>\n<li><strong>组合模式</strong>：请求在组合对象上传递，被深度遍历到组合对象的所有子孙叶节点具体执行。</li>\n<li><strong>职责链模式</strong>：实现请求的发送者和接受者之间的解耦，把多个接受者组合起来形成职责链，请求在链上传递，直到有接受者处理请求为止。</li>\n</ul>\n<h3 id=\"组合模式和迭代器模式\"> 组合模式和迭代器模式</h3>\n<p>组合模式可以结合迭代器模式一起使用，在遍历组合对象的叶节点的时候，可以使用迭代器模式来遍历。</p>\n<h3 id=\"组合模式和命令模式\"> 组合模式和命令模式</h3>\n<p>命令模式里有一个用法「宏命令」，宏命令就是组合模式和命令模式一起使用的结果，是组合模式组装而成。</p>\n<p>（完）</p>\n",
      "date_published": "2022-03-28T13:31:06.000Z",
      "date_modified": "2022-03-30T05:39:08.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "外观模式",
      "url": "https://www.fedbook.cn/in-depth-learning/design-patterns/facade-pattern/",
      "id": "https://www.fedbook.cn/in-depth-learning/design-patterns/facade-pattern/",
      "content_html": "<h1 id=\"外观模式\"> 外观模式</h1>\n<h2 id=\"介绍\"> 介绍</h2>\n<p>外观模式（Facade Pattern）又叫门面模式，它用于为子系统中的一组接口提供一个高层接口，使用者使用这个高层接口。外观模式让外界减少与子系统内多个模块的直接交互，从而减少耦合，让外界可以更轻松地使用子系统。本质是<strong>封装交互，简化调用</strong>。</p>\n<p>外观模式在源码中使用很多，具体可以参考后文中源码阅读部分。</p>\n<h2 id=\"通俗的示例\"> 通俗的示例</h2>\n<p>比如常见的空调、冰箱、洗衣机，内部结构都并不简单，对于我们使用者而言，理解他们内部的运行机制的门槛比较高，但是理解遥控器/控制面板上面寥寥几个按钮就相对容易的多，这就是外观模式的意义。</p>\n<p>在类似场景中，这些例子有以下特点：</p>\n<ul>\n<li>一个统一的外观为复杂的子系统提供一个简单的高层功能接口。</li>\n<li>原本访问者直接调用子系统内部模块导致的复杂引用关系，现在可以通过只访问这个统一的外观来避免。</li>\n</ul>\n<h2 id=\"外观模式的通用实现\"> 外观模式的通用实现</h2>\n<p>在外观模式中，客户端直接对接外观（Facade），通过接口去对接子接口，而子接口里封装的一系列复杂操作，则不是我们要关注的重点。</p>\n<p>结构如下：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/facade-pattern.jpg\" alt=\"外观模式结构图\" style=\"width: 640px;\">\n  <p style=\"text-align: center; color: #888;\">（外观模式结构图）</p>\n</div>\n<div><p>注意</p>\n<p>外观模式一般是作为子系统的功能出口出现，使用的时候可以在其中增加新的功能，但是不推荐这样做，因为外观应该是对已有功能的包装，不应在其中掺杂新的功能。</p>\n</div>\n<h2 id=\"外观模式的实际应用\"> 外观模式的实际应用</h2>\n<h3 id=\"函数参数重载\"> 函数参数重载</h3>\n<p>有一种情况，比如某个函数有多个参数，其中一个参数可以传递也可以不传递，你当然可以直接弄两个接口，但是使用函数参数重载的方式，可以让使用者获得更大的自由度，让两个使用上基本类似的方法获得统一的外观。</p>\n<div><pre><code><span>function</span> <span>bindEvent</span><span>(</span><span>elem<span>,</span> type<span>,</span> selector<span>,</span> fn</span><span>)</span> <span>{</span>\n  <span>if</span> <span>(</span>fn <span>===</span> <span>undefined</span><span>)</span> <span>{</span>\n    fn <span>=</span> selector<span>;</span>\n    selector <span>=</span> <span>null</span><span>;</span>\n  <span>}</span>\n  <span>// ... 剩下相关逻辑</span>\n<span>}</span>\n\n<span>bindEvent</span><span>(</span>elem<span>,</span> <span>'click'</span><span>,</span> <span>'#div1'</span><span>,</span> fn<span>)</span>\n<span>bindEvent</span><span>(</span>elem<span>,</span> <span>'click'</span><span>,</span> fn<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>上面这个绑定事件的函数中，参数 <code>selector</code> 就是可选的。</p>\n<p>这种方式在一些工具库或者框架提供的多功能方法上经常得到使用，特别是在通用 API 的<strong>某些参数可传可不传的时候</strong>。</p>\n<p>参数重载之后的函数在使用上会获得更大的自由度，而不必重新创建一个新的 API，这在 Vue、React、jQuery、Lodash 等库中使用非常频繁。</p>\n<h3 id=\"抹平浏览器兼容性问题\"> 抹平浏览器兼容性问题</h3>\n<p>外观模式经常被用于 JavaScript 的库中，封装一些接口用于兼容多浏览器，让我们可以间接调用我们封装的外观，从而屏蔽了浏览器差异，便于使用。</p>\n<p>比如经常用的兼容不同浏览器的事件绑定方法：</p>\n<div><pre><code><span>function</span> <span>addEvent</span><span>(</span><span>element<span>,</span> type<span>,</span> fn</span><span>)</span> <span>{</span>\n  <span>if</span> <span>(</span>element<span>.</span>addEventListener<span>)</span> <span>{</span>      <span>// 支持 DOM2 级事件处理方法的浏览器</span>\n    element<span>.</span><span>addEventListener</span><span>(</span>type<span>,</span> fn<span>,</span> <span>false</span><span>)</span><span>;</span>\n  <span>}</span> <span>else</span> <span>if</span> <span>(</span>element<span>.</span>attachEvent<span>)</span> <span>{</span>    <span>// 不支持 DOM2 级但支持 attachEvent</span>\n    element<span>.</span><span>attachEvent</span><span>(</span><span>'on'</span> <span>+</span> type<span>,</span> fn<span>)</span><span>;</span>\n  <span>}</span> <span>else</span> <span>{</span>\n    element<span>[</span><span>'on'</span> <span>+</span> type<span>]</span> <span>=</span> fn<span>;</span>         <span>// 都不支持的浏览器</span>\n  <span>}</span>\n<span>}</span>\n\n<span>var</span> myInput <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'myinput'</span><span>)</span><span>;</span>\n\n<span>addEvent</span><span>(</span>myInput<span>,</span> <span>'click'</span><span>,</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'绑定 click 事件'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>除了事件绑定之外，在抹平浏览器兼容性的其他问题上我们也经常使用外观模式：</p>\n<div><pre><code><span>// 移除 DOM 上的事件</span>\n<span>function</span> <span>removeEvent</span><span>(</span><span>element<span>,</span> type<span>,</span> fn</span><span>)</span> <span>{</span>\n  <span>if</span> <span>(</span>element<span>.</span>removeEventListener<span>)</span> <span>{</span>\n    element<span>.</span><span>removeEventListener</span><span>(</span>type<span>,</span> fn<span>,</span> <span>false</span><span>)</span><span>;</span>\n  <span>}</span> <span>else</span> <span>if</span> <span>(</span>element<span>.</span>detachEvent<span>)</span> <span>{</span>\n    element<span>.</span><span>detachEvent</span><span>(</span><span>'on'</span> <span>+</span> type<span>,</span> fn<span>)</span><span>;</span>\n  <span>}</span> <span>else</span> <span>{</span>\n    element<span>[</span><span>'on'</span> <span>+</span> type<span>]</span> <span>=</span> <span>null</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 获取样式</span>\n<span>function</span> <span>getStyle</span><span>(</span><span>obj<span>,</span> styleName</span><span>)</span> <span>{</span>\n  <span>if</span> <span>(</span>window<span>.</span>getComputedStyle<span>)</span> <span>{</span>\n    <span>var</span> styles <span>=</span> <span>getComputedStyle</span><span>(</span>obj<span>,</span> <span>null</span><span>)</span><span>[</span>styleName<span>]</span><span>;</span>\n  <span>}</span> <span>else</span> <span>{</span>\n    <span>var</span> styles <span>=</span> obj<span>.</span>currentStyle<span>[</span>styleName<span>]</span><span>;</span>\n  <span>}</span>\n  <span>return</span> styles<span>;</span>\n<span>}</span>\n\n<span>// 阻止默认事件</span>\n<span>var</span> <span>preventDefault</span> <span>=</span> <span>function</span><span>(</span><span>event</span><span>)</span> <span>{</span>\n  <span>if</span> <span>(</span>event<span>.</span>preventDefault<span>)</span> <span>{</span>\n    event<span>.</span><span>preventDefault</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span> <span>else</span> <span>{</span>                    <span>// IE 下</span>\n    event<span>.</span>returnValue <span>=</span> <span>false</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 阻止事件冒泡</span>\n<span>var</span> <span>cancelBubble</span> <span>=</span> <span>function</span><span>(</span><span>event</span><span>)</span> <span>{</span>\n  <span>if</span> <span>(</span>event<span>.</span>stopPropagation<span>)</span> <span>{</span>\n    event<span>.</span><span>stopPropagation</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span> <span>else</span> <span>{</span>                    <span>// IE 下</span>\n    event<span>.</span>cancelBubble <span>=</span> <span>true</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><p>通过将处理不同浏览器兼容性问题的过程封装成一个外观，我们在使用的时候可以直接使用外观方法即可，在遇到兼容性问题的时候，这个外观方法自然帮我们解决，方便又不容易出错。</p>\n<h3 id=\"vue-源码中的函数参数重载\"> Vue 源码中的函数参数重载</h3>\n<p>Vue 提供的一个创建元素的方法 <a href=\"https://cn.vuejs.org/v2/guide/render-function.html\" target=\"_blank\" rel=\"noopener noreferrer\">createElement</a> 就使用了函数参数重载，使得使用者在使用这个参数的时候很灵活：</p>\n<div><pre><code><span>export</span> <span>function</span> <span>createElement</span><span>(</span>\n  <span>context<span>,</span>\n  tag<span>,</span>\n  data<span>,</span>\n  children<span>,</span>\n  normalizationType<span>,</span>\n  alwaysNormalize</span>\n<span>)</span> <span>{</span>\n  <span>if</span> <span>(</span>Array<span>.</span><span>isArray</span><span>(</span>data<span>)</span> <span>||</span> <span>isPrimitive</span><span>(</span>data<span>)</span><span>)</span> <span>{</span>  <span>// 参数的重载</span>\n    normalizationType <span>=</span> children\n    children <span>=</span> data\n    data <span>=</span> <span>undefined</span>\n  <span>}</span>\n    \n  <span>// ...</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p><code>createElement</code> 方法里面对第三个参数 <code>data</code> 进行了判断，如果第三个参数的类型是 <code>array</code>、<code>string</code>、<code>number</code>、<code>boolean</code> 中的一种，那么说明是 <code>createElement(tag [, data], children, ...)</code> 这样的使用方式，用户传的第二个参数不是 <code>data</code>，而是 <code>children</code>。</p>\n<p><code>data</code> 这个参数是包含模板相关属性的数据对象，如果用户没有什么要设置，那这个参数自然不传，不使用函数参数重载的情况下，需要用户手动传递 <code>null</code> 或者 <code>undefined</code> 之类，参数重载之后，用户对 <code>data</code> 这个参数可传可不传，使用自由度比较大，也很方便。</p>\n<p><code>createElement</code> 方法的源码参见 Github 链接 <a href=\"https://github.com/vuejs/vue/blob/v2.6.10/src/core/vdom/create-element.js#L28-L45\" target=\"_blank\" rel=\"noopener noreferrer\">vue/src/core/vdom/create-element.js</a></p>\n<h3 id=\"lodash-源码中的函数参数重载\"> Lodash 源码中的函数参数重载</h3>\n<p>Lodash 的 range 方法的 API 为 <code>_.range([start=0], end, [step=1])</code>，这就很明显使用了参数重载，这个方法调用了一个内部函数 <code>createRange</code>：</p>\n<div><pre><code><span>function</span> <span>createRange</span><span>(</span><span>fromRight</span><span>)</span> <span>{</span>\n  <span>return</span> <span>(</span><span>start<span>,</span> end<span>,</span> step</span><span>)</span> <span>=></span> <span>{</span>\n    <span>// ...</span>\n    \n    <span>if</span> <span>(</span>end <span>===</span> <span>undefined</span><span>)</span> <span>{</span>\n      end <span>=</span> start\n      start <span>=</span> <span>0</span>\n    <span>}</span>\n    \n    <span>// ...</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>意思就是，如果没有传第二个参数，那么就把传入的第一个参数作为 <code>end</code>，并把 <code>start</code> 置为默认值。</p>\n<p><code>createRange</code> 方法的源码参见 Github 链接 <a href=\"https://github.com/lodash/lodash/blob/4.17.14-es/_createRange.js#L19\" target=\"_blank\" rel=\"noopener noreferrer\">lodash/.internal/createRange.js</a></p>\n<h3 id=\"jquery-源码中的函数参数重载\"> jQuery 源码中的函数参数重载</h3>\n<p>函数参数重载在源码中使用比较多，jQuery 中也有大量使用，比如 <code>on</code>、<code>off</code>、<code>bind</code>、<code>one</code>、<code>load</code>、<code>ajaxPrefilter</code> 等方法，这里以 <code>off</code> 方法为例，该方法在选择元素上移除一个或多个事件的事件处理函数。源码如下：</p>\n<div><pre><code><span>off</span><span>:</span> <span>function</span> <span>(</span><span>types<span>,</span> selector<span>,</span> fn</span><span>)</span> <span>{</span>\n  <span>// ...</span>\n  \n  <span>if</span> <span>(</span>selector <span>===</span> <span>false</span> <span>||</span> <span>typeof</span> selector <span>===</span> <span>'function'</span><span>)</span> <span>{</span>\n    <span>// ( types [, fn] ) 的使用方式</span>\n    fn <span>=</span> selector\n    selector <span>=</span> <span>undefined</span>\n  <span>}</span>\n  \n  <span>// ...</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>可以看到如果传入第二个参数为 <code>false</code> 或者是函数的时候，就是 <code>off(types [, fn])</code> 的使用方式。</p>\n<p><code>off</code> 方法的源码参见 Github 链接 <a href=\"https://github.com/jquery/jquery/blob/3.4.1/src/event.js#L872-L877\" target=\"_blank\" rel=\"noopener noreferrer\">jquery/src/event.js</a></p>\n<p>再比如 <code>load</code> 方法的源码：</p>\n<div><pre><code>jQuery<span>.</span>fn<span>.</span><span>load</span> <span>=</span> <span>function</span><span>(</span><span>url<span>,</span> params<span>,</span> callback</span><span>)</span> <span>{</span>\n  <span>// ...</span>\n  \n  <span>if</span> <span>(</span><span>isFunction</span><span>(</span>params<span>)</span><span>)</span> <span>{</span>\n    callback <span>=</span> params\n    params <span>=</span> <span>undefined</span>\n  <span>}</span>\n  \n  <span>// ...</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>可以看到 jQuery 对第二个参数进行了判断，如果是函数，就是 <code>load(url [, callback])</code> 的使用方式。</p>\n<p><code>load</code> 方法的源码参见 Github 链接 <a href=\"https://github.com/jquery/jquery/blob/3.4.1/src/ajax/load.js#L28-L35\" target=\"_blank\" rel=\"noopener noreferrer\">jquery/src/ajax/load.js</a></p>\n<h3 id=\"jquery-源码中的外观模式\"> jQuery 源码中的外观模式</h3>\n<p>当我们使用 jQuery 的 <code>$(document).ready(...)</code> 来给浏览器加载事件添加回调时，jQuery 会使用源码中的 <code>bindReady</code> 方法：</p>\n<div><pre><code><span>bindReady</span><span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n  <span>// ...</span>\n    \n  <span>// Mozilla, Opera and webkit 支持</span>\n  <span>if</span> <span>(</span>document<span>.</span>addEventListener<span>)</span> <span>{</span>\n    document<span>.</span><span>addEventListener</span><span>(</span><span>'DOMContentLoaded'</span><span>,</span> DOMContentLoaded<span>,</span> <span>false</span><span>)</span>\n        \n    <span>// A fallback to window.onload, that will always work</span>\n    window<span>.</span><span>addEventListener</span><span>(</span><span>'load'</span><span>,</span> jQuery<span>.</span>ready<span>,</span> <span>false</span><span>)</span>\n        \n    <span>// 如果使用了 IE 的事件绑定形式</span>\n  <span>}</span> <span>else</span> <span>if</span> <span>(</span>document<span>.</span>attachEvent<span>)</span> <span>{</span>\n    document<span>.</span><span>attachEvent</span><span>(</span><span>'onreadystatechange'</span><span>,</span> DOMContentLoaded<span>)</span>\n        \n    <span>// A fallback to window.onload, that will always work</span>\n    window<span>.</span><span>attachEvent</span><span>(</span><span>'onload'</span><span>,</span> jQuery<span>.</span>ready<span>)</span>\n  <span>}</span>\n    \n  <span>// ...</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>通过这个方法，jQuery 帮我们将不同浏览器下的不同绑定形式隐藏起来，从而简化了使用。</p>\n<p><code>bindReady</code> 方法的源码参见 Github 链接 <a href=\"https://github.com/jquery/jquery/blob/1.6.2/src/core.js#L424-L467\" target=\"_blank\" rel=\"noopener noreferrer\">jquery/src/core.js</a></p>\n<p>除了屏蔽浏览器兼容性问题之外，jQuery 还有其他的一些其他外观模式的应用：</p>\n<p>比如修改 css 的时候可以 <code>$('p').css('color', 'red')</code>，也可以 <code>$('p').css('width', 100)</code>，对不同样式的操作被封装到同一个外观方法中，极大地方便了使用，对不同样式的特殊处理（比如设置 <code>width</code> 的时候不用加 <code>px</code>）也一同被封装了起来。</p>\n<p>源码参见 Github 链接 <a href=\"https://github.com/jquery/jquery/blob/3.4.1/src/css.js#L230\" target=\"_blank\" rel=\"noopener noreferrer\">jquery/src/css.js</a></p>\n<p>再比如 jQuery 的 ajax 的 API <code>$.ajax(url [, settings])</code>，当我们在设置以 JSONP 的形式发送请求的时候，只要传入 <code>dataType: 'jsonp'</code> 设置，jQuery 会进行一些额外操作帮我们启动 JSONP 流程，并不需要使用者手动添加代码，这些都被封装在 <code>$.ajax()</code> 这个外观方法中了。</p>\n<p>源码参见 Github 链接 <a href=\"https://github.com/jquery/jquery/blob/3.4.1/src/ajax/jsonp.js\" target=\"_blank\" rel=\"noopener noreferrer\">jquery/src/ajax/jsonp.js</a></p>\n<h3 id=\"axios-源码中的外观模式\"> Axios 源码中的外观模式</h3>\n<p>Axios 可以使用在不同环境中，那么在不同环境中发送 HTTP 请求的时候会使用不同环境中的特有模块，Axios 这里是使用外观模式来解决这个问题的：</p>\n<div><pre><code><span>function</span> <span>getDefaultAdapter</span><span>(</span><span>)</span> <span>{</span>\n  <span>// ...</span>\n\n  <span>if</span> <span>(</span><span>typeof</span> process <span>!==</span> <span>'undefined'</span> <span>&amp;&amp;</span> <span>Object</span><span>.</span>prototype<span>.</span><span>toString</span><span>.</span><span>call</span><span>(</span>process<span>)</span> <span>===</span> <span>'[object process]'</span><span>)</span> <span>{</span>\n    <span>// Nodejs 中使用 HTTP adapter</span>\n    adapter <span>=</span> <span>require</span><span>(</span><span>'./adapters/http'</span><span>)</span><span>;</span>\n  <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>typeof</span> XMLHttpRequest <span>!==</span> <span>'undefined'</span><span>)</span> <span>{</span>\n    <span>// 浏览器使用 XHR adapter</span>\n    adapter <span>=</span> <span>require</span><span>(</span><span>'./adapters/xhr'</span><span>)</span><span>;</span>\n  <span>}</span>\n  \n  <span>// ...</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>这个方法进行了一个判断，如果在 Nodejs 的环境中则使用 Nodejs 的 <code>HTTP</code> 模块来发送请求，在浏览器环境中则使用 <code>XMLHTTPRequest</code> 这个浏览器 API。</p>\n<p><code>getDefaultAdapter</code> 方法源码参见 Github 链接 <a href=\"https://github.com/axios/axios/blob/v0.19.0/lib/defaults.js#L16-L27\" target=\"_blank\" rel=\"noopener noreferrer\">axios/lib/defaults.js</a></p>\n<h2 id=\"设计原则验证\"> 设计原则验证</h2>\n<ul>\n<li>不符合单一职责原则和开放封闭原则，因此谨慎使用，不可滥用</li>\n</ul>\n<h2 id=\"外观模式的优缺点\"> 外观模式的优缺点</h2>\n<p>优点：</p>\n<ul>\n<li>访问者不需要再了解子系统内部模块的功能，而只需和外观交互即可，使得访问者对子系统的<strong>使用变得简单</strong>，符合最少知识原则，增强了可移植性和可读性。</li>\n<li>减少了与子系统模块的直接引用，实现了<strong>访问者与子系统中模块之间的松耦合</strong>，增加了可维护性和可扩展性。</li>\n<li>通过合理使用外观模式，可以帮助我们<strong>更好地划分系统访问层次</strong>，比如把需要暴露给外部的功能集中到外观中，这样既方便访问者使用，也很好地隐藏了内部的细节，提升了安全性。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>不符合开闭原则，对修改关闭，对扩展开放，如果外观模块出错，那么只能通过修改的方式来解决问题，因为外观模块是子系统的唯一出口。</li>\n<li>不需要或不合理的使用外观会让人迷惑，过犹不及。</li>\n</ul>\n<h2 id=\"外观模式的适用场景\"> 外观模式的适用场景</h2>\n<ul>\n<li>维护设计粗糙和难以理解的遗留系统，或者系统非常复杂的时候，可以为这些系统设置外观模块，给外界提供清晰的接口，以后新系统只需与外观交互即可。</li>\n<li>你写了若干小模块，可以完成某个大功能，但日后常用的是大功能，可以使用外观来提供大功能，因为外界也不需要了解小模块的功能。</li>\n<li>团队协作时，可以给各自负责的模块建立合适的外观，以简化使用，节约沟通时间。</li>\n<li>如果构建多层系统，可以使用外观模式来将系统分层，让外观模块成为每层的入口，简化层间调用，松散层间耦合。</li>\n</ul>\n<h2 id=\"其他相关模式\"> 其他相关模式</h2>\n<h3 id=\"外观模式与中介者模式\"> 外观模式与中介者模式</h3>\n<ul>\n<li><strong>外观模式</strong>：封装子使用者对子系统内模块的直接交互，方便使用者对子系统的调用。</li>\n<li><strong>中介者模式</strong>：封装子系统间各模块之间的直接交互，松散模块间的耦合。</li>\n</ul>\n<h3 id=\"外观模式与单例模式\"> 外观模式与单例模式</h3>\n<p>有时候一个系统只需要一个外观，比如之前举的 Axios 的 HTTP 模块例子。这时我们可以将外观模式和单例模式一起使用，把外观实现为单例。</p>\n<p>（完）</p>\n",
      "date_published": "2022-03-26T06:53:54.000Z",
      "date_modified": "2022-03-26T06:53:54.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "工厂模式",
      "url": "https://www.fedbook.cn/in-depth-learning/design-patterns/factory-pattern/",
      "id": "https://www.fedbook.cn/in-depth-learning/design-patterns/factory-pattern/",
      "content_html": "<h1 id=\"工厂模式\"> 工厂模式</h1>\n<blockquote>\n<p>此处介绍的工厂模式是基于前端场景下的设计模式应用，因此会与传统的设计模式有所区别，主要体现在过程会更简化。</p>\n</blockquote>\n<h2 id=\"介绍\"> 介绍</h2>\n<p>工厂模式（Factory Pattern），根据不同的输入返回不同类的实例，一般用来创建同一类对象。工厂方式的主要思想是<strong>将对象的创建与对象的实现分离</strong>。</p>\n<h2 id=\"通俗的示例\"> 通俗的示例</h2>\n<ul>\n<li>我们去 KFC 购买汉堡，只需直接点餐、取餐，不用自己亲手做</li>\n<li>KFC 要「封装」做汉堡的工作，做好直接给购买者</li>\n</ul>\n<p>在类似场景中，这些例子有以下特点：</p>\n<ul>\n<li>访问者只需要知道产品名，就可以从工厂获得对应实例。</li>\n<li>访问者不关心实例创建过程。</li>\n</ul>\n<h2 id=\"工厂模式的通用实现\"> 工厂模式的通用实现</h2>\n<p>传统的工厂模式比较复杂，因为像 Java 等语言中有「接口」的概念。但 JS 中没有接口，即使可以用再加一层父类的形式来代替接口，但「用不同的子类继承父类，从而实现不同子类」的场景比较少，所以我们可以提炼一下工厂模式：</p>\n<p>如果我们希望获得产品，通过工厂类就可以拿到产品实例，不用关注产品实例创建流程。主要有下面几个概念：</p>\n<ul>\n<li><strong>Factory</strong>：工厂，负责返回产品实例。</li>\n<li><strong>Product</strong>：产品，访问者从工厂拿到产品实例。</li>\n</ul>\n<p>结构如下：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/factory-pattern.jpg\" alt=\"简易工厂模式结构图\" style=\"width: 640px;\">\n  <p style=\"text-align: center; color: #888;\">（简易工厂模式结构图）</p>\n</div>\n<p>代码如下：</p>\n<blockquote>\n<p>以下代码中的 <code>init</code>、<code>func1</code>、<code>func2</code> 都是用来处理业务逻辑的代码，不是工厂模式相关的逻辑，实际使用中看情况进行修改。</p>\n</blockquote>\n<div><pre><code><span>/* 工厂类 */</span>\n<span>class</span> <span>Factory</span> <span>{</span>\n  <span>static</span> <span>create</span><span>(</span><span>type</span><span>)</span> <span>{</span>\n    <span>switch</span> <span>(</span>type<span>)</span> <span>{</span>\n      <span>case</span> <span>'Product1'</span><span>:</span>\n        <span>return</span> <span>new</span> <span>Product1</span><span>(</span><span>)</span><span>;</span>\n      <span>case</span> <span>'Product2'</span><span>:</span>\n        <span>return</span> <span>new</span> <span>Product2</span><span>(</span><span>)</span><span>;</span>\n      <span>default</span><span>:</span>\n        <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>'当前没有这个产品'</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* 产品类 1 */</span>\n<span>class</span> <span>Product1</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>type <span>=</span> <span>'Product1'</span><span>;</span>\n  <span>}</span>\n  <span>init</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'init'</span><span>)</span><span>;</span>\n  <span>}</span>\n  <span>func1</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'func1'</span><span>)</span><span>;</span>\n  <span>}</span>\n  <span>func2</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'func2'</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* 产品类 2 */</span>\n<span>class</span> <span>Product2</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>type <span>=</span> <span>'Product2'</span><span>;</span>\n  <span>}</span>\n  <span>init</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'init'</span><span>)</span><span>;</span>\n  <span>}</span>\n  <span>func1</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'func1'</span><span>)</span><span>;</span>\n  <span>}</span>\n  <span>func2</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'func2'</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 测试</span>\n<span>let</span> p1 <span>=</span> Factory<span>.</span><span>create</span><span>(</span><span>'Product1'</span><span>)</span><span>;</span>\np1<span>.</span><span>init</span><span>(</span><span>)</span><span>;</span>\n<span>let</span> p3 <span>=</span> Factory<span>.</span><span>create</span><span>(</span><span>'Product3'</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div><p>这样就完成了一个工厂模式，但是这个实现有一个问题：工厂中会包含很多与创建产品相关的过程，如果产品种类很多的话，这个工厂中就会罗列很多产品的创建逻辑，每次新增或删除产品种类，不仅要增加产品类，还需要对应地去修改工厂中的方法，违反了开闭原则，也导致这个工厂类变得臃肿、高耦合。</p>\n<p>严格上这种实现在面向对象语言中叫做<strong>简单工厂模式</strong>。适用于产品种类比较少，创建逻辑不复杂的时候使用。</p>\n<p>工厂模式的本意是将实际创建对象的过程推迟到子类中，一般用抽象类来作为父类，创建过程由抽象类的子类来具体实现。JavaScript 中没有抽象类（或者 Java 中的接口），所以我们可以简单地将工厂模式看做是一个实例化对象的工厂类即可。</p>\n<h2 id=\"工厂模式的实际应用\"> 工厂模式的实际应用</h2>\n<h3 id=\"vue-react-源码中的工厂模式\"> Vue/React 源码中的工厂模式</h3>\n<p>和原生的 <code>document.createElement</code> 类似，Vue 和 React 这种具有虚拟 DOM 树（Virtual Dom Tree）机制的框架在生成虚拟 DOM 的时候，都提供了 <code>createElement</code> 方法用来生成 VNode，用来作为真实 DOM 节点的映射：</p>\n<div><pre><code><span>// Vue</span>\n<span>createElement</span><span>(</span><span>'h3'</span><span>,</span> <span>{</span> <span>class</span><span>:</span> <span>'main-title'</span> <span>}</span><span>,</span> <span>[</span>\n  <span>createElement</span><span>(</span><span>'img'</span><span>,</span> <span>{</span> <span>class</span><span>:</span> <span>'avatar'</span><span>,</span> attrs<span>:</span> <span>{</span> src<span>:</span> <span>'../avatar.jpg'</span> <span>}</span> <span>}</span><span>)</span><span>,</span>\n  <span>createElement</span><span>(</span><span>'p'</span><span>,</span> <span>{</span> <span>class</span><span>:</span> <span>'user-desc'</span> <span>}</span><span>,</span> <span>'放弃不难，但坚持一定很酷'</span><span>)</span>\n<span>]</span><span>)</span>\n\n<span>// React</span>\nReact<span>.</span><span>createElement</span><span>(</span><span>'h3'</span><span>,</span> <span>{</span> className<span>:</span> <span>'user-info'</span> <span>}</span><span>,</span>\n  React<span>.</span><span>createElement</span><span>(</span><span>'img'</span><span>,</span> <span>{</span> src<span>:</span> <span>'../avatar.jpg'</span><span>,</span> className<span>:</span> <span>'avatar'</span> <span>}</span><span>)</span><span>,</span>\n  React<span>.</span><span>createElement</span><span>(</span><span>'p'</span><span>,</span> <span>{</span> className<span>:</span> <span>'user-desc'</span> <span>}</span><span>,</span> <span>'放弃不难，但坚持一定很酷'</span><span>)</span>\n<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><code>createElement</code> 函数结构大概如下：</p>\n<div><pre><code><span>class</span> <span>Vnode</span> <span>(</span>tag<span>,</span> data<span>,</span> children<span>)</span> <span>{</span> <span>...</span> <span>}</span>\n\n<span>function</span> <span>createElement</span><span>(</span><span>tag<span>,</span> data<span>,</span> children</span><span>)</span> <span>{</span>\n  <span>return</span> <span>new</span> <span>Vnode</span><span>(</span>tag<span>,</span> data<span>,</span> children<span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>可以看到 <code>createElement</code> 函数内会进行 VNode 的具体创建，创建的过程是很复杂的，而框架提供的 <code>createElement</code> 工厂方法封装了复杂的创建与验证过程，对于使用者来说就很方便了。</p>\n<h3 id=\"vue-router-源码中的工厂模式\"> vue-router 源码中的工厂模式</h3>\n<p>工厂模式在源码中应用频繁，以 vue-router 中的源码为例，代码位置：<a href=\"https://github.com/vuejs/vue-router/blob/v3.0.6/src/index.js\" target=\"_blank\" rel=\"noopener noreferrer\">vue-router/src/index.js</a></p>\n<div><pre><code><span>// src/index.js</span>\n<span>export</span> <span>default</span> <span>class</span> <span>VueRouter</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>options</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>mode <span>=</span> mode\t<span>// 路由模式</span>\n        \n    <span>switch</span> <span>(</span>mode<span>)</span> <span>{</span>     <span>// 简单工厂</span>\n      <span>case</span> <span>'history'</span><span>:</span>   <span>// history 方式</span>\n        <span>this</span><span>.</span>history <span>=</span> <span>new</span> <span>HTML5History</span><span>(</span><span>this</span><span>,</span> options<span>.</span>base<span>)</span>\n        <span>break</span>\n      <span>case</span> <span>'hash'</span><span>:</span>      <span>// hash 方式</span>\n        <span>this</span><span>.</span>history <span>=</span> <span>new</span> <span>HashHistory</span><span>(</span><span>this</span><span>,</span> options<span>.</span>base<span>,</span> <span>this</span><span>.</span>fallback<span>)</span>\n        <span>break</span>\n      <span>case</span> <span>'abstract'</span><span>:</span>  <span>// abstract 方式</span>\n        <span>this</span><span>.</span>history <span>=</span> <span>new</span> <span>AbstractHistory</span><span>(</span><span>this</span><span>,</span> options<span>.</span>base<span>)</span>\n        <span>break</span>\n      <span>default</span><span>:</span>\n        <span>// ... 初始化失败报错</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>稍微解释一下这里的源码。<code>mode</code> 是路由创建的模式，这里有三种 History、Hash、Abstract，前两种我们已经很熟悉了，History 是 H5 的路由方式，Hash 是路由中带 <code>#</code> 的路由方式，Abstract 代表非浏览器环境中路由方式，比如 Node、weex 等；<code>this.history</code> 用来保存路由实例，vue-router 中使用了工厂模式的思想来获得响应路由控制类的实例。</p>\n<p>源码里没有把工厂方法的产品创建流程封装出来，而是直接将产品实例的创建流程暴露在 <code>VueRouter</code> 的构造函数中，在被 <code>new</code> 的时候创建对应产品实例，相当于 <code>VueRouter</code> 的构造函数就是一个工厂方法。</p>\n<p>如果一个系统不是 SPA （Single Page Application，单页应用），而是是 MPA（Multi Page Application，多页应用），那么就需要创建多个 <code>VueRouter</code> 的实例，此时 <code>VueRouter</code> 的构造函数也就是工厂方法将会被多次执行，以分别获得不同实例。</p>\n<h2 id=\"设计原则验证\"> 设计原则验证</h2>\n<ul>\n<li>构造函数和创建者分离</li>\n<li>符合开放封闭原则</li>\n</ul>\n<h2 id=\"工厂模式的优缺点\"> 工厂模式的优缺点</h2>\n<p>优点：</p>\n<ul>\n<li>良好的封装，代码结构清晰，<strong>访问者无需知道对象的创建流程</strong>，特别是创建比较复杂的情况下。</li>\n<li>扩展性优良，通过工厂方法隔离了用户和创建流程隔离，<strong>符合开放封闭原则</strong>。</li>\n<li>解耦了高层逻辑和底层产品类，<strong>符合最少知识原则</strong>，不需要的就不要去交流。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>带来了<strong>额外的系统复杂度</strong>，增加了抽象性。</li>\n</ul>\n<h2 id=\"工厂模式的适用场景\"> 工厂模式的适用场景</h2>\n<p>那在什么时候使用工厂模式呢：</p>\n<ul>\n<li>对象的创建比较复杂，而访问者无需知道创建的具体流程。</li>\n<li>处理大量具有相同属性的小对象。</li>\n</ul>\n<p>什么时候不该用工厂模式：滥用只是增加了不必要的系统复杂度，过犹不及。</p>\n<p>（完）</p>\n",
      "date_published": "2022-03-19T14:35:22.000Z",
      "date_modified": "2022-03-24T13:58:55.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "迭代器模式",
      "url": "https://www.fedbook.cn/in-depth-learning/design-patterns/iterator-pattern/",
      "id": "https://www.fedbook.cn/in-depth-learning/design-patterns/iterator-pattern/",
      "content_html": "<h1 id=\"迭代器模式\"> 迭代器模式</h1>\n<h2 id=\"介绍\"> 介绍</h2>\n<p>迭代器模式（Iterator Pattern）用于顺序地访问聚合对象内部的元素，又无需知道对象内部结构。使用了迭代器之后，使用者不需要关心对象的内部构造，就可以按序访问其中的每个元素。</p>\n<h2 id=\"通俗的示例\"> 通俗的示例</h2>\n<p>银行里的点钞机就是一个迭代器，放入点钞机的钞票里有不同版次的人民币，每张钞票的冠字号也不一样，但当一沓钞票被放入点钞机中，使用者并不关心这些差别，只关心钞票的数量，以及是否有假币。</p>\n<p>JavaScript 已经内置了迭代器的实现，在某些个很古老的语言中，使用者可能会为了实现迭代器而烦恼，但是在 JavaScript 中则完全不用担心。</p>\n<h2 id=\"js-中迭代器的实现\"> JS 中迭代器的实现</h2>\n<p>用 <code>forEach</code> 的方式来模拟点钞机：</p>\n<div><pre><code><span>var</span> bills <span>=</span> <span>[</span><span>'MCK013840031'</span><span>,</span> <span>'MCK013840032'</span><span>,</span> <span>'MCK013840033'</span><span>,</span> <span>'MCK013840034'</span><span>,</span> <span>'MCK013840035'</span><span>]</span>\n\nbills<span>.</span><span>forEach</span><span>(</span><span>function</span><span>(</span><span>bill</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'当前钞票的冠字号为 '</span> <span>+</span> bill<span>)</span><span>;</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这里的 <code>forEach</code> 方法是在 IE9 之后才原生提供的，那么在 IE9 之前的时代里，如何实现一个迭代器呢，我们可以使用 <code>for</code> 循环自己实现一个 <code>forEach</code>：</p>\n<div><pre><code><span>var</span> <span>forEach</span> <span>=</span> <span>function</span><span>(</span><span>arr<span>,</span> cb</span><span>)</span> <span>{</span>\n  <span>for</span> <span>(</span><span>var</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n    <span>cb</span><span>.</span><span>call</span><span>(</span>arr<span>[</span>i<span>]</span><span>,</span> arr<span>[</span>i<span>]</span><span>,</span> i<span>,</span> arr<span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>forEach</span><span>(</span><span>[</span><span>'hello'</span><span>,</span> <span>'world'</span><span>,</span> <span>'!'</span><span>]</span><span>,</span> <span>function</span><span>(</span><span>currValue<span>,</span> idx<span>,</span> arr</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'当前值 '</span> <span>+</span> currValue <span>+</span> <span>'，索引为 '</span> <span>+</span> idx<span>)</span>\n<span>}</span><span>)</span>\n\n<span>// 输出： 当前值 hello，索引为 0</span>\n<span>// 输出： 当前值 world，索引为 1</span>\n<span>// 输出： 当前值 !    ，索引为 2</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id=\"jquery-源码中迭代器实现\"> jQuery 源码中迭代器实现</h3>\n<p>jQuery 也提供了一个 <code>$.each</code> 的遍历方法：</p>\n<div><pre><code><span>// jquery 源码  /src/core.js#L246-L265</span>\n<span>each</span><span>:</span> <span>function</span> <span>(</span><span>obj<span>,</span> callback</span><span>)</span> <span>{</span>\n  <span>var</span> i <span>=</span> <span>0</span>\n\n  <span>// obj 为数组时</span>\n  <span>if</span> <span>(</span><span>isArrayLike</span><span>(</span>obj<span>)</span><span>)</span> <span>{</span>\n    <span>for</span> <span>(</span><span>;</span> i <span>&lt;</span> obj<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n      <span>if</span> <span>(</span><span>callback</span><span>.</span><span>call</span><span>(</span>obj<span>[</span>i<span>]</span><span>,</span> i<span>,</span> obj<span>[</span>i<span>]</span><span>)</span> <span>===</span> <span>false</span><span>)</span> <span>{</span>\n        <span>break</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span>\n\n  <span>// obj 为对象时</span>\n  <span>else</span> <span>{</span>\n    <span>for</span> <span>(</span>i <span>in</span> obj<span>)</span> <span>{</span>\n      <span>if</span> <span>(</span><span>callback</span><span>.</span><span>call</span><span>(</span>obj<span>[</span>i<span>]</span><span>,</span> i<span>,</span> obj<span>[</span>i<span>]</span><span>)</span> <span>===</span> <span>false</span><span>)</span> <span>{</span>\n        <span>break</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span>\n\n  <span>return</span> obj\n<span>}</span>\n\n<span>// 使用</span>\n$<span>.</span><span>each</span><span>(</span><span>[</span><span>'hello'</span><span>,</span> <span>'world'</span><span>,</span> <span>'!'</span><span>]</span><span>,</span> <span>function</span><span>(</span><span>idx<span>,</span> currValue</span><span>)</span><span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'当前值 '</span> <span>+</span> currValue <span>+</span> <span>'，索引为 '</span> <span>+</span> idx<span>)</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>这里的源码分为两个部分，前一个部分是形参 <code>obj</code> 为数组情况下的处理，使用 <code>for</code> 循环，以数组下标依次使用 <code>call/apply</code> 传入回调中执行，第二部分是形参 <code>obj</code> 为对象情况下的处理，是使用 <code>for-in</code> 循环来获取对象上的属性。另外可以看到如果 <code>callback.call</code> 返回的结果是 <code>false</code> 的话，这个循环会被 <code>break</code>。</p>\n<p>源码位于：<a href=\"https://github.com/jquery/jquery/blob/3.4.1/src/core.js#L246-L265\" target=\"_blank\" rel=\"noopener noreferrer\">jquery/src/core.js</a></p>\n<p>由于处理对象时使用的是 <code>for-in</code>，所以原型上的变量也会被遍历出来：</p>\n<div><pre><code><span>var</span> foo <span>=</span> <span>{</span> paramProto<span>:</span> <span>'原型上的变量'</span> <span>}</span>\n\n<span>var</span> bar <span>=</span> Object<span>.</span><span>create</span><span>(</span>foo<span>,</span> <span>{</span>\n  paramPrivate<span>:</span> <span>{</span>\n    configurable<span>:</span> <span>true</span><span>,</span>\n    enumerable<span>:</span> <span>true</span><span>,</span>\n    value<span>:</span> <span>'自有属性'</span><span>,</span>\n    writable<span>:</span> <span>true</span>\n  <span>}</span>\n<span>}</span><span>)</span>\n\n$<span>.</span><span>each</span><span>(</span>bar<span>,</span> <span>function</span><span>(</span><span>key<span>,</span> currValue</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'当前值为 「'</span> <span>+</span> currValue <span>+</span> <span>'」，键为 '</span> <span>+</span> key<span>)</span>\n<span>}</span><span>)</span>\n\n<span>// 输出： 当前值为 「自有属性」   ，键为 paramPrivate</span>\n<span>// 输出： 当前值为 「原型上的属性」，键为 paramProto</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>因此可以使用 <code>hasOwnProperty</code> 来判断键是否是在原型链上还是对象的自有属性。</p>\n<p>我们还可以利用如果 <code>callback.call</code> 返回的结果是 <code>false</code> 则 <code>break</code> 的特点，来进行一些操作：</p>\n<div><pre><code>$<span>.</span><span>each</span><span>(</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>]</span><span>,</span> <span>function</span><span>(</span><span>idx<span>,</span> currValue</span><span>)</span> <span>{</span>\n  <span>if</span> <span>(</span>currValue <span>></span> <span>3</span><span>)</span>\n    <span>return</span> <span>false</span>\n  console<span>.</span><span>log</span><span>(</span><span>'当前值为 '</span> <span>+</span> currValue<span>)</span>\n<span>}</span><span>)</span>\n\n<span>// 输出：  当前值为 1</span>\n<span>// 输出：  当前值为 2</span>\n<span>// 输出：  当前值为 3</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"javascript-原生支持\"> JavaScript 原生支持</h3>\n<p>随着 JavaScript 的 ECMAScript 标准每年的发展，给越来越多好用的 API 提供了支持，比如 Array 上的 <code>filter</code>、<code>forEach</code>、<code>reduce</code>、<code>flat</code> 等，还有 Map、Set、String 等数据结构，也提供了原生的迭代器支持，给我们的开发提供了很多便利，也让 underscore 这些工具库渐渐淡出历史舞台。</p>\n<p>另外，JavaScript 中还有很多类数组结构，比如：</p>\n<ul>\n<li><code>arguments</code>：函数接受的所有参数构成的类数组对象。</li>\n<li><code>NodeList</code>：是 <code>querySelector</code> 接口族返回的数据结构。</li>\n<li><code>HTMLCollection</code>：是 <code>getElementsBy</code> 接口族返回的数据结构。</li>\n</ul>\n<p>对于这些类数组结构，我们可以通过一些方式来转换成普通数组结构，以 <code>arguments</code> 为例：</p>\n<div><pre><code><span>// 方法一</span>\n<span>var</span> args <span>=</span> <span>Array</span><span>.</span>prototype<span>.</span><span>slice</span><span>.</span><span>call</span><span>(</span>arguments<span>)</span><span>;</span>\n\n<span>// 方法二</span>\n<span>var</span> args <span>=</span> <span>[</span><span>]</span><span>.</span><span>slice</span><span>.</span><span>call</span><span>(</span>arguments<span>)</span><span>;</span>\n\n<span>// 方法三 ES6 提供</span>\n<span>const</span> args <span>=</span> Array<span>.</span><span>from</span><span>(</span>arguments<span>)</span><span>;</span>\n\n<span>// 方法四 ES6 提供</span>\n<span>const</span> args <span>=</span> <span>[</span><span>...</span>arguments<span>]</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>转换成数组之后，就可以使用 JavaScript 在 Array 上提供的各种方法了。</p>\n<h3 id=\"es6-中的迭代器\"> ES6 中的迭代器</h3>\n<p>ES6 规定，默认的迭代器部署在对应数据结构的 <code>Symbol.iterator</code> 属性上，如果一个数据结构具有 <code>Symbol.iterator</code> 属性，就被视为可遍历的，就可以用 <code>for...of</code> 循环遍历它的成员。也就是说，<code>for...of</code> 循环内部调用的是数据结构的 <code>Symbol.iterator</code> 方法。</p>\n<p><code>for-of</code> 循环可以使用的范围包括 Array、Set、Map 结构、上文提到的类数组结构、Generator 对象，以及字符串。</p>\n<div><p>注意</p>\n<p>关于 ES6 的 Iterator，参考 <a href=\"https://es6.ruanyifeng.com/#docs/iterator\" target=\"_blank\" rel=\"noopener noreferrer\">Iterator 和 for...of 循环</a>。</p>\n</div>\n<p>通过 <code>for-of</code> 可以使用 <code>Symbol.iterator</code> 这个属性提供的迭代器可以遍历对应数据结构，如果对没有提供 <code>Symbol.iterator</code> 的目标使用 <code>for-of</code> 则会抛错：</p>\n<div><pre><code><span>var</span> foo <span>=</span> <span>{</span> a<span>:</span> <span>1</span> <span>}</span>\n\n<span>for</span> <span>(</span><span>var</span> key <span>of</span> foo<span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>key<span>)</span><span>;</span>\n<span>}</span>\n\n<span>// 输出：Uncaught TypeError: foo is not iterable</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>我们可以给一个对象设置一个迭代器，让一个对象也可以使用 <code>for-of</code> 循环：</p>\n<div><pre><code><span>var</span> bar <span>=</span> <span>{</span>\n  a<span>:</span> <span>1</span><span>,</span>\n  <span>[</span>Symbol<span>.</span>iterator<span>]</span><span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    <span>var</span> valArr <span>=</span> <span>[</span>\n      <span>{</span> value<span>:</span> <span>'hello'</span><span>,</span> done<span>:</span> <span>false</span> <span>}</span><span>,</span>\n      <span>{</span> value<span>:</span> <span>'world'</span><span>,</span> done<span>:</span> <span>false</span> <span>}</span><span>,</span>\n      <span>{</span> value<span>:</span> <span>'!'</span><span>,</span> done<span>:</span> <span>false</span> <span>}</span><span>,</span>\n      <span>{</span> value<span>:</span> <span>undefined</span><span>,</span> done<span>:</span> <span>true</span> <span>}</span>\n    <span>]</span>\n    <span>return</span> <span>{</span>\n      <span>next</span><span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> valArr<span>.</span><span>shift</span><span>(</span><span>)</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n\n<span>for</span> <span>(</span><span>var</span> key <span>of</span> bar<span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>key<span>)</span>\n<span>}</span>\n\n<span>// 输出： hello</span>\n<span>// 输出： world</span>\n<span>// 输出： !</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>可以看到 <code>for-of</code> 循环连 <code>bar</code> 对象自己的属性都不遍历了，遍历获取的值只和 <code>Symbol.iterator</code> 方法实现有关。</p>\n<h2 id=\"迭代器模式总结\"> 迭代器模式总结</h2>\n<p>迭代器模式早已融入我们的日常开发中，在使用 <code>filter</code>、<code>reduce</code>、<code>map</code> 等方法的时候，不要忘记这些便捷的方法就是迭代器模式的应用。当我们使用迭代器方法处理一个对象时，我们可以关注与处理的逻辑，而不必关心对象的内部结构，侧面将对象内部结构和使用者之间解耦，也使得代码中的循环结构变得紧凑而优美。</p>\n<p>（完）</p>\n",
      "date_published": "2022-03-27T06:40:49.000Z",
      "date_modified": "2022-03-27T06:40:49.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "观察者模式",
      "url": "https://www.fedbook.cn/in-depth-learning/design-patterns/observer-pattern/",
      "id": "https://www.fedbook.cn/in-depth-learning/design-patterns/observer-pattern/",
      "content_html": "<h1 id=\"观察者模式\"> 观察者模式</h1>\n<blockquote>\n<p>在众多设计模式中，可能最常见、最有名的就是观察者模式了。如果说前端只学一种设计模式，那一定非他莫属。</p>\n</blockquote>\n<h2 id=\"介绍\"> 介绍</h2>\n<p>观察者模式（Observer Pattern）又叫发布 - 订阅模式（Publish-Subscribe Pattern, pub-sub），它定义了一种一对多的关系，让多个订阅者对象（或者叫观察者对象）同时监听某一个发布者（或者叫主题对象），这个主题对象的状态发生变化时就会通知所有订阅自己的订阅者对象，使得它们能够自动更新自己。</p>\n<p>也有人提出发布 - 订阅模式和观察者模式之间是<a href=\"https://www.cnblogs.com/viaiu/p/9939301.html\" target=\"_blank\" rel=\"noopener noreferrer\">有一些区别的</a>，但是大部分情况下你可以将他们当成是一个模式，本文将不对它们之间进行区分，文末会简单讨论一下他们之间的微妙区别，了解即可。</p>\n<h2 id=\"通俗的示例\"> 通俗的示例</h2>\n<p>在现实生活中其实我们会经常碰到观察者模式的例子。</p>\n<ul>\n<li>当我们被公众号主拉进了一个技术交流群，如果有人发言，那么这个群里的所有人都会收到这个人的发言。这是一个典型的发布 - 订阅模式，当我们加入了这个群，相当于订阅了在这个群发送的消息，当有新的消息产生，聊天室会负责将消息发布给所有聊天室的订阅者。</li>\n<li>当我们去鸿星尔克买鞋，发现之前在直播间看中的款式已经没货了。售货员告诉你不久后这个款式会进货，到时候打电话通知你，于是你留了个电话就回家了。当下周某个时候鸿星尔克进货了，售货员拿出小本本，给所有关注这个款式的人打电话。</li>\n</ul>\n<p>上面两个生活小例子都属于发布 - 订阅模式的实例，群成员 / 买家属于消息的订阅者，订阅消息的变化。技术交流群 / 售货员属于消息的发布者，在合适的时机向群成员 / 小本本上的订阅者发布消息。</p>\n<p>在类似场景中，这些例子有以下特点：</p>\n<ul>\n<li>买家（订阅者）只要声明对消息的一次订阅，就可以在未来的某个时候接受来自售货员（发布者）的消息，不用一直轮询消息的变化。</li>\n<li>售货员（发布者）持有一个小本本（订阅者列表），对这个本本上记录的订阅者的情况并不关心，只需要在消息发生时挨个去通知小本本上的订阅者，当订阅者增加或减少时，只需要在小本本上增删记录即可。</li>\n<li>将上面的逻辑升级一下，一个人可以加多个群，售货员也可以有多个小本本，当不同的群产生消息或者不款式的鞋进货了，发布者可以按照不同的名单 / 小本本分别去通知订阅了不同类型消息的订阅者，这里有个消息类型的概念。</li>\n</ul>\n<blockquote>\n<ul>\n<li>如果你在 DOM 上绑定过事件处理函数 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener\" target=\"_blank\" rel=\"noopener noreferrer\">addEventListener</a>，那么你已经使用过观察者模式了。</li>\n<li>我们经常将一些操作挂载在 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/load_event\" target=\"_blank\" rel=\"noopener noreferrer\">onload</a> 事件上执行，当页面元素加载完毕，就会触发你注册在 <code>onload</code> 事件上的回调。我们无法预知页面元素何时加载完毕，但是通过订阅 window 的 <code>onload</code> 事件，window 会在加载完毕时向订阅者发布消息，也就是执行回调函数。<div><pre><code>window<span>.</span><span>addEventListener</span><span>(</span><span>'load'</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'loaded!'</span><span>)</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>\n</ul>\n</blockquote>\n<h2 id=\"观察者模式的通用实现\"> 观察者模式的通用实现</h2>\n<p>我们可以把上面例子的几个核心概念提取一下，买家可以被认为是订阅者（Subscriber），售货员可以被认为是发布者（Publisher），售货员持有小本本（SubscriberMap），小本本上记录有买家订阅（subscribe）的不同鞋型（Type）的信息，当然也可以退订（unSubscribe），当鞋型有消息时售货员会给订阅了当前类型消息的订阅者发布（notify）消息。</p>\n<p>主要有下面几个概念：</p>\n<ul>\n<li><strong>Publisher</strong>：发布者，当消息发生时负责通知对应订阅者</li>\n<li><strong>Subscriber</strong>：订阅者，当消息发生时被通知的对象</li>\n<li><strong>SubscriberMap</strong>：持有不同 type 的数组，存储有所有订阅者的数组</li>\n<li><strong>type</strong>：消息类型，订阅者可以订阅的不同消息类型</li>\n<li><strong>subscribe</strong>：该方法为将订阅者添加到 SubscriberMap 中对应的数组中</li>\n<li><strong>unSubscribe</strong>：该方法为在 SubscriberMap 中删除订阅者</li>\n<li><strong>notify</strong>：该方法遍历通知 SubscriberMap 中对应 type 的每个订阅者</li>\n</ul>\n<p>结构如下：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/observer-pattern.jpg\" alt=\"观察者模式结构图\" style=\"width: 640px;\">\n  <p style=\"text-align: center; color: #888;\">（观察者模式结构图）</p>\n</div>\n<p>下面使用通用化的方法实现一下。</p>\n<p>首先我们使用立即调用函数 IIFE（Immediately Invoked Function Expression）方式来将不希望公开的 <code>SubscriberMap</code> 隐藏，然后可以将注册的订阅行为换为回调函数的形式，这样我们可以在消息通知时附带参数信息，在处理通知的时候也更灵活：</p>\n<div><pre><code><span>const</span> Publisher <span>=</span> <span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>\n  <span>const</span> _subsMap <span>=</span> <span>{</span><span>}</span>   <span>// 存储订阅者</span>\n  <span>return</span> <span>{</span>\n    <span>/* 消息订阅 */</span>\n    <span>subscribe</span><span>(</span><span>type<span>,</span> cb</span><span>)</span> <span>{</span>\n      <span>if</span> <span>(</span>_subsMap<span>[</span>type<span>]</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>!</span>_subsMap<span>[</span>type<span>]</span><span>.</span><span>includes</span><span>(</span>cb<span>)</span><span>)</span>\n          _subsMap<span>[</span>type<span>]</span><span>.</span><span>push</span><span>(</span>cb<span>)</span>\n      <span>}</span> <span>else</span> _subsMap<span>[</span>type<span>]</span> <span>=</span> <span>[</span>cb<span>]</span>\n    <span>}</span><span>,</span>\n    <span>/* 消息退订 */</span>\n    <span>unsubscribe</span><span>(</span><span>type<span>,</span> cb</span><span>)</span> <span>{</span>\n      <span>if</span> <span>(</span><span>!</span>_subsMap<span>[</span>type<span>]</span> <span>||</span> <span>!</span>_subsMap<span>[</span>type<span>]</span><span>.</span><span>includes</span><span>(</span>cb<span>)</span><span>)</span> <span>return</span>\n      <span>const</span> idx <span>=</span> _subsMap<span>[</span>type<span>]</span><span>.</span><span>indexOf</span><span>(</span>cb<span>)</span>\n      _subsMap<span>[</span>type<span>]</span><span>.</span><span>splice</span><span>(</span>idx<span>,</span> <span>1</span><span>)</span>\n    <span>}</span><span>,</span>\n    <span>/* 消息发布 */</span>\n    <span>notify</span><span>(</span><span>type<span>,</span> <span>...</span>payload</span><span>)</span> <span>{</span>\n      <span>if</span> <span>(</span><span>!</span>_subsMap<span>[</span>type<span>]</span><span>)</span> <span>return</span>\n      _subsMap<span>[</span>type<span>]</span><span>.</span><span>forEach</span><span>(</span><span>cb</span> <span>=></span> <span>cb</span><span>(</span><span>...</span>payload<span>)</span><span>)</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span><span>)</span><span>(</span><span>)</span>\n\n<span>// 测试</span>\nPublisher<span>.</span><span>subscribe</span><span>(</span><span>'面包鞋'</span><span>,</span> <span>message</span> <span>=></span> console<span>.</span><span>log</span><span>(</span><span>'152********'</span> <span>+</span> message<span>)</span><span>)</span>   <span>// 订阅面包鞋</span>\nPublisher<span>.</span><span>subscribe</span><span>(</span><span>'面包鞋'</span><span>,</span> <span>message</span> <span>=></span> console<span>.</span><span>log</span><span>(</span><span>'138********'</span> <span>+</span> message<span>)</span><span>)</span>\nPublisher<span>.</span><span>subscribe</span><span>(</span><span>'奇弹跑鞋'</span><span>,</span> <span>message</span> <span>=></span> console<span>.</span><span>log</span><span>(</span><span>'139********'</span> <span>+</span> message<span>)</span><span>)</span> <span>// 订阅奇弹跑鞋</span>\n\nPublisher<span>.</span><span>notify</span><span>(</span><span>'面包鞋'</span><span>,</span> <span>' 面包鞋到货了 ~'</span><span>)</span>       <span>// 打电话通知买家面包鞋消息</span>\nPublisher<span>.</span><span>notify</span><span>(</span><span>'奇弹跑鞋'</span><span>,</span> <span>' 奇弹跑鞋售罄了 T.T'</span><span>)</span> <span>// 打电话通知买家奇弹跑鞋消息</span>\n\n<span>// 输出:</span>\n<span>// 152******** 面包鞋到货了 ~</span>\n<span>// 138******** 面包鞋到货了 ~</span>\n<span>// 139******** 奇弹跑鞋售罄了 T.T</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><p>上面是使用 IIFE 实现的，现在 ES6 的普及面已经很广了，生产中可以使用 class 语法来改写一下：</p>\n<div><pre><code><span>class</span> <span>Publisher</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>_subsMap <span>=</span> <span>{</span><span>}</span>\n  <span>}</span>\n\n  <span>/* 消息订阅 */</span>\n  <span>subscribe</span><span>(</span><span>type<span>,</span> cb</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>this</span><span>.</span>_subsMap<span>[</span>type<span>]</span><span>)</span> <span>{</span>\n      <span>if</span> <span>(</span><span>!</span><span>this</span><span>.</span>_subsMap<span>[</span>type<span>]</span><span>.</span><span>includes</span><span>(</span>cb<span>)</span><span>)</span>\n        <span>this</span><span>.</span>_subsMap<span>[</span>type<span>]</span><span>.</span><span>push</span><span>(</span>cb<span>)</span>\n    <span>}</span> <span>else</span> <span>this</span><span>.</span>_subsMap<span>[</span>type<span>]</span> <span>=</span> <span>[</span>cb<span>]</span>\n  <span>}</span>\n\n  <span>/* 消息退订 */</span>\n  <span>unsubscribe</span><span>(</span><span>type<span>,</span> cb</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>!</span><span>this</span><span>.</span>_subsMap<span>[</span>type<span>]</span> <span>||</span> <span>!</span><span>this</span><span>.</span>_subsMap<span>[</span>type<span>]</span><span>.</span><span>includes</span><span>(</span>cb<span>)</span><span>)</span> <span>return</span>\n    <span>const</span> idx <span>=</span> <span>this</span><span>.</span>_subsMap<span>[</span>type<span>]</span><span>.</span><span>indexOf</span><span>(</span>cb<span>)</span>\n    <span>this</span><span>.</span>_subsMap<span>[</span>type<span>]</span><span>.</span><span>splice</span><span>(</span>idx<span>,</span> <span>1</span><span>)</span>\n  <span>}</span>\n\n  <span>/* 消息发布 */</span>\n  <span>notify</span><span>(</span><span>type<span>,</span> <span>...</span>payload</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>!</span><span>this</span><span>.</span>_subsMap<span>[</span>type<span>]</span><span>)</span> <span>return</span>\n    <span>this</span><span>.</span>_subsMap<span>[</span>type<span>]</span><span>.</span><span>forEach</span><span>(</span><span>cb</span> <span>=></span> <span>cb</span><span>(</span><span>...</span>payload<span>)</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 测试</span>\n<span>const</span> erke <span>=</span> <span>new</span> <span>Publisher</span><span>(</span><span>)</span>\n\nerke<span>.</span><span>subscribe</span><span>(</span><span>'面包鞋'</span><span>,</span> <span>message</span> <span>=></span> console<span>.</span><span>log</span><span>(</span><span>'152********'</span> <span>+</span> message<span>)</span><span>)</span>    <span>// 订阅面包鞋</span>\nerke<span>.</span><span>subscribe</span><span>(</span><span>'面包鞋'</span><span>,</span> <span>message</span> <span>=></span> console<span>.</span><span>log</span><span>(</span><span>'138********'</span> <span>+</span> message<span>)</span><span>)</span>\nerke<span>.</span><span>subscribe</span><span>(</span><span>'奇弹跑鞋'</span><span>,</span> <span>message</span> <span>=></span> console<span>.</span><span>log</span><span>(</span><span>'139********'</span> <span>+</span> message<span>)</span><span>)</span>    <span>// 订阅奇弹跑鞋</span>\n\nerke<span>.</span><span>notify</span><span>(</span><span>'面包鞋'</span><span>,</span> <span>' 面包鞋到货了 ~'</span><span>)</span>   <span>// 打电话通知买家面包鞋消息</span>\nerke<span>.</span><span>notify</span><span>(</span><span>'奇弹跑鞋'</span><span>,</span> <span>' 奇弹跑鞋售罄了 T.T'</span><span>)</span> <span>// 打电话通知买家奇弹跑鞋消息</span>\n\n<span>// 输出:  </span>\n<span>// 152******** 面包鞋到货了 ~</span>\n<span>// 138******** 面包鞋到货了 ~</span>\n<span>// 139******** 奇弹跑鞋售罄了 T.T</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h2 id=\"观察者模式的实际应用\"> 观察者模式的实际应用</h2>\n<h3 id=\"使用-jquery-的方式来实现\"> 使用 jQuery 的方式来实现</h3>\n<p>我们使用 jQuery 的时候可以通过其自带的 API 比如 <code>on</code>、<code>trigger</code>、<code>off</code> 来轻松实现事件的订阅、发布、取消订阅等操作：</p>\n<div><pre><code><span>function</span> <span>eventHandler</span><span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'自定义方法'</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>/* ---- 事件订阅 ---- */</span>\n<span>// 订阅</span>\n<span>$</span><span>(</span><span>'#app'</span><span>)</span><span>.</span><span>on</span><span>(</span><span>'myevent'</span><span>,</span> eventHandler<span>)</span><span>;</span>\n<span>// 发布</span>\n<span>$</span><span>(</span><span>'#app'</span><span>)</span><span>.</span><span>trigger</span><span>(</span><span>'myevent'</span><span>)</span><span>;</span>\n<span>// 输出：自定义方法</span>\n\n\n<span>/* ---- 取消订阅 ---- */</span>\n<span>$</span><span>(</span><span>'#app'</span><span>)</span><span>.</span><span>off</span><span>(</span><span>'myevent'</span><span>)</span><span>;</span>\n<span>$</span><span>(</span><span>'#app'</span><span>)</span><span>.</span><span>trigger</span><span>(</span><span>'myevent'</span><span>)</span><span>;</span>\n<span>// 没有输出</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>甚至我们可以使用原生的 <code>addEventListener</code>、<code>dispatchEvent</code>、<code>removeEventListener</code> 来实现发布订阅：</p>\n<div><pre><code><span>// 输出：自定义方法</span>\n<span>function</span> <span>eventHandler</span><span>(</span><span>dom</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'自定义方法'</span><span>,</span> dom<span>)</span><span>;</span>\n<span>}</span>\n\n<span>var</span> app <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'app'</span><span>)</span><span>;</span>\n\n<span>/* ---- 事件订阅 ---- */</span>\n<span>// 订阅</span>\napp<span>.</span><span>addEventListener</span><span>(</span><span>'myevent'</span><span>,</span> eventHandler<span>)</span><span>;</span>\n<span>// 发布</span>\napp<span>.</span><span>dispatchEvent</span><span>(</span><span>new</span> <span>Event</span><span>(</span><span>'myevent'</span><span>)</span><span>)</span><span>;</span>\n\n<span>// 输出：自定义方法+DOM</span>\n\n\n<span>/* ---- 取消订阅 ---- */</span>\napp<span>.</span><span>removeEventListener</span><span>(</span><span>'myevent'</span><span>,</span> eventHandler<span>)</span><span>;</span>\napp<span>.</span><span>dispatchEvent</span><span>(</span><span>new</span> <span>Event</span><span>(</span><span>'myevent'</span><span>)</span><span>)</span><span>;</span>\n<span>// 没有输出</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h3 id=\"使用-vue-的-eventbus\"> 使用 Vue 的 EventBus</h3>\n<p>和 jQuery 一样，Vue 也是实现有一套事件机制，其中一个我们熟知的用法是 <code>EventBus</code>。在多层组件的事件处理中，如果你觉得一层层 <code>$on</code>、<code>$emit</code> 比较麻烦，而你又不愿意引入 Vuex，那么这时候可以使用 <code>EventBus</code> 来解决组件间的数据通信：</p>\n<div><pre><code><span>// event-bus.js</span>\n\n<span>import</span> Vue <span>from</span> <span>'vue'</span>\n<span>export</span> <span>const</span> EventBus <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>使用时：</p>\n<div><pre><code><span>// 组件A</span>\n<span>import</span> <span>{</span> EventBus <span>}</span> <span>from</span> <span>\"./event-bus.js\"</span><span>;</span>\n\nEventBus<span>.</span><span>$on</span><span>(</span><span>\"myevent\"</span><span>,</span> <span>args</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>args<span>)</span><span>;</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code><span>// 组件B</span>\n<span>import</span> <span>{</span> EventBus <span>}</span> <span>from</span> <span>\"./event-bus.js\"</span><span>;</span>\n\nEventBus<span>.</span><span>$emit</span><span>(</span><span>\"myevent\"</span><span>,</span> <span>'some args'</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>实现组件间的消息传递，不过在中大型项目中，还是推荐使用 Vuex，因为如果 Bus 上的事件挂载过多，事件满天飞，就分不清消息的来源和先后顺序，对可维护性是一种破坏。</p>\n<h3 id=\"vue-源码中的观察者模式\"> Vue 源码中的观察者模式</h3>\n<p>观察者模式在源码中应用很多，特别是现在很多前端框架都会有的双向绑定机制的场景，这里以 Vue 为例，来分析一下 Vue 是如何利用观察者模式来实现视图层和数据层的双向绑定。先借用官网的双向绑定原理图：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/vue-observer-pattern.jpg\" alt=\"双向绑定原理图\" style=\"width: 640px;\">\n  <p style=\"text-align: center; color: #888;\">（双向绑定原理图）</p>\n</div>\n<p>下面稍微解释一下这个图（框架源码整个过程比较复杂，如果现在看不懂下面几段也没关系，大致了解一下即可）。</p>\n<p>组件渲染函数（Component Render Function）被执行前，会对数据层的数据进行响应式化。响应式化大致就是使用 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\" target=\"_blank\" rel=\"noopener noreferrer\">Object.defineProperty</a> 把数据转为 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects#%E5%AE%9A%E4%B9%89_getters_%E4%B8%8E_setters\" target=\"_blank\" rel=\"noopener noreferrer\">getter/setter</a>，并为每个数据添加一个订阅者列表的过程。这个列表是 <code>getter</code> 闭包中的属性，将会记录所有依赖这个数据的组件。</p>\n<p>也就是说，响应式化后的数据相当于<strong>发布者</strong>。</p>\n<p>每个组件都对应一个 Watcher <strong>订阅者</strong>。当每个组件的渲染函数被执行时，都会将本组件的 Watcher 放到自己所依赖的响应式数据的订阅者列表里，这就相当于完成了<strong>订阅</strong>，一般这个过程被称为依赖收集（Dependency Collect）。</p>\n<blockquote>\n<p>组件渲染函数执行的结果是生成虚拟 DOM 树（Virtual DOM Tree），这个树生成后将被映射为浏览器上的真实的 DOM 树，也就是用户所看到的页面视图。</p>\n</blockquote>\n<p>当响应式数据发生变化的时候，也就是触发了 <code>setter</code> 时，<code>setter</code> 会负责<strong>通知</strong>（Notify）该数据的订阅者列表里的 Watcher，Watcher 会触发组件重渲染（Trigger re-render）来更新（update）视图。</p>\n<p>我们可以看看 Vue 的<a href=\"https://github.com/vuejs/vue/blob/v2.5.18/src/core/observer/index.js#L157-L194\" target=\"_blank\" rel=\"noopener noreferrer\">源码</a>：</p>\n<div><pre><code><span>// src/core/observer/index.js 响应式化过程</span>\n\nObject<span>.</span><span>defineProperty</span><span>(</span>obj<span>,</span> key<span>,</span> <span>{</span>\n  enumerable<span>:</span> <span>true</span><span>,</span>\n  configurable<span>:</span> <span>true</span><span>,</span>\n  <span>get</span><span>:</span> <span>function</span> <span>reactiveGetter</span><span>(</span><span>)</span> <span>{</span>\n    <span>// ...</span>\n    <span>const</span> value <span>=</span> getter <span>?</span> <span>getter</span><span>.</span><span>call</span><span>(</span>obj<span>)</span> <span>:</span> val <span>// 如果原本对象拥有getter方法则执行</span>\n    dep<span>.</span><span>depend</span><span>(</span><span>)</span>                     <span>// 进行依赖收集，dep.addSub</span>\n    <span>return</span> value\n  <span>}</span><span>,</span>\n  <span>set</span><span>:</span> <span>function</span> <span>reactiveSetter</span><span>(</span><span>newVal</span><span>)</span> <span>{</span>\n    <span>// ...</span>\n    <span>if</span> <span>(</span>setter<span>)</span> <span>{</span> <span>setter</span><span>.</span><span>call</span><span>(</span>obj<span>,</span> newVal<span>)</span> <span>}</span>    <span>// 如果原本对象拥有setter方法则执行</span>\n    dep<span>.</span><span>notify</span><span>(</span><span>)</span>               <span>// 如果发生变更，则通知更新</span>\n  <span>}</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>而这个 <code>dep</code> 上的 <code>depend</code> 和 <code>notify</code> 就是订阅和发布通知的具体方法。</p>\n<p>简单来说，响应式数据是消息的发布者，而视图层是消息的订阅者，如果数据更新了，那么发布者会发布数据更新的消息来通知视图更新，从而实现数据层和视图层的双向绑定。</p>\n<h2 id=\"设计原则验证\"> 设计原则验证</h2>\n<ul>\n<li>主题（发布事件）和观察者（订阅事件）分离，不是主动触发而是被动监听，两者解耦（发布 - 订阅的方式）</li>\n<li>符合开放封闭原则</li>\n</ul>\n<h2 id=\"观察者模式的优缺点\"> 观察者模式的优缺点</h2>\n<p>观察者模式最大的优点就是<strong>解耦</strong>：</p>\n<p>优点：</p>\n<ul>\n<li><strong>时间上的解耦</strong>：注册的订阅行为由消息的发布方来决定何时调用，订阅者不用持续关注，当消息发生时发布者会负责通知。</li>\n<li><strong>对象上的解耦</strong>：发布者不用提前知道消息的接受者是谁，发布者只需要遍历处理所有订阅该消息类型的订阅者发送消息即可（迭代器模式），由此解耦了发布者和订阅者之间的联系，互不持有，都依赖于抽象，不再依赖于具体。</li>\n</ul>\n<p>由于它的解耦特性，观察者模式的使用场景一般是：当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变。观察者模式还可以帮助实现一些其他的模式，比如<strong>中介者模式</strong>。</p>\n<p>缺点：</p>\n<ul>\n<li><strong>增加消耗</strong>：创建结构和缓存订阅者这两个过程需要消耗计算和内存资源，即使订阅后始终没有触发，订阅者也会始终存在于内存。</li>\n<li><strong>增加复杂度</strong>：订阅者被缓存在一起，如果多个订阅者和发布者层层嵌套，那么程序将变得难以追踪和调试，参考一下 Vue 调试的时候你点开原型链时看到的那堆 deps/subs/watchers 们…</li>\n</ul>\n<p>缺点主要在于理解成本、运行效率、资源消耗，特别是在多级发布 - 订阅时，情况会变得更复杂。</p>\n<h2 id=\"其他相关模式\"> 其他相关模式</h2>\n<h3 id=\"观察者模式和发布-订阅模式\"> 观察者模式和发布 - 订阅模式</h3>\n<p>观察者模式与发布 - 订阅者模式，在平时你可以认为他们是一个东西，但是某些场合（比如面试）下可能需要稍加注意，借用网上一张流行的图：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/observer-pattern-and-pub-sub-pattern.jpg\" alt=\"观察者模式和发布-订阅模式\" style=\"width: 640px;\">\n  <p style=\"text-align: center; color: #888;\">（观察者模式和发布-订阅模式）</p>\n</div>\n<p>区别主要在发布 - 订阅模式中间的这个 Event Channel：</p>\n<ul>\n<li><strong>观察者模式</strong> 中的观察者和被观察者之间还存在耦合，被观察者还是知道观察者的。</li>\n<li><strong>发布 - 订阅模式</strong> 中的发布者和订阅者不需要知道对方的存在，他们通过<strong>消息代理</strong>来进行通信，解耦更加彻底；</li>\n</ul>\n<h3 id=\"观察者模式和责任链模式\"> 观察者模式和责任链模式</h3>\n<p>观察者模式和责任链模式也有点类似，主要区别在于：</p>\n<ul>\n<li><strong>观察者模式</strong> 传播的消息是根据需要随时发生变化，是发布者和订阅者之间约定的结构，在多级发布 - 订阅的场景下，消息可能完全不一样。</li>\n<li><strong>责任链模式</strong> 传播的消息是不变化的，即使变化也是在原来的消息上稍加修正，不会大幅改变结构；</li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-03-27T03:13:36.000Z",
      "date_modified": "2022-03-27T03:13:36.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "备忘录模式",
      "url": "https://www.fedbook.cn/in-depth-learning/design-patterns/memento-pattern/",
      "id": "https://www.fedbook.cn/in-depth-learning/design-patterns/memento-pattern/",
      "content_html": "<h1 id=\"备忘录模式\"> 备忘录模式</h1>\n<h2 id=\"介绍\"> 介绍</h2>\n<p>备忘录模式（Memento Pattern）用于随时记录一个对象的状态变化，随时可以恢复之前的某个状态（如撤销功能）。</p>\n<h2 id=\"通俗的示例\"> 通俗的示例</h2>\n<p>前端实现的一些工具比如编辑器中比较常见，其它场景用的比较少。</p>\n<h2 id=\"备忘录模式的通用实现\"> 备忘录模式的通用实现</h2>\n<p>以一个编辑器为例，代码如下：</p>\n<div><pre><code><span>/* 状态备忘 */</span>\n<span>class</span> <span>Memento</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>content</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>content <span>=</span> content<span>;</span>\n  <span>}</span>\n  <span>getContent</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span>content<span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* 备忘列表 */</span>\n<span>class</span> <span>CareTaker</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>list <span>=</span> <span>[</span><span>]</span><span>;</span>\n  <span>}</span>\n  <span>add</span><span>(</span><span>memento</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>list<span>.</span><span>push</span><span>(</span>memento<span>)</span><span>;</span>\n  <span>}</span>\n  <span>get</span><span>(</span>index<span>)</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span>list<span>[</span>index<span>]</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* 编辑器 */</span>\n<span>class</span> <span>Editor</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>content <span>=</span> <span>null</span><span>;</span>\n  <span>}</span>\n  <span>setContent</span><span>(</span><span>content</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>content <span>=</span> content<span>;</span>\n  <span>}</span>\n  <span>getContent</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span>content<span>;</span>\n  <span>}</span>\n  <span>saveContentToMemento</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>new</span> <span>Memento</span><span>(</span><span>this</span><span>.</span>content<span>)</span><span>;</span>\n  <span>}</span>\n  <span>getContentFromMemento</span><span>(</span><span>memento</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>content <span>=</span> memento<span>.</span><span>getContent</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 测试</span>\n<span>let</span> editor <span>=</span> <span>new</span> <span>Editor</span><span>(</span><span>)</span><span>;</span>\n<span>let</span> careTaker <span>=</span> <span>new</span> <span>CareTaker</span><span>(</span><span>)</span><span>;</span>\neditor<span>.</span><span>setContent</span><span>(</span><span>'111'</span><span>)</span><span>;</span>\neditor<span>.</span><span>setContent</span><span>(</span><span>'222'</span><span>)</span><span>;</span>\ncareTaker<span>.</span><span>add</span><span>(</span>editor<span>.</span><span>saveContentToMemento</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// 将当前内容备份</span>\neditor<span>.</span><span>setContent</span><span>(</span><span>'333'</span><span>)</span><span>;</span>\ncareTaker<span>.</span><span>add</span><span>(</span>editor<span>.</span><span>saveContentToMemento</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// 将当前内容备份</span>\neditor<span>.</span><span>setContent</span><span>(</span><span>'444'</span><span>)</span><span>;</span>\n\nconsole<span>.</span><span>log</span><span>(</span>editor<span>.</span><span>getContent</span><span>(</span><span>)</span><span>)</span><span>;</span>\neditor<span>.</span><span>getContentFromMemento</span><span>(</span>careTaker<span>.</span><span>get</span><span>(</span><span>1</span><span>)</span><span>)</span><span>;</span> <span>// 撤销</span>\nconsole<span>.</span><span>log</span><span>(</span>editor<span>.</span><span>getContent</span><span>(</span><span>)</span><span>)</span><span>;</span>\neditor<span>.</span><span>getContentFromMemento</span><span>(</span>careTaker<span>.</span><span>get</span><span>(</span><span>0</span><span>)</span><span>)</span><span>;</span> <span>// 撤销</span>\nconsole<span>.</span><span>log</span><span>(</span>editor<span>.</span><span>getContent</span><span>(</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br></div></div><h2 id=\"设计原则验证\"> 设计原则验证</h2>\n<ul>\n<li>状态对象与使用者分开，解耦</li>\n<li>符合开放封闭原则</li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-03-30T02:59:08.000Z",
      "date_modified": "2022-03-30T02:59:08.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "享元模式",
      "url": "https://www.fedbook.cn/in-depth-learning/design-patterns/flyweight-pattern/",
      "id": "https://www.fedbook.cn/in-depth-learning/design-patterns/flyweight-pattern/",
      "content_html": "<h1 id=\"享元模式\"> 享元模式</h1>\n<h2 id=\"介绍\"> 介绍</h2>\n<p>享元模式（Flyweight Pattern）运用共享技术来有效地支持大量细粒度对象的复用，以减少创建的对象的数量。</p>\n<p>享元模式的主要思想是<strong>共享细粒度对象</strong>，也就是说如果系统中存在多个相同的对象，那么只需共享一份就可以了，不必每个都去实例化每一个对象，这样来精简内存资源，提升性能和效率。</p>\n<p>简单来说，</p>\n<ul>\n<li>共享内存（主要考虑内存，而非效率）</li>\n<li>相同的数据，共享使用</li>\n<li>但是前端主要运行在客户端，所以使用场景不多。</li>\n</ul>\n<blockquote>\n<p>Fly 意为苍蝇，Flyweight 指轻蝇量级，指代对象粒度很小。</p>\n</blockquote>\n<h2 id=\"通俗的示例\"> 通俗的示例</h2>\n<p>我们去驾考的时候，如果给每个考试的人都准备一辆车，那考场就挤爆了，考点都堆不下考试车，因此驾考现场一般会有几辆车给要考试的人依次使用。如果考生人数少，就分别少准备几个自动档和手动档的驾考车，考生多的话就多准备几辆。如果考手动档的考生比较多，就多准备几辆手动档的驾考车。</p>\n<p>生活中类似的场景还有很多，比如咖啡厅的咖啡口味，餐厅的菜品种类，拳击比赛的重量级等等。</p>\n<p>在类似场景中，这些例子有以下特点：</p>\n<ul>\n<li>目标对象具有一些共同的状态，比如驾考考生考的是自动档还是手动档。</li>\n<li>这些共同的状态所对应的对象，可以被共享出来。</li>\n</ul>\n<h2 id=\"享元模式的通用实现\"> 享元模式的通用实现</h2>\n<p>首先假设考生的 ID 为奇数则考的是手动档，为偶数则考的是自动档。如果给所有考生都 <code>new</code> 一个驾考车，那么这个系统中就会创建了和考生数量一致的驾考车对象：</p>\n<div><pre><code><span>var</span> candidateNum <span>=</span> <span>10</span>   <span>// 考生数量</span>\n<span>var</span> examCarNum <span>=</span> <span>0</span>      <span>// 驾考车的数量</span>\n\n<span>/* 驾考车构造函数 */</span>\n<span>function</span> <span>ExamCar</span><span>(</span><span>carType</span><span>)</span> <span>{</span>\n  examCarNum<span>++</span>\n  <span>this</span><span>.</span>carId <span>=</span> examCarNum\n  <span>this</span><span>.</span>carType <span>=</span> carType <span>?</span> <span>'手动档'</span> <span>:</span> <span>'自动档'</span>\n<span>}</span>\n\n<span>ExamCar</span><span>.</span>prototype<span>.</span><span>examine</span> <span>=</span> <span>function</span><span>(</span><span>candidateId</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'考生- '</span> <span>+</span> candidateId <span>+</span> <span>' 在'</span> <span>+</span> <span>this</span><span>.</span>carType <span>+</span> <span>'驾考车- '</span> <span>+</span> <span>this</span><span>.</span>carId <span>+</span> <span>' 上考试'</span><span>)</span>\n<span>}</span>\n\n<span>for</span> <span>(</span><span>var</span> candidateId <span>=</span> <span>1</span><span>;</span> candidateId <span>&lt;=</span> candidateNum<span>;</span> candidateId<span>++</span><span>)</span> <span>{</span>\n  <span>var</span> examCar <span>=</span> <span>new</span> <span>ExamCar</span><span>(</span>candidateId <span>%</span> <span>2</span><span>)</span>\n  examCar<span>.</span><span>examine</span><span>(</span>candidateId<span>)</span>\n<span>}</span>\n\nconsole<span>.</span><span>log</span><span>(</span><span>'驾考车总数 - '</span> <span>+</span> examCarNum<span>)</span>\n<span>// 输出: 驾考车总数 - 10</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>如果考生很多，那么系统中就会存在更多个驾考车对象实例，假如驾考车对象比较复杂，那么这些新建的驾考车实例就会占用大量内存。这时我们将同种类型的驾考车实例进行合并，手动档和自动档档驾考车分别引用同一个实例，就可以节约大量内存：</p>\n<div><pre><code><span>var</span> candidateNum <span>=</span> <span>10</span>   <span>// 考生数量</span>\n<span>var</span> examCarNum <span>=</span> <span>0</span>      <span>// 驾考车的数量</span>\n\n<span>/* 驾考车构造函数 */</span>\n<span>function</span> <span>ExamCar</span><span>(</span><span>carType</span><span>)</span> <span>{</span>\n  examCarNum<span>++</span>\n  <span>this</span><span>.</span>carId <span>=</span> examCarNum\n  <span>this</span><span>.</span>carType <span>=</span> carType <span>?</span> <span>'手动档'</span> <span>:</span> <span>'自动档'</span>\n<span>}</span>\n\n<span>ExamCar</span><span>.</span>prototype<span>.</span><span>examine</span> <span>=</span> <span>function</span><span>(</span><span>candidateId</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'考生- '</span> <span>+</span> candidateId <span>+</span> <span>' 在'</span> <span>+</span> <span>this</span><span>.</span>carType <span>+</span> <span>'驾考车- '</span> <span>+</span> <span>this</span><span>.</span>carId <span>+</span> <span>' 上考试'</span><span>)</span>\n<span>}</span>\n\n<span>var</span> manualExamCar <span>=</span> <span>new</span> <span>ExamCar</span><span>(</span><span>true</span><span>)</span>\n<span>var</span> autoExamCar <span>=</span> <span>new</span> <span>ExamCar</span><span>(</span><span>false</span><span>)</span>\n\n<span>for</span> <span>(</span><span>var</span> candidateId <span>=</span> <span>1</span><span>;</span> candidateId <span>&lt;=</span> candidateNum<span>;</span> candidateId<span>++</span><span>)</span> <span>{</span>\n  <span>var</span> examCar <span>=</span> candidateId <span>%</span> <span>2</span> <span>?</span> manualExamCar <span>:</span> autoExamCar\n  examCar<span>.</span><span>examine</span><span>(</span>candidateId<span>)</span>\n<span>}</span>\n\nconsole<span>.</span><span>log</span><span>(</span><span>'驾考车总数 - '</span> <span>+</span> examCarNum<span>)</span>\n<span>// 输出: 驾考车总数 - 2</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>可以看到我们使用 2 个驾考车实例就实现了刚刚 10 个驾考车实例实现的功能。这是仅有 10 个考生的情况，如果有几百上千考生，这时我们节约的内存就比较可观了，这就是享元模式要达到的目的。</p>\n<h2 id=\"享元模式改进\"> 享元模式改进</h2>\n<p>在原型链继承和组合继承中，子类通过原型 <code>prototype</code> 来复用父类的方法和属性，如果子类实例每次都创建新的方法与属性，那么在子类实例很多的情况下，内存中就存在有很多重复的方法和属性，即使这些方法和属性完全一样，因此这部分内存完全可以通过复用来优化，这也是享元模式的思想。</p>\n<p>传统的享元模式是将目标对象的状态区分为<strong>内部状态</strong>和<strong>外部状态</strong>，内部状态相同的对象可以被共享出来指向同一个内部状态。正如之前举的驾考例子中，自动档还是手动档，就属于驾考考生中的内部状态，对应的驾考车就是可以被共享的对象。而考生的年龄、姓名、籍贯等就属于外部状态，一般没有被共享出来的价值。</p>\n<p>主要的原理可以参看下面的示意图：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/flyweight-pattern.jpg\" alt=\"享元模式示意图\" style=\"width: 640px;\">\n  <p style=\"text-align: center; color: #888;\">（享元模式示意图）</p>\n</div>\n<p>享元模式的主要思想是细粒度对象的共享和复用，因此对之前的驾考例子，我们可以继续改进一下：</p>\n<ul>\n<li>如果某考生正在使用一辆驾考车，那么这辆驾考车的状态就是被占用，其他考生只能选择剩下未被占用状态的驾考车。</li>\n<li>如果某考生对驾考车的使用完毕，那么将驾考车开回考点，驾考车的状态改为未被占用，供给其他考生使用。</li>\n<li>如果所有驾考车都被占用，那么其他考生只能等待正在使用驾考车的考生使用完毕，直到有驾考车的状态变为未被占用。</li>\n<li>组织单位可以根据考生数量多准备几辆驾考车，比如手动档考生比较多，那么手动档驾考车就应该比自动档驾考车多准备几辆。</li>\n</ul>\n<p>接下来简单实现一下，首先创建 3 个手动档驾考车，然后注册 10 个考生参与考试，一开始肯定有 3 个考生同时上车，然后在某个考生考完之后其他考生接着后面考。为了实现这个过程，这里使用了 <code>Promise</code>，考试的考生在 0 到 2 秒后的随机时间考试完毕归还驾考车，其他考生在前面考生考完之后接着进行考试：</p>\n<div><pre><code><span>let</span> examCarNum <span>=</span> <span>0</span>                  <span>// 驾考车总数</span>\n\n<span>/* 驾考车对象 */</span>\n<span>class</span> <span>ExamCar</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>carType</span><span>)</span> <span>{</span>\n    examCarNum<span>++</span>\n    <span>this</span><span>.</span>carId <span>=</span> examCarNum\n    <span>this</span><span>.</span>carType <span>=</span> carType <span>?</span> <span>'手动档'</span> <span>:</span> <span>'自动档'</span>\n    <span>this</span><span>.</span>usingState <span>=</span> <span>false</span>    <span>// 是否正在使用</span>\n  <span>}</span>\n\n  <span>/* 在本车上考试 */</span>\n  <span>examine</span><span>(</span><span>candidateId</span><span>)</span> <span>{</span>\n    <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve</span> <span>=></span> <span>{</span>\n      <span>this</span><span>.</span>usingState <span>=</span> <span>true</span>\n      console<span>.</span><span>log</span><span>(</span><span><span>`</span><span>考生- </span><span><span>${</span> candidateId <span>}</span></span><span> 开始在</span><span><span>${</span> <span>this</span><span>.</span>carType <span>}</span></span><span>驾考车- </span><span><span>${</span> <span>this</span><span>.</span>carId <span>}</span></span><span> 上考试</span><span>`</span></span><span>)</span>\n      <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n        <span>this</span><span>.</span>usingState <span>=</span> <span>false</span>\n        console<span>.</span><span>log</span><span>(</span><span><span>`</span><span>%c考生- </span><span><span>${</span> candidateId <span>}</span></span><span> 在</span><span><span>${</span> <span>this</span><span>.</span>carType <span>}</span></span><span>驾考车- </span><span><span>${</span> <span>this</span><span>.</span>carId <span>}</span></span><span> 上考试完毕</span><span>`</span></span><span>,</span> <span>'color:#f40'</span><span>)</span>\n        <span>resolve</span><span>(</span><span>)</span>                       <span>// 0~2秒后考试完毕</span>\n      <span>}</span><span>,</span> Math<span>.</span><span>random</span><span>(</span><span>)</span> <span>*</span> <span>2000</span><span>)</span>\n    <span>}</span><span>)</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* 手动档汽车对象池 */</span>\nManualExamCarPool <span>=</span> <span>{</span>\n  _pool<span>:</span> <span>[</span><span>]</span><span>,</span>                  <span>// 驾考车对象池</span>\n  _candidateQueue<span>:</span> <span>[</span><span>]</span><span>,</span>        <span>// 考生队列</span>\n\n  <span>/* 注册考生 ID 列表 */</span>\n  <span>registCandidates</span><span>(</span><span>candidateList</span><span>)</span> <span>{</span>\n    candidateList<span>.</span><span>forEach</span><span>(</span><span>candidateId</span> <span>=></span> <span>this</span><span>.</span><span>registCandidate</span><span>(</span>candidateId<span>)</span><span>)</span>\n  <span>}</span><span>,</span>\n\n  <span>/* 注册手动档考生 */</span>\n  <span>registCandidate</span><span>(</span><span>candidateId</span><span>)</span> <span>{</span>\n    <span>const</span> examCar <span>=</span> <span>this</span><span>.</span><span>getManualExamCar</span><span>(</span><span>)</span>    <span>// 找一个未被占用的手动档驾考车</span>\n    <span>if</span> <span>(</span>examCar<span>)</span> <span>{</span>\n      examCar<span>.</span><span>examine</span><span>(</span>candidateId<span>)</span>           <span>// 开始考试，考完了让队列中的下一个考生开始考试</span>\n        <span>.</span><span>then</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n          <span>const</span> nextCandidateId <span>=</span> <span>this</span><span>.</span>_candidateQueue<span>.</span>length <span>&amp;&amp;</span> <span>this</span><span>.</span>_candidateQueue<span>.</span><span>shift</span><span>(</span><span>)</span>\n          nextCandidateId <span>&amp;&amp;</span> <span>this</span><span>.</span><span>registCandidate</span><span>(</span>nextCandidateId<span>)</span>\n        <span>}</span><span>)</span>\n    <span>}</span> <span>else</span> <span>this</span><span>.</span>_candidateQueue<span>.</span><span>push</span><span>(</span>candidateId<span>)</span>\n  <span>}</span><span>,</span>\n\n  <span>/* 注册手动档车 */</span>\n  <span>initManualExamCar</span><span>(</span><span>manualExamCarNum</span><span>)</span> <span>{</span>\n    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> manualExamCarNum<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n      <span>this</span><span>.</span>_pool<span>.</span><span>push</span><span>(</span><span>new</span> <span>ExamCar</span><span>(</span><span>true</span><span>)</span><span>)</span>\n    <span>}</span>\n  <span>}</span><span>,</span>\n\n  <span>/* 获取状态为未被占用的手动档车 */</span>\n  <span>getManualExamCar</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span>_pool<span>.</span><span>find</span><span>(</span><span>car</span> <span>=></span> <span>!</span>car<span>.</span>usingState<span>)</span>\n  <span>}</span>\n<span>}</span>\n\nManualExamCarPool<span>.</span><span>initManualExamCar</span><span>(</span><span>3</span><span>)</span>          <span>// 一共有3个驾考车</span>\nManualExamCarPool<span>.</span><span>registCandidates</span><span>(</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>,</span> <span>10</span><span>]</span><span>)</span>  <span>// 10个考生来考试</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br></div></div><p>在浏览器中运行下试试，可以看到一个驾考的过程被模拟出来了，这里只简单实现了手动档，自动档驾考场景同理，就不进行实现了。上面的实现还可以进一步优化，比如考生多的时候自动新建驾考车，考生少的时候逐渐减少驾考车，但又不能无限新建驾考车对象，这些情况可以自行发挥。</p>\n<p>如果可以将目标对象的内部状态和外部状态区分的比较明显，就可以将内部状态一致的对象很方便地共享出来，但是对 JavaScript 来说，我们并不一定要严格区分内部状态和外部状态才能进行资源共享，比如资源池模式。</p>\n<h2 id=\"资源池\"> 资源池</h2>\n<p>上面这种改进的模式一般叫做<strong>资源池</strong>（Resource Pool），或者叫对象池（Object Pool），可以当作是享元模式的升级版，实现不一样，但是目的相同。资源池一般维护一个装载对象的池子，封装有获取、释放资源的方法，当需要对象的时候直接从资源池中获取，使用完毕之后释放资源等待下次被获取。</p>\n<p>在上面的例子中，驾考车相当于有限资源，考生作为访问者根据资源的使用情况从资源池中获取资源，如果资源池中的资源都正在被占用，要么资源池创建新的资源，要么访问者等待占用的资源被释放。</p>\n<p>资源池在后端应用相当广泛，比如缓冲池、连接池、线程池、字符常量池等场景，前端使用场景不多，但是也有使用，比如有些频繁的 DOM 创建销毁操作，就可以引入对象池来节约一些 DOM 创建损耗。</p>\n<p>下面介绍资源池的几种主要应用。</p>\n<h3 id=\"线程池\"> 线程池</h3>\n<p>以 Node.js 中的线程池为例，Node.js 的 JavaScript 引擎是执行在单线程中的，启动的时候会新建 4 个线程放到线程池中，当遇到一些异步 I/O 操作（比如文件异步读写、DNS 查询等）或者一些 CPU 密集的操作（Crypto、Zlib 模块等）的时候，会在线程池中拿出一个线程去执行。如果有需要，线程池会按需创建新的线程。</p>\n<p>线程池在整个 Node.js 事件循环中的位置可以参照下图：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/node-thread-pool.jpg\" alt=\"Node.js 线程池\" style=\"width: 640px;\">\n  <p style=\"text-align: center; color: #888;\">（Node.js 线程池）</p>\n</div>\n<p>上面这个图就是 Node.js 的事件循环（Event Loop）机制，简单解读一下（扩展视野，不一定需要懂）：</p>\n<ul>\n<li>所有任务都在主线程上执行，形成执行栈（Execution Context Stack）。</li>\n<li>主线程之外维护一个任务队列（Task Queue），接到请求时将请求作为一个任务放入这个队列中，然后继续接收其他请求。</li>\n<li>一旦执行栈中的任务执行完毕，主线程空闲时，主线程读取任务队列中的任务，检查队列中是否有要处理的事件，这时要分两种情况：如果是非 I/O 任务，就亲自处理，并通过回调函数返回到上层调用；如果是 I/O 任务，将传入的参数和回调函数封装成请求对象，并将这个请求对象推入线程池等待执行，主线程则读取下一个任务队列的任务，以此类推处理完任务队列中的任务。</li>\n<li>线程池当线程可用时，取出请求对象执行 I/O 操作，任务完成以后归还线程，并把这个完成的事件放到任务队列的尾部，等待事件循环，当主线程再次循环到该事件时，就直接处理并返回给上层调用。</li>\n</ul>\n<h3 id=\"缓存\"> 缓存</h3>\n<p>根据二八原则，80% 的请求其实访问的是 20% 的资源，我们可以将频繁访问的资源缓存起来，如果用户访问被缓存起来的资源就直接返回缓存的版本，这就是 Web 开发中经常遇到的<strong>缓存</strong>。</p>\n<p>缓存服务器就是缓存的最常见应用之一，也是复用资源的一种常用手段。缓存服务器的示意图如下：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/cache-server.jpg\" alt=\"缓存服务器示意图\" style=\"width: 640px;\">\n  <p style=\"text-align: center; color: #888;\">（缓存服务器示意图）</p>\n</div>\n<p>缓存服务器位于访问者与业务服务器之间，对业务服务器来说，减轻了压力，减小了负载，提高了数据查询的性能。对用户来说，提升了网页打开速度，优化了体验。</p>\n<p>缓存技术用的非常多，不仅仅用在缓存服务器上，浏览器本地也有缓存，查询的 DNS 也有缓存，包括我们的电脑 CPU 上，也有缓存硬件。</p>\n<h3 id=\"连接池\"> 连接池</h3>\n<p>我们知道对数据库进行操作需要先创建一个数据库连接对象，然后通过创建好的数据库连接来对数据库进行 CRUD（增删改查）操作。如果访问量不大，对数据库的 CRUD 操作就不多，每次访问都创建连接并在使用完销毁连接就没什么，但是如果访问量比较多，并发的要求比较高时，频繁创建和销毁连接就比较消耗资源了。</p>\n<p>这时，可以不销毁连接，一直使用已创建的连接，就可以避免频繁创建销毁连接的损耗了。但是有个问题，一个连接同一时间只能做一件事，某使用者（一般是线程）正在使用时，其他使用者就不可以使用了，所以如果只创建一个不关闭的连接显然不符合要求，我们需要创建多个不关闭的连接。</p>\n<p>这就是<strong>连接池</strong>的来源，创建多个数据库连接，当有调用的时候直接在创建好的连接中拿出来使用，使用完毕之后将连接放回去供其他调用者使用。</p>\n<p>我们以 Node.js 中 <code>mysql</code> 模块的连接池应用为例，看看后端一般是如何使用数据库连接池的。在 Node.js 中使用 <code>mysql</code> 创建单个连接，一般这样使用：</p>\n<div><pre><code><span>var</span> mysql <span>=</span> <span>require</span><span>(</span><span>'mysql'</span><span>)</span>\n\n<span>var</span> connection <span>=</span> mysql<span>.</span><span>createConnection</span><span>(</span><span>{</span>     <span>// 创建数据库连接</span>\n  host<span>:</span> <span>'localhost'</span><span>,</span>\n  user<span>:</span> <span>'root'</span><span>,</span>         <span>// 用户名</span>\n  password<span>:</span> <span>'123456'</span><span>,</span>   <span>// 密码</span>\n  database<span>:</span> <span>'db'</span><span>,</span>       <span>// 指定数据库</span>\n  port<span>:</span> <span>'3306'</span>          <span>// 端口号</span>\n<span>}</span><span>)</span>\n\n<span>// 连接回调，在回调中增删改查</span>\nconnection<span>.</span><span>connect</span><span>(</span><span>...</span><span>)</span>\n\n<span>// 关闭连接</span>\nconnection<span>.</span><span>end</span><span>(</span><span>...</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>在 Node.js 中使用 <code>mysql</code> 模块的连接池创建连接：</p>\n<div><pre><code><span>var</span> mysql <span>=</span> <span>require</span><span>(</span><span>'mysql'</span><span>)</span>\n\n<span>var</span> pool <span>=</span> mysql<span>.</span><span>createPool</span><span>(</span><span>{</span>     <span>// 创建数据库连接池</span>\n  host<span>:</span> <span>'localhost'</span><span>,</span>\n  user<span>:</span> <span>'root'</span><span>,</span>         <span>// 用户名</span>\n  password<span>:</span> <span>'123456'</span><span>,</span>   <span>// 密码</span>\n  database<span>:</span> <span>'db'</span><span>,</span>       <span>// 制定数据库</span>\n  port<span>:</span> <span>'3306'</span>          <span>// 端口号</span>\n<span>}</span><span>)</span>\n\n<span>// 从连接池中获取一个连接，进行增删改查</span>\npool<span>.</span><span>getConnection</span><span>(</span><span>function</span><span>(</span><span>err<span>,</span> connection</span><span>)</span> <span>{</span>\n  <span>// ... 数据库操作</span>\n  connection<span>.</span><span>release</span><span>(</span><span>)</span>  <span>// 将连接释放回连接池中</span>\n<span>}</span><span>)</span>\n\n<span>// 关闭连接池</span>\npool<span>.</span><span>end</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>一般连接池在初始化的时候，都会自动打开 n 个连接，称为<strong>连接预热</strong>。如果这 n 个连接都被使用了，再从连接池中请求新的连接时，会动态地隐式创建额外连接，即<strong>自动扩容</strong>。如果扩容后的连接池一段时间后有不少连接没有被调用，则<strong>自动缩容</strong>，适当释放空闲连接，增加连接池中连接的使用效率。在连接失效的时候，自动<strong>抛弃无效连接</strong>。在系统关闭的时候，自动<strong>释放所有连接</strong>。为了维持连接池的有效运转和避免连接池无限扩容，还会给连接池设置最大最小连接数。</p>\n<p>这些都是连接池的功能，可以看到连接池一般可以根据当前使用情况自动地进行缩容和扩容，来进行连接池资源的最优化，和连接池连接的复用效率最大化。这些连接池的功能点，看着是不是和之前驾考例子的优化过程有点似曾相识呢！</p>\n<p>在实际项目中，除了数据库连接池外，还有 <strong>HTTP 连接池</strong>。使用 HTTP 连接池管理长连接可以复用 HTTP 连接，省去创建 TCP 连接的 3 次握手和关闭 TCP 连接的 4 次挥手的步骤，降低请求响应的时间。</p>\n<p>连接池某种程度也算是一种缓冲池，只不过这种缓冲池是专门用来管理连接的。</p>\n<h3 id=\"字符常量池\"> 字符常量池</h3>\n<p>很多语言的引擎为了减少字符串对象的重复创建，会在内存中维护有一个特殊的内存，这个内存就叫<strong>字符常量池</strong>。当创建新的字符串时，引擎会对这个字符串进行检查，与字符常量池中已有的字符串进行比对，如果存在有相同内容的字符串，就直接将引用返回，否则在字符常量池中创建新的字符常量，并返回引用。</p>\n<p>类似于 Java、C# 这些语言，都有字符常量池的机制。JavaScript 有多个引擎，以 Chrome 的 V8 引擎为例，V8 在把 JavaScript 编译成字节码过程中就引入了字符常量池这个优化手段，这就是为什么很多 JavaScript 的书籍都提到了 JavaScript 中的字符串具有不可变性，因为如果内存中的字符串可变，一个引用操作改变了字符串的值，那么其他同样的字符串也会受到影响。</p>\n<p>V8 引擎中的字符常量池存在一个变量 <code>string_table_</code> 中，这个变量保存有所有的字符串 <code>All strings are copied here, one after another</code>，地址位于 <a href=\"https://github.com/v8/v8/blob/7.7.205/src/ast/ast-value-factory.h#L349-L350\" target=\"_blank\" rel=\"noopener noreferrer\">v8/src/ast/ast-value-factory.h</a>，核心方法是 <a href=\"https://github.com/v8/v8/blob/7.7.205/src/ast/ast-value-factory.cc#L275\" target=\"_blank\" rel=\"noopener noreferrer\">LookupOrInsert</a>，这个方法给每一个字符串计算出 hash 值，并从 table 中搜索，没有则插入，感兴趣的话可以自行阅读。</p>\n<p>引用《JavaScript 高级程序设计》中的话解释一下：</p>\n<blockquote>\n<p>ECMAScript 中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。</p>\n</blockquote>\n<p>字符常量池也是复用资源的一种手段，只不过这种手段通常用在编译器的运行过程中，通常开发（搬砖）过程用不到，了解即可。</p>\n<h2 id=\"设计原则验证\"> 设计原则验证</h2>\n<ul>\n<li>将相同的部分抽象出来</li>\n<li>符合开放封闭原则</li>\n</ul>\n<h2 id=\"享元模式的优缺点\"> 享元模式的优缺点</h2>\n<p>优点：</p>\n<ul>\n<li>由于<strong>减少了系统中的对象数量</strong>，提高了程序运行效率和性能，精简了内存占用，加快运行速度。</li>\n<li><strong>外部状态相对独立</strong>，不会影响到内部状态，所以享元对象能够在不同的环境被共享。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>引入了共享对象，使对象结构变得复杂。</li>\n<li>共享对象的创建、销毁等需要维护，带来额外的复杂度（如果需要把共享对象维护起来的话）。</li>\n</ul>\n<h2 id=\"享元模式的适用场景\"> 享元模式的适用场景</h2>\n<ul>\n<li>如果一个程序中大量使用了相同或相似对象，那么可以考虑引入享元模式。</li>\n<li>如果使用了大量相同或相似对象，并造成了比较大的内存开销。</li>\n<li>对象的大多数状态可以被转变为外部状态。</li>\n<li>剥离出对象的外部状态后，可以使用相对较少的共享对象取代大量对象。</li>\n</ul>\n<p>在一些程序中，如果引入享元模式对系统的性能和内存的占用影响不大时，比如目标对象不多，或者场景比较简单，则不需要引入，以免适得其反。</p>\n<h2 id=\"其他相关模式\"> 其他相关模式</h2>\n<p>享元模式和单例模式、工厂模式、组合模式、策略模式、状态模式等等可以一起使用。</p>\n<h3 id=\"享元模式和工厂模式、单例模式\"> 享元模式和工厂模式、单例模式</h3>\n<p>在区分出不同种类的外部状态后，创建新对象时需要选择不同种类的共享对象，这时就可以使用工厂模式来提供共享对象，在共享对象的维护上，经常会采用单例模式来提供单实例的共享对象。</p>\n<h3 id=\"享元模式和组合模式\"> 享元模式和组合模式</h3>\n<p>在使用工厂模式来提供共享对象时，比如某些时候共享对象中的某些状态就是对象不需要的，可以引入组合模式来提升自定义共享对象的自由度，对共享对象的组成部分进一步归类、分层，来实现更复杂的多层次对象结构，当然系统也会更难维护。</p>\n<h3 id=\"享元模式和策略模式\"> 享元模式和策略模式</h3>\n<p>策略模式中的策略属于一系列功能单一、细粒度的细粒度对象，可以作为目标对象来考虑引入享元模式进行优化，但是前提是这些策略是会被频繁使用的，如果不经常使用，就没有必要了。</p>\n<p>（完）</p>\n",
      "date_published": "2022-03-28T14:34:28.000Z",
      "date_modified": "2022-03-30T02:59:08.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "原型模式",
      "url": "https://www.fedbook.cn/in-depth-learning/design-patterns/prototype-pattern/",
      "id": "https://www.fedbook.cn/in-depth-learning/design-patterns/prototype-pattern/",
      "content_html": "<h1 id=\"原型模式\"> 原型模式</h1>\n<h2 id=\"介绍\"> 介绍</h2>\n<p>原型模式（Prototype Pattern）不是指的 JS 的原型，它是 clone 自己，生成一个新对象的操作。因为 new 一个新对象的时候开销会比较大，或者由于其他原因不合适，所以采用这种方式创建一个一模一样的对象。</p>\n<p>Java 默认有 clone 接口，不用自己实现。JS 中有一个比较像的实现就是 <code>Object.create</code> 方法。</p>\n<h2 id=\"原型模式的通用实现\"> 原型模式的通用实现</h2>\n<div><pre><code><span>// 一个对象（作为原型）</span>\n<span>const</span> prototype <span>=</span> <span>{</span>\n  <span>getName</span><span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span>first <span>+</span> <span>''</span> <span>+</span> <span>this</span><span>.</span>last<span>;</span>\n  <span>}</span><span>,</span>\n  <span>say</span><span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'hello world'</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 基于原型创建 x</span>\n<span>let</span> x <span>=</span> Object<span>.</span><span>create</span><span>(</span>prototype<span>)</span><span>;</span>\nx<span>.</span>first <span>=</span> <span>'A'</span><span>;</span>\nx<span>.</span>last <span>=</span> <span>'B'</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>x<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\nx<span>.</span><span>say</span><span>(</span><span>)</span><span>;</span>\n\n<span>// 基于原型创建 y</span>\n<span>let</span> y <span>=</span> Object<span>.</span><span>create</span><span>(</span>prototype<span>)</span><span>;</span>\ny<span>.</span>first <span>=</span> <span>'C'</span><span>;</span>\ny<span>.</span>last <span>=</span> <span>'D'</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>y<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\ny<span>.</span><span>say</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id=\"对比-js-中的原型-prototype\"> 对比 JS 中的原型（prototype）</h2>\n<ul>\n<li>JS 中的 prototype 可以理解为 ES6 class 的一种底层原理\n<ul>\n<li>上面用到的 <code>Object.create</code> 方法也是基于原型 prototype 的</li>\n</ul>\n</li>\n<li>而 class 是实现面向对象的基础，并不是服务于某个模式</li>\n<li>若干年后 ES6 全面普及，大家可能会忽略掉 prototype，但是 <code>Object.create</code> 却会长久存在</li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-03-27T14:17:45.000Z",
      "date_modified": "2022-03-28T10:17:00.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "中介者模式",
      "url": "https://www.fedbook.cn/in-depth-learning/design-patterns/mediator-pattern/",
      "id": "https://www.fedbook.cn/in-depth-learning/design-patterns/mediator-pattern/",
      "content_html": "<h1 id=\"中介者模式\"> 中介者模式</h1>\n<h2 id=\"介绍\"> 介绍</h2>\n<p>中介者模式（Mediator Pattern）又称调停模式，使得各对象不用显式地相互引用，将对象与对象之间紧密的耦合关系变得松散，从而可以独立地改变他们。核心是多个对象之间复杂交互的封装。</p>\n<p>根据最少知识原则，一个对象应该尽量少地了解其他对象。如果对象之间耦合性太高，改动一个对象则会影响到很多其他对象，可维护性差。复杂的系统，对象之间的耦合关系会得更加复杂，中介者模式就是为了解决这个问题而诞生的。</p>\n<h2 id=\"通俗的示例\"> 通俗的示例</h2>\n<p>比如相亲，可能男生对女生有各种要求，女生对男生也有各种要求，男方家长对女生有各种要求，女方家长对男生有各种要求。总之，男生、女生、男方家长、女方家长各方的关系交错复杂，每个人都有自己的考量，如果某一方有什么想法，要和其他三方进行沟通，牵一发动全身。这时候我们可以引入媒人，无论哪一方有什么要求或者什么想法，都可以直接告诉媒人，这样就不用各方自己互相沟通了。</p>\n<p>在类似场景中，这些例子有以下特点：</p>\n<ul>\n<li>相亲各方（目标对象）之间的关系复杂，引入媒人（中介者）会极大方便各方之间的沟通。</li>\n<li>相亲各方（目标对象）之间如果有什么想法和要求上的变动，通过媒人（中介者）就可以及时通知到相关各方，而目标对象之间相互不通信。</li>\n</ul>\n<h2 id=\"中介者模式的通用实现\"> 中介者模式的通用实现</h2>\n<p>我们使用 JavaScript 将刚刚的相亲例子实现一下。</p>\n<p>首先我们考虑一个场景，男方和女方都有一定的条件，双方之间有要求，双方家长对对方孩子也有要求，如果达不到要求则不同意这门婚事。（也就是说暂时不考虑男女双方对于对方家长，和双方家长之间的要求，因为这样代码就太长了）</p>\n<p>如果不使用中介者模式，代码可以这样写：</p>\n<div><pre><code><span>const</span> PersonFunc <span>=</span> <span>{</span>\n  <span>/* 注册相亲对象及家长 */</span>\n  <span>registEnemy</span><span>(</span><span><span>...</span>enemy</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>enemyList<span>.</span><span>push</span><span>(</span><span>...</span>enemy<span>)</span>\n  <span>}</span><span>,</span>\n\n  <span>/* 检查所有相亲对象及其家长的条件 */</span>\n  <span>checkAllPurpose</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>enemyList<span>.</span><span>forEach</span><span>(</span><span>enemy</span> <span>=></span> enemy<span>.</span>info <span>&amp;&amp;</span> <span>this</span><span>.</span><span>checkPurpose</span><span>(</span>enemy<span>)</span><span>)</span>\n  <span>}</span><span>,</span>\n\n  <span>/* 检查对方是否满足自己的要求，并发信息 */</span>\n  <span>checkPurpose</span><span>(</span><span>enemy</span><span>)</span> <span>{</span>\n    <span>const</span> result <span>=</span> Object<span>.</span><span>keys</span><span>(</span><span>this</span><span>.</span>target<span>)</span>    <span>// 是否满足自己的要求</span>\n      <span>.</span><span>every</span><span>(</span><span>key</span> <span>=></span> <span>{</span>\n        <span>const</span> <span>[</span>low<span>,</span> high<span>]</span> <span>=</span> <span>this</span><span>.</span>target<span>[</span>key<span>]</span>\n        <span>return</span> low <span>&lt;=</span> enemy<span>.</span>info<span>[</span>key<span>]</span> <span>&amp;&amp;</span> enemy<span>.</span>info<span>[</span>key<span>]</span> <span>&lt;=</span> high\n      <span>}</span><span>)</span>\n    enemy<span>.</span><span>receiveResult</span><span>(</span>result<span>,</span> <span>this</span><span>,</span> enemy<span>)</span>   <span>// 通知对方</span>\n  <span>}</span><span>,</span>\n\n  <span>/* 接受到对方的信息 */</span>\n  <span>receiveResult</span><span>(</span><span>result<span>,</span> they<span>,</span> me</span><span>)</span> <span>{</span>\n    result\n      <span>?</span> console<span>.</span><span>log</span><span>(</span><span><span>`</span><span><span>${</span> they<span>.</span>name <span>}</span></span><span>：我觉得合适~ \\t（我的要求 </span><span><span>${</span> me<span>.</span>name <span>}</span></span><span> 已经满足）</span><span>`</span></span><span>)</span>\n      <span>:</span> console<span>.</span><span>log</span><span>(</span><span><span>`</span><span><span>${</span> they<span>.</span>name <span>}</span></span><span>：你是个好人! \\t（我的要求 </span><span><span>${</span> me<span>.</span>name <span>}</span></span><span> 不能满足！）</span><span>`</span></span><span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* 男方 */</span>\n<span>const</span> ZhangXiaoShuai <span>=</span> <span>{</span>\n  <span>...</span>PersonFunc<span>,</span>\n  name<span>:</span> <span>'张小帅'</span><span>,</span>\n  info<span>:</span> <span>{</span> age<span>:</span> <span>25</span><span>,</span> height<span>:</span> <span>171</span><span>,</span> salary<span>:</span> <span>5000</span> <span>}</span><span>,</span>\n  target<span>:</span> <span>{</span> age<span>:</span> <span>[</span><span>23</span><span>,</span> <span>27</span><span>]</span> <span>}</span><span>,</span>\n  enemyList<span>:</span> <span>[</span><span>]</span>\n<span>}</span>\n\n<span>/* 男方家长 */</span>\n<span>const</span> ZhangXiaoShuaiParent <span>=</span> <span>{</span>\n  <span>...</span>PersonFunc<span>,</span>\n  name<span>:</span> <span>'张小帅家长'</span><span>,</span>\n  info<span>:</span> <span>null</span><span>,</span>\n  target<span>:</span> <span>{</span> height<span>:</span> <span>[</span><span>160</span><span>,</span> <span>167</span><span>]</span> <span>}</span><span>,</span>\n  enemyList<span>:</span> <span>[</span><span>]</span>\n<span>}</span>\n\n<span>/* 女方 */</span>\n<span>const</span> LiXiaoMei <span>=</span> <span>{</span>\n  <span>...</span>PersonFunc<span>,</span>\n  name<span>:</span> <span>'李小美'</span><span>,</span>\n  info<span>:</span> <span>{</span> age<span>:</span> <span>23</span><span>,</span> height<span>:</span> <span>160</span> <span>}</span><span>,</span>\n  target<span>:</span> <span>{</span> age<span>:</span> <span>[</span><span>25</span><span>,</span> <span>27</span><span>]</span> <span>}</span><span>,</span>\n  enemyList<span>:</span> <span>[</span><span>]</span>\n<span>}</span>\n\n<span>/* 女方家长 */</span>\n<span>const</span> LiXiaoMeiParent <span>=</span> <span>{</span>\n  <span>...</span>PersonFunc<span>,</span>\n  name<span>:</span> <span>'李小美家长'</span><span>,</span>\n  info<span>:</span> <span>null</span><span>,</span>\n  target<span>:</span> <span>{</span> salary<span>:</span> <span>[</span><span>10000</span><span>,</span> <span>20000</span><span>]</span> <span>}</span><span>,</span>\n  enemyList<span>:</span> <span>[</span><span>]</span>\n<span>}</span>\n\n<span>/* 注册 */</span>\nZhangXiaoShuai<span>.</span><span>registEnemy</span><span>(</span>LiXiaoMei<span>,</span> LiXiaoMeiParent<span>)</span>\nLiXiaoMei<span>.</span><span>registEnemy</span><span>(</span>ZhangXiaoShuai<span>,</span> ZhangXiaoShuaiParent<span>)</span>\nZhangXiaoShuaiParent<span>.</span><span>registEnemy</span><span>(</span>LiXiaoMei<span>,</span> LiXiaoMeiParent<span>)</span>\nLiXiaoMeiParent<span>.</span><span>registEnemy</span><span>(</span>ZhangXiaoShuai<span>,</span> ZhangXiaoShuaiParent<span>)</span>\n\n<span>/* 检查对方是否符合要求 */</span>\nZhangXiaoShuai<span>.</span><span>checkAllPurpose</span><span>(</span><span>)</span>\nLiXiaoMei<span>.</span><span>checkAllPurpose</span><span>(</span><span>)</span>\nZhangXiaoShuaiParent<span>.</span><span>checkAllPurpose</span><span>(</span><span>)</span>\nLiXiaoMeiParent<span>.</span><span>checkAllPurpose</span><span>(</span><span>)</span>\n\n<span>// 张小帅：我觉得合适~ \t（我的要求 李小美 已经满足）</span>\n<span>// 李小美：我觉得合适~ \t（我的要求 张小帅 已经满足）</span>\n<span>// 张小帅家长：我觉得合适~ \t（我的要求 李小美 已经满足）</span>\n<span>// 李小美家长：你是个好人! \t（我的要求 张小帅 不能满足！）</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br></div></div><p>单就结果而言，上面的代码可以实现整个逻辑。<strong>但是这几个对象之间相互引用、相互持有，并紧密耦合</strong>。如果继续引入关系，比如张小帅的七大姑、李小美的八大姨，或者考虑的情况更多一些，那么就要改动很多代码，上面的写法就满足不了要求了。</p>\n<p>这时我们可以引入媒人（中介者），专门处理对象之间的耦合关系，所有对象间相互不了解，只与媒人交互，如果引入了新的相关方，也只需要通知媒人即可。看一下实现：</p>\n<div><pre><code><span>/* 男方 */</span>\n<span>const</span> ZhangXiaoShuai <span>=</span> <span>{</span>\n  name<span>:</span> <span>'张小帅'</span><span>,</span>\n  family<span>:</span> <span>'张小帅家'</span><span>,</span>\n  info<span>:</span> <span>{</span> age<span>:</span> <span>25</span><span>,</span> height<span>:</span> <span>171</span><span>,</span> salary<span>:</span> <span>5000</span> <span>}</span><span>,</span>\n  target<span>:</span> <span>{</span> age<span>:</span> <span>[</span><span>23</span><span>,</span> <span>27</span><span>]</span> <span>}</span>\n<span>}</span>\n\n<span>/* 男方家长 */</span>\n<span>const</span> ZhangXiaoShuaiParent <span>=</span> <span>{</span>\n  name<span>:</span> <span>'张小帅家长'</span><span>,</span>\n  family<span>:</span> <span>'张小帅家'</span><span>,</span>\n  info<span>:</span> <span>null</span><span>,</span>\n  target<span>:</span> <span>{</span> height<span>:</span> <span>[</span><span>160</span><span>,</span> <span>167</span><span>]</span> <span>}</span>\n<span>}</span>\n\n<span>/* 女方 */</span>\n<span>const</span> LiXiaoMei <span>=</span> <span>{</span>\n  name<span>:</span> <span>'李小美'</span><span>,</span>\n  family<span>:</span> <span>'李小美家'</span><span>,</span>\n  info<span>:</span> <span>{</span> age<span>:</span> <span>23</span><span>,</span> height<span>:</span> <span>160</span> <span>}</span><span>,</span>\n  target<span>:</span> <span>{</span> age<span>:</span> <span>[</span><span>25</span><span>,</span> <span>27</span><span>]</span> <span>}</span>\n<span>}</span>\n\n<span>/* 女方家长 */</span>\n<span>const</span> LiXiaoMeiParent <span>=</span> <span>{</span>\n  name<span>:</span> <span>'李小美家长'</span><span>,</span>\n  family<span>:</span> <span>'李小美家'</span><span>,</span>\n  info<span>:</span> <span>null</span><span>,</span>\n  target<span>:</span> <span>{</span> salary<span>:</span> <span>[</span><span>10000</span><span>,</span> <span>20000</span><span>]</span> <span>}</span>\n<span>}</span>\n\n<span>/* 媒人 */</span>\n<span>const</span> MatchMaker <span>=</span> <span>{</span>\n  matchBook<span>:</span> <span>{</span><span>}</span><span>,</span>\t\t<span>// 媒人的花名册</span>\n\n  <span>/* 注册各方 */</span>\n  <span>registPersons</span><span>(</span><span><span>...</span>personList</span><span>)</span> <span>{</span>\n    personList<span>.</span><span>forEach</span><span>(</span><span>person</span> <span>=></span> <span>{</span>\n      <span>if</span> <span>(</span><span>this</span><span>.</span>matchBook<span>[</span>person<span>.</span>family<span>]</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span>matchBook<span>[</span>person<span>.</span>family<span>]</span><span>.</span><span>push</span><span>(</span>person<span>)</span>\n      <span>}</span> <span>else</span> <span>this</span><span>.</span>matchBook<span>[</span>person<span>.</span>family<span>]</span> <span>=</span> <span>[</span>person<span>]</span>\n    <span>}</span><span>)</span>\n  <span>}</span><span>,</span>\n\n  <span>/* 检查对方家庭的孩子对象是否满足要求 */</span>\n  <span>checkAllPurpose</span><span>(</span><span>)</span> <span>{</span>\n    Object<span>.</span><span>keys</span><span>(</span><span>this</span><span>.</span>matchBook<span>)</span>    <span>// 遍历名册中所有家庭</span>\n      <span>.</span><span>forEach</span><span>(</span><span>(</span><span>familyName<span>,</span> idx<span>,</span> matchList</span><span>)</span> <span>=></span>\n        matchList\n          <span>.</span><span>filter</span><span>(</span><span>match</span> <span>=></span> match <span>!==</span> familyName<span>)</span>  <span>// 对于其中一个家庭，过滤出名册中其他的家庭</span>\n          <span>.</span><span>forEach</span><span>(</span><span>enemyFamily</span> <span>=></span> <span>this</span><span>.</span>matchBook<span>[</span>enemyFamily<span>]</span>  <span>// 遍历该家庭中注册到名册上的所有成员</span>\n            <span>.</span><span>forEach</span><span>(</span><span>enemy</span> <span>=></span> <span>this</span><span>.</span>matchBook<span>[</span>familyName<span>]</span>\n              <span>.</span><span>forEach</span><span>(</span><span>person</span> <span>=></span>             <span>// 逐项比较自己的条件和他们的要求</span>\n                enemy<span>.</span>info <span>&amp;&amp;</span> <span>this</span><span>.</span><span>checkPurpose</span><span>(</span>person<span>,</span> enemy<span>)</span>\n              <span>)</span>\n            <span>)</span><span>)</span>\n      <span>)</span>\n  <span>}</span><span>,</span>\n\n  <span>/* 检查对方是否满足自己的要求，并发信息 */</span>\n  <span>checkPurpose</span><span>(</span><span>person<span>,</span> enemy</span><span>)</span> <span>{</span>\n    <span>const</span> result <span>=</span> Object<span>.</span><span>keys</span><span>(</span>person<span>.</span>target<span>)</span>    <span>// 是否满足自己的要求</span>\n      <span>.</span><span>every</span><span>(</span><span>key</span> <span>=></span> <span>{</span>\n        <span>const</span> <span>[</span>low<span>,</span> high<span>]</span> <span>=</span> person<span>.</span>target<span>[</span>key<span>]</span>\n        <span>return</span> low <span>&lt;=</span> enemy<span>.</span>info<span>[</span>key<span>]</span> <span>&amp;&amp;</span> enemy<span>.</span>info<span>[</span>key<span>]</span> <span>&lt;=</span> high\n      <span>}</span><span>)</span>\n    <span>this</span><span>.</span><span>receiveResult</span><span>(</span>result<span>,</span> person<span>,</span> enemy<span>)</span>    <span>// 通知对方</span>\n  <span>}</span><span>,</span>\n\n  <span>/* 通知对方信息 */</span>\n  <span>receiveResult</span><span>(</span><span>result<span>,</span> person<span>,</span> enemy</span><span>)</span> <span>{</span>\n    result\n      <span>?</span> console<span>.</span><span>log</span><span>(</span><span><span>`</span><span><span>${</span> person<span>.</span>name <span>}</span></span><span> 觉得合适~ \\t（</span><span><span>${</span> enemy<span>.</span>name <span>}</span></span><span> 已经满足要求）</span><span>`</span></span><span>)</span>\n      <span>:</span> console<span>.</span><span>log</span><span>(</span><span><span>`</span><span><span>${</span> person<span>.</span>name <span>}</span></span><span> 觉得不合适! \\t（</span><span><span>${</span> enemy<span>.</span>name <span>}</span></span><span> 不能满足要求！）</span><span>`</span></span><span>)</span>\n  <span>}</span>\n<span>}</span>\n\n\n<span>/* 注册 */</span>\nMatchMaker<span>.</span><span>registPersons</span><span>(</span>ZhangXiaoShuai<span>,</span> ZhangXiaoShuaiParent<span>,</span> LiXiaoMei<span>,</span> LiXiaoMeiParent<span>)</span>\n\nMatchMaker<span>.</span><span>checkAllPurpose</span><span>(</span><span>)</span>\n\n<span>// 输出: 小帅 觉得合适~ \t    （李小美 已经满足要求）</span>\n<span>// 输出: 张小帅家长 觉得合适~ \t（李小美 已经满足要求）</span>\n<span>// 输出: 李小美 觉得合适~ \t    （张小帅 已经满足要求）</span>\n<span>// 输出: 李小美家长 觉得不合适! \t（张小帅 不能满足要求！）</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br></div></div><p>可以看到，除了媒人之外，其他各个角色都是独立的，相互不知道对方的存在，对象间关系被解耦，我们甚至可以方便地添加新的对象。比如赵小美家同时还在考虑着孙小拽：</p>\n<div><pre><code><span>// 重写上面「注册」之后的代码</span>\n\n<span>/* 引入孙小拽 */</span>\n<span>const</span> SunXiaoZhuai <span>=</span> <span>{</span>\n  name<span>:</span> <span>'孙小拽'</span><span>,</span>\n  familyType<span>:</span> <span>'男方'</span><span>,</span>\n  info<span>:</span> <span>{</span> age<span>:</span> <span>27</span><span>,</span> height<span>:</span> <span>173</span><span>,</span> salary<span>:</span> <span>20000</span> <span>}</span><span>,</span>\n  target<span>:</span> <span>{</span> age<span>:</span> <span>[</span><span>23</span><span>,</span> <span>27</span><span>]</span> <span>}</span>\n<span>}</span>\n\n<span>/* 孙小拽家长 */</span>\n<span>const</span> SunXiaoZhuaiParent <span>=</span> <span>{</span>\n  name<span>:</span> <span>'孙小拽家长'</span><span>,</span>\n  familyType<span>:</span> <span>'男方'</span><span>,</span>\n  info<span>:</span> <span>null</span><span>,</span>\n  target<span>:</span> <span>{</span> height<span>:</span> <span>[</span><span>160</span><span>,</span> <span>170</span><span>]</span> <span>}</span>\n<span>}</span>\n\n<span>/* 注册，这里只需要注册一次 */</span>\nMatchMaker<span>.</span><span>registPersons</span><span>(</span>ZhangXiaoShuai<span>,</span>\n  ZhangXiaoShuaiParent<span>,</span>\n  LiXiaoMei<span>,</span>\n  LiXiaoMeiParent<span>,</span>\n  SunXiaoZhuai<span>,</span>\n  SunXiaoZhuaiParent<span>)</span>\n\n<span>/* 检查对方是否符合要求，也只需要检查一次 */</span>\nMatchMaker<span>.</span><span>checkAllPurpose</span><span>(</span><span>)</span>\n\n<span>// 输出: 张小帅 觉得合适~ \t    （李小美 已经满足要求）</span>\n<span>// 输出: 张小帅家长 觉得合适~ \t（李小美 已经满足要求）</span>\n<span>// 输出: 孙小拽 觉得合适~ \t    （李小美 已经满足要求）</span>\n<span>// 输出: 孙小拽家长 觉得合适~ \t（李小美 已经满足要求）</span>\n<span>// 输出: 李小美 觉得合适~ \t    （张小帅 已经满足要求）</span>\n<span>// 输出: 李小美家长 觉得不合适! \t（张小帅 不能满足要求！）</span>\n<span>// 输出: 李小美 觉得合适~ \t    （孙小拽 已经满足要求）</span>\n<span>// 输出: 李小美家长 觉得合适~ \t（孙小拽 已经满足要求）</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><p>从这个例子就已经可以看出中介者模式的优点了，因为各对象之间的相互引用关系被解耦，从而令系统的可扩展性、可维护性更好。</p>\n<p>对于上面的例子，张小帅、李小美、孙小拽和他们的家长们相当于容易产生耦合的对象（最早的一本设计模式书上将这些对象称为同事，这里也借用一下这个称呼，Colleague），而媒人就相当于中介者（Mediator）。在中介者模式中，同事对象之间互相不通信，而只与中介者通信，同事对象只需知道中介者即可。主要有以下几个概念：</p>\n<ul>\n<li><strong>Colleague</strong>：同事对象，只知道中介者而不知道其他同事对象，通过中介者来与其他同事对象通信。</li>\n<li><strong>Mediator</strong>：中介者，负责与各同事对象的通信。</li>\n</ul>\n<p>结构如下：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/mediator-pattern.png\" alt=\"中介者模式结构图\">\n  <p style=\"text-align: center; color: #888;\">（中介者模式结构图）</p>\n</div>\n<p>可以看到上图，使用中介者模式之后同事对象间的网状结构变成了星型结构，同事对象之间不需要知道彼此，符合最少知识原则。如果同事对象之间需要相互通信，只能通过中介者的方式，这样让同事对象之间原本的强耦合变成弱耦合，强相互依赖变成弱相互依赖，从而让这些同事对象可以独立地改变和复用。原本同事对象间的交互逻辑被中介者封装起来，各个同事对象只需关心自身即可。</p>\n<h2 id=\"设计原则验证\"> 设计原则验证</h2>\n<ul>\n<li>将各关联对象通过中介者隔离</li>\n<li>符合开放封闭原则</li>\n</ul>\n<h2 id=\"中介者模式的优缺点\"> 中介者模式的优缺点</h2>\n<p>优点：</p>\n<ul>\n<li><strong>松散耦合</strong>，降低了同事对象之间的相互依赖和耦合，不会像之前那样牵一发动全身。</li>\n<li>将同事对象间的<strong>一对多关联转变为一对一的关联</strong>，符合最少知识原则，提高系统的灵活性，使得系统易于维护和扩展。</li>\n<li>中介者在同事对象间起到了控制和协调的作用，因此可以结合代理模式那样，进行<strong>同事对象间的访问控制、功能扩展</strong>。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li><strong>逻辑过度集中化</strong>，当同事对象太多时，中介者的职责将很重，逻辑变得复杂而庞大，以至于难以维护。</li>\n</ul>\n<p>当出现中介者可维护性变差的情况时，考虑是否在系统设计上不合理，从而简化系统设计，优化并重构，避免中介者出现职责过重的情况。</p>\n<h2 id=\"中介者模式的适用场景\"> 中介者模式的适用场景</h2>\n<p>中介者模式适用多个对象间的关系确实已经紧密耦合，且导致扩展、维护产生了困难的场景，也就是当多个<strong>对象之间的引用关系变成了网状结构的时候</strong>，此时可以考虑使用引入中介者来把<strong>网状结构转化为星型结构</strong>。</p>\n<p>但是，如果对象之间的关系耦合并不紧密，或者之间的关系本就一目了然，那么引入中介者模式就是多此一举、画蛇添足。</p>\n<p>实际上，我们通常使用的 MVC/MVVM 框架，就含有中介者模式的思想，Controller/ViewModel 层作为中介者协调 View/Model 进行工作，减少 View/Model 之间的直接耦合依赖，从而做到视图层和数据层的最大分离。可以关注后面有单独一章分析 MVC/MVVM 模式，深入了解。</p>\n<h2 id=\"其他相关模式\"> 其他相关模式</h2>\n<h3 id=\"中介者模式和外观模式\"> 中介者模式和外观模式</h3>\n<p>外观模式和中介者模式思想上有一些相似的地方，但也有不同：</p>\n<ul>\n<li><strong>中介者模式</strong> 将多个平等对象之间内部的复杂交互关系封装起来，主要目的是为了多个对象之间的解耦。</li>\n<li><strong>外观模式</strong> 封装一个子系统内部的模块，是为了向系统外部提供方便的调用。</li>\n</ul>\n<h3 id=\"中介者模式与观察者模式\"> 中介者模式与观察者模式</h3>\n<p>中介者模式和观察者模式都可以用来进行对象间的解耦，比如观察者模式的发布者/订阅者和中介者模式里面的中介者/同事对象功能上就比较类似。</p>\n<p>这两个模式也可以组合使用，比如中介者模式就可以使用发布-订阅的方式，对相关同事对象进行消息的广播通知。</p>\n<p>比如上面相亲的例子中，注册各方和通知信息就使用了观察者模式。</p>\n<h3 id=\"中介者模式与代理模式\"> 中介者模式与代理模式</h3>\n<p>同事对象之间需要通信的时候，需要经由中介者，这时中介者就相当于同事对象间的代理。所以这时就可以引入代理模式的概念，对同事对象相互访问的时候，起到访问控制、功能扩展等等功能。</p>\n<p>（完）</p>\n",
      "date_published": "2022-03-30T05:39:08.000Z",
      "date_modified": "2022-03-30T05:39:08.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "单例模式",
      "url": "https://www.fedbook.cn/in-depth-learning/design-patterns/singleton-pattern/",
      "id": "https://www.fedbook.cn/in-depth-learning/design-patterns/singleton-pattern/",
      "content_html": "<h1 id=\"单例模式\"> 单例模式</h1>\n<blockquote>\n<p>单例模式可能是设计模式里面最简单的模式了，虽然简单，但在我们日常生活和编程中却经常接触到。</p>\n</blockquote>\n<h2 id=\"介绍\"> 介绍</h2>\n<p>单例模式（Singleton Pattern）又称为单体模式，保证一个类只有一个实例，并提供一个访问它的全局访问点。也就是说，第二次使用同一个类创建新对象的时候，应该得到与第一次创建的对象完全相同的对象。</p>\n<h2 id=\"通俗的示例\"> 通俗的示例</h2>\n<ul>\n<li>登录框：一个系统有好多页面，但登录框只有一个。</li>\n<li>购物车：一个商城有很多的模块，但购物车只有一个，添加商品时都是添加到同一个购物车中。</li>\n</ul>\n<p>编程中也有很多对象我们只需要唯一一个，比如数据库连接、线程池、配置文件缓存、浏览器中的 window/document 等，如果创建多个实例，会带来资源耗费严重，或访问行为不一致等情况。</p>\n<p>类似于数据库连接实例，我们可能频繁使用，但是创建它所需要的开销又比较大，这时只使用一个数据库连接就可以节约很多开销。一些文件的读取场景也类似，如果文件比较大，那么文件读取就是一个比较重的操作。比如这个文件是一个配置文件，那么完全可以将读取到的文件内容缓存一份，每次来读取的时候访问缓存即可，这样也可以达到节约开销的目的。</p>\n<p>在类似场景中，这些例子有以下特点：</p>\n<ul>\n<li>每次访问者来访问，返回的都是同一个实例。</li>\n<li>如果一开始实例没有创建，那么这个特定类需要自行创建这个实例。</li>\n</ul>\n<h2 id=\"单例模式的通用实现\"> 单例模式的通用实现</h2>\n<p>单例模式需要用到 private 的特性，JavaScript 中没有（TypeScript 除外），所以先用 Java 代码对应的单例模式来演示，然后用 JavaScript 来模仿实现。</p>\n<h3 id=\"java-代码实现\"> Java 代码实现</h3>\n<div><pre><code><span>public</span> <span>class</span> <span>SingleObject</span> <span>{</span>\n    <span>// 注意，私有化构造函数，外部不能 new，只能内部 new</span>\n    <span>private</span> <span>SingleObject</span><span>(</span><span>)</span> <span>{</span>\n    <span>}</span>\n    <span>// 唯一被 new 出来的对象</span>\n    <span>private</span> <span>SingleObject</span> instance <span>=</span> <span>null</span><span>;</span>\n    <span>// 获取对象的唯一接口</span>\n    <span>public</span> <span>SingleObject</span> <span>getInstance</span><span>(</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>instance <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            <span>// 只 new 一次</span>\n            instance <span>=</span> <span>new</span> <span>SingleObject</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> instance<span>;</span>\n    <span>}</span>\n\n    <span>// 对象方法</span>\n    <span>public</span> <span>void</span> <span>login</span><span>(</span>username<span>,</span> password<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"login...\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>// 测试代码</span>\n<span>public</span> <span>class</span> <span>SingletonPatternDemo</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>// 如果这样实例化对象，会报编译时错误：构造函数 SingleObject() 时不可见的！</span>\n        <span>// 原因是构造函数已经私有化了，这样可以保证没法在外面初始化很多个实例</span>\n        <span>// SingleObject object = new SingleObject();</span>\n\n        <span>// 获取唯一可用的对象</span>\n        <span>SingleObject</span> object <span>=</span> <span>SingleObject</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>\n        object<span>.</span><span>login</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><h3 id=\"javascript-代码实现\"> JavaScript 代码实现</h3>\n<p>根据上面的 Java 代码实现，我们用 JavaScript 代码来模仿一下。主要有下面几个概念：</p>\n<ul>\n<li><strong>Singleton</strong>：特定类，这是我们需要访问的类，访问者要拿到的是它的实例。</li>\n<li><strong>instance</strong>：单例，是特定类的实例，特定类一般会提供 <code>getInstance</code> 方法来获取该单例。</li>\n<li><strong>getInstance</strong>：获取单例的方法，或者直接由 <code>new</code> 操作符获取。</li>\n</ul>\n<p>这里有几个实现点要关注一下：</p>\n<ul>\n<li>访问时始终返回的是同一个实例。</li>\n<li>自行实例化，无论是一开始加载的时候就创建好，还是在第一次被访问时。</li>\n<li>一般还会提供一个 <code>getInstance</code> 方法用来获取它的实例。</li>\n</ul>\n<p>结构如下：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/singleton-pattern.jpg\" alt=\"单例模式结构图\">\n  <p style=\"text-align: center; color: #888;\">（单例模式结构图）</p>\n</div>\n<p>代码如下：</p>\n<h4 id=\"_1-一个最简单的单例模式\"> 1）一个最简单的单例模式</h4>\n<blockquote>\n<p>复习一个 JS 的小知识点：构造函数中的 <code>this</code> 指向 new 创建的新对象</p>\n</blockquote>\n<div><pre><code><span>class</span> <span>Singleton</span> <span>{</span>\n  <span>static</span> _instance <span>=</span> <span>null</span><span>;</span>  <span>// 存储单例</span>\n\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>Singleton<span>.</span>_instance<span>)</span> <span>{</span>  <span>// 判断是否已经有单例了</span>\n      <span>return</span> Singleton<span>.</span>_instance<span>;</span>\n    <span>}</span>\n    Singleton<span>.</span>_instance <span>=</span> <span>this</span><span>;</span> <span>// this 指向新创建的对象，此处再把它赋值给 _instance 变量</span>\n  <span>}</span>\n\n  <span>// 定义静态方法：无论 new 多少次，只会共享这一个方法</span>\n  <span>static</span> <span>getInstance</span><span>(</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>Singleton<span>.</span>_instance<span>)</span> <span>{</span>  <span>// 判断是否已经有单例了</span>\n      <span>return</span> Singleton<span>.</span>_instance<span>;</span>\n    <span>}</span>\n    <span>return</span> Singleton<span>.</span>_instance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 测试</span>\n<span>const</span> obj1 <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>\n<span>const</span> obj2 <span>=</span> Singleton<span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span><span>'obj1 === obj2'</span><span>,</span> obj1 <span>===</span> obj2<span>)</span><span>;</span>  <span>// 两者必须完全相等</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>这个类在内部维护一个实例，第一次执行 <code>new</code> 的时候判断这个实例有没有创建过，创建过就直接返回，否则走创建流程。</p>\n<p>但这种简单实现有一个缺点，就是维护的实例 <code>_instance</code> 作为静态属性直接暴露，外部可以直接修改。</p>\n<h4 id=\"_2-iife-方式创建单例模式\"> 2）IIFE 方式创建单例模式</h4>\n<p>我们使用立即调用函数 IIFE 将不希望公开的单例实例 <code>_instance</code> 隐藏。这样一来，由于变量 <code>_instance</code> 在闭包的内部，所以外部代码无法直接修改。</p>\n<blockquote>\n<p>以下代码中的 <code>init</code> 是用来处理业务逻辑的代码，不是单例相关逻辑，实际使用中看情况进行修改。</p>\n</blockquote>\n<div><pre><code><span>const</span> Singleton <span>=</span> <span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>\n  <span>let</span> _instance <span>=</span> <span>null</span><span>;</span>  <span>// 存储单例</span>\n    \n  <span>const</span> <span>Singleton</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>_instance<span>)</span> <span>return</span> _instance<span>;</span>  <span>// 判断是否已有单例</span>\n    _instance <span>=</span> <span>this</span><span>;</span>                 <span>// this 指向新创建的对象，此处再把它赋值给 _instance 变量</span>\n    <span>this</span><span>.</span><span>init</span><span>(</span><span>)</span><span>;</span>                      <span>// 初始化操作</span>\n    <span>return</span> _instance<span>;</span>\n  <span>}</span>\n    \n  <span>Singleton</span><span>.</span>prototype<span>.</span><span>init</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>foo <span>=</span> <span>'Singleton Pattern'</span><span>;</span>\n  <span>}</span>\n\n  <span>// 定义静态方法</span>\n  Singleton<span>.</span><span>getInstance</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>_instance<span>)</span> <span>return</span> _instance<span>;</span>\n    _instance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>\n    <span>return</span> _instance<span>;</span>\n  <span>}</span>\n    \n  <span>return</span> Singleton<span>;</span>\n<span>}</span><span>)</span><span>(</span><span>)</span>\n\n<span>// 测试</span>\n<span>const</span> visitor1 <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>\n<span>const</span> visitor2 <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>         <span>// 既可以 new 获取单例</span>\n<span>const</span> visitor3 <span>=</span> Singleton<span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span> <span>// 也可以 getInstance 获取单例</span>\n\nconsole<span>.</span><span>log</span><span>(</span>visitor1 <span>===</span> visitor2<span>)</span><span>;</span>\t<span>// true</span>\nconsole<span>.</span><span>log</span><span>(</span>visitor1 <span>===</span> visitor3<span>)</span><span>;</span>\t<span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>注意，上述代码中 IIFE 内部返回的 <code>Singleton</code> 才是我们真正需要的单例的构造函数，外部的 <code>Singleton</code> 把它和一些单例模式的创建逻辑进行了一些封装。</p>\n<p>这种方法有一个代价就是闭包开销，并且因为 IIFE 操作带来了额外的复杂度，让可读性变差。</p>\n<h4 id=\"_3-块级作用域方式创建单例\"> 3）块级作用域方式创建单例</h4>\n<p>IIFE 方式本质还是通过函数作用域的方式来隐藏内部作用域的变量，有了 ES6 的 let/const 之后，可以通过 <code>{ }</code> 块级作用域的方式来隐藏内部变量：</p>\n<blockquote>\n<p>以下代码中的 <code>init</code> 是用来处理业务逻辑的代码，不是单例相关逻辑，实际使用中看情况进行修改。</p>\n</blockquote>\n<div><pre><code><span>let</span> getInstance<span>;</span>\n\n<span>{</span>\n  <span>let</span> _instance <span>=</span> <span>null</span><span>;</span>  <span>// 存储单例</span>\n    \n  <span>const</span> <span>Singleton</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>_instance<span>)</span> <span>return</span> _instance<span>;</span>  <span>// 判断是否已有单例</span>\n    _instance <span>=</span> <span>this</span><span>;</span>\n    <span>this</span><span>.</span><span>init</span><span>(</span><span>)</span><span>;</span>                      <span>// 初始化操作</span>\n    <span>return</span> _instance<span>;</span>\n  <span>}</span>\n    \n  <span>Singleton</span><span>.</span>prototype<span>.</span><span>init</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>foo <span>=</span> <span>'Singleton Pattern'</span><span>;</span>\n  <span>}</span>\n    \n  <span>getInstance</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>_instance<span>)</span> <span>return</span> _instance<span>;</span>\n    _instance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>\n    <span>return</span> _instance<span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 测试</span>\n<span>const</span> visitor1 <span>=</span> <span>getInstance</span><span>(</span><span>)</span><span>;</span>\n<span>const</span> visitor2 <span>=</span> <span>getInstance</span><span>(</span><span>)</span><span>;</span>\n\nconsole<span>.</span><span>log</span><span>(</span>visitor1 <span>===</span> visitor2<span>)</span><span>;</span>  <span>// 两者必须完全相等</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>这种对块级作用域的用法是不是很巧妙！</p>\n<h4 id=\"_4-单例模式赋能\"> 4）单例模式赋能</h4>\n<p>之前的例子中，单例模式的创建逻辑和原先这个类的一些功能逻辑（比如 <code>init</code> 等操作）混杂在一起，根据<strong>单一职责原则</strong>，这个例子我们还可以继续改进一下，将单例模式的创建逻辑和特定类的功能逻辑拆开，这样功能逻辑就可以和正常的类一样。</p>\n<blockquote>\n<p>以下代码中的 <code>FuncClass</code> 是业务逻辑类，不是单例相关逻辑，实际使用中看情况进行修改。</p>\n</blockquote>\n<div><pre><code><span>/* 功能类 */</span>\n<span>class</span> <span>FuncClass</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>bar</span><span>)</span> <span>{</span> \n    <span>this</span><span>.</span>bar <span>=</span> bar<span>;</span>\n    <span>this</span><span>.</span><span>init</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n    \n  <span>init</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>foo <span>=</span> <span>'Singleton Pattern'</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* 单例模式的赋能类 */</span>\n<span>const</span> Singleton <span>=</span> <span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>\n  <span>let</span> _instance <span>=</span> <span>null</span><span>;</span>  <span>// 存储单例</span>\n    \n  <span>const</span> <span>ProxySingleton</span> <span>=</span> <span>function</span><span>(</span><span>bar</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>_instance<span>)</span> <span>return</span> _instance<span>;</span>  <span>// 判断是否已有单例</span>\n    _instance <span>=</span> <span>new</span> <span>FuncClass</span><span>(</span>bar<span>)</span><span>;</span>\n    <span>return</span> _instance<span>;</span>\n  <span>}</span>\n\n  ProxySingleton<span>.</span><span>getInstance</span> <span>=</span> <span>function</span><span>(</span><span>bar</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>_instance<span>)</span> <span>return</span> _instance<span>;</span>\n    _instance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span>bar<span>)</span><span>;</span>\n    <span>return</span> _instance<span>;</span>\n  <span>}</span>\n    \n  <span>return</span> ProxySingleton<span>;</span>\n<span>}</span><span>)</span><span>(</span><span>)</span>\n\n\n<span>// 测试</span>\n<span>const</span> visitor1 <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>'单例1'</span><span>)</span><span>;</span>\n<span>const</span> visitor2 <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>'单例2'</span><span>)</span><span>;</span>\n<span>const</span> visitor3 <span>=</span> Singleton<span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>\n\nconsole<span>.</span><span>log</span><span>(</span>visitor1 <span>===</span> visitor2<span>)</span><span>;</span>\t<span>// true</span>\nconsole<span>.</span><span>log</span><span>(</span>visitor1 <span>===</span> visitor3<span>)</span><span>;</span>\t<span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><p>这样的单例模式赋能类也可被称为<strong>代理类</strong>，将业务类和单例模式的逻辑解耦，把单例的创建逻辑抽象封装出来，有利于业务类的扩展和维护。代理的概念我们将在后面<strong>代理模式</strong>的章节中更加详细地探讨。</p>\n<p>使用类似的概念，配合 ES6 引入的 <code>Proxy</code> 来拦截默认的 <code>new</code> 方式，我们可以写出更简化的单例模式赋能方法：</p>\n<div><pre><code><span>/* Person 类 */</span>\n<span>class</span> <span>Person</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>name<span>,</span> age</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n    <span>this</span><span>.</span>age <span>=</span> age<span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* 单例模式的赋能方法 */</span>\n<span>function</span> <span>Singleton</span><span>(</span><span>FuncClass</span><span>)</span> <span>{</span>\n  <span>let</span> _instance<span>;</span>\n  <span>return</span> <span>new</span> <span>Proxy</span><span>(</span>FuncClass<span>,</span> <span>{</span>\n    <span>construct</span><span>(</span><span>target<span>,</span> args</span><span>)</span> <span>{</span>\n      <span>return</span> _instance <span>||</span> <span>(</span>_instance <span>=</span> Reflect<span>.</span><span>construct</span><span>(</span>FuncClass<span>,</span> args<span>)</span><span>)</span><span>;</span> <span>// 使用 new FuncClass(...args) 也可以</span>\n    <span>}</span>\n  <span>}</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>// 测试</span>\n<span>const</span> PersonInstance <span>=</span> <span>Singleton</span><span>(</span>Person<span>)</span><span>;</span>\n\n<span>const</span> person1 <span>=</span> <span>new</span> <span>PersonInstance</span><span>(</span><span>'张三'</span><span>,</span> <span>13</span><span>)</span><span>;</span>\n<span>const</span> person2 <span>=</span> <span>new</span> <span>PersonInstance</span><span>(</span><span>'李四'</span><span>,</span> <span>14</span><span>)</span><span>;</span>\n\nconsole<span>.</span><span>log</span><span>(</span>person1 <span>===</span> person2<span>)</span><span>;</span> <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h3 id=\"惰性单例、懒汉式-饿汉式\"> 惰性单例、懒汉式-饿汉式</h3>\n<p>有时候一个实例化过程比较耗费性能的类，但是却一直用不到，如果一开始就对这个类进行实例化就显得有些浪费，那么这时我们就可以使用<strong>惰性创建</strong>，即延迟创建该类的单例。之前的例子都属于惰性单例，实例的创建都是 <code>new</code> 的时候才进行。</p>\n<p>惰性单例又被成为<strong>懒汉式</strong>，相对应的概念是<strong>饿汉式</strong>：</p>\n<ul>\n<li>懒汉式单例是在使用时才实例化</li>\n<li>饿汉式是当程序启动时或单例模式类一加载的时候就被创建</li>\n</ul>\n<p>举一个简单的例子比较一下：</p>\n<div><pre><code><span>class</span> <span>FuncClass</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span> <span>this</span><span>.</span>bar <span>=</span> <span>'bar'</span> <span>}</span><span>;</span>\n<span>}</span>\n\n<span>// 饿汉式</span>\n<span>const</span> HungrySingleton <span>=</span> <span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>\n  <span>const</span> _instance <span>=</span> <span>new</span> <span>FuncClass</span><span>(</span><span>)</span><span>;</span>\n    \n  <span>return</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> _instance<span>;</span>\n  <span>}</span>\n<span>}</span><span>)</span><span>(</span><span>)</span>\n\n<span>// 懒汉式</span>\n<span>const</span> LazySingleton <span>=</span> <span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>\n  <span>let</span> _instance <span>=</span> <span>null</span><span>;</span>\n    \n  <span>return</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> _instance <span>||</span> <span>(</span>_instance <span>=</span> <span>new</span> <span>FuncClass</span><span>(</span><span>)</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span><span>)</span><span>(</span><span>)</span>\n\n<span>// 测试</span>\n<span>const</span> visitor1 <span>=</span> <span>new</span> <span>HungrySingleton</span><span>(</span><span>)</span><span>;</span>\n<span>const</span> visitor2 <span>=</span> <span>new</span> <span>HungrySingleton</span><span>(</span><span>)</span><span>;</span>\n<span>const</span> visitor3 <span>=</span> <span>new</span> <span>LazySingleton</span><span>(</span><span>)</span><span>;</span>\n<span>const</span> visitor4 <span>=</span> <span>new</span> <span>LazySingleton</span><span>(</span><span>)</span><span>;</span>\n\nconsole<span>.</span><span>log</span><span>(</span>visitor1 <span>===</span> visitor2<span>)</span>\t<span>// true</span>\nconsole<span>.</span><span>log</span><span>(</span>visitor3 <span>===</span> visitor4<span>)</span>\t<span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>通过打上 <code>debugger</code> 可以在控制台中观察到：</p>\n<ul>\n<li>饿汉式在 <code>HungrySingleton</code> 这个 IIFE 执行的时候就进入到 <code>FuncClass</code> 的实例化流程了。</li>\n<li>懒汉式的 <code>LazySingleton</code> 中 <code>FuncClass</code> 的实例化过程是在第一次 <code>new</code> 的时候才进行的。</li>\n</ul>\n<p>惰性创建在实际开发中使用很普遍，了解一下对以后的开发工作很有帮助。</p>\n<h2 id=\"单例模式的实际应用\"> 单例模式的实际应用</h2>\n<h3 id=\"模拟登录框\"> 模拟登录框</h3>\n<div><pre><code><span>class</span> <span>LoginForm</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>state <span>=</span> <span>'hide'</span><span>;</span>\n  <span>}</span>\n  <span>show</span><span>(</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>this</span><span>.</span>state <span>===</span> <span>'show'</span><span>)</span> <span>{</span>\n      console<span>.</span><span>log</span><span>(</span><span>'登录框已经显示'</span><span>)</span><span>;</span>\n      <span>return</span><span>;</span>\n    <span>}</span>\n    <span>this</span><span>.</span>state <span>=</span> <span>'show'</span><span>;</span>\n    console<span>.</span><span>log</span><span>(</span><span>'登录框显示成功'</span><span>)</span><span>;</span>\n  <span>}</span>\n  <span>hide</span><span>(</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>this</span><span>.</span>state <span>===</span> <span>'hide'</span><span>)</span> <span>{</span>\n      console<span>.</span><span>log</span><span>(</span><span>'登录框已经隐藏'</span><span>)</span><span>;</span>\n      <span>return</span><span>;</span>\n    <span>}</span>\n    <span>this</span><span>.</span>state <span>=</span> <span>'hide'</span><span>;</span>\n    console<span>.</span><span>log</span><span>(</span><span>'登录框隐藏成功'</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 定义获取单例的静态方法</span>\n<span>// 自执行函数的目的是方便里面添加闭包变量，防止把变量添加在外面造成变量污染</span>\nLoginForm<span>.</span>getInstance <span>=</span> <span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>\n  <span>let</span> _instance<span>;</span> <span>// 闭包</span>\n  <span>return</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>!</span>_instance<span>)</span> <span>{</span>\n      _instance <span>=</span> <span>new</span> <span>LoginForm</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> _instance<span>;</span>\n  <span>}</span>\n<span>}</span><span>)</span><span>(</span><span>)</span>\n\n<span>// 测试</span>\n<span>let</span> login1 <span>=</span> LoginForm<span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>\nlogin1<span>.</span><span>show</span><span>(</span><span>)</span><span>;</span>\n<span>let</span> login2 <span>=</span> LoginForm<span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>\nlogin2<span>.</span><span>show</span><span>(</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span><span>'login1 === login2'</span><span>,</span> login1 <span>===</span> login2<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><h3 id=\"elementui-中的-loading\"> ElementUI 中的 Loading</h3>\n<p>以 ElementUI 为例，ElementUI 中的全屏 Loading 蒙层调用有两种形式：</p>\n<div><pre><code><span>// 1. 指令形式</span>\nVue<span>.</span><span>use</span><span>(</span>Loading<span>.</span>directive<span>)</span>\n<span>// 2. 服务形式</span>\n<span>Vue</span><span>.</span>prototype<span>.</span>$loading <span>=</span> service\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>\n<li>上面的是指令形式注册，使用的方式 <code>&lt;div :v-loading.fullscreen=&quot;true&quot;&gt;...&lt;/div&gt;</code></li>\n<li>下面的是服务形式注册，使用的方式 <code>this.$loading({ fullscreen: true })</code></li>\n</ul>\n<p>用服务方式使用全屏 Loading 是单例的，即在前一个全屏 Loading 关闭前再次调用全屏 Loading，并不会创建一个新的 Loading 实例，而是返回现有全屏 Loading 的实例。</p>\n<p>下面我们可以看看 ElementUI 2.9.2 的<a href=\"https://github.com/ElemeFE/element/blob/v2.9.2/packages/loading/src/index.js\" target=\"_blank\" rel=\"noopener noreferrer\">源码</a>是如何实现的，为了观看方便，省略了部分代码：</p>\n<div><pre><code><span>import</span> Vue <span>from</span> <span>'vue'</span>\n<span>import</span> loadingVue <span>from</span> <span>'./loading.vue'</span>\n\n<span>const</span> LoadingConstructor <span>=</span> Vue<span>.</span><span>extend</span><span>(</span>loadingVue<span>)</span>\n\n<span>let</span> fullscreenLoading\n\n<span>const</span> <span>Loading</span> <span>=</span> <span>(</span><span>options <span>=</span> <span>{</span><span>}</span></span><span>)</span> <span>=></span> <span>{</span>\n  <span>if</span> <span>(</span>options<span>.</span>fullscreen <span>&amp;&amp;</span> fullscreenLoading<span>)</span> <span>{</span>\n    <span>return</span> fullscreenLoading\n  <span>}</span>\n\n  <span>let</span> instance <span>=</span> <span>new</span> <span>LoadingConstructor</span><span>(</span><span>{</span>\n    el<span>:</span> document<span>.</span><span>createElement</span><span>(</span><span>'div'</span><span>)</span><span>,</span>\n    data<span>:</span> options\n  <span>}</span><span>)</span>\n\n  <span>if</span> <span>(</span>options<span>.</span>fullscreen<span>)</span> <span>{</span>\n    fullscreenLoading <span>=</span> instance\n  <span>}</span>\n  <span>return</span> instance\n<span>}</span>\n\n<span>export</span> <span>default</span> Loading\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>这里的单例是 <code>fullscreenLoading</code>，是存放在闭包中的，如果用户传的 <code>options</code> 的 <code>fullscreen</code> 为 <code>true</code> 且已经创建了单例的情况下则回直接返回之前创建的单例，如果之前没有创建过，则创建单例并赋值给闭包中的 <code>fullscreenLoading</code> 后返回新创建的单例实例。</p>\n<p>这是一个典型的单例模式的应用，通过复用之前创建的全屏蒙层单例，不仅减少了实例化过程，而且避免了蒙层叠加蒙层出现的底色变深的情况。</p>\n<h3 id=\"其他\"> 其他</h3>\n<ul>\n<li>购物车（和登录框类似）</li>\n<li>vuex 和 redux 中的 store</li>\n</ul>\n<h2 id=\"设计原则验证\"> 设计原则验证</h2>\n<ul>\n<li>符合单一职责原则，只实例化唯一的对象（意思是初始化的动作都放到 <code>getInstance</code> 函数里去了，没有交给外面的人来做）</li>\n<li>没法具体体现开放封闭原则，但是绝对不违反开放封闭原则</li>\n</ul>\n<h2 id=\"单例模式的优缺点\"> 单例模式的优缺点</h2>\n<p>单例模式主要解决的问题就是<strong>节约资源，保持访问一致性</strong>。</p>\n<p>优点：</p>\n<ul>\n<li>单例模式在创建后在内存中只存在一个实例，节约了内存开支和实例化时的性能开支，特别是需要重复使用一个创建开销比较大的类时，比起实例不断地销毁和重新实例化，单例能节约更多资源，比如数据库连接。</li>\n<li>单例模式可以解决对资源的多重占用，比如写文件操作时，因为只有一个实例，可以避免对一个文件进行同时操作。</li>\n<li>只使用一个实例，也可以减小垃圾回收机制 GC（Garbage Collection）的压力，表现在浏览器中就是系统卡顿减少，操作更流畅，CPU 资源占用更少。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>单例模式对扩展不友好，一般<strong>不容易扩展</strong>，因为单例模式一般自行实例化，没有接口。</li>\n<li><strong>与单一职责原则冲突</strong>，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化（从这个方面来讲确实）。</li>\n</ul>\n<h2 id=\"单例模式的适用场景\"> 单例模式的适用场景</h2>\n<p>那在什么时候使用单例模式呢：</p>\n<ul>\n<li>当一个类的<strong>实例化过程消耗的资源过多</strong>，可以使用单例模式来避免性能浪费。</li>\n<li>当项目中需要一个公共的状态，那么需要使用单例模式来<strong>保证访问一致性</strong>。</li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-03-20T14:29:26.000Z",
      "date_modified": "2022-03-24T13:58:55.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "状态模式",
      "url": "https://www.fedbook.cn/in-depth-learning/design-patterns/state-pattern/",
      "id": "https://www.fedbook.cn/in-depth-learning/design-patterns/state-pattern/",
      "content_html": "<h1 id=\"状态模式\"> 状态模式</h1>\n<h2 id=\"介绍\"> 介绍</h2>\n<p>状态模式（State Pattern）允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类，类的行为随着它的状态改变而改变。</p>\n<p>当程序需要根据不同的外部情况来做出不同操作时，最直接的方法就是使用 <code>switch-case</code> 或 <code>if-else</code> 语句将这些可能发生的情况全部兼顾到，但是这种做法应付复杂一点的状态判断时就有点力不从心，开发者得找到合适的位置添加或修改代码，这个过程很容易出错，这时引入状态模式可以某种程度上缓解这个问题。</p>\n<p>简单地说就是：</p>\n<ul>\n<li>一个对象有状态变化</li>\n<li>每次状态变化都会触发一个逻辑</li>\n<li>不能总是用 <code>if-else</code> 来控制</li>\n</ul>\n<h2 id=\"通俗的示例\"> 通俗的示例</h2>\n<ul>\n<li>交通信号灯不同颜色的变化：红灯停，绿灯行，黄灯亮了等一等</li>\n<li>下载文件时候的状态：比如下载验证、下载中、暂停下载、下载完毕、失败，文件在不同状态下表现的行为不一样。</li>\n</ul>\n<p>在这些场景中，有以下特点：</p>\n<ul>\n<li>对象有有限多个状态，且状态间可以相互切换。</li>\n<li>各个状态和对象的行为逻辑有比较强的对应关系，即在不同状态时，对应的处理逻辑不一样。</li>\n</ul>\n<h2 id=\"状态模式的通用实现\"> 状态模式的通用实现</h2>\n<p>使用 JavaScript 来将上面的交通灯例子实现一下。</p>\n<p>如果通过 <code>if-else</code> 或 <code>switch-case</code> 来区分不同状态的处理逻辑，会存在这样的问题：在添加新的状态时，比如增加了 <code>蓝灯</code>、<code>紫灯</code> 等颜色及其处理逻辑的时候，需要到每个状态里找到相应的地方修改。业务处理逻辑越复杂，找到要修改的状态就不容易，特别是如果是别人的代码，或者接手遗留项目时，需要看完这个 <code>if-else</code> 的分支处理逻辑，新增或修改分支逻辑的过程中也很容易引入 Bug。</p>\n<p>因此我们可以把每种状态和对应的处理逻辑封装在一起，放到一个状态类中：</p>\n<div><pre><code><span>/* 抽象状态类 */</span>\n<span>class</span> <span>AbstractState</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>new</span><span>.</span>target <span>===</span> AbstractState<span>)</span> <span>{</span>\n      <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>'抽象类不能直接实例化!'</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n\n  <span>/* 抽象方法 */</span>\n  <span>employ</span><span>(</span><span>)</span> <span>{</span>\n    <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>'抽象方法不能调用!'</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* 交通灯状态类 */</span>\n<span>class</span> <span>State</span> <span>extends</span> <span>AbstractState</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>name<span>,</span> desc</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span><span>)</span><span>;</span>\n    <span>this</span><span>.</span>color <span>=</span> <span>{</span> name<span>,</span> desc <span>}</span><span>;</span>\n  <span>}</span>\n\n  <span>/* 覆盖抽象方法 */</span>\n  <span>employ</span><span>(</span><span>trafficLight</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'交通灯颜色变为 '</span> <span>+</span> <span>this</span><span>.</span>color<span>.</span>name <span>+</span> <span>'，'</span> <span>+</span> <span>this</span><span>.</span>color<span>.</span>desc<span>)</span><span>;</span>\n    trafficLight<span>.</span><span>setState</span><span>(</span><span>this</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* 交通灯类 */</span>\n<span>class</span> <span>TrafficLight</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>state <span>=</span> <span>null</span><span>;</span>\n  <span>}</span>\n\n  <span>/* 获取交通灯状态 */</span>\n  <span>getState</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span>state<span>;</span>\n  <span>}</span>\n\n  <span>/* 设置交通灯状态 */</span>\n  <span>setState</span><span>(</span><span>state</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>state <span>=</span> state<span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>const</span> trafficLight <span>=</span> <span>new</span> <span>TrafficLight</span><span>(</span><span>)</span><span>;</span>\n\n<span>const</span> greenState <span>=</span> <span>new</span> <span>State</span><span>(</span><span>'绿色'</span><span>,</span> <span>'可以通行'</span><span>)</span><span>;</span>\n<span>const</span> yellowState <span>=</span> <span>new</span> <span>State</span><span>(</span><span>'黄色'</span><span>,</span> <span>'大家等一等'</span><span>)</span><span>;</span>\n<span>const</span> redState <span>=</span> <span>new</span> <span>State</span><span>(</span><span>'红色'</span><span>,</span> <span>'都给我停下来'</span><span>)</span><span>;</span>\n\ngreenState<span>.</span><span>employ</span><span>(</span>trafficLight<span>)</span><span>;</span>  <span>// 输出： 交通灯颜色变为 绿色，可以通行</span>\nyellowState<span>.</span><span>employ</span><span>(</span>trafficLight<span>)</span><span>;</span> <span>// 输出： 交通灯颜色变为 黄色，大家等一等</span>\nredState<span>.</span><span>employ</span><span>(</span>trafficLight<span>)</span><span>;</span>    <span>// 输出： 交通灯颜色变为 红色，都给我停下来</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br></div></div><p>这里的不同状态是同一个类的类实例，比如 <code>redState</code> 这个类实例，就把所有红灯状态处理的逻辑封装起来，如果要把状态切换为红灯状态，那么只需要 <code>redState.employ()</code> 把交通灯的状态切换为红色，并且把交通灯对应的行为逻辑也切换为红灯状态。</p>\n<p>如果要新建状态，不用修改原有代码，只要加上下面的代码：</p>\n<div><pre><code><span>// 接上面</span>\n\n<span>const</span> blueState <span>=</span> <span>new</span> <span>State</span><span>(</span><span>'蓝色'</span><span>,</span> <span>'这是要干啥'</span><span>)</span>\n\nblueState<span>.</span><span>employ</span><span>(</span>trafficLight<span>)</span>    <span>// 输出： 交通灯颜色变为 蓝色，这是要干啥</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>传统的状态区分一般是基于状态类扩展的不同状态类，如何实现看需求具体了，比如逻辑比较复杂，通过新建状态实例的方法已经不能满足需求，那么可以使用状态类的方式。</p>\n<p>这里提供一个状态类的实现，同时引入状态的切换逻辑：</p>\n<div><pre><code><span>/* 抽象状态类 */</span>\n<span>class</span> <span>AbstractState</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>new</span><span>.</span>target <span>===</span> AbstractState<span>)</span> <span>{</span>\n      <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>'抽象类不能直接实例化!'</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n\n  <span>/* 抽象方法 */</span>\n  <span>employ</span><span>(</span><span>)</span> <span>{</span>\n    <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>'抽象方法不能调用!'</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>changeState</span><span>(</span><span>)</span> <span>{</span>\n    <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>'抽象方法不能调用!'</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* 交通灯类-绿灯 */</span>\n<span>class</span> <span>GreenState</span> <span>extends</span> <span>AbstractState</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span><span>)</span><span>;</span>\n    <span>this</span><span>.</span>colorState <span>=</span> <span>'绿色'</span><span>;</span>\n  <span>}</span>\n\n  <span>/* 覆盖抽象方法 */</span>\n  <span>employ</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'交通灯颜色变为 '</span> <span>+</span> <span>this</span><span>.</span>colorState <span>+</span> <span>'，可以通行'</span><span>)</span><span>;</span>\n    <span>// 省略业务相关操作</span>\n  <span>}</span>\n\n  <span>changeState</span><span>(</span><span>trafficLight</span><span>)</span> <span>{</span>\n    trafficLight<span>.</span><span>setState</span><span>(</span>trafficLight<span>.</span>yellowState<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* 交通灯类-黄灯 */</span>\n<span>class</span> <span>YellowState</span> <span>extends</span> <span>AbstractState</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span><span>)</span><span>;</span>\n    <span>this</span><span>.</span>colorState <span>=</span> <span>'黄色'</span><span>;</span>\n  <span>}</span>\n\n  <span>/* 覆盖抽象方法 */</span>\n  <span>employ</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'交通灯颜色变为 '</span> <span>+</span> <span>this</span><span>.</span>colorState <span>+</span> <span>'，大家等一等'</span><span>)</span><span>;</span>\n    <span>// 省略业务相关操作</span>\n  <span>}</span>\n\n  <span>changeState</span><span>(</span><span>trafficLight</span><span>)</span> <span>{</span>\n    trafficLight<span>.</span><span>setState</span><span>(</span>trafficLight<span>.</span>redState<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* 交通灯类-红灯 */</span>\n<span>class</span> <span>RedState</span> <span>extends</span> <span>AbstractState</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span><span>)</span><span>;</span>\n    <span>this</span><span>.</span>colorState <span>=</span> <span>'红色'</span><span>;</span>\n  <span>}</span>\n\n  <span>/* 覆盖抽象方法 */</span>\n  <span>employ</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'交通灯颜色变为 '</span> <span>+</span> <span>this</span><span>.</span>colorState <span>+</span> <span>'，都给我停下来'</span><span>)</span><span>;</span>\n    <span>// 省略业务相关操作</span>\n  <span>}</span>\n\n  <span>changeState</span><span>(</span><span>trafficLight</span><span>)</span> <span>{</span>\n    trafficLight<span>.</span><span>setState</span><span>(</span>trafficLight<span>.</span>greenState<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* 交通灯类 */</span>\n<span>class</span> <span>TrafficLight</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>greenState <span>=</span> <span>new</span> <span>GreenState</span><span>(</span><span>)</span><span>;</span>\n    <span>this</span><span>.</span>yellowState <span>=</span> <span>new</span> <span>YellowState</span><span>(</span><span>)</span><span>;</span>\n    <span>this</span><span>.</span>redState <span>=</span> <span>new</span> <span>RedState</span><span>(</span><span>)</span><span>;</span>\n\n    <span>this</span><span>.</span>state <span>=</span> <span>this</span><span>.</span>greenState<span>;</span>\n  <span>}</span>\n\n  <span>/* 设置交通灯状态 */</span>\n  <span>setState</span><span>(</span><span>state</span><span>)</span> <span>{</span>\n    state<span>.</span><span>employ</span><span>(</span><span>this</span><span>)</span><span>;</span>\n    <span>this</span><span>.</span>state <span>=</span> state<span>;</span>\n  <span>}</span>\n\n  <span>changeState</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>state<span>.</span><span>changeState</span><span>(</span><span>this</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n\n<span>const</span> trafficLight <span>=</span> <span>new</span> <span>TrafficLight</span><span>(</span><span>)</span><span>;</span>\n\ntrafficLight<span>.</span><span>changeState</span><span>(</span><span>)</span><span>;</span>   <span>// 输出：交通灯颜色变为 黄色，大家等一等</span>\ntrafficLight<span>.</span><span>changeState</span><span>(</span><span>)</span><span>;</span>   <span>// 输出：交通灯颜色变为 红色，都给我停下来</span>\ntrafficLight<span>.</span><span>changeState</span><span>(</span><span>)</span><span>;</span>   <span>// 输出：交通灯颜色变为 绿色，可以通行</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br></div></div><p>如果我们要增加新的交通灯颜色，也是很方便的：</p>\n<div><pre><code><span>// 接上面</span>\n\n<span>/* 交通灯类-蓝灯 */</span>\n<span>class</span> <span>BlueState</span> <span>extends</span> <span>AbstractState</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span><span>)</span><span>;</span>\n    <span>this</span><span>.</span>colorState <span>=</span> <span>'蓝色'</span><span>;</span>\n  <span>}</span>\n\n  <span>/* 覆盖抽象方法 */</span>\n  <span>employ</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'交通灯颜色变为 '</span> <span>+</span> <span>this</span><span>.</span>colorState <span>+</span> <span>'，这是要干啥'</span><span>)</span><span>;</span>\n    <span>const</span> redDom <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'color-blue'</span><span>)</span><span>;</span>\n    redDom<span>.</span><span>click</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>const</span> blueState <span>=</span> <span>new</span> <span>BlueState</span><span>(</span><span>)</span><span>;</span>\n\ntrafficLight<span>.</span><span>employ</span><span>(</span>blueState<span>)</span><span>;</span>    <span>// 输出：交通灯颜色变为 蓝色，这是要干啥</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>对原来的代码没有修改，非常符合开闭原则了。</p>\n<h2 id=\"状态模式的原理\"> 状态模式的原理</h2>\n<p>所谓对象的状态，通常指的就是对象实例的属性的值。行为指的就是对象的功能，行为大多可以对应到方法上。状态模式把状态和状态对应的行为从原来的大杂烩代码中分离出来，把每个状态所对应的功能处理封装起来，这样选择不同状态的时候，其实就是在选择不同的状态处理类。</p>\n<p>也就是说，状态和行为是相关联的，它们的关系可以描述总结成：<strong>状态决定行为</strong>。由于状态是在运行期被改变的，因此行为也会在运行期根据状态的改变而改变，看起来，同一个对象，在不同的运行时刻，行为是不一样的，就像是类被修改了一样。</p>\n<p>为了提取不同的状态类共同的外观，可以给状态类定义一个共同的状态接口或抽象类，正如之前最后的两个代码示例一样，这样可以面向统一的接口编程，无须关心具体的状态类实现。</p>\n<h2 id=\"设计原则验证\"> 设计原则验证</h2>\n<ul>\n<li>将状态对象和主题对象分离，状态的变化逻辑单独处理</li>\n<li>符合开放封闭原则</li>\n</ul>\n<h2 id=\"状态模式的优缺点\"> 状态模式的优缺点</h2>\n<p>优点：</p>\n<ul>\n<li><strong>结构相比之下清晰</strong>，避免了过多的 <code>switch-case</code> 或 <code>if-else</code> 语句的使用，避免了程序的复杂性提高系统的可维护性。</li>\n<li><strong>符合开闭原则</strong>，每个状态都是一个子类，增加状态只需增加新的状态类即可，修改状态也只需修改对应状态类就可以了。</li>\n<li><strong>封装性良好</strong>，状态的切换在类的内部实现，外部的调用无需知道类内部如何实现状态和行为的变换。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>引入了多余的类，每个状态都有对应的类，导致系统中类的个数增加。</li>\n</ul>\n<h2 id=\"状态模式的适用场景\"> 状态模式的适用场景</h2>\n<ul>\n<li>操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态，那么可以使用状态模式来将分支的处理分散到单独的状态类中。</li>\n<li>对象的行为随着状态的改变而改变，那么可以考虑状态模式，来把状态和行为分离，虽然分离了，但是状态和行为是对应的，再通过改变状态调用状态对应的行为。</li>\n</ul>\n<h2 id=\"其他相关模式\"> 其他相关模式</h2>\n<h3 id=\"状态模式和策略模式\"> 状态模式和策略模式</h3>\n<p>状态模式和策略模式在之前的代码就可以看出来，看起来比较类似，他们的区别：</p>\n<ul>\n<li><strong>状态模式</strong>：重在强调对象内部状态的变化改变对象的行为，状态类之间是<strong>平行</strong>的，无法相互替换。</li>\n<li><strong>策略模式</strong>：策略的选择由外部条件决定，策略可以动态的切换，策略之间是<strong>平等</strong>的，可以相互替换。</li>\n</ul>\n<p>状态模式的状态类是<strong>平行</strong>的，意思是各个状态类封装的状态和对应的行为是相互独立、没有关联的，封装的业务逻辑可能差别很大毫无关联，相互之间不可替换。但是策略模式中的策略是<strong>平等</strong>的，是同一行为的不同描述或者实现，在同一个行为发生的时候，可以根据外部条件挑选任意一个实现来进行处理</p>\n<h3 id=\"状态模式和观察者模式\"> 状态模式和观察者模式</h3>\n<p>这两个模式都是在状态发生改变的时候触发行为，不过观察者模式的行为是固定的，那就是通知所有的订阅者，而状态模式是根据状态来选择不同的处理逻辑。</p>\n<ul>\n<li><strong>状态模式</strong>：根据状态来分离行为，当状态发生改变的时候，动态地改变行为。</li>\n<li><strong>观察者模式</strong>：发布者在消息发生时通知订阅者，具体如何处理则不在乎，或者直接丢给用户自己处理。</li>\n</ul>\n<p>这两个模式是可以组合使用的，比如在观察者模式的发布消息部分，当对象的状态发生了改变，触发通知了所有的订阅者后，可以引入状态模式，根据通知过来的状态选择相应的处理。</p>\n<h3 id=\"状态模式和单例模式\"> 状态模式和单例模式</h3>\n<p>之前的示例代码中，状态类每次使用都 <code>new</code> 出来一个状态实例，实际上使用同一个实例即可，因此可以引入单例模式，不同的状态类可以返回的同一个实例。</p>\n<p>（完）</p>\n",
      "date_published": "2022-03-27T07:56:06.000Z",
      "date_modified": "2022-03-27T07:56:06.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "策略模式",
      "url": "https://www.fedbook.cn/in-depth-learning/design-patterns/strategy-pattern/",
      "id": "https://www.fedbook.cn/in-depth-learning/design-patterns/strategy-pattern/",
      "content_html": "<h1 id=\"策略模式\"> 策略模式</h1>\n<h2 id=\"介绍\"> 介绍</h2>\n<p>策略模式（Strategy Pattern）又称政策模式，其定义一系列的算法，把它们一个个封装起来，并且使它们可以互相替换。封装的策略算法一般是独立的，策略模式根据输入来调整采用哪个算法。关键是策略的<strong>实现和使用分离</strong>。</p>\n<h2 id=\"通俗的示例\"> 通俗的示例</h2>\n<p>简单来说就是不同策略分开处理，避免出现大量 <code>if...else</code> 或者 <code>switch... case</code>。</p>\n<p>例如电商网站在双十一举办活动，有的商品满 100 减 30，有的商品满 200 减 80，有的商品直接 8 折出售，不同商品的优惠策略不一样。</p>\n<p>在这些场景中，有以下特点：</p>\n<ul>\n<li>折扣计算方式（策略）之间相互独立，但又可以相互替换。</li>\n<li>具体折扣的计算过程（封装上下文）可以根据需要的不同选用不同的策略。</li>\n</ul>\n<h2 id=\"策略模式的通用实现\"> 策略模式的通用实现</h2>\n<p>假设要实现上面说的双十一促销折扣功能，不使用策略模式的写法：</p>\n<div><pre><code><span>function</span> <span>priceCalculate</span><span>(</span><span>discountType<span>,</span> price</span><span>)</span> <span>{</span>\n  <span>if</span> <span>(</span>discountType <span>===</span> <span>'minus100_30'</span><span>)</span> <span>{</span>   \t\t<span>// 满100减30</span>\n    <span>return</span> price <span>-</span> Math<span>.</span><span>floor</span><span>(</span>price <span>/</span> <span>100</span><span>)</span> <span>*</span> <span>30</span><span>;</span>\n  <span>}</span>\n  <span>else</span> <span>if</span> <span>(</span>discountType <span>===</span> <span>'minus200_80'</span><span>)</span> <span>{</span>    <span>// 满200减80</span>\n    <span>return</span> price <span>-</span> Math<span>.</span><span>floor</span><span>(</span>price <span>/</span> <span>200</span><span>)</span> <span>*</span> <span>80</span><span>;</span>\n  <span>}</span>\n  <span>else</span> <span>if</span> <span>(</span>discountType <span>===</span> <span>'percent80'</span><span>)</span> <span>{</span>      <span>// 8折</span>\n    <span>return</span> price <span>*</span> <span>0.8</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>priceCalculate</span><span>(</span><span>'minus100_30'</span><span>,</span> <span>270</span><span>)</span><span>;</span> <span>// 输出: 210</span>\n<span>priceCalculate</span><span>(</span><span>'percent80'</span><span>,</span> <span>250</span><span>)</span><span>;</span>   <span>// 输出: 200</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>通过判断输入的折扣类型来计算商品总价的方式，几个 <code>if-else</code> 就满足了需求，但是这样的做法的缺点也很明显：</p>\n<ul>\n<li><code>priceCalculate</code> 函数随着折扣类型的增多，<code>if-else</code> 判断语句会变得越来越臃肿。</li>\n<li>如果增加了新的折扣类型或者折扣类型的算法有所改变，那么需要更改 <code>priceCalculate</code> 函数的实现，这是违反开放-封闭原则的。</li>\n<li>可复用性差，如果在其他的地方也有类似这样的算法，但规则不一样，上述代码不能复用。</li>\n</ul>\n<p>使用策略模式来写的话，折扣计算方式作为策略，具体折扣的计算过程作为封装上下文，主要有下面几个概念：</p>\n<ul>\n<li><strong>Context</strong>：封装上下文，根据需要调用需要的策略，屏蔽外界对策略的直接调用，只对外提供一个接口，根据需要调用对应的策略。</li>\n<li><strong>Strategy</strong>：策略，含有具体的算法，其方法的外观相同，因此可以互相代替。</li>\n<li><strong>StrategyMap</strong>：所有策略的合集，供封装上下文调用。</li>\n</ul>\n<p>结构如下：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/strategy-pattern.jpg\" alt=\"策略模式结构图\" style=\"width: 640px;\">\n  <p style=\"text-align: center; color: #888;\">（策略模式结构图）</p>\n</div>\n<p>代码如下：</p>\n<div><pre><code><span>// 存储所有策略</span>\n<span>const</span> StrategyMap <span>=</span> <span>{</span><span>}</span>\n\n<span>// 封装上下文</span>\n<span>function</span> <span>context</span><span>(</span><span>type<span>,</span> <span>...</span>rest</span><span>)</span> <span>{</span>\n  <span>return</span> StrategyMap<span>[</span>type<span>]</span> <span>&amp;&amp;</span> StrategyMap<span>[</span>type<span>]</span><span>(</span><span>...</span>rest<span>)</span>\n<span>}</span>\n\n<span>// 增加策略</span>\nStrategyMap<span>.</span><span>minus100_30</span> <span>=</span> <span>function</span><span>(</span><span>price</span><span>)</span> <span>{</span>\n  <span>return</span> price <span>-</span> Math<span>.</span><span>floor</span><span>(</span>price <span>/</span> <span>100</span><span>)</span> <span>*</span> <span>30</span>\n<span>}</span>\n<span>// 调用策略</span>\n<span>context</span><span>(</span><span>'minus100_30'</span><span>,</span> <span>270</span><span>)</span>\t<span>// 输出: 210</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>这样就能很方便地增加策略，便于扩展。</p>\n<h2 id=\"策略模式的实际应用\"> 策略模式的实际应用</h2>\n<h3 id=\"表格-formatter\"> 表格 formatter</h3>\n<p>这里举一个 Vue + ElementUI 项目中用到的例子。</p>\n<p>Element 的表格控件的 Column 接受一个 <code>formatter</code> 参数，用来格式化内容，其类型为函数，并且还可以接受几个特定参数，像这样：<code>Function(row, column, cellValue, index)</code>。</p>\n<p>以文件的大小转化为例，后端经常会直接传 bit 单位的文件大小，那么前端需要根据后端的数据，根据需求转化为自己需要的单位的文件大小，比如 KB/MB。</p>\n<p>首先实现文件大小的计算算法：</p>\n<div><pre><code><span>export</span> <span>const</span> StrategyMap <span>=</span> <span>{</span>\n  <span>/* Strategy 1: 将文件大小（bit）转化为 KB */</span>\n  <span>bitToKB</span><span>:</span> <span>val</span> <span>=></span> <span>{</span>\n    <span>const</span> num <span>=</span> <span>Number</span><span>(</span>val<span>)</span>\n    <span>return</span> <span>isNaN</span><span>(</span>num<span>)</span> <span>?</span> val <span>:</span> <span>(</span>num <span>/</span> <span>1024</span><span>)</span><span>.</span><span>toFixed</span><span>(</span><span>0</span><span>)</span> <span>+</span> <span>'KB'</span>\n  <span>}</span><span>,</span>\n  <span>/* Strategy 2: 将文件大小（bit）转化为 MB */</span>\n  <span>bitToMB</span><span>:</span> <span>val</span> <span>=></span> <span>{</span>\n    <span>const</span> num <span>=</span> <span>Number</span><span>(</span>val<span>)</span>\n    <span>return</span> <span>isNaN</span><span>(</span>num<span>)</span> <span>?</span> val <span>:</span> <span>(</span>num <span>/</span> <span>1024</span> <span>/</span> <span>1024</span><span>)</span><span>.</span><span>toFixed</span><span>(</span><span>1</span><span>)</span> <span>+</span> <span>'MB'</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* Context: 生成el表单 formatter */</span>\n<span>const</span> <span>strategyContext</span> <span>=</span> <span>function</span><span>(</span><span>type<span>,</span> rowKey</span><span>)</span><span>{</span>\n  <span>return</span> <span>function</span><span>(</span><span>row<span>,</span> column<span>,</span> cellValue<span>,</span> index</span><span>)</span><span>{</span>\n    <span>return</span> StrategyMap<span>[</span>type<span>]</span><span>(</span>row<span>[</span>rowKey<span>]</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>export</span> <span>default</span> strategyContext\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>那么在组件中我们可以直接：</p>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>el-table</span> <span>:data</span><span><span>=</span><span>\"</span>tableData<span>\"</span></span><span>></span></span>\n    <span><span><span>&lt;</span>el-table-column</span> <span>prop</span><span><span>=</span><span>\"</span>date<span>\"</span></span> <span>label</span><span><span>=</span><span>\"</span>日期<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>el-table-column</span><span>></span></span>\n    <span><span><span>&lt;</span>el-table-column</span> <span>prop</span><span><span>=</span><span>\"</span>name<span>\"</span></span> <span>label</span><span><span>=</span><span>\"</span>文件名<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>el-table-column</span><span>></span></span>\n    <span>&lt;!-- 直接调用 strategyContext --></span>\n    <span><span><span>&lt;</span>el-table-column</span> <span>prop</span><span><span>=</span><span>\"</span>sizeKb<span>\"</span></span> <span>label</span><span><span>=</span><span>\"</span>文件大小(KB)<span>\"</span></span>\n                     <span>:formatter</span><span><span>=</span><span>'</span>strategyContext(<span>\"</span>bitToKB<span>\"</span>, <span>\"</span>sizeKb<span>\"</span>)<span>'</span></span><span>></span></span>\n    <span><span><span>&lt;/</span>el-table-column</span><span>></span></span>\n    <span><span><span>&lt;</span>el-table-column</span> <span>prop</span><span><span>=</span><span>\"</span>sizeMb<span>\"</span></span> <span>label</span><span><span>=</span><span>\"</span>附件大小(MB)<span>\"</span></span>\n                     <span>:formatter</span><span><span>=</span><span>'</span>strategyContext(<span>\"</span>bitToMB<span>\"</span>, <span>\"</span>sizeMb<span>\"</span>)<span>'</span></span><span>></span></span>\n    <span><span><span>&lt;/</span>el-table-column</span><span>></span></span>\n  <span><span><span>&lt;/</span>el-table</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span> <span>type</span><span><span>=</span><span>'</span>text/javascript<span>'</span></span><span>></span></span><span><span>\n<span>import</span> strategyContext <span>from</span> <span>'./strategyContext.js'</span>\n    \n<span>export</span> <span>default</span> <span>{</span>\n  name<span>:</span> <span>'ElTableDemo'</span><span>,</span>\n  <span>data</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>{</span>\n      strategyContext<span>,</span>\n      tableData<span>:</span> <span>[</span>\n        <span>{</span> date<span>:</span> <span>'2022-03-27'</span><span>,</span> name<span>:</span> <span>'文件1'</span><span>,</span> sizeKb<span>:</span> <span>1234</span><span>,</span> sizeMb<span>:</span> <span>1234426</span> <span>}</span><span>,</span>\n        <span>{</span> date<span>:</span> <span>'2022-03-29'</span><span>,</span> name<span>:</span> <span>'文件2'</span><span>,</span> sizeKb<span>:</span> <span>4213</span><span>,</span> sizeMb<span>:</span> <span>8636152</span> <span>}</span>\n      <span>]</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n\n<span><span><span>&lt;</span>style</span> <span>scoped</span><span>></span></span><span></span><span><span><span>&lt;/</span>style</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><h3 id=\"表单验证\"> 表单验证</h3>\n<p>除了表格中的 formatter 之外，策略模式也经常用在表单验证的场景，还是举一个 Vue + ElementUI 项目的例子。</p>\n<p>ElementUI 的 Form 表单 具有表单验证功能，用来校验用户输入的表单内容。实际需求中表单验证项一般会比较复杂，所以需要给每个表单项增加 validator 自定义校验方法。</p>\n<p>我们可以像官网示例一样把表单验证都写在组件的状态 <code>data</code> 函数中，但是这样就不好复用使用频率比较高的表单验证方法了，这时我们可以结合策略模式和函数柯里化的知识来重构一下。首先我们在项目的工具模块（一般是 <code>utils</code> 文件夹）实现通用的表单验证方法：</p>\n<div><pre><code><span>// src/utils/validates.js</span>\n\n<span>/* 姓名校验 由2-10位汉字组成 */</span>\n<span>export</span> <span>function</span> <span>validateUsername</span><span>(</span><span>str</span><span>)</span> <span>{</span>\n  <span>const</span> reg <span>=</span> <span><span>/</span><span>^[\\u4e00-\\u9fa5]{2,10}$</span><span>/</span></span>\n  <span>return</span> reg<span>.</span><span>test</span><span>(</span>str<span>)</span>\n<span>}</span>\n\n<span>/* 手机号校验 由以1开头的11位数字组成  */</span>\n<span>export</span> <span>function</span> <span>validateMobile</span><span>(</span><span>str</span><span>)</span> <span>{</span>\n  <span>const</span> reg <span>=</span> <span><span>/</span><span>^1\\d{10}$</span><span>/</span></span>\n  <span>return</span> reg<span>.</span><span>test</span><span>(</span>str<span>)</span>\n<span>}</span>\n\n<span>/* 邮箱校验 */</span>\n<span>export</span> <span>function</span> <span>validateEmail</span><span>(</span><span>str</span><span>)</span> <span>{</span>\n  <span>const</span> reg <span>=</span> <span><span>/</span><span>^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$</span><span>/</span></span>\n  <span>return</span> reg<span>.</span><span>test</span><span>(</span>str<span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>然后在 <code>utils/index.js</code> 中增加一个柯里化方法，用来生成表单验证函数：</p>\n<div><pre><code><span>// src/utils/index.js</span>\n\n<span>import</span> <span>*</span> <span>as</span> Validates <span>from</span> <span>'./validates.js'</span>\n\n<span>/* 生成表格自定义校验函数 */</span>\n<span>export</span> <span>const</span> <span>formValidateGene</span> <span>=</span> <span>(</span><span>key<span>,</span> msg</span><span>)</span> <span>=></span> <span>(</span><span>rule<span>,</span> value<span>,</span> cb</span><span>)</span> <span>=></span> <span>{</span>\n  <span>if</span> <span>(</span>Validates<span>[</span>key<span>]</span><span>(</span>value<span>)</span><span>)</span> <span>{</span>\n    <span>cb</span><span>(</span><span>)</span>\n  <span>}</span> <span>else</span> <span>{</span>\n    <span>cb</span><span>(</span><span>new</span> <span>Error</span><span>(</span>msg<span>)</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>上面的 <code>formValidateGene</code> 函数接受两个参数，第一个是验证规则，也就是 <code>src/utils/validates.js</code> 文件中提取出来的通用验证规则的方法名，第二个参数是报错的话表单验证的提示信息。</p>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>el-form</span> <span>ref</span><span><span>=</span><span>\"</span>ruleForm<span>\"</span></span>\n           <span>label-width</span><span><span>=</span><span>\"</span>100px<span>\"</span></span>\n           <span>class</span><span><span>=</span><span>\"</span>demo-ruleForm<span>\"</span></span>\n           <span>:rules</span><span><span>=</span><span>\"</span>rules<span>\"</span></span>\n           <span>:model</span><span><span>=</span><span>\"</span>ruleForm<span>\"</span></span><span>></span></span>\n        \n    <span><span><span>&lt;</span>el-form-item</span> <span>label</span><span><span>=</span><span>\"</span>用户名<span>\"</span></span> <span>prop</span><span><span>=</span><span>\"</span>username<span>\"</span></span><span>></span></span>\n      <span><span><span>&lt;</span>el-input</span> <span>v-model</span><span><span>=</span><span>\"</span>ruleForm.username<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>el-input</span><span>></span></span>\n    <span><span><span>&lt;/</span>el-form-item</span><span>></span></span>\n        \n    <span><span><span>&lt;</span>el-form-item</span> <span>label</span><span><span>=</span><span>\"</span>手机号<span>\"</span></span> <span>prop</span><span><span>=</span><span>\"</span>mobile<span>\"</span></span><span>></span></span>\n      <span><span><span>&lt;</span>el-input</span> <span>v-model</span><span><span>=</span><span>\"</span>ruleForm.mobile<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>el-input</span><span>></span></span>\n    <span><span><span>&lt;/</span>el-form-item</span><span>></span></span>\n        \n    <span><span><span>&lt;</span>el-form-item</span> <span>label</span><span><span>=</span><span>\"</span>邮箱<span>\"</span></span> <span>prop</span><span><span>=</span><span>\"</span>email<span>\"</span></span><span>></span></span>\n      <span><span><span>&lt;</span>el-input</span> <span>v-model</span><span><span>=</span><span>\"</span>ruleForm.email<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>el-input</span><span>></span></span>\n    <span><span><span>&lt;/</span>el-form-item</span><span>></span></span>\n  <span><span><span>&lt;/</span>el-form</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span> <span>type</span><span><span>=</span><span>'</span>text/javascript<span>'</span></span><span>></span></span><span><span>\n<span>import</span> <span>*</span> <span>as</span> Utils <span>from</span> <span>'../utils'</span>\n    \n<span>export</span> <span>default</span> <span>{</span>\n  name<span>:</span> <span>'ElTableDemo'</span><span>,</span>\n  <span>data</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>{</span>\n      ruleForm<span>:</span> <span>{</span> pass<span>:</span> <span>''</span><span>,</span> checkPass<span>:</span> <span>''</span><span>,</span> age<span>:</span> <span>''</span> <span>}</span><span>,</span>\n      rules<span>:</span> <span>{</span>\n        username<span>:</span> <span>[</span><span>{</span>\n          validator<span>:</span> Utils<span>.</span><span>formValidateGene</span><span>(</span><span>'validateUsername'</span><span>,</span> <span>'姓名由2-10位汉字组成'</span><span>)</span><span>,</span>\n          trigger<span>:</span> <span>'blur'</span>\n        <span>}</span><span>]</span><span>,</span>\n        mobile<span>:</span> <span>[</span><span>{</span>\n          validator<span>:</span> Utils<span>.</span><span>formValidateGene</span><span>(</span><span>'validateMobile'</span><span>,</span> <span>'手机号由以1开头的11位数字组成'</span><span>)</span><span>,</span>\n          trigger<span>:</span> <span>'blur'</span>\n        <span>}</span><span>]</span><span>,</span>\n        email<span>:</span> <span>[</span><span>{</span>\n          validator<span>:</span> Utils<span>.</span><span>formValidateGene</span><span>(</span><span>'validateEmail'</span><span>,</span> <span>'不是正确的邮箱格式'</span><span>)</span><span>,</span>\n          trigger<span>:</span> <span>'blur'</span>\n        <span>}</span><span>]</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><p>可以看见在使用的时候非常方便，把表单验证方法提取出来作为策略，使用柯里化方法动态选择表单验证方法，从而对策略灵活运用，大大加快开发效率。</p>\n<h2 id=\"设计原则验证\"> 设计原则验证</h2>\n<ul>\n<li>不同策略，分开处理，而不是混合在一起</li>\n<li>符合开放封闭原则</li>\n</ul>\n<h2 id=\"策略模式的优缺点\"> 策略模式的优缺点</h2>\n<p>策略模式将算法的<strong>实现和使用拆分</strong>，这个特点带来了很多优点：</p>\n<ul>\n<li>策略之间相互独立，但<strong>策略可以自由切换</strong>，这个策略模式的特点给策略模式带来很多灵活性，也提高了策略的复用率。</li>\n<li>如果不采用策略模式，那么在选策略时一般会采用多重的条件判断，采用策略模式可以<strong>避免多重条件判断</strong>，增加可维护性。</li>\n<li><strong>可扩展性好</strong>，策略可以很方便的进行扩展。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>策略相互独立，因此一些复杂的算法逻辑<strong>无法共享</strong>，造成一些资源浪费。</li>\n<li>如果用户想采用什么策略，必须了解策略的实现，因此<strong>所有策略都需向外暴露</strong>，这是违背迪米特法则/最少知识原则的，也增加了用户对策略对象的使用成本。</li>\n</ul>\n<h2 id=\"策略模式的适用场景\"> 策略模式的适用场景</h2>\n<p>那么应该在什么场景下使用策略模式呢：</p>\n<ul>\n<li>多个算法<strong>只在行为上稍有不同</strong>的场景，这时可以使用策略模式来动态选择算法。</li>\n<li>算法<strong>需要自由切换</strong>的场景。</li>\n<li>有时<strong>需要多重条件判断</strong>，那么可以使用策略模式来规避多重条件判断的情况。</li>\n</ul>\n<h2 id=\"其他相关模式\"> 其他相关模式</h2>\n<h3 id=\"策略模式和模板方法模式\"> 策略模式和模板方法模式</h3>\n<p>策略模式和模板方法模式的作用比较类似，但是结构和实现方式有点不一样。</p>\n<ul>\n<li><strong>策略模式</strong> 让我们在程序运行的时候动态地指定要使用的算法。</li>\n<li><strong>模板方法模式</strong> 是在子类定义的时候就已经确定了使用的算法。</li>\n</ul>\n<h3 id=\"策略模式和享元模式\"> 策略模式和享元模式</h3>\n<p>见享元模式中的介绍。</p>\n<p>（完）</p>\n",
      "date_published": "2022-03-29T06:05:06.000Z",
      "date_modified": "2022-03-29T06:05:06.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "访问者模式和解释器模式",
      "url": "https://www.fedbook.cn/in-depth-learning/design-patterns/visitor-pattern-and-interpreter-pattern/",
      "id": "https://www.fedbook.cn/in-depth-learning/design-patterns/visitor-pattern-and-interpreter-pattern/",
      "content_html": "<h1 id=\"访问者模式和解释器模式\"> 访问者模式和解释器模式</h1>\n<h2 id=\"访问者模式\"> 访问者模式</h2>\n<p>访问者模式（Visitor Pattern）的概念是将数据操作和数据结构进行分离，但不管是前端还是后端，使用场景都不多。</p>\n<h2 id=\"解释器模式\"> 解释器模式</h2>\n<p>解释器模式（Interpreter Pattern）用于描述语言语法如何定义，如何解释和编译。主要用在一些专业场景（比如 babel 解析 ES6 语法，SCSS、LESS 解析成 CSS 等），此外使用场景都不多。</p>\n<p>（完）</p>\n",
      "date_published": "2022-03-30T06:13:45.000Z",
      "date_modified": "2022-03-30T06:40:43.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "模板方法模式",
      "url": "https://www.fedbook.cn/in-depth-learning/design-patterns/template-method-pattern/",
      "id": "https://www.fedbook.cn/in-depth-learning/design-patterns/template-method-pattern/",
      "content_html": "<h1 id=\"模板方法模式\"> 模板方法模式</h1>\n<h2 id=\"介绍\"> 介绍</h2>\n<p>模板方法模式（Template Method Pattern）父类中定义一组操作算法骨架，而将一些实现步骤延迟到子类中，使得子类可以不改变父类的算法结构的同时，重新定义算法中的某些实现步骤。模板方法模式的关键是<strong>算法步骤的骨架和具体实现分离</strong>。</p>\n<h2 id=\"通俗的示例\"> 通俗的示例</h2>\n<p>这里举个经典的咖啡厅例子，咖啡厅制作饮料的过程有一些类似的步骤：</p>\n<ol>\n<li>先把水煮沸</li>\n<li>冲泡饮料（咖啡、茶、牛奶）</li>\n<li>倒进杯子中</li>\n<li>最后加一些调味料（咖啡伴侣、枸杞、糖）</li>\n</ol>\n<p>无论冲饮的是咖啡、茶、牛奶，他们的制作过程都类似，可以被总结为这几个流程。也就是说这个流程是存在着类似的流程结构的，这就给我们留下了将操作流程抽象封装出来的余地。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/make-drinks.jpg\" alt=\"制作饮料步骤图\">\n  <p style=\"text-align: center; color: #888;\">（制作饮料步骤图）</p>\n</div>\n<p>再举个例子，做菜的过程也可以被总结为固定的几个步骤：</p>\n<ol>\n<li>准备食材（肉、蔬菜、菌菇）</li>\n<li>食材放到锅里</li>\n<li>放调味料（糖、盐、油）</li>\n<li>炒菜</li>\n<li>倒到容器里（盘子、碗）</li>\n</ol>\n<p>在类似的场景中，这些例子都有这些特点：</p>\n<ul>\n<li>有一个基本的操作流程，这个流程我们可以抽象出来，由具体实例的操作流程来实现，比如做咖啡的时候冲泡的就是咖啡，做茶的时候冲泡的就是茶。</li>\n<li>一些共用的流程，就可以使用通用的公共步骤，比如把水煮沸，比如将食材放到锅里，这样的共用流程就可以共用一个具体方法就可以了。</li>\n</ul>\n<h2 id=\"模板方法模式的通用实现\"> 模板方法模式的通用实现</h2>\n<p>根据上面的例子，我们可以提炼一下模板方法模式。饮料类可以被认为是父类（AbstractClass），父类中实现了模板方法（templateMethod），模板方法中抽象了操作的流程，共用的操作流程是普通方法，而非共用的可变方法是抽象方法，需要被子类（ConcreteClass）实现，或者说覆盖，子类在实例化后执行模板方法，就可以按照模板方法定义好的算法一步步执行。主要有下面几个概念：</p>\n<ul>\n<li><strong>AbstractClass</strong>：抽象父类，把一些共用的方法提取出来，把可变的方法作为抽象类，最重要的是把算法骨架抽象出来为模板方法。</li>\n<li><strong>templateMethod</strong>：模板方法，固定了希望执行的算法骨架。</li>\n<li><strong>ConcreteClass</strong>：子类，实现抽象父类中定义的抽象方法，调用继承的模板方法时，将执行模板方法中定义的算法流程。</li>\n</ul>\n<p>结构如下：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/template-method-pattern.jpg\" alt=\"模板方法模式结构图\">\n  <p style=\"text-align: center; color: #888;\">（模板方法模式结构图）</p>\n</div>\n<p>代码如下：</p>\n<div><pre><code><span>/* 抽象父类 */</span>\n<span>class</span> <span>AbstractClass</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>new</span><span>.</span>target <span>===</span> AbstractClass<span>)</span> <span>{</span>\n      <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>'抽象类不能直接实例化!'</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n\n  <span>/* 共用方法 */</span>\n  <span>operate1</span><span>(</span><span>)</span> <span>{</span> console<span>.</span><span>log</span><span>(</span><span>'operate1'</span><span>)</span> <span>}</span>\n\n  <span>/* 抽象方法 */</span>\n  <span>operate2</span><span>(</span><span>)</span> <span>{</span> <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>'抽象方法不能调用!'</span><span>)</span> <span>}</span>\n\n  <span>/* 模板方法 */</span>\n  <span>templateMethod</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span><span>operate1</span><span>(</span><span>)</span><span>;</span>\n    <span>this</span><span>.</span><span>operate2</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* 实例子类，继承抽象父类 */</span>\n<span>class</span> <span>ConcreteClass</span> <span>extends</span> <span>AbstractClass</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span> <span>super</span><span>(</span><span>)</span> <span>}</span>\n\n  <span>/* 覆盖抽象方法 operate2 */</span>\n  <span>operate2</span><span>(</span><span>)</span> <span>{</span> console<span>.</span><span>log</span><span>(</span><span>'operate2'</span><span>)</span> <span>}</span>\n<span>}</span>\n\n<span>const</span> instance <span>=</span> <span>new</span> <span>ConcreteClass</span><span>(</span><span>)</span><span>;</span>\ninstance<span>.</span><span>templateMethod</span><span>(</span><span>)</span><span>;</span>\n\n<span>// 输出：operate1</span>\n<span>// 输出：operate2</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><h2 id=\"模板方法模式的优缺点\"> 模板方法模式的优缺点</h2>\n<p>优点：</p>\n<ul>\n<li><strong>封装了不变部分，扩展可变部分</strong>，把算法中不变的部分封装到父类中直接实现，而可变的部分由子类继承后再具体实现。</li>\n<li><strong>提取了公共代码部分，易于维护</strong>，因为公共的方法被提取到了父类，那么如果我们需要修改算法中不变的步骤时，不需要到每一个子类中去修改，只要改一下对应父类即可。</li>\n<li><strong>行为被父类的模板方法固定</strong>，子类实例只负责执行模板方法，具备可扩展性，符合开闭原则。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li><strong>增加了系统复杂度</strong>，主要是增加了的抽象类和类间联系，需要做好文档工作。</li>\n</ul>\n<h2 id=\"模板方法模式的适用场景\"> 模板方法模式的适用场景</h2>\n<ul>\n<li>如果知道一个算法所需的关键步骤，而且<strong>很明确这些步骤的执行顺序，但是具体的实现是未知的、灵活的</strong>，那么这时候就可以使用模板方法模式来<strong>将算法步骤的框架抽象出来</strong>。</li>\n<li>重要而复杂的算法，可以<strong>把核心算法逻辑设计为模板方法</strong>，周边相关细节功能由各个子类实现。</li>\n<li>模板方法模式可以被用来将<strong>子类组件将自己的方法挂钩到高层组件中</strong>，也就是钩子，子类组件中的方法交出控制权，高层组件在模板方法中决定何时回调子类组件中的方法，类似的用法场景还有发布-订阅模式、回调函数。</li>\n</ul>\n<h2 id=\"其他相关模式\"> 其他相关模式</h2>\n<h3 id=\"模板方法模式与工厂模式\"> 模板方法模式与工厂模式</h3>\n<p>模板方法模式的实现可以使用工厂模式来获取所需的对象。</p>\n<p>另外，模板方法模式和抽象工厂模式比较类似，都是使用抽象类来提取公共部分，不一样的是：</p>\n<ul>\n<li><strong>适配器模式</strong>：主要用来解决接口之间不匹配的问题，通常是为所适配的对象提供一个不同的接口。</li>\n<li><strong>代理模式</strong>：提供访问目标对象的间接访问，以及对目标对象功能的扩展，一般提供和目标对象一样的接口。</li>\n</ul>\n<h3 id=\"代理模式与装饰器模式\"> 代理模式与装饰器模式</h3>\n<p>装饰器模式实现上和代理模式类似，都是在访问目标对象之前或者之后执行一些逻辑，但是目的和功能不同：</p>\n<ul>\n<li><strong>抽象工厂模式</strong> 提取的是实例的功能结构。</li>\n<li><strong>模板方法模式</strong> 提取的是算法的骨架结构。</li>\n</ul>\n<h3 id=\"模板方法模式与策略模式\"> 模板方法模式与策略模式</h3>\n<p>参见策略模式介绍。</p>\n<p>（完）</p>\n",
      "date_published": "2022-03-29T08:52:08.000Z",
      "date_modified": "2022-03-30T05:39:08.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "代理模式",
      "url": "https://www.fedbook.cn/in-depth-learning/design-patterns/proxy-pattern/",
      "id": "https://www.fedbook.cn/in-depth-learning/design-patterns/proxy-pattern/",
      "content_html": "<h1 id=\"代理模式\"> 代理模式</h1>\n<h2 id=\"介绍\"> 介绍</h2>\n<p>代理模式（Proxy Pattern）又称委托模式，它为目标对象创造了一个代理对象，以控制对目标对象的访问。</p>\n<p>代理模式把代理对象插入到访问者和目标对象之间，从而为访问者对目标对象的访问引入一定的间接性。正是这种间接性，给了代理对象很多操作空间，比如在调用目标对象前和调用后进行一些预操作和后操作，从而实现新的功能或者扩展目标的功能。</p>\n<h2 id=\"通俗的示例\"> 通俗的示例</h2>\n<p>明星一般都有个经纪人，如果某个品牌来找明星做广告，需要经纪人帮明星做接洽工作，而且经纪人也起到过滤的作用。</p>\n<p>在类似场景中，这些例子有以下特点：</p>\n<ul>\n<li>广告商（访问者）对明星（目标）的访问都是通过经纪人（代理）来完成。</li>\n<li>访问者不关心实例创建过程。</li>\n</ul>\n<h2 id=\"代理模式的通用实现\"> 代理模式的通用实现</h2>\n<p>就用明星和经纪人的例子，明星就相当于被代理的目标对象（Target），而经纪人就相当于代理对象（Proxy），希望找明星的人是访问者（Visitor），他们直接找不到明星，只能找明星的经纪人来进行业务商洽。主要有以下几个概念：</p>\n<ul>\n<li><strong>Target</strong>：目标对象，也是被代理对象，是具体业务的实际执行者。</li>\n<li><strong>Proxy</strong>：代理对象，负责引用目标对象，以及对访问的过滤和预处理。</li>\n</ul>\n<p>结构如下：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/factory-pattern.jpg\" alt=\"代理模式结构图\" style=\"width: 640px;\">\n  <p style=\"text-align: center; color: #888;\">（代理模式结构图）</p>\n</div>\n<p>ES6 原生提供了 <code>Proxy</code> 构造函数，这个构造函数让我们可以很方便地创建代理对象：</p>\n<div><pre><code><span>var</span> proxy <span>=</span> <span>new</span> <span>Proxy</span><span>(</span>target<span>,</span> handler<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>参数中 <code>target</code> 是被代理对象，<code>handler</code> 用来设置代理行为。</p>\n<p>使用 <code>Proxy</code> 来实现一下上面的经纪人例子，代码如下：</p>\n<div><pre><code><span>/* 明星 */</span>\n<span>const</span> SuperStar <span>=</span> <span>{</span>\n  name<span>:</span> <span>'当红小鲜肉'</span><span>,</span>\n  scheduleFlag<span>:</span> <span>false</span><span>,</span> <span>// 档期标识位，false-没空（默认值），true-有空</span>\n  <span>playAdvertisement</span><span>(</span><span>ad</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span>ad<span>)</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/* 经纪人 */</span>\n<span>const</span> ProxyAssistant <span>=</span> <span>{</span>\n  name<span>:</span> <span>'经纪人刘姐'</span><span>,</span>\n  <span>scheduleTime</span><span>(</span><span>ad</span><span>)</span> <span>{</span>\n    <span>const</span> schedule <span>=</span> <span>new</span> <span>Proxy</span><span>(</span>SuperStar<span>,</span> <span>{</span> <span>// 在这里监听 scheduleFlag 值的变化</span>\n      <span>set</span><span>(</span>obj<span>,</span> prop<span>,</span> val<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>prop <span>!==</span> <span>'scheduleFlag'</span><span>)</span> <span>return</span>\n        <span>if</span> <span>(</span>obj<span>.</span>scheduleFlag <span>===</span> <span>false</span> <span>&amp;&amp;</span> val <span>===</span> <span>true</span><span>)</span> <span>{</span> <span>// 小鲜肉现在有空了</span>\n          obj<span>.</span>scheduleFlag <span>=</span> <span>true</span>\n          obj<span>.</span><span>playAdvertisement</span><span>(</span>ad<span>)</span> <span>// 安排上了</span>\n        <span>}</span>\n      <span>}</span>\n    <span>}</span><span>)</span>\n\n    <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n      console<span>.</span><span>log</span><span>(</span><span>'小鲜肉有空了'</span><span>)</span>\n      schedule<span>.</span>scheduleFlag <span>=</span> <span>true</span> <span>// 明星有空了</span>\n    <span>}</span><span>,</span> <span>2000</span><span>)</span>\n  <span>}</span><span>,</span>\n  <span>playAdvertisement</span><span>(</span><span>reward<span>,</span> ad</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>reward <span>></span> <span>1000000</span><span>)</span> <span>{</span> <span>// 如果报酬超过 100w</span>\n      console<span>.</span><span>log</span><span>(</span><span>'没问题，我们小鲜肉最喜欢拍广告了！'</span><span>)</span>\n      ProxyAssistant<span>.</span><span>scheduleTime</span><span>(</span>ad<span>)</span>\n    <span>}</span> <span>else</span>\n      console<span>.</span><span>log</span><span>(</span><span>'最近档期排满了，没空！'</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n\nProxyAssistant<span>.</span><span>playAdvertisement</span><span>(</span><span>10000</span><span>,</span> <span>'纯蒸酸牛奶，味道纯纯，尽享纯蒸'</span><span>)</span>\n<span>// 输出： 没空，滚</span>\n\nProxyAssistant<span>.</span><span>playAdvertisement</span><span>(</span><span>1000001</span><span>,</span> <span>'纯蒸酸牛奶，味道纯纯，尽享纯蒸'</span><span>)</span>\n<span>// 输出： 没问题，我们小鲜肉最喜欢拍广告了！</span>\n<span>// 2秒后</span>\n<span>// 输出： 小鲜肉有空了</span>\n<span>// 输出： 纯蒸酸牛奶，味道纯纯，尽享纯蒸</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><h2 id=\"代理模式的实际应用\"> 代理模式的实际应用</h2>\n<h3 id=\"拦截器\"> 拦截器</h3>\n<p>前面的例子使用代理模式代理对象的访问的方式，一般又被称为拦截器。</p>\n<p>拦截器的思想在实战中应用非常多，比如我们在项目中经常使用 Axios 的实例来进行 HTTP 的请求，使用拦截器 <code>interceptor</code> 可以提前对 <code>request</code> 请求和 <code>response</code> 返回进行一些预处理，比如：</p>\n<ul>\n<li><code>request</code> 请求头的设置，和 Cookie 信息的设置。</li>\n<li>权限信息的预处理，常见的比如验权操作或者 Token 验证。</li>\n<li>数据格式的格式化，比如对组件绑定的 <code>Date</code> 类型的数据在请求前进行一些格式约定好的序列化操作。</li>\n<li>空字段的格式预处理，根据后端进行一些过滤操作。</li>\n<li><code>response</code> 的一些通用报错处理，比如使用 Message 控件抛出错误。</li>\n</ul>\n<p>除了 HTTP 相关的拦截器之外，还有 vue-router、react-router 路由跳转的拦截器，可以进行一些路由跳转的预处理等操作。以 vue-router 的路由全局前置守卫为例：</p>\n<div><pre><code><span>const</span> router <span>=</span> <span>new</span> <span>VueRouter</span><span>(</span><span>{</span> <span>...</span> <span>}</span><span>)</span>\n\nrouter<span>.</span><span>beforeEach</span><span>(</span><span>(</span><span>to<span>,</span> from<span>,</span> next</span><span>)</span> <span>=></span> <span>{</span>\n  <span>// ...</span>\n  console<span>.</span><span>log</span><span>(</span><span>' beforeRouteEnter ! '</span><span>)</span>\n  <span>next</span><span>(</span><span>)</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>拦截器看起来似乎和装饰器模式很像，但是要注意装饰器模式和代理模式的区别，代理模式控制访问者对目标对象的访问，而装饰器模式只给目标对象添加功能，原有功能不变且可直接使用。Axios 拦截器是可以取消请求的，vue-router 路由拦截器也可以进行路由截停和重定向等等复杂操作，这些场景下，无疑是代理模式，因为这里的拦截器控制了对目标对象的访问，如果没有进行访问控制而只进行消息预处理和后处理，那么则可以当作是装饰器模式。</p>\n<h3 id=\"前端框架的数据响应式化\"> 前端框架的数据响应式化</h3>\n<p>现在的很多前端框架或者状态管理框架都使用 <code>Object.defineProperty</code> 和 <code>Proxy</code> 来实现数据的响应式化，比如 Vue、Mobx、AvalonJS 等，Vue 2.x 与 AvalonJS 使用前者，而 Vue 3.x 与 Mobx 5.x 使用后者。</p>\n<p>Vue 2.x 中通过 <code>Object.defineProperty</code> 来劫持各个属性的 <code>setter/getter</code>，在数据变动时，通过发布-订阅模式发布消息给订阅者，触发相应的监听回调，从而实现数据的响应式化，也就是数据到视图的双向绑定。</p>\n<p>为什么 Vue 2.x 到 3.x 要从 <code>Object.defineProperty</code> 改用 <code>Proxy</code> 呢，是因为前者的一些局限性，导致的以下缺陷：</p>\n<ul>\n<li>无法监听利用索引直接设置数组的一个项，例如：<code>vm.items[indexOfItem] = newValue</code>。</li>\n<li>无法监听数组的长度的修改，例如：<code>vm.items.length = newLength</code>。</li>\n<li>无法监听 ES6 的 <code>Set</code>、<code>WeakSet</code>、<code>Map</code>、<code>WeakMap</code> 的变化。</li>\n<li>无法监听 <code>Class</code> 类型的数据。</li>\n<li>无法监听对象属性的新加或者删除。</li>\n</ul>\n<p>除此之外还有性能上的差异，基于这些原因，Vue 3.x 改用 <code>Proxy</code> 来实现数据监听了。当然缺点就是对 IE 用户的不友好，兼容性敏感的场景需要做一些取舍。</p>\n<h3 id=\"缓存代理\"> 缓存代理</h3>\n<p>在高阶函数的文章中，就介绍了<strong>备忘模式</strong>，备忘模式就是使用缓存代理的思想，将复杂计算的结果缓存起来，下次传参一致时直接返回之前缓存的计算结果。</p>\n<h3 id=\"保护代理和虚拟代理\"> 保护代理和虚拟代理</h3>\n<p>有的书籍中着重强调代理的两种形式，<strong>保护代理</strong>和<strong>虚拟代理</strong>：</p>\n<ul>\n<li><strong>保护代理</strong>：当一个对象可能会收到大量请求时，可以设置保护代理，通过一些条件判断对请求进行过滤。</li>\n<li><strong>虚拟代理</strong>：在程序中可以能有一些代价昂贵的操作，此时可以设置虚拟代理，虚拟代理会在适合的时候才执行操作。</li>\n</ul>\n<p>保护代理其实就是对访问的过滤，之前的经纪人例子就属于这种类型。</p>\n<p>而虚拟代理是为一个开销很大的操作先占位，之后再执行，比如：</p>\n<ul>\n<li>一个很大的图片加载前，一般使用菊花图、低质量图片等提前占位，优化图片加载导致白屏的情况。</li>\n<li>现在很流行的页面加载前使用骨架屏来提前占位，很多 WebApp 和 NativeApp 都采用这种方式来优化用户白屏体验。</li>\n</ul>\n<h3 id=\"正向代理与反向代理\"> 正向代理与反向代理</h3>\n<p>还有个经常用的例子是反向代理（Reverse Proxy），反向代理对应的是正向代理（Forward Proxy），他们的区别是：</p>\n<ul>\n<li><strong>正向代理</strong>：一般的访问流程是客户端直接向目标服务器发送请求并获取内容，使用正向代理后，客户端改为向代理服务器发送请求，并指定目标服务器（原始服务器），然后由代理服务器和原始服务器通信，转交请求并获得的内容，再返回给客户端。正向代理隐藏了真实的客户端，为客户端收发请求，使真实客户端对服务器不可见。</li>\n<li><strong>反向代理</strong>：与一般访问流程相比，使用反向代理后，直接收到请求的服务器是代理服务器，然后将请求转发给内部网络上真正进行处理的服务器，得到的结果返回给客户端。反向代理隐藏了真实的服务器，为服务器收发请求，使真实服务器对客户端不可见。</li>\n</ul>\n<p>反向代理一般在处理跨域请求的时候比较常用，属于服务端开发人员的日常操作了，另外在缓存服务器、负载均衡服务器等等场景也是使用到代理模式的思想。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/forward-proxy-and-reverse-proxy.jpg\" alt=\"正向代理与反向代理\" style=\"width: 640px;\">\n  <p style=\"text-align: center; color: #888;\">（正向代理与反向代理）</p>\n</div>\n<h2 id=\"设计原则验证\"> 设计原则验证</h2>\n<ul>\n<li>代理类和目标类分离，隔离开目标类和使用者</li>\n<li>符合开放封闭原则</li>\n</ul>\n<h2 id=\"代理模式的优缺点\"> 代理模式的优缺点</h2>\n<p>优点：</p>\n<ul>\n<li>代理对象在访问者与目标对象之间可以起到<strong>中介和保护目标对象</strong>的作用。</li>\n<li>代理对象可以<strong>扩展目标对象的功能</strong>。</li>\n<li>代理模式能将访问者与目标对象分离，在一定程度上<strong>降低了系统的耦合度</strong>，如果我们希望适度扩展目标对象的一些功能，通过修改代理对象就可以了，符合开闭原则。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>增加了系统的复杂度，要斟酌当前场景是不是真的需要引入代理模式（<strong>三十六线明星就别请经纪人了</strong>）。</li>\n</ul>\n<h2 id=\"其他相关模式\"> 其他相关模式</h2>\n<p>很多其他的模式，比如状态模式、策略模式、访问者模式其实也是使用了代理模式，包括在之前高阶函数处介绍的备忘模式，本质上也是一种缓存代理。</p>\n<h3 id=\"代理模式与适配器模式\"> 代理模式与适配器模式</h3>\n<p>代理模式和适配器模式都为另一个对象提供间接性的访问，他们的区别：</p>\n<ul>\n<li><strong>适配器模式</strong>：主要用来解决接口之间不匹配的问题，通常是为所适配的对象提供一个不同的接口。</li>\n<li><strong>代理模式</strong>：提供访问目标对象的间接访问，以及对目标对象功能的扩展，一般提供和目标对象一样的接口。</li>\n</ul>\n<h3 id=\"代理模式与装饰器模式\"> 代理模式与装饰器模式</h3>\n<p>装饰器模式实现上和代理模式类似，都是在访问目标对象之前或者之后执行一些逻辑，但是目的和功能不同：</p>\n<ul>\n<li><strong>装饰器模式</strong>：目的是为了方便地给目标对象添加功能，也就是动态地添加功能。</li>\n<li><strong>代理模式</strong>：主要目的是控制其他访问者对目标对象的访问。</li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-03-24T15:29:25.000Z",
      "date_modified": "2022-03-26T06:53:54.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "未完待续",
      "url": "https://www.fedbook.cn/in-depth-learning/source-code/to-be-continued/",
      "id": "https://www.fedbook.cn/in-depth-learning/source-code/to-be-continued/",
      "content_html": "<h1 id=\"未完待续\"> 未完待续</h1>\n<h2 id=\"知识点正在火速整理中\"> 知识点正在火速整理中</h2>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2021-11-19T03:27:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "UML 类图",
      "url": "https://www.fedbook.cn/in-depth-learning/design-patterns/uml-class-diagram/",
      "id": "https://www.fedbook.cn/in-depth-learning/design-patterns/uml-class-diagram/",
      "content_html": "<h1 id=\"uml-类图\"> UML 类图</h1>\n<h2 id=\"uml-介绍\"> UML 介绍</h2>\n<p>UML（Unified Modeling Language）中文名叫统一建模语言，是一种为面向对象系统的产品进行说明、可视化和编制文档的一种标准语言。</p>\n<p>它本身包括很多类型的图，但在设计模式中，主要使用其中的一种 —— 类图，以及关系（泛化和关联）。</p>\n<h2 id=\"类图\"> 类图</h2>\n<ul>\n<li><code>+</code> 表示 public：完全开放</li>\n<li><code>#</code> 表示 protected：对子类开放</li>\n<li><code>-</code> 表示 private：对自己开放</li>\n</ul>\n<p>当然了，JavaScript 的语言特性本身只支持 public，而 TypeScript 可以支持这三种类型。</p>\n<div style=\"text-align: center;\">\n  <svg id=\"SvgjsSvg1006\" width=\"359\" height=\"184\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><defs id=\"SvgjsDefs1007\"></defs><g id=\"SvgjsG1008\" transform=\"translate(25,25)\"><path id=\"SvgjsPath1009\" d=\"M 0 4Q 0 0 4 0L 305 0Q 309 0 309 4L 309 130Q 309 134 305 134L 4 134Q 0 134 0 130Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><path id=\"SvgjsPath1010\" d=\"M 0 30L 309 30M 0 79L 309 79\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill=\"none\"></path><path id=\"SvgjsPath1011\" d=\"M 0 0L 309 0L 309 134L 0 134Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1012\"><text id=\"SvgjsText1013\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"289px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"4.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1014\" dy=\"16\" x=\"154.5\"><tspan id=\"SvgjsTspan1015\" style=\"text-decoration:;\">类名</tspan></tspan></text></g><g id=\"SvgjsG1016\"><text id=\"SvgjsText1017\" font-family=\"微软雅黑\" text-anchor=\"start\" font-size=\"13px\" width=\"289px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"start\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"27.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1018\" dy=\"16\" x=\"10\"><tspan id=\"SvgjsTspan1019\" style=\"text-decoration:;\">+ public属性名A: 类型</tspan></tspan><tspan id=\"SvgjsTspan1020\" dy=\"16\" x=\"10\"><tspan id=\"SvgjsTspan1021\" style=\"text-decoration:;\"># protected属性名B: 类型</tspan></tspan><tspan id=\"SvgjsTspan1022\" dy=\"16\" x=\"10\"><tspan id=\"SvgjsTspan1023\" style=\"text-decoration:;\">- private属性名C: 类型</tspan></tspan></text></g><g id=\"SvgjsG1024\"><text id=\"SvgjsText1025\" font-family=\"微软雅黑\" text-anchor=\"start\" font-size=\"13px\" width=\"289px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"start\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"76.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1026\" dy=\"16\" x=\"10\"><tspan id=\"SvgjsTspan1027\" style=\"text-decoration:;\">+ public方法名A(参数1, 参数2): 返回值类型</tspan></tspan><tspan id=\"SvgjsTspan1028\" dy=\"16\" x=\"10\"><tspan id=\"SvgjsTspan1029\" style=\"text-decoration:;\"># protected方法名B(参数1, 参数2): 返回值类型</tspan></tspan><tspan id=\"SvgjsTspan1030\" dy=\"16\" x=\"10\"><tspan id=\"SvgjsTspan1031\" style=\"text-decoration:;\">- private方法名C(参数1): 返回值类型</tspan></tspan></text></g></g></svg>\n  <p style=\"text-align: center; color: #888;\">（类图的画法）</p>\n</div>\n<h2 id=\"泛化和关联\"> 泛化和关联</h2>\n<ul>\n<li>泛化，表示继承\n<ul>\n<li>用空心箭头表示，箭头指向就是「继承自」</li>\n</ul>\n</li>\n<li>关联，表示引用\n<ul>\n<li>用实心箭头表示，箭头指向就是「引用了」</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"一个示例\"> 一个示例</h1>\n<p>代码示例：</p>\n<ul>\n<li>继承关系：A 和 B 继承了 People</li>\n<li>引用关系：People 里面引用了 House</li>\n</ul>\n<div><pre><code><span>class</span> <span>People</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>name<span>,</span> house</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n    <span>this</span><span>.</span>house <span>=</span> house<span>;</span>\n  <span>}</span>\n  <span>saySomething</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n\n<span>}</span>\n\n<span>class</span> <span>A</span> <span>extends</span> <span>People</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>name<span>,</span> house</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span>name<span>,</span> house<span>)</span><span>;</span>\n  <span>}</span>\n  <span>saySomething</span><span>(</span><span>)</span><span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'I am A'</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>B</span> <span>extends</span> <span>People</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>name<span>,</span> house</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span>name<span>,</span> house<span>)</span><span>;</span>\n  <span>}</span>\n  <span>saySomething</span><span>(</span><span>)</span><span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'I am B'</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>Houst</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>city</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>city <span>=</span> city<span>;</span>\n  <span>}</span>\n  <span>showCity</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span><span>`</span><span>houst in </span><span><span>${</span><span>this</span><span>.</span>city<span>}</span></span><span>`</span></span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 测试</span>\n<span>let</span> aHoust <span>=</span> <span>new</span> <span>Houst</span><span>(</span><span>'北京'</span><span>)</span><span>;</span>\n<span>let</span> a <span>=</span> <span>new</span> <span>A</span><span>(</span><span>'aaa'</span><span>,</span> aHoust<span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>a<span>)</span><span>;</span> <span>// a 有房子</span>\n<span>let</span> b <span>=</span> <span>new</span> <span>B</span><span>(</span><span>'bbb'</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>b<span>)</span><span>;</span> <span>// b 无房子</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><p>UML 类图示例：</p>\n<div style=\"text-align: center;\">\n  <svg id=\"SvgjsSvg1032\" width=\"579\" height=\"349\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><defs id=\"SvgjsDefs1033\"><marker id=\"SvgjsMarker1098\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1099\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1102\" markerWidth=\"14\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 14 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1103\" d=\"M1,1 L14,6 L1,11L1,1\" fill=\"#ffffff\" stroke=\"#323232\" stroke-width=\"2\"></path></marker><marker id=\"SvgjsMarker1106\" markerWidth=\"14\" markerHeight=\"12\" refX=\"16\" refY=\"6\" viewBox=\"0 0 14 12\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1107\" d=\"M1,1 L14,6 L1,11L1,1\" fill=\"#ffffff\" stroke=\"#323232\" stroke-width=\"2\"></path></marker></defs><g id=\"SvgjsG1034\" transform=\"translate(25,85)\"><path id=\"SvgjsPath1035\" d=\"M 0 4Q 0 0 4 0L 226 0Q 230 0 230 4L 230 89Q 230 93 226 93L 4 93Q 0 93 0 89Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><path id=\"SvgjsPath1036\" d=\"M 0 30L 230 30M 0 63L 230 63\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill=\"none\"></path><path id=\"SvgjsPath1037\" d=\"M 0 0L 230 0L 230 93L 0 93Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1038\"><text id=\"SvgjsText1039\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"210px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"4.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1040\" dy=\"16\" x=\"115\"><tspan id=\"SvgjsTspan1041\" style=\"text-decoration:;\">People</tspan></tspan></text></g><g id=\"SvgjsG1042\"><text id=\"SvgjsText1043\" font-family=\"微软雅黑\" text-anchor=\"start\" font-size=\"13px\" width=\"210px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"start\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"27.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1044\" dy=\"16\" x=\"10\"><tspan id=\"SvgjsTspan1045\" style=\"text-decoration:;\">+ name: String</tspan></tspan><tspan id=\"SvgjsTspan1046\" dy=\"16\" x=\"10\"><tspan id=\"SvgjsTspan1047\" style=\"text-decoration:;\">+ house: House</tspan></tspan></text></g><g id=\"SvgjsG1048\"><text id=\"SvgjsText1049\" font-family=\"微软雅黑\" text-anchor=\"start\" font-size=\"13px\" width=\"210px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"start\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"67.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1050\" dy=\"16\" x=\"10\"><tspan id=\"SvgjsTspan1051\" style=\"text-decoration:;\">+ saySomething(): void</tspan></tspan></text></g></g><g id=\"SvgjsG1052\" transform=\"translate(324,161)\"><path id=\"SvgjsPath1053\" d=\"M 0 4Q 0 0 4 0L 226 0Q 230 0 230 4L 230 86Q 230 90 226 90L 4 90Q 0 90 0 86Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><path id=\"SvgjsPath1054\" d=\"M 0 30L 230 30M 0 60L 230 60\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill=\"none\"></path><path id=\"SvgjsPath1055\" d=\"M 0 0L 230 0L 230 90L 0 90Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1056\"><text id=\"SvgjsText1057\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"210px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"4.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1058\" dy=\"16\" x=\"115\"><tspan id=\"SvgjsTspan1059\" style=\"text-decoration:;\">B</tspan></tspan></text></g><g id=\"SvgjsG1060\"><text id=\"SvgjsText1061\" font-family=\"微软雅黑\" text-anchor=\"start\" font-size=\"13px\" width=\"210px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"start\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"34.375\" transform=\"rotate(0)\"></text></g><g id=\"SvgjsG1062\"><text id=\"SvgjsText1063\" font-family=\"微软雅黑\" text-anchor=\"start\" font-size=\"13px\" width=\"210px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"start\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"64.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1064\" dy=\"16\" x=\"10\"><tspan id=\"SvgjsTspan1065\" style=\"text-decoration:;\">+ saySomething(): void</tspan></tspan></text></g></g><g id=\"SvgjsG1066\" transform=\"translate(25,234)\"><path id=\"SvgjsPath1067\" d=\"M 0 4Q 0 0 4 0L 226 0Q 230 0 230 4L 230 86Q 230 90 226 90L 4 90Q 0 90 0 86Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><path id=\"SvgjsPath1068\" d=\"M 0 30L 230 30M 0 60L 230 60\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill=\"none\"></path><path id=\"SvgjsPath1069\" d=\"M 0 0L 230 0L 230 90L 0 90Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1070\"><text id=\"SvgjsText1071\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"210px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"4.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1072\" dy=\"16\" x=\"115\"><tspan id=\"SvgjsTspan1073\" style=\"text-decoration:;\">House</tspan></tspan></text></g><g id=\"SvgjsG1074\"><text id=\"SvgjsText1075\" font-family=\"微软雅黑\" text-anchor=\"start\" font-size=\"13px\" width=\"210px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"start\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"34.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1076\" dy=\"16\" x=\"10\"><tspan id=\"SvgjsTspan1077\" style=\"text-decoration:;\">+ city: String</tspan></tspan></text></g><g id=\"SvgjsG1078\"><text id=\"SvgjsText1079\" font-family=\"微软雅黑\" text-anchor=\"start\" font-size=\"13px\" width=\"210px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"start\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"64.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1080\" dy=\"16\" x=\"10\"><tspan id=\"SvgjsTspan1081\" style=\"text-decoration:;\">+ showCity(): void</tspan></tspan></text></g></g><g id=\"SvgjsG1082\" transform=\"translate(324,25)\"><path id=\"SvgjsPath1083\" d=\"M 0 4Q 0 0 4 0L 226 0Q 230 0 230 4L 230 86Q 230 90 226 90L 4 90Q 0 90 0 86Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><path id=\"SvgjsPath1084\" d=\"M 0 30L 230 30M 0 60L 230 60\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill=\"none\"></path><path id=\"SvgjsPath1085\" d=\"M 0 0L 230 0L 230 90L 0 90Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1086\"><text id=\"SvgjsText1087\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"210px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"4.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1088\" dy=\"16\" x=\"115\"><tspan id=\"SvgjsTspan1089\" style=\"text-decoration:;\">A</tspan></tspan></text></g><g id=\"SvgjsG1090\"><text id=\"SvgjsText1091\" font-family=\"微软雅黑\" text-anchor=\"start\" font-size=\"13px\" width=\"210px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"start\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"34.375\" transform=\"rotate(0)\"></text></g><g id=\"SvgjsG1092\"><text id=\"SvgjsText1093\" font-family=\"微软雅黑\" text-anchor=\"start\" font-size=\"13px\" width=\"210px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"start\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"64.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1094\" dy=\"16\" x=\"10\"><tspan id=\"SvgjsTspan1095\" style=\"text-decoration:;\">+ saySomething(): void</tspan></tspan></text></g></g><g id=\"SvgjsG1096\"><path id=\"SvgjsPath1097\" d=\"M140 179L140 206L140 206L140 230.39999999999998\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1098)\"></path></g><g id=\"SvgjsG1100\"><path id=\"SvgjsPath1101\" d=\"M323.32049378635134 205.26633024758218L257.4462223691353 134.14121110870408\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1102)\"></path></g><g id=\"SvgjsG1104\"><path id=\"SvgjsPath1105\" d=\"M323.25348672832433 70.66537052475445L257.6874477780326 129.10466611088398\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1106)\"></path></g></svg>\n  <p style=\"text-align: center; color: #888;\">（一个类图示例）</p>\n</div>\n<p>（完）</p>\n",
      "date_published": "2022-03-19T14:35:22.000Z",
      "date_modified": "2022-03-19T14:35:22.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "源码阅读与学习",
      "url": "https://www.fedbook.cn/in-depth-learning/source-code/",
      "id": "https://www.fedbook.cn/in-depth-learning/source-code/",
      "content_html": "<h1 id=\"源码阅读与学习\"> 源码阅读与学习</h1>\n<p><strong>为什么要阅读源码（Why）</strong>：</p>\n<ul>\n<li><strong>能够学习到高手的编程技巧</strong>，了解高手是如何组织代码的，了解一些算法思想和设计模式的应用。</li>\n<li>通过学习开源框架、开源项目的源码，<strong>可以学习到多种场景多种技术的解决方案，快速增加经验</strong>。</li>\n<li>在使用某个框架或工具进行开发时，如果你对其源码有所了解，<strong>可以最大化地减少出故障的可能</strong>。</li>\n<li>有利于你研究一个新系统的代码逻辑，<strong>快速接手一个新系统</strong>。</li>\n<li>通过看源码，<strong>看别人如何设计，然后思考为何这样设计，可以开阔思维，提升架构设计能力</strong>。</li>\n<li>现在大厂都喜欢考源码，这已经成了敲门砖。</li>\n</ul>\n<hr>\n<p><strong>怎么阅读源码（How）</strong>：</p>\n<ul>\n<li>明确学习目标，为了从中学习到什么。不能只是单纯的为了面试，这种学习相对低效。</li>\n<li>前提是要用过这个开源框架、开源项目，不然直接上手源码会不知所云。</li>\n<li>从简单的开始，从单独的模块（耦合性小的模块）开始，不要急着一口气攀登珠峰。</li>\n<li>开源项目一般都能在 <code>README.md</code> 或者 <code>.github/contributing.md</code> 找到贡献指南。优先阅读这里的信息，因为其中写了很多关于参与项目开发的信息。比如怎么跑起来，项目目录结构是怎样的。怎么投入开发，需要哪些知识储备等。</li>\n<li><code>README.md</code> 和 <code>contributing.md</code> 一般都是英文的，代码中的注释也都是英文的，大部分人其实都看不懂，完全可以借助翻译工具的划词翻译功能来阅读。</li>\n<li>直接或间接的提升英语阅读能力（词汇、语法）。</li>\n</ul>\n<div style=\"text-align: right\">\n  <svg t=\"1607526012170\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"10484\" width=\"64\" height=\"64\"><path d=\"M737.6 356.608a8.96 8.96 0 0 1 12.096-1.472l235.712 175.36a18.688 18.688 0 0 1 2.88 2.688v0.064a15.808 15.808 0 0 1-2.88 23.04l-235.712 175.36c0 2.56-1.28 4.928-3.328 6.464a8.96 8.96 0 0 1-12.096-1.472 7.936 7.936 0 0 1 1.536-11.456v-83.2c0-2.56 1.28-4.928 3.328-6.464l123.776-92.16-123.776-92.096a7.808 7.808 0 0 1-3.328-6.4V361.6c0-1.792 0.64-3.584 1.792-4.992z m-458.112-3.2c4.736-0.064 8.64 3.584 8.64 8.128v83.2c0 2.56-1.28 4.864-3.328 6.4L161.024 543.36l123.776 92.16c2.112 1.472 3.328 3.84 3.328 6.272v83.328c0 1.792-0.64 3.584-1.792 4.992a8.96 8.96 0 0 1-12.096 1.472L38.528 556.16a15.872 15.872 0 0 1 0-25.792l235.712-175.296a8.704 8.704 0 0 1 5.248-1.728z\" fill=\"#101A33\" p-id=\"10485\"></path><path d=\"M672.576 192H599.936a8.704 8.704 0 0 0-8.192 5.44v0.064L342.72 885.184a8.128 8.128 0 0 0 5.312 10.368c0.96 0.32 1.92 0.448 2.88 0.448h72.96a8.704 8.704 0 0 0 8.192-5.44v-0.064l0.768-2.176 248.064-685.44a8.192 8.192 0 0 0-5.504-10.432A9.28 9.28 0 0 0 672.64 192z\" fill=\"#107CEE\" p-id=\"10486\"></path></svg>\n</div>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2022-03-30T06:40:43.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "HTML 问题",
      "url": "https://www.fedbook.cn/interview/html/",
      "id": "https://www.fedbook.cn/interview/html/",
      "content_html": "<h1 id=\"html-问题\"> HTML 问题</h1>\n<blockquote>\n<p>本章节会持续收录 HTML 相关的问题，由笔者凭主观理解作答，答案仅供参考，如有存疑，欢迎提出 PR 进行建议和指正！</p>\n</blockquote>\n<p><div><ul><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul></div></p>\n<h3 id=\"_1-doctype-的意义是什么\"> 1. doctype 的意义是什么</h3>\n<ul>\n<li>让浏览器以标准模式渲染\n<ul>\n<li>针对 IE，设置 <code>width: 200px; padding: 10px;</code> 时，标准模式下盒子宽度会解析为 <code>220px</code>。</li>\n<li>让浏览器知道元素的合法性。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"_2-html-xhtml-html5-的关系\"> 2. HTML XHTML HTML5 的关系</h3>\n<ul>\n<li>HTML 属于 SGML</li>\n<li>XHTML 属于 XML，是 HTML 进行 XML 严格化的结果</li>\n<li>HTML5 不属于 SGML 或 XML，比 XHTML 宽松</li>\n</ul>\n<h3 id=\"_3-html5-有什么变化\"> 3. HTML5 有什么变化</h3>\n<ul>\n<li>新的语义化元素</li>\n<li>表单增强</li>\n<li>新的 API（离线、音视频、图形、实时通信、本地存储、设备能力）</li>\n<li>分类和嵌套变更</li>\n</ul>\n<h3 id=\"_4-em-和-i-有什么区别\"> 4. em 和 i 有什么区别</h3>\n<ul>\n<li>em 是语义化的标签，表示强调</li>\n<li>i 是纯样式的标签，表示斜体</li>\n<li>HTML5 中 i 不推荐使用，一般用作图标</li>\n</ul>\n<h3 id=\"_5-语义化的意义是什么\"> 5. 语义化的意义是什么</h3>\n<ul>\n<li>开发者容易理解</li>\n<li>机器容易理解结构（搜索、读屏软件）</li>\n<li>有助于 SEO</li>\n<li>semantic microdata 规范</li>\n</ul>\n<h3 id=\"_6-哪些元素可以自闭合\"> 6. 哪些元素可以自闭合</h3>\n<ul>\n<li>表单元素 input</li>\n<li>图片 img</li>\n<li>换行 br，水平线 hr</li>\n<li>元信息 meta link</li>\n</ul>\n<h3 id=\"_7-html-和-dom-的关系\"> 7. HTML 和 DOM 的关系</h3>\n<ul>\n<li>HTML 没有结构，仅是字符串</li>\n<li>DOM 由 HTML 解析而来，它是浏览器内存中的树结构</li>\n<li>JavaScript 可以维护 DOM</li>\n</ul>\n<h3 id=\"_8-property-和-attribute-的区别\"> 8. property 和 attribute 的区别</h3>\n<ul>\n<li>property 是通过 <code>.value</code> 直接获取/设置的值，直观显示在输入框中</li>\n<li>property 是通过 <code>.getAttribute('value')</code> 和 <code>.setAttribute('value', 'xxx')</code> 获取/设置的值，显示在 dom 元素的属性中</li>\n<li>两者互不影响</li>\n</ul>\n<h3 id=\"_9-form-的作用有哪些\"> 9. form 的作用有哪些</h3>\n<ul>\n<li>直接提交表单</li>\n<li>使用 submit/reset 按钮</li>\n<li>便于浏览器保存表单</li>\n<li>第三方库可以整体提取值</li>\n<li>第三方库可以进行表单验证（HTML5 官方的表单验证不需要有 form，但 Angular 这类库需要）</li>\n</ul>\n",
      "date_published": "2020-09-20T14:25:34.000Z",
      "date_modified": "2020-10-07T08:58:13.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "CSS 问题",
      "url": "https://www.fedbook.cn/interview/css/",
      "id": "https://www.fedbook.cn/interview/css/",
      "content_html": "<h1 id=\"css-问题\"> CSS 问题</h1>\n<blockquote>\n<p>本章节会持续收录 CSS 相关的问题，由笔者凭主观理解作答，答案仅供参考，如有存疑，欢迎提出 PR 进行建议和指正！</p>\n</blockquote>\n<p><div><ul><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul></div></p>\n<h3 id=\"_1-css-样式-选择器-的优先级\"> 1. CSS 样式（选择器）的优先级</h3>\n<ul>\n<li>计算权重确定</li>\n<li>带 <code>!important</code> 属性的优先级是最高的，唯一能覆盖它的是再加一个带 <code>!important</code> 属性的样式</li>\n<li>内联样式（直接写在元素属性上的样式）优先级高</li>\n<li>后写的优先级高</li>\n</ul>\n<h3 id=\"_2-什么是雪碧图\"> 2. 什么是雪碧图</h3>\n<p>把网站上用到的一些图片整合到一张单独的图片中，在需要用到图片的时候，通过 CSS 属性<code>background-image</code> 组合 <code>background-repeat</code>，<code>background-position</code> 等来实现图片的显示。</p>\n<p>最重要的是通过 <code>background-position</code> 调整背景图的位置，并通过容器的宽高共同作用，来选出所需的图片。</p>\n<h3 id=\"_3-雪碧图的作用\"> 3. 雪碧图的作用</h3>\n<ul>\n<li>减少 HTTP 请求数，提高加载性能</li>\n<li>有一些情况下可以减少图片大小（合并后的图片体积 &lt; 每个图片加起来的体积）</li>\n</ul>\n<h3 id=\"_4-自定义字体的使用场景\"> 4. 自定义字体的使用场景</h3>\n<ul>\n<li>宣传/品牌/banner 等固定文案</li>\n<li>字体图标</li>\n</ul>\n<h3 id=\"_5-base64-的使用\"> 5. base64 的使用</h3>\n<ul>\n<li>把图片变成文本的形式，用于减少 HTTP 请求</li>\n<li>适用于小图片</li>\n<li>base64 的体积约为原图 4/3（会增大）</li>\n</ul>\n<h3 id=\"_6-伪类和伪元素的区别\"> 6. 伪类和伪元素的区别</h3>\n<ul>\n<li>伪类表示状态（<code>:link</code>、<code>:visited</code>、<code>:hover</code>、<code>:focus</code> 和 <code>:active</code> 等）</li>\n<li>伪元素是真的有元素（<code>::before</code>、<code>::after</code> 等），在页面中可以显示内容</li>\n<li>伪类使用单冒号，伪元素使用双冒号</li>\n</ul>\n<h3 id=\"_7-如何美化-checkbox\"> 7. 如何美化 checkbox</h3>\n<ul>\n<li><code>label</code> 的 <code>for</code> 属性绑定 <code>input</code> 的 <code>id</code>（这样点击 <code>label</code>，<code>checkbox</code> 的选中状态也会联动变化）</li>\n</ul>\n<div><div><br><br><div>&nbsp;</div><br><br></div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>my-checkbox<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>\"</span>checkbox<span>\"</span></span> <span>id</span><span><span>=</span><span>\"</span>category<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>label</span> <span>for</span><span><span>=</span><span>\"</span>category<span>\"</span></span><span>></span></span>CSS<span><span><span>&lt;/</span>label</span><span>></span></span>\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>\n<li>隐藏 <code>input</code></li>\n<li>样式都写在 <code>label</code> 上</li>\n</ul>\n<div><pre><code><span>.my-checkbox input</span> <span>{</span>\n  <span>display</span><span>:</span> none<span>;</span>\n<span>}</span>\n<span>.my-checkbox input:checked + label</span> <span>{</span>\n  <span>background-image</span><span>:</span> <span><span>url</span><span>(</span><span>\"./checkbox2.png\"</span><span>)</span></span><span>;</span>\n<span>}</span>\n<span>.my-checkbox input + label</span> <span>{</span>\n  <span>background</span><span>:</span> <span><span>url</span><span>(</span><span>\"./checkbox1.png\"</span><span>)</span></span> left center no-repeat<span>;</span>\n  <span>background-size</span><span>:</span> 20px 20px<span>;</span>\n  <span>padding-left</span><span>:</span> 20px<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"_8-实现两栏-三栏-布局的方法\"> 8. 实现两栏（三栏）布局的方法</h3>\n<ul>\n<li>表格布局（或 <code>display: table</code>）</li>\n<li>float + margin 布局</li>\n<li>inline-block 布局</li>\n<li>flexbox 布局</li>\n</ul>\n<h3 id=\"_9-position-absolute-fixed-有什么区别\"> 9. position: absolute / fixed 有什么区别</h3>\n<p>都是一种绝对定位的方式，主要区别是参照物不同。</p>\n<ul>\n<li>前者相对最近的 absolute / relative 元素进行定位</li>\n<li>后者相对屏幕（viewport）进行定位</li>\n</ul>\n<h3 id=\"_10-display-inline-block-的间隙\"> 10. display: inline-block 的间隙</h3>\n<p>原因：在 html 代码中存在字符间距，即换行或空格会占据一定的位置。</p>\n<p>两种解决方案：</p>\n<ul>\n<li>除去当前元素的空格或换行（将元素写在一行）</li>\n<li>给父元素设置 <code>font-size: 0</code>，给子元素设置需要的 <code>font-size</code> 值</li>\n</ul>\n<h3 id=\"_11-为什么要清除浮动\"> 11. 为什么要清除浮动</h3>\n<p>浮动的元素不会占据父元素的布局空间，因此有可能浮动元素会超出父元素，从而对其它元素产生影响。</p>\n<p>所以父元素要清除浮动。</p>\n<h3 id=\"_12-如何清除浮动\"> 12. 如何清除浮动</h3>\n<p>设置超出之后的行为：<code>overflow: hidden</code> 或 <code>overflow: auto</code></p>\n<p>或</p>\n<p>在浮动元素后面加一个元素，让父元素包含浮动元素：<code>::after {clear: both}</code></p>\n<h3 id=\"_13-如何适配移动端页面\"> 13. 如何适配移动端页面</h3>\n<ul>\n<li>必须添加 viewport，让页面宽度等于移动端宽度</li>\n<li>rem / viewport / media query</li>\n<li>设计上：隐藏、折行、自适应</li>\n</ul>\n",
      "date_published": "2020-10-07T08:58:13.000Z",
      "date_modified": "2020-10-07T08:58:13.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Vue3 源码中的基础工具函数",
      "url": "https://www.fedbook.cn/in-depth-learning/source-code/vue3-utils/",
      "id": "https://www.fedbook.cn/in-depth-learning/source-code/vue3-utils/",
      "content_html": "<h1 id=\"vue3-源码中的基础工具函数\"> Vue3 源码中的基础工具函数</h1>\n<h2 id=\"学习目标\"> 学习目标</h2>\n<ul>\n<li>学习调试源码：打包构建项目代码，生成 sourcemap 调试源码。</li>\n<li>学习优秀开源框架中工具函数是如何设计以达到优化的目的。</li>\n<li>工作中如果有用到类似的工具函数，可以借鉴参考。</li>\n<li>对 JavaScript 基础知识查漏补缺。</li>\n<li>复习巩固 TypeScript 语法和用法。</li>\n</ul>\n<h2 id=\"前期准备\"> 前期准备</h2>\n<h3 id=\"源码位置\"> 源码位置</h3>\n<p>Vue3 的源码仓库是 <a href=\"https://github.com/vuejs/vue-next\" target=\"_blank\" rel=\"noopener noreferrer\">vue-next</a>，根据 <a href=\"https://github.com/vuejs/vue-next/blob/master/.github/contributing.md#project-structure\" target=\"_blank\" rel=\"noopener noreferrer\">项目目录结构</a> 的描述：</p>\n<ul>\n<li><code>shared</code>: Internal utilities shared across multiple packages (especially environment-agnostic utils used by both runtime and compiler packages).</li>\n</ul>\n<p>本次要阅读的工具函数位于 <code>shared</code> 模块，对应的文件路径是：<a href=\"https://github.com/vuejs/vue-next/blob/master/packages/shared/src/index.ts\" target=\"_blank\" rel=\"noopener noreferrer\"><code>vue-next/packages/shared/src/index.ts</code></a>。</p>\n<h3 id=\"打包构建代码-非必须\"> 打包构建代码（非必须）</h3>\n<p>这个步骤非必须，主要是为了将 <code>ts</code> 编译成 <code>js</code>，从而可以降低阅读源代码的难度。</p>\n<div><pre><code><span># 需要确保 Node.js 版本是 10+，而且 yarn 的版本是 1.x</span>\nnode -v\n\n<span># 克隆项目</span>\n<span>git</span> clone https://github.com/vuejs/vue-next.git\n<span>cd</span> vue-next\n\n<span># 全局安装 yarn</span>\n<span>npm</span> <span>install</span> --global <span>yarn</span>\n\n<span>yarn</span> <span># install the dependencies of the project</span>\n<span>yarn</span> build\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>可以得到 <code>vue-next/packages/shared/dist/shared.esm-bundler.js</code>，文件也就是纯 <code>js</code> 文件。</p>\n<h2 id=\"工具函数\"> 工具函数</h2>\n<p>由于我刚学过 TypeScript，但还未在实际项目中运用过，所以可以借此机会通过阅读 <code>ts</code> 代码来巩固相关知识点。</p>\n<p>接下来我会先按照源码 <code>vue-next/packages/shared/src/index.ts</code> 中的工具函数顺序，找到纯 <code>js</code> 文件里对应的函数进行解读；然后回到 <code>ts</code> 文件学习 TS 版本的实现方式。（从外部导入的方法暂时先省去不进行阅读）</p>\n<h3 id=\"babelparserdefaultplugins\"> babelParserDefaultPlugins</h3>\n<p>babelParserDefaultPlugins：babel 解析默认插件，定义了 babel 需要使用的插件。</p>\n<ul>\n<li>JS 版</li>\n</ul>\n<div><pre><code><span>/**\n * List of @babel/parser plugins that are used for template expression\n * transforms and SFC script transforms. By default we enable proposals slated\n * for ES2020. This will need to be updated as the spec moves forward.\n * Full list at https://babeljs.io/docs/en/next/babel-parser#plugins\n */</span>\n<span>const</span> babelParserDefaultPlugins <span>=</span> <span>[</span>\n    <span>'bigInt'</span><span>,</span>\n    <span>'optionalChaining'</span><span>,</span>\n    <span>'nullishCoalescingOperator'</span>\n<span>]</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><ul>\n<li>TS 版</li>\n</ul>\n<div><pre><code><span>export</span> <span>const</span> babelParserDefaultPlugins <span>=</span> <span>[</span>\n  <span>'bigInt'</span><span>,</span>\n  <span>'optionalChaining'</span><span>,</span>\n  <span>'nullishCoalescingOperator'</span>\n<span>]</span> <span>as</span> <span>const</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>第一个 <code>const</code>：常量声明，是 ES6 的语法，对 TS 而言，它只能反映该常量本身是不可被重新赋值的，它的子属性仍然可以被修改，故 TS 只会对它们做松散的类型推断。</p>\n<p>第二个 <code>const</code>：<code>as const</code> 这个语法叫 <a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions\" target=\"_blank\" rel=\"noopener noreferrer\">const 断言</a>，它专用于字面量类型，它的语法是将类型断言 <code>值 as 类型</code> 的类型名称修改为 <code>const</code>。\n使用 const 断言构造字面量类型时，它告诉 TS 它所断言的值以及该值的所有层级的子属性都是不可篡改的（readonly），故对每一级子属性都会做最严格的类型推断。</p>\n<p>例如下面字面量对象的第二层属性会被推断成 <code>13</code> 这样的单值类型而不是宽泛的 number 或 string 类型，其类型推断结果与字面量声明几乎长得一模一样。</p>\n<div><pre><code><span>const</span> students <span>=</span> <span>[</span>\n  <span>{</span>\n    name<span>:</span> <span>'zhangsan'</span><span>,</span>\n    age<span>:</span> <span>13</span>\n  <span>}</span><span>,</span>\n  <span>{</span>\n    name<span>:</span> <span>'lisi'</span><span>,</span>\n    age<span>:</span> <span>14</span>\n  <span>}</span>\n<span>]</span> <span>as</span> <span>const</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"empty-obj\"> EMPTY_OBJ</h3>\n<p>EMPTY_OBJ：空对象，Vue 源码中常用它来赋初值和做判断。</p>\n<ul>\n<li>JS 版</li>\n</ul>\n<div><pre><code><span>const</span> <span>EMPTY_OBJ</span> <span>=</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span>\n    <span>?</span> Object<span>.</span><span>freeze</span><span>(</span><span>{</span><span>}</span><span>)</span>\n    <span>:</span> <span>{</span><span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>process.env.NODE_ENV</code> 是 node 项目中的一个环境变量，一般定义为：<code>development</code> 和 <code>production</code>。根据环境写代码。比如开发环境，有报错等信息，生产环境则不需要这些报错警告。</p>\n<p><code>Object.freeze()</code> 方法可以冻结一个对象，被冻结对象自身的所有属性都不能以任何方式被修改，且该对象的原型也不能被修改。但如果一个属性的值是个对象（对象B），则这个对象（对象B）中的属性是可以修改的，除非它也是个冻结对象。数组作为一种对象，被冻结，其元素不能被修改，没有数组元素可以被添加或移除。这个方法返回传递的对象，而不是创建一个被冻结的副本。</p>\n<p>在开发环境中，如果开发者误操作（对冻结后的对象进行修改），就可以在编译时发现错误（严格模式下会报错）。而在生产环境中则只需要直接使用 <code>{}</code> 创建空对象。</p>\n<ul>\n<li>TS 版</li>\n</ul>\n<div><pre><code><span>export</span> <span>const</span> <span>EMPTY_OBJ</span><span>:</span> <span>{</span> <span>readonly</span> <span>[</span>key<span>:</span> <span>string</span><span>]</span><span>:</span> <span>any</span> <span>}</span> <span>=</span> __DEV__\n  <span>?</span> Object<span>.</span><span>freeze</span><span>(</span><span>{</span><span>}</span><span>)</span>\n  <span>:</span> <span>{</span><span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>__DEV__</code> 是一个环境变量，但它是个布尔值，所以只能区别两种环境。而 <code>NODE_ENV</code> 依赖了 <code>process.env</code> 环境变量，它是个字符串，可以写多个值区分多个环境。</p>\n<h3 id=\"empty-arr\"> EMPTY_ARR</h3>\n<p>EMPTY_ARR：空数组，Vue 源码中常用它来赋初值和做判断。</p>\n<ul>\n<li>JS 版</li>\n</ul>\n<div><pre><code><span>const</span> <span>EMPTY_ARR</span> <span>=</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>?</span> Object<span>.</span><span>freeze</span><span>(</span><span>[</span><span>]</span><span>)</span> <span>:</span> <span>[</span><span>]</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li>TS 版</li>\n</ul>\n<div><pre><code><span>export</span> <span>const</span> <span>EMPTY_ARR</span> <span>=</span> __DEV__ <span>?</span> Object<span>.</span><span>freeze</span><span>(</span><span>[</span><span>]</span><span>)</span> <span>:</span> <span>[</span><span>]</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>和 EMPTY_OBJ 一样，在开发环境中，如果开发者误操作（对冻结后的数组进行修改），就可以在编译时发现错误（非严格模式下也会报错）。而在生产环境中则只需要直接使用 <code>[]</code> 创建空数组。</p>\n<h3 id=\"noop\"> NOOP</h3>\n<p>NOOP：空函数</p>\n<ul>\n<li>JS 版</li>\n</ul>\n<div><pre><code><span>const</span> <span>NOOP</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span> <span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li>TS 版</li>\n</ul>\n<div><pre><code><span>export</span> <span>const</span> <span>NOOP</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span><span>}</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"no\"> NO</h3>\n<p>NO：永远返回 <code>false</code> 的函数。</p>\n<ul>\n<li>JS 版</li>\n</ul>\n<div><pre><code><span>const</span> <span>NO</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>false</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li>TS 版</li>\n</ul>\n<div><pre><code><span>export</span> <span>const</span> <span>NO</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>false</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"ison\"> isOn</h3>\n<p>isOn：判断字符串是不是 <code>on</code> 开头，并且 <code>on</code> 后首字母不是小写字母。</p>\n<ul>\n<li>JS 版</li>\n</ul>\n<div><pre><code><span>const</span> onRE <span>=</span> <span><span>/</span><span>^on[^a-z]</span><span>/</span></span><span>;</span>\n<span>const</span> <span>isOn</span> <span>=</span> <span>(</span><span>key</span><span>)</span> <span>=></span> onRE<span>.</span><span>test</span><span>(</span>key<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p><code>^</code> 符号在开头，表示以什么开头，而在其他地方是指非。<br>\n<code>$</code> 符号在结尾，表示是以什么结尾。<br>\n<code>[]</code> 表示字符组，表示匹配其中任何一个字符。<br>\n<code>[^a-z]</code> 指不是 <code>a</code> 到 <code>z</code> 的小写字母，即英文小写字母以外的其它任意字符。</p>\n<ul>\n<li>TS 版</li>\n</ul>\n<div><pre><code><span>const</span> onRE <span>=</span> <span><span>/</span><span>^on[^a-z]</span><span>/</span></span>\n<span>export</span> <span>const</span> <span>isOn</span> <span>=</span> <span>(</span>key<span>:</span> <span>string</span><span>)</span> <span>=></span> onRE<span>.</span><span>test</span><span>(</span>key<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"ismodellistener\"> isModelListener</h3>\n<p>isModelListener 监听器：判断字符串是不是以 <code>onUpdate:</code> 开头。</p>\n<ul>\n<li>JS 版</li>\n</ul>\n<div><pre><code><span>const</span> <span>isModelListener</span> <span>=</span> <span>(</span><span>key</span><span>)</span> <span>=></span> key<span>.</span><span>startsWith</span><span>(</span><span>'onUpdate:'</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><code>startsWith()</code> 是 ES6 新增的方法，用于判断原字符串是不是以指定的参数字符串开头，返回布尔值。</p>\n<ul>\n<li>TS 版</li>\n</ul>\n<div><pre><code><span>export</span> <span>const</span> <span>isModelListener</span> <span>=</span> <span>(</span>key<span>:</span> <span>string</span><span>)</span> <span>=></span> key<span>.</span><span>startsWith</span><span>(</span><span>'onUpdate:'</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"extend\"> extend</h3>\n<p>extend：合并对象</p>\n<ul>\n<li>JS 版</li>\n</ul>\n<div><pre><code><span>const</span> extend <span>=</span> Object<span>.</span>assign<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><code>Object.assign()</code> 是 ES6 新增的方法，忽略 <code>enumerable</code> 为 <code>false</code> 的属性，只拷贝对象自身的可枚举的属性。</p>\n<ul>\n<li>TS 版</li>\n</ul>\n<div><pre><code><span>export</span> <span>const</span> extend <span>=</span> Object<span>.</span>assign\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"remove\"> remove</h3>\n<p>remove：移除数组的一项（传入一个数组和一个元素，删除第一个匹配到的值），直接修改在原数组上，无返回值。</p>\n<ul>\n<li>JS 版</li>\n</ul>\n<div><pre><code><span>const</span> <span>remove</span> <span>=</span> <span>(</span><span>arr<span>,</span> el</span><span>)</span> <span>=></span> <span>{</span>\n    <span>const</span> i <span>=</span> arr<span>.</span><span>indexOf</span><span>(</span>el<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>i <span>></span> <span>-</span><span>1</span><span>)</span> <span>{</span>\n        arr<span>.</span><span>splice</span><span>(</span>i<span>,</span> <span>1</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/splice\" target=\"_blank\" rel=\"noopener noreferrer\"><code>splice()</code></a> 方法通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容。此方法会改变原数组。</p>\n<p>例子：</p>\n<div><pre><code><span>// 第 1 个参数：从 0 计数，指定开始位置</span>\n<span>// 第 2 个参数：指定要移除的元素个数</span>\n<span>// 第 3 ~ N 个参数（可选）：指定要插入数组的元素，如果不指定，则 splice() 将只删除数组元素</span>\n<span>const</span> months <span>=</span> <span>[</span><span>'Jan'</span><span>,</span> <span>'March'</span><span>,</span> <span>'April'</span><span>,</span> <span>'June'</span><span>]</span><span>;</span>\nmonths<span>.</span><span>splice</span><span>(</span><span>1</span><span>,</span> <span>0</span><span>,</span> <span>'Feb'</span><span>)</span><span>;</span>\n<span>// inserts at index 1</span>\nconsole<span>.</span><span>log</span><span>(</span>months<span>)</span><span>;</span>\n<span>// expected output: Array [\"Jan\", \"Feb\", \"March\", \"April\", \"June\"]</span>\n\nmonths<span>.</span><span>splice</span><span>(</span><span>4</span><span>,</span> <span>1</span><span>,</span> <span>'May'</span><span>)</span><span>;</span>\n<span>// replaces 1 element at index 4</span>\nconsole<span>.</span><span>log</span><span>(</span>months<span>)</span><span>;</span>\n<span>// expected output: Array [\"Jan\", \"Feb\", \"March\", \"April\", \"May\"]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>但是，<code>splice()</code> 其实是一个很耗性能的方法，因为删除数组中的一项，其他元素都要移动位置。</p>\n<p>引申：在 <a href=\"https://github.com/axios/axios/blob/master/lib/core/InterceptorManager.js\" target=\"_blank\" rel=\"noopener noreferrer\"><code>axios InterceptorManager</code> 拦截器源码</a> 中，拦截器用数组存储的。但实际移除拦截器时，只是把拦截器置为 <code>null</code> 。而不是用 <code>splice</code> 移除。最后执行时为 <code>null</code> 的不执行，同样效果。axios 拦截器这个场景下，不得不说为性能做到了很好的考虑。</p>\n<p>看如下 axios 拦截器代码示例：</p>\n<div><pre><code><span>// 代码有删减</span>\n<span>// 声明</span>\n<span>this</span><span>.</span>handlers <span>=</span> <span>[</span><span>]</span><span>;</span>\n\n<span>// 移除</span>\n<span>if</span> <span>(</span><span>this</span><span>.</span>handlers<span>[</span>id<span>]</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>handlers<span>[</span>id<span>]</span> <span>=</span> <span>null</span><span>;</span>\n<span>}</span>\n\n<span>// 执行</span>\n<span>if</span> <span>(</span>h <span>!==</span> <span>null</span><span>)</span> <span>{</span>\n    <span>fn</span><span>(</span>h<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><ul>\n<li>TS 版</li>\n</ul>\n<div><pre><code><span>export</span> <span>const</span> remove <span>=</span> <span>&lt;</span><span>T</span><span>></span><span>(</span>arr<span>:</span> <span>T</span><span>[</span><span>]</span><span>,</span> el<span>:</span> <span>T</span><span>)</span> <span>=></span> <span>{</span>\n  <span>const</span> i <span>=</span> arr<span>.</span><span>indexOf</span><span>(</span>el<span>)</span>\n  <span>if</span> <span>(</span>i <span>></span> <span>-</span><span>1</span><span>)</span> <span>{</span>\n    arr<span>.</span><span>splice</span><span>(</span>i<span>,</span> <span>1</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>这里用到了 TypeScript 中的泛型，泛型是指在定义函数，接口或者类的时候，不预先定义好具体的类型，而在使用的时候再指定类型，或者索性使用的时候也不手动指定类型，让代码根据你传入的值，用类型推论自动推算出来。</p>\n<p>泛型的语法是在函数名后添加范型变量 <code>&lt;T&gt;</code>（上例的匿名函数将函数名称省略了），其中 <code>T</code> 用来指代任意输入的类型，之后我们就可以使用这个类型。例如在后面的两个输入参数 <code>arr: T[]</code> 和 <code>el: T</code> 中再次使用，分别指定了数组元素的类型和变量的类型。</p>\n<h3 id=\"hasown\"> hasOwn</h3>\n<p>hasOwn：是不是自己本身所拥有的属性</p>\n<ul>\n<li>JS 版</li>\n</ul>\n<div><pre><code><span>const</span> hasOwnProperty <span>=</span> <span>Object</span><span>.</span>prototype<span>.</span>hasOwnProperty<span>;</span>\n<span>const</span> <span>hasOwn</span> <span>=</span> <span>(</span><span>val<span>,</span> key</span><span>)</span> <span>=></span> <span>hasOwnProperty</span><span>.</span><span>call</span><span>(</span>val<span>,</span> key<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p><code>hasOwnProperty</code> 是 <code>Object</code> 原型上的方法，几乎所有的对象都可以调用该方法。该方法用于判断对象自身属性中有没有指定的属性，会返回一个布尔值（和 <code>in</code> 运算符不同，该方法会忽略掉那些从原型链上继承到的属性）。</p>\n<ul>\n<li>TS 版</li>\n</ul>\n<div><pre><code><span>const</span> hasOwnProperty <span>=</span> Object<span>.</span>prototype<span>.</span>hasOwnProperty\n<span>export</span> <span>const</span> hasOwn <span>=</span> <span>(</span>\n  val<span>:</span> object<span>,</span>\n  key<span>:</span> <span>string</span> <span>|</span> <span>symbol</span>\n<span>)</span><span>:</span> key <span>is</span> <span>keyof</span> <span>typeof</span> val <span>=></span> <span>hasOwnProperty</span><span>.</span><span>call</span><span>(</span>val<span>,</span> key<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>key is keyof typeof val</code> 这句比较复杂，包含了三个 TypeScript 语法，意思是函数返回的 <code>key</code> 是属于 <code>val</code> 对象的键的联合类型。</p>\n<p><code>is</code> 关键字：又被称为类型谓词。一般用在封装的类型判断函数中，用来判断参数是否属于某个类型，并根据结果返回对应的布尔类型。语法为 <code>prop is type</code>，例如：</p>\n<div><pre><code><span>// val is number 指定函数返回类型，而不是将 boolean 用为函数返回类型。</span>\n<span>// 因为在调用 isNumber 之后，如果函数返回 true，TypeScript 会将类型范围缩小为 string，</span>\n<span>// 这样在编译时就能发现代码错误，有效缩小类型范围，从而避免一些隐藏的运行时错误。</span>\n<span>const</span> isNumber <span>=</span> <span>(</span>val<span>:</span> <span>unknown</span><span>)</span><span>:</span> val <span>is</span> <span>number</span> <span>=></span> <span>typeof</span> val <span>===</span> <span>'number'</span>\n<span>const</span> isString <span>=</span> <span>(</span>val<span>:</span> <span>unknown</span><span>)</span><span>:</span> val <span>is</span> <span>string</span> <span>=></span> <span>typeof</span> val <span>===</span> <span>'string'</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>keyof</code> 操作符：用于获取某种类型的所有键，其返回类型是联合类型，例如：</p>\n<div><pre><code><span>interface</span> <span>Person</span> <span>{</span>\n  name<span>:</span> <span>string</span><span>,</span>\n  age<span>:</span> <span>number</span><span>;</span>\n  location<span>:</span> <span>string</span><span>;</span>\n<span>}</span>\n\n<span>// type 是 TypeScript 的保留关键字</span>\n<span>// 用来给一个类型起个新名字，常用于联合类型</span>\n<span>type</span> <span><span>K</span></span> <span>=</span> <span>keyof</span> Person<span>;</span> <span>// \"name\" | \"age\" | \"location\"</span>\n<span>let</span> param1<span>:</span> <span>K</span> <span>=</span> <span>\"name\"</span><span>;</span> <span>// 正常</span>\n<span>let</span> param2<span>:</span> <span>K</span> <span>=</span> <span>12</span><span>;</span>     <span>// 报错，只能为 K 中字符串其一</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><code>typeof</code> 操作符：js 中的 <code>typeof</code> 只能获取几种类型，而在 ts 中 <code>typeof</code> 用来获取一个变量或对象的类型，例如：</p>\n<div><pre><code><span>interface</span> <span>Person</span> <span>{</span>\n  name<span>:</span> <span>string</span><span>,</span>\n  age<span>:</span> <span>number</span><span>;</span>\n<span>}</span>\n\n<span>const</span> sem<span>:</span> Person <span>=</span> <span>{</span> name<span>:</span> <span>'semlinker'</span><span>,</span> age<span>:</span> <span>30</span> <span>}</span><span>;</span>\n<span>type</span> <span>Sem</span> <span>=</span> <span>typeof</span> sem<span>;</span> <span>// type Sem = Person</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"isarray\"> isArray</h3>\n<p>isArray：判断是否数组</p>\n<ul>\n<li>JS 版</li>\n</ul>\n<div><pre><code><span>const</span> isArray <span>=</span> Array<span>.</span>isArray<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><code>Array.isArray</code> 比 <code>instanceof</code> 更加可靠，如下代码对比两者的区别：</p>\n<div><pre><code><span>const</span> arr <span>=</span> <span>[</span><span>]</span>\n<span>const</span> fakeArr <span>=</span> <span>{</span> __proto__<span>:</span> <span>Array</span><span>.</span>prototype<span>,</span> length<span>:</span> <span>0</span> <span>}</span><span>;</span>\n\n<span>// 如果参数是数组一定返回 true，否则一定返回 false</span>\n<span>// 在判断对象是否为数组时，采用Array.isArray 更加可靠</span>\nArray<span>.</span><span>isArray</span><span>(</span><span>Array</span><span>.</span>prototype<span>)</span>   <span>// true</span>\nArray<span>.</span><span>isArray</span><span>(</span>arr<span>)</span>               <span>// true</span>\nArray<span>.</span><span>isArray</span><span>(</span>fakeArr<span>)</span><span>;</span>          <span>// false</span>\n\n<span>// instanceof 操作符判断左边是否为右边的实例，其工作原理是判断右边参数的原型是否在左边参数的原型链上</span>\n<span>Array</span><span>.</span>prototype <span>instanceof</span> <span>Array</span> <span>// false 不能正确判断 Array.prototype</span>\narr <span>instanceof</span> <span>Array</span>             <span>// true</span>\nfakeArr <span>instanceof</span> <span>Array</span><span>;</span>        <span>// true 可以被刻意误导</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><ul>\n<li>TS 版</li>\n</ul>\n<div><pre><code><span>export</span> <span>const</span> isArray <span>=</span> <span>Array</span><span>.</span>isArray\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"ismap\"> isMap</h3>\n<p>isMap：判断是否 Map 对象</p>\n<ul>\n<li>JS 版</li>\n</ul>\n<div><pre><code><span>const</span> <span>isMap</span> <span>=</span> <span>(</span><span>val</span><span>)</span> <span>=></span> <span>toTypeString</span><span>(</span>val<span>)</span> <span>===</span> <span>'[object Map]'</span><span>;</span>\n\n<span>const</span> objectToString <span>=</span> <span>Object</span><span>.</span>prototype<span>.</span>toString<span>;</span>\n<span>const</span> <span>toTypeString</span> <span>=</span> <span>(</span><span>value</span><span>)</span> <span>=></span> <span>objectToString</span><span>.</span><span>call</span><span>(</span>value<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>Map 是 ES6 提供的数据结构，它类似于对象，也是键值对的集合。但是「键」的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了「字符串—值」的对应，Map 结构提供了「值—值」的对应，是一种更完善的 Hash 结构实现。如果你需要「键值对」的数据结构，Map 比 Object 更合适。</p>\n<p>Map 的用法：</p>\n<div><pre><code><span>let</span> map <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span><span>;</span>\n<span>let</span> o <span>=</span> <span>{</span> p<span>:</span> <span>'Hello World'</span> <span>}</span><span>;</span>\n\nmap<span>.</span><span>set</span><span>(</span>o<span>,</span> <span>'content'</span><span>)</span><span>;</span>\nmap<span>.</span><span>get</span><span>(</span>o<span>)</span><span>;</span> <span>// 'content'</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>\n<li>TS 版</li>\n</ul>\n<div><pre><code><span>export</span> <span>const</span> isMap <span>=</span> <span>(</span>val<span>:</span> <span>unknown</span><span>)</span><span>:</span> val <span>is</span> Map<span>&lt;</span><span>any</span><span>,</span> <span>any</span><span>></span> <span>=></span>\n  <span>toTypeString</span><span>(</span>val<span>)</span> <span>===</span> <span>'[object Map]'</span>\n\n<span>export</span> <span>const</span> objectToString <span>=</span> Object<span>.</span>prototype<span>.</span>toString\n<span>export</span> <span>const</span> toTypeString <span>=</span> <span>(</span>value<span>:</span> <span>unknown</span><span>)</span><span>:</span> <span>string</span> <span>=></span>\n  <span>objectToString</span><span>.</span><span>call</span><span>(</span>value<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"isset\"> isSet</h3>\n<p>isSet：判断是否 Set 对象</p>\n<ul>\n<li>JS 版</li>\n</ul>\n<div><pre><code><span>const</span> <span>isSet</span> <span>=</span> <span>(</span><span>val</span><span>)</span> <span>=></span> <span>toTypeString</span><span>(</span>val<span>)</span> <span>===</span> <span>'[object Set]'</span><span>;</span>\n\n<span>export</span> <span>const</span> objectToString <span>=</span> <span>Object</span><span>.</span>prototype<span>.</span>toString\n<span>export</span> <span>const</span> toTypeString <span>=</span> <span>(</span>value<span>:</span> unknown<span>)</span><span>:</span> <span>string</span> <span>=></span>\n  <span>objectToString</span><span>.</span><span>call</span><span>(</span>value<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>Set 是 ES6 提供的数据结构，它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>\n<p>Set 的用法：</p>\n<div><pre><code><span>let</span> set <span>=</span> <span>new</span> <span>Set</span><span>(</span><span>)</span><span>;</span>\n<span>// 在 Set 内部，两个NaN是相等的。</span>\n<span>let</span> a <span>=</span> <span>NaN</span><span>;</span>\n<span>let</span> b <span>=</span> <span>NaN</span><span>;</span>\nset<span>.</span><span>add</span><span>(</span>a<span>)</span><span>;</span>\nset<span>.</span><span>add</span><span>(</span>b<span>)</span><span>;</span>\n<span>set</span> <span>// Set { NaN }</span>\n\n<span>// 而两个对象总是不相等的</span>\nset<span>.</span><span>add</span><span>(</span><span>{</span><span>}</span><span>)</span><span>;</span>\nset<span>.</span><span>add</span><span>(</span><span>{</span><span>}</span><span>)</span><span>;</span>\n<span>set</span> <span>// Set { NaN, {}, {} }</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><ul>\n<li>TS 版</li>\n</ul>\n<div><pre><code><span>export</span> <span>const</span> isSet <span>=</span> <span>(</span>val<span>:</span> <span>unknown</span><span>)</span><span>:</span> val <span>is</span> Set<span>&lt;</span><span>any</span><span>></span> <span>=></span>\n  <span>toTypeString</span><span>(</span>val<span>)</span> <span>===</span> <span>'[object Set]'</span>\n\n<span>export</span> <span>const</span> objectToString <span>=</span> Object<span>.</span>prototype<span>.</span>toString\n<span>export</span> <span>const</span> toTypeString <span>=</span> <span>(</span>value<span>:</span> <span>unknown</span><span>)</span><span>:</span> <span>string</span> <span>=></span>\n  <span>objectToString</span><span>.</span><span>call</span><span>(</span>value<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"其它判断是否某种类型的函数\"> 其它判断是否某种类型的函数</h3>\n<ul>\n<li>JS 版</li>\n</ul>\n<div><pre><code><span>// 判断是否 Date 对象</span>\n<span>// instanceof 这种根据原型链向上查找的方式不太精确，但这里够用了。</span>\n<span>const</span> <span>isDate</span> <span>=</span> <span>(</span><span>val</span><span>)</span> <span>=></span> val <span>instanceof</span> <span>Date</span><span>;</span>\n\n<span>// 判断是否函数</span>\n<span>const</span> <span>isFunction</span> <span>=</span> <span>(</span><span>val</span><span>)</span> <span>=></span> <span>typeof</span> val <span>===</span> <span>'function'</span><span>;</span>\n\n<span>// 判断是否字符串</span>\n<span>const</span> <span>isString</span> <span>=</span> <span>(</span><span>val</span><span>)</span> <span>=></span> <span>typeof</span> val <span>===</span> <span>'string'</span><span>;</span>\n\n<span>// 判断是否 Symbol</span>\n<span>// Symbol 是 ES6 引入的一种新的原始数据类型，表示独一无二的值。</span>\n<span>const</span> <span>isSymbol</span> <span>=</span> <span>(</span><span>val</span><span>)</span> <span>=></span> <span>typeof</span> val <span>===</span> <span>'symbol'</span><span>;</span>\n\n<span>// 判断是否对象</span>\n<span>// 因为 typeof null 也是 \"object\"，所以这里同时判断了非 null 的值</span>\n<span>const</span> <span>isObject</span> <span>=</span> <span>(</span><span>val</span><span>)</span> <span>=></span> val <span>!==</span> <span>null</span> <span>&amp;&amp;</span> <span>typeof</span> val <span>===</span> <span>'object'</span><span>;</span>\n\n<span>// 判断是否 Promise</span>\n<span>const</span> <span>isPromise</span> <span>=</span> <span>(</span><span>val</span><span>)</span> <span>=></span> <span>{</span>\n    <span>return</span> <span>isObject</span><span>(</span>val<span>)</span> <span>&amp;&amp;</span> <span>isFunction</span><span>(</span>val<span>.</span>then<span>)</span> <span>&amp;&amp;</span> <span>isFunction</span><span>(</span>val<span>.</span>catch<span>)</span><span>;</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><ul>\n<li>TS 版</li>\n</ul>\n<div><pre><code><span>// 判断是否 Date 对象</span>\n<span>export</span> <span>const</span> isDate <span>=</span> <span>(</span>val<span>:</span> <span>unknown</span><span>)</span><span>:</span> val <span>is</span> Date <span>=></span> val <span>instanceof</span> <span>Date</span>\n\n<span>// 判断是否函数</span>\n<span>export</span> <span>const</span> isFunction <span>=</span> <span>(</span>val<span>:</span> <span>unknown</span><span>)</span><span>:</span> val <span>is</span> <span>Function</span> <span>=></span>\n  <span>typeof</span> val <span>===</span> <span>'function'</span>\n\n<span>// 判断是否字符串</span>\n<span>export</span> <span>const</span> isString <span>=</span> <span>(</span>val<span>:</span> <span>unknown</span><span>)</span><span>:</span> val <span>is</span> <span>string</span> <span>=></span> <span>typeof</span> val <span>===</span> <span>'string'</span>\n\n<span>// 判断是否 Symbol</span>\n<span>export</span> <span>const</span> isSymbol <span>=</span> <span>(</span>val<span>:</span> <span>unknown</span><span>)</span><span>:</span> val <span>is</span> <span>symbol</span> <span>=></span> <span>typeof</span> val <span>===</span> <span>'symbol'</span>\n\n<span>// 判断是否对象</span>\n<span>export</span> <span>const</span> isObject <span>=</span> <span>(</span>val<span>:</span> <span>unknown</span><span>)</span><span>:</span> val <span>is</span> Record<span>&lt;</span><span>any</span><span>,</span> <span>any</span><span>></span> <span>=></span>\n  val <span>!==</span> <span>null</span> <span>&amp;&amp;</span> <span>typeof</span> val <span>===</span> <span>'object'</span>\n\n<span>// 判断是否 Promise</span>\n<span>export</span> <span>const</span> isPromise <span>=</span> <span>&lt;</span><span>T</span> <span>=</span> <span>any</span><span>></span><span>(</span>val<span>:</span> <span>unknown</span><span>)</span><span>:</span> val <span>is</span> <span>Promise</span><span>&lt;</span><span>T</span><span>></span> <span>=></span> <span>{</span>\n  <span>return</span> <span>isObject</span><span>(</span>val<span>)</span> <span>&amp;&amp;</span> <span>isFunction</span><span>(</span>val<span>.</span>then<span>)</span> <span>&amp;&amp;</span> <span>isFunction</span><span>(</span>val<span>.</span>catch<span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h3 id=\"torawtype\"> toRawType</h3>\n<p>toRawType：对象转字符串，截取后第八位到倒数第二位</p>\n<ul>\n<li>JS 版</li>\n</ul>\n<div><pre><code><span>const</span> <span>toRawType</span> <span>=</span> <span>(</span><span>value</span><span>)</span> <span>=></span> <span>{</span>\n    <span>// extract \"RawType\" from strings like \"[object RawType]\"</span>\n    <span>return</span> <span>toTypeString</span><span>(</span>value<span>)</span><span>.</span><span>slice</span><span>(</span><span>8</span><span>,</span> <span>-</span><span>1</span><span>)</span><span>;</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>可以截取到 <code>String</code>、<code>Array</code> 等这些类型，这个函数可以用来做类型判断。</p>\n<p>JS 判断类型也有 <code>typeof</code> ，但不是很准确，而且能够识别出的不多。<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof\" target=\"_blank\" rel=\"noopener noreferrer\">MDN - typeof 文档</a> 中介绍的比较详细，而且也实现了一个很完善的 <code>type</code> 函数。</p>\n<div><pre><code>// typeof 返回值目前有以下8种 \n&#39;undefined&#39;\n&#39;object&#39;\n&#39;boolean&#39;\n&#39;number&#39;\n&#39;bigint&#39;\n&#39;string&#39;\n&#39;symobl&#39;\n&#39;function&#39;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ul>\n<li>TS 版</li>\n</ul>\n<div><pre><code><span>export</span> <span>const</span> toRawType <span>=</span> <span>(</span>value<span>:</span> <span>unknown</span><span>)</span><span>:</span> <span>string</span> <span>=></span> <span>{</span>\n  <span>// extract \"RawType\" from strings like \"[object RawType]\"</span>\n  <span>return</span> <span>toTypeString</span><span>(</span>value<span>)</span><span>.</span><span>slice</span><span>(</span><span>8</span><span>,</span> <span>-</span><span>1</span><span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"isplainobject\"> isPlainObject</h3>\n<p>isPlainObject：判断是否纯粹的对象</p>\n<ul>\n<li>JS 版</li>\n</ul>\n<div><pre><code><span>const</span> <span>isPlainObject</span> <span>=</span> <span>(</span><span>val</span><span>)</span> <span>=></span> <span>toTypeString</span><span>(</span>val<span>)</span> <span>===</span> <span>'[object Object]'</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>前面有一个 <code>isObject</code> 用来判断是否对象，这里的 <code>isPlainObject</code> 区别在于：</p>\n<div><pre><code><span>isObject</span><span>(</span><span>[</span><span>]</span><span>)</span>      <span>// true  因为 type [] 为 'object'</span>\n<span>isPlainObject</span><span>(</span><span>[</span><span>]</span><span>)</span> <span>// false</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><ul>\n<li>TS 版</li>\n</ul>\n<div><pre><code><span>export</span> <span>const</span> isPlainObject <span>=</span> <span>(</span>val<span>:</span> <span>unknown</span><span>)</span><span>:</span> val <span>is</span> object <span>=></span>\n  <span>toTypeString</span><span>(</span>val<span>)</span> <span>===</span> <span>'[object Object]'</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"isintegerkey\"> isIntegerKey</h3>\n<p>isIntegerKey：判断是不是数字型的字符串 key 值</p>\n<ul>\n<li>JS 版</li>\n</ul>\n<div><pre><code><span>const</span> <span>isIntegerKey</span> <span>=</span> <span>(</span><span>key</span><span>)</span> <span>=></span> <span>isString</span><span>(</span>key<span>)</span> <span>&amp;&amp;</span>\n    key <span>!==</span> <span>'NaN'</span> <span>&amp;&amp;</span>\n    key<span>[</span><span>0</span><span>]</span> <span>!==</span> <span>'-'</span> <span>&amp;&amp;</span>\n    <span>''</span> <span>+</span> <span>parseInt</span><span>(</span>key<span>,</span> <span>10</span><span>)</span> <span>===</span> key<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>第一步先判断 key 是否是字符串类型（作为 key 值有两种类型，<code>string</code> 和 <code>symbol</code>），第二步排除 <code>NaN</code> 值，第三步排除 <code>-</code> 值（排除负数），第四步将 key 转换成数字再隐式转换为字符串，与原 key 对比。</p>\n<ul>\n<li>TS 版</li>\n</ul>\n<div><pre><code><span>export</span> <span>const</span> <span>isIntegerKey</span> <span>=</span> <span>(</span>key<span>:</span> <span>unknown</span><span>)</span> <span>=></span>\n  <span>isString</span><span>(</span>key<span>)</span> <span>&amp;&amp;</span>\n  key <span>!==</span> <span>'NaN'</span> <span>&amp;&amp;</span>\n  key<span>[</span><span>0</span><span>]</span> <span>!==</span> <span>'-'</span> <span>&amp;&amp;</span>\n  <span>''</span> <span>+</span> <span>parseInt</span><span>(</span>key<span>,</span> <span>10</span><span>)</span> <span>===</span> key\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"isreservedprop\"> isReservedProp</h3>\n<p>isReservedProp：判断该属性是否为保留属性</p>\n<ul>\n<li>JS 版</li>\n</ul>\n<div><pre><code><span>/**\n * Make a map and return a function for checking if a key\n * is in that map.\n * IMPORTANT: all calls of this function must be prefixed with\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\n * So that rollup can tree-shake them if necessary.\n */</span>\n<span>function</span> <span>makeMap</span><span>(</span><span>str<span>,</span> expectsLowerCase</span><span>)</span> <span>{</span>\n    <span>const</span> map <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>null</span><span>)</span><span>;</span>\n    <span>const</span> list <span>=</span> str<span>.</span><span>split</span><span>(</span><span>','</span><span>)</span><span>;</span>\n    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> list<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        map<span>[</span>list<span>[</span>i<span>]</span><span>]</span> <span>=</span> <span>true</span><span>;</span>\n    <span>}</span>\n    <span>return</span> expectsLowerCase <span>?</span> <span>val</span> <span>=></span> <span>!</span><span>!</span>map<span>[</span>val<span>.</span><span>toLowerCase</span><span>(</span><span>)</span><span>]</span> <span>:</span> <span>val</span> <span>=></span> <span>!</span><span>!</span>map<span>[</span>val<span>]</span><span>;</span>\n<span>}</span>\n\n<span>const</span> isReservedProp <span>=</span> <span>/*#__PURE__*/</span> <span>makeMap</span><span>(</span>\n<span>// the leading comma is intentional so empty string \"\" is also included</span>\n<span>',key,ref,'</span> <span>+</span>\n    <span>'onVnodeBeforeMount,onVnodeMounted,'</span> <span>+</span>\n    <span>'onVnodeBeforeUpdate,onVnodeUpdated,'</span> <span>+</span>\n    <span>'onVnodeBeforeUnmount,onVnodeUnmounted'</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>这个函数依赖于 <code>makeMap</code>，也是 Vue3 源码中自用的工具函数，它传入一个以逗号分隔的字符串，将这个字符串转换成数组，并循环赋值 key 給一个空对象 map，然后返回一个包含参数 val 的闭包用来检查 val 是否是存在在字符串中。</p>\n<p><code>isReservedProp(&quot;key&quot;)</code> 其实就相当于 <code>makeMap(str)(&quot;key&quot;)</code>。</p>\n<p>测试：</p>\n<div><pre><code><span>// 保留的属性</span>\n<span>isReservedProp</span><span>(</span><span>'key'</span><span>)</span><span>;</span>                  <span>// true</span>\n<span>isReservedProp</span><span>(</span><span>'ref'</span><span>)</span><span>;</span>                  <span>// true</span>\n<span>isReservedProp</span><span>(</span><span>'onVnodeBeforeMount'</span><span>)</span><span>;</span>   <span>// true</span>\n<span>isReservedProp</span><span>(</span><span>'onVnodeMounted'</span><span>)</span><span>;</span>       <span>// true</span>\n<span>isReservedProp</span><span>(</span><span>'onVnodeBeforeUpdate'</span><span>)</span><span>;</span>  <span>// true</span>\n<span>isReservedProp</span><span>(</span><span>'onVnodeUpdated'</span><span>)</span><span>;</span>       <span>// true</span>\n<span>isReservedProp</span><span>(</span><span>'onVnodeBeforeUnmount'</span><span>)</span><span>;</span> <span>// true</span>\n<span>isReservedProp</span><span>(</span><span>'onVnodeUnmounted'</span><span>)</span><span>;</span>     <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ul>\n<li>TS 版</li>\n</ul>\n<div><pre><code><span>/**\n * Make a map and return a function for checking if a key\n * is in that map.\n * IMPORTANT: all calls of this function must be prefixed with\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\n * So that rollup can tree-shake them if necessary.\n */</span>\n<span>export</span> <span>function</span> <span>makeMap</span><span>(</span>\n  str<span>:</span> <span>string</span><span>,</span>\n  expectsLowerCase<span>?</span><span>:</span> <span>boolean</span>\n<span>)</span><span>:</span> <span>(</span>key<span>:</span> <span>string</span><span>)</span> <span>=></span> <span>boolean</span> <span>{</span>\n  <span>const</span> map<span>:</span> Record<span>&lt;</span><span>string</span><span>,</span> <span>boolean</span><span>></span> <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>null</span><span>)</span>\n  <span>const</span> list<span>:</span> <span>Array</span><span>&lt;</span><span>string</span><span>></span> <span>=</span> str<span>.</span><span>split</span><span>(</span><span>','</span><span>)</span>\n  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> list<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n    map<span>[</span>list<span>[</span>i<span>]</span><span>]</span> <span>=</span> <span>true</span>\n  <span>}</span>\n  <span>return</span> expectsLowerCase <span>?</span> val <span>=></span> <span>!</span><span>!</span>map<span>[</span>val<span>.</span><span>toLowerCase</span><span>(</span><span>)</span><span>]</span> <span>:</span> val <span>=></span> <span>!</span><span>!</span>map<span>[</span>val<span>]</span>\n<span>}</span>\n\n<span>export</span> <span>const</span> isReservedProp <span>=</span> <span>/*#__PURE__*/</span> <span>makeMap</span><span>(</span>\n  <span>// the leading comma is intentional so empty string \"\" is also included</span>\n  <span>',key,ref,'</span> <span>+</span>\n    <span>'onVnodeBeforeMount,onVnodeMounted,'</span> <span>+</span>\n    <span>'onVnodeBeforeUpdate,onVnodeUpdated,'</span> <span>+</span>\n    <span>'onVnodeBeforeUnmount,onVnodeUnmounted'</span>\n<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h3 id=\"cachestringfunction\"> cacheStringFunction</h3>\n<p>cacheStringFunction：缓存字符串的函数</p>\n<ul>\n<li>JS 版</li>\n</ul>\n<div><pre><code><span>const</span> <span>cacheStringFunction</span> <span>=</span> <span>(</span><span>fn</span><span>)</span> <span>=></span> <span>{</span>\n    <span>const</span> cache <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>null</span><span>)</span><span>;</span>\n    <span>return</span> <span>(</span><span>(</span><span>str</span><span>)</span> <span>=></span> <span>{</span>\n        <span>const</span> hit <span>=</span> cache<span>[</span>str<span>]</span><span>;</span>\n        <span>return</span> hit <span>||</span> <span>(</span>cache<span>[</span>str<span>]</span> <span>=</span> <span>fn</span><span>(</span>str<span>)</span><span>)</span><span>;</span>\n    <span>}</span><span>)</span><span>;</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>这个函数和上面 <code>makeMap</code> 函数类似，传入一个 <code>fn</code> 参数，返回一个包含参数 <code>str</code> 的闭包，将这个 <code>str</code> 字符串作为 key 赋值给一个空对象 <code>cache</code>，闭包返回 <code>cache[str] || (cache[str] = fn(str))</code>。</p>\n<p><code>cache[str] || (cache[str] = fn(str))</code> 的意思是，如果 <code>cache</code> 有缓存到 <code>str</code> 这个 key，直接返回对应的值；否则，先调用 <code>fn(str)</code>，再赋值给 <code>cache[str]</code>，这样可以将需要经过 <code>fn</code> 函数处理的字符串缓存起来，避免多次重复处理字符串。</p>\n<p>用法举例（也是来自于源码后面几行内容）：</p>\n<div><pre><code><span>// \\w 就是 [0-9a-zA-Z_]。表示数字、大小写字母和下划线。</span>\n<span>// () 小括号是分组捕获</span>\n<span>// g 是 global 的意思，表示全局匹配，即在目标字符串中按顺序找到满足匹配模式的所有子串</span>\n<span>const</span> camelizeRE <span>=</span> <span><span>/</span><span>-(\\w)</span><span>/</span><span>g</span></span><span>;</span>\n<span>/**\n * @private\n */</span>\n<span>// 连字符 => 驼峰  on-click => onClick</span>\n<span>const</span> camelize <span>=</span> <span>cacheStringFunction</span><span>(</span><span>(</span><span>str</span><span>)</span> <span>=></span> <span>{</span>\n    <span>return</span> str<span>.</span><span>replace</span><span>(</span>camelizeRE<span>,</span> <span>(</span><span>_<span>,</span> c</span><span>)</span> <span>=></span> <span>(</span>c <span>?</span> c<span>.</span><span>toUpperCase</span><span>(</span><span>)</span> <span>:</span> <span>''</span><span>)</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n\n<span>// \\B 是指非单词边界(与 \\b 是反面意思)</span>\n<span>const</span> hyphenateRE <span>=</span> <span><span>/</span><span>\\B([A-Z])</span><span>/</span><span>g</span></span><span>;</span>\n<span>/**\n * @private\n */</span>\n<span>// 驼峰 => 连字符  onClick => on-click</span>\n<span>const</span> hyphenate <span>=</span> <span>cacheStringFunction</span><span>(</span><span>(</span><span>str</span><span>)</span> <span>=></span> str<span>.</span><span>replace</span><span>(</span>hyphenateRE<span>,</span> <span>'-$1'</span><span>)</span><span>.</span><span>toLowerCase</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\n<span>/**\n * @private\n */</span>\n<span>// 首字母转大写</span>\n<span>const</span> capitalize <span>=</span> <span>cacheStringFunction</span><span>(</span><span>(</span><span>str</span><span>)</span> <span>=></span> str<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span><span>.</span><span>toUpperCase</span><span>(</span><span>)</span> <span>+</span> str<span>.</span><span>slice</span><span>(</span><span>1</span><span>)</span><span>)</span><span>;</span>\n\n<span>/**\n * @private\n */</span>\n<span>// 加上 on 字符串  click => onClick</span>\n<span>const</span> toHandlerKey <span>=</span> <span>cacheStringFunction</span><span>(</span><span>(</span><span>str</span><span>)</span> <span>=></span> str <span>?</span> <span><span>`</span><span>on</span><span><span>${</span><span>capitalize</span><span>(</span>str<span>)</span><span>}</span></span><span>`</span></span> <span>:</span> <span><span>`</span><span>`</span></span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><ul>\n<li>TS 版</li>\n</ul>\n<div><pre><code><span>const</span> cacheStringFunction <span>=</span> <span>&lt;</span><span>T</span> <span>extends</span> <span>(</span>str<span>:</span> <span>string</span><span>)</span> <span>=></span> <span>string</span><span>></span><span>(</span>fn<span>:</span> <span>T</span><span>)</span><span>:</span> <span>T</span> <span>=></span> <span>{</span>\n  <span>const</span> cache<span>:</span> Record<span>&lt;</span><span>string</span><span>,</span> <span>string</span><span>></span> <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>null</span><span>)</span>\n  <span>return</span> <span>(</span><span>(</span>str<span>:</span> <span>string</span><span>)</span> <span>=></span> <span>{</span>\n    <span>const</span> hit <span>=</span> cache<span>[</span>str<span>]</span>\n    <span>return</span> hit <span>||</span> <span>(</span>cache<span>[</span>str<span>]</span> <span>=</span> <span>fn</span><span>(</span>str<span>)</span><span>)</span>\n  <span>}</span><span>)</span> <span>as</span> <span>any</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>用法举例（也是来自于源码后面几行内容）：</p>\n<div><pre><code><span>const</span> camelizeRE <span>=</span> <span><span>/</span><span>-(\\w)</span><span>/</span><span>g</span></span>\n<span>/**\n * @private\n */</span>\n<span>export</span> <span>const</span> camelize <span>=</span> <span>cacheStringFunction</span><span>(</span><span>(</span>str<span>:</span> <span>string</span><span>)</span><span>:</span> <span>string</span> <span>=></span> <span>{</span>\n  <span>return</span> str<span>.</span><span>replace</span><span>(</span>camelizeRE<span>,</span> <span>(</span>_<span>,</span> c<span>)</span> <span>=></span> <span>(</span>c <span>?</span> c<span>.</span><span>toUpperCase</span><span>(</span><span>)</span> <span>:</span> <span>''</span><span>)</span><span>)</span>\n<span>}</span><span>)</span>\n\n<span>const</span> hyphenateRE <span>=</span> <span><span>/</span><span>\\B([A-Z])</span><span>/</span><span>g</span></span>\n<span>/**\n * @private\n */</span>\n<span>export</span> <span>const</span> hyphenate <span>=</span> <span>cacheStringFunction</span><span>(</span><span>(</span>str<span>:</span> <span>string</span><span>)</span> <span>=></span>\n  str<span>.</span><span>replace</span><span>(</span>hyphenateRE<span>,</span> <span>'-$1'</span><span>)</span><span>.</span><span>toLowerCase</span><span>(</span><span>)</span>\n<span>)</span>\n\n<span>/**\n * @private\n */</span>\n<span>export</span> <span>const</span> capitalize <span>=</span> <span>cacheStringFunction</span><span>(</span>\n  <span>(</span>str<span>:</span> <span>string</span><span>)</span> <span>=></span> str<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span><span>.</span><span>toUpperCase</span><span>(</span><span>)</span> <span>+</span> str<span>.</span><span>slice</span><span>(</span><span>1</span><span>)</span>\n<span>)</span>\n\n<span>/**\n * @private\n */</span>\n<span>export</span> <span>const</span> toHandlerKey <span>=</span> <span>cacheStringFunction</span><span>(</span><span>(</span>str<span>:</span> <span>string</span><span>)</span> <span>=></span>\n  str <span>?</span> <span><span>`</span><span>on</span><span><span>${</span><span>capitalize</span><span>(</span>str<span>)</span><span>}</span></span><span>`</span></span> <span>:</span> <span><span>`</span><span>`</span></span>\n<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h3 id=\"haschanged\"> hasChanged</h3>\n<p>hasChanged：判断是否有变化</p>\n<ul>\n<li>JS 版</li>\n</ul>\n<div><pre><code><span>// compare whether a value has changed, accounting for NaN.</span>\n<span>const</span> <span>hasChanged</span> <span>=</span> <span>(</span><span>value<span>,</span> oldValue</span><span>)</span> <span>=></span> <span>!</span>Object<span>.</span><span>is</span><span>(</span>value<span>,</span> oldValue<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p><code>Object.is(value1, value2)</code> 是 ES6 提供的方法，用来比较两个值是否严格相等。它与严格比较运算符（<code>===</code>）的行为基本一致。不同之处只有两个：一是 <code>+0</code> 不等于 <code>-0</code>，而 <code>NaN</code> 等于自身。</p>\n<p>对比：</p>\n<div><pre><code>Object<span>.</span><span>is</span><span>(</span><span>'abc'</span><span>,</span> <span>'abc'</span><span>)</span><span>;</span> <span>// true</span>\nObject<span>.</span><span>is</span><span>(</span><span>{</span><span>}</span><span>,</span><span>{</span><span>}</span><span>)</span><span>;</span>        <span>// false</span>\nObject<span>.</span><span>is</span><span>(</span><span>+</span><span>0</span><span>,</span> <span>-</span><span>0</span><span>)</span><span>;</span>       <span>// false</span>\nObject<span>.</span><span>is</span><span>(</span><span>NaN</span><span>,</span> <span>NaN</span><span>)</span><span>;</span>     <span>// true</span>\n\n<span>+</span><span>0</span> <span>===</span> <span>-</span><span>0</span><span>;</span>               <span>// true</span>\n<span>NaN</span> <span>===</span> <span>NaN</span><span>;</span>             <span>// false</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>因而基于 <code>Object.is</code> 的 <code>hasChanged</code> 会有如下比较结果：</p>\n<div><pre><code><span>hasChanged</span><span>(</span><span>NaN</span><span>,</span> <span>NaN</span><span>)</span><span>;</span> <span>// false</span>\n<span>hasChanged</span><span>(</span><span>1</span><span>,</span> <span>1</span><span>)</span><span>;</span>     <span>// false</span>\n<span>hasChanged</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span><span>;</span>     <span>// true</span>\n<span>hasChanged</span><span>(</span><span>+</span><span>0</span><span>,</span> <span>-</span><span>0</span><span>)</span><span>;</span>   <span>// false</span>\n\n<span>// 场景</span>\n<span>// watch 监测值是否变化了</span>\n<span>// (value === value || oldValue === oldValue)</span>\n<span>// 为什么会有这句，因为要判断 NaN。hasChanged 认为 NaN 是不变的，通过 NaN === NaN 为 false 来判断。</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>ES5 可以通过以下代码实现 <code>Object.is</code>。</p>\n<div><pre><code>Object<span>.</span><span>defineProperty</span><span>(</span>Object<span>,</span> <span>'is'</span><span>,</span> <span>{</span>\n    <span>value</span><span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span>x<span>,</span> y<span>}</span> <span>{</span>\n        <span>if</span> <span>(</span>x <span>===</span> y<span>)</span> <span>{</span>\n           <span>// 针对 +0 不等于 -0 的情况</span>\n           <span>return</span> x <span>!==</span> <span>0</span> <span>||</span> <span>1</span> <span>/</span> x <span>===</span> <span>1</span> <span>/</span> y<span>;</span>\n        <span>}</span>\n        <span>// 针对 NaN的情况</span>\n        <span>return</span> x <span>!==</span> x <span>&amp;&amp;</span> y <span>!==</span> y<span>;</span>\n    <span>}</span><span>,</span>\n    configurable<span>:</span> <span>true</span><span>,</span>\n    enumerable<span>:</span> <span>false</span><span>,</span>\n    writable<span>:</span> <span>true</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><ul>\n<li>TS 版</li>\n</ul>\n<div><pre><code><span>// compare whether a value has changed, accounting for NaN.</span>\n<span>export</span> <span>const</span> hasChanged <span>=</span> <span>(</span>value<span>:</span> <span>any</span><span>,</span> oldValue<span>:</span> <span>any</span><span>)</span><span>:</span> <span>boolean</span> <span>=></span>\n  <span>!</span>Object<span>.</span><span>is</span><span>(</span>value<span>,</span> oldValue<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"invokearrayfns\"> invokeArrayFns</h3>\n<p>invokeArrayFns：执行数组里的函数</p>\n<p>当有多个函数要依次执行，且每个函数的参数存在包含关系（或个别函数没有参数）时，可以用这种写法来统一执行多个函数。</p>\n<ul>\n<li>JS 版</li>\n</ul>\n<div><pre><code><span>const</span> <span>invokeArrayFns</span> <span>=</span> <span>(</span><span>fns<span>,</span> arg</span><span>)</span> <span>=></span> <span>{</span>\n    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> fns<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        fns<span>[</span>i<span>]</span><span>(</span>arg<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>用法示例：</p>\n<div><pre><code><span>const</span> funcArr <span>=</span> <span>[</span>\n    <span>function</span><span>(</span><span>val</span><span>)</span><span>{</span>\n        console<span>.</span><span>log</span><span>(</span><span>'当前时间是:'</span> <span>+</span> val<span>)</span><span>;</span>\n    <span>}</span><span>,</span>\n    <span>function</span><span>(</span><span>val</span><span>)</span><span>{</span>\n        console<span>.</span><span>log</span><span>(</span><span>'打印当前时间:'</span> <span>+</span> val<span>)</span><span>;</span>\n    <span>}</span><span>,</span>\n    <span>function</span><span>(</span><span>)</span><span>{</span>\n        console<span>.</span><span>log</span><span>(</span><span>'上面的时间是通过 new Date().toLocaleString() 计算出来的'</span><span>)</span><span>;</span>\n    <span>}</span><span>,</span>\n<span>]</span>\n<span>invokeArrayFns</span><span>(</span>funcArr<span>,</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>.</span><span>toLocaleString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><ul>\n<li>TS 版</li>\n</ul>\n<div><pre><code><span>export</span> <span>const</span> <span>invokeArrayFns</span> <span>=</span> <span>(</span>fns<span>:</span> <span>Function</span><span>[</span><span>]</span><span>,</span> arg<span>?</span><span>:</span> <span>any</span><span>)</span> <span>=></span> <span>{</span>\n  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> fns<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n    fns<span>[</span>i<span>]</span><span>(</span>arg<span>)</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这里对函数 <code>invokeArrayFns</code> 的参数进行了类型约束， <code>fns: Function[]</code> 指定第一个参数为数组且元素都是 <code>Function</code> 类型。<code>arg?: any</code> 用 <code>?</code> 表示第二个参数为可选，且值类型为任意值。</p>\n<h3 id=\"def\"> def</h3>\n<p>def：定义对象属性</p>\n<ul>\n<li>JS 版</li>\n</ul>\n<div><pre><code><span>const</span> <span>def</span> <span>=</span> <span>(</span><span>obj<span>,</span> key<span>,</span> value</span><span>)</span> <span>=></span> <span>{</span>\n    Object<span>.</span><span>defineProperty</span><span>(</span>obj<span>,</span> key<span>,</span> <span>{</span>\n        configurable<span>:</span> <span>true</span><span>,</span>\n        enumerable<span>:</span> <span>false</span><span>,</span>\n        value\n    <span>}</span><span>)</span><span>;</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\" target=\"_blank\" rel=\"noopener noreferrer\"><code>Object.defineProperty(obj, prop, descriptor)</code></a> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。还有一个方法能用于定义多个属性：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties\" target=\"_blank\" rel=\"noopener noreferrer\"><code>Object.defineProperties(obj, props)</code></a> (ES5)。</p>\n<p>引申：<code>Object.defineProperty</code> 涉及到比较重要的知识点：</p>\n<p>在 ES3 中，除了一些内置属性（如：<code>Math.PI</code>），对象的所有的属性在任何时候都可以被修改、插入、删除。在 ES5 中，我们可以设置属性是否可以被改变或是被删除 —— 在这之前，它是内置属性的特权。ES5 中引入了属性描述符的概念，我们可以通过它对所定义的属性有更大的控制权。这些属性描述符（特性）包括：</p>\n<blockquote>\n<p><code>value</code> —— 当试图获取属性时所返回的值。<br>\n<code>writable</code> —— 该属性是否可写。<br>\n<code>enumerable</code> —— 该属性在 <code>for in</code> 循环中是否会被枚举。<br>\n<code>configurable</code>—— 该属性是否可被删除。<br>\n<code>set()</code> —— 该属性的更新操作所调用的函数。<br>\n<code>get()</code> —— 获取属性值时所调用的函数。</p>\n</blockquote>\n<p>另外，<strong>数据描述符</strong>（其中属性为：<code>enumerable</code>，<code>configurable</code>，<code>value</code>，<code>writable</code>）与<strong>存取描述符</strong>（其中属性为 <code>enumerable</code>，<code>configurable</code>，<code>set()</code>，<code>get()</code>）之间是有互斥关系的。在定义了 <code>set()</code> 和 <code>get()</code> 之后，描述符会认为存取操作已被 定义了，其中再定义 <code>value</code> 和 <code>writable</code> 会引起错误。</p>\n<p>以下是 ES3 风格的属性定义方式：</p>\n<div><pre><code><span>var</span> person <span>=</span> <span>{</span><span>}</span><span>;</span>\nperson<span>.</span>legs <span>=</span> <span>2</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>以下是等价的 ES5 通过数据描述符定义属性的方式：</p>\n<div><pre><code><span>var</span> person <span>=</span> <span>{</span><span>}</span><span>;</span>\nObject<span>.</span><span>defineProperty</span><span>(</span>person<span>,</span> <span>'legs'</span><span>,</span> <span>{</span>\n    value<span>:</span> <span>2</span><span>,</span>\n    writable<span>:</span> <span>true</span><span>,</span>\n    configurable<span>:</span> <span>true</span><span>,</span>\n    enumerable<span>:</span> <span>true</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>其中， 除了 value 的默认值为 <code>undefined</code> 以外，其他的默认值都为 <code>false</code>。这就意味着，如果想要通过这一方式定义一个可写的属性，必须显示将它们设为 <code>true</code>。或者，我们也可以通过 ES5 的存储描述符来定义：</p>\n<div><pre><code><span>var</span> person <span>=</span> <span>{</span><span>}</span><span>;</span>\nObject<span>.</span><span>defineProperty</span><span>(</span>person<span>,</span> <span>'legs'</span><span>,</span> <span>{</span>\n    <span>set</span><span>:</span><span>function</span><span>(</span><span>v</span><span>)</span> <span>{</span>\n        <span>return</span> <span>this</span><span>.</span>value <span>=</span> v<span>;</span>\n    <span>}</span><span>,</span>\n    <span>get</span><span>:</span> <span>function</span><span>(</span><span>v</span><span>)</span> <span>{</span>\n        <span>return</span> <span>this</span><span>.</span>value<span>;</span>\n    <span>}</span><span>,</span>\n    configurable<span>:</span> <span>true</span><span>,</span>\n    enumerable<span>:</span> <span>true</span>\n<span>}</span><span>)</span><span>;</span>\nperson<span>.</span>legs <span>=</span> <span>2</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>这样一来，多了许多可以用来描述属性的代码，如果想要防止别人篡改我们的属性，就必须要用到它们。此外，也不要忘了浏览器向后兼容 ES3 方面所做的考虑。例如，跟添加 <code>Array.prototype</code> 属性不一样，我们不能再旧版的浏览器中使用 <code>shim</code> 这一特性。 另外，我们还可以（通过定义 <code>nonmalleable</code> 属性），在具体行为中运用这些描述符：</p>\n<div><pre><code><span>var</span> person <span>=</span> <span>{</span><span>}</span><span>;</span>\nObject<span>.</span><span>defineProperty</span><span>(</span>person<span>,</span> <span>'heads'</span><span>,</span> <span>{</span>value<span>:</span> <span>1</span><span>}</span><span>)</span><span>;</span>\nperson<span>.</span>heads <span>=</span> <span>0</span><span>;</span>    <span>// 0</span>\nperson<span>.</span>heads<span>;</span>        <span>// 1  (改不了)</span>\n<span>delete</span> person<span>.</span>heads<span>;</span> <span>// false</span>\nperson<span>.</span>heads         <span>// 1 (删不掉)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>\n<li>TS 版</li>\n</ul>\n<div><pre><code><span>export</span> <span>const</span> <span>def</span> <span>=</span> <span>(</span>obj<span>:</span> object<span>,</span> key<span>:</span> <span>string</span> <span>|</span> <span>symbol</span><span>,</span> value<span>:</span> <span>any</span><span>)</span> <span>=></span> <span>{</span>\n  Object<span>.</span><span>defineProperty</span><span>(</span>obj<span>,</span> key<span>,</span> <span>{</span>\n    configurable<span>:</span> <span>true</span><span>,</span>\n    enumerable<span>:</span> <span>false</span><span>,</span>\n    value\n  <span>}</span><span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"tonumber\"> toNumber</h3>\n<p>toNumber：转数字</p>\n<ul>\n<li>JS 版</li>\n</ul>\n<div><pre><code><span>const</span> <span>toNumber</span> <span>=</span> <span>(</span><span>val</span><span>)</span> <span>=></span> <span>{</span>\n    <span>const</span> n <span>=</span> <span>parseFloat</span><span>(</span>val<span>)</span><span>;</span>\n    <span>return</span> <span>isNaN</span><span>(</span>n<span>)</span> <span>?</span> val <span>:</span> n<span>;</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>JavaScript 中将字符串转为数字的方法有三种：</p>\n<p><code>Number()</code>（ES6）：将字符串转换为数字（空字符串转换为 <code>0</code>，其他的字符串会转换为 <code>NaN</code>）。\n<code>parseFloat()</code>：解析一个字符串，并返回一个浮点数（空字符串转换为 <code>NaN</code>，其他的字符串会返回非数字或无效数字字符之前的值）。\n<code>parseInt()</code>：解析一个字符串，并返回一个整数（空字符串转换为 <code>NaN</code>，其他的字符串会返回非数字或无效数字字符之前的值）。</p>\n<p><code>isNaN</code> 本意是判断是不是 <code>NaN</code> 值，但是不准确。比如：<code>isNaN('a')</code> 为 <code>true</code>。所以 ES6 有了 <code>Number.isNaN</code> 这个判断方法，为了弥补这一个 API。</p>\n<div><pre><code><span>isNaN</span><span>(</span><span>NaN</span><span>)</span><span>;</span>        <span>// true</span>\nNumber<span>.</span><span>isNaN</span><span>(</span><span>NaN</span><span>)</span><span>;</span> <span>// true</span>\n\n<span>isNaN</span><span>(</span><span>'a'</span><span>)</span><span>;</span>        <span>// true</span>\nNumber<span>.</span><span>isNaN</span><span>(</span><span>'a'</span><span>)</span><span>;</span> <span>// false</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>\n<li>TS 版</li>\n</ul>\n<div><pre><code><span>export</span> <span>const</span> toNumber <span>=</span> <span>(</span>val<span>:</span> <span>any</span><span>)</span><span>:</span> <span>any</span> <span>=></span> <span>{</span>\n  <span>const</span> n <span>=</span> <span>parseFloat</span><span>(</span>val<span>)</span>\n  <span>return</span> <span>isNaN</span><span>(</span>n<span>)</span> <span>?</span> val <span>:</span> n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"getglobalthis\"> getGlobalThis</h3>\n<p>getGlobalThis：获取全局对象</p>\n<ul>\n<li>JS 版</li>\n</ul>\n<div><pre><code><span>let</span> _globalThis<span>;</span>\n<span>const</span> <span>getGlobalThis</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n    <span>return</span> <span>(</span>_globalThis <span>||</span>\n        <span>(</span>_globalThis <span>=</span>\n            <span>typeof</span> globalThis <span>!==</span> <span>'undefined'</span>\n                <span>?</span> globalThis\n                <span>:</span> <span>typeof</span> self <span>!==</span> <span>'undefined'</span>\n                    <span>?</span> self\n                    <span>:</span> <span>typeof</span> window <span>!==</span> <span>'undefined'</span>\n                        <span>?</span> window\n                        <span>:</span> <span>typeof</span> global <span>!==</span> <span>'undefined'</span>\n                            <span>?</span> global\n                            <span>:</span> <span>{</span><span>}</span><span>)</span><span>)</span><span>;</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>这个方法用于获取全局 <code>this</code> 指向。</p>\n<p><strong>首次执行</strong>时 <code>_globalThis</code> 是 <code>undefined</code>。所以会执行后面的赋值语句。</p>\n<p>如果存在 <code>globalThis</code> 就用 <code>globalThis</code>。<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/globalThis\" target=\"_blank\" rel=\"noopener noreferrer\">MDN - globalThis</a></p>\n<p>如果存在 <code>self</code>，就用 <code>self</code>。在 <code>Web Worker</code> 中不能访问到 <code>window</code> 对象，但是我们却能通过 <code>self</code> 访问到 <code>Worker</code> 环境中的全局对象。</p>\n<p>如果存在 <code>window</code>，就用 <code>window</code>。</p>\n<p>如果存在 <code>global</code>，就用 <code>global</code>。Node环境下，使用 <code>global</code>。</p>\n<p>如果都不存在，使用空对象。可能是微信小程序环境下。</p>\n<p><strong>下次执行</strong>就直接返回 <code>_globalThis</code>，不需要第二次继续判断了。这种设计思路值得我们借鉴。</p>\n<ul>\n<li>TS 版</li>\n</ul>\n<div><pre><code><span>let</span> _globalThis<span>:</span> <span>any</span>\n<span>export</span> <span>const</span> getGlobalThis <span>=</span> <span>(</span><span>)</span><span>:</span> <span>any</span> <span>=></span> <span>{</span>\n  <span>return</span> <span>(</span>\n    _globalThis <span>||</span>\n    <span>(</span>_globalThis <span>=</span>\n      <span>typeof</span> globalThis <span>!==</span> <span>'undefined'</span>\n        <span>?</span> globalThis\n        <span>:</span> <span>typeof</span> self <span>!==</span> <span>'undefined'</span>\n        <span>?</span> self\n        <span>:</span> <span>typeof</span> window <span>!==</span> <span>'undefined'</span>\n        <span>?</span> window\n        <span>:</span> <span>typeof</span> global <span>!==</span> <span>'undefined'</span>\n        <span>?</span> global\n        <span>:</span> <span>{</span><span>}</span><span>)</span>\n  <span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id=\"总结\"> 总结</h2>\n<p>以上这些是 Vue3 源码中的基础工具函数，但实际上跟 Vue3 框架本身的耦合性不是很强（除了个别函数比如 <code>isReservedProp</code> 是专门设计给框架内部用的），相对独立，能够很方便的上手阅读和调试。</p>\n<p>通过阅读这部分工具函数产生了不少价值：</p>\n<ul>\n<li>对 JavaScript 原生基础知识进行查漏补缺，特别像 Object 对象的那些 API 等等。</li>\n<li>刚学习完 TypeScript，在正式使用前先阅读高手代码里的 TS 写法，既能检验学习效果，也能为之后 TS 的运用提高熟练度。</li>\n<li>部分函数中用到了正则表达式的知识点，这块内容很大，如果需要专门学习就需要通读 《<a href=\"https://github.com/qdlaoyao/js-regex-mini-book\" target=\"_blank\" rel=\"noopener noreferrer\">JS 正则迷你书</a>》了，平时用正则表达式的使用需求查阅即可。</li>\n<li>汲取了一些优秀的设计思路，例如 <code>cacheStringFunction</code>、<code>invokeArrayFns</code>、<code>getGlobalThis</code> 等函数。</li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-11-19T03:27:03.000Z",
      "date_modified": "2021-11-19T03:27:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "解决方案",
      "url": "https://www.fedbook.cn/project/solutions/",
      "id": "https://www.fedbook.cn/project/solutions/",
      "content_html": "<h1 id=\"解决方案\"> 解决方案</h1>\n<p>归纳总结项目优化、痛点，以及常见问题解决方案。</p>\n<div style=\"text-align: right\">\n  <svg t=\"1642755192825\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"15888\" width=\"64\" height=\"64\"><path d=\"M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z\" fill=\"#FFA92F\" p-id=\"15889\"></path><path d=\"M840.704 367.662545l-283.089455 288.581819-77.684363 77.777454-231.284364-234.961454 77.684364-77.684364 153.6 157.277091 283.042909-288.674909z\" fill=\"#FFFFFF\" p-id=\"15890\"></path></svg>\n</div>\n",
      "date_published": "2022-02-24T13:43:21.000Z",
      "date_modified": "2022-02-24T13:43:21.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "大文件分片上传和断点续传",
      "url": "https://www.fedbook.cn/project/solutions/file-upload/",
      "id": "https://www.fedbook.cn/project/solutions/file-upload/",
      "content_html": "<h1 id=\"大文件分片上传和断点续传\"> 大文件分片上传和断点续传</h1>\n<h2 id=\"场景描述\"> 场景描述</h2>\n<p>文件上传是一个很常见的需求，在文件相对比较小的情况下，可以直接把文件转化为字节流上传到服务器，但在文件比较大的情况下，用普通的方式进行上传就不是一个好的办法了。毕竟很少有人能忍受，当文件上传到一半中断后，继续上传却只能重头开始上传，这种体验很不友好。</p>\n<p>本文将从零搭建前端和服务端，实现一个大文件分片上传和断点续传的小案例。</p>\n<ul>\n<li>前端：Vue.js、Element-Ui、Axios</li>\n<li>后端：Node.js</li>\n<li>实例代码仓库：<a href=\"https://github.com/wenyuan/file-upload\" target=\"_blank\" rel=\"noopener noreferrer\">file-upload</a></li>\n</ul>\n<h2 id=\"整体思路\"> 整体思路</h2>\n<h3 id=\"前端\"> 前端</h3>\n<h4 id=\"大文件上传\"> 大文件上传</h4>\n<ul>\n<li>将大文件转换成二进制流的格式</li>\n<li>利用流可以切割的属性，将二进制流切割成多份</li>\n<li>借助 http 的可并发性，同时上传多个切片（比起传一个大文件可以减少上传时间）</li>\n<li>等监听到所有请求都成功发出去以后，再给服务端发出一个合并的信号</li>\n</ul>\n<h4 id=\"断点续传\"> 断点续传</h4>\n<ul>\n<li>为每一个文件切割块添加不同的标识</li>\n<li>当上传成功的之后，记录上传成功的标识</li>\n<li>当我们暂停或者发送失败后，可以重新发送没有上传成功的切割文件</li>\n</ul>\n<h3 id=\"后端\"> 后端</h3>\n<ul>\n<li>接收每一个切割文件，并在接收成功后，存到指定位置，并告诉前端接收成功</li>\n<li>收到合并信号，将所有的切割文件排序、合并，生成最终的大文件，然后删除切割小文件，并告知前端大文件的地址</li>\n</ul>\n<h2 id=\"前端代码\"> 前端代码</h2>\n<p>前端使用 Vue + ElementUI，代码比较清晰，虽然原生也可以，但要多写很多代码。</p>\n<h3 id=\"上传控件\"> 上传控件</h3>\n<p>首先创建上传控件和进度条控件，因为要自定义一个上传的实现，所以 <code>el-upload</code> 组件的 <code>auto-upload</code> 要设定为 <code>false</code>；<code>action</code> 为必选参数，此处可以不填值。</p>\n<div><p>提示</p>\n<p>ElementUI 的上传组件，默认是基于文件流的：</p>\n<ul>\n<li>数据格式：form-data</li>\n<li>传递的数据： file 文件流信息；filename 文件名字</li>\n</ul>\n</div>\n<p>代码如下：</p>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>\"</span>app<span>\"</span></span><span>></span></span>\n    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>file-upload<span>\"</span></span><span>></span></span>\n      <span>&lt;!-- 上传组件 --></span>\n      <span><span><span>&lt;</span>el-upload</span> <span>action</span><span><span>=</span><span>\"</span>#<span>\"</span></span> <span>:auto-upload</span><span><span>=</span><span>\"</span>false<span>\"</span></span> <span>:show-file-list</span><span><span>=</span><span>\"</span>false<span>\"</span></span> <span>:on-change</span><span><span>=</span><span>\"</span>handleChange<span>\"</span></span><span>></span></span>\n        <span><span><span>&lt;</span>el-button</span> <span>slot</span><span><span>=</span><span>\"</span>trigger<span>\"</span></span> <span>size</span><span><span>=</span><span>\"</span>small<span>\"</span></span> <span>type</span><span><span>=</span><span>\"</span>primary<span>\"</span></span><span>></span></span>选取文件<span><span><span>&lt;/</span>el-button</span><span>></span></span>\n        <span><span><span>&lt;</span>el-button</span> <span><span>style</span><span><span>=</span><span>\"</span><span><span>margin-left</span><span>:</span> 10px<span>;</span></span><span>\"</span></span></span> <span>size</span><span><span>=</span><span>\"</span>small<span>\"</span></span> <span>type</span><span><span>=</span><span>\"</span>success<span>\"</span></span> <span>@click</span><span><span>=</span><span>\"</span>handleUpload<span>\"</span></span><span>></span></span>上传到服务器<span><span><span>&lt;/</span>el-button</span><span>></span></span>\n        <span><span><span>&lt;</span>div</span> <span>slot</span><span><span>=</span><span>\"</span>tip<span>\"</span></span> <span>class</span><span><span>=</span><span>\"</span>el-upload__tip<span>\"</span></span> <span>v-if</span><span><span>=</span><span>\"</span>file<span>\"</span></span><span>></span></span>待上传文件：{{ file.name }}<span><span><span>&lt;/</span>div</span><span>></span></span>\n      <span><span><span>&lt;/</span>el-upload</span><span>></span></span>\n      <span>&lt;!-- 进度显示 --></span>\n      <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>progress-box<span>\"</span></span><span>></span></span>\n        <span><span><span>&lt;</span>span</span><span>></span></span>上传进度：{{ percent.toFixed() }}%<span><span><span>&lt;/</span>span</span><span>></span></span>\n        <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>\"</span>primary<span>\"</span></span> <span>size</span><span><span>=</span><span>\"</span>mini<span>\"</span></span> <span>@click</span><span><span>=</span><span>\"</span>handleClickBtn<span>\"</span></span><span>></span></span>{{ upload | btnTextFilter}}<span><span><span>&lt;/</span>el-button</span><span>></span></span>\n      <span><span><span>&lt;/</span>div</span><span>></span></span>\n    <span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>export</span> <span>default</span> <span>{</span>\n  name<span>:</span> <span>'App'</span><span>,</span>\n  filters<span>:</span> <span>{</span>\n    <span>btnTextFilter</span><span>(</span><span>val</span><span>)</span> <span>{</span>\n      <span>return</span> val <span>?</span> <span>'暂停'</span> <span>:</span> <span>'继续'</span>\n    <span>}</span>\n  <span>}</span><span>,</span>\n  <span>data</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>{</span>\n      file<span>:</span> <span>null</span><span>,</span>\n      chunkList<span>:</span> <span>[</span><span>]</span><span>,</span>\n      hash<span>:</span> <span>''</span><span>,</span>\n      percentCount<span>:</span> <span>0</span><span>,</span>\n      percent<span>:</span> <span>0</span><span>,</span>\n      upload<span>:</span> <span>true</span>\n    <span>}</span>\n  <span>}</span><span>,</span>\n  methods<span>:</span> <span>{</span>\n    <span>// 提交文件后触发</span>\n    <span>handleChange</span><span>(</span><span>file</span><span>)</span> <span>{</span>\n      Object<span>.</span><span>assign</span><span>(</span><span>this</span><span>.</span>$data<span>,</span> <span>this</span><span>.</span>$options<span>.</span><span>data</span><span>(</span><span>)</span><span>)</span> <span>// 将 data 重置为初始状态</span>\n      <span>this</span><span>.</span>file <span>=</span> file\n    <span>}</span><span>,</span>\n    <span>// 点击上传按钮后触发</span>\n    <span>async</span> <span>handleUpload</span><span>(</span><span>)</span> <span>{</span>\n    <span>}</span><span>,</span>\n    <span>// 将 File 对象转为 ArrayBuffer</span>\n    <span>fileToBuffer</span><span>(</span><span>)</span> <span>{</span>\n    <span>}</span><span>,</span>\n    <span>// 生成文件切片</span>\n    <span>createChunks</span><span>(</span><span>)</span> <span>{</span>\n    <span>}</span><span>,</span>\n    <span>// 上传文件切片</span>\n    <span>uploadChunks</span><span>(</span><span>)</span> <span>{</span>\n    <span>}</span><span>,</span>\n    <span>// 发送合并指令</span>\n    <span>mergeUpload</span><span>(</span><span>)</span> <span>{</span>\n    <span>}</span><span>,</span>\n    <span>// 按下暂停按钮</span>\n    <span>handleClickBtn</span><span>(</span><span>)</span> <span>{</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n\n<span><span><span>&lt;</span>style</span><span>></span></span><span><span>\n<span>.file-upload</span> <span>{</span>\n  <span>margin-top</span><span>:</span> 50px<span>;</span>\n  <span>margin-left</span><span>:</span> 50px<span>;</span>\n<span>}</span>\n\n<span>.progress-box</span> <span>{</span>\n  <span>box-sizing</span><span>:</span> border-box<span>;</span>\n  <span>width</span><span>:</span> 360px<span>;</span>\n  <span>display</span><span>:</span> flex<span>;</span>\n  <span>justify-content</span><span>:</span> space-between<span>;</span>\n  <span>align-items</span><span>:</span> center<span>;</span>\n  <span>margin-top</span><span>:</span> 10px<span>;</span>\n  <span>padding</span><span>:</span> 8px 10px<span>;</span>\n  <span>background-color</span><span>:</span> #ecf5ff<span>;</span>\n  <span>font-size</span><span>:</span> 14px<span>;</span>\n  <span>border-radius</span><span>:</span> 4px<span>;</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br></div></div><h3 id=\"转二进制\"> 转二进制</h3>\n<p>转成 ArrayBuffer 是因为后面要用 SparkMD5 这个库生成 hash 值，对文件进行命名。</p>\n<p>JS 常见的二进制格式有 Blob，ArrayBuffer 和 Buffer，如果对二进制流不了解，可以查看<a href=\"https://www.cnblogs.com/penghuwan/p/12053775.html\" target=\"_blank\" rel=\"noopener noreferrer\">这篇文章</a>。</p>\n<p>这里采用 ArrayBuffer，并且因为解析过程可能会比较久，所以我们采用 promise 异步处理的方式。</p>\n<p>代码如下：</p>\n<div><pre><code><span>// 在 ElementUI 中, 自带方法中的 file 并不是 File 对象</span>\n<span>// 要获取 File 对象需要通过 file.raw, 以下所有的 fileObj = file.raw</span>\n<span>fileToBuffer</span><span>(</span><span>fileObj</span><span>)</span> <span>{</span>\n  <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>\n    <span>const</span> fileReader <span>=</span> <span>new</span> <span>FileReader</span><span>(</span><span>)</span>\n    fileReader<span>.</span><span>onload</span> <span>=</span> <span>event</span> <span>=></span> <span>{</span>\n      <span>resolve</span><span>(</span>event<span>.</span>target<span>.</span>result<span>)</span>\n    <span>}</span>\n    fileReader<span>.</span><span>readAsArrayBuffer</span><span>(</span>fileObj<span>)</span>\n    fileReader<span>.</span><span>onerror</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n      <span>reject</span><span>(</span><span>new</span> <span>Error</span><span>(</span><span>'转换文件格式发生错误'</span><span>)</span><span>)</span>\n    <span>}</span>\n  <span>}</span><span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id=\"创建切片\"> 创建切片</h3>\n<p>接下来将大文件按固定大小（10M）进行切片，就像操作数组一样（注意此处同时声明了多个常量）。</p>\n<p>我们在拆分切片大文件的时候，还要考虑大文件的合并，所以我们的拆分必须有规律，比如 <code>1_1</code>，<code>1_2</code>，<code>1_3</code>，<code>1_5</code> 这样的，到时候服务端拿到切片数据，当接收到合并信号的时候，就可以将这些切片排序合并了。</p>\n<p>同时，为了避免同一个文件（改名字）多次上传，我们引入了 spark-md5，它能根据具体文件内容，生成 hash 值。</p>\n<p>这么一来，为每一个切片命名的时候，也就成了 <code>hash_1</code>，<code>hash_2</code> 这种形式。</p>\n<blockquote>\n<p>切割文件用到的是 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/slice\" target=\"_blank\" rel=\"noopener noreferrer\"><code>Blob.slice()</code></a>。</p>\n</blockquote>\n<p>代码如下：</p>\n<div><pre><code><span>const</span> <span>SIZE</span> <span>=</span> <span>10</span> <span>*</span> <span>1024</span> <span>*</span> <span>1024</span> <span>// 切片大小</span>\n\n<span>createChunks</span><span>(</span><span>buffer<span>,</span> fileObj<span>,</span> chunkSize <span>=</span> <span>SIZE</span></span><span>)</span> <span>{</span>\n  <span>// 声明几个变量, 后面切分文件要用</span>\n  <span>const</span> chunkList <span>=</span> <span>[</span><span>]</span> <span>// 保存所有切片的数组</span>\n  <span>const</span> chunkListLength <span>=</span> Math<span>.</span><span>ceil</span><span>(</span>fileObj<span>.</span>size <span>/</span> chunkSize<span>)</span> <span>// 计算总共多个切片</span>\n  <span>const</span> suffix <span>=</span> <span><span>/</span><span>\\.([0-9A-z]+)$</span><span>/</span></span><span>.</span><span>exec</span><span>(</span>fileObj<span>.</span>name<span>)</span><span>[</span><span>1</span><span>]</span> <span>// 文件后缀名(文件格式)</span>\n\n  <span>// 根据文件内容生成 hash 值</span>\n  <span>const</span> spark <span>=</span> <span>new</span> <span>SparkMD5<span>.</span>ArrayBuffer</span><span>(</span><span>)</span>\n  spark<span>.</span><span>append</span><span>(</span>buffer<span>)</span>\n  <span>const</span> hash <span>=</span> spark<span>.</span><span>end</span><span>(</span><span>)</span>\n  \n  <span>// 生成切片, 这里后端要求传递的参数为字节数据块(chunk)和每个数据块的文件名(fileName)</span>\n  <span>let</span> cur <span>=</span> <span>0</span> <span>// 切片时的初始位置</span>\n  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> chunkListLength<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n    <span>const</span> item <span>=</span> <span>{</span>\n      chunk<span>:</span> fileObj<span>.</span><span>slice</span><span>(</span>cur<span>,</span> cur <span>+</span> chunkSize<span>)</span><span>,</span>\n      fileName<span>:</span> <span><span>`</span><span><span>${</span>hash<span>}</span></span><span>_</span><span><span>${</span>i<span>}</span></span><span>.</span><span><span>${</span>suffix<span>}</span></span><span>`</span></span> <span>// 文件名规则按照 hash_1.jpg 命名</span>\n    <span>}</span>\n    cur <span>+=</span> chunkSize\n    chunkList<span>.</span><span>push</span><span>(</span>item<span>)</span>\n  <span>}</span>\n  console<span>.</span><span>log</span><span>(</span><span>'切片完后的数组：'</span><span>,</span> chunkList<span>)</span>\n  <span>this</span><span>.</span>chunkList <span>=</span> chunkList <span>// uploadChunks 要用到</span>\n  <span>this</span><span>.</span>hash <span>=</span> hash           <span>// uploadChunks 要用到</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><div><p>提示</p>\n<p>分割大文件的时候，一般可以采用「定切片数量」和「定切片大小」两种方式。</p>\n<p>为了避免由于 JS 使用的 IEEE754 二进制浮点数算术标准可能导致的误差，这里采用定切片大小的方式，规定每个切片 10MB，也就是说 100 MB 的文件会被分成 10 个切片。</p>\n</div>\n<h3 id=\"发送请求\"> 发送请求</h3>\n<p>上传切片的请求可以是并行的或是串行的，这里选择串行发送。每个切片都新建一个请求，为了后面能实现断点续传，将请求封装到函数 <code>fn</code> 里，用一个数组 <code>requestList</code> 来保存请求集合，然后封装一个 <code>send</code> 函数，用于请求发送，这样一旦按下暂停键，可以方便的终止上传。</p>\n<p>切片发送完成后，何时合并它们呢，一般有两种思路：</p>\n<ul>\n<li>前端在每个切片中都携带切片最大数量的信息，当服务端接受到这个数量的切片时自动合并</li>\n<li>前端额外发一个请求，主动通知服务端进行合并，服务端接受到这个请求时主动合并切片</li>\n</ul>\n<p>这里采用第二种方式，即前端主动通知服务端进行合并。为此需要再发送一个 get 请求并把文件的 hash 值传给服务器，我们定义一个 <code>complete</code> 方法来实现。</p>\n<p>代码如下：</p>\n<div><pre><code><span>const</span> BaseUrl <span>=</span> <span>'http://localhost:5000'</span>\n\n<span>uploadChunks</span><span>(</span><span>)</span> <span>{</span>\n  <span>const</span> requestList <span>=</span> <span>[</span><span>]</span> <span>// 请求集合</span>\n  <span>this</span><span>.</span>chunkList<span>.</span><span>forEach</span><span>(</span><span>(</span><span>item<span>,</span> index</span><span>)</span> <span>=></span> <span>{</span>\n    <span>const</span> <span>fn</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n      <span>const</span> formData <span>=</span> <span>new</span> <span>FormData</span><span>(</span><span>)</span>\n      formData<span>.</span><span>append</span><span>(</span><span>'hash'</span><span>,</span> <span>this</span><span>.</span>hash<span>)</span>\n      formData<span>.</span><span>append</span><span>(</span><span>'chunk'</span><span>,</span> item<span>.</span>chunk<span>)</span>\n      formData<span>.</span><span>append</span><span>(</span><span>'filename'</span><span>,</span> item<span>.</span>fileName<span>)</span>\n      <span>return</span> <span>axios</span><span>(</span><span>{</span>\n        url<span>:</span> BaseUrl <span>+</span> <span>'/api/upload/'</span><span>,</span>\n        method<span>:</span> <span>'post'</span><span>,</span>\n        headers<span>:</span> <span>{</span> <span>'Content-Type'</span><span>:</span> <span>'multipart/form-data'</span> <span>}</span><span>,</span>\n        data<span>:</span> formData\n      <span>}</span><span>)</span><span>.</span><span>then</span><span>(</span><span>res</span> <span>=></span> <span>{</span>\n        <span>if</span> <span>(</span>res<span>.</span>data<span>.</span>code <span>===</span> <span>0</span><span>)</span> <span>{</span> <span>// 成功</span>\n          <span>if</span> <span>(</span><span>this</span><span>.</span>percentCount <span>===</span> <span>0</span><span>)</span> <span>{</span> <span>// 避免上传成功后会删除切片改变 chunkList 的长度影响到 percentCount 的值</span>\n            <span>this</span><span>.</span>percentCount <span>=</span> <span>100</span> <span>/</span> <span>this</span><span>.</span>chunkList<span>.</span>length\n          <span>}</span>\n          <span>this</span><span>.</span>percent <span>+=</span> <span>this</span><span>.</span>percentCount <span>// 改变进度</span>\n          <span>this</span><span>.</span>chunkList<span>.</span><span>splice</span><span>(</span>index<span>,</span> <span>1</span><span>)</span>   <span>// 一旦上传成功就删除这一个 chunk, 方便断点续传</span>\n        <span>}</span>\n      <span>}</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>error</span> <span>=></span> <span>{</span>\n        console<span>.</span><span>log</span><span>(</span><span>'上传失败：'</span><span>,</span> error<span>)</span>\n        <span>this</span><span>.</span>$message<span>.</span><span>error</span><span>(</span><span>'上传失败，请检查服务端是否正常'</span><span>)</span>\n      <span>}</span><span>)</span>\n    <span>}</span>\n    requestList<span>.</span><span>push</span><span>(</span>fn<span>)</span>\n  <span>}</span><span>)</span>\n\n  <span>let</span> i <span>=</span> <span>0</span> <span>// 记录发送的请求个数</span>\n  <span>// 文件切片全部发送完毕后, 需要请求 merge 接口, 把文件的 hash 传递给服务器</span>\n  <span>const</span> <span>complete</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n    <span>axios</span><span>(</span><span>{</span>\n      url<span>:</span> BaseUrl <span>+</span> <span>'/api/merge/'</span><span>,</span>\n      method<span>:</span> <span>'post'</span><span>,</span>\n      data<span>:</span> <span>{</span> hash<span>:</span> <span>this</span><span>.</span>hash<span>,</span> filename<span>:</span> <span>this</span><span>.</span>file<span>.</span>name<span>,</span> size<span>:</span> <span>this</span><span>.</span>chunkList<span>.</span>length<span>}</span>\n    <span>}</span><span>)</span><span>.</span><span>then</span><span>(</span><span>res</span> <span>=></span> <span>{</span>\n      <span>if</span> <span>(</span>res<span>.</span>data<span>.</span>code <span>===</span> <span>0</span><span>)</span> <span>{</span> <span>// 请求发送成功</span>\n        <span>this</span><span>.</span><span>$message</span><span>(</span><span>{</span>\n          message<span>:</span> res<span>.</span>data<span>.</span>message<span>,</span>\n          type<span>:</span> <span>'success'</span>\n        <span>}</span><span>)</span>\n      <span>}</span> <span>else</span> <span>{</span>\n        <span>this</span><span>.</span><span>$message</span><span>(</span><span>{</span>\n          message<span>:</span> res<span>.</span>data<span>.</span>message<span>,</span>\n          type<span>:</span> <span>'error'</span>\n        <span>}</span><span>)</span>\n      <span>}</span>\n    <span>}</span><span>)</span>\n  <span>}</span>\n  <span>const</span> <span>send</span> <span>=</span> <span>async</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n    <span>if</span> <span>(</span>i <span>>=</span> requestList<span>.</span>length<span>)</span> <span>{</span>\n      <span>// 全部发送完毕</span>\n      <span>complete</span><span>(</span><span>)</span>\n      <span>return</span>\n    <span>}</span>\n    <span>await</span> requestList<span>[</span>i<span>]</span><span>(</span><span>)</span>\n    i<span>++</span>\n    <span>send</span><span>(</span><span>)</span>\n  <span>}</span>\n  <span>send</span><span>(</span><span>)</span> <span>// 发送请求</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br></div></div><div><p>提示</p>\n<p>这里需要注意的就是，我们发出去的数据采用的是 FormData 数据格式。（<a href=\"https://segmentfault.com/q/1010000025217412\" target=\"_blank\" rel=\"noopener noreferrer\">为什么</a>）</p>\n</div>\n<h3 id=\"断点续传-2\"> 断点续传</h3>\n<p>暂停按钮文字的处理，用了一个过滤器，如果 <code>upload</code> 值为 <code>true</code> 则显示「暂停」，否则显示「继续」：</p>\n<div><pre><code>filters<span>:</span> <span>{</span>\n  <span>btnTextFilter</span><span>(</span><span>val</span><span>)</span> <span>{</span>\n    <span>return</span> val <span>?</span> <span>'暂停'</span> <span>:</span> <span>'继续'</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>当按下暂停按钮，触发 <code>handleClickBtn()</code> 方法：</p>\n<div><pre><code><span>handleClickBtn</span><span>(</span><span>)</span> <span>{</span>\n  <span>this</span><span>.</span>upload <span>=</span> <span>!</span><span>this</span><span>.</span>upload\n  <span>// 如果不暂停则继续上传</span>\n  <span>if</span> <span>(</span><span>this</span><span>.</span>upload<span>)</span> <span>this</span><span>.</span><span>uploadChunks</span><span>(</span><span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>同时需要在 <code>send()</code> 方法里增加判断是否暂停的逻辑：只要 <code>upload</code> 这个变量为 <code>false</code> 就不会继续上传了。</p>\n<p>为了在暂停完后可以继续发送，需要在每次成功发送一个切片后将这个切片从 <code>chunkList</code> 数组里删除 <code>this.chunkList.splice(index, 1)</code>（所以前面在写上传接口的时候有了这么一行代码）。</p>\n<p>代码中增加一行如下：</p>\n<div><div><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br></div><pre><code><span>const</span> <span>send</span> <span>=</span> <span>async</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>if</span> <span>(</span><span>!</span><span>this</span><span>.</span>upload<span>)</span> <span>return</span>\n  <span>if</span> <span>(</span>i <span>>=</span> requestList<span>.</span>length<span>)</span> <span>{</span>\n    <span>// 全部发送完毕</span>\n    <span>complete</span><span>(</span><span>)</span>\n    <span>return</span>\n  <span>}</span>\n  <span>await</span> requestList<span>[</span>i<span>]</span><span>(</span><span>)</span>\n  i<span>++</span>\n  <span>send</span><span>(</span><span>)</span>\n<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id=\"后端代码\"> 后端代码</h2>\n<p>简单使用 http 模块搭建服务端，主要实现两个接口的处理逻辑：</p>\n<ul>\n<li>上传切片（<code>/api/upload/</code>）</li>\n<li>合并切片（<code>/api/merge/</code>）</li>\n</ul>\n<p>代码比较简单，主要是一些第三方和内置模块的使用，关键的地方加了一些注释，参见 <a href=\"https://github.com/wenyuan/file-upload/tree/main/backend\" target=\"_blank\" rel=\"noopener noreferrer\">file-upload/backend/</a>。</p>\n<h2 id=\"问题总结\"> 问题总结</h2>\n<p>当前的例子，基于前端大文件分片上传和断点续传的场景，总结了实现思路，并用代码进行了简单的实现。</p>\n<p>如果是在复杂的生产环境中，可能会有更多的问题需要考虑，下面是我能想到的一些以及思路：</p>\n<ul>\n<li>断网（或者电脑重启）后，再次选择文件，如何续传？</li>\n</ul>\n<blockquote>\n<p>思路：前端把已经上传的信息存在 Local Storage 里，或者向后端请求接口去获得，更偏向于让后端来存这个信息。</p>\n</blockquote>\n<ul>\n<li>基于上面的问题，如何判别新的上次文件，是新建上传还是续传文件？</li>\n</ul>\n<blockquote>\n<p>思路：根据 SparkMD5 生成的 hash 来判断（这个 hash 值是依据文件内容来的）。</p>\n</blockquote>\n<ul>\n<li>多人同时上传同一文件冲突、换电脑之后再次上传同一文件处理。</li>\n</ul>\n<blockquote>\n<p>思路：多人上传可以考虑用用户 token 来区分，或者从生成浏览器唯一 id 的思路出发，id 结合文件 hash 来标识这个文件。</p>\n</blockquote>\n<ul>\n<li>更大的文件（比如 100G）上传时，计算 MD5 切片时会遇到资源不够用的问题，浏览器会卡死。</li>\n</ul>\n<blockquote>\n<p>JS 单线程逻辑异步的效果不会很明显，整个过程（计算 Md5 - 获取切片 - 上传切片 - 文件合并）可以用 worker api，开多线程调用 CPU 另外的核去做，主线程只负责接收 Message，这样性能和体验应该会好很多。但因为 V8 对内存的限制，并没有完美的解决方案。</p>\n</blockquote>\n<ul>\n<li>多文件上传的优化思路</li>\n</ul>\n<blockquote>\n<p>大文件用 worker 切片保证线程不卡，但多个大文件内存肯定不够用，所以只能尽可能优化。</p>\n</blockquote>\n<h2 id=\"不错的项目\"> 不错的项目</h2>\n<p>实际业务中，可能对大文件上传有更细化的需求，并且需要兼容和考虑很多种情况，因此可以借鉴现成的轮子，经过调研，我发现了几个不错的项目：</p>\n<ul>\n<li><a href=\"https://github.com/simple-uploader/vue-uploader\" target=\"_blank\" rel=\"noopener noreferrer\">vue-simple-uploader</a></li>\n<li><a href=\"https://github.com/yangrds/file-chunk\" target=\"_blank\" rel=\"noopener noreferrer\">file-chunk</a></li>\n<li><a href=\"https://github.com/fex-team/webuploader\" target=\"_blank\" rel=\"noopener noreferrer\">webuploader</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-02-24T13:43:21.000Z",
      "date_modified": "2022-02-24T13:43:21.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "接口设计",
      "url": "https://www.fedbook.cn/style-guide/apis/",
      "id": "https://www.fedbook.cn/style-guide/apis/",
      "content_html": "<h1 id=\"接口设计\"> 接口设计</h1>\n<blockquote>\n<p>接口设计遵循 RESTful 规范，这是目前最流行的 API 设计规范。</p>\n</blockquote>\n<p>在 RESTful 风格中，URL 被视为「资源」，要求使用名词进行说明，一般标准如下：</p>\n<div><pre><code>http(s)://域名:端口[/版本]/资源1[/子资源2/.../子资源n][/路径变量]\n</code></pre>\n<div><span>1</span><br></div></div><p>其中版本号是可选项，用于版本控制，通常使用 v1 / v1.1 这样的格式进行表达。如果版本号没有写，则默认使用最新版本获取资源。</p>\n<p>下面列几个 RESTful 接口设计的注意点。</p>\n<h2 id=\"域名\"> 域名</h2>\n<p>应该尽量将 API 部署在专用域名之下。</p>\n<div><pre><code>https://api.example.com\n</code></pre>\n<div><span>1</span><br></div></div><p>如果确定 API 很简单，不会有进一步扩展，可以考虑放在主域名下。</p>\n<div><pre><code>https://example.org/api/\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"版本-versioning\"> 版本（Versioning）</h2>\n<p>应该将 API 的版本号放入 URL。</p>\n<div><pre><code>https://api.example.com/v1/\n</code></pre>\n<div><span>1</span><br></div></div><p>另一种做法是，将版本号放在 HTTP 头信息中，但不如放入 URL 方便和直观。<a href=\"https://developer.github.com/v3/media/#request-specific-version\" target=\"_blank\" rel=\"noopener noreferrer\">Github</a> 采用这种做法。</p>\n<h2 id=\"路径-endpoint\"> 路径（Endpoint）</h2>\n<p>路径又称「终点」（endpoint），表示 API 的具体网址。</p>\n<p>在 RESTful 架构中，每个网址代表一种资源（resource），所以网址中<strong>不能有动词，只能有名词</strong>，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的「集合」（collection），所以 API 中的名词也应该使用<strong>复数</strong>。</p>\n<p>举例来说，有一个 API 提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。</p>\n<div><pre><code>https://api.example.com/v1/zoos\nhttps://api.example.com/v1/animals\nhttps://api.example.com/v1/employees\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><blockquote>\n<p>URL 中的名词，应该使用复数，还是单数？</p>\n<p>这没有统一的规定，常见的操作是读取一个集合，比如 <code>GET /articles</code>（读取所有文章），这里明显应该是复数。</p>\n<p>为了统一起见，建议都使用复数 URL，比如 <code>GET /articles/2</code> 要好于 <code>GET /article/2</code>。</p>\n</blockquote>\n<h2 id=\"http-动词\"> HTTP 动词</h2>\n<p>对于资源的具体操作类型，由 HTTP 动词表示。</p>\n<p>常用的 HTTP 动词有下面五个（括号里是对应的 SQL 命令）。</p>\n<ul>\n<li>GET（SELECT）：从服务器取出资源（一项或多项）。</li>\n<li>POST（CREATE）：在服务器新建一个资源。</li>\n<li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li>\n<li>PATCH（UPDATE）：在服务器更新资源，通常是部分更新（客户端提供改变的属性）。</li>\n<li>DELETE（DELETE）：从服务器删除资源。</li>\n</ul>\n<p>还有两个不常用的 HTTP 动词。</p>\n<ul>\n<li>HEAD：获取资源的元数据。</li>\n<li>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</li>\n</ul>\n<p>下面是一些例子（根据 HTTP 规范，动词一律大写）：</p>\n<div><pre><code>GET /zoos                     列出所有动物园\nPOST /zoos                    新建一个动物园\nGET /zoos/ID                  获取某个指定动物园的信息\nPUT /zoos/ID                  更新某个指定动物园的信息（提供该动物园的全部信息）\nPATCH /zoos/ID                更新某个指定动物园的信息（提供该动物园的部分信息）\nDELETE /zoos/ID               删除某个动物园\nGET /zoos/ID/animals          列出某个指定动物园的所有动物\nDELETE /zoos/ID/animals/ID    删除某个指定动物园的指定动物\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"过滤信息-filtering\"> 过滤信息（Filtering）</h2>\n<p>如果记录数量很多，服务器不可能都将它们返回给用户。API 应该提供参数，过滤返回结果。</p>\n<p>下面是一些常见的参数：</p>\n<div><pre><code>?limit=10                     指定返回记录的数量\n?offset=10                    指定返回记录的开始位置\n?page=2&amp;per_page=100          指定第几页，以及每页的记录数\n?sortby=name&amp;order=asc        指定返回结果按照哪个属性排序，以及排序顺序\n?animal_type_id=1             指定筛选条件\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>参数的设计允许存在冗余，即允许 API 路径和 URL 参数偶尔有重复。比如，<code>GET /zoo/ID/animals</code> 与 <code>GET /animals?zoo_id=ID</code> 的含义是相同的。</p>\n<h2 id=\"状态码-status-codes\"> 状态码（Status Codes）</h2>\n<p>客户端的每一次请求，服务器都必须给出回应。回应包括 HTTP 状态码和数据两部分。</p>\n<p>HTTP 状态码就是一个三位数，分成五个类别。</p>\n<ul>\n<li>1xx：接受的请求正在处理 （信息性状态码）</li>\n<li>2xx：表示请求正常处理完毕 （成功状态码）</li>\n<li>3xx：表示重定向状态，需要重新请求 （重定向状态码）</li>\n<li>4xx：服务器无法处理请求 （客户端错误状态码）</li>\n<li>5xx：服务器处理请求出错 （服务端错误状态码）</li>\n</ul>\n<p>这五大类总共包含 <a href=\"https://en.wikipedia.org/wiki/List_of_HTTP_status_codes\" target=\"_blank\" rel=\"noopener noreferrer\">100 多种</a>状态码，覆盖了绝大部分可能遇到的情况。每一种状态码都有标准的（或者约定的）解释，客户端只需查看状态码，就可以判断出发生了什么情况，所以服务器应该返回尽可能精确的状态码。</p>\n<p>常用的状态码有以下一些（方括号中是该状态码对应的 HTTP 动词）：</p>\n<div><pre><code>200 OK                     - [GET]             服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。\n201 Created                - [POST/PUT/PATCH]  用户新建或修改数据成功。\n202 Accepted               - [*]               表示一个请求已经进入后台排队（异步任务）。\n204 No Content             - [DELETE]          用户删除数据成功。\n400 Bad Request            - [POST/PUT/PATCH]  服务器不理解客户端的请求，未做任何处理。\n401 Unauthorized           - [*]               用户未提供身份验证凭据，或者没有通过身份验证。\n403 Forbidden              - [*]               用户通过了身份验证，但是不具有访问资源所需的权限。\n404 Not Found              - [*]               所请求的资源不存在，或不可用。\n405 Method Not Allowed     - [*]               用户已经通过身份验证，但是所用的 HTTP 方法不在他的权限之内。\n406 Not Acceptable         - [GET]             请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体，即我要的你不给（比如用户请求 JSON 格式，但是只有 XML 格式）。\n410 Gone                   - [GET]             所请求的资源已从这个地址转移，不再可用。\n415 Unsupported Media Type - [POST/PUT/PATCH]  服务器拒绝服务，原因是请求格式不被支持，即我给的你不要（比如 API 只能返回 JSON 格式，但是客户端要求返回 XML 格式）。\n422 Unprocesable entity    - [POST/PUT/PATCH]  客户端上传的附件无法处理，导致请求失败。\n429 Too Many Requests      - [*]               客户端的请求次数超过限额。\n500 Internal Server Error  - [*]               客户端请求有效，服务器处理时发生了意外。\n503 Service Unavailable    - [*]               服务器无法处理请求，一般用于网站维护状态。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>注意事项：</p>\n<ul>\n<li>API 不需要 1xx 状态码。</li>\n<li>API 用不到 301 状态码（永久重定向）和 302 状态码（暂时重定向，307 也是这个含义），因为它们可以由应用级别返回，浏览器会直接跳转，API 级别可以不考虑这两种情况。</li>\n<li>API 用到的 3xx 状态码，主要是 303（See Other），表示参考另一个 URL。它与 302 和 307 的含义一样，也是「暂时重定向」，区别在于 302 和 307 用于 GET 请求，而 303 用于 POST、PUT 和 DELETE 请求。收到 303 以后，浏览器不会自动跳转，而会让用户自己决定下一步怎么办。</li>\n<li>一般来说，API 不会向用户透露服务器的详细信息，所以表示服务端错误的 5xx 状态码只要两个就够了：500 和 503。</li>\n</ul>\n<p>状态码的完全列表参见<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status\" target=\"_blank\" rel=\"noopener noreferrer\">这里</a>。</p>\n<h2 id=\"返回结果\"> 返回结果</h2>\n<blockquote>\n<p>API 返回的数据格式，不应该是纯文本，而应该是一个 JSON 对象，因为这样才能返回标准的结构化数据。</p>\n<p>所以，服务器回应的 HTTP 头的 <code>Content-Type</code> 属性要设为 <code>application/json</code>。</p>\n<p>客户端请求时，也要明确告诉服务器，可以接受 JSON 格式，即请求的 HTTP 头的 <code>ACCEPT</code> 属性也要设成 <code>application/json</code>。</p>\n</blockquote>\n<p>RESTful 响应的 JSON 结构应当全局保持相同的结构与语义，这里我给出行业最常见的数据格式范例。</p>\n<p>在<strong>标准化的响应结构</strong>中，要包含 code、message 两项，分别对应了服务器处理结果与返回的消息内容。除此以外，data 属性是可选项，包含从响应返回的额外数据，如查询结果、新增或更新后的数据。</p>\n<p>在<strong>语义层面</strong>，也要遵循相同的规则。例如，当服务器处理成功，code 固定等于 0；如果遇到异常情况，公司内部也要遵循统一的 code 命名标准。例如：code 以 1xxx 开头代表参数异常，2xxx 开头代表数据库处理异常。</p>\n<blockquote>\n<p>注意：这里的 code 与 HTTP 状态码（Status Codes）是两码事，请不要混淆。</p>\n</blockquote>\n<p>当然不同的公司有不同的命名规则，一定要提前定义好并要求开发团队严格按语义使用编码。</p>\n<div><pre><code>{\n    code:&quot;0&quot; ,\n    message : &quot;success&quot; ,\n    data : {\n        employee : {\n            name : &quot;张三&quot;,\n            salary : 3500 , \n            version : 2\n        }\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>（完）</p>\n",
      "date_published": "2021-08-21T15:55:13.000Z",
      "date_modified": "2021-08-29T05:51:49.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "前端登录方案总结",
      "url": "https://www.fedbook.cn/project/solutions/login/",
      "id": "https://www.fedbook.cn/project/solutions/login/",
      "content_html": "<h1 id=\"前端登录方案总结\"> 前端登录方案总结</h1>\n<h2 id=\"场景描述\"> 场景描述</h2>\n<p>登录是几乎每个网站都有的一个基本功能，本文介绍几种常用的登录方式和背后的原理：</p>\n<ul>\n<li>Cookie + Session 登录</li>\n<li>Token 登录</li>\n<li>SSO 单点登录</li>\n<li>OAuth 第三方登录</li>\n</ul>\n<h2 id=\"cookie-session-登录\"> Cookie + Session 登录</h2>\n<p>HTTP 是一种无状态的协议，客户端每次发送请求时，首先要和服务器端建立一个连接，在请求完成后又会断开这个连接。</p>\n<p>这种方式可以节省传输时占用的连接资源，但同时也存在一个问题：每次请求都是独立的，服务器端无法判断本次请求和上一次请求是否来自同一个用户，进而也就无法判断用户的登录状态。</p>\n<p>为了解决 HTTP 无状态的问题，就有了 Cookie。</p>\n<blockquote>\n<p>Cookie 是服务器端发送给客户端的一段特殊信息，这些信息以文本的方式存放在客户端，客户端每次向服务器端发送请求时都会带上这些特殊信息。</p>\n</blockquote>\n<p>有了 Cookie 之后，服务器端就能够获取到客户端传递过来的信息了，如果需要对信息进行验证，还需要通过 Session。</p>\n<blockquote>\n<p>客户端请求服务端，服务端会为这次请求开辟一块内存空间，这个便是 Session 对象。</p>\n</blockquote>\n<p>有了 Cookie 和 Session 之后，我们就可以进行登录认证了。</p>\n<h3 id=\"实现流程\"> 实现流程</h3>\n<p>Cookie + Session 的登录方式是最传统的一种登录方式，现在仍然有大量的企业在使用。</p>\n<p>用户首次登录时：</p>\n<div style=\"text-align: center;\">\n  <svg id=\"SvgjsSvg1006\" width=\"708\" height=\"239\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><defs id=\"SvgjsDefs1007\"><marker id=\"SvgjsMarker1028\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1029\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1044\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1045\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1060\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1061\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1076\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1077\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1090\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1091\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1094\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1095\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker></defs><g id=\"SvgjsG1008\" transform=\"translate(37,25)\"><path id=\"SvgjsPath1009\" d=\"M 0 10C 0 -3.3333333333333335 20 -3.3333333333333335 20 10C 20 23.333333333333332 0 23.333333333333332 0 10Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1010\"><text id=\"SvgjsText1011\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"0px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"-0.625\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1012\"><path id=\"SvgjsPath1013\" d=\"M25 61L47 61L47 61L69 61\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\"></path></g><g id=\"SvgjsG1014\"><path id=\"SvgjsPath1015\" d=\"M47 46L47 59.5L47 59.5L47 74\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\"></path></g><g id=\"SvgjsG1016\"><path id=\"SvgjsPath1017\" d=\"M46 73L29 91\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\"></path></g><g id=\"SvgjsG1018\"><path id=\"SvgjsPath1019\" d=\"M47 73L62 91\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\"></path></g><g id=\"SvgjsG1020\" transform=\"translate(151,33)\"><path id=\"SvgjsPath1021\" d=\"M 0 0L 108 0L 108 56L 0 56Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1022\"><text id=\"SvgjsText1023\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"88px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"17.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1024\" dy=\"16\" x=\"54\"><tspan id=\"SvgjsTspan1025\" style=\"text-decoration:;\">a.com/page-a</tspan></tspan></text></g></g><g id=\"SvgjsG1026\"><path id=\"SvgjsPath1027\" d=\"M73 61L147.39999999999998 61\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1028)\"></path><rect id=\"SvgjsRect1030\" width=\"26\" height=\"16\" x=\"97.19999999999999\" y=\"53\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1031\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"26px\" fill=\"#323232\" font-weight=\"400\" align=\"top\" lineHeight=\"16px\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"50.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1032\" dy=\"16\" x=\"110.19999999999999\"><tspan id=\"SvgjsTspan1033\" style=\"text-decoration:;\">访问</tspan></tspan></text></g><g id=\"SvgjsG1034\" transform=\"translate(365,33)\"><path id=\"SvgjsPath1035\" d=\"M 0 0L 108 0L 108 56L 0 56Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1036\"><text id=\"SvgjsText1037\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"88px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.875\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1038\" dy=\"16\" x=\"54\"><tspan id=\"SvgjsTspan1039\" style=\"text-decoration:;\">服务器</tspan></tspan><tspan id=\"SvgjsTspan1040\" dy=\"16\" x=\"54\"><tspan id=\"SvgjsTspan1041\" style=\"text-decoration:;\">验证账号密码</tspan></tspan></text></g></g><g id=\"SvgjsG1042\"><path id=\"SvgjsPath1043\" d=\"M260 61L361.4 61\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1044)\"></path><rect id=\"SvgjsRect1046\" width=\"52\" height=\"16\" x=\"284.7\" y=\"53\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1047\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"52px\" fill=\"#323232\" font-weight=\"400\" align=\"top\" lineHeight=\"16px\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"50.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1048\" dy=\"16\" x=\"310.7\"><tspan id=\"SvgjsTspan1049\" style=\"text-decoration:;\">输入密码</tspan></tspan></text></g><g id=\"SvgjsG1050\" transform=\"translate(575,33)\"><path id=\"SvgjsPath1051\" d=\"M 0 0L 108 0L 108 56L 0 56Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1052\"><text id=\"SvgjsText1053\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"88px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.875\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1054\" dy=\"16\" x=\"54\"><tspan id=\"SvgjsTspan1055\" style=\"text-decoration:;\">创建并保存</tspan></tspan><tspan id=\"SvgjsTspan1056\" dy=\"16\" x=\"54\"><tspan id=\"SvgjsTspan1057\" style=\"text-decoration:;\">SessionId</tspan></tspan></text></g></g><g id=\"SvgjsG1058\"><path id=\"SvgjsPath1059\" d=\"M474 61L571.4 61\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1060)\"></path><rect id=\"SvgjsRect1062\" width=\"52\" height=\"16\" x=\"496.70000000000005\" y=\"53\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1063\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"52px\" fill=\"#323232\" font-weight=\"400\" align=\"top\" lineHeight=\"16px\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"50.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1064\" dy=\"16\" x=\"522.7\"><tspan id=\"SvgjsTspan1065\" style=\"text-decoration:;\">验证成功</tspan></tspan></text></g><g id=\"SvgjsG1066\" transform=\"translate(365,158)\"><path id=\"SvgjsPath1067\" d=\"M 0 0L 108 0L 108 56L 0 56Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1068\"><text id=\"SvgjsText1069\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"88px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.875\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1070\" dy=\"16\" x=\"54\"><tspan id=\"SvgjsTspan1071\" style=\"text-decoration:;\">将 SessionId</tspan></tspan><tspan id=\"SvgjsTspan1072\" dy=\"16\" x=\"54\"><tspan id=\"SvgjsTspan1073\" style=\"text-decoration:;\">写入 Cookie</tspan></tspan></text></g></g><g id=\"SvgjsG1074\"><path id=\"SvgjsPath1075\" d=\"M629 90L629 186L476.6 186\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1076)\"></path><rect id=\"SvgjsRect1078\" width=\"68\" height=\"16\" x=\"540\" y=\"178\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1079\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"68px\" fill=\"#323232\" font-weight=\"400\" align=\"top\" lineHeight=\"16px\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"175.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1080\" dy=\"16\" x=\"574\"><tspan id=\"SvgjsTspan1081\" style=\"text-decoration:;\">Set-Cookie</tspan></tspan></text></g><g id=\"SvgjsG1082\" transform=\"translate(151,158)\"><path id=\"SvgjsPath1083\" d=\"M 0 0L 108 0L 108 56L 0 56Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1084\"><text id=\"SvgjsText1085\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"88px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"17.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1086\" dy=\"16\" x=\"54\"><tspan id=\"SvgjsTspan1087\" style=\"text-decoration:;\">登录成功</tspan></tspan></text></g></g><g id=\"SvgjsG1088\"><path id=\"SvgjsPath1089\" d=\"M364 186L312 186L312 186L262.6 186\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1090)\"></path></g><g id=\"SvgjsG1092\"><path id=\"SvgjsPath1093\" d=\"M205 157L205 123.5L205 123.5L205 92.6\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1094)\"></path><rect id=\"SvgjsRect1096\" width=\"52\" height=\"16\" x=\"179\" y=\"116.8\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1097\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"52px\" fill=\"#323232\" font-weight=\"400\" align=\"top\" lineHeight=\"16px\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"114.175\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1098\" dy=\"16\" x=\"205\"><tspan id=\"SvgjsTspan1099\" style=\"text-decoration:;\">允许访问</tspan></tspan></text></g></svg>\n  <p style=\"text-align:center; color: #888;\">（Cookie + Session 实现流程 - 首次登录）</p>\n</div>\n<ol>\n<li>用户访问 <code>a.com/page-a</code>，并输入密码登录。</li>\n<li>服务器验证密码无误后，会创建 SessionId，并将它保存起来。</li>\n<li>服务器端响应这个 HTTP 请求，并通过 Set-Cookie 头信息，将 SessionId 写入 Cookie 中。</li>\n</ol>\n<blockquote>\n<p>服务器端的 SessionId 可能存放在很多地方，例如：内存、文件、数据库等。</p>\n</blockquote>\n<p>第一次登录完成之后，后续的访问就可以直接使用 Cookie 进行身份验证了：</p>\n<div style=\"text-align: center;\">\n  <svg id=\"SvgjsSvg1100\" width=\"718\" height=\"240\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><defs id=\"SvgjsDefs1101\"><marker id=\"SvgjsMarker1122\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1123\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1138\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1139\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1152\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1153\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1166\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1167\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1174\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1175\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker></defs><g id=\"SvgjsG1102\" transform=\"translate(37,25)\"><path id=\"SvgjsPath1103\" d=\"M 0 10C 0 -3.3333333333333335 20 -3.3333333333333335 20 10C 20 23.333333333333332 0 23.333333333333332 0 10Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1104\"><text id=\"SvgjsText1105\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"0px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"-0.625\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1106\"><path id=\"SvgjsPath1107\" d=\"M25 61L47 61L47 61L69 61\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\"></path></g><g id=\"SvgjsG1108\"><path id=\"SvgjsPath1109\" d=\"M47 46L47 59.5L47 59.5L47 74\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\"></path></g><g id=\"SvgjsG1110\"><path id=\"SvgjsPath1111\" d=\"M46 73L29 91\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\"></path></g><g id=\"SvgjsG1112\"><path id=\"SvgjsPath1113\" d=\"M47 73L62 91\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\"></path></g><g id=\"SvgjsG1114\" transform=\"translate(151,33)\"><path id=\"SvgjsPath1115\" d=\"M 0 0L 108 0L 108 56L 0 56Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1116\"><text id=\"SvgjsText1117\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"88px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"17.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1118\" dy=\"16\" x=\"54\"><tspan id=\"SvgjsTspan1119\" style=\"text-decoration:;\">a.com/page-b</tspan></tspan></text></g></g><g id=\"SvgjsG1120\"><path id=\"SvgjsPath1121\" d=\"M73 61L147.39999999999998 61\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1122)\"></path><rect id=\"SvgjsRect1124\" width=\"26\" height=\"16\" x=\"97.19999999999999\" y=\"53\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1125\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"26px\" fill=\"#323232\" font-weight=\"400\" align=\"top\" lineHeight=\"16px\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"50.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1126\" dy=\"16\" x=\"110.19999999999999\"><tspan id=\"SvgjsTspan1127\" style=\"text-decoration:;\">访问</tspan></tspan></text></g><g id=\"SvgjsG1128\" transform=\"translate(385,33)\"><path id=\"SvgjsPath1129\" d=\"M 0 0L 108 0L 108 56L 0 56Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1130\"><text id=\"SvgjsText1131\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"88px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.875\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1132\" dy=\"16\" x=\"54\"><tspan id=\"SvgjsTspan1133\" style=\"text-decoration:;\">服务器</tspan></tspan><tspan id=\"SvgjsTspan1134\" dy=\"16\" x=\"54\"><tspan id=\"SvgjsTspan1135\" style=\"text-decoration:;\">验证 Cookie</tspan></tspan></text></g></g><g id=\"SvgjsG1136\"><path id=\"SvgjsPath1137\" d=\"M260 61L381.4 61\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1138)\"></path><rect id=\"SvgjsRect1140\" width=\"73\" height=\"16\" x=\"284.2\" y=\"53\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1141\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"73px\" fill=\"#323232\" font-weight=\"400\" align=\"top\" lineHeight=\"16px\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"50.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1142\" dy=\"16\" x=\"320.7\"><tspan id=\"SvgjsTspan1143\" style=\"text-decoration:;\">传递 Cookie</tspan></tspan></text></g><g id=\"SvgjsG1144\" transform=\"translate(585,33)\"><path id=\"SvgjsPath1145\" d=\"M 0 0L 108 0L 108 56L 0 56Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1146\"><text id=\"SvgjsText1147\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"88px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"17.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1148\" dy=\"16\" x=\"54\"><tspan id=\"SvgjsTspan1149\" style=\"text-decoration:;\">踢回登录</tspan></tspan></text></g></g><g id=\"SvgjsG1150\"><path id=\"SvgjsPath1151\" d=\"M494 61L581.4 61\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1152)\"></path><rect id=\"SvgjsRect1154\" width=\"26\" height=\"16\" x=\"524.7\" y=\"53\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1155\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"26px\" fill=\"#323232\" font-weight=\"400\" align=\"top\" lineHeight=\"16px\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"50.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1156\" dy=\"16\" x=\"537.7\"><tspan id=\"SvgjsTspan1157\" style=\"text-decoration:;\">无效</tspan></tspan></text></g><g id=\"SvgjsG1158\" transform=\"translate(385,159)\"><path id=\"SvgjsPath1159\" d=\"M 0 0L 108 0L 108 56L 0 56Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1160\"><text id=\"SvgjsText1161\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"88px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"17.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1162\" dy=\"16\" x=\"54\"><tspan id=\"SvgjsTspan1163\" style=\"text-decoration:;\">登录成功</tspan></tspan></text></g></g><g id=\"SvgjsG1164\"><path id=\"SvgjsPath1165\" d=\"M439 90L439 124L439 124L439 155.4\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1166)\"></path><rect id=\"SvgjsRect1168\" width=\"26\" height=\"16\" x=\"426\" y=\"114.7\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1169\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"26px\" fill=\"#323232\" font-weight=\"400\" align=\"top\" lineHeight=\"16px\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"112.075\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1170\" dy=\"16\" x=\"439\"><tspan id=\"SvgjsTspan1171\" style=\"text-decoration:;\">有效</tspan></tspan></text></g><g id=\"SvgjsG1172\"><path id=\"SvgjsPath1173\" d=\"M384 187L205 187L205 92.6\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1174)\"></path><rect id=\"SvgjsRect1176\" width=\"52\" height=\"16\" x=\"221.3\" y=\"179\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1177\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"52px\" fill=\"#323232\" font-weight=\"400\" align=\"top\" lineHeight=\"16px\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"176.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1178\" dy=\"16\" x=\"247.3\"><tspan id=\"SvgjsTspan1179\" style=\"text-decoration:;\">允许访问</tspan></tspan></text></g></svg>\n  <p style=\"text-align:center; color: #888;\">（Cookie + Session 实现流程 - 身份验证）</p>\n</div>\n<ol>\n<li>用户访问 <code>a.com/page-b</code> 页面时，会自动带上第一次登录时写入的 Cookie。</li>\n<li>服务器端比对 Cookie 中的 SessionId 和保存在服务器端的 SessionId 是否一致。</li>\n<li>如果一致，则身份验证成功。</li>\n</ol>\n<h3 id=\"存在的问题\"> 存在的问题</h3>\n<p>虽然使用 Cookie + Session 的方式可以完成登录验证，但仍然存在一些问题：</p>\n<ul>\n<li>由于服务器端需要对接大量的客户端，也就需要存放大量的 SessionId，这样会导致服务器压力过大。</li>\n<li>如果服务器端是一个集群，为了同步登录态，需要将 SessionId 同步到每一台机器上，无形中增加了服务器端维护成本。</li>\n<li>由于 SessionId 存放在 Cookie 中，所以无法避免 CSRF 攻击。</li>\n</ul>\n<h2 id=\"token-登录\"> Token 登录</h2>\n<p>为了解决 Session + Cookie 机制暴露出的诸多问题，我们可以使用 Token 的登录方式。</p>\n<blockquote>\n<p>Token 是服务端生成的一串字符串，以作为客户端请求的一个令牌。当第一次登录后，服务器会生成一个 Token 并返回给客户端，客户端后续访问时，只需带上这个 Token 即可完成身份认证。</p>\n</blockquote>\n<h3 id=\"token-机制实现流程\"> Token 机制实现流程</h3>\n<p>用户首次登录时：</p>\n<div style=\"text-align: center;\">\n  <svg id=\"SvgjsSvg1180\" width=\"518\" height=\"240\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><defs id=\"SvgjsDefs1181\"><marker id=\"SvgjsMarker1202\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1203\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1219\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1220\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1233\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1234\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1247\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1248\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1255\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1256\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker></defs><g id=\"SvgjsG1182\" transform=\"translate(37,25)\"><path id=\"SvgjsPath1183\" d=\"M 0 10C 0 -3.3333333333333335 20 -3.3333333333333335 20 10C 20 23.333333333333332 0 23.333333333333332 0 10Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1184\"><text id=\"SvgjsText1185\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"0px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"-0.625\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1186\"><path id=\"SvgjsPath1187\" d=\"M25 61L47 61L47 61L69 61\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\"></path></g><g id=\"SvgjsG1188\"><path id=\"SvgjsPath1189\" d=\"M47 46L47 59.5L47 59.5L47 74\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\"></path></g><g id=\"SvgjsG1190\"><path id=\"SvgjsPath1191\" d=\"M46 73L29 91\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\"></path></g><g id=\"SvgjsG1192\"><path id=\"SvgjsPath1193\" d=\"M47 73L62 91\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\"></path></g><g id=\"SvgjsG1194\" transform=\"translate(151,33)\"><path id=\"SvgjsPath1195\" d=\"M 0 0L 108 0L 108 56L 0 56Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1196\"><text id=\"SvgjsText1197\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"88px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"17.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1198\" dy=\"16\" x=\"54\"><tspan id=\"SvgjsTspan1199\" style=\"text-decoration:;\">a.com/page-a</tspan></tspan></text></g></g><g id=\"SvgjsG1200\"><path id=\"SvgjsPath1201\" d=\"M73 61L147.39999999999998 61\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1202)\"></path><rect id=\"SvgjsRect1204\" width=\"26\" height=\"16\" x=\"97.19999999999999\" y=\"53\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1205\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"26px\" fill=\"#323232\" font-weight=\"400\" align=\"top\" lineHeight=\"16px\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"50.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1206\" dy=\"16\" x=\"110.19999999999999\"><tspan id=\"SvgjsTspan1207\" style=\"text-decoration:;\">访问</tspan></tspan></text></g><g id=\"SvgjsG1208\" transform=\"translate(385,33)\"><path id=\"SvgjsPath1209\" d=\"M 0 0L 108 0L 108 56L 0 56Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1210\"><text id=\"SvgjsText1211\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"88px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.875\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1212\" dy=\"16\" x=\"54\"><tspan id=\"SvgjsTspan1213\" style=\"text-decoration:;\">服务器</tspan><tspan id=\"SvgjsTspan1214\" style=\"text-decoration:;font-size: inherit;\">验证</tspan></tspan><tspan id=\"SvgjsTspan1215\" dy=\"16\" x=\"54\"><tspan id=\"SvgjsTspan1216\" style=\"text-decoration:;font-size: inherit;\">账号密码</tspan></tspan></text></g></g><g id=\"SvgjsG1217\"><path id=\"SvgjsPath1218\" d=\"M260 61L381.4 61\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1219)\"></path><rect id=\"SvgjsRect1221\" width=\"52\" height=\"16\" x=\"294.7\" y=\"53\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1222\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"52px\" fill=\"#323232\" font-weight=\"400\" align=\"top\" lineHeight=\"16px\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"50.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1223\" dy=\"16\" x=\"320.7\"><tspan id=\"SvgjsTspan1224\" style=\"text-decoration:;\">输入密码</tspan></tspan></text></g><g id=\"SvgjsG1225\" transform=\"translate(385,159)\"><path id=\"SvgjsPath1226\" d=\"M 0 0L 108 0L 108 56L 0 56Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1227\"><text id=\"SvgjsText1228\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"88px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"17.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1229\" dy=\"16\" x=\"54\"><tspan id=\"SvgjsTspan1230\" style=\"text-decoration:;\">生成 token</tspan></tspan></text></g></g><g id=\"SvgjsG1231\"><path id=\"SvgjsPath1232\" d=\"M439 90L439 124L439 124L439 155.4\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1233)\"></path><rect id=\"SvgjsRect1235\" width=\"52\" height=\"16\" x=\"413\" y=\"114.7\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1236\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"52px\" fill=\"#323232\" font-weight=\"400\" align=\"top\" lineHeight=\"16px\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"112.075\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1237\" dy=\"16\" x=\"439\"><tspan id=\"SvgjsTspan1238\" style=\"text-decoration:;\">验证成功</tspan></tspan></text></g><g id=\"SvgjsG1239\" transform=\"translate(151,159)\"><path id=\"SvgjsPath1240\" d=\"M 0 0L 108 0L 108 56L 0 56Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1241\"><text id=\"SvgjsText1242\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"88px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"17.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1243\" dy=\"16\" x=\"54\"><tspan id=\"SvgjsTspan1244\" style=\"text-decoration:;\">登录成功</tspan></tspan></text></g></g><g id=\"SvgjsG1245\"><path id=\"SvgjsPath1246\" d=\"M384 187L322 187L322 187L262.6 187\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1247)\"></path><rect id=\"SvgjsRect1249\" width=\"65\" height=\"16\" x=\"290.8\" y=\"179\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1250\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"65px\" fill=\"#323232\" font-weight=\"400\" align=\"top\" lineHeight=\"16px\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"176.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1251\" dy=\"16\" x=\"323.3\"><tspan id=\"SvgjsTspan1252\" style=\"text-decoration:;\">返回客户端</tspan></tspan></text></g><g id=\"SvgjsG1253\"><path id=\"SvgjsPath1254\" d=\"M205 158L205 124L205 124L205 92.6\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1255)\"></path><rect id=\"SvgjsRect1257\" width=\"52\" height=\"16\" x=\"179\" y=\"117.3\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1258\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"52px\" fill=\"#323232\" font-weight=\"400\" align=\"top\" lineHeight=\"16px\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"114.675\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1259\" dy=\"16\" x=\"205\"><tspan id=\"SvgjsTspan1260\" style=\"text-decoration:;\">允许访问</tspan></tspan></text></g></svg>\n  <p style=\"text-align:center; color: #888;\">（Token 机制实现流程 - 首次登录）</p>\n</div>\n<ol>\n<li>用户输入账号密码，并点击登录。</li>\n<li>服务器端验证账号密码无误，创建 Token。</li>\n<li>服务器端将 Token 返回给客户端，由<strong>客户端自由保存</strong>。</li>\n</ol>\n<p>后续页面访问时：</p>\n<div style=\"text-align: center;\">\n  <svg id=\"SvgjsSvg1261\" width=\"707\" height=\"240\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><defs id=\"SvgjsDefs1262\"><marker id=\"SvgjsMarker1283\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1284\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1299\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1300\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1313\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1314\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1327\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1328\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1335\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1336\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker></defs><g id=\"SvgjsG1263\" transform=\"translate(37,25)\"><path id=\"SvgjsPath1264\" d=\"M 0 10C 0 -3.3333333333333335 20 -3.3333333333333335 20 10C 20 23.333333333333332 0 23.333333333333332 0 10Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1265\"><text id=\"SvgjsText1266\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"0px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"-0.625\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1267\"><path id=\"SvgjsPath1268\" d=\"M25 61L47 61L47 61L69 61\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\"></path></g><g id=\"SvgjsG1269\"><path id=\"SvgjsPath1270\" d=\"M47 46L47 59.5L47 59.5L47 74\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\"></path></g><g id=\"SvgjsG1271\"><path id=\"SvgjsPath1272\" d=\"M46 73L29 91\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\"></path></g><g id=\"SvgjsG1273\"><path id=\"SvgjsPath1274\" d=\"M47 73L62 91\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\"></path></g><g id=\"SvgjsG1275\" transform=\"translate(151,33)\"><path id=\"SvgjsPath1276\" d=\"M 0 0L 108 0L 108 56L 0 56Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1277\"><text id=\"SvgjsText1278\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"88px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"17.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1279\" dy=\"16\" x=\"54\"><tspan id=\"SvgjsTspan1280\" style=\"text-decoration:;\">a.com/page-b</tspan></tspan></text></g></g><g id=\"SvgjsG1281\"><path id=\"SvgjsPath1282\" d=\"M73 61L147.39999999999998 61\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1283)\"></path><rect id=\"SvgjsRect1285\" width=\"26\" height=\"16\" x=\"97.19999999999999\" y=\"53\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1286\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"26px\" fill=\"#323232\" font-weight=\"400\" align=\"top\" lineHeight=\"16px\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"50.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1287\" dy=\"16\" x=\"110.19999999999999\"><tspan id=\"SvgjsTspan1288\" style=\"text-decoration:;\">访问</tspan></tspan></text></g><g id=\"SvgjsG1289\" transform=\"translate(385,33)\"><path id=\"SvgjsPath1290\" d=\"M 0 0L 108 0L 108 56L 0 56Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1291\"><text id=\"SvgjsText1292\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"88px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"8.875\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1293\" dy=\"16\" x=\"54\"><tspan id=\"SvgjsTspan1294\" style=\"text-decoration:;\">服务器</tspan></tspan><tspan id=\"SvgjsTspan1295\" dy=\"16\" x=\"54\"><tspan id=\"SvgjsTspan1296\" style=\"text-decoration:;font-size: inherit;\">验证 token</tspan></tspan></text></g></g><g id=\"SvgjsG1297\"><path id=\"SvgjsPath1298\" d=\"M260 61L381.4 61\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1299)\"></path><rect id=\"SvgjsRect1301\" width=\"65\" height=\"16\" x=\"288.2\" y=\"53\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1302\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"65px\" fill=\"#323232\" font-weight=\"400\" align=\"top\" lineHeight=\"16px\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"50.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1303\" dy=\"16\" x=\"320.7\"><tspan id=\"SvgjsTspan1304\" style=\"text-decoration:;\">传递 token</tspan></tspan></text></g><g id=\"SvgjsG1305\" transform=\"translate(385,159)\"><path id=\"SvgjsPath1306\" d=\"M 0 0L 108 0L 108 56L 0 56Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1307\"><text id=\"SvgjsText1308\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"88px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"17.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1309\" dy=\"16\" x=\"54\"><tspan id=\"SvgjsTspan1310\" style=\"text-decoration:;\">登录成功</tspan></tspan></text></g></g><g id=\"SvgjsG1311\"><path id=\"SvgjsPath1312\" d=\"M439 90L439 124L439 124L439 155.4\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1313)\"></path><rect id=\"SvgjsRect1315\" width=\"26\" height=\"16\" x=\"426\" y=\"114.7\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1316\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"26px\" fill=\"#323232\" font-weight=\"400\" align=\"top\" lineHeight=\"16px\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"112.075\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1317\" dy=\"16\" x=\"439\"><tspan id=\"SvgjsTspan1318\" style=\"text-decoration:;\">有效</tspan></tspan></text></g><g id=\"SvgjsG1319\" transform=\"translate(574,33)\"><path id=\"SvgjsPath1320\" d=\"M 0 0L 108 0L 108 56L 0 56Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffffff\"></path><g id=\"SvgjsG1321\"><text id=\"SvgjsText1322\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"88px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"17.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1323\" dy=\"16\" x=\"54\"><tspan id=\"SvgjsTspan1324\" style=\"text-decoration:;\">踢回登录</tspan></tspan></text></g></g><g id=\"SvgjsG1325\"><path id=\"SvgjsPath1326\" d=\"M494 61L533.5 61L533.5 61L570.4 61\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1327)\"></path><rect id=\"SvgjsRect1329\" width=\"26\" height=\"16\" x=\"519.2\" y=\"53\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1330\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"26px\" fill=\"#323232\" font-weight=\"400\" align=\"top\" lineHeight=\"16px\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"50.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1331\" dy=\"16\" x=\"532.2\"><tspan id=\"SvgjsTspan1332\" style=\"text-decoration:;\">无效</tspan></tspan></text></g><g id=\"SvgjsG1333\"><path id=\"SvgjsPath1334\" d=\"M384 187L205 187L205 92.6\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1335)\"></path><rect id=\"SvgjsRect1337\" width=\"52\" height=\"16\" x=\"221.3\" y=\"179\" fill=\"#ffffff\"></rect><text id=\"SvgjsText1338\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"52px\" fill=\"#323232\" font-weight=\"400\" align=\"top\" lineHeight=\"16px\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"176.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1339\" dy=\"16\" x=\"247.3\"><tspan id=\"SvgjsTspan1340\" style=\"text-decoration:;\">允许访问</tspan></tspan></text></g></svg>\n  <p style=\"text-align:center; color: #888;\">（Token 机制实现流程 - 身份验证）</p>\n</div>\n<ol>\n<li>用户访问 <code>a.com/pageB</code> 时，带上第一次登录时获取的 Token。</li>\n<li>服务器端验证 Token ，有效则身份验证成功。</li>\n</ol>\n<h3 id=\"token-机制的特点\"> Token 机制的特点</h3>\n<p>根据上面的案例，我们可以分析出 Token 的优缺点：</p>\n<ul>\n<li>服务器端不需要存放 Token，所以不会对服务器端造成压力，即使是服务器集群，也不需要增加维护成本。</li>\n<li>Token 可以存放在前端任何地方，可以不用保存在 Cookie 中，提升了页面的安全性。</li>\n<li>Token 下发之后，只要在生效时间之内，就一直有效，如果服务器端想收回此 Token 的权限，并不容易。</li>\n</ul>\n<h3 id=\"token-的生成方式\"> Token 的生成方式</h3>\n<p>最常见的 Token 生成方式是使用 JWT（Json Web Token），它是一种简洁的，自包含的方法用于通信双方之间以 JSON 对象的形式安全的传递信息。</p>\n<p>前面说到，使用 Token 后，服务器端并不会存储 Token，那怎么判断客户端发过来的 Token 是合法有效的呢？</p>\n<p>答案其实就在 Token 字符串中，其实 Token 并不是一串杂乱无章的字符串，而是通过多种算法拼接组合而成的字符串，我们来具体分析一下。</p>\n<p>JWT 算法主要分为 3 个部分：header（头信息），playload（消息体），signature（签名）。</p>\n<p>header 部分指定了该 JWT 使用的签名算法：</p>\n<div><pre><code>header <span>=</span> <span>'{\"alg\":\"HS256\",\"typ\":\"JWT\"}'</span>   <span>// \"HS256\" 表示使用了 HMAC-SHA256 来生成签名。</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>playload 部分表明了 JWT 的意图：</p>\n<div><pre><code>payload <span>=</span> <span>'{\"loggedInAs\":\"admin\",\"iat\":1422779638}'</span>   <span>// iat 表示令牌生成的时间</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>signature 部分为 JWT 的签名，主要为了让 JWT 不能被随意篡改，签名的方法分为两个步骤：</p>\n<ul>\n<li>输入 <code>base64url</code> 编码的 header 部分、<code>.</code>、<code>base64url</code> 编码的 playload 部分，输出 unsignedToken。</li>\n<li>输入服务器端私钥、unsignedToken，输出 signature 签名。</li>\n</ul>\n<div><pre><code><span>const</span> base64Header <span>=</span> <span>encodeBase64</span><span>(</span>header<span>)</span>\n<span>const</span> base64Payload <span>=</span> <span>encodeBase64</span><span>(</span>payload<span>)</span>\n<span>const</span> unsignedToken <span>=</span> <span><span>`</span><span><span>${</span>base64Header<span>}</span></span><span>.</span><span><span>${</span>base64Payload<span>}</span></span><span>`</span></span>\n<span>const</span> key <span>=</span> <span>'服务器私钥'</span>\n\nsignature <span>=</span> <span>HMAC</span><span>(</span>key<span>,</span> unsignedToken<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>最后的 Token 计算如下：</p>\n<div><pre><code><span>const</span> base64Header <span>=</span> <span>encodeBase64</span><span>(</span>header<span>)</span>\n<span>const</span> base64Payload <span>=</span> <span>encodeBase64</span><span>(</span>payload<span>)</span>\n<span>const</span> base64Signature <span>=</span> <span>encodeBase64</span><span>(</span>signature<span>)</span>\n\ntoken <span>=</span> <span><span>`</span><span><span>${</span>base64Header<span>}</span></span><span>.</span><span><span>${</span>base64Payload<span>}</span></span><span>.</span><span><span>${</span>base64Signature<span>}</span></span><span>`</span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>服务器在判断 Token 时：</p>\n<div><pre><code><span>const</span> <span>[</span>base64Header<span>,</span> base64Payload<span>,</span> base64Signature<span>]</span> <span>=</span> token<span>.</span><span>split</span><span>(</span><span>'.'</span><span>)</span>\n\n<span>const</span> signature1 <span>=</span> <span>decodeBase64</span><span>(</span>base64Signature<span>)</span>\n<span>const</span> unsignedToken <span>=</span> <span><span>`</span><span><span>${</span>base64Header<span>}</span></span><span>.</span><span><span>${</span>base64Payload<span>}</span></span><span>`</span></span>\n<span>const</span> signature2 <span>=</span> <span>HMAC</span><span>(</span><span>'服务器私钥'</span><span>,</span> unsignedToken<span>)</span>\n\n<span>if</span><span>(</span>signature1 <span>===</span> signature2<span>)</span> <span>{</span>\n  <span>return</span> <span>'签名验证成功，token 没有被篡改'</span>\n<span>}</span>\n\n<span>const</span> payload <span>=</span>  <span>decodeBase64</span><span>(</span>base64Payload<span>)</span>\n<span>if</span><span>(</span><span>new</span> <span>Date</span><span>(</span><span>)</span> <span>-</span> payload<span>.</span>iat <span>&lt;</span> <span>'token 有效期'</span><span>)</span><span>{</span>\n  <span>return</span> <span>'token 有效'</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>有了 Token 之后，登录方式已经变得非常高效。</p>\n<h2 id=\"sso-单点登录\"> SSO 单点登录</h2>\n<p>单点登录指的是在公司内部搭建一个公共的认证中心，公司下的所有产品的登录都可以在认证中心里完成，一个产品在认证中心登录后，再去访问另一个产品，可以不用再次登录，即可获取登录状态。</p>\n<h3 id=\"sso-机制实现流程\"> SSO 机制实现流程</h3>\n<p>用户首次访问时，需要在认证中心登录：</p>\n<div style=\"text-align: center;\">\n  <svg id=\"SvgjsSvg1006\" width=\"899.5\" height=\"566\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><defs id=\"SvgjsDefs1007\"><marker id=\"SvgjsMarker1050\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1051\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1066\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1067\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1076\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1077\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1092\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1093\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1108\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1109\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1118\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1119\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1128\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1129\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1144\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1145\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1148\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1149\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1152\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1153\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1174\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1175\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker></defs><g id=\"SvgjsG1008\"><path id=\"SvgjsPath1009\" d=\"M91 68L91 541\" stroke-dasharray=\"8,5\" stroke=\"#e0e0e0\" stroke-width=\"2\" fill=\"none\"></path></g><g id=\"SvgjsG1010\"><path id=\"SvgjsPath1011\" d=\"M390 67L390 531\" stroke-dasharray=\"8,5\" stroke=\"#e0e0e0\" stroke-width=\"2\" fill=\"none\"></path></g><g id=\"SvgjsG1012\"><path id=\"SvgjsPath1013\" d=\"M689 68L689 537.5\" stroke-dasharray=\"8,5\" stroke=\"#e0e0e0\" stroke-width=\"2\" fill=\"none\"></path></g><g id=\"SvgjsG1014\" transform=\"translate(623,25)\"><path id=\"SvgjsPath1015\" d=\"M 0 0L 132 0L 132 42L 0 42Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffe0b2\"></path><g id=\"SvgjsG1016\"><text id=\"SvgjsText1017\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"112px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"10.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1018\" dy=\"16\" x=\"66\"><tspan id=\"SvgjsTspan1019\" style=\"text-decoration:;\">认证中心(sso.com)</tspan></tspan></text></g></g><g id=\"SvgjsG1020\" transform=\"translate(324,25)\"><path id=\"SvgjsPath1021\" d=\"M 0 0L 132 0L 132 42L 0 42Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#fff9c4\"></path><g id=\"SvgjsG1022\"><text id=\"SvgjsText1023\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"112px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"10.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1024\" dy=\"16\" x=\"66\"><tspan id=\"SvgjsTspan1025\" style=\"text-decoration:;\">系统 A(a.com)</tspan></tspan></text></g></g><g id=\"SvgjsG1026\" transform=\"translate(25,25)\"><path id=\"SvgjsPath1027\" d=\"M 0 0L 132 0L 132 42L 0 42Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#bbdefb\"></path><g id=\"SvgjsG1028\"><text id=\"SvgjsText1029\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"112px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"10.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1030\" dy=\"16\" x=\"66\"><tspan id=\"SvgjsTspan1031\" style=\"text-decoration:;\">浏览器</tspan></tspan></text></g></g><g id=\"SvgjsG1032\" transform=\"translate(81,114.5)\"><path id=\"SvgjsPath1033\" d=\"M 0 0L 20 0L 20 75L 0 75Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#bbdefb\"></path><g id=\"SvgjsG1034\"><text id=\"SvgjsText1035\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"0px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"26.875\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1036\" transform=\"translate(380,114.5)\"><path id=\"SvgjsPath1037\" d=\"M 0 0L 20 0L 20 75L 0 75Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#fff9c4\"></path><g id=\"SvgjsG1038\"><text id=\"SvgjsText1039\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"0px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"26.875\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1040\" transform=\"translate(81,251.5)\"><path id=\"SvgjsPath1041\" d=\"M 0 0L 20 0L 20 259L 0 259Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#bbdefb\"></path><g id=\"SvgjsG1042\"><text id=\"SvgjsText1043\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"0px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"118.875\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1044\" transform=\"translate(679,251.5)\"><path id=\"SvgjsPath1045\" d=\"M 0 0L 20 0L 20 259L 0 259Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffe0b2\"></path><g id=\"SvgjsG1046\"><text id=\"SvgjsText1047\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"0px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"118.875\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1048\"><path id=\"SvgjsPath1049\" d=\"M102 114.84452575685384L240.42758649849338 114.84452575685384L240.42758649849338 114.84452575685384L376.4 114.84452575685384\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1050)\"></path></g><g id=\"SvgjsG1052\" transform=\"translate(181.5,84)\"><path id=\"SvgjsPath1053\" d=\"M 0 0L 119 0L 119 30L 0 30Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1054\"><text id=\"SvgjsText1055\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"119px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"4.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1056\" dy=\"16\" x=\"59.5\"><tspan id=\"SvgjsTspan1057\" style=\"text-decoration:;\">访问受保护页面</tspan></tspan></text></g></g><g id=\"SvgjsG1058\" transform=\"translate(144.5,119)\"><path id=\"SvgjsPath1059\" d=\"M 0 0L 193 0L 193 22L 0 22Z\" stroke=\"none\" fill-opacity=\"1\" fill=\"#e0e0e0\"></path><g id=\"SvgjsG1060\"><text id=\"SvgjsText1061\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"173px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"0.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1062\" dy=\"16\" x=\"96.5\"><tspan id=\"SvgjsTspan1063\" style=\"text-decoration:;\">www.a.com/page-a</tspan></tspan></text></g></g><g id=\"SvgjsG1064\"><path id=\"SvgjsPath1065\" d=\"M400.9860544094445 117.1120754343518C 479 123 472 137 403.4537995365141 150.98448596190178\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1066)\"></path></g><g id=\"SvgjsG1068\" transform=\"translate(435.5,115)\"><path id=\"SvgjsPath1069\" d=\"M 0 0L 119 0L 119 30L 0 30Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1070\"><text id=\"SvgjsText1071\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"119px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"4.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1072\" dy=\"16\" x=\"59.5\"><tspan id=\"SvgjsTspan1073\" style=\"text-decoration:;\">验证未登录</tspan></tspan></text></g></g><g id=\"SvgjsG1074\"><path id=\"SvgjsPath1075\" d=\"M379 185.22339182284404L104.60000000000002 185.22339182284404\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1076)\"></path></g><g id=\"SvgjsG1078\" transform=\"translate(181.5,159)\"><path id=\"SvgjsPath1079\" d=\"M 0 0L 119 0L 119 30L 0 30Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1080\"><text id=\"SvgjsText1081\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"119px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"4.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1082\" dy=\"16\" x=\"59.5\"><tspan id=\"SvgjsTspan1083\" style=\"text-decoration:;\">302 重定向</tspan></tspan></text></g></g><g id=\"SvgjsG1084\" transform=\"translate(103,193)\"><path id=\"SvgjsPath1085\" d=\"M 0 0L 332.5 0L 332.5 22L 0 22Z\" stroke=\"none\" fill-opacity=\"1\" fill=\"#e0e0e0\"></path><g id=\"SvgjsG1086\"><text id=\"SvgjsText1087\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"313px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"0.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1088\" dy=\"16\" x=\"166.5\"><tspan id=\"SvgjsTspan1089\" style=\"text-decoration:;\">www.sso.com/login?redirect=www.a.com/page-a</tspan></tspan></text></g></g><g id=\"SvgjsG1090\"><path id=\"SvgjsPath1091\" d=\"M102 253.84729635533387L675.4 253.84729635533387\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1092)\"></path></g><g id=\"SvgjsG1094\" transform=\"translate(307.25,226)\"><path id=\"SvgjsPath1095\" d=\"M 0 0L 119 0L 119 30L 0 30Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1096\"><text id=\"SvgjsText1097\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"119px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"4.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1098\" dy=\"16\" x=\"59.5\"><tspan id=\"SvgjsTspan1099\" style=\"text-decoration:;\">访问 www.sso.com</tspan></tspan></text></g></g><g id=\"SvgjsG1100\" transform=\"translate(205.25,260)\"><path id=\"SvgjsPath1101\" d=\"M 0 0L 348.75 0L 348.75 22L 0 22Z\" stroke=\"none\" fill-opacity=\"1\" fill=\"#e0e0e0\"></path><g id=\"SvgjsG1102\"><text id=\"SvgjsText1103\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"329px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"0.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1104\" dy=\"16\" x=\"174.5\"><tspan id=\"SvgjsTspan1105\" style=\"text-decoration:;\">www.sso.com/login?redirect=www.a.com/page-a</tspan></tspan></text></g></g><g id=\"SvgjsG1106\"><path id=\"SvgjsPath1107\" d=\"M699.9377795270102 252.28300998928887C 771 263 716.6447150240459 298 702.4035464371821 297.32702444614347\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1108)\"></path></g><g id=\"SvgjsG1110\" transform=\"translate(714.5,256)\"><path id=\"SvgjsPath1111\" d=\"M 0 0L 119 0L 119 30L 0 30Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1112\"><text id=\"SvgjsText1113\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"119px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"4.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1114\" dy=\"16\" x=\"59.5\"><tspan id=\"SvgjsTspan1115\" style=\"text-decoration:;\">验证未登录</tspan></tspan></text></g></g><g id=\"SvgjsG1116\"><path id=\"SvgjsPath1117\" d=\"M678 318L104.60000000000002 318\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1118)\"></path></g><g id=\"SvgjsG1120\" transform=\"translate(307.25,292.5)\"><path id=\"SvgjsPath1121\" d=\"M 0 0L 119 0L 119 30L 0 30Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1122\"><text id=\"SvgjsText1123\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"119px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"4.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1124\" dy=\"16\" x=\"59.5\"><tspan id=\"SvgjsTspan1125\" style=\"text-decoration:;\">展示登录 form</tspan></tspan></text></g></g><g id=\"SvgjsG1126\"><path id=\"SvgjsPath1127\" d=\"M102 370L675.4 370\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1128)\"></path></g><g id=\"SvgjsG1130\" transform=\"translate(307.25,341)\"><path id=\"SvgjsPath1131\" d=\"M 0 0L 119 0L 119 30L 0 30Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1132\"><text id=\"SvgjsText1133\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"119px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"4.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1134\" dy=\"16\" x=\"59.5\"><tspan id=\"SvgjsTspan1135\" style=\"text-decoration:;\">POST 用户名+密码</tspan></tspan></text></g></g><g id=\"SvgjsG1136\" transform=\"translate(205.25,376)\"><path id=\"SvgjsPath1137\" d=\"M 0 0L 348.75 0L 348.75 22L 0 22Z\" stroke=\"none\" fill-opacity=\"1\" fill=\"#e0e0e0\"></path><g id=\"SvgjsG1138\"><text id=\"SvgjsText1139\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"329px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"0.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1140\" dy=\"16\" x=\"174.5\"><tspan id=\"SvgjsTspan1141\" style=\"text-decoration:;\">www.sso.com/login?redirect=www.a.com/page-a</tspan></tspan></text></g></g><g id=\"SvgjsG1142\"><path id=\"SvgjsPath1143\" d=\"M699.9615239476408 369.27472112789735C 762 374 741 401 702.4423198398267 403.9462286204612\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1144)\"></path></g><g id=\"SvgjsG1146\"><path id=\"SvgjsPath1147\" d=\"M699.9528888156635 410.30331980644746C 770 417 731 444 702.473730724737 444.05491013548044\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1148)\"></path></g><g id=\"SvgjsG1150\"><path id=\"SvgjsPath1151\" d=\"M699.9528755086391 450.3033616077157C 777 458 722 482 702.449762779039 482.97085629363175\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1152)\"></path></g><g id=\"SvgjsG1154\" transform=\"translate(744.5,372)\"><path id=\"SvgjsPath1155\" d=\"M 0 0L 130.5 0L 130.5 30L 0 30Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1156\"><text id=\"SvgjsText1157\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"131px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"4.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1158\" dy=\"16\" x=\"65.5\"><tspan id=\"SvgjsTspan1159\" style=\"text-decoration:;\">验证用户名和密码成功</tspan></tspan></text></g></g><g id=\"SvgjsG1160\" transform=\"translate(723.5,411)\"><path id=\"SvgjsPath1161\" d=\"M 0 0L 119 0L 119 30L 0 30Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1162\"><text id=\"SvgjsText1163\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"119px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"4.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1164\" dy=\"16\" x=\"59.5\"><tspan id=\"SvgjsTspan1165\" style=\"text-decoration:;\">创建全局会话</tspan></tspan></text></g></g><g id=\"SvgjsG1166\" transform=\"translate(725,446)\"><path id=\"SvgjsPath1167\" d=\"M 0 0L 103 0L 103 36L 0 36Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1168\"><text id=\"SvgjsText1169\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"103px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"7.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1170\" dy=\"16\" x=\"51.5\"><tspan id=\"SvgjsTspan1171\" style=\"text-decoration:;\">创建 ticket</tspan></tspan></text></g></g><g id=\"SvgjsG1172\"><path id=\"SvgjsPath1173\" d=\"M678 486L104.60000000000002 486\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1174)\"></path></g><g id=\"SvgjsG1176\" transform=\"translate(307.25,456)\"><path id=\"SvgjsPath1177\" d=\"M 0 0L 119 0L 119 30L 0 30Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1178\"><text id=\"SvgjsText1179\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"119px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"4.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1180\" dy=\"16\" x=\"59.5\"><tspan id=\"SvgjsTspan1181\" style=\"text-decoration:;\">302 重定向</tspan></tspan></text></g></g><g id=\"SvgjsG1182\" transform=\"translate(205.25,492)\"><path id=\"SvgjsPath1183\" d=\"M 0 0L 348.75 0L 348.75 45.5L 0 45.5Z\" stroke=\"none\" fill-opacity=\"1\" fill=\"#e0e0e0\"></path><g id=\"SvgjsG1184\"><text id=\"SvgjsText1185\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"329px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"3.625\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1186\" dy=\"16\" x=\"174.5\"><tspan id=\"SvgjsTspan1187\" style=\"text-decoration:;\">Set cookie: ssoid=1234, sso.com</tspan></tspan><tspan id=\"SvgjsTspan1188\" dy=\"16\" x=\"174.5\"><tspan id=\"SvgjsTspan1189\" style=\"text-decoration:;\">redirect 目标: www.a.com/page-a?ticket=T123</tspan></tspan></text></g></g></svg>\n  <p style=\"text-align:center; color: #888;\">（SSO 机制实现流程 - 首次访问）</p>\n</div>\n<ol>\n<li>用户访问网站 <code>a.com</code> 下的 page-a 页面。</li>\n<li>由于没有登录，则会重定向到认证中心，并带上回调地址 <code>www.sso.com/login?redirect=www.a.com/page-a</code>，以便登录后直接进入对应页面。</li>\n<li>用户在认证中心输入账号密码，提交登录。</li>\n<li>认证中心验证账号密码有效，然后重定向  <code>a.com?ticket=123</code> 带上授权码 ticket，并将认证中心 <code>sso.com</code> 的登录态写入 Cookie。</li>\n<li>在 <code>a.com</code> 服务器中，拿着 ticket 向认证中心确认，授权码 ticket 真实有效。</li>\n<li>验证成功后，服务器将登录信息写入 Cookie（此时客户端有 2 个 Cookie 分别存有 <code>a.com</code> 和 <code>sso.com</code> 的登录态）。</li>\n</ol>\n<hr>\n<p>认证中心登录完成之后，继续访问 <code>a.com</code> 下的其他页面：</p>\n<div style=\"text-align: center;\">\n  <svg id=\"SvgjsSvg1006\" width=\"840\" height=\"566\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><defs id=\"SvgjsDefs1007\"><marker id=\"SvgjsMarker1066\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1067\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1070\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1071\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1080\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1081\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1090\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1091\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1100\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1101\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1110\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1111\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1120\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1121\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1130\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1131\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1140\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1141\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1156\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1157\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1166\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1167\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker></defs><g id=\"SvgjsG1008\"><path id=\"SvgjsPath1009\" d=\"M91 68L91 541\" stroke-dasharray=\"8,5\" stroke=\"#e0e0e0\" stroke-width=\"2\" fill=\"none\"></path></g><g id=\"SvgjsG1010\"><path id=\"SvgjsPath1011\" d=\"M390 67L390 541\" stroke-dasharray=\"8,5\" stroke=\"#e0e0e0\" stroke-width=\"2\" fill=\"none\"></path></g><g id=\"SvgjsG1012\"><path id=\"SvgjsPath1013\" d=\"M689 68L689 537.5\" stroke-dasharray=\"8,5\" stroke=\"#e0e0e0\" stroke-width=\"2\" fill=\"none\"></path></g><g id=\"SvgjsG1014\" transform=\"translate(623,25)\"><path id=\"SvgjsPath1015\" d=\"M 0 0L 132 0L 132 42L 0 42Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffe0b2\"></path><g id=\"SvgjsG1016\"><text id=\"SvgjsText1017\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"112px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"10.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1018\" dy=\"16\" x=\"66\"><tspan id=\"SvgjsTspan1019\" style=\"text-decoration:;\">认证中心(sso.com)</tspan></tspan></text></g></g><g id=\"SvgjsG1020\" transform=\"translate(324,25)\"><path id=\"SvgjsPath1021\" d=\"M 0 0L 132 0L 132 42L 0 42Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#fff9c4\"></path><g id=\"SvgjsG1022\"><text id=\"SvgjsText1023\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"112px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"10.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1024\" dy=\"16\" x=\"66\"><tspan id=\"SvgjsTspan1025\" style=\"text-decoration:;\">系统 A(a.com)</tspan></tspan></text></g></g><g id=\"SvgjsG1026\" transform=\"translate(25,25)\"><path id=\"SvgjsPath1027\" d=\"M 0 0L 132 0L 132 42L 0 42Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#bbdefb\"></path><g id=\"SvgjsG1028\"><text id=\"SvgjsText1029\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"112px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"10.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1030\" dy=\"16\" x=\"66\"><tspan id=\"SvgjsTspan1031\" style=\"text-decoration:;\">浏览器</tspan></tspan></text></g></g><g id=\"SvgjsG1032\" transform=\"translate(81,114.5)\"><path id=\"SvgjsPath1033\" d=\"M 0 0L 20 0L 20 257.5L 0 257.5Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#bbdefb\"></path><g id=\"SvgjsG1034\"><text id=\"SvgjsText1035\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"0px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"118.125\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1036\" transform=\"translate(380,175)\"><path id=\"SvgjsPath1037\" d=\"M 0 0L 20 0L 20 197L 0 197Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#fff9c4\"></path><g id=\"SvgjsG1038\"><text id=\"SvgjsText1039\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"0px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"87.875\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1040\" transform=\"translate(81,430)\"><path id=\"SvgjsPath1041\" d=\"M 0 0L 20 0L 20 80.5L 0 80.5Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#bbdefb\"></path><g id=\"SvgjsG1042\"><text id=\"SvgjsText1043\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"0px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"29.625\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1044\" transform=\"translate(679,160.5)\"><path id=\"SvgjsPath1045\" d=\"M 0 0L 20 0L 20 124.5L 0 124.5Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffe0b2\"></path><g id=\"SvgjsG1046\"><text id=\"SvgjsText1047\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"0px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"51.625\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1048\" transform=\"translate(134.5,114.5)\"><path id=\"SvgjsPath1049\" d=\"M 0 0L 169.5 0L 169.5 29.5L 0 29.5Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1050\"><text id=\"SvgjsText1051\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"170px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"4.125\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1052\" dy=\"16\" x=\"85\"><tspan id=\"SvgjsTspan1053\" style=\"text-decoration:;\">保存 sso.com 的 cookie</tspan></tspan></text></g></g><g id=\"SvgjsG1054\" transform=\"translate(124.25,353.5)\"><path id=\"SvgjsPath1055\" d=\"M 0 0L 232.5 0L 232.5 24.5L 0 24.5Z\" stroke=\"none\" fill-opacity=\"1\" fill=\"#e0e0e0\"></path><g id=\"SvgjsG1056\"><text id=\"SvgjsText1057\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"213px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"1.625\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1058\" dy=\"16\" x=\"116.5\"><tspan id=\"SvgjsTspan1059\" style=\"text-decoration:;\">Set cookie: sessionid=xxxx, a.com</tspan></tspan></text></g></g><g id=\"SvgjsG1060\" transform=\"translate(380,430)\"><path id=\"SvgjsPath1061\" d=\"M 0 0L 20 0L 20 80.5L 0 80.5Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#fff9c4\"></path><g id=\"SvgjsG1062\"><text id=\"SvgjsText1063\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"0px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"29.625\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1064\"><path id=\"SvgjsPath1065\" d=\"M101.97753660527621 117.2107657119767C 159 122 155 134 104.36395057678453 146.7178781193073\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1066)\"></path></g><g id=\"SvgjsG1068\"><path id=\"SvgjsPath1069\" d=\"M102 188L376.4 188\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1070)\"></path></g><g id=\"SvgjsG1072\" transform=\"translate(123.25,160.5)\"><path id=\"SvgjsPath1073\" d=\"M 0 0L 234.5 0L 234.5 27.5L 0 27.5Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1074\"><text id=\"SvgjsText1075\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"235px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"3.125\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1076\" dy=\"16\" x=\"117.5\"><tspan id=\"SvgjsTspan1077\" style=\"text-decoration:;\">www.a.com/page-a?ticket=T123</tspan></tspan></text></g></g><g id=\"SvgjsG1078\"><path id=\"SvgjsPath1079\" d=\"M401 187L675.4 187\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1080)\"></path></g><g id=\"SvgjsG1082\" transform=\"translate(442.5,160.5)\"><path id=\"SvgjsPath1083\" d=\"M 0 0L 169.5 0L 169.5 29.5L 0 29.5Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1084\"><text id=\"SvgjsText1085\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"170px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"4.125\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1086\" dy=\"16\" x=\"85\"><tspan id=\"SvgjsTspan1087\" style=\"text-decoration:;\">验证 ticket</tspan></tspan></text></g></g><g id=\"SvgjsG1088\"><path id=\"SvgjsPath1089\" d=\"M699.9678414941243 186.25156081223298C 766 192 739 214 702.3805419509584 221.51228593051127\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1090)\"></path></g><g id=\"SvgjsG1092\" transform=\"translate(736,182)\"><path id=\"SvgjsPath1093\" d=\"M 0 0L 79 0L 79 36L 0 36Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1094\"><text id=\"SvgjsText1095\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"79px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"7.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1096\" dy=\"16\" x=\"39.5\"><tspan id=\"SvgjsTspan1097\" style=\"text-decoration:;\">ticket 有效</tspan></tspan></text></g></g><g id=\"SvgjsG1098\"><path id=\"SvgjsPath1099\" d=\"M697.96252089222 233.27120754421668C 775 237 722 270 700.465543384554 268.0253159230942\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1100)\"></path></g><g id=\"SvgjsG1102\" transform=\"translate(736,229.5)\"><path id=\"SvgjsPath1103\" d=\"M 0 0L 79 0L 79 36L 0 36Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1104\"><text id=\"SvgjsText1105\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"79px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"7.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1106\" dy=\"16\" x=\"39.5\"><tspan id=\"SvgjsTspan1107\" style=\"text-decoration:;\">注册系统 A</tspan></tspan></text></g></g><g id=\"SvgjsG1108\"><path id=\"SvgjsPath1109\" d=\"M678 273.5L403.6 273.5\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1110)\"></path></g><g id=\"SvgjsG1112\" transform=\"translate(438.5,247.5)\"><path id=\"SvgjsPath1113\" d=\"M 0 0L 169.5 0L 169.5 29.5L 0 29.5Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1114\"><text id=\"SvgjsText1115\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"170px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"4.125\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1116\" dy=\"16\" x=\"85\"><tspan id=\"SvgjsTspan1117\" style=\"text-decoration:;\">令牌有效</tspan></tspan></text></g></g><g id=\"SvgjsG1118\"><path id=\"SvgjsPath1119\" d=\"M400.94931991990256 295.31431145330106C 472 306 431 334 403.41341629114334 337.8560641524293\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1120)\"></path></g><g id=\"SvgjsG1122\" transform=\"translate(406,299)\"><path id=\"SvgjsPath1123\" d=\"M 0 0L 157 0L 157 30L 0 30Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1124\"><text id=\"SvgjsText1125\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"157px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"4.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1126\" dy=\"16\" x=\"78.5\"><tspan id=\"SvgjsTspan1127\" style=\"text-decoration:;\">创建局部会话</tspan></tspan></text></g></g><g id=\"SvgjsG1128\"><path id=\"SvgjsPath1129\" d=\"M379 349C 268.4 349 212.60000000000002 349.0000000000001 104.60000000000002 349\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1130)\"></path></g><g id=\"SvgjsG1132\" transform=\"translate(134.5,321.5)\"><path id=\"SvgjsPath1133\" d=\"M 0 0L 169.5 0L 169.5 29.5L 0 29.5Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1134\"><text id=\"SvgjsText1135\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"170px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"4.125\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1136\" dy=\"16\" x=\"85\"><tspan id=\"SvgjsTspan1137\" style=\"text-decoration:;\">返回受保护资源 page-a</tspan></tspan></text></g></g><g id=\"SvgjsG1138\"><path id=\"SvgjsPath1139\" d=\"M101.01522120763303 431.3486229709906L376.9315389351832 431.3486229709906\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1140)\"></path></g><g id=\"SvgjsG1142\" transform=\"translate(129.5,405.5)\"><path id=\"SvgjsPath1143\" d=\"M 0 0L 222 0L 222 24.5L 0 24.5Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1144\"><text id=\"SvgjsText1145\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"222px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"1.625\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1146\" dy=\"16\" x=\"111\"><tspan id=\"SvgjsTspan1147\" style=\"text-decoration:;\">访问另外一个受保护资源 page-a1</tspan></tspan></text></g></g><g id=\"SvgjsG1148\" transform=\"translate(119,435.5)\"><path id=\"SvgjsPath1149\" d=\"M 0 0L 232.5 0L 232.5 24.5L 0 24.5Z\" stroke=\"none\" fill-opacity=\"1\" fill=\"#e0e0e0\"></path><g id=\"SvgjsG1150\"><text id=\"SvgjsText1151\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"213px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"1.625\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1152\" dy=\"16\" x=\"116.5\"><tspan id=\"SvgjsTspan1153\" style=\"text-decoration:;\">cookie: sessionid=xxxx, a.com</tspan></tspan></text></g></g><g id=\"SvgjsG1154\"><path id=\"SvgjsPath1155\" d=\"M400.9523392635343 432.305040861412C 473 441 423 465 403.3678961151569 468.9782784276773\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1156)\"></path></g><g id=\"SvgjsG1158\" transform=\"translate(406,432.75)\"><path id=\"SvgjsPath1159\" d=\"M 0 0L 157 0L 157 30L 0 30Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1160\"><text id=\"SvgjsText1161\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"157px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"4.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1162\" dy=\"16\" x=\"78.5\"><tspan id=\"SvgjsTspan1163\" style=\"text-decoration:;\">验证已经登录</tspan></tspan></text></g></g><g id=\"SvgjsG1164\"><path id=\"SvgjsPath1165\" d=\"M379 508.26794919243116L104.60000000000002 508.26794919243116\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1166)\"></path></g><g id=\"SvgjsG1168\" transform=\"translate(119,484.5)\"><path id=\"SvgjsPath1169\" d=\"M 0 0L 222 0L 222 24.5L 0 24.5Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1170\"><text id=\"SvgjsText1171\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"222px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"1.625\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1172\" dy=\"16\" x=\"111\"><tspan id=\"SvgjsTspan1173\" style=\"text-decoration:;\">返回 page-a1</tspan></tspan></text></g></g></svg>\n  <p style=\"text-align:center; color: #888;\">（SSO 机制实现流程 - 系统 A 身份验证）</p>\n</div>\n<p>这个时候，由于 <code>a.com</code> 存在已登录的 Cookie 信息，所以服务器端直接认证成功。</p>\n<hr>\n<p>如果认证中心登录完成之后，访问 <code>b.com</code> 下的页面：</p>\n<div style=\"text-align: center;\">\n  <svg id=\"SvgjsSvg1006\" width=\"866.5\" height=\"425\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><defs id=\"SvgjsDefs1007\"><marker id=\"SvgjsMarker1050\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1051\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1066\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1067\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1076\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1077\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1092\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1093\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1110\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1111\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1120\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1121\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#323232\" stroke=\"#323232\" stroke-width=\"1\"></path></marker></defs><g id=\"SvgjsG1008\"><path id=\"SvgjsPath1009\" d=\"M91 68L91 400\" stroke-dasharray=\"8,5\" stroke=\"#e0e0e0\" stroke-width=\"2\" fill=\"none\"></path></g><g id=\"SvgjsG1010\"><path id=\"SvgjsPath1011\" d=\"M390 67L390 400\" stroke-dasharray=\"8,5\" stroke=\"#e0e0e0\" stroke-width=\"2\" fill=\"none\"></path></g><g id=\"SvgjsG1012\"><path id=\"SvgjsPath1013\" d=\"M689 68L689 398\" stroke-dasharray=\"8,5\" stroke=\"#e0e0e0\" stroke-width=\"2\" fill=\"none\"></path></g><g id=\"SvgjsG1014\" transform=\"translate(623,25)\"><path id=\"SvgjsPath1015\" d=\"M 0 0L 132 0L 132 42L 0 42Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffe0b2\"></path><g id=\"SvgjsG1016\"><text id=\"SvgjsText1017\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"112px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"10.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1018\" dy=\"16\" x=\"66\"><tspan id=\"SvgjsTspan1019\" style=\"text-decoration:;\">认证中心(sso.com)</tspan></tspan></text></g></g><g id=\"SvgjsG1020\" transform=\"translate(324,25)\"><path id=\"SvgjsPath1021\" d=\"M 0 0L 132 0L 132 42L 0 42Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#c8e6c9\"></path><g id=\"SvgjsG1022\"><text id=\"SvgjsText1023\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"112px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"10.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1024\" dy=\"16\" x=\"66\"><tspan id=\"SvgjsTspan1025\" style=\"text-decoration:;\">系统 B(b.com)</tspan></tspan></text></g></g><g id=\"SvgjsG1026\" transform=\"translate(25,25)\"><path id=\"SvgjsPath1027\" d=\"M 0 0L 132 0L 132 42L 0 42Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#bbdefb\"></path><g id=\"SvgjsG1028\"><text id=\"SvgjsText1029\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"112px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"10.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1030\" dy=\"16\" x=\"66\"><tspan id=\"SvgjsTspan1031\" style=\"text-decoration:;\">浏览器</tspan></tspan></text></g></g><g id=\"SvgjsG1032\" transform=\"translate(81,114.5)\"><path id=\"SvgjsPath1033\" d=\"M 0 0L 20 0L 20 75L 0 75Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#bbdefb\"></path><g id=\"SvgjsG1034\"><text id=\"SvgjsText1035\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"0px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"26.875\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1036\" transform=\"translate(380,114.5)\"><path id=\"SvgjsPath1037\" d=\"M 0 0L 20 0L 20 75L 0 75Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#c8e6c9\"></path><g id=\"SvgjsG1038\"><text id=\"SvgjsText1039\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"0px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"26.875\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1040\" transform=\"translate(81,251.5)\"><path id=\"SvgjsPath1041\" d=\"M 0 0L 20 0L 20 115.5L 0 115.5Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#bbdefb\"></path><g id=\"SvgjsG1042\"><text id=\"SvgjsText1043\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"0px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"47.125\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1044\" transform=\"translate(679,251.5)\"><path id=\"SvgjsPath1045\" d=\"M 0 0L 20 0L 20 115.5L 0 115.5Z\" stroke=\"rgba(50,50,50,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffe0b2\"></path><g id=\"SvgjsG1046\"><text id=\"SvgjsText1047\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"0px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"47.125\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1048\"><path id=\"SvgjsPath1049\" d=\"M102 114.84452575685384L240.42758649849338 114.84452575685384L240.42758649849338 114.84452575685384L376.4 114.84452575685384\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1050)\"></path></g><g id=\"SvgjsG1052\" transform=\"translate(157,86.5)\"><path id=\"SvgjsPath1053\" d=\"M 0 0L 160.5 0L 160.5 28L 0 28Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1054\"><text id=\"SvgjsText1055\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"161px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"3.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1056\" dy=\"16\" x=\"80.5\"><tspan id=\"SvgjsTspan1057\" style=\"text-decoration:;\">访问系统 B 的受保护资源</tspan></tspan></text></g></g><g id=\"SvgjsG1058\" transform=\"translate(144.5,119)\"><path id=\"SvgjsPath1059\" d=\"M 0 0L 193 0L 193 22L 0 22Z\" stroke=\"none\" fill-opacity=\"1\" fill=\"#e0e0e0\"></path><g id=\"SvgjsG1060\"><text id=\"SvgjsText1061\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"173px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"0.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1062\" dy=\"16\" x=\"96.5\"><tspan id=\"SvgjsTspan1063\" style=\"text-decoration:;\">www.b.com/page-b</tspan></tspan></text></g></g><g id=\"SvgjsG1064\"><path id=\"SvgjsPath1065\" d=\"M400.9860544094445 117.1120754343518C 479 123 472 137 403.4537995365141 150.98448596190178\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1066)\"></path></g><g id=\"SvgjsG1068\" transform=\"translate(435.5,115)\"><path id=\"SvgjsPath1069\" d=\"M 0 0L 180.5 0L 180.5 30L 0 30Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1070\"><text id=\"SvgjsText1071\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"181px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"4.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1072\" dy=\"16\" x=\"90.5\"><tspan id=\"SvgjsTspan1073\" style=\"text-decoration:;\">未登录(没有局部会话)</tspan></tspan></text></g></g><g id=\"SvgjsG1074\"><path id=\"SvgjsPath1075\" d=\"M379 185.22339182284404L104.60000000000002 185.22339182284404\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1076)\"></path></g><g id=\"SvgjsG1078\" transform=\"translate(181.5,159.5)\"><path id=\"SvgjsPath1079\" d=\"M 0 0L 119 0L 119 30L 0 30Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1080\"><text id=\"SvgjsText1081\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"119px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"4.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1082\" dy=\"16\" x=\"59.5\"><tspan id=\"SvgjsTspan1083\" style=\"text-decoration:;\">302 重定向</tspan></tspan></text></g></g><g id=\"SvgjsG1084\" transform=\"translate(101,193)\"><path id=\"SvgjsPath1085\" d=\"M 0 0L 332.5 0L 332.5 22L 0 22Z\" stroke=\"none\" fill-opacity=\"1\" fill=\"#e0e0e0\"></path><g id=\"SvgjsG1086\"><text id=\"SvgjsText1087\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"313px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"0.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1088\" dy=\"16\" x=\"166.5\"><tspan id=\"SvgjsTspan1089\" style=\"text-decoration:;\">www.sso.com/login?redirect=www.b.com/page-b</tspan></tspan></text></g></g><g id=\"SvgjsG1090\"><path id=\"SvgjsPath1091\" d=\"M102 252.54676729359483L675.4 252.54676729359483\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1092)\"></path></g><g id=\"SvgjsG1094\" transform=\"translate(307.25,226)\"><path id=\"SvgjsPath1095\" d=\"M 0 0L 119 0L 119 30L 0 30Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1096\"><text id=\"SvgjsText1097\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"119px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"4.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1098\" dy=\"16\" x=\"59.5\"><tspan id=\"SvgjsTspan1099\" style=\"text-decoration:;\">访问 www.sso.com</tspan></tspan></text></g></g><g id=\"SvgjsG1100\" transform=\"translate(205.25,260)\"><path id=\"SvgjsPath1101\" d=\"M 0 0L 347.75 0L 347.75 41L 0 41Z\" stroke=\"none\" fill-opacity=\"1\" fill=\"#e0e0e0\"></path><g id=\"SvgjsG1102\"><text id=\"SvgjsText1103\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"328px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"1.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1104\" dy=\"16\" x=\"174\"><tspan id=\"SvgjsTspan1105\" style=\"text-decoration:;\">www.sso.com/login?redirect=www.b.com/page-b</tspan></tspan><tspan id=\"SvgjsTspan1106\" dy=\"16\" x=\"174\"><tspan id=\"SvgjsTspan1107\" style=\"text-decoration:;\">Cookie: ssoid=1234</tspan></tspan></text></g></g><g id=\"SvgjsG1108\"><path id=\"SvgjsPath1109\" d=\"M699.9569302267545 251.98465175072067C 732 259 760 272 702.163639613562 294.2820406304279\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1110)\"></path></g><g id=\"SvgjsG1112\" transform=\"translate(714.5,256)\"><path id=\"SvgjsPath1113\" d=\"M 0 0L 127.5 0L 127.5 30L 0 30Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1114\"><text id=\"SvgjsText1115\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"128px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"4.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1116\" dy=\"16\" x=\"64\"><tspan id=\"SvgjsTspan1117\" style=\"text-decoration:;\">验证已经登录</tspan></tspan></text></g></g><g id=\"SvgjsG1118\"><path id=\"SvgjsPath1119\" d=\"M678 349L104.60000000000002 349\" stroke=\"#323232\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1120)\"></path></g><g id=\"SvgjsG1122\" transform=\"translate(311.5,319.5)\"><path id=\"SvgjsPath1123\" d=\"M 0 0L 119 0L 119 30L 0 30Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1124\"><text id=\"SvgjsText1125\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"119px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"4.375\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1126\" dy=\"16\" x=\"59.5\"><tspan id=\"SvgjsTspan1127\" style=\"text-decoration:;\">302 重定向</tspan></tspan></text></g></g><g id=\"SvgjsG1128\" transform=\"translate(254.375,354)\"><path id=\"SvgjsPath1129\" d=\"M 0 0L 249.5 0L 249.5 23L 0 23Z\" stroke=\"none\" fill-opacity=\"1\" fill=\"#e0e0e0\"></path><g id=\"SvgjsG1130\"><text id=\"SvgjsText1131\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"13px\" width=\"230px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"13px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"0.875\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1132\" dy=\"16\" x=\"125\"><tspan id=\"SvgjsTspan1133\" style=\"text-decoration:;\">www.b.com/page-b?ticket=T5678</tspan></tspan></text></g></g></svg>\n  <p style=\"text-align:center; color: #888;\">（SSO 机制实现流程 - 系统 B 身份验证）</p>\n</div>\n<p>这个时候，由于认证中心存在之前登录过的 Cookie，所以也不用再次输入账号密码，直接返回第 4 步，下发 ticket 给 <code>b.com</code> 即可。</p>\n<h3 id=\"sso-单点登录退出\"> SSO 单点登录退出</h3>\n<p>目前我们已经完成了单点登录，在同一套认证中心的管理下，多个产品可以共享登录态。现在我们需要考虑退出了，即：在一个产品中退出了登录，怎么让其他的产品也都退出登录？</p>\n<p>原理其实不难，可以回过头来看第 5 步，每一个产品在向认证中心验证 ticket 时，其实可以顺带将自己的退出登录 api 发送到认证中心。</p>\n<p>当某个产品 <code>c.com</code> 退出登录时：</p>\n<ol>\n<li>清空 <code>c.com</code> 中的登录态 Cookie。</li>\n<li>请求认证中心 <code>sso.com</code> 中的退出 api。</li>\n<li>认证中心遍历下发过 ticket 的所有产品，并调用对应的退出 api，完成退出。</li>\n</ol>\n<h2 id=\"oauth-第三方登录\"> OAuth 第三方登录</h2>\n<p>在上一种方案中，我们使用单点登录完成了多产品的登录态共享，但都是建立在一套统一的认证中心下，对于一些小型企业，未免太麻烦，有没有一种登录能够做到开箱即用？</p>\n<p>其实是有的，很多大厂都会提供自己的第三方登录服务，我们一起来分析一下。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/oauth.jpg\" alt=\"OAuth 第三方登录\" style=\"width: 460px;\">\n  <p style=\"text-align: center; color: #888;\">（OAuth 第三方登录）</p>\n</div>\n<h3 id=\"oauth-机制实现流程\"> OAuth 机制实现流程</h3>\n<p>这里以微信开放平台的接入流程为例：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/wx-oauth.png\" alt=\"微信开放平台的接入流程\">\n  <p style=\"text-align: center; color: #888;\">（微信开放平台的接入流程，图来源于网络）</p>\n</div>\n<ol>\n<li>首先，<code>a.com</code> 的运营者需要在微信开放平台注册账号，并向微信申请使用微信登录功能。</li>\n<li>申请成功后，得到申请的 appid、appsecret。</li>\n<li>用户在 <code>a.com</code> 上选择使用微信登录。</li>\n<li>这时会跳转微信的 OAuth 授权登录，并带上 <code>a.com</code> 的回调地址。</li>\n<li>用户输入微信账号和密码，登录成功后，需要选择具体的授权范围，如：授权用户的头像、昵称等。</li>\n<li>授权之后，微信会根据拉起 <code>a.com?code=123</code>，这时带上了一个临时票据 code。</li>\n<li>获取 code 之后，<code>a.com</code> 会拿着 code 、appid、appsecret，向微信服务器申请 token，验证成功后，微信会下发一个 token。</li>\n<li>有了 token 之后，<code>a.com</code> 就可以凭借 token 拿到对应的微信用户头像，用户昵称等信息了。</li>\n<li><code>a.com</code> 提示用户登录成功，并将登录状态写入 Cookie，以作为后续访问的凭证。</li>\n</ol>\n<h2 id=\"总结\"> 总结</h2>\n<p>本文介绍了 4 种常见的登录方式及其原理，总结一下这 4 种方案的使用场景：</p>\n<ul>\n<li>Cookie + Session 历史悠久，适合于简单的后端架构，需开发人员自己处理好安全问题。</li>\n<li>Token 方案对后端压力小，适合大型分布式的后端架构，但已分发出去的 token ，如果想收回权限，就不是很方便了。</li>\n<li>SSO 单点登录，适用于中大型企业，想要统一内部所有产品的登录方式。</li>\n<li>OAuth 第三方登录，简单易用，对用户和开发者都友好，但第三方平台很多，需要选择合适自己的第三方登录平台。</li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-03-17T10:04:03.000Z",
      "date_modified": "2022-03-17T10:04:03.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "文案指南",
      "url": "https://www.fedbook.cn/style-guide/product/",
      "id": "https://www.fedbook.cn/style-guide/product/",
      "content_html": "<h1 id=\"文案指南\"> 文案指南</h1>\n<p>文案不像机械生产加工，也不像计算机编程，它没有固定的标准，没有标准答案和通用模板。不过，每个领域总会有一些实用的技巧，文案也不例外。好的技巧能够让文案事半功倍，产生不错的效果。</p>\n<p>在这个系列，通过借鉴各知名公司产品的文案，汲取其精华，整理出适合在不同领域的文案规则，梳理出了一份写文案时可以随时查阅的参考指南。</p>\n<hr>\n<p>由于本人仅是开发，虽对一些产品有过观察和拆解，但并未经过专业的培训。所以这个系列的内容不是原创出来的，均是通过查阅、整合、提取的过程整理而成，<strong>仅供自用，不作为商业/官方参考标准</strong>。</p>\n<p>在平时开发中编写提示语和页面文字时：</p>\n<hr>\n<p>使用原则：</p>\n<ul>\n<li>如果公司有专业的产品经理和运营人员提供文案，则直接照抄他们给的即可。</li>\n<li>如果公司未设相关人员提供文案，则可以在查阅这份参考指南的同时，结合自己的理解使用。</li>\n</ul>\n<div style=\"text-align: right\">\n  <svg t=\"1638953945001\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"11630\" width=\"64\" height=\"64\"><path d=\"M0 0m93.090909 0l837.818182 0q93.090909 0 93.090909 93.090909l0 837.818182q0 93.090909-93.090909 93.090909l-837.818182 0q-93.090909 0-93.090909-93.090909l0-837.818182q0-93.090909 93.090909-93.090909Z\" fill=\"#4876F9\" p-id=\"11631\"></path><path d=\"M420.736 709.818182l90.705455-329.693091h1.675636L603.264 709.818182h50.653091L768 314.181818h-51.2l-87.377455 331.915637H627.2L537.041455 314.181818h-49.524364L396.8 646.097455h-2.222545L307.2 314.181818H256l114.082909 395.636364z\" fill=\"#FFFFFF\" p-id=\"11632\"></path></svg>\n</div>\n",
      "date_published": "2021-12-08T09:16:40.000Z",
      "date_modified": "2021-12-08T09:16:40.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "文档规范",
      "url": "https://www.fedbook.cn/style-guide/document/",
      "id": "https://www.fedbook.cn/style-guide/document/",
      "content_html": "<h1 id=\"文档规范\"> 文档规范</h1>\n<blockquote>\n<p>建议遵守行文规范，可以保证所有文章阅读体验的一致性，特别是复制到其他平台的样式一致性。</p>\n</blockquote>\n<p>本页介绍我遵循的写作规范和常用的文章结构，主要参考阮一峰老师的《<a href=\"https://github.com/ruanyf/document-style-guide\" title=\"中文技术文档的写作规范\" target=\"_blank\" rel=\"noopener noreferrer\">中文技术文档的写作规范</a>》和《<a href=\"https://juejin.im/book/6844723704639782920\" title=\"如何写一本掘金小册\" target=\"_blank\" rel=\"noopener noreferrer\">如何写一本掘金小册</a>》。</p>\n<p>下面列几点比较重要常见的要点。</p>\n<h2 id=\"文章的标题分级\"> 文章的标题分级</h2>\n<ul>\n<li>一级标题：文章的标题</li>\n<li>二级标题：文章主要内容的大标题</li>\n<li>三级标题：二级标题下面一级的小标题</li>\n<li>四级标题：三级标题下面某一方面的小标题（原则上不要写到四级标题）</li>\n</ul>\n<p>示例：</p>\n<div><pre><code># 文章标题\n\n## 1. 内容标题\n\n### 1.1 内容子标题\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>谨慎使用四级标题，尽量避免出现，保持层级的简单，防止出现过于复杂的章节。</p>\n<p>如果三级标题下有并列性的内容，建议只使用项目列表（Item list）。</p>\n<p>示例：下面的结构二要好于结构一。结构一适用的场景，主要是较长篇幅的内容。</p>\n<div><pre><code>结构一\n\n### 三级标题\n\n#### 四级标题 A\n\n#### 四级标题 B\n\n#### 四级标题 C\n\n结构二\n\n### 三级标题\n\n**（1）A**\n\n**（2）B**\n\n**（3）C**\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id=\"段落与段落之间留空行\"> 段落与段落之间留空行</h2>\n<p>标题和段落之间留空行。<br>\n段落与段落、图片与段落、图片与图片、代码块与段落，前后留空行。</p>\n<h2 id=\"段首不进行缩进\"> 段首不进行缩进</h2>\n<p>不对任何段落做段首的缩进。</p>\n<h2 id=\"换行的两种方式\"> 换行的两种方式</h2>\n<blockquote>\n<p>空格 + 空格 + 回车 VS 回车 + 回车</p>\n</blockquote>\n<p>行末加两个空格再回车是换行，对应着 <code>&lt;br&gt;</code>，类似于 Word 中的软回车（Shift + Enter），只作分行处理，前后仍属于同一个段落。</p>\n<p>两次回车是分段，对应着 <code>&lt;p&gt;</code>，类似于 Word 中的硬回车（Enter），表示一个段落到此结束。</p>\n<h2 id=\"中英文前后留出空格\"> 中英文前后留出空格</h2>\n<p>单词/数字和中文之间添加空格，示例：</p>\n<div><pre><code>本文主要介绍 React 和 Vue 的区别，大约有 1000 字。（注意空格）\n</code></pre>\n<div><span>1</span><br></div></div><p>注：当数字、英文是句子开头，它前面不需留空格，当数字、英文是句子末尾，它后面不需留空格。</p>\n<p>例外：「豆瓣FM」等产品名词，按照官方所定义的格式书写。</p>\n<p>关于文本留空格，更详细的标准参见《<a href=\"https://github.com/ruanyf/document-style-guide/blob/master/docs/text.md\" title=\"文本 - 字间距\" target=\"_blank\" rel=\"noopener noreferrer\">文本 - 字间距 by 阮一峰</a>》。</p>\n<h2 id=\"代码缩进\"> 代码缩进</h2>\n<p>代码缩进以 2 个空格为单位，首行不需要缩进。</p>\n<h2 id=\"图片居中对齐并加注释\"> 图片居中对齐并加注释</h2>\n<ul>\n<li>居中对齐</li>\n<li>如果是引用的图片，注明来源</li>\n<li>为图片添加注释，例如：</li>\n</ul>\n<p>示例：</p>\n<details><summary>使用相对路径插入图片</summary>\n<div><div><br><div>&nbsp;</div><br><br><br></div><pre><code>&lt;div style=&quot;text-align: center;&quot;&gt;\n  &lt;img src=&quot;./assets/demo-pic.png&quot; alt=&quot;demo-pic&quot;&gt;\n  &lt;p style=&quot;text-align: center; color: #888;&quot;&gt;（JavaScript 执行流程图）&lt;/p&gt;\n&lt;/div&gt;\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></details>\n<p>或</p>\n<details><summary>插入 svg 图片</summary>\n<div><div><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br></div><pre><code>&lt;div style=&quot;text-align: center;&quot;&gt;\n  &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; width=&quot;530&quot; height=&quot;274&quot; viewBox=&quot;0 0 530 274&quot;&gt;\n    &lt;image id=&quot;demo-pic&quot; data-name=&quot;demo-pic&quot; x=&quot;15&quot; y=&quot;8&quot; width=&quot;500&quot; height=&quot;259&quot; xlink:href=&quot;data:img/png;base64,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&quot;/&gt;\n  &lt;/svg&gt;\n  &lt;p style=&quot;text-align:center; color: #888;&quot;&gt;（JavaScript 执行流程图）&lt;/p&gt;\n&lt;/div&gt;\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></details>\n<p>或</p>\n<details><summary>使用基础路径插入图片</summary>\n<div><div><br><div>&nbsp;</div><br><br><br></div><pre><code>&lt;div style=&quot;text-align: center;&quot;&gt;\n  &lt;img :src=&quot;$withBase(&#39;/img/demo-pic.png&#39;)&quot; alt=&quot;demo-pic&quot;&gt;\n  &lt;p style=&quot;text-align: center; color: #888;&quot;&gt;（JavaScript 执行流程图）&lt;/p&gt;\n&lt;/div&gt;\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></details>\n<h2 id=\"标点符号\"> 标点符号</h2>\n<p>中文语句的标点符号，均应该采取全角符号，这样可以与全角文字保持视觉的一致。<br>\n如果整句为英文，则该句使用英文/半角标点。</p>\n<p><strong>省略号</strong></p>\n<p>省略号占两个汉字空间、包含六个省略点，不要使用<code>。。。。。。</code> 或 <code>...</code> 等非标准形式。中文省略号<code>……</code> 在中文输入法下，用 <code>shift + 6</code> 打出来，而三个点是英文中的省略号。</p>\n<p><strong>破折号</strong></p>\n<p>破折号应占两个汉字的位置，不能用连字符代替，即 <code>--</code>。如果破折号本身只占一个汉字的位置，那么前后应该留出一个半角空格。在中文输入法下，用 <code>shift + -</code> （键盘 0 右侧的键）打出来，即 <code>——</code>。</p>\n<p><strong>连接号</strong></p>\n<p>（1）数值范围（例如日期、时间或数字）应该使用波浪连接号（<code>～</code>），占一个全角字符的位置。</p>\n<div><pre><code>例句：2009 年～2011 年\n</code></pre>\n<div><span>1</span><br></div></div><p>注意，波浪连接号前后两个值都应该加上单位。</p>\n<p>（4）波浪连接号也可以用汉字“至”代替。</p>\n<div><pre><code>例句：周围温度：-20°C 至 -10°C\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>引号</strong></p>\n<p>（1）引用时，应该使用全角双引号（<code>“ ”</code>），且引号是成对出现的，上引号和下引号的外观不同。</p>\n<p>示例：</p>\n<div><pre><code>许多人都认为客户服务的核心是“友好”和“专业”。\n</code></pre>\n<div><span>1</span><br></div></div><p>（2）引号里面还要用引号时，外面一层用双引号，里面一层用单引号（<code>‘ ’</code>）。</p>\n<p>示例：</p>\n<div><pre><code>鲍勃解释道：“我要放音乐，可萨利说，‘不行！’。”\n</code></pre>\n<div><span>1</span><br></div></div><p>（3）简体中文也可以使用直角引号，看个人喜好，不强制。但一份文档内要始终保持一致。</p>\n<p>示例：</p>\n<div><pre><code>「老师，『有条不紊』的『紊』是什么意思？」\n\n“老师，‘有条不紊’的‘紊’是什么意思？”\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>关于标点符号的使用，更详细的标准参见《<a href=\"https://github.com/ruanyf/document-style-guide/blob/master/docs/marks.md\" title=\"标点符号\" target=\"_blank\" rel=\"noopener noreferrer\">标点符号 by 阮一峰</a>》。</p>\n<h2 id=\"不要加粗标点符号\"> 不要加粗标点符号</h2>\n<p>在被加粗的语句、短语前后，如果加粗句子最后有标点符号，不要对它加粗，句子中间的标点符号正常加粗。</p>\n<h2 id=\"字体大小与颜色\"> 字体大小与颜色</h2>\n<p>不要对任何文字，做字号调整和颜色调整，更不要把非标题字号扩大用作标题。</p>\n<h2 id=\"英文拼写要正确\"> 英文拼写要正确</h2>\n<p>英文的拼写，如 GraphQL 而不是 graphql，Node.js 而不是 nodejs，iPhone 而不是 iphone，Apple 而不是 apple，Java 而不是 java，Aliyun 而不是 aliyun，UED 而不是  ued，RDS MySQL 而不是 rds mysql，OSS 而不是 oss 等等。</p>\n<p>使用前，先网上查下正确使用。</p>\n<h2 id=\"文件名命名规范\"> 文件名命名规范</h2>\n<p>文件名建议只使用小写字母，不使用大写字母（为了醒目，某些说明文件的文件名，可以使用大写字母，比如README、LICENSE）。</p>\n<p>文件名包含多个单词时，单词之间建议使用半角的连词线（-）分隔。</p>\n<h2 id=\"javascript-语句基本规则\"> JavaScript 语句基本规则</h2>\n<p><strong>默认</strong>：</p>\n<ul>\n<li>语句后面要用分号（<code>;</code>）结束\n<ul>\n<li><code>function demo(){}</code> 函数后面可以不用加分号</li>\n<li><code>for(){}</code> 后面可以不用加分号</li>\n<li><code>if(){}</code> 后面可以不用加分号</li>\n</ul>\n</li>\n<li>书写格式要规范，<code>=、+、-、/</code> 两边应该有空格</li>\n<li>缩进使用两个空格</li>\n</ul>\n<p><strong>入乡随俗</strong>：</p>\n<p>使用框架时，语句结束是否加分号或缩进几个空格，按照框架的规则来（比如 Vue.js 工程里，不加分号）。</p>\n<h2 id=\"附-参考大纲结构\"> 附：参考大纲结构</h2>\n<div><pre><code># 文章名\n\n前言部分，几句话概括本文内容，也可以是介绍性的文字、图片、代码。\n\n## 1. 标题一\n\n### 1.1 子标题\n\n正文正文正文正文正文正文正文正文\n\n### 1.2 子标题\n\n正文正文正文正文正文正文正文正文\n\n**（1）A**\n\n**（2）B**\n\n**（3）C**\n\n## 2. 标题二\n\n正文正文正文正文正文正文正文正文\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>（完）</p>\n",
      "date_published": "2021-02-26T06:03:04.000Z",
      "date_modified": "2021-12-06T15:56:46.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "B 端产品文案指南",
      "url": "https://www.fedbook.cn/style-guide/product/tob/",
      "id": "https://www.fedbook.cn/style-guide/product/tob/",
      "content_html": "<h1 id=\"b-端产品文案指南\"> B 端产品文案指南</h1>\n<blockquote>\n<p>B 端文案不同于 C 端，面对的用户都是企业为主，语言风格上要正式官方，以帮助用户高效地使用产品、完成工作为核心目标，据此来组织内容和语言。</p>\n</blockquote>\n<h2 id=\"前言\"> 前言</h2>\n<ul>\n<li>本文<strong>主要面向 B 类业务、简体中文语境</strong>，提供实操性指南。</li>\n<li>行业内约定俗成的常用语请继续沿用，可以不依照这里的建议。</li>\n<li>本文所指的文案不包含营销推广类文案。</li>\n</ul>\n<h2 id=\"原则\"> 原则</h2>\n<h3 id=\"帮助用户高效操作\"> 帮助用户高效操作</h3>\n<ul>\n<li>站在产品官方的角度来传达信息，表达上要官方、正式。</li>\n<li>以帮助用户高效地使用产品、完成工作为核心目标，据此来组织内容和语言。</li>\n</ul>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/tob/1.png\" alt=\"帮助用户高效操作\" style=\"width: 680px;\">\n  <p style=\"text-align: center; color: #888;\">（帮助用户高效操作，图片来源于网络）</p>\n</div>\n<h3 id=\"一致性\"> 一致性</h3>\n<ul>\n<li>描述同一个事物和同样动作的词汇保持统一。</li>\n<li>上下文的语法、语种、语序保持统一。</li>\n<li>表述角色一致，不要在同一个句式中混用「你」和「我」。</li>\n</ul>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/tob/2.png\" alt=\"一致性\" style=\"width: 680px;\">\n  <p style=\"text-align: center; color: #888;\">（一致性，图片来源于网络）</p>\n</div>\n<p><strong>提示</strong>：本指南中无法涵盖在业务中可能遇到的全部场景/文案，可以通过一致性的原则选择扩充文案。</p>\n<p>例如在页面模板的列表中，点击后到详情内容的操作字段的选择上，因为目前已有的是「查看全部」、「加载更多」这些文案，所以选择使用「查看详情」这一同类短语。</p>\n<h3 id=\"内容完整、语言精简\"> 内容完整、语言精简</h3>\n<p>B 类产品通常有一定的学习成本，但阅读冗长的文案会消耗用户大量的精力，因此需要在保证内容完整性的同时，采用精练的语言。</p>\n<p>避免不够完整明确的表达。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/tob/3.png\" alt=\"避免不够完整明确的表达\" style=\"width: 680px;\">\n  <p style=\"text-align: center; color: #888;\">（避免不够完整明确的表达，图片来源于网络）</p>\n</div>\n<p>避免累赘的词句、意思重复的用词。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/tob/4.png\" alt=\"避免累赘的词句\" style=\"width: 680px;\">\n  <p style=\"text-align: center; color: #888;\">（避免累赘的词句，图片来源于网络）</p>\n</div>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/tob/5.png\" alt=\"避免意思重复的用词\" style=\"width: 680px;\">\n  <p style=\"text-align: center; color: #888;\">（避免意思重复的用词，图片来源于网络）</p>\n</div>\n<p>文字完整易读：完整词语在一行不拆分，账号，数字，标点符号不折行。</p>\n<p>目前行业内文字均是根据手机分辨率自动折行，有些机型会出现词被拆开，或是一个字或标点符号单独一行的问题。常见问题页面有三种类型：协议类、系统弹层、产品说明和活动说明页面。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/tob/6.png\" alt=\"通过手动换行确保词语不被拆开\" style=\"width: 680px;\">\n  <p style=\"text-align: center; color: #888;\">（通过手动换行确保词语不被拆开，图片来源于网络）</p>\n</div>\n<h3 id=\"用词专业、精准\"> 用词专业、精准</h3>\n<p>需要充分了解用户背景，采用专业度适当、精练准确的词语来高效地传达信息，提高用户理解的效率。</p>\n<ul>\n<li>避免对目标用户来说过于专业难懂的词语。</li>\n<li>避免使用错别字、口语、夸大的用词、含糊的比喻、网络流行语。</li>\n</ul>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/tob/7.png\" alt=\"用词专业、精准\" style=\"width: 680px;\">\n  <p style=\"text-align: center; color: #888;\">（用词专业、精准，图片来源于网络）</p>\n</div>\n<h3 id=\"语气友好、正面\"> 语气友好、正面</h3>\n<p>B 类产品需要表现「有温度」的专业形象，而不是浮躁、冰冷、苛刻的态度。</p>\n<p>避免使用过于极端、绝对、夸张的表述。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/tob/8.png\" alt=\"避免使用过于夸张的表述\" style=\"width: 680px;\">\n  <p style=\"text-align: center; color: #888;\">（避免使用过于夸张的表述，图片来源于网络）</p>\n</div>\n<p>避免强迫用户、责怪用户的语气。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/tob/9.png\" alt=\"避免强迫用户的语气\" style=\"width: 680px;\">\n  <p style=\"text-align: center; color: #888;\">（避免强迫用户的语气，图片来源于网络）</p>\n</div>\n<p>避免否定视角、采用积极的表达方式。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/tob/10.png\" alt=\"避免否定视角\" style=\"width: 680px;\">\n  <p style=\"text-align: center; color: #888;\">（避免否定视角，图片来源于网络）</p>\n</div>\n<h2 id=\"词表\"> 词表</h2>\n<p>说明：这里列举了通用的，且需要与类似词语有所区分的容易写错/混淆的词汇和短语。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/tob/11.png\" alt=\"常用词表\">\n  <p style=\"text-align: center; color: #888;\">（常用词表，图片来源于网络）</p>\n</div>\n<h2 id=\"格式\"> 格式</h2>\n<h3 id=\"段落\"> 段落</h3>\n<p>首行不空格，段与段之间空一行。</p>\n<h3 id=\"空格\"> 空格</h3>\n<ul>\n<li>英文与非标点的中文之间需要有一个空格。</li>\n<li>数字与非标点的中文之间需要有一个空格。</li>\n<li>数字与单位之间需要有一个空格。</li>\n<li>中文标点与其他字符间不加空格。</li>\n<li>百分比数字与百分号之间不加空格（如「56%」）。</li>\n</ul>\n<h3 id=\"标点\"> 标点</h3>\n<ul>\n<li>只有中文或中英文混排中，使用中文全角标点；</li>\n<li>中英文混排中如果出现整句英文，则在这句英文中使用英文/半角标点；</li>\n<li>具体使用请参考 1995 年中国标准出版社出版的《标点符号用法》。</li>\n</ul>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/tob/12.png\" alt=\"标点符号用法部分内容\">\n  <p style=\"text-align: center; color: #888;\">（标点符号用法部分内容，图片来源于网络）</p>\n</div>\n<h2 id=\"文案类型\"> 文案类型</h2>\n<p>为便于查阅和参考，这里按常用的具体场景，阐述统一的原则在场景中的应用和正反案例。使用中请举一反三。</p>\n<h3 id=\"系统通知\"> 系统通知</h3>\n<p>系统通知是各类产品的基础功能，目的是从产品的角度向用户传达信息并进行必要的处理。</p>\n<p>阐述角度：以产品的视角陈述，精准、实时地告知用户客观信息，让用户及时了解情况。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/tob/13.png\" alt=\"以产品的视角陈述\" style=\"width: 680px;\">\n  <p style=\"text-align: center; color: #888;\">（以产品的视角陈述，图片来源于网络）</p>\n</div>\n<p>通用句式：「情况陈述 + 相关操作（可选）」。</p>\n<p>如果需要用户针对通知的信息尽快进行某些操作，需要提供相关引导。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/tob/14.png\" alt=\"必要时提供相关引导\" style=\"width: 680px;\">\n  <p style=\"text-align: center; color: #888;\">（必要时提供相关引导，图片来源于网络）</p>\n</div>\n<p>主动语态：使用简洁流畅的主动语态，少用被动语态。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/tob/15.png\" alt=\"使用主动语态\" style=\"width: 680px;\">\n  <p style=\"text-align: center; color: #888;\">（使用主动语态，图片来源于网络）</p>\n</div>\n<h3 id=\"帮助-提示\"> 帮助/提示</h3>\n<p>帮助/提示指的是内嵌在产品界面的信息，用来帮助用户理解产品、消除疑虑、合理操作。</p>\n<p>这里的帮助不同于帮助中心或帮助文档，后者通常是通过单独的网站或一系列网页，系统地阐述产品功能、定价、操作步骤、常见问题等，帮助用户购买和操作的内容。</p>\n<p>阐述角度：让用户高效地理解当前的情况、了解产品功能、完成当下的任务。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/tob/16.png\" alt=\"让用户高效地理解\" style=\"width: 680px;\">\n  <p style=\"text-align: center; color: #888;\">（让用户高效地理解，图片来源于网络）</p>\n</div>\n<p>逐条表述：当内容较多时，建议按内容逻辑分段分条目来陈述，建议一组不超过 5 条，每条不超过 3 行。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/tob/17.png\" alt=\"分段分条目\" style=\"width: 680px;\">\n  <p style=\"text-align: center; color: #888;\">（分段分条目，图片来源于网络）</p>\n</div>\n<h3 id=\"操作引导\"> 操作引导</h3>\n<p>操作引导用于指导和推动用户执行某些操作，常用于新手用户的初始化、空状态、新功能引导等场景。</p>\n<ul>\n<li>阐述角度：从用户角度出发，关注点是用户能用产品做什么、收获什么，从而引导用户进行相应操作。</li>\n<li>通用句式：「目的或重要性（可选）+ 具体操作」。</li>\n</ul>\n<p>当我们希望用户执行一个动作时，要专注于用户能得到什么以及用户的感受，因此在操作前告知用户其目的或重要性，能促进用户更愿意去做。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/tob/18.png\" alt=\"告知用户目的或重要性\" style=\"width: 680px;\">\n  <p style=\"text-align: center; color: #888;\">（告知用户目的或重要性，图片来源于网络）</p>\n</div>\n<p>动词开头：使用动词开头的祈使句或动宾短语。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/tob/19.png\" alt=\"使用动词祈使句或动宾短语\" style=\"width: 680px;\">\n  <p style=\"text-align: center; color: #888;\">（使用动词祈使句或动宾短语，图片来源于网络）</p>\n</div>\n<p>避免方向性词语：明确指出具体的功能/组件，而不是表意不够精准的方向性词语，如错误案例「在屏幕顶部」。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/tob/20.png\" alt=\"避免不明确的方向性词语\" style=\"width: 680px;\">\n  <p style=\"text-align: center; color: #888;\">（避免不明确的方向性词语，图片来源于网络）</p>\n</div>\n<ul>\n<li>控制步骤数：分步引导控制在 3~5 步，移动端每屏每次展示 1 步；根据实际的用户需要，如果内容比较复杂，建议使用视频、帮助文档等其他模式。</li>\n<li>控制字数：每条引导的字数不宜过多，否则会让产品看起来比实际上更难操作，建议不超出 3 行。</li>\n</ul>\n<h3 id=\"操作反馈\"> 操作反馈</h3>\n<p>操作反馈是指产品对用户的行为作出的即时响应。</p>\n<p>阐述角度：对于完成的操作，即时性地告知用户结果；对于有风险的操作，先告知用户风险，再请用户确认。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/tob/21.png\" alt=\"即时告知用户结果\" style=\"width: 680px;\">\n  <p style=\"text-align: center; color: #888;\">（即时告知用户结果，图片来源于网络）</p>\n</div>\n<p>二次确认句式：对于风险较大的操作，需要用户进行二次确认，句式为「操作风险 + 给出建议（可选）+ 是否执行」。</p>\n<p>建议对应的按钮使用具体动词或词组，而不是直接使用通用的「确定」、「OK」、「是」。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/tob/22.png\" alt=\"按钮使用具体动词或词组\" style=\"width: 680px;\">\n  <p style=\"text-align: center; color: #888;\">（按钮使用具体动词或词组，图片来源于网络）</p>\n</div>\n<p>用词精准：虽然「友好、正面」是原则之一，但用作提醒、警示的反馈中，要将问题直接通知用户，无需刻意隐晦。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/tob/23.png\" alt=\"提醒、警示的用词无需刻意隐晦\" style=\"width: 680px;\">\n  <p style=\"text-align: center; color: #888;\">（提醒、警示的用词无需刻意隐晦，图片来源于网络）</p>\n</div>\n<h3 id=\"报错信息\"> 报错信息</h3>\n<p>报错信息与操作反馈、系统通知有交集，是在用户行为、系统运行、网络问题等因素引发问题后，通知用户并指导如何处理。</p>\n<p>阐述角度：引起用户关注，让其快速了解出错情况，并专注于解决问题。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/tob/24.png\" alt=\"引起用户关注\" style=\"width: 680px;\">\n  <p style=\"text-align: center; color: #888;\">（引起用户关注，图片来源于网络）</p>\n</div>\n<p>通用句式：「表达歉意（产品/系统原因时）+ 问题阐述 + 操作指导（推荐提供）」。</p>\n<p>如果具体的出错原因对于目标用户容易理解、对接下来的操作有帮助，则明确告知用户，反之则概括性说明出错原因即可。</p>\n<p>面向商家的后台产品：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/tob/25.png\" alt=\"面向商家的后台产品\" style=\"width: 680px;\">\n  <p style=\"text-align: center; color: #888;\">（面向商家的后台产品，图片来源于网络）</p>\n</div>\n<p>面向开发者的工具产品：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/tob/26.png\" alt=\"面向开发者的工具产品\" style=\"width: 680px;\">\n  <p style=\"text-align: center; color: #888;\">（面向开发者的工具产品，图片来源于网络）</p>\n</div>\n<p>态度友好：当出错的时候，尤其需要多给用户支持与鼓励，不要责怪用户。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/tob/27.png\" alt=\"态度友好\" style=\"width: 680px;\">\n  <p style=\"text-align: center; color: #888;\">（态度友好，图片来源于网络）</p>\n</div>\n<h2 id=\"场景指南\"> 场景指南</h2>\n<p>前面介绍的是文案「怎么说」，这里根据 B 类产品中的主要操作场景，来简要介绍「说什么」，即文案较复杂时如何对多种类型进行组合。</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/tob/28.png\" alt=\"主要操作场景的文案公式\">\n  <p style=\"text-align: center; color: #888;\">（主要操作场景的文案公式，图片来源于网络）</p>\n</div>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://ant.design/docs/spec/copywriting-cn\" target=\"_blank\" rel=\"noopener noreferrer\">Ant Design 文案</a>（还有英文版的）</li>\n<li><a href=\"https://design.teambition.com/doc/copywriting\" target=\"_blank\" rel=\"noopener noreferrer\">Clarity Design 文案</a></li>\n<li><a href=\"https://open.avoscloud.com/copywriting-style-guide/\" target=\"_blank\" rel=\"noopener noreferrer\">LeanCloud 开放资源</a></li>\n<li><a href=\"https://contentdesign.intuit.com/content-patterns/\" target=\"_blank\" rel=\"noopener noreferrer\">Content patterns</a>（英文文案）</li>\n</ul>\n",
      "date_published": "2021-12-08T09:58:03.000Z",
      "date_modified": "2021-12-09T08:46:13.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "代码风格",
      "url": "https://www.fedbook.cn/style-guide/program/",
      "id": "https://www.fedbook.cn/style-guide/program/",
      "content_html": "<h1 id=\"代码风格\"> 代码风格</h1>\n<p>团队关于代码风格必须遵循两个基本原则：少数服从多数、用工具统一风格。</p>\n<hr>\n<p>Tips：</p>\n<ul>\n<li>在一个项目中，永远遵循同一套编码规范。</li>\n<li>这里整理的代码风格我在个人项目中遵循的，具体需要根据所在团队和项目的变化而调整。</li>\n<li>参与和维护其他人的项目时，秉承入乡随俗的原则，尊重别人代码的风格习惯。</li>\n</ul>\n<hr>\n<p><strong>与其自己建立编码规范，更推荐选择社区沉淀下来的规范</strong>。因此，在制定代码风格指南时，主要借鉴了一些大厂和开源组织的前端代码规范：</p>\n<ul>\n<li><a href=\"https://tgideas.qq.com/doc/index.html\" title=\"TGideas 文档库\" target=\"_blank\" rel=\"noopener noreferrer\">腾讯</a></li>\n<li><a href=\"https://guide.aotu.io/index.html\" title=\"凹凸实验室\" target=\"_blank\" rel=\"noopener noreferrer\">京东</a>（比较齐全）</li>\n<li><a href=\"https://github.com/ecomfe/spec\" title=\"spec\" target=\"_blank\" rel=\"noopener noreferrer\">百度</a></li>\n<li><a href=\"http://nec.netease.com/standard\" title=\"NEC\" target=\"_blank\" rel=\"noopener noreferrer\">网易</a></li>\n<li><a href=\"https://github.com/airbnb/javascript\" title=\"Airbnb\" target=\"_blank\" rel=\"noopener noreferrer\">Airbnb</a></li>\n<li><a href=\"https://github.com/standard/standard\" title=\"JavaScript Standard Style\" target=\"_blank\" rel=\"noopener noreferrer\">JavaScript Standard Style</a></li>\n<li><a href=\"https://cn.vuejs.org/v2/style-guide/\" title=\"Vue.js 风格指南\" target=\"_blank\" rel=\"noopener noreferrer\">Vue.js 官网的风格指南</a></li>\n<li><a href=\"https://codeguide.bootcss.com/\" title=\"Bootstrap 编码规范\" target=\"_blank\" rel=\"noopener noreferrer\">Bootstrap 编码规范</a></li>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/style\" title=\"Prettier\" target=\"_blank\" rel=\"noopener noreferrer\">ES6 编程风格</a></li>\n</ul>\n<hr>\n<p>用工具统一风格是一个很好的选择：</p>\n<ul>\n<li><a href=\"https://cn.eslint.org/\" title=\"ESLint 中文网\" target=\"_blank\" rel=\"noopener noreferrer\">ESLint</a></li>\n<li><a href=\"https://prettier.io/\" title=\"Prettier\" target=\"_blank\" rel=\"noopener noreferrer\">Prettier</a></li>\n</ul>\n<p>ESLint 和 Prettier 区别：</p>\n<ul>\n<li>ESLint（包括其他一些 Lint 工具）主要解决的是<strong>代码质量问题</strong>。</li>\n<li>Prettier 主要解决的是<strong>代码风格问题</strong>。</li>\n</ul>\n<p>代码质量出问题意味着程序有潜在 Bug（未使用变量、三等号、全局变量声明等），而风格问题充其量也只是看着不爽（单行代码长度、tab 长度、空格、逗号表达式等）。</p>\n<p>一般可以使用 Prettier + ESLint 来同时解决两个问题，但需要通过 <code>eslint-config-prettier</code> 插件来解决两个规则同时使用时的冲突问题。</p>\n<div style=\"text-align: right\">\n  <svg t=\"1607526012170\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"10484\" width=\"64\" height=\"64\"><path d=\"M737.6 356.608a8.96 8.96 0 0 1 12.096-1.472l235.712 175.36a18.688 18.688 0 0 1 2.88 2.688v0.064a15.808 15.808 0 0 1-2.88 23.04l-235.712 175.36c0 2.56-1.28 4.928-3.328 6.464a8.96 8.96 0 0 1-12.096-1.472 7.936 7.936 0 0 1 1.536-11.456v-83.2c0-2.56 1.28-4.928 3.328-6.464l123.776-92.16-123.776-92.096a7.808 7.808 0 0 1-3.328-6.4V361.6c0-1.792 0.64-3.584 1.792-4.992z m-458.112-3.2c4.736-0.064 8.64 3.584 8.64 8.128v83.2c0 2.56-1.28 4.864-3.328 6.4L161.024 543.36l123.776 92.16c2.112 1.472 3.328 3.84 3.328 6.272v83.328c0 1.792-0.64 3.584-1.792 4.992a8.96 8.96 0 0 1-12.096 1.472L38.528 556.16a15.872 15.872 0 0 1 0-25.792l235.712-175.296a8.704 8.704 0 0 1 5.248-1.728z\" fill=\"#101A33\" p-id=\"10485\"></path><path d=\"M672.576 192H599.936a8.704 8.704 0 0 0-8.192 5.44v0.064L342.72 885.184a8.128 8.128 0 0 0 5.312 10.368c0.96 0.32 1.92 0.448 2.88 0.448h72.96a8.704 8.704 0 0 0 8.192-5.44v-0.064l0.768-2.176 248.064-685.44a8.192 8.192 0 0 0-5.504-10.432A9.28 9.28 0 0 0 672.64 192z\" fill=\"#107CEE\" p-id=\"10486\"></path></svg>\n</div>\n",
      "date_published": "2021-02-26T06:03:04.000Z",
      "date_modified": "2022-02-11T09:16:08.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Code Review",
      "url": "https://www.fedbook.cn/style-guide/program/code-review/",
      "id": "https://www.fedbook.cn/style-guide/program/code-review/",
      "content_html": "<h1 id=\"code-review\"> Code Review</h1>\n<h2 id=\"目的\"> 目的</h2>\n<ul>\n<li>保证团队编码风格一致\n<ul>\n<li>自己的代码要给别人看，开发过程中需要潜意识的注意代码规，以及逻辑严谨性。</li>\n</ul>\n</li>\n<li>保证项目质量，扼杀潜在风险\n<ul>\n<li>虽然功能完成后自己会自测，但难免会遗漏掉一些边界点，或者受思维限制的一些点。</li>\n</ul>\n</li>\n<li>相互提升\n<ul>\n<li>多学习别人代码，看高手是如何写出严谨、简洁、优美的代码，和自己做对照，取齐精髓，去其糟粕！</li>\n</ul>\n</li>\n<li>便捷交叉维护\n<ul>\n<li>通过交叉 Code Review 过程，了解不同业务，方便后期交叉维护，无需花更多时间上手。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"如何开展\"> 如何开展</h2>\n<ul>\n<li>结对\n<ul>\n<li>至少两人为一小组</li>\n</ul>\n</li>\n<li>集体\n<ul>\n<li>每周周会集体 review 代码，每次 review 核心代码，预期每周集体 review 三位同学代码</li>\n<li>各自讲解自己的模块，复杂业务最好有流程图</li>\n</ul>\n</li>\n<li>git hooks – pre commit\n<ul>\n<li>新项目统一使用 ESLint 作为代码规范检测工具，每次 <code>git commit</code> 会判断代码是否符合规范，只有符合规范的才能被提交</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"自测-check-list\"> 自测 check list</h2>\n<p>功能完成之后要进行自测，具体可以从以下方面切入：</p>\n<table>\n  <tr>\n    <th colspan=\"2\">自查细则</th>\n    <th style=\"width: 64px;\">是否通过</th>\n    <th style=\"width: 120px;\">未通过原因/现象</th>\n  </tr>\n  <tr>\n    <td rowspan=\"10\" style=\"width: 64px;\">常规检查</td>\n    <td>代码是否能正常运行？</td>\n    <td></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td>控制台是否有明显的报错？</td>\n    <td></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td>代码有没有达到预期需求效果？</td>\n    <td></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td>代码逻辑是否简单易懂？</td>\n    <td></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td>代码书写是否符合规范？</td>\n    <td></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td>是否尽可能组件化了？</td>\n    <td></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td>有没有重复造轮子？</td>\n    <td></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td>去掉大段被注释的代码？<br>（如果注释代码是可用的，那就先提交未删除注释的代码到 Git 上，然后再提交删除了注释的代码，以后能回滚就可以）</td>\n    <td></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td>按钮是否控制了单次点击？</td>\n    <td></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td>定时器是否随生命周期消除？</td>\n    <td></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td rowspan=\"3\">安全检查</td>\n    <td>引入他人（公司内部或者其他外部机构）依赖包，是否存在不可用和版本升级导致功能不可用的风险？</td>\n    <td></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td>所有请求是否都使用了 https，包括图片链接，对 App 应用嵌入的页面，是否提供了 https 协议链接？</td>\n    <td></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td>代码注释或者文案中是否包含了敏感词汇？</td>\n    <td></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td rowspan=\"3\">文档检查</td>\n    <td>是否有符合规范的注释？注释是否描述准确？对方法参数或者名词是否进行了解释？</td>\n    <td></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td>第三方库使用是否有完善文档？</td>\n    <td></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td>Readme 文档是否书写规范？是否对项目有准确描述？</td>\n    <td></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td rowspan=\"5\">性能检查</td>\n    <td>页面加载是否超过了 3s？超过 3s 的原因是什么？有没有友好的提示？</td>\n    <td></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td>代码有没有明显影响性能的逻辑和计算？</td>\n    <td></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td>组件层级是否可控？</td>\n    <td></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td>组件通信是否正常？</td>\n    <td></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td>页面嵌套是否简单？</td>\n    <td></td>\n    <td></td>\n  </tr>\n</table>\n<h2 id=\"评分标准\"> 评分标准</h2>\n<p>总分 30 分，24 分以上是允许被 <code>merge</code> 到 master 的代码，低于 24 分需要进行优化。</p>\n<ul>\n<li>需求\n<ul>\n<li>9-10 分：项目结构清晰，组件合理，代码逻辑严谨，功能无遗漏</li>\n<li>6-8 分：无逻辑错误，功能无遗漏</li>\n<li>0-5 分：代码逻辑错误，功能遗漏</li>\n</ul>\n</li>\n<li>代码\n<ul>\n<li>9-10 分：代码简洁，合理注释，模块独立</li>\n<li>6-8 分：模块中度耦合，代码相对简洁</li>\n<li>0-5 分：模块耦合度较高，代码注释不清晰，代码书写复杂，命名不规范</li>\n</ul>\n</li>\n<li>可读性\n<ul>\n<li>9-10 分：严格的代码规范，代码逻辑易理解，注释清晰</li>\n<li>6-8 分：存在阅读障碍的逻辑代码，注释模糊</li>\n<li>0-5 分：逻辑代码混乱复杂，理解起来极其空难</li>\n</ul>\n</li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-02-11T09:16:08.000Z",
      "date_modified": "2022-02-11T09:16:08.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "HTML 规范",
      "url": "https://www.fedbook.cn/style-guide/program/html-spec/",
      "id": "https://www.fedbook.cn/style-guide/program/html-spec/",
      "content_html": "<h1 id=\"html-规范\"> HTML 规范</h1>\n<h2 id=\"文件模板\"> 文件模板</h2>\n<p>HTML5 文件模板：</p>\n<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>\n  <span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>\"</span>zh-CN<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>head</span><span>></span></span>\n    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>\"</span>UTF-8<span>\"</span></span><span>></span></span>\n    <span><span><span>&lt;</span>title</span><span>></span></span>HTML5 标准模版<span><span><span>&lt;/</span>title</span><span>></span></span>\n  <span><span><span>&lt;/</span>head</span><span>></span></span>\n  <span><span><span>&lt;</span>body</span><span>></span></span>\n  <span><span><span>&lt;/</span>body</span><span>></span></span>\n<span><span><span>&lt;/</span>html</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>移动端：</p>\n<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>\n<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>\"</span>zh-CN<span>\"</span></span><span>></span></span>\n<span><span><span>&lt;</span>head</span><span>></span></span>\n  <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>\"</span>UTF-8<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>\"</span>viewport<span>\"</span></span> \n        <span>content</span><span><span>=</span><span>\"</span>width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>\"</span>format-detection<span>\"</span></span> <span>content</span><span><span>=</span><span>\"</span>telephone=no<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>title</span><span>></span></span>移动端 HTML 模版<span><span><span>&lt;/</span>title</span><span>></span></span>\n\n  <span>&lt;!-- S DNS预解析 --></span>\n  <span><span><span>&lt;</span>link</span> <span>rel</span><span><span>=</span><span>\"</span>dns-prefetch<span>\"</span></span> <span>href</span><span><span>=</span><span>\"</span><span>\"</span></span><span>></span></span>\n  <span>&lt;!-- E DNS预解析 --></span>\n\n  <span>&lt;!-- S 线上样式页面片，开发请直接取消注释引用 --></span>\n  <span>&lt;!-- #include virtual=\"\" --></span>\n  <span>&lt;!-- E 线上样式页面片 --></span>\n\n  <span>&lt;!-- S 本地调试，根据开发模式选择调试方式，请开发删除 --></span>\n  <span><span><span>&lt;</span>link</span> <span>rel</span><span><span>=</span><span>\"</span>stylesheet<span>\"</span></span> <span>href</span><span><span>=</span><span>\"</span>css/index.css<span>\"</span></span><span>></span></span>\n  <span>&lt;!-- /本地调试方式 --></span>\n\n  <span><span><span>&lt;</span>link</span> <span>rel</span><span><span>=</span><span>\"</span>stylesheet<span>\"</span></span> <span>href</span><span><span>=</span><span>\"</span>http://srcPath/index.css<span>\"</span></span><span>></span></span>\n  <span>&lt;!-- /开发机调试方式 --></span>\n  <span>&lt;!-- E 本地调试 --></span>\n\n<span><span><span>&lt;/</span>head</span><span>></span></span>\n<span><span><span>&lt;</span>body</span><span>></span></span>\n<span><span><span>&lt;/</span>body</span><span>></span></span>\n<span><span><span>&lt;/</span>html</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h2 id=\"属性顺序\"> 属性顺序</h2>\n<p>HTML 属性应当按照以下给出的顺序依次排列，确保代码的易读性。</p>\n<ul>\n<li><code>class</code></li>\n<li><code>id</code>，<code>name</code></li>\n<li><code>data-*</code></li>\n<li><code>src</code>，<code>for</code>，<code>type</code>，<code>href</code>，<code>value</code></li>\n<li><code>title</code>，<code>alt</code></li>\n<li><code>role</code>，<code>aria-*</code></li>\n</ul>\n<p>class 用于标识高度可复用组件，因此应该排在首位。</p>\n<p>id 用于标识具体组件，应当谨慎使用（例如，页面内的书签），因此排在第二位。</p>\n<h2 id=\"class-命名\"> class 命名</h2>\n<ul>\n<li><code>class</code> 必须单词全字母小写，单词间以 <code>-</code> 分隔。</li>\n<li><code>class</code> 必须代表相应模块或部件的内容或功能，不得以样式信息进行命名。</li>\n<li>避免过度任意的简写。<code>.btn</code> 代表 <code>button</code>，但是 <code>.s</code> 不能表达任何意思。</li>\n<li>基于最近的父 class 或基本（base） class 作为新 class 的前缀。</li>\n</ul>\n<h2 id=\"id-命名\"> id 命名</h2>\n<ul>\n<li>元素 <code>id</code> 必须保证页面唯一。</li>\n<li><code>id</code> 建议单词全字母小写，单词间以 <code>-</code> 分隔。同项目必须保持风格一致。</li>\n<li><code>id</code>、<code>class</code> 命名，在避免冲突并描述清楚的前提下尽可能短。</li>\n</ul>\n<h2 id=\"name-命名\"> name 命名</h2>\n<ul>\n<li>同一页面，应避免使用相同的 <code>name</code> 与 <code>id</code>。</li>\n<li><code>name</code> 一般与后端 model 中的字段名命名规则保持一致。\n<ul>\n<li>例如 Java 使用小驼峰命名法（camelCase），Python使用下划线 <code>_</code> 连接两个小写单词。</li>\n</ul>\n</li>\n</ul>\n<p>解释：</p>\n<p>IE 浏览器会混淆元素的 <code>id</code> 和 <code>name</code> 属性， <code>document.getElementById</code> 可能获得不期望的元素。所以在对元素的 <code>id</code> 与 <code>name</code> 属性的命名需要非常小心。</p>\n<p>一个比较好的实践是，为 <code>id</code> 和 <code>name</code> 使用不同的命名法。</p>\n<h2 id=\"标签类型属性\"> 标签类型属性</h2>\n<p>不需要为 CSS、JS 指定类型属性，HTML5 中默认已包含。</p>\n<p>推荐：</p>\n<div><pre><code><span><span><span>&lt;</span>link</span> <span>rel</span><span><span>=</span><span>\"</span>stylesheet<span>\"</span></span> <span>href</span><span><span>=</span><span>\"</span><span>\"</span></span> <span>></span></span>\n<span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>\"</span><span>\"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>不推荐：</p>\n<div><pre><code><span><span><span>&lt;</span>link</span> <span>rel</span><span><span>=</span><span>\"</span>stylesheet<span>\"</span></span> <span>type</span><span><span>=</span><span>\"</span>text/css<span>\"</span></span> <span>href</span><span><span>=</span><span>\"</span><span>\"</span></span> <span>></span></span>\n<span><span><span>&lt;</span>script</span> <span>type</span><span><span>=</span><span>\"</span>text/javascript<span>\"</span></span> <span>src</span><span><span>=</span><span>\"</span><span>\"</span></span> <span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"代码嵌套\"> 代码嵌套</h2>\n<ul>\n<li>元素嵌套规范，每个块状元素独立一行，内联元素可选。</li>\n</ul>\n<p>推荐：</p>\n<div><pre><code><span><span><span>&lt;</span>div</span><span>></span></span>\n  <span><span><span>&lt;</span>h1</span><span>></span></span><span><span><span>&lt;/</span>h1</span><span>></span></span>\n  <span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;/</span>p</span><span>></span></span>\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;</span>span</span><span>></span></span><span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;</span>span</span><span>></span></span><span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;/</span>p</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>不推荐：</p>\n<div><pre><code><span><span><span>&lt;</span>div</span><span>></span></span>\n  <span><span><span>&lt;</span>h1</span><span>></span></span><span><span><span>&lt;/</span>h1</span><span>></span></span><span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;/</span>p</span><span>></span></span>\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;</span>p</span><span>></span></span> \n  <span><span><span>&lt;</span>span</span><span>></span></span><span><span><span>&lt;/</span>span</span><span>></span></span>\n  <span><span><span>&lt;</span>span</span><span>></span></span><span><span><span>&lt;/</span>span</span><span>></span></span>\n<span><span><span>&lt;/</span>p</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>\n<li>段落元素与标题元素只能嵌套内联元素。</li>\n</ul>\n<p>推荐：</p>\n<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span><span><span><span>&lt;</span>span</span><span>></span></span><span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;/</span>h1</span><span>></span></span>\n<span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;</span>span</span><span>></span></span><span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;</span>span</span><span>></span></span><span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;/</span>p</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>不推荐：</p>\n<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span><span><span><span>&lt;</span>div</span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span><span><span><span>&lt;/</span>h1</span><span>></span></span>\n<span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;</span>div</span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span><span><span><span>&lt;</span>div</span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span><span><span><span>&lt;/</span>p</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"注释规范\"> 注释规范</h2>\n<h3 id=\"单行注释\"> 单行注释</h3>\n<p>一般用于简单的描述，如某些状态描述、属性描述等。</p>\n<p>注释内容前后各一个空格字符，注释位于要注释代码的上面，单独占一行。</p>\n<p>推荐：</p>\n<div><pre><code><span>&lt;!-- Comment Text --></span>\n<span><span><span>&lt;</span>div</span><span>></span></span>...<span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>不推荐：</p>\n<div><pre><code><span><span><span>&lt;</span>div</span><span>></span></span>...<span><span><span>&lt;/</span>div</span><span>></span></span><span>&lt;!-- Comment Text --></span>\n\n<span><span><span>&lt;</span>div</span><span>></span></span><span>&lt;!-- Comment Text --></span>\n  ...\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"模块注释\"> 模块注释</h3>\n<p>一般用于描述模块的名称以及模块开始与结束的位置。</p>\n<p>注释内容前后各一个空格字符，<code>&lt;!-- S Comment Text --&gt;</code> 表示模块开始，<code>&lt;!-- E Comment Text --&gt;</code> 表示模块结束，模块与模块之间相隔一行。</p>\n<p>推荐：</p>\n<div><pre><code><span>&lt;!-- S Comment Text A --></span>\n<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>mod-a<span>\"</span></span><span>></span></span>\n  ...\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n<span>&lt;!-- E Comment Text A --></span>\n\n<span>&lt;!-- S Comment Text B --></span>\n<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>mod-b<span>\"</span></span><span>></span></span>\n  ...\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n<span>&lt;!-- E Comment Text B --></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>不推荐：</p>\n<div><pre><code><span>&lt;!-- S Comment Text A --></span>\n<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>mod_a<span>\"</span></span><span>></span></span>\n  ...\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n<span>&lt;!-- E Comment Text A --></span>\n<span>&lt;!-- S Comment Text B --></span>\n<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>mod_b<span>\"</span></span><span>></span></span>\n  ...\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n<span>&lt;!-- E Comment Text B --></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"嵌套模块注释\"> 嵌套模块注释</h3>\n<p>当模块注释内再出现模块注释的时候，为了突出主要模块，嵌套模块改用 <code>&lt;!-- /Comment Text --&gt;</code>。</p>\n<p>注释写在模块结尾标签底部，单独一行。</p>\n<div><pre><code><span>&lt;!-- S Comment Text A --></span>\n<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>mod-a<span>\"</span></span><span>></span></span>\n\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>mod-b<span>\"</span></span><span>></span></span>\n    ...\n  <span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span>&lt;!-- /mod-b --></span>\n\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>mod-c<span>\"</span></span><span>></span></span>\n    ...\n  <span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span>&lt;!-- /mod-c --></span>\n\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n<span>&lt;!-- E Comment Text A --></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>（完）</p>\n",
      "date_published": "2021-02-26T06:03:04.000Z",
      "date_modified": "2021-12-03T07:01:56.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "JavaScript 规范",
      "url": "https://www.fedbook.cn/style-guide/program/javascript-spec/",
      "id": "https://www.fedbook.cn/style-guide/program/javascript-spec/",
      "content_html": "<h1 id=\"javascript-规范\"> JavaScript 规范</h1>\n<blockquote>\n<p>统一团队的编码规范，有助于代码的维护。<br>\n没有什么规则是「必须」的。这些是风格偏好，而不是宗教教条。</p>\n</blockquote>\n<h2 id=\"语法\"> 语法</h2>\n<p>下图是一个概要图，其中列出了一些建议的规范，更具体的请参阅下文：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/javascript-code-style.svg\" alt=\"JavaScript 编码规范\">\n  <p style=\"text-align: center; color: #888;\">（JavaScript 编码规范）</p>\n</div>\n<h2 id=\"花括号\"> 花括号</h2>\n<p>在大多数的 JavaScript 项目中，花括号以「Egyptian」风格书写，即左花括号与相应的关键词在同一行上，而不是新起一行。左括号前还应该有一个空格，如下所示：</p>\n<p>推荐：</p>\n<div><pre><code><span>if</span> <span>(</span>foo<span>)</span> <span>{</span>\n  <span>bar</span><span>(</span><span>)</span>\n<span>}</span> <span>else</span> <span>{</span>\n  <span>baz</span><span>(</span><span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>不推荐：</p>\n<div><pre><code><span>if</span> <span>(</span>foo<span>)</span>\n<span>{</span>\n  <span>bar</span><span>(</span><span>)</span>\n<span>}</span>\n<span>else</span>\n<span>{</span>\n  <span>baz</span><span>(</span><span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"单行代码块\"> 单行代码块</h2>\n<p>在单行代码块中使用空格。</p>\n<p>推荐：</p>\n<div><pre><code><span>function</span> <span>foo</span> <span>(</span><span>)</span> <span>{</span> <span>return</span> <span>true</span> <span>}</span>\n<span>if</span> <span>(</span>foo<span>)</span> <span>{</span> bar <span>=</span> <span>0</span> <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>不推荐：</p>\n<div><pre><code><span>function</span> <span>foo</span> <span>(</span><span>)</span> <span>{</span><span>return</span> <span>true</span><span>}</span>\n<span>if</span> <span>(</span>foo<span>)</span> <span>{</span>bar <span>=</span> <span>0</span><span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"缩进\"> 缩进</h2>\n<p>常见的缩进有三种：2 个空格、4 个空格、<code>Tab</code> 制表符。</p>\n<p>本规范参考市面上优秀的开源项目，姑且约定使用 <code>空格</code> 来缩进，而且缩进使用两个空格。</p>\n<h2 id=\"对象字面量的键值缩进\"> 对象字面量的键值缩进</h2>\n<p>对象字面量的键和值之间不能存在空格，对象字面量的冒号和值之间存在一个空格。</p>\n<p>推荐：</p>\n<div><pre><code><span>const</span> obj <span>=</span> <span>{</span> <span>'foo'</span><span>:</span> <span>'haha'</span> <span>}</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>不推荐：</p>\n<div><pre><code><span>const</span> obj <span>=</span> <span>{</span> <span>'foo'</span> <span>:</span> <span>'haha'</span> <span>}</span>\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"构造函数首字母大写\"> 构造函数首字母大写</h2>\n<p>在 JavaScript 中 <code>new</code> 操作符用来创建某个特定类型的对象的一个实例，该类型的对象是由一个构造函数表示的。</p>\n<p>由于构造函数只是常规函数，唯一区别是使用 <code>new</code> 来调用。所以我们约定构造函数的首字母要大写，以此来区分构造函数和普通函数。</p>\n<p>推荐：</p>\n<div><pre><code><span>const</span> fooItem <span>=</span> <span>new</span> <span>Foo</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>不推荐：</p>\n<div><pre><code><span>const</span> fooItem <span>=</span> <span>new</span> <span>foo</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"拖尾换行\"> 拖尾换行</h2>\n<p>在非空文件中，存在拖尾换行是一个常见的 UNIX 风格，它的好处是可以方便在串联和追加文件时不会打断 Shell 的提示。在日常的项目中，保留拖尾换行的好处是，可以减少版本控制时的代码冲突。</p>\n<p>推荐：</p>\n<div><pre><code><span>function</span> <span>func</span> <span>(</span><span>)</span> <span>{</span>\n  <span>// do something</span>\n<span>}</span>\n  <span>// 此处是新的一行</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>不推荐：</p>\n<div><pre><code><span>function</span> <span>func</span> <span>(</span><span>)</span> <span>{</span>\n  <span>// do something</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"空行\"> 空行</h2>\n<p>空白行对于分离代码逻辑有帮助，但过多的空行会占据屏幕的空间，影响可读性。约定最大连续空行数为 2。</p>\n<p>推荐：</p>\n<div><pre><code><span>const</span> a <span>=</span> <span>1</span>\n\n\n<span>const</span> b <span>=</span> <span>2</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>不推荐：</p>\n<div><pre><code><span>const</span> a <span>=</span> <span>1</span>\n\n\n\n<span>const</span> b <span>=</span> <span>2</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"变量声明\"> 变量声明</h2>\n<p>JavaScript 允许在一个声明中，声明多个变量。但我们约定在声明变量时，一个声明只能有一个变量。</p>\n<p>推荐：</p>\n<div><pre><code><span>const</span> a\n<span>const</span> b\n<span>const</span> c\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>不推荐：</p>\n<div><pre><code><span>const</span> a<span>,</span> b<span>,</span> c\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"分号\"> 分号</h2>\n<p>每一个语句后面都应该有一个分号，即使它可以被跳过。</p>\n<p>JavaScript 在所有类 C 语言中是比较独特的，它不需要在每个语句的末尾有分号。在很多情况下，JavaScript 引擎可以确定一个分号应该在什么位置然后自动添加它。此特征被称为自动分号插入（ASI），被认为是 JavaScript 中较为有争议的特征。</p>\n<p>业内对于是否应该使用分号，也有许多争论，本规范<strong>推荐使用分号</strong>，这样可以避免可能出现的陷阱。</p>\n<p>有两种情况下可以不使用分号：</p>\n<ul>\n<li>如果你是一个有经验的 JavaScript 程序员，你可以选择像 <a href=\"https://standardjs.com/\" target=\"_blank\" rel=\"noopener noreferrer\">StandardJS</a> 这样的无分号的代码风格。</li>\n<li>在使用 Vue.js 这类现代化框架编写项目时，遵循框架本身的代码风格（不加分号）。</li>\n</ul>\n<div><p>提示</p>\n<p>如果搞不清什么时候必须加分号，记得在以 <code>(</code>、<code>[</code>、<code>'</code>、<code>/</code>、<code>+</code>、<code>-</code>（即小括号、中括号、单引号、正则开头的斜杠、加号、减号）开头的语句前面都加上一个分号，否则可能得到非预想结果：</p>\n<div><pre><code><span>var</span> a <span>=</span> <span>2</span>\n<span>var</span> b <span>=</span> <span>3</span>\n<span>[</span>a<span>,</span> b<span>]</span> <span>=</span> <span>[</span>b<span>,</span> a<span>]</span>\nconsole<span>.</span><span>log</span><span>(</span>a<span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>b<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></div>\n<h2 id=\"代码块空格\"> 代码块空格</h2>\n<p>一致性是任何风格指南的重要组成部分。虽然在哪里放置块的开括号纯属个人偏好，但在整个项目中应该保持一致。不一致的风格将会分散读者阅读代码的注意力。</p>\n<p>我们约定代码块前要添加空格。</p>\n<p>推荐：</p>\n<div><pre><code><span>if</span> <span>(</span>a<span>)</span> <span>{</span>\n  <span>b</span><span>(</span><span>)</span>\n<span>}</span>\n\n<span>function</span> <span>a</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>不推荐：</p>\n<div><pre><code><span>if</span> <span>(</span>a<span>)</span><span>{</span>\n  <span>b</span><span>(</span><span>)</span>\n<span>}</span>\n\n<span>function</span> <span>a</span><span>(</span><span>)</span><span>{</span><span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"函数声明的空格\"> 函数声明的空格</h2>\n<p>本规范约定函数括号前不加空格。</p>\n<p>推荐：</p>\n<div><pre><code><span>function</span> <span>func</span><span>(</span><span>x</span><span>)</span> <span>{</span>\n  <span>// ...</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>不推荐：</p>\n<div><pre><code><span>function</span> <span>func</span> <span>(</span><span>x</span><span>)</span> <span>{</span>\n  <span>// ...</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"操作符的空格\"> 操作符的空格</h2>\n<p>操作符前后都需要添加空格。</p>\n<p>推荐：</p>\n<div><pre><code><span>const</span> sum <span>=</span> <span>1</span> <span>+</span> <span>2</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>不推荐：</p>\n<div><pre><code><span>const</span> sum <span>=</span> <span>1</span><span>+</span><span>2</span>\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"函数位置\"> 函数位置</h2>\n<p>如果你正在写几个「辅助」函数和一些使用它们的代码，我们约定<strong>先写调用代码，再写函数</strong>。</p>\n<p>这是因为阅读代码时，我们首先想要知道的是「它做了什么」。如果代码先行，那么在整个程序的最开始就展示出了这些信息。之后，可能我们就不需要阅读这些函数了，尤其是它们的名字清晰地展示出了它们的功能的时候。</p>\n<p>推荐：</p>\n<div><pre><code><span>// 调用函数的代码</span>\n<span>let</span> elem <span>=</span> <span>createElement</span><span>(</span><span>)</span><span>;</span>\n<span>setHandler</span><span>(</span>elem<span>)</span><span>;</span>\n<span>walkAround</span><span>(</span><span>)</span><span>;</span>\n\n<span>// --- 辅助函数 ---</span>\n<span>function</span> <span>createElement</span><span>(</span><span>)</span> <span>{</span>\n  <span>...</span>\n<span>}</span>\n\n<span>function</span> <span>setHandler</span><span>(</span><span>elem</span><span>)</span> <span>{</span>\n  <span>...</span>\n<span>}</span>\n\n<span>function</span> <span>walkAround</span><span>(</span><span>)</span> <span>{</span>\n  <span>...</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id=\"注释规范\"> 注释规范</h2>\n<h3 id=\"单行注释\"> 单行注释</h3>\n<p>必须独占一行。<code>//</code> 后跟一个空格，缩进与下一行被注释说明的代码一致。</p>\n<p>推荐：</p>\n<div><pre><code><span>// is current tab</span>\n<span>const</span> active <span>=</span> <span>true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>不推荐：</p>\n<div><pre><code><span>const</span> active <span>=</span> <span>true</span> <span>// is current tab</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>注释行的上方需要有一个空行（<strong>除非注释行上方是一个块的顶部</strong>），以增加可读性。</p>\n<h3 id=\"多行注释\"> 多行注释</h3>\n<p>避免使用 <code>/*...*/</code> 这样的多行注释。有多行注释内容时，使用多个单行注释。</p>\n<h3 id=\"特殊标记\"> 特殊标记</h3>\n<p>有时我们发现某个可能的 bug，但因为一些原因还没法修复；或者某个地方还有一些待完成的功能，这时我们需要使用相应的特殊标记注释来告知未来的自己或合作者。常用的特殊标记有两种：</p>\n<ul>\n<li><code>// FIXME</code>：说明问题是什么</li>\n<li><code>// TODO</code>：说明还要做什么或者问题的解决方案</li>\n</ul>\n<p>例如：</p>\n<div><pre><code><span>class</span> <span>Calculator</span> <span>extends</span> <span>Abacus</span> <span>{</span>\n  <span>constructor</span> <span>(</span><span>)</span> <span>{</span>\n    <span>super</span> <span>(</span><span>)</span>\n\n      <span>// FIXME: shouldn’t use a global here</span>\n      total <span>=</span> <span>0</span>\n\n      <span>// TODO: total should be configurable by an options param</span>\n      <span>this</span><span>.</span>total <span>=</span> <span>0</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"函数-方法注释\"> 函数/方法注释</h3>\n<ul>\n<li>必须包含函数的说明，说明 what，而不是 how。</li>\n<li>有参数和返回值时，必须有注释标志。</li>\n<li>参数和返回值必须包含类型信息和说明。</li>\n<li>当函数是内部函数，外部不可以访问时，可以使用 <code>@inner</code> 来标识。</li>\n</ul>\n<p>推荐：</p>\n<div><pre><code><span>/**\n * Number formatting\n * like 10000 => 10k\n * @param {number} num\n * @param {number} digits\n * @return {string}\n */</span>\n<span>function</span> <span>numberFormatter</span><span>(</span><span>num<span>,</span> digits</span><span>)</span> <span>{</span>\n  <span>const</span> si <span>=</span> <span>[</span>\n    <span>{</span> value<span>:</span> <span>1E18</span><span>,</span> symbol<span>:</span> <span>'E'</span> <span>}</span><span>,</span>\n    <span>{</span> value<span>:</span> <span>1E15</span><span>,</span> symbol<span>:</span> <span>'P'</span> <span>}</span><span>,</span>\n    <span>{</span> value<span>:</span> <span>1E12</span><span>,</span> symbol<span>:</span> <span>'T'</span> <span>}</span><span>,</span>\n    <span>{</span> value<span>:</span> <span>1E9</span><span>,</span> symbol<span>:</span> <span>'G'</span> <span>}</span><span>,</span>\n    <span>{</span> value<span>:</span> <span>1E6</span><span>,</span> symbol<span>:</span> <span>'M'</span> <span>}</span><span>,</span>\n    <span>{</span> value<span>:</span> <span>1E3</span><span>,</span> symbol<span>:</span> <span>'k'</span> <span>}</span>\n  <span>]</span>\n  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> si<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>num <span>>=</span> si<span>[</span>i<span>]</span><span>.</span>value<span>)</span> <span>{</span>\n      <span>return</span> <span>(</span>num <span>/</span> si<span>[</span>i<span>]</span><span>.</span>value<span>)</span><span>.</span><span>toFixed</span><span>(</span>digits<span>)</span><span>.</span><span>replace</span><span>(</span><span><span>/</span><span>\\.0+$|(\\.[0-9]*[1-9])0+$</span><span>/</span></span><span>,</span> <span>'$1'</span><span>)</span> <span>+</span> si<span>[</span>i<span>]</span><span>.</span>symbol\n    <span>}</span>\n  <span>}</span>\n  <span>return</span> num<span>.</span><span>toString</span><span>(</span><span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h3 id=\"文件注释\"> 文件注释</h3>\n<ul>\n<li>用于告诉不熟悉这段代码的读者这个文件中包含哪些东西。</li>\n<li>文件注释要标明作者、文件版本、创建/修改时间、重大版本修改记录。</li>\n</ul>\n<p>推荐：</p>\n<div><pre><code><span>/**\n * @desc Description of file, its uses and information\n * @dependencies about its dependencies.\n * @author Author Name\n * @date 2020-12-29\n */</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>（完）</p>\n",
      "date_published": "2021-02-26T06:03:04.000Z",
      "date_modified": "2021-10-28T05:29:08.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "CSS 规范",
      "url": "https://www.fedbook.cn/style-guide/program/css-spec/",
      "id": "https://www.fedbook.cn/style-guide/program/css-spec/",
      "content_html": "<h1 id=\"css-规范\"> CSS 规范</h1>\n<h2 id=\"样式文件\"> 样式文件</h2>\n<p>样式文件必须写上 <code>@charset</code> 规则，并且一定要在样式文件的第一行首个字符位置开始写，编码名用 <code>&quot;UTF-8&quot;</code>。</p>\n<p>推荐：</p>\n<div><pre><code><span><span>@charset</span> <span>\"UTF-8\"</span><span>;</span></span>\n<span>.jdc</span> <span>{</span><span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>不推荐：</p>\n<div><pre><code><span>/* @charset 规则不在文件首行首个字符开始 */</span>\n<span><span>@charset</span> <span>\"UTF-8\"</span><span>;</span></span>\n<span>.jdc</span> <span>{</span><span>}</span>\n\n<span>/* @charset 规则没有用小写 */</span>\n<span><span>@CHARSET</span> <span>\"UTF-8\"</span><span>;</span></span>\n<span>.jdc</span> <span>{</span><span>}</span>\n\n<span>/* 无@charset规则 */</span>\n<span>.jdc</span> <span>{</span><span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id=\"代码格式化\"> 代码格式化</h2>\n<p>样式书写一般有两种：一种是紧凑格式（Compact），一种是展开格式（Expanded）。</p>\n<p>推荐：展开格式（Expanded）</p>\n<div><pre><code><span>.jdc</span> <span>{</span>\n  <span>display</span><span>:</span> block<span>;</span>\n  <span>width</span><span>:</span> 50px<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>不推荐：紧凑格式（Compact）</p>\n<div><pre><code><span>.jdc</span> <span>{</span> <span>display</span><span>:</span> block<span>;</span> <span>width</span><span>:</span> 50px<span>;</span><span>}</span>\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"代码大小写\"> 代码大小写</h2>\n<p>样式选择器，属性名，属性值关键字全部使用小写字母书写，属性字符串允许使用大小写。</p>\n<p>推荐：</p>\n<div><pre><code><span>.jdc</span> <span>{</span>\n  <span>display</span><span>:</span> block<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>不推荐：</p>\n<div><pre><code><span>.JDC</span> <span>{</span>\n  <span>DISPLAY</span><span>:</span> BLOCK<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"代码易读性\"> 代码易读性</h2>\n<ul>\n<li>左括号与类名之间一个空格，冒号与属性值之间一个空格。</li>\n</ul>\n<p>推荐：</p>\n<div><pre><code><span>.jdc</span> <span>{</span>\n  <span>width</span><span>:</span> 100%<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>不推荐：</p>\n<div><pre><code><span>.jdc</span><span>{</span>\n  <span>width</span><span>:</span>100%<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>\n<li>逗号分隔的取值，逗号之后一个空格。</li>\n</ul>\n<p>推荐：</p>\n<div><pre><code><span>.jdc</span> <span>{</span>\n  <span>box-shadow</span><span>:</span> 1px 1px 1px #333<span>,</span> 2px 2px 2px #ccc<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>不推荐：</p>\n<div><pre><code><span>.jdc</span> <span>{</span>\n  <span>box-shadow</span><span>:</span> 1px 1px 1px #333<span>,</span>2px 2px 2px #ccc<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>\n<li>为单个 CSS 选择器或新声明开启新行。</li>\n</ul>\n<p>推荐：</p>\n<div><pre><code><span>.jdc, .jdc_logo, .jdc_hd</span> <span>{</span>\n  <span>color</span><span>:</span> #ff0<span>;</span>\n<span>}</span>\n\n<span>.nav</span><span>{</span>\n  <span>color</span><span>:</span> #fff<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>不推荐：</p>\n<div><pre><code><span>.jdc, .jdc_logo, .jdc_hd</span> <span>{</span>\n  <span>color</span><span>:</span> #ff0<span>;</span>\n<span>}</span><span>.nav</span><span>{</span>\n  <span>color</span><span>:</span> #fff<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>\n<li>颜色值 <code>rgb()</code>、<code>rgba()</code>、<code>hsl()</code>、<code>hsla()</code>、<code>rect()</code> 中不需有空格，且取值不要带有不必要的 <code>0</code>。</li>\n</ul>\n<p>推荐：</p>\n<div><pre><code><span>.jdc</span> <span>{</span>\n  <span>color</span><span>:</span> <span>rgba</span><span>(</span>255<span>,</span>255<span>,</span>255<span>,</span>.5<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>不推荐：</p>\n<div><pre><code><span>.jdc</span> <span>{</span>\n  <span>color</span><span>:</span> <span>rgba</span><span>(</span> 255<span>,</span> 255<span>,</span> 255<span>,</span> 0.5 <span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>\n<li>颜色属性值十六进制数值能用简写的尽量用简写。</li>\n</ul>\n<p>推荐：</p>\n<div><pre><code><span>.jdc</span> <span>{</span>\n  <span>color</span><span>:</span> #fff<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>不推荐：</p>\n<div><pre><code><span>.jdc</span> <span>{</span>\n  <span>color</span><span>:</span> #ffffff<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>\n<li>不要为 <code>0</code> 指明单位。</li>\n</ul>\n<p>推荐：</p>\n<div><pre><code><span>.jdc</span> <span>{</span>\n  <span>margin</span><span>:</span> 0 10px<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>不推荐：</p>\n<div><pre><code><span>.jdc</span> <span>{</span>\n  <span>margin</span><span>:</span> 0px 10px<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"属性值引号\"> 属性值引号</h2>\n<p>CSS 属性值需要用到引号时，统一使用单引号。</p>\n<p>推荐：</p>\n<div><pre><code><span>.jdc</span> <span>{</span>\n  <span>font-family</span><span>:</span> <span>'Hiragino Sans GB'</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>不推荐：</p>\n<div><pre><code><span>.jdc</span> <span>{</span>\n  <span>font-family</span><span>:</span> <span>\"Hiragino Sans GB\"</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"声明顺序\"> 声明顺序</h2>\n<p>相关的属性声明应当归为一组，并按照下面的顺序排列：</p>\n<ul>\n<li>Positioning（元素定位）</li>\n<li>Box model（盒模型）</li>\n<li>Typographic（字体排版）</li>\n<li>Visual（颜色视觉）</li>\n<li>Misc（其它杂项）</li>\n</ul>\n<p>解释：</p>\n<p>由于定位（positioning）可以从正常的文档流中移除元素，并且还能覆盖盒模型（box model）相关的样式，因此排在首位。盒模型排在第二位，因为它决定了组件的尺寸和位置。</p>\n<p>其他属性只是影响组件的 内部 或者是不影响前两组属性，因此排在后面。</p>\n<p>示例：</p>\n<div><pre><code><span>.declaration-order</span> <span>{</span>\n  <span>/* Positioning */</span>\n  <span>position</span><span>:</span> absolute<span>;</span>\n  <span>top</span><span>:</span> 0<span>;</span>\n  <span>right</span><span>:</span> 0<span>;</span>\n  <span>bottom</span><span>:</span> 0<span>;</span>\n  <span>left</span><span>:</span> 0<span>;</span>\n  <span>z-index</span><span>:</span> 100<span>;</span>\n\n  <span>/* Box-model */</span>\n  <span>display</span><span>:</span> block<span>;</span>\n  <span>float</span><span>:</span> right<span>;</span>\n  <span>width</span><span>:</span> 100px<span>;</span>\n  <span>height</span><span>:</span> 100px<span>;</span>\n\n  <span>/* Typography */</span>\n  <span>font</span><span>:</span> normal 13px <span>\"Helvetica Neue\"</span><span>,</span> sans-serif<span>;</span>\n  <span>line-height</span><span>:</span> 1.5<span>;</span>\n  <span>color</span><span>:</span> #333<span>;</span>\n  <span>text-align</span><span>:</span> center<span>;</span>\n\n  <span>/* Visual */</span>\n  <span>background-color</span><span>:</span> #f5f5f5<span>;</span>\n  <span>border</span><span>:</span> 1px solid #e5e5e5<span>;</span>\n  <span>border-radius</span><span>:</span> 3px<span>;</span>\n\n  <span>/* Misc */</span>\n  <span>opacity</span><span>:</span> 1<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>完整的属性列表及其排列顺序请参考 <a href=\"https://github.com/stormwarning/stylelint-config-recess-order/blob/main/index.js\" target=\"_blank\" rel=\"noopener noreferrer\">Bootstrap property order for Stylelint</a>。</p>\n<h2 id=\"css3-浏览器私有前缀\"> CSS3 浏览器私有前缀</h2>\n<p>CSS3 浏览器私有前缀在前，标准前缀在后。</p>\n<div><pre><code><span>.jdc</span> <span>{</span>\n  <span>-webkit-border-radius</span><span>:</span> 10px<span>;</span>\n  <span>-moz-border-radius</span><span>:</span> 10px<span>;</span>\n  <span>-o-border-radius</span><span>:</span> 10px<span>;</span>\n  <span>-ms-border-radius</span><span>:</span> 10px<span>;</span>\n  <span>border-radius</span><span>:</span> 10px<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"媒体查询的位置\"> 媒体查询的位置</h2>\n<p>将媒体查询放在尽可能相关规则的附近。不要将他们打包放在一个单一样式文件中或者放在文档底部。如果你把他们分开了，将来只会被大家遗忘。</p>\n<p>示例：</p>\n<div><pre><code><span>.element</span> <span>{</span> ... <span>}</span>\n<span>.element-avatar</span> <span>{</span> ... <span>}</span>\n<span>.element-selected</span> <span>{</span> ... <span>}</span>\n\n<span><span>@media</span> <span>(</span><span>min-width</span><span>:</span> 480px<span>)</span></span> <span>{</span>\n  <span>.element</span> <span>{</span> ...<span>}</span>\n  <span>.element-avatar</span> <span>{</span> ... <span>}</span>\n  <span>.element-selected</span> <span>{</span> ... <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id=\"注释规范\"> 注释规范</h2>\n<h3 id=\"单行注释\"> 单行注释</h3>\n<p>注释内容第一个字符和最后一个字符都是一个空格字符，单独占一行，行与行之间相隔一行。</p>\n<p>推荐：</p>\n<div><pre><code><span>/* Comment Text */</span>\n<span>.jdc</span> <span>{</span><span>}</span>\n\n<span>/* Comment Text */</span>\n<span>.jdc</span> <span>{</span><span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>不推荐：</p>\n<div><pre><code><span>/*Comment Text*/</span>\n<span>.jdc</span> <span>{</span>\n  <span>display</span><span>:</span> block<span>;</span>\n<span>}</span>\n\n<span>.jdc</span> <span>{</span>\n  <span>display</span><span>:</span> block<span>;</span><span>/*Comment Text*/</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"模块注释\"> 模块注释</h3>\n<p>注释内容第一个字符和最后一个字符都是一个空格字符，<code>/*</code> 与模块信息描述占一行，多个横线分隔符 <code>-</code> 与 <code>*/</code> 占一行，行与行之间相隔两行。</p>\n<p>推荐：</p>\n<div><pre><code><span>/* Module A\n---------------------------------------------------------------- */</span>\n<span>.mod-a</span> <span>{</span><span>}</span>\n\n\n<span>/* Module B\n---------------------------------------------------------------- */</span>\n<span>.mod-b</span> <span>{</span><span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>不推荐：</p>\n<div><pre><code><span>/* Module A ---------------------------------------------------- */</span>\n<span>.mod-a</span> <span>{</span><span>}</span>\n<span>/* Module B ---------------------------------------------------- */</span>\n<span>.mod-b</span> <span>{</span><span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"文件注释\"> 文件注释</h3>\n<p>在样式文件编码声明<code>@charset</code> 语句下面注明页面名称、作者、创建日期等信息。</p>\n<p>推荐：</p>\n<div><pre><code><span><span>@charset</span> <span>\"UTF-8\"</span><span>;</span></span>\n<span>/**\n * @desc File Info\n * @author Author Name\n * @date 2020-12-29\n */</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>（完）</p>\n",
      "date_published": "2021-02-26T06:03:04.000Z",
      "date_modified": "2022-02-11T07:47:14.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Git 提交信息规范",
      "url": "https://www.fedbook.cn/style-guide/version-control/git-commit-message/",
      "id": "https://www.fedbook.cn/style-guide/version-control/git-commit-message/",
      "content_html": "<h1 id=\"git-提交信息规范\"> Git 提交信息规范</h1>\n<blockquote>\n<p>无论是个人项目还是在团队协作中，commit message 都应该清晰明了，遵守一定规范。</p>\n<p>目前，社区有多种 commit message 的写法规范。本文介绍 <a href=\"https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#commits\" target=\"_blank\" rel=\"noopener noreferrer\">Angular 规范</a>，这是目前使用最广的写法，比较合理和系统化，并且有配套的工具。</p>\n</blockquote>\n<h2 id=\"规范-commit-的好处\"> 规范 commit 的好处</h2>\n<ul>\n<li>提供更明确的历史信息，方便浏览和判断提交目的</li>\n<li>可以过滤某些不必要的提交，方便快速查找信息</li>\n<li>自动化生成 Change log</li>\n</ul>\n<p>以上的好处，个人认为要有一个大的前提，就是每一个提交，尽量保证其目的单一性。例如几个 bug 仅仅看上去类似，就合并成一次性修改提交，反而会让 commit 的信息变的复杂化，阅读不方便，也容易让人想到一些不必要的关联性。</p>\n<h2 id=\"开源项目-commit-示例\"> 开源项目 commit 示例</h2>\n<p>找了几个 star 较多的库，看看它们的提交格式。</p>\n<ul>\n<li><a href=\"https://github.com/angular/angular/commits/master\" target=\"_blank\" rel=\"noopener noreferrer\">angular-commit</a></li>\n</ul>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/angular-commit.png\" alt=\"Angular 的提交历史\" style=\"width: 500px;\">\n  <p style=\"text-align: center; color: #888;\">（Angular 的提交历史）</p>\n</div>\n<ul>\n<li><a href=\"https://github.com/vuejs/vue/commits/dev\" target=\"_blank\" rel=\"noopener noreferrer\">vuejs-commit</a></li>\n</ul>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/vuejs-commit.png\" alt=\"Vue.js 的提交历史\" style=\"width: 500px;\">\n  <p style=\"text-align: center; color: #888;\">（Vue.js 的提交历史）</p>\n</div>\n<ul>\n<li><a href=\"https://github.com/facebook/react/commits/main\" target=\"_blank\" rel=\"noopener noreferrer\">react-commit</a>：跟前两者的风格不一样，似乎就是首字母大写，但最近的提交记录中，看见有参与者在按照 Angular 的 commit 规范进行提交。</li>\n</ul>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/react-commit.png\" alt=\"React 的提交历史\" style=\"width: 500px;\">\n  <p style=\"text-align: center; color: #888;\">（React 的提交历史）</p>\n</div>\n<h2 id=\"commit-的格式\"> commit 的格式</h2>\n<p>每次提交，commit message 都包括三个部分：header，body 和 footer。header 有一个特殊的格式包含有 type，scope 和 subject：</p>\n<div><pre><code><span>&lt;</span>type<span>></span><span>(</span><span>&lt;</span>scope<span>></span><span>)</span>: <span>&lt;</span>subject<span>></span>  <span># header</span>\n<span>&lt;</span>BLANK LINE<span>></span>                <span># 空行</span>\n<span>&lt;</span>body<span>></span>                      <span># body</span>\n<span>&lt;</span>BLANK LINE<span>></span>                <span># 空行</span>\n<span>&lt;</span>footer<span>></span>                    <span># footer</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>header、body、footer 之间都要空一行，header 是必填项，scope 是选填项。commit message 的每一行的文字不能超过 100 个字符。这样子在 GitHub 和 Git 工具上更便于阅读。</p>\n<h3 id=\"type\"> type</h3>\n<p>type 用于说明 commit 的类别，必须为以下类型的一种：</p>\n<p>type 用于说明 commit 的类别，一般常用的有下面几种标识：</p>\n<ul>\n<li><code>feat</code>：新功能（feature）</li>\n<li><code>fix</code>：修复 bug</li>\n<li><code>docs</code>：只是文档的更改（documentation）</li>\n<li><code>style</code>：不影响程序逻辑的代码修改（例如格式化、修改空白字符，补全缺失的分号等）</li>\n<li><code>refactor</code>：即不是新增功能，也不是修改 bug 的代码变动（一般指重构代码）</li>\n<li><code>perf</code>：提高性能的代码更改</li>\n<li><code>test</code>：新增测试用例或是更新现有测试</li>\n<li><code>revert</code>：回滚某个更早之前的提交</li>\n<li><code>build</code>：主要目的是修改项目构建系统（例如 glup，webpack，rollup 的配置等）的提交</li>\n<li><code>ci</code>：主要目的是修改项目继续集成流程（例如 Travis，Jenkins，GitLab CI，Circle 等）的提交</li>\n<li><code>chore</code>：不属于以上类型的其他类型（日常事务，例如对构建或者辅助工具的更改、生成文档等）</li>\n</ul>\n<p>如果 type 为 feat 和 fix，则该 commit 将肯定出现在 Change log 之中。其他情况由你决定要不要放入 Change log，建议是不要。</p>\n<h3 id=\"scope\"> scope</h3>\n<p>scope 用于说明 commit 影响的范围（比如数据层、控制层、视图层等等），当影响的范围有多个时候，可以使用 <code>*</code>。</p>\n<h3 id=\"subject\"> subject</h3>\n<p>subject 用于对本次 commit 的简洁描述，不超过 50 个字符：</p>\n<ul>\n<li>使用<a href=\"https://baike.baidu.com/item/%E7%A5%88%E4%BD%BF%E5%8F%A5/19650285\" target=\"_blank\" rel=\"noopener noreferrer\">祈使句</a>，一般以动词原形开始，例如使用 change 而不是 changed 或者 changes。</li>\n<li>第一个字母小写。</li>\n<li>结尾不加句号（<code>.</code>）。</li>\n</ul>\n<h3 id=\"body\"> body</h3>\n<p>body 用于对 commit 详细描述。</p>\n<ul>\n<li>使用祈使句，一般以动词原形开始，例如使用 change 而不是 changed 或者 changes。</li>\n<li>应该说明代码变动的动机，以及与以前行为的对比。</li>\n<li>可以分成多行。</li>\n</ul>\n<h3 id=\"footer\"> footer</h3>\n<p>footer 部分只用于两种情况。</p>\n<h4 id=\"_1-不兼容的变动\"> 1）不兼容的变动</h4>\n<p>如果当前代码与上一个版本不兼容，则 footer 部分以 <code>BREAKING CHANGE:</code> 开头，后面是对变动的描述、以及变动理由和迁移方法。</p>\n<div><pre><code>BREAKING CHANGE: isolate scope bindings definition has changed.\n\nTo migrate the code follow the example below:\n\nBefore:\n\nscope: <span>{</span>\n  myAttr: <span>'attribute'</span>,\n<span>}</span>\n\nAfter:\n\nscope: <span>{</span>\n  myAttr: <span>'@'</span>,\n<span>}</span>\n\nThe removed <span><span>`</span>inject<span>`</span></span> wasn't generaly useful <span>for</span> directives so there should be no code using it.\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h4 id=\"_2-关闭-issue\"> 2）关闭 issue</h4>\n<p>如果当前 commit 针对某个 issue，那么可以在 footer 部分关闭这个 issue。</p>\n<div><pre><code>Closes <span>#234</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>也可以一次关闭多个 issue。</p>\n<div><pre><code>Closes <span>#123, #245, #992</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"revert-可忽视\"> revert（可忽视）</h3>\n<p>如果当前 commit 用于撤销之前的 commit，则必须以 <code>revert:</code> 开头，后面跟着被撤销 commit 的 header。</p>\n<p>body 部分的格式是固定的，必须写成 <code>This reverts commit &lt;hash&gt;.</code>，其中的 hash 是被撤销 commit 的 SHA 标识符。</p>\n<div><pre><code>revert: feat<span>(</span>pencil<span>)</span>: <span>add</span> <span>'graphiteWidth'</span> option\n\nThis reverts commit 667ecc1654a317a13331b17617d973392f415f02.\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的 Reverts 小标题下面。</p>\n<h2 id=\"模板参考\"> 模板参考</h2>\n<div><pre><code>feat<span>(</span><span>$browser</span><span>)</span>: onUrlChange event <span>(</span>popstate/hashchange/polling<span>)</span>\n\nAdded new event to <span>$browser</span><span>:</span>\n- forward popstate event <span>if</span> available\n- forward hashchange event <span>if</span> popstate not available\n- <span>do</span> polling when neither popstate nor hashchange available\n\nBreaks <span>$browser</span>.onHashChange, <span>which</span> was removed <span>(</span>use onUrlChange instead<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code>fix<span>(</span><span>$compile</span><span>)</span>: couple of unit tests <span>for</span> IE9\n\nOlder IEs serialize html uppercased, but IE9 does not<span>..</span>.\nWould be better to <span>expect</span> <span>case</span> insensitive, unfortunately jasmine does\nnot allow to user regexps <span>for</span> throw expectations.\n\nCloses <span>#392</span>\nBreaks foo.bar api, foo.baz should be used instead\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code>feat<span>(</span>directive<span>)</span>: ng:disabled, ng:checked, ng:multiple, ng:readonly, ng:selected\n\nNew directives <span>for</span> proper binding these attributes <span>in</span> older browsers <span>(</span>IE<span>)</span>.\nAdded coresponding description, live examples and e2e tests.\n\nCloses <span>#351</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code>style<span>(</span><span>$location</span><span>)</span>: <span>add</span> couple of missing semi colons\n</code></pre>\n<div><span>1</span><br></div></div><div><pre><code>docs<span>(</span>guide<span>)</span>: updated fixed docs from Google Docs\n\nCouple of typos fixed:\n- indentation\n- batchLogbatchLog -<span>></span> batchLog\n- start periodic checking\n- missing brace\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><div><pre><code>feat<span>(</span><span>$compile</span><span>)</span>: simplify isolate scope bindings\n\nChanged the isolate scope binding options to:\n  - @attr - attribute binding <span>(</span>including interpolation<span>)</span>\n  - <span>=</span>model - by-directional model binding\n  - <span>&amp;</span><span>expr</span> - expression execution binding\n\nThis change simplifies the terminology as well as\nnumber of choices available to the developer. It\nalso supports <span>local</span> name aliasing from the parent.\n\nBREAKING CHANGE: isolate scope bindings definition has changed and\nthe inject option <span>for</span> the directive controller injection was removed.\n\nTo migrate the code follow the example below:\n\nBefore:\n\nscope: <span>{</span>\n  myAttr: <span>'attribute'</span>,\n  myBind: <span>'bind'</span>,\n  myExpression: <span>'expression'</span>,\n  myEval: <span>'evaluate'</span>,\n  myAccessor: <span>'accessor'</span>\n<span>}</span>\n\nAfter:\n\nscope: <span>{</span>\n  myAttr: <span>'@'</span>,\n  myBind: <span>'@'</span>,\n  myExpression: <span>'&amp;'</span>,\n  // myEval - usually not useful, but <span>in</span> cases where the expression is assignable, you can use <span>'='</span>\n  myAccessor: <span>'='</span> // <span>in</span> directive<span>'s template change myAccessor() to myAccessor\n}\n\nThe removed `inject` wasn'</span>t generaly useful <span>for</span> directives so there should be no code using it.\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><h2 id=\"提交频率\"> 提交频率</h2>\n<p>关于什么时候提交一次：</p>\n<p>每次你写完一个功能的时候，就应该做一次提交（这个提交是提交到本地的 Git 库中）。</p>\n<p>当然，这里的写完表示的是你的这个功能是没有问题的。</p>\n<h2 id=\"参考资料\"> 参考资料</h2>\n<ul>\n<li><a href=\"https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#commits\" target=\"_blank\" rel=\"noopener noreferrer\">Angular 规范</a></li>\n<li><a href=\"https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit\" target=\"_blank\" rel=\"noopener noreferrer\">Angular 规范文档</a></li>\n<li><a href=\"https://www.conventionalcommits.org/zh-hans/v1.0.0/\" target=\"_blank\" rel=\"noopener noreferrer\">约定式提交</a></li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2021-11-22T09:42:58.000Z",
      "date_modified": "2021-12-09T09:07:13.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Vue 项目规范",
      "url": "https://www.fedbook.cn/style-guide/program/vuejs-spec/",
      "id": "https://www.fedbook.cn/style-guide/program/vuejs-spec/",
      "content_html": "<h1 id=\"vue-项目规范\"> Vue 项目规范</h1>\n<h2 id=\"前言\"> 前言</h2>\n<p>根据入乡随俗原则，在 Vue 项目中 ：</p>\n<ul>\n<li>JavaScript 语句后不加分号</li>\n<li>缩进使用两个空格</li>\n</ul>\n<p>市面上常用的命名规范：</p>\n<ul>\n<li><code>camelCase</code>（小驼峰式命名法 —— 首字母小写）</li>\n<li><code>PascalCase</code>（大驼峰式命名法 —— 首字母大写）</li>\n<li><code>kebab-case</code>（短横线连接式）</li>\n<li><code>Snake</code>（下划线连接式）</li>\n</ul>\n<h2 id=\"工程目录\"> 工程目录</h2>\n<ul>\n<li>全局通用的组件放在 <code>/src/components/</code> 下。</li>\n<li>页面/视图组件放在 <code>/src/views/</code> 下。</li>\n<li>全局公共指令、过滤器（多于三个文件以上引用）分别放在 <code>src/</code> 目录下的 <code>directives/</code>、<code>filters/</code>。</li>\n<li>当页面文件具有私有组件、指令、过滤器时，则建立一个与页面同名的目录，页面文件更名为 <code>index.vue</code>，然后在该目录下创建私有 <code>./components</code> 等文件夹。</li>\n</ul>\n<p>例如：</p>\n<div><pre><code>src/\n├── App.vue\n├── assets\n├── main.js\n├── components                     <span># 全局通用组件</span>\n├── directive                      <span># 全局公共指令</span>\n├── filters                        <span># 全局公共过滤器</span>\n└── views                          <span># 页面/视图</span>\n    ├── login\n    │   ├── components             <span># 私有组件</span>\n    │   └── index.vue\n    └── profile\n        ├── components             <span># 私有组件</span>\n        └── index.vue\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id=\"命名规范\"> 命名规范</h2>\n<h3 id=\"通用文件与文件夹\"> 通用文件与文件夹</h3>\n<h4 id=\"_1-项目名\"> 1）项目名</h4>\n<p>全部采用小写方式，以<strong>短横线</strong>分隔。例如：<code>my-project-name</code>。</p>\n<h4 id=\"_2-目录名\"> 2）目录名</h4>\n<p>有复数结构时，要采用复数命名法。例如：<code>docs</code>、<code>assets</code>、<code>components</code>、<code>directives</code>、<code>mixins</code>、<code>utils</code>、<code>views</code>。</p>\n<h4 id=\"_3-图像文件名\"> 3）图像文件名</h4>\n<p>全部采用小写方式， 优先选择单个单词命名，多个单词命名以<strong>下划线</strong>分隔。</p>\n<div><pre><code>banner_sina.gif\nmenu_aboutus.gif\nmenutitle_news.gif\nlogo_police.gif\nlogo_national.gif\npic_people.jpg\npic_TV.jpg\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h4 id=\"_4-html-文件名\"> 4）HTML 文件名</h4>\n<p>全部采用小写方式， 优先选择单个单词命名，多个单词命名以<strong>下划线</strong>分隔。</p>\n<div><pre><code>├── error_report.html\n├── success_report.html\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h4 id=\"_5-css-文件名\"> 5）CSS 文件名</h4>\n<p>全部采用小写方式， 优先选择单个单词命名，多个单词命名以<strong>短横线</strong>分隔。</p>\n<div><pre><code>├── normalize.less\n├── base.less\n├── date-picker.scss\n├── input-number.scss\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id=\"_6-javascript-文件名\"> 6）JavaScript 文件名</h4>\n<p>全部采用小写方式， 优先选择单个单词命名，多个单词命名以<strong>短横线</strong>分隔。</p>\n<div><pre><code>├── index.js\n├── plugin.js\n├── util.js\n├── date-util.js\n├── account-model.js\n├── collapse-transition.js\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><blockquote>\n<p>上述规则可以快速记忆为「静态文件下划线，编译文件短横线」。</p>\n</blockquote>\n<h3 id=\"vue-特色文件夹\"> Vue 特色文件夹</h3>\n<p>在 Vue 工程中，这是对通用文件与文件夹命名规范的补充。</p>\n<h4 id=\"_1-位于-components-下的直接子文件夹\"> 1）位于 <code>components/</code> 下的直接子文件夹</h4>\n<ul>\n<li>代表着这类模块的类别。</li>\n<li>由名词组成（例如：<code>Charts/</code>）。</li>\n<li>最好只有一个单词，特殊情况可例外（good: <code>Car/</code>，<code>Order/</code>，<code>Cart/</code>）（bad: <code>CarInfo/</code>，<code>CarPage/</code>）。</li>\n<li>如果有两个以上单词，采用 PascalBase 风格（例如：<code>BackToTop/</code>）</li>\n</ul>\n<h4 id=\"_2-位于-views-下的文件夹和其它文件夹\"> 2）位于 <code>views/</code> 下的文件夹和其它文件夹</h4>\n<ul>\n<li>代表着页面的名字，或者类名。</li>\n<li>由名词组成（例如：<code>profile/</code>）。</li>\n<li>如果有两个以上单词，采用 kebab-case 的风格（例如：<code>error-page/</code>）。</li>\n</ul>\n<p>例如：</p>\n<div><pre><code>src/\n├── App.vue\n├── assets\n├── main.js\n├── components\n│   ├── BackToTop             <span># 通用组件的文件夹</span>\n│   └── Charts                <span># 通用组件的文件夹</span>\n│       ├── Keyboard.vue\n│       ├── LineMarker.vue\n│       ├── MixChart.vue\n│       └── mixins            <span># 其它文件夹（不是 components/ 的直接子文件夹）</span>\n├── directive\n│   ├── clipboard             <span># 其它文件夹</span>\n│   └── permission            <span># 其它文件夹</span>\n├── filters\n└── views\n    ├── charts                <span># 视图组件的文件夹</span>\n    ├── clipboard             <span># 视图组件的文件夹</span>\n    ├── dashboard             <span># 视图组件的文件夹</span>\n    │   ├── admin             <span># 视图组件的文件夹</span>\n    │   │   ├── components\n    │   │   └── index.vue\n    │   ├── editor            <span># 视图组件的文件夹</span>\n    │   │   └── index.vue\n    │   └── index.vue\n    └── error-page            <span># 视图组件的文件夹</span>\n        ├── <span>401</span>.vue\n        └── <span>404</span>.vue\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h3 id=\"vue-组件命名\"> Vue 组件命名</h3>\n<h4 id=\"_1-单文件组件名\"> 1）单文件组件名</h4>\n<p>文件扩展名为 <code>.vue</code> 的 <code>single-file components</code>（单文件组件）。单文件组件名应该始终是<strong>单词大写开头</strong>（PascalCase）。</p>\n<p>推荐：</p>\n<div><pre><code>src/\n├── MyComponent.vue\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h4 id=\"_2-单例组件名\"> 2）单例组件名</h4>\n<p><strong>只拥有单个活跃实例的组件应该以 <code>The</code> 前缀命名，以示其唯一性</strong>。</p>\n<p>这不意味着组件只可用于一个单页面，而是每个页面只使用一次。这些组件永远不接受任何 prop，因为它们是为你的应用定制的。如果你发现有必要添加 prop，那就表明这实际上是一个可复用的组件，只是目前在每个页面里只使用一次。</p>\n<p>比如，头部和侧边栏组件几乎在每个页面都会使用，不接受 prop，该组件是专门为该应用所定制的。</p>\n<p>推荐：</p>\n<div><pre><code>components/\n├── TheHeading.vue\n├── TheSidebar.vue\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>不推荐：</p>\n<div><pre><code>components/\n├── Heading.vue\n├── MySidebar.vue\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id=\"_3-基础组件名\"> 3）基础组件名</h4>\n<blockquote>\n<p>基础组件：不包含业务，独立、具体功能的基础组件，比如<strong>日期选择器</strong>、<strong>模态框</strong>等。\n这类组件作为项目的基础控件，会被大量使用，因此组件的 API 进行过高强度的抽象，可以通过不同配置实现不同的功能。</p>\n</blockquote>\n<p>应用特定样式和约定的基础组件（也就是展示类的、无逻辑的或无状态、不掺杂业务逻辑的组件）应该全部以一个特定的前缀开头，比如 <code>Base</code>、<code>App</code> 或 <code>V</code>。</p>\n<p><strong>基础组件在一个页面内可使用多次，在不同页面内也可复用，是高可复用组件</strong>。</p>\n<p>推荐：</p>\n<div><pre><code>components/\n├── BaseButton.vue\n├── BaseTable.vue\n├── BaseIcon.vue\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>不推荐：</p>\n<div><pre><code>components/\n├── MyButton.vue\n├── VueTable.vue\n├── Icon.vue\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id=\"_4-业务组件名\"> 4）业务组件名</h4>\n<blockquote>\n<p>业务组件：它不像基础组件只包含某个功能，而是在业务中被多个页面复用的（具有可复用性）。\n它与基础组件的区别是：业务组件只在当前项目中会用到，不具有通用性，而且会包含一些业务，比如数据请求；而基础组件不含业务，在任何项目中都可以使用，功能单一，比如一个具有数据校验功能的输入框。</p>\n</blockquote>\n<p><strong>掺杂了复杂业务的组件（拥有自身 <code>data</code>、<code>prop</code> 的相关处理）即业务组件</strong>。应该以 <code>Custom</code> 前缀命名。</p>\n<p>业务组件在一个页面内比如：某个页面内有一个卡片列表，而样式和逻辑跟业务紧密相关的卡片就是业务组件。</p>\n<p>推荐：</p>\n<div><pre><code>components/\n├── CustomCard.vue\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h4 id=\"_5-紧密耦合的组件名\"> 5）紧密耦合的组件名</h4>\n<p>该类组件只在某个父组件的场景下有意义，这层关系应该体现在其名字上。因为编辑器通常会按字母顺序组织文件，所以这样做可以把相关联的文件排在一起。</p>\n<p><strong>和父组件紧密耦合的子组件一般以父组件名作为前缀命名</strong>。</p>\n<p>推荐：</p>\n<div><pre><code>components/\n├── TodoList.vue\n├── TodoListItem.vue\n├── TodoListItemButton.vue\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>不推荐：</p>\n<div><pre><code>components/\n├── TodoList.vue\n├── ItemForTodoList.vue\n├── ButtonForTodoListItem.vue\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id=\"_6-组件名中单词顺序\"> 6）组件名中单词顺序</h4>\n<p><strong>组件名应该以高级别的（通常是一般化描述的）单词开头，以描述性的修饰词结尾</strong>。因为编辑器通常会按字母顺序组织文件，所以现在组件之间的重要关系一目了然。</p>\n<p>这个表达比较抽象，下面以搜索和设置功能的组件为例，解释什么叫「高级别」。</p>\n<p>推荐：</p>\n<div><pre><code>components/\n├── SearchButtonClear.vue\n├── SearchButtonRun.vue\n├── SearchInputQuery.vue\n├── SearchInputExcludeGlob.vue\n├── SettingsCheckboxTerms.vue\n├── SettingsCheckboxLaunchOnStartup.vue\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>不推荐：</p>\n<div><pre><code>components/\n├── ClearSearchButton.vue\n├── ExcludeFromSearchInput.vue\n├── LaunchOnStartupCheckbox.vue\n├── RunSearchButton.vue\n├── SearchInput.vue\n├── TermsCheckbox.vue\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>还有另一种多级目录的方式，把所有的搜索组件放到 <code>search/</code> 目录，把所有的设置组件放到 <code>settings/</code> 目录。我们只推荐在非常大型（如有 100+ 个组件）的应用下才考虑这么做，因为在多级目录间找来找去，要比在单个 components 目录下滚动查找花费的精力更多。</p>\n<h4 id=\"_7-组件名使用完整单词\"> 7）组件名使用完整单词</h4>\n<p><strong>组件名应该倾向于完整单词而不是缩写</strong>，这样便于团队合作与后期维护。编辑器中的自动补全已经让书写长命名的代价非常之低了，而其带来的明确性却是非常宝贵的。不常用的缩写尤其应该避免。</p>\n<p>推荐：</p>\n<div><pre><code>components/\n├── StudentDashboardSettings.vue\n├── UserProfileOptions.vue\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>不推荐：</p>\n<div><pre><code>components/\n├── SdSettings.vue\n├── UProfOpts.vue\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id=\"_8-视图组件名\"> 8）视图组件名</h4>\n<blockquote>\n<p>视图文件夹：位于 <code>views/</code> 文件夹下，代表着一类页面的名字，存放视图组件。\n视图组件：代表着某一页面的名字，或者类名。\n视图组件与其它组件的区别是：视图组件位于 <code>view/</code> 文件夹或视图文件夹下，其它组件位于 <code>components/</code> 文件夹下。</p>\n</blockquote>\n<ul>\n<li>视图组件可以直接位于 <code>views/</code> 文件夹下，例如：<code>Login.vue</code>、<code>Home.vue</code>。</li>\n<li>视图文件夹的名字要代表着页面的名字，例如：<code>login/</code>、<code>error-page/</code>。</li>\n<li>视图文件夹下只有一个视图组件的时候，该组件取名为 <code>index.vue</code>，例如：<code>login/index.vue</code>。</li>\n<li>视图文件夹下有两个以上视图组件的时候，分别取名，要体现内部文件的所属类名，例如：<code>car/car-list.vue</code> 和 <code>car/car-detail.vue</code>。</li>\n<li>尽量是名词。</li>\n<li>常用结尾单词有（<code>detail</code>、<code>edit</code>、<code>list</code>、<code>info</code>、<code>report</code>）。</li>\n<li>视图文件夹下可以存在私有 <code>components/</code>，其内部 <code>.vue</code> 文件遵循其它组件的命名方式（大驼峰）。</li>\n<li>除 <code>components/</code> 下的，一律采用 kebab-case 的风格。</li>\n</ul>\n<p>例如：</p>\n<div><pre><code>src/\n├── components\n│   ├── BackToTop               <span># 通用组件的文件夹</span>\n│   └── Charts                  <span># 通用组件的文件夹</span>\n│       ├── Keyboard.vue\n│       ├── LineMarker.vue\n│       ├── MixChart.vue\n│       └── mixins              <span># 其它文件夹</span>\n└── views\n    ├── login                   <span># 视图组件的文件夹</span>\n    │   └── index.vue\n    ├── profile                 <span># 视图组件的文件夹</span>\n    │   ├── index.vue\n    │   └── components\n    ├── car                     <span># 视图组件的文件夹</span>\n    │   ├── car-list.vue        <span># 视图组件</span>\n    │   ├── car-detail.vue      <span># 视图组件</span>\n    │   └── components\n    │       ├── CarListItem.vue\n    │       └── CarInfoItem.vue\n    └── error-page              <span># 视图组件的文件夹</span>\n        ├── <span>401</span>.vue             <span># 视图组件</span>\n        └── <span>404</span>.vue             <span># 视图组件</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h3 id=\"vue-组件内部参数命名\"> Vue 组件内部参数命名</h3>\n<h4 id=\"_1-name\"> 1）name</h4>\n<p><strong>组件名应该始终是多个单词，应该始终是 PascalCase 的</strong>。根组件 App 以及 <code>&lt;transition&gt;</code>、<code>&lt;component&gt;</code> 之类的 Vue 内置组件除外。这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。</p>\n<p>推荐：</p>\n<div><pre><code><span>export</span> <span>default</span> <span>{</span>\n  name<span>:</span> <span>'ToDoList'</span><span>,</span>\n  <span>// ...</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id=\"_2-prop\"> 2）prop</h4>\n<p><strong>在声明 prop 的时候，其命名应该始终使用 camelCase，而在模板和 JSX 中应该始终使用 kebab-case</strong>。我们单纯的遵循每个语言的约定，在 JavaScript 中更自然的是 camelCase。而在 HTML 中则是 kebab-case。</p>\n<p>推荐：</p>\n<div><pre><code><span><span><span>&lt;</span>WelcomeMessage</span> <span>greeting-text</span><span><span>=</span><span>\"</span>hi<span>\"</span></span><span>/></span></span>\n</code></pre>\n<div><span>1</span><br></div></div><div><pre><code><span>export</span> <span>default</span> <span>{</span>\n  name<span>:</span> <span>'MyComponent'</span><span>,</span>\n  <span>// ...</span>\n  props<span>:</span> <span>{</span>\n    greetingText<span>:</span> <span>{</span>\n      type<span>:</span> String<span>,</span>\n      required<span>:</span> <span>true</span><span>,</span>\n      <span>validator</span><span>:</span> <span>function</span> <span>(</span><span>value</span><span>)</span> <span>{</span>\n        <span>return</span> <span>[</span><span>'syncing'</span><span>,</span> <span>'synced'</span><span>,</span><span>]</span><span>.</span><span>indexOf</span><span>(</span>value<span>)</span> <span>!==</span> <span>-</span><span>1</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h4 id=\"_3-router\"> 3）router</h4>\n<p><strong>Vue Router Path 命名采用 kebab-case 格式</strong>。用 Snake（如：<code>/user_info</code>）或 camelCase（如：<code>/userInfo</code>)的单词会被当成一个单词，搜索引擎无法区分语义。</p>\n<p>推荐：</p>\n<div><pre><code><span>{</span>\n  path<span>:</span> <span>'/user-info'</span><span>,</span> <span>// user-info 能被搜索引擎解析成 user info</span>\n  name<span>:</span> <span>'UserInfo'</span><span>,</span>\n  component<span>:</span> UserInfo<span>,</span>\n  meta<span>:</span> <span>{</span>\n    title<span>:</span> <span>' - 用户'</span><span>,</span>\n    desc<span>:</span> <span>''</span>\n  <span>}</span>\n<span>}</span><span>,</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>不推荐：</p>\n<div><pre><code><span>// bad</span>\n<span>{</span>\n  path<span>:</span> <span>'/user_info'</span><span>,</span> <span>// user_info 被搜索引擎当成一个单词</span>\n  name<span>:</span> <span>'UserInfo'</span><span>,</span>\n  component<span>:</span> UserInfo<span>,</span>\n  meta<span>:</span> <span>{</span>\n    title<span>:</span> <span>' - 用户'</span><span>,</span>\n    desc<span>:</span> <span>''</span>\n  <span>}</span>\n<span>}</span><span>,</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h4 id=\"_4-模板中组件\"> 4）模板中组件</h4>\n<p>对于绝大多数项目来说，在单文件组件和字符串模板中组件名应该总是 PascalCase 的，但是在 DOM 模板中总是 kebab-case 的。</p>\n<p>推荐：</p>\n<div><pre><code><span>&lt;!-- 在单文件组件和字符串模板中 --></span> \n<span><span><span>&lt;</span>MyComponent</span><span>/></span></span>\n\n<span>&lt;!-- 在 DOM 模板中 --></span> \n<span><span><span>&lt;</span>my-component</span><span>></span></span><span><span><span>&lt;/</span>my-component</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id=\"_5-自闭合组件\"> 5）自闭合组件</h4>\n<p>在单文件组件、字符串模板和 JSX 中没有内容的组件应该是自闭合的 —— 但在 DOM 模板里永远不要这样做。</p>\n<p>推荐：</p>\n<div><pre><code><span>&lt;!-- 在单文件组件和字符串模板中 --></span>\n<span><span><span>&lt;</span>MyComponent</span><span>/></span></span>\n\n<span>&lt;!-- 在所有地方 --></span>\n<span><span><span>&lt;</span>my-component</span><span>></span></span><span><span><span>&lt;/</span>my-component</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id=\"_6-变量\"> 6）变量</h4>\n<ul>\n<li>命名方法：camelCase</li>\n<li>命名规范：类型 + 对象描述或属性的方式</li>\n</ul>\n<p>推荐：</p>\n<div><pre><code><span>let</span> tableTitle <span>=</span> <span>\"LoginTable\"</span>\n<span>let</span> mySchool <span>=</span> <span>\"我的学校\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>不推荐：</p>\n<div><pre><code><span>var</span> getTitle <span>=</span> <span>\"LoginTable\"</span>\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"_7-常量\"> 7）常量</h4>\n<ul>\n<li>命名方法：全部大写下划线分割</li>\n<li>命名规范：使用大写字母和下划线来组合命名，下划线用以分割单词</li>\n</ul>\n<p>推荐：</p>\n<div><pre><code><span>const</span> <span>MAX_COUNT</span> <span>=</span> <span>10</span>\n<span>const</span> <span>URL</span> <span>=</span> <span>'https://www.fedbook.cn'</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h4 id=\"_8-方法\"> 8）方法</h4>\n<ul>\n<li>命名方法：camelCase</li>\n<li>命名规范：统一使用动词或者动词 + 名词形式</li>\n</ul>\n<p><strong>1）普通情况下，使用动词 + 名词形式</strong></p>\n<p>推荐：<code>jumpPage</code>、<code>openCarInfoDialog</code></p>\n<p>不推荐：<code>go</code>、<code>nextPage</code>、<code>show</code>、<code>open</code>、<code>login</code></p>\n<p><strong>2）请求数据方法，以 data 结尾</strong></p>\n<p>推荐：<code>getListData</code>、<code>postFormData</code></p>\n<p>不推荐：<code>takeData</code>、<code>confirmData</code>、<code>getList</code>、<code>postForm</code></p>\n<p><strong>3）单个动词的情况</strong></p>\n<p>推荐：<code>init</code>、<code>refresh</code></p>\n<table>\n<thead>\n<tr>\n<th>动词</th>\n<th>含义</th>\n<th>返回值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>can</td>\n<td>判断是否可执行某个动作（权）</td>\n<td>函数返回一个布尔值。true：可执行；false：不可执行。</td>\n</tr>\n<tr>\n<td>has</td>\n<td>判断是否含有某个值</td>\n<td>函数返回一个布尔值。true：含有此值；false：不含有此值。</td>\n</tr>\n<tr>\n<td>is</td>\n<td>判断是否为某个值</td>\n<td>函数返回一个布尔值。true：为某个值；false：不为某个值。</td>\n</tr>\n<tr>\n<td>get</td>\n<td>获取某个值</td>\n<td>函数返回一个非布尔值。</td>\n</tr>\n<tr>\n<td>set</td>\n<td>设置某个值</td>\n<td>无返回值、返回是否设置成功或者返回链式对象。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"_9-自定义事件\"> 9）自定义事件</h4>\n<p><strong>自定义事件应始终使用 kebab-case 的事件名</strong>。</p>\n<p>不同于组件和 prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。</p>\n<div><pre><code><span><span><span>&lt;</span>MyComponent</span> <span>@my-event</span><span><span>=</span><span>\"</span>handleDoSomething<span>\"</span></span> <span>/></span></span>\n</code></pre>\n<div><span>1</span><br></div></div><div><pre><code><span>this</span><span>.</span><span>$emit</span><span>(</span><span>'my-event'</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>不同于组件和 prop，事件名不会被用作一个 JavaScript 变量名或 property 名，所以就没有理由使用 camelCase 或 PascalCase 了。并且 <code>v-on</code> 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以 <code>v-on:myEvent</code> 将会变成 <code>v-on:myevent</code> —— 导致 <code>myEvent</code> 不可能被监听到。</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Events\" title=\"原生事件参考列表\" target=\"_blank\" rel=\"noopener noreferrer\">原生事件参考列表</a></li>\n</ul>\n<p>由原生事件可以发现其使用方式如下：</p>\n<div><pre><code><span><span><span>&lt;</span>div</span>\n  <span>@blur</span><span><span>=</span><span>\"</span>toggleHeaderFocus<span>\"</span></span>\n  <span>@focus</span><span><span>=</span><span>\"</span>toggleHeaderFocus<span>\"</span></span>\n  <span>@click</span><span><span>=</span><span>\"</span>toggleMenu<span>\"</span></span>\n  <span>@keydown.esc</span><span><span>=</span><span>\"</span>handleKeydown<span>\"</span></span>\n  <span>@keydown.enter</span><span><span>=</span><span>\"</span>handleKeydown<span>\"</span></span>\n  <span>@keydown.up.prevent</span><span><span>=</span><span>\"</span>handleKeydown<span>\"</span></span>\n  <span>@keydown.down.prevent</span><span><span>=</span><span>\"</span>handleKeydown<span>\"</span></span>\n  <span>@keydown.tab</span><span><span>=</span><span>\"</span>handleKeydown<span>\"</span></span>\n  <span>@keydown.delete</span><span><span>=</span><span>\"</span>handleKeydown<span>\"</span></span>\n  <span>@mouseenter</span><span><span>=</span><span>\"</span>hasMouseHoverHead = true<span>\"</span></span>\n  <span>@mouseleave</span><span><span>=</span><span>\"</span>hasMouseHoverHead = false<span>\"</span></span><span>></span></span>\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>而为了区分<strong>原生事件</strong>和<strong>自定义事件</strong>在 Vue 中的使用，建议除了多单词事件名使用 kebab-case 的情况下，自定义事件的命名还需遵守 <strong><code>on</code> + 动词</strong> 的形式，如下：</p>\n<div><pre><code><span>&lt;!-- 父组件 --></span>\n<span><span><span>&lt;</span>div</span>\n  <span>@on-search</span><span><span>=</span><span>\"</span>handleSearch<span>\"</span></span>\n  <span>@on-clear</span><span><span>=</span><span>\"</span>handleClear<span>\"</span></span>\n  <span>@on-clickoutside</span><span><span>=</span><span>\"</span>handleClickOutside<span>\"</span></span><span>></span></span>\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code><span>// 子组件</span>\n<span>export</span> <span>default</span> <span>{</span>\n  methods<span>:</span> <span>{</span>\n    <span>handleTriggerItem</span> <span>(</span><span>)</span> <span>{</span>\n      <span>this</span><span>.</span><span>$emit</span><span>(</span><span>'on-clear'</span><span>)</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h4 id=\"_10-事件方法\"> 10）事件方法</h4>\n<ul>\n<li>命名方法：camelCase</li>\n<li>命名规范：handle + 名称（可选）+ 动词</li>\n</ul>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span>\n    <span>@click.native.stop</span><span><span>=</span><span>\"</span>handleItemClick()<span>\"</span></span>\n    <span>@mouseenter.native.stop</span><span><span>=</span><span>\"</span>handleItemHover()<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n\n<span>export</span> <span>default</span> <span>{</span>\n  methods<span>:</span> <span>{</span>\n    <span>handleItemClick</span> <span>(</span><span>)</span> <span>{</span>\n      <span>//...</span>\n    <span>}</span><span>,</span>\n    <span>handleItemHover</span> <span>(</span><span>)</span> <span>{</span>\n      <span>//...</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h2 id=\"vue-代码规范\"> Vue 代码规范</h2>\n<h3 id=\"代码结构\"> 代码结构</h3>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>\"</span>my-component<span>\"</span></span><span>></span></span>\n    <span><span><span>&lt;</span>DemoComponent</span> <span>/></span></span>\n  <span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>import</span> DemoComponent <span>from</span> <span>'../components/DemoComponent'</span>\n\n<span>export</span> <span>default</span> <span>{</span>\n  name<span>:</span> <span>'MyComponent'</span><span>,</span>\n  components<span>:</span> <span>{</span>\n    DemoComponent\n  <span>}</span><span>,</span>\n  mixins<span>:</span> <span>[</span><span>]</span><span>,</span>\n  props<span>:</span> <span>{</span><span>}</span><span>,</span>\n  <span>data</span> <span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>{</span><span>}</span>\n  <span>}</span><span>,</span>\n  computed<span>:</span> <span>{</span><span>}</span><span>,</span>\n  watch<span>:</span> <span>{</span><span>}</span><span>,</span>\n  <span>created</span> <span>(</span><span>)</span> <span>{</span><span>}</span><span>,</span>\n  <span>mounted</span> <span>(</span><span>)</span> <span>{</span><span>}</span><span>,</span>\n  <span>destroyed</span> <span>(</span><span>)</span> <span>{</span><span>}</span><span>,</span>\n  methods<span>:</span> <span>{</span><span>}</span><span>,</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n\n<span><span><span>&lt;</span>style</span> <span>lang</span><span><span>=</span><span>\"</span>scss<span>\"</span></span> <span>scoped</span><span>></span></span><span><span>\n<span>#my-component</span> <span>{</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><h3 id=\"书写顺序\"> 书写顺序</h3>\n<h4 id=\"_1-元素-attribute-顺序\"> 1）元素 attribute 顺序</h4>\n<p>这是 Vue 官方为组件选项推荐的默认顺序。它们被划分为几大类，所以你也能知道新添加的自定义 attribute 和指令应该放到哪里。</p>\n<ul>\n<li><strong>定义</strong>（提供组件的选项）\n<ul>\n<li><code>is</code></li>\n</ul>\n</li>\n<li><strong>列表渲染</strong>（创建多个变化的相同元素)\n<ul>\n<li><code>v-for</code></li>\n</ul>\n</li>\n<li><strong>条件渲染</strong>（元素是否渲染/显示）\n<ul>\n<li><code>v-if</code></li>\n<li><code>v-else-if</code></li>\n<li><code>v-else</code></li>\n<li><code>v-show</code></li>\n<li><code>v-cloak</code></li>\n</ul>\n</li>\n<li><strong>渲染方式</strong>（改变元素的渲染方式）\n<ul>\n<li><code>v-pre</code></li>\n<li><code>v-once</code></li>\n</ul>\n</li>\n<li><strong>全局感知</strong>（需要超越组件的知识）\n<ul>\n<li><code>id</code></li>\n</ul>\n</li>\n<li><strong>唯一的 attribute</strong>（需要唯一值的 attribute）\n<ul>\n<li><code>ref</code></li>\n<li><code>key</code></li>\n</ul>\n</li>\n<li><strong>双向绑定</strong>（把绑定和事件结合起来）\n<ul>\n<li><code>v-model</code></li>\n</ul>\n</li>\n<li><strong>其它 attribute</strong>（所有普通的绑定或未绑定的 attribute）</li>\n<li><strong>事件</strong>（组件事件监听器）\n<ul>\n<li><code>v-on</code></li>\n</ul>\n</li>\n<li><strong>内容</strong>（覆写元素的内容）\n<ul>\n<li><code>v-html</code></li>\n<li><code>v-text</code></li>\n</ul>\n</li>\n</ul>\n<p>注意：不推荐同时使用 <code>v-if</code> 和 <code>v-for</code>。</p>\n<h4 id=\"_2-组件方法顺序\"> 2）组件方法顺序</h4>\n<p>这是 Vue 官方推荐的组件选项默认顺序。它们被划分为几大类，所以你也能知道从插件里添加的新 property 应该放到哪里。</p>\n<ul>\n<li><strong>副作用</strong>（触发组件外的影响）\n<ul>\n<li><code>el</code></li>\n</ul>\n</li>\n<li><strong>全局感知</strong>（要求组件以外的知识）\n<ul>\n<li><code>name</code></li>\n<li><code>parent</code></li>\n</ul>\n</li>\n<li><strong>组件类型</strong>（更改组件的类型）\n<ul>\n<li><code>functional</code></li>\n</ul>\n</li>\n<li><strong>模板修改器</strong>（改变模板的编译方式）\n<ul>\n<li><code>delimiters</code></li>\n<li><code>comments</code></li>\n</ul>\n</li>\n<li><strong>模板依赖</strong>（模板内使用的资源）\n<ul>\n<li><code>components</code></li>\n<li><code>directives</code></li>\n<li><code>filters</code></li>\n</ul>\n</li>\n<li><strong>组合</strong>（向选项里合并 property）\n<ul>\n<li><code>extends</code></li>\n<li><code>mixins</code></li>\n</ul>\n</li>\n<li><strong>接口</strong>（组件的接口）\n<ul>\n<li><code>inheritAttrs</code></li>\n<li><code>model</code></li>\n<li><code>props</code> / <code>propsData</code></li>\n</ul>\n</li>\n<li><strong>本地状态</strong>（本地的响应式 property）\n<ul>\n<li><code>data</code></li>\n<li><code>computed</code></li>\n</ul>\n</li>\n<li><strong>事件</strong>（通过响应式事件触发的回调）\n<ul>\n<li><code>watch</code></li>\n<li>生命周期钩子（按照它们被调用的顺序）\n<ul>\n<li><code>beforeCreated</code></li>\n<li><code>created</code></li>\n<li><code>beforeMount</code></li>\n<li><code>mounted</code></li>\n<li><code>beforeUpdate</code></li>\n<li><code>updated</code></li>\n<li><code>activated</code></li>\n<li><code>deactivated</code></li>\n<li><code>beforeDestroy</code></li>\n<li><code>destroyed</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>非响应式的 property</strong>（不依赖响应系统的实例 property）\n<ul>\n<li><code>methods</code></li>\n</ul>\n</li>\n<li><strong>渲染</strong>（组件输出的声明式描述）\n<ul>\n<li><code>templated</code> / <code>render</code></li>\n<li><code>renderError</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"书写格式\"> 书写格式</h3>\n<h4 id=\"_1-多个-attribute-的元素\"> 1）多个 attribute 的元素</h4>\n<p>多个 attribute 的元素应该分多行撰写，每个 attribute 一行。</p>\n<p>推荐：</p>\n<div><pre><code><span><span><span>&lt;</span>img</span>\n  <span>src</span><span><span>=</span><span>\"</span>https://vuejs.org/images/logo.png<span>\"</span></span>\n  <span>alt</span><span><span>=</span><span>\"</span>Vue Logo<span>\"</span></span><span>></span></span>\n\n<span><span><span>&lt;</span>MyComponent</span>\n  <span>foo</span><span><span>=</span><span>\"</span>a<span>\"</span></span>\n  <span>bar</span><span><span>=</span><span>\"</span>b<span>\"</span></span>\n  <span>baz</span><span><span>=</span><span>\"</span>c<span>\"</span></span><span>/></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>不推荐：</p>\n<div><pre><code><span><span><span>&lt;</span>img</span> <span>src</span><span><span>=</span><span>\"</span>https://vuejs.org/images/logo.png<span>\"</span></span> <span>alt</span><span><span>=</span><span>\"</span>Vue Logo<span>\"</span></span><span>></span></span>\n<span><span><span>&lt;</span>MyComponent</span> <span>foo</span><span><span>=</span><span>\"</span>a<span>\"</span></span> <span>bar</span><span><span>=</span><span>\"</span>b<span>\"</span></span> <span>baz</span><span><span>=</span><span>\"</span>c<span>\"</span></span><span>/></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h4 id=\"_2-模板中简单的表达式\"> 2）模板中简单的表达式</h4>\n<p><strong>组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法</strong>。</p>\n<p>复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的<strong>是什么</strong>，而非<strong>如何</strong>计算那个值。而且计算属性和方法使得代码可以重用。</p>\n<p>推荐：</p>\n<div><pre><code><span>&lt;!-- 在模板中 --></span>\n{{ normalizedFullName }}\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><div><pre><code><span>// 复杂表达式已经移入一个计算属性</span>\ncomputed<span>:</span> <span>{</span>\n  <span>normalizedFullName</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span>fullName<span>.</span><span>split</span><span>(</span><span>' '</span><span>)</span><span>.</span><span>map</span><span>(</span><span>function</span> <span>(</span><span>word</span><span>)</span> <span>{</span>\n      <span>return</span> word<span>[</span><span>0</span><span>]</span><span>.</span><span>toUpperCase</span><span>(</span><span>)</span> <span>+</span> word<span>.</span><span>slice</span><span>(</span><span>1</span><span>)</span>\n    <span>}</span><span>)</span><span>.</span><span>join</span><span>(</span><span>' '</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>不推荐：</p>\n<div><pre><code><span>&lt;!-- 在模板中 --></span>\n{{\n  fullName.split(' ').map((word) => {\n    return word[0].toUpperCase() + word.slice(1)\n  }).join(' ')\n}}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id=\"_3-带引号的-attribute-值\"> 3）带引号的 attribute 值</h4>\n<p>非空 HTML 特性值应该始终带双引号。</p>\n<p>推荐：</p>\n<div><pre><code><span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>\"</span>text<span>\"</span></span><span>></span></span>\n<span><span><span>&lt;</span>AppSidebar</span> <span>:style</span><span><span>=</span><span>\"</span>{ width: sidebarWidth + <span>'</span>px<span>'</span> }<span>\"</span></span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>不推荐：</p>\n<div><pre><code><span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span>text</span><span>></span></span>\n&lt;AppSidebar :style={width:sidebarWidth+'px'}>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h4 id=\"_4-指令缩写\"> 4）指令缩写</h4>\n<ul>\n<li>用 <code>:</code> 表示 <code>v-bind:</code></li>\n<li>用 <code>@</code> 表示 <code>v-on:</code></li>\n<li>用 <code>#</code> 表示 <code>v-slot:</code></li>\n</ul>\n<div><pre><code><span><span><span>&lt;</span>input</span>\n  <span>:value</span><span><span>=</span><span>\"</span>newTodoText<span>\"</span></span>\n  <span>:placeholder</span><span><span>=</span><span>\"</span>newTodoInstructions<span>\"</span></span><span>></span></span>\n\n<span><span><span>&lt;</span>input</span>\n  <span>@input</span><span><span>=</span><span>\"</span>onInput<span>\"</span></span>\n  <span>@focus</span><span><span>=</span><span>\"</span>onFocus<span>\"</span></span><span>></span></span>\n\n<span><span><span>&lt;</span>template</span> <span>#header</span><span>></span></span>\n  <span><span><span>&lt;</span>h1</span><span>></span></span>Here might be a page title<span><span><span>&lt;/</span>h1</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>template</span> <span>#footer</span><span>></span></span>\n  <span><span><span>&lt;</span>p</span><span>></span></span>Here's some contact info<span><span><span>&lt;/</span>p</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id=\"赋值要求\"> 赋值要求</h3>\n<h4 id=\"_1-data\"> 1）data</h4>\n<p>组件的 <code>data</code> 必须是一个函数。</p>\n<div><pre><code><span>// In a .vue file</span>\n<span>export</span> <span>default</span> <span>{</span>\n  <span>data</span> <span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>{</span>\n      foo<span>:</span> <span>'bar'</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h4 id=\"_2-prop-2\"> 2）prop</h4>\n<p>Prop 定义应该尽量详细。</p>\n<div><pre><code><span>export</span> <span>default</span> <span>{</span>\n  props<span>:</span> <span>{</span>\n    status<span>:</span> <span>{</span>\n      type<span>:</span> String<span>,</span>\n      required<span>:</span> <span>true</span><span>,</span>\n      <span>validator</span><span>:</span> <span>function</span> <span>(</span><span>value</span><span>)</span> <span>{</span>\n        <span>return</span> <span>[</span>\n          <span>'syncing'</span><span>,</span> \n          <span>'synced'</span><span>,</span>\n          <span>'version-conflict'</span><span>,</span>\n          <span>'error'</span>\n        <span>]</span><span>.</span><span>indexOf</span><span>(</span>value<span>)</span> <span>!==</span> <span>-</span><span>1</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h4 id=\"_3-computed\"> 3）computed</h4>\n<p><strong>应该把复杂计算属性分割为尽可能多的更简单的属性</strong>。小的、专注的计算属性减少了信息使用时的假设性限制，所以需求变更时也用不着那么多重构了。</p>\n<p>推荐：</p>\n<div><pre><code>computed<span>:</span> <span>{</span>\n  <span>basePrice</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span>manufactureCost <span>/</span> <span>(</span><span>1</span> <span>-</span> <span>this</span><span>.</span>profitMargin<span>)</span>\n  <span>}</span><span>,</span>\n  <span>discount</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span>basePrice <span>*</span> <span>(</span><span>this</span><span>.</span>discountPercent <span>||</span> <span>0</span><span>)</span>\n  <span>}</span><span>,</span>\n  <span>finalPrice</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span>basePrice <span>-</span> <span>this</span><span>.</span>discount\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>不推荐：</p>\n<div><pre><code>computed<span>:</span> <span>{</span> \n  <span>price</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span> \n    <span>var</span> basePrice <span>=</span> <span>this</span><span>.</span>manufactureCost <span>/</span> <span>(</span><span>1</span> <span>-</span> <span>this</span><span>.</span>profitMargin<span>)</span> \n    <span>return</span> <span>(</span> \n      basePrice <span>-</span> \n      basePrice <span>*</span> <span>(</span><span>this</span><span>.</span>discountPercent <span>||</span> <span>0</span><span>)</span> \n    <span>)</span> \n  <span>}</span> \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"api-用法要求\"> API 用法要求</h3>\n<h4 id=\"_1-为-v-for-设置键值\"> 1）为 <code>v-for</code> 设置键值</h4>\n<p><strong>在组件上必须用 <code>key</code> 搭配 <code>v-for</code></strong>，以便维护内部组件及其子树的状态。甚至在元素上维护可预测的行为，比如动画中的<a href=\"https://bost.ocks.org/mike/constancy/\" target=\"_blank\" rel=\"noopener noreferrer\">对象固化（object constancy）</a>。</p>\n<div><pre><code><span><span><span>&lt;</span>ul</span><span>></span></span>\n  <span><span><span>&lt;</span>li</span>\n    <span>v-for</span><span><span>=</span><span>\"</span>todo in todos<span>\"</span></span>\n    <span>:key</span><span><span>=</span><span>\"</span>todo.id<span>\"</span></span><span>></span></span>\n      {{ todo.text }}\n  <span><span><span>&lt;/</span>li</span><span>></span></span>\n<span><span><span>&lt;/</span>ul</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h4 id=\"_2-v-if-和-v-for-互斥\"> 2）<code>v-if</code> 和 <code>v-for</code> 互斥</h4>\n<p>永远不要把 <code>v-if</code> 和 <code>v-for</code> 同时用在同一个元素上。</p>\n<p>不推荐（控制台会报错）：</p>\n<div><pre><code><span><span><span>&lt;</span>ul</span><span>></span></span>\n  <span><span><span>&lt;</span>li</span>\n    <span>v-for</span><span><span>=</span><span>\"</span>user in users<span>\"</span></span>\n    <span>v-if</span><span><span>=</span><span>\"</span>shouldShowUsers<span>\"</span></span>\n    <span>:key</span><span><span>=</span><span>\"</span>user.id<span>\"</span></span><span>></span></span>\n      {{ user.name }}\n  <span><span><span>&lt;/</span>li</span><span>></span></span>\n<span><span><span>&lt;/</span>ul</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>一般我们在两种常见的情况下会倾向于这样做：</p>\n<ul>\n<li>为了过滤一个列表中的项目（比如 <code>v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;</code>）。在这种情形下，请将 <code>users</code> 替换为一个计算属性（比如 <code>activeUsers</code>），让其返回过滤后的列表。</li>\n</ul>\n<p>推荐：</p>\n<div><pre><code><span><span><span>&lt;</span>ul</span><span>></span></span>\n  <span><span><span>&lt;</span>li</span>\n    <span>v-for</span><span><span>=</span><span>\"</span>user in activeUsers<span>\"</span></span>\n    <span>:key</span><span><span>=</span><span>\"</span>user.id<span>\"</span></span><span>></span></span>\n      {{ user.name }}\n  <span><span><span>&lt;/</span>li</span><span>></span></span>\n<span><span><span>&lt;/</span>ul</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><div><pre><code>computed<span>:</span> <span>{</span>\n  <span>activeUsers</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span>users<span>.</span><span>filter</span><span>(</span><span>(</span><span>user</span><span>)</span> <span>=></span> <span>{</span>\n      <span>return</span> user<span>.</span>isActive\n    <span>}</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>\n<li>为了避免渲染本应该被隐藏的列表（比如 <code>v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;</code>）。这种情形下，请将 <code>v-if</code> 移动至容器元素上（比如 <code>ul</code>，<code>ol</code>）。</li>\n</ul>\n<p>推荐：</p>\n<div><pre><code><span><span><span>&lt;</span>ul</span> <span>v-if</span><span><span>=</span><span>\"</span>shouldShowUsers<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>li</span>\n    <span>v-for</span><span><span>=</span><span>\"</span>user in users<span>\"</span></span>\n    <span>:key</span><span><span>=</span><span>\"</span>user.id<span>\"</span></span><span>></span></span>\n      {{ user.name }}\n  <span><span><span>&lt;/</span>li</span><span>></span></span>\n<span><span><span>&lt;/</span>ul</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>不推荐：</p>\n<div><pre><code><span><span><span>&lt;</span>ul</span><span>></span></span>\n  <span><span><span>&lt;</span>li</span>\n    <span>v-for</span><span><span>=</span><span>\"</span>user in users<span>\"</span></span>\n    <span>v-if</span><span><span>=</span><span>\"</span>shouldShowUsers<span>\"</span></span>\n    <span>:key</span><span><span>=</span><span>\"</span>user.id<span>\"</span></span><span>></span></span>\n      {{ user.name }}\n  <span><span><span>&lt;/</span>li</span><span>></span></span>\n<span><span><span>&lt;/</span>ul</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>（完）</p>\n",
      "date_published": "2021-02-26T06:03:04.000Z",
      "date_modified": "2022-02-11T09:16:08.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "版本控制",
      "url": "https://www.fedbook.cn/style-guide/version-control/",
      "id": "https://www.fedbook.cn/style-guide/version-control/",
      "content_html": "<h1 id=\"版本控制\"> 版本控制</h1>\n<p>版本控制系统是指对软件开发过程中程序代码、配置文件、文档等发生的变更进行管理的系统，它可以帮助团队更好的沟通协作，从而更好的进行交付，常见的版本控制系统分为集中式版本控制系统（如 SVN）和分布式版本控制系统（如 Git）。</p>\n<p>目前业内大部分团队都使用 Git 作为版本库，管理好代码也是一种学问。尤其是涉及多人并发协作、需要管理多个软件版本的情况下，定义良好的版本库管理规范，可以让大型项目更有组织性，也可以提高成员协作效率。</p>\n<div style=\"text-align: right\">\n  <svg t=\"1637141435644\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"1168\" width=\"64\" height=\"64\"><path d=\"M63.49884471 444.72482676L339.27934283 168.4672005l80.63478137 81.1119106c-11.45109332 40.55595587 7.15693331 84.92894248 44.3729866 106.39974246v264.32940369c-28.62773329 16.22238256-47.7128892 47.23575993-47.71288806 82.54329842a95.42577726 95.42577726 0 0 0 95.42577726 95.42577726 95.42577726 95.42577726 0 0 0 95.42577726-95.42577726c0-35.30753736-19.08515589-66.32091583-47.71288806-82.54329842V388.42361757l98.76567986 99.7199384c-3.33990259 7.15693331-3.33990259 15.26812405-3.33990261 23.85644403a95.42577726 95.42577726 0 0 0 95.42577728 95.42577726 95.42577726 95.42577726 0 0 0 95.42577839-95.42577726 95.42577726 95.42577726 0 0 0-95.42577839-95.42577726c-8.58831998 0-16.69951071 0-23.85644403 3.33990146L604.0858758 297.2920003a94.47151987 94.47151987 0 0 0-54.86982251-111.64815985c-20.51654257-7.63406259-41.98734253-9.54257739-61.07249732-4.29415998L407.03164421 100.71489799l37.69318255-37.21605328c37.21605328-37.69318254 97.3342932-37.69318254 134.55034648 0l381.22598205 381.22598205c37.69318254 37.21605328 37.69318254 97.3342932 0 134.55034648l-381.22598205 381.22598205c-37.21605328 37.69318254-97.3342932 37.69318254-134.55034648 0L63.49884471 579.27517324c-37.69318254-37.21605328-37.69318254-97.3342932 0-134.55034648z\" fill=\"#E64A19\" p-id=\"1169\"></path></svg>\n</div>\n",
      "date_published": "2021-11-22T09:42:58.000Z",
      "date_modified": "2022-02-11T06:03:23.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "Git 工作流 — 分支策略",
      "url": "https://www.fedbook.cn/style-guide/version-control/git-workflow/",
      "id": "https://www.fedbook.cn/style-guide/version-control/git-workflow/",
      "content_html": "<h1 id=\"git-工作流-分支策略\"> Git 工作流 — 分支策略</h1>\n<h2 id=\"前言\"> 前言</h2>\n<p>设想这样一个场景：某企业的开发团队使用 Git 管理日常开发工作，最初开发团队的代码有一条主干分支（master/main）。后来为了开发新功能，从主干分支拉出一条特性分支，但新功能完成后，该特性分支没有合入主干分支，而是作为下次开发的主干分支，重新拉出一条新的特性分支，导致主干分支一直形同虚设，团队没有一条稳定的代码分支。</p>\n<p>这个问题很大程度上源于团队对分支策略的不了解，导致分支策略使用很混乱。因此，我们需要采用 Git 工作流 —— 分支策略来此类问题。</p>\n<p>目前业界常见的 Git 分支策略主要有：GitFlow、GitHubFlow 以及 GitLabFlow，本文一一作介绍，方便团队开发时，根据自身情况选择最合适的方案。</p>\n<h2 id=\"gitflow-策略\"> GitFlow 策略</h2>\n<p>GitFlow 是这三种分支策略中最早出现的。</p>\n<p>GitFlow 通常包含五种类型的分支：<code>master</code> 分支、<code>develop</code> 分支、<code>feature</code> 分支、<code>release</code> 分支以及 <code>hotfix</code> 分支。</p>\n<h3 id=\"分支定义\"> 分支定义</h3>\n<p><strong>master 分支</strong>：主干分支，这是一个稳定的分支，又称为保护分支，表示正式发布的历史，所有对外正式版本发布都会合并到这里，并打上版本标签。通常情况下只允许其他分支将代码合入，不允许向 <code>master</code> 分支直接提交代码。</p>\n<p><strong>develop 分支</strong>：开发分支，用来用来整合功能分支，表示最新的开发状态。包含要发布到下一个 <code>release</code> 的代码。</p>\n<blockquote>\n<ul>\n<li>注意每次合并到 <code>master</code> 都要打上 tag，方便定位。</li>\n<li><code>master</code> 分支和 <code>develop</code> 分支都是历史分支，用来记录项目的历史记录。相对于这两个分支，下面的其它分支都属于临时分支，这些分支完成自己的使命后就可以被删除。</li>\n</ul>\n</blockquote>\n<p><strong>feature 分支</strong>：功能分支，通常从 <code>develop</code> 分支拉出，每个新功能的开发对应一个功能分支，用于开发人员提交代码并进行自测。自测完成后，会将 <code>feature</code> 分支的代码合并至 <code>develop</code> 分支，进入下一个 <code>release</code>。</p>\n<p><strong>release 分支</strong>：发布分支，发布新版本时，基于 <code>develop</code> 分支创建，从此刻开始新的功能不会加到这个分支，这个分支只应该做 bug 修复、文档生成和其他面向发布的任务。当发布分支足够稳定后，它的生命周期就可以结束了，这时候将 <code>release</code> 分支 合并到 <code>master</code> 分支，然后打上 tag 版本号；接着还需要将 <code>release</code> 分支合并回 <code>develop</code> 分支。</p>\n<blockquote>\n<ul>\n<li><code>release</code> 分支可以删掉，因为在 <code>master</code> 上打了 tag，即使删掉了发布分支，你也可以很方便的重新创建一个：<div><pre><code><span># 基于 tag v1.0.0 创建一个分支</span>\n$ <span>git</span> checkout -b release/v1.0.0 v1.0.0\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div></li>\n<li>release 分支是 develop 和 master 之间的缓冲区，对于一个发布，往往会在发布分支中停留一段时间，等待稳定后才合并到 master。</li>\n<li>release 分支使得团队可以在完善当前发布版本的同时，不阻拦新功能的开发。</li>\n</ul>\n</blockquote>\n<p><strong>hotfix 分支</strong>：热修复分支，生产环境发现新 bug 时创建的临时分支，这些 bug 可能比较紧急，而且跨越多个分支，所以可以创建一个 <code>hotfix</code> 分支快速修复 <code>master</code> 上面的 bug。问题验证通过后，合并到 <code>master</code> 和 <code>develop</code> 分支，并打上 tag。</p>\n<blockquote>\n<p><code>hotfix</code> 分支是唯一一个可以从 <code>master</code> 分叉出来的分支类型。</p>\n</blockquote>\n<h3 id=\"开发流程\"> 开发流程</h3>\n<p>通常开发过程中新功能的开发过程如下：</p>\n<ul>\n<li>从 <code>develop</code> 分支拉取一条 <code>feature</code> 分支，开发团队在 <code>feature</code> 分支上进行新功能开发。</li>\n<li>开发完成后，将 <code>feature</code> 分支合入到 <code>develop</code> 分支，并进行开发环境的验证。</li>\n<li>开发环境验证完成，从 <code>develop</code> 分支拉取一条 <code>release</code> 分支，到测试环境进行 SIT/UAT 测试。</li>\n<li>测试无问题后，可将 <code>develop</code> 分支合入 <code>master</code> 分支。</li>\n<li>待发版时，直接将 <code>master</code> 分支代码部署到生产环境。</li>\n</ul>\n<p>可参考下图：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/gitflow.png\" alt=\"GitFlow\">\n  <p style=\"text-align: center; color: #888;\">（GitFlow 示意图）</p>\n</div>\n<h3 id=\"优缺点\"> 优缺点</h3>\n<p>GitFlow 的优点：</p>\n<ul>\n<li>分支各司其职，覆盖大部分开发场景。</li>\n<li>预期 master 分支中任何 commit 都是可部署的。</li>\n<li>严格按照流程执行，出现重大事故的情形会大大降低。</li>\n</ul>\n<p>GitFlow 的缺点：</p>\n<ul>\n<li>过于繁琐，无法要求所有团队成员按照这个流程严格执行。</li>\n<li>违反 Git 提倡的 short-lived 分支原则。</li>\n<li>如果特性分支过多的话很容易造成代码冲突，从而提高了合入的成本。</li>\n<li>由于每次提交都涉及多个分支，所以 GitFlow 也太不适合提交频率较高的项目。</li>\n<li>master 分支历史记录并不干净，只能通过打 tag 标记哪些是 master 真正要部署的。</li>\n<li>对持续部署和 <a href=\"https://zhuanlan.zhihu.com/p/77577415\" target=\"_blank\" rel=\"noopener noreferrer\">Monorepo</a> 仓库不友好。</li>\n</ul>\n<h2 id=\"githubflow-策略\"> GitHubFlow 策略</h2>\n<p>GitHubFlow 看名字也知道和 GitHub 有关，它来源于 GitHub 团队的工作实践。当代码托管在 GitHub 上时，则需要使用 GitHubFlow。相比 GitFlow 而言，GitHubFlow 没有那么多分支。</p>\n<p>GitHubFlow 通常只有一个 <code>master</code> 分支是固定的（<a href=\"https://github.com/github/renaming\" target=\"_blank\" rel=\"noopener noreferrer\">现在被更名为 main 了</a>），而且 GitHubFlow 中的 <code>master</code> 分支通常是受保护的，只有特定权限的人才可以向 <code>master</code> 分支合入代码。</p>\n<h3 id=\"适用场景\"> 适用场景</h3>\n<ul>\n<li>适合开源项目。开源项目需要接受任何开发者的代码共享，无需给他们正式的代码库的写权限。</li>\n<li>适合大型的，自发性的团队。fork 的方式可以提供灵活的方式来安全协作。</li>\n</ul>\n<h3 id=\"开发流程-2\"> 开发流程</h3>\n<ul>\n<li>在 GitHubFlow 中，要求每个成员先 fork 项目到自己的目录（fork 的本质就是让 GitHub 将项目克隆到你的个人目录）。</li>\n<li>每次有新功能开发或修复 bug 时，需要从 <code>master</code> 分支拉取一个新的 <code>feature</code> 分支，在这个新分支上进行代码提交。</li>\n<li>功能开发完成，开发者创建 <code>feature</code> 分支合并到上游（upstream）项目的 Pull Request（简称 PR），通知源仓库开发者进行代码修改 Review。</li>\n<li>上游项目的所有者决定是否合并你的代码，如果确认无误，他会将代码合入 <code>master</code> 分支。</li>\n</ul>\n<p>可参考下图：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/githubflow.png\" alt=\"GitHubFlow\">\n  <p style=\"text-align: center; color: #888;\">（GitHubFlow 示意图）</p>\n</div>\n<p>很多人可能会问，提交代码通常是 <code>commit</code> 或者 <code>push</code>，拉取代码才是 <code>pull</code>，为什么 GitHubFlow 中提交代码是「Pull Request」。因为在 GitHubFlow 中，PR 是通知其他人员到你的代码库去拉取代码至本地，然后由他们进行最终的提交，所以用 <code>pull</code> 而非 <code>push</code>。</p>\n<h3 id=\"优缺点-2\"> 优缺点</h3>\n<p>GitHubFlow 的优点：</p>\n<ul>\n<li>相对于 GitFlow 来说比较简单。</li>\n</ul>\n<p>GitHubFlow 的缺点：</p>\n<ul>\n<li>因为只有一条 master 分支，万一代码合入后，由于某些因素 master 分支不能立刻发布，就会导致最终发布的版本和计划不同。</li>\n</ul>\n<h2 id=\"gitlabflow-策略\"> GitLabFlow 策略</h2>\n<p>GitLabFlow 出现的最晚，GitLabFlow 是开源工具 GitLab 推荐的做法。</p>\n<p>GitLabFlow 支持 GitFlow 的分支策略，也支持 GitHubFlow 的「Pull Request」（在 GitLabFlow 中被称为「Merge Request」）。</p>\n<p>相比于 GitHubFlow，GitLabFlow 增加了对预生产环境和生产环境的管理，即 <code>master</code> 分支对应为开发环境的分支，预生产和生产环境由其他分支（如 <code>pre-production</code>、<code>production</code>）进行管理。在这种情况下，<code>master</code> 分支是 <code>pre-production</code> 分支的上游，<code>pre-production</code> 是 <code>production</code> 分支的上游；GitLabFlow 规定代码必须从上游向下游发展，即新功能或修复 bug 时，特性分支的代码测试无误后，必须先合入 <code>master</code> 分支，然后才能由 <code>master</code> 分支向 <code>pre-production</code> 环境合入，最后由 <code>pre-production</code> 合入到 <code>production</code>。</p>\n<p>基于环境：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/gitlabflow-production.png\" alt=\"GitLabFlow\" style=\"width: 200px;\">\n  <p style=\"text-align: center; color: #888;\">（GitLabFlow：master -> production，图来源于网络）</p>\n</div>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/gitlabflow-pre-production.png\" alt=\"GitLabFlow\" style=\"width: 300px;\">\n  <p style=\"text-align: center; color: #888;\">（GitLabFlow：master -> pre-production -> production，图来源于网络）</p>\n</div>\n<p>基于发布计划：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/gitlabflow-stable.png\" alt=\"GitLabFlow\" style=\"width: 300px;\">\n  <p style=\"text-align: center; color: #888;\">（GitLabFlow：master -> stable，图来源于网络）</p>\n</div>\n<p>GitLabFlow 中的 Merge Request 是将一个分支合入到另一个分支的请求，通过 Merge Request 可以对比合入分支和被合入分支的差异，也可以做代码的 Review。</p>\n<p>GitLabFlow 并不像 GitFlow、GitHubFlow 一样具有明显的规范，它更多是在 GitHubFlow 基础上，综合考虑环境部署、项目管理等问题而得出的一种实践。</p>\n<h2 id=\"团队定制的分支策略\"> 团队定制的分支策略</h2>\n<p>比较流行的 Git 分支策略是 GitFlow，但是大部分团队会根据自己的情况制定自己的 Git 工作流规范，例如我们团队的分支规范：</p>\n<p><strong>master 分支</strong>：表示一个稳定的发布版本。</p>\n<ul>\n<li>场景：前端会跟随后端的版本迭代，在 <code>dev</code> 分支测试稳定后，合并到 <code>master</code> 分支，并使用 <code>tag</code> 标记前端版本和对应的后端版本。</li>\n<li>tag 规范：<code>v{version}@{product_version}</code>，例如 v0.1.0@SQY_3.0。</li>\n<li>人员：由项目负责人进行审核合并，普通开发者没有权限。</li>\n</ul>\n<p><strong>dev 分支</strong>：开发者主要工作的分支，最新的特性或 bug 修复都会提交到这个分支。开发者如果在该分支进行了提交，在 <code>push</code> 到远程之前应该先 <code>pull</code> 一下，并尽量使用 <code>rebase</code> 模式，保证分支的简洁。</p>\n<ul>\n<li>命名规范：<code>dev</code></li>\n<li>tag 规范：在 <code>dev</code> 分支中也可能会经历发布过程，例如 bug 修复版本。这里同样使用 tag 来标记这些发布，例如 v0.1.1。</li>\n<li>提交规范：如果是在开发分支上进行开发，在推送到远程之前，应该使用 <code>git rebase</code> 形式更新本地分支。</li>\n<li>建议操作：建议时不时地 <code>pull</code> 一下，尤其是每天打开电脑正式工作前，保证本地代码版本与远端版本的一致性（因为很多人都不能优雅地解决代码冲突）。</li>\n</ul>\n<p><strong>feature 分支</strong>：涉及多人协作或者大功能的开发，应该从 <code>dev</code> 分支 <code>checkout</code> 出独立的 <code>feature</code> 分支，避免干扰 <code>dev</code> 分支。</p>\n<ul>\n<li>场景\n<ul>\n<li>涉及多人协作：团队多个成员在同一个项目下负责开发不同的功能，这时候每个成员在自己的 <code>feature</code> 分支独立开发。</li>\n<li>大功能开发：大功能开发跨越周期比较长，需要多次迭代才会稳定。这时候应该在独立的分支上开发。方便跟踪历史记录，也免于干扰 <code>dev</code> 分支的迭代和发布。</li>\n</ul>\n</li>\n<li>命名规范\n<ul>\n<li><code>feature/name</code>：name 是功能名称。</li>\n<li><code>feature/product_version</code>：这也是团队常见的模式，当无法使用一个功能名称来描述时，可以使用后端版本号作为「功能」。</li>\n</ul>\n</li>\n<li>合并时机\n<ul>\n<li>当 <code>feature</code> 分支迭代稳定，并通过测试后，合并到 <code>dev</code> 分支。合并到 <code>dev</code> 后，<code>feature</code> 分支的生命周期就结束了。后续 bug 修复和功能优化直接在 <code>dev</code> 开发。</li>\n<li>当多个 <code>feature</code> 分支需要合并对外发布临时版本时。合并到 <code>preview</code> 分支。（⚠️这种情况不应该合并到 <code>dev</code> 分支，因为 <code>feature</code> 分支可能还不稳定或未完成，比如为了联调某些功能）</li>\n</ul>\n</li>\n<li>合并方式\n<ul>\n<li>为了能在分支图上查看到分支历史，不要使用 <a href=\"https://www.cnblogs.com/mengff/p/15514944.html\" target=\"_blank\" rel=\"noopener noreferrer\">fast-forward</a>。</li>\n</ul>\n</li>\n</ul>\n<p><strong>preview 分支</strong>：临时的预览分支，<code>preview</code> 分支用于临时合并 <code>feature</code> 分支，这其中可能会修复某些 bug 或者冲突。可以选择性地将这些提交 <code>cherry-pick</code> 回 <code>feature</code> 分支。当预览结束后就可以销毁 <code>preview</code> 分支。</p>\n<p><strong>release 分支</strong>：<code>release</code> 分支遵循 GitFlow 流程。</p>\n<ul>\n<li>GitFlow 风格的 release：当前前端的稳定版本和 SQY（产品名）版本绑定。<code>release</code> 分支不一定存在。一般情况下，只会在前端版本稳定后，将其合并到 <code>master</code>，并创建 tag 标记。而只有需要为指定的正式版本修复 bug 时才会创建 <code>release</code> 分支。</li>\n<li>场景：需要为某个正式版本修复 bug（hotfix）时，从 <code>master</code> 的对应 tag 中 <code>checkout</code> 出一个 <code>release</code> 分支。</li>\n<li>命名规范：<code>release/{product_version}</code>，外部人员只会关注产品版本。</li>\n<li>如何修复：\n<ul>\n<li>如果对应 bug 可以在 <code>dev</code> 分支直接被修复，可以先提交到 <code>dev</code> 分支（或者已经修复了），然后再 <code>cherry-pick</code> 到 <code>release</code> 分支。</li>\n<li>如果 bug 在新版本无法复现，比如新版本升级了依赖，那么在 <code>release</code> 分支直接修复即可。</li>\n</ul>\n</li>\n<li><code>release</code> 分支树：\n<div style=\"text-align: center;\">\n<svg id=\"SvgjsSvg1006\" width=\"309.5\" height=\"462\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><defs id=\"SvgjsDefs1007\"><marker id=\"SvgjsMarker1036\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1037\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#64b5f6\" stroke=\"#64b5f6\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1040\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1041\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#64b5f6\" stroke=\"#64b5f6\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1044\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1045\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#64b5f6\" stroke=\"#64b5f6\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1048\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1049\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#64b5f6\" stroke=\"#64b5f6\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1076\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1077\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#e57373\" stroke=\"#e57373\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1086\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1087\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#e57373\" stroke=\"#e57373\" stroke-width=\"1\"></path></marker><marker id=\"SvgjsMarker1090\" markerWidth=\"14\" markerHeight=\"10\" refX=\"10\" refY=\"5\" viewBox=\"0 0 14 10\" orient=\"auto\" markerUnits=\"userSpaceOnUse\" stroke-dasharray=\"0,0\"><path id=\"SvgjsPath1091\" d=\"M0,0 L14,5 L0,10 L0,0\" fill=\"#64b5f6\" stroke=\"#64b5f6\" stroke-width=\"1\"></path></marker></defs><g id=\"SvgjsG1008\" transform=\"translate(109.75,414)\"><path id=\"SvgjsPath1009\" d=\"M 0 0L 71.5 0L 71.5 23L 0 23Z\" stroke=\"rgba(229,115,115,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffcdd2\"></path><g id=\"SvgjsG1010\"><text id=\"SvgjsText1011\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"52px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"0.75\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1012\" dy=\"17\" x=\"36\"><tspan id=\"SvgjsTspan1013\" style=\"text-decoration:;\">master</tspan></tspan></text></g></g><g id=\"SvgjsG1014\" transform=\"translate(135.5,353.5)\"><path id=\"SvgjsPath1015\" d=\"M 0 11.5C 0 -3.8333333333333335 20 -3.8333333333333335 20 11.5C 20 26.833333333333332 0 26.833333333333332 0 11.5Z\" stroke=\"rgba(100,181,246,1)\" stroke-width=\"1\" fill-opacity=\"1\" fill=\"#bbdefb\"></path><g id=\"SvgjsG1016\"><text id=\"SvgjsText1017\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"0px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"0.75\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1018\" transform=\"translate(135.5,270.5)\"><path id=\"SvgjsPath1019\" d=\"M 0 11.5C 0 -3.8333333333333335 20 -3.8333333333333335 20 11.5C 20 26.833333333333332 0 26.833333333333332 0 11.5Z\" stroke=\"rgba(100,181,246,1)\" stroke-width=\"1\" fill-opacity=\"1\" fill=\"#bbdefb\"></path><g id=\"SvgjsG1020\"><text id=\"SvgjsText1021\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"0px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"0.75\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1022\" transform=\"translate(135.5,136.5)\"><path id=\"SvgjsPath1023\" d=\"M 0 11.5C 0 -3.8333333333333335 20 -3.8333333333333335 20 11.5C 20 26.833333333333332 0 26.833333333333332 0 11.5Z\" stroke=\"rgba(100,181,246,1)\" stroke-width=\"1\" fill-opacity=\"1\" fill=\"#bbdefb\"></path><g id=\"SvgjsG1024\"><text id=\"SvgjsText1025\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"0px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"0.75\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1026\" transform=\"translate(135.5,54.5)\"><path id=\"SvgjsPath1027\" d=\"M 0 11.5C 0 -3.8333333333333335 20 -3.8333333333333335 20 11.5C 20 26.833333333333332 0 26.833333333333332 0 11.5Z\" stroke=\"rgba(100,181,246,1)\" stroke-width=\"1\" fill-opacity=\"1\" fill=\"#bbdefb\"></path><g id=\"SvgjsG1028\"><text id=\"SvgjsText1029\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"0px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"0.75\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1030\" transform=\"translate(213,234)\"><path id=\"SvgjsPath1031\" d=\"M 0 11.5C 0 -3.8333333333333335 20 -3.8333333333333335 20 11.5C 20 26.833333333333332 0 26.833333333333332 0 11.5Z\" stroke=\"rgba(100,181,246,1)\" stroke-width=\"1\" fill-opacity=\"1\" fill=\"#bbdefb\"></path><g id=\"SvgjsG1032\"><text id=\"SvgjsText1033\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"0px\" fill=\"#323232\" font-weight=\"400\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"400\" font-style=\"\" opacity=\"1\" y=\"0.75\" transform=\"rotate(0)\"></text></g></g><g id=\"SvgjsG1034\"><path id=\"SvgjsPath1035\" d=\"M145.5 413L145.5 394.5L145.5 394.5L145.5 379.6\" stroke=\"#64b5f6\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1036)\"></path></g><g id=\"SvgjsG1038\"><path id=\"SvgjsPath1039\" d=\"M145.5 353L145.5 323.5L145.5 323.5L145.5 296.6\" stroke=\"#64b5f6\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1040)\"></path></g><g id=\"SvgjsG1042\"><path id=\"SvgjsPath1043\" d=\"M145.5 270L145.5 215L145.5 215L145.5 162.6\" stroke=\"#64b5f6\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1044)\"></path></g><g id=\"SvgjsG1046\"><path id=\"SvgjsPath1047\" d=\"M145.5 136L145.5 106L145.5 106L145.5 80.6\" stroke=\"#64b5f6\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1048)\"></path></g><g id=\"SvgjsG1050\" transform=\"translate(143.5,345)\"><path id=\"SvgjsPath1051\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1052\"><text id=\"SvgjsText1053\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"120px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"9.25\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1054\" dy=\"17\" x=\"60\"><tspan id=\"SvgjsTspan1055\" style=\"text-decoration:;\">v0.5.0@3.2</tspan></tspan></text></g></g><g id=\"SvgjsG1056\" transform=\"translate(25,262)\"><path id=\"SvgjsPath1057\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1058\"><text id=\"SvgjsText1059\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"120px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"9.25\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1060\" dy=\"17\" x=\"60\"><tspan id=\"SvgjsTspan1061\" style=\"text-decoration:;\">v1.0.0@3.3</tspan></tspan></text></g></g><g id=\"SvgjsG1062\" transform=\"translate(143.5,46)\"><path id=\"SvgjsPath1063\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1064\"><text id=\"SvgjsText1065\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"120px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"9.25\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1066\" dy=\"17\" x=\"60\"><tspan id=\"SvgjsTspan1067\" style=\"text-decoration:;\">v1.2.0@3.5</tspan></tspan></text></g></g><g id=\"SvgjsG1068\" transform=\"translate(143.5,128)\"><path id=\"SvgjsPath1069\" d=\"M 0 0L 120 0L 120 40L 0 40Z\" stroke=\"none\" fill=\"none\"></path><g id=\"SvgjsG1070\"><text id=\"SvgjsText1071\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"120px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"9.25\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1072\" dy=\"17\" x=\"60\"><tspan id=\"SvgjsTspan1073\" style=\"text-decoration:;\">v1.1.0@3.4</tspan></tspan></text></g></g><g id=\"SvgjsG1074\"><path id=\"SvgjsPath1075\" d=\"M155.9984707362022 282.03907588962545C 183.85493945180906 286.99974086170886 217.5 275 221.4350122678727 259.6759696183423\" stroke=\"#e57373\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1076)\"></path></g><g id=\"SvgjsG1078\" transform=\"translate(186.5,181)\"><path id=\"SvgjsPath1079\" d=\"M 0 0L 98 0L 98 23L 0 23Z\" stroke=\"rgba(229,115,115,1)\" stroke-width=\"2\" fill-opacity=\"1\" fill=\"#ffcdd2\"></path><g id=\"SvgjsG1080\"><text id=\"SvgjsText1081\" font-family=\"微软雅黑\" text-anchor=\"middle\" font-size=\"14px\" width=\"78px\" fill=\"#323232\" font-weight=\"700\" align=\"middle\" lineHeight=\"125%\" anchor=\"middle\" family=\"微软雅黑\" size=\"14px\" weight=\"700\" font-style=\"\" opacity=\"1\" y=\"0.75\" transform=\"rotate(0)\"><tspan id=\"SvgjsTspan1082\" dy=\"17\" x=\"49\"><tspan id=\"SvgjsTspan1083\" style=\"text-decoration:;\">release/3.3</tspan></tspan></text></g></g><g id=\"SvgjsG1084\"><path id=\"SvgjsPath1085\" d=\"M223.0898770882842 233.50814421930653C 225.9561216427084 222.96760383605817 225.3804347826087 216.9670315068311 225.38437810353196 207.5999978403077\" stroke=\"#e57373\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1086)\"></path></g><g id=\"SvgjsG1088\"><path id=\"SvgjsPath1089\" d=\"M144.5 56L144.5 40.5L144.5 40.5L144.5 25\" stroke=\"#64b5f6\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#SvgjsMarker1090)\"></path></g></svg>\n<p style=\"text-align: center; color: #888;\">（浏览器可视区域的宽高）</p>\n</div></li>\n</ul>\n<h2 id=\"总结\"> 总结</h2>\n<p>Git 提供了丰富的分支策略和工作流方式，通过学习业界 Git 工作流，可以发现每种工作流都设计的非常好，似乎都能运用到团队实践。但在引入 Git 工作流规范开发时要留意：Git 工作流仅仅是整个研发流程中的一环。上游项目管理/缺陷追踪系统虎视眈眈，下游 CD (Continuous Delivery) 嗷嗷待哺，还得考虑团队规模、产品形态、发版方式等等因素。因此，在团队中落地 Git 工作流规范并不是一件能轻松决定的事。</p>\n<p>选择的策略不同，研发效率也不同，没有最好的工作流策略，只有最适合团队的工作流策略，Git工作流中常见的三种分支策略及其优缺点在上面已经列出，可以根据团队具体情况，选择合适的分支策略进行开发。</p>\n<p>（完）</p>\n",
      "date_published": "2021-11-27T07:45:37.000Z",
      "date_modified": "2022-02-11T06:03:23.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    },
    {
      "title": "版本号定义规范",
      "url": "https://www.fedbook.cn/style-guide/version-control/version-number/",
      "id": "https://www.fedbook.cn/style-guide/version-control/version-number/",
      "content_html": "<h1 id=\"版本号定义规范\"> 版本号定义规范</h1>\n<h2 id=\"开源项目示例\"> 开源项目示例</h2>\n<p>下图是目前最流行的前端框架之一的 vue 近期版本发布记录，截图来自 <a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"noopener noreferrer\">npmjs.com</a>：</p>\n<div style=\"text-align: center;\">\n  <img src=\"./assets/vue-versions.png\" alt=\"vue 版本发布记录\" style=\"width: 540px;\">\n  <p style=\"text-align: center; color: #888;\">（vue 版本发布记录）</p>\n</div>\n<p>从上图不难看出：</p>\n<ul>\n<li>vue 的版本号通常由三位组成，形如：X.Y.Z</li>\n<li>版本是严格递增的，此处是：3.2.0 -&gt; 3.2.1 -&gt; 3.2.2</li>\n<li>在发布重要版本时，可以发布 alpha，rc 等先行版本</li>\n<li>alpha 和 rc 等修饰版本的关键字后面可以带上次数和 meta 信息</li>\n<li>可以说，vue 发布版本时做的相当到位，版本给人的感觉非常清晰，也很严谨。这得益于 Semver（语义化版本） 规范的功劳。</li>\n</ul>\n<h2 id=\"语义化版本\"> 语义化版本</h2>\n<p>项目的版本号应该根据某些规则进行迭代，这里推荐使用<a href=\"https://semver.org/lang/zh-CN/\" target=\"_blank\" rel=\"noopener noreferrer\">语义化版本</a>规范，通过这个规范，用户可以了解版本变更的影响范围。规则如下：</p>\n<ul>\n<li>主版本号（major）：当你做了不兼容的 API 修改。</li>\n<li>次版本号（minor）：当你做了向下兼容的功能性新增，可以理解为 Feature 版本。</li>\n<li>修订号（patch）：当你做了向下兼容的问题修正，可以理解为 Bug fix 版本。</li>\n</ul>\n<p>先行版本号及版本编译信息可以加到「主版本号.次版本号.修订号」的后面，作为延伸。</p>\n<h2 id=\"先行版本\"> 先行版本</h2>\n<p>当要发布<strong>大版本</strong>或者<strong>核心的 Feature</strong> 时，但是又不能保证这个版本的功能 100% 正常。这个时候就需要通过发布<strong>先行版本</strong>。</p>\n<p>比较常见的先行版本包括：内测版、灰度版本和 RC 版本。Semver 规范中使用 alpha、beta、rc（以前叫做 gama）来修饰即将要发布的版本。它们的含义是：</p>\n<ul>\n<li><strong>alpha</strong>：内部版本。此版本表示该软件在此阶段主要是以实现软件功能为主，通常只在软件开发者内部交流，一般而言，该版本软件的 Bug 较多，需要继续修改。</li>\n<li><strong>beta</strong>：公测版本。该版本相对于 alpha 版已有了很大的改进，消除了严重的错误，但还是存在着一些缺陷，需要经过多次测试来进一步消除，此版本主要的修改对像是软件的 UI，这个阶段的版本也会一直加入新的功能。</li>\n<li><strong>rc</strong>：即 Release candiate，正式版本的候选版本。该版本已经相当成熟了，基本上不存在导致错误的 BUG，与即将发行的正式版相差无几，不会再加入新的功能了，主要着重于除错。</li>\n</ul>\n<p>比如：1.0.0-alpha.0，1.0.0-alpha.1，1.0.0-beta.0，1.0.0-rc.0，1.0.p-rc.1 等版本。alpha，beta，rc 后需要带上次数信息。</p>\n<p>最后，当经过这些先行版本的一系列测试之后，终归会有一个正式版本，是最终交付用户使用的一个版本，也就是 Release 版。</p>\n<h2 id=\"版本发布准则\"> 版本发布准则</h2>\n<p>列举出比较实用的一些规则：</p>\n<ul>\n<li>标准的版本号必须采用 XYZ 的格式，并且 X、Y 和 Z 为非负的整数，禁止在数字前方补零，版本发布需要严格递增。例如：1.9.1 -&gt; 1.10.0 -&gt; 1.11.0。</li>\n<li>某个软件版本发行后，任何修改都必须以新版本发行。</li>\n<li>1.0.0 的版本号用于界定公共 API。当你的软件发布到了正式环境，或者有稳定的 API 时，就可以发布 1.0.0 版本了。</li>\n<li>版本的优先层级指的是不同版本在排序时如何比较。判断优先层级时，必须把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较。</li>\n</ul>\n<p>（完）</p>\n",
      "date_published": "2022-02-10T09:27:57.000Z",
      "date_modified": "2022-02-10T09:27:57.000Z",
      "authors": [
        {
          "name": "wenyuan"
        }
      ],
      "tags": []
    }
  ]
}