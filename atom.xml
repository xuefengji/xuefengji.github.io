<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
  <id>https://www.snowji.cn/</id>
  <title>测试开发手册</title>
  <subtitle>纪小雪的测试笔记</subtitle>
  <author>
    <name>snowji</name>
  </author>
  <updated>2022-10-30T09:03:36.399Z</updated>
  <generator>@mr-hope/vuepress-plugin-feed</generator>
  <link rel="self" href="https://www.snowji.cn/atom.xml"/>
  <link rel="alternate" href="https://www.snowji.cn/"/>
  <rights>Copyright by snowji</rights>
  <contributor>
    <name>snowji</name>
  </contributor>
  <entry>
    <title type="html">Jenkins 安装</title>
    <id>https://www.snowji.cn/basic-skills/Jenkins/jenkins-install/</id>
    <link href="https://www.snowji.cn/basic-skills/Jenkins/jenkins-install/"/>
    <updated>2022-09-02T02:10:15.000Z</updated>
    <content type="html"><![CDATA[<h1 id="jenkins-安装"> Jenkins 安装</h1>
<h2 id="安装前准备"> 安装前准备</h2>
<ul>
<li>需要安装的软件
<ul>
<li>Java 8 (JRE 或 JDK 都可以)</li>
</ul>
</li>
<li>机器要求
<ul>
<li>256 MB 内存，建议大于 512 MB</li>
<li>10 GB 的硬盘空间</li>
</ul>
</li>
</ul>
<h2 id="安装-jenkins"> 安装 Jenkins</h2>
<p><strong>安装步骤</strong>：</p>
<ul>
<li>
<p>下载地址：https://www.jenkins.io/download/</p>
</li>
<li>
<p>选择 .war 文件下载</p>
</li>
<li>
<p>下载完成后，进入下载目录，运行 <code>java -jar jenkins.war --httpPort=8080</code></p>
</li>
<li>
<p>打开浏览器进入链接 <code>http://localhost:8080</code></p>
</li>
<li>
<p>能成功打开链接时，即说明安装成功</p>
</li>
</ul>
<h2 id="jenkins-版本升级"> Jenkins 版本升级</h2>
<p><strong>升级步骤</strong>：</p>
<ul>
<li>根据上面的步骤下载想要升级的 war 包</li>
<li>使用 <code>http://jenkinsIP:port/exit</code> 停止 Jenkins 服务</li>
<li>找到 war 包路径，替换最新的 war 包</li>
<li>使用 <code>java -jar jenkins.war</code> 启动 Jenkins服务</li>
</ul>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T02:10:15.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">MySql 数据持久化</title>
    <id>https://www.snowji.cn/basic-skills/docker/MySql/</id>
    <link href="https://www.snowji.cn/basic-skills/docker/MySql/"/>
    <updated>2022-08-26T03:40:33.000Z</updated>
    <content type="html"><![CDATA[<h1 id="mysql-数据持久化"> MySql 数据持久化</h1>
<p>思考：MySql 的数据持久化的问题</p>
<h2 id="安装-mysql"> 安装 MySql</h2>
<h3 id="搜索镜像"> 搜索镜像</h3>
<div><pre><code><span>docker</span> search mysql
</code></pre>
<div><span>1</span><br></div></div><h3 id="pull-镜像"> pull 镜像</h3>
<div><pre><code><span>docker</span> pull mysql <span># 拉取最新的镜像</span>

<span>docker</span> pull mysql:5.7 <span># 拉取指定版本的镜像</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="运行-mysql-容器"> 运行 MySql 容器</h3>
<div><p>注意</p>
<p>创建 MySql 时，必须要设置密码</p>
</div>
<p>在 docker hub 上找到 MySql 查看使用方式</p>
<div><pre><code>$ docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag
</code></pre>
<div><span>1</span><br></div></div><p>运行容器，并挂载目录</p>
<div><pre><code><span>docker</span> run -d -p <span>80</span>:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e <span>MYSQL_ROOT_PASSWORD</span><span>=</span><span>123456</span> --name mysql01 mysql
</code></pre>
<div><span>1</span><br></div></div><p>-e：是指定环境变量，所以 MYSQL_ROOT_PASSWORD 是一个环境变量</p>
<ul>
<li>上面的例子讲了 MYSQL_ROOT_PASSWORD 是环境变量</li>
<li>docker run mysql 时，可以通过在 docker run 命令行中传入一个或多个环境变量来调整 MySQL 实例的配置</li>
</ul>
<h4 id="更多环境变量"> 更多环境变量</h4>
<h5 id="mysql-root-password"> MYSQL_ROOT_PASSWORD</h5>
<p>必需的，它指定将为 MySQL root 超级用户帐户设置的密码</p>
<h5 id="mysql-database"> MYSQL_DATABASE</h5>
<ul>
<li>可选的，允许指定要在 docker run mysql 时创建的数据库的名称</li>
<li>如果提供了用户/密码，则该用户将被授予对该数据库的超级用户访问权限（对应于 GRANT ALL）</li>
</ul>
<h5 id="mysql-user-mysql-password"> MYSQL_USER, MYSQL_PASSWORD</h5>
<ul>
<li>可选的，结合使用来创建新用户和密码</li>
<li>该用户将被授予对 MYSQL_DATABASE 变量指定的数据库的超级用户权限</li>
<li>创建用户需要这两个变量</li>
</ul>
<h5 id="mysql-allow-empty-password"> MYSQL_ALLOW_EMPTY_PASSWORD</h5>
<p>这是一个可选变量，设置为非空值，如 yes，允许使用 root 用户的空白密码启动容器</p>
<h6 id="mysql-random-root-password"> MYSQL_RANDOM_ROOT_PASSWORD</h6>
<ul>
<li>可选的，设置为非空值，如 yes，为 root 用户生成随机初始密码</li>
<li>生成的 root 密码将打印到 stdout</li>
</ul>
<h6 id="mysql-onetime-password"> MYSQL_ONETIME_PASSWORD</h6>
<ul>
<li>初始化完成后，将 root（不是 MYSQL_USER 中指定的用户！）用户设置为过期，强制在首次登录时更改密码</li>
<li>任何非空值都将激活此设置</li>
</ul>
<h5 id="mysql-initdb-skip-tzinfo"> MYSQL_INITDB_SKIP_TZINFO</h5>
<ul>
<li>默认情况下，入口点脚本会自动加载 CONVERT_TZ() 函数所需的时区数据</li>
<li>如果不需要，任何非空值都会禁用时区加载</li>
</ul>
<h2 id="参考资料"> 参考资料</h2>
<p><a href="https://hub.docker.com/_/mysql?tab=description" target="_blank" rel="noopener noreferrer">官方镜像文档</a></p>
<p><a href="https://hub.docker.com/_/mysql?tab=tags" target="_blank" rel="noopener noreferrer">镜像版本</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T03:15:48.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Jenkins</title>
    <id>https://www.snowji.cn/basic-skills/Jenkins/</id>
    <link href="https://www.snowji.cn/basic-skills/Jenkins/"/>
    <updated>2022-08-25T08:04:07.000Z</updated>
    <content type="html"><![CDATA[<h1 id="jenkins"> Jenkins</h1>
<h2 id="简介"> 简介</h2>
<ul>
<li>一款开源的持续集成的工具</li>
<li>底层语言为 Java</li>
<li>通常与版本管理工具（ SVN、Git等）、构建工具（Maven、Ant、Gradle等）结合使用</li>
</ul>
<h2 id="jenkins-特征"> Jenkins 特征</h2>
<ul>
<li>开源的 Java 语言开发持续集成工具，支持持续集成、持续部署</li>
<li>易于安装部署配置：可通过 yum 安装或下载 war 包以及通过 Docker 容器等快速实现安装部署</li>
<li>消息通知及测试报告：集成 RSS-E-mail 通过 RSS 发布构建结果或当构建完成时通过 e-mail 通知，生成 JUint/TestNG 测试报告</li>
<li>分布式构建：支持让多台计算机一起构建/测试</li>
<li>文件识别</li>
<li>丰富的插件支持</li>
</ul>
<h2 id="ci-cd-介绍"> CI/CD 介绍</h2>
<h3 id="ci"> CI</h3>
<p>Continuous integration ，持续集成，是一种开发时间</p>
<p>持续集成强调开发人员提交了代码之后，立即进行构建、测试</p>
<p><img src="./../Jenkins/images/ci.png" alt="CI" /></p>
<h3 id="cd"> CD</h3>
<p>Continuous Delivery，持续交付，在持续集成基础上，将集成后的代码部署到更贴近真实运行环境中</p>
<p><img src="./../Jenkins/images/CD.png" alt="CD" /></p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:04:07.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Docker</title>
    <id>https://www.snowji.cn/basic-skills/docker/</id>
    <link href="https://www.snowji.cn/basic-skills/docker/"/>
    <updated>2022-08-25T03:15:48.000Z</updated>
    <content type="html"><![CDATA[<h1 id="docker"> Docker</h1>
<h2 id="docker-概念"> Docker 概念</h2>
<p><strong>定义</strong>：Docker 是一种虚拟化技术的产品，属于一种容器</p>
<p><strong>容器</strong>：将软件打包成标准化单元，以用于开发、交付和部署</p>
<h2 id="docker-架构"> Docker 架构</h2>
<p><img src="./images/拉取运行原理.jpg" alt="拉取运行原理" /></p>
<h2 id="docker-思想"> Docker 思想</h2>
<ul>
<li>集装箱</li>
<li>标准化
<ul>
<li>运输方式</li>
<li>存储方式</li>
<li>API 接口</li>
</ul>
</li>
<li>隔离</li>
</ul>
<h2 id="docker-解决的问题"> Docker 解决的问题</h2>
<ul>
<li>不同环境运行导致软件运行出错</li>
</ul>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T03:15:48.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">docker commit</title>
    <id>https://www.snowji.cn/basic-skills/docker/docker-commit/</id>
    <link href="https://www.snowji.cn/basic-skills/docker/docker-commit/"/>
    <updated>2022-08-26T03:40:33.000Z</updated>
    <content type="html"><![CDATA[<h1 id="docker-commit"> docker commit</h1>
<p>作用:</p>
<p>从容器创建一个新的镜像</p>
<h2 id="语法"> 语法</h2>
<div><pre><code><span>docker</span> commit <span>[</span>OPTIONS<span>]</span> CONTAINER <span>[</span>REPOSITORY<span>[</span>:TAG<span>]</span><span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p>options 描述：</p>
<table>
<thead>
<tr>
<th>option</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>提交镜像的作者</td>
</tr>
<tr>
<td>-c</td>
<td>使用 Dockerfile 指令来创建镜像</td>
</tr>
<tr>
<td>-m</td>
<td>提交时的说明文字</td>
</tr>
<tr>
<td>-p</td>
<td>commit 时，将容器暂停</td>
</tr>
</tbody>
</table>
<h2 id="示例"> 示例</h2>
<p>将从运行的 tomcat 容器中创建一个新的镜像：mytomcat</p>
<div><pre><code><span>docker</span> commit -m<span>=</span><span>"add:test"</span> -a<span>=</span><span>"snowji"</span> 7641ee541af2 mytomcat
</code></pre>
<div><span>1</span><br></div></div><p>查看镜像：</p>
<div><pre><code><span>[</span>root@VM-16-7-centos ~<span>]</span><span># docker images</span>
REPOSITORY   TAG       IMAGE ID       CREATED         SIZE
mytomcat     latest    d6759220ab85   <span>6</span> seconds ago   680MB
nginx        latest    605c77e624dd   <span>3</span> months ago    141MB
tomcat       latest    fb5657adc892   <span>3</span> months ago    680MB
redis        latest    7614ae9453d1   <span>3</span> months ago    113MB
centos       centos7   eeb6ee3f44bd   <span>6</span> months ago    204MB

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>（完）
​</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T03:15:48.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">docker cp</title>
    <id>https://www.snowji.cn/basic-skills/docker/docker-cp/</id>
    <link href="https://www.snowji.cn/basic-skills/docker/docker-cp/"/>
    <updated>2022-08-26T03:40:33.000Z</updated>
    <content type="html"><![CDATA[<h1 id="docker-cp"> docker cp</h1>
<p>作用：在宿主机与容器中相互复制文件/文件夹</p>
<h2 id="语法格式"> 语法格式</h2>
<div><pre><code>docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH
docker cp [OPTIONS] SRC_PATH CONTAINER:DEST_PATH
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h4 id="options-说明"> options 说明</h4>
<table>
<thead>
<tr>
<th>option</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>存档模式（复制所有 uid / gid 信息）</td>
</tr>
<tr>
<td>-L</td>
<td>保持源目标中的链接</td>
</tr>
</tbody>
</table>
<p><strong>重点</strong>:</p>
<ul>
<li>容器 container 可以是正在运行或已停止的容器</li>
<li>SRC_PATH 或 DEST_PATH 可以是文件或目录</li>
<li>该命令会假定容器路径相对于容器的 /（根）目录</li>
<li>而主机路径则是相对于执行 docker cp 命令的当前目录</li>
</ul>
<h2 id="src-path-和-dest-path"> SRC_PATH 和 DEST_PATH</h2>
<h3 id="src-path-指定一个文件"> SRC_PATH 指定一个文件</h3>
<h4 id="若-dest-path-不存在"> 若 DEST_PATH 不存在</h4>
<p>创建 DEST_PATH 所需的文件夹，文件正常保存到 DEST_PATH 中</p>
<h4 id="若-dest-path-不存在-并以-结尾"> 若 DEST_PATH 不存在，并以 / 结尾</h4>
<p>错误：目标目录必须存在</p>
<h4 id="若-dest-path-存在并且是一个文件"> 若 DEST_PATH 存在并且是一个文件</h4>
<p>目标被源文件的内容覆盖</p>
<h4 id="若-dest-path-存在并且是目录"> 若 DEST_PATH 存在并且是目录</h4>
<p>使用 SRC_PATH 中的基本名称将文件复制到此目录中</p>
<h3 id="src-path指定目录"> SRC_PATH指定目录</h3>
<h4 id="若-dest-path-不存在-2"> 若 DEST_PATH 不存在</h4>
<p>将 DEST_PATH 创建为目录，并将源目录的内容复制到该目录中</p>
<h4 id="若-dest-path存在并且是一个文件"> 若 DEST_PATH存在并且是一个文件</h4>
<p>错误：无法将目录复制到文件</p>
<h4 id="若-dest-path存在并且是目录"> 若 DEST_PATH存在并且是目录</h4>
<ul>
<li>SRC_PATH 不以 /. 结尾，源目录复制到此目录</li>
<li>SRC_PATH 以 /. 结尾，源目录的内容被复制到该目录中</li>
</ul>
<h2 id="实例"> 实例</h2>
<h3 id="从容器复制文件到主机"> 从容器复制文件到主机</h3>
<p>复制容器的目录到主机</p>
<div><pre><code>docker cp nginx01:etc/ ./
</code></pre>
<div><span>1</span><br></div></div><p><img src="./images/7.png" alt="top" /></p>
<h3 id="从主机复制文件到容器"> 从主机复制文件到容器</h3>
<p>复制主机文件到容器</p>
<div><pre><code>docker cp text.txt nginx01:/
</code></pre>
<div><span>1</span><br></div></div><p><img src="./images/cp1.png" alt="top" /></p>
<h2 id="参考资料"> 参考资料</h2>
<p><a href="https://docs.docker.com/engine/reference/commandline/cp/" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T03:15:48.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">docker exec/attach</title>
    <id>https://www.snowji.cn/basic-skills/docker/docker-exe-attach/</id>
    <link href="https://www.snowji.cn/basic-skills/docker/docker-exe-attach/"/>
    <updated>2022-08-26T03:40:33.000Z</updated>
    <content type="html"><![CDATA[<h1 id="docker-exec-attach"> docker exec/attach</h1>
<h2 id="exec"> exec</h2>
<p>作用：在正在运行的容器中运行命令</p>
<h3 id="语法格式"> 语法格式</h3>
<div><pre><code> docker exec [OPTIONS] CONTAINER COMMAND [ARG...]
</code></pre>
<div><span>1</span><br></div></div><p>介绍常用 options 说明：</p>
<table>
<thead>
<tr>
<th>option</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td>在后台运行命令</td>
</tr>
<tr>
<td>-i</td>
<td>即使没有附加也保持 STDIN 打开，和 -t 配合</td>
</tr>
<tr>
<td>-t</td>
<td>进入容器的 CLI 模式</td>
</tr>
<tr>
<td>-e</td>
<td>设置环境变量</td>
</tr>
<tr>
<td>--env-file</td>
<td>读入环境变量文件</td>
</tr>
<tr>
<td>-w</td>
<td>需要执行命令的目录</td>
</tr>
<tr>
<td>-u</td>
<td>指定访问容器的用户名</td>
</tr>
</tbody>
</table>
<h3 id="docker-exec-实例"> docker exec 实例</h3>
<h4 id="进入容器的-cli-模式-常用"> 进入容器的 CLI 模式(常用)</h4>
<div><pre><code><span>docker</span> <span>exec</span> -it mynginx <span>bash</span>
</code></pre>
<div><span>1</span><br></div></div><p><img src="./images/exec1.png" alt="exec" /></p>
<h4 id="指定目录执行命令"> 指定目录执行命令</h4>
<div><pre><code>docker exec -it -w /root mynginx pwd
</code></pre>
<div><span>1</span><br></div></div><p><img src="./images/exec3.png" alt="exec" /></p>
<h4 id="执行命令"> 执行命令</h4>
<div><pre><code>docker exec -it mynginx pwd
</code></pre>
<div><span>1</span><br></div></div><p><img src="./images/exec2.png" alt="exec" /></p>
<h4 id="以-root-用户身份进入容器-重点"> 以 root 用户身份进入容器（重点）</h4>
<div><pre><code>docker exec -it -uroot mynginx bash
</code></pre>
<div><span>1</span><br></div></div><p>好处就是，你在容器里敲命令就是 root 用户，畅通无阻，不存在权限不足的问题</p>
<p><strong>注意</strong>：</p>
<p><code>docker exec</code> 不能在暂停的容器中运行命令，会报错</p>
<p><img src="./images/exec4.png" alt="exec" /></p>
<h2 id="attach"> attach</h2>
<p>作用：进入容器正在执行的终端</p>
<h3 id="语法格式-2"> 语法格式</h3>
<div><pre><code>docker attach [OPTIONS] CONTAINER
</code></pre>
<div><span>1</span><br></div></div><p>option 说明：</p>
<table>
<thead>
<tr>
<th>option</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>--detach-keys</td>
<td>覆盖用于分离容器的键序列</td>
</tr>
<tr>
<td>--no-stdin</td>
<td>不要附加标准输入</td>
</tr>
<tr>
<td>--sing-proxy</td>
<td>所有接收到的信号代理到进程</td>
</tr>
</tbody>
</table>
<h3 id="docker-attach-实例"> docker attach 实例</h3>
<div><pre><code>docker run -d --name topdemo centos /usr/bin/top -b
docker attach topdemo
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><img src="./images/attach1png.png" alt="attach" /></p>
<p>能看到 topdemo 容器内部正在执行的命令，1s 输出一次</p>
<h2 id="exec-与-attach-区别"> exec 与 attach 区别</h2>
<div><pre><code>#进入当前容器后开启一个新的终端，可以在里面操作。（常用）
docker exec 

# 进入容器正在执行某个命令的终端，不能在里面操作
docker attach 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T03:15:48.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Home</title>
    <id>https://www.snowji.cn/</id>
    <link href="https://www.snowji.cn/"/>
    <updated>2022-10-30T05:59:58.000Z</updated>
    <content type="html"><![CDATA[<div>
  <h1>我的技术栈</h1>
  <div>
    <div data-tooltip="Python">
      <svg t="1597990804379" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3374" width="200" height="200"><path d="M420.693333 85.333333C353.28 85.333333 298.666667 139.946667 298.666667 207.36v71.68h183.04c16.64 0 30.293333 24.32 30.293333 40.96H207.36C139.946667 320 85.333333 374.613333 85.333333 442.026667v161.322666c0 67.413333 54.613333 122.026667 122.026667 122.026667h50.346667v-114.346667c0-67.413333 54.186667-122.026667 121.6-122.026666h224c67.413333 0 122.026667-54.229333 122.026666-121.642667V207.36C725.333333 139.946667 670.72 85.333333 603.306667 85.333333z m-30.72 68.693334c17.066667 0 30.72 5.12 30.72 30.293333s-13.653333 38.016-30.72 38.016c-16.64 0-30.293333-12.8-30.293333-37.973333s13.653333-30.336 30.293333-30.336z" fill="#3C78AA" p-id="3375"></path><path d="M766.250667 298.666667v114.346666a121.6 121.6 0 0 1-121.6 121.984H420.693333A121.6 121.6 0 0 0 298.666667 656.597333v160a122.026667 122.026667 0 0 0 122.026666 122.026667h182.613334A122.026667 122.026667 0 0 0 725.333333 816.64v-71.68h-183.082666c-16.64 0-30.250667-24.32-30.250667-40.96h304.64A122.026667 122.026667 0 0 0 938.666667 581.973333v-161.28a122.026667 122.026667 0 0 0-122.026667-122.026666zM354.986667 491.221333l-0.170667 0.170667c0.512-0.085333 1.066667-0.042667 1.621333-0.170667z m279.04 310.442667c16.64 0 30.293333 12.8 30.293333 37.973333a30.293333 30.293333 0 0 1-30.293333 30.293334c-17.066667 0-30.72-5.12-30.72-30.293334s13.653333-37.973333 30.72-37.973333z" fill="#FDD835" p-id="3376"></path></svg>
    </div>
    <div data-tooltip="Pytest">
      <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0" y="0" width="1500" height="1500" viewBox="0, 0, 1500, 1500"><g id="pytest_logo"><g id="graphics"><path d="M521.576,213.75 L952.616,213.75 C964.283,213.75 973.741,223.208 973.741,234.875 L973.741,234.875 C973.741,246.542 964.283,256 952.616,256 L521.576,256 C509.909,256 500.451,246.542 500.451,234.875 L500.451,234.875 C500.451,223.208 509.909,213.75 521.576,213.75 z" fill="#696969" id="horizontal_bar"/><g id="top_bars"><path d="M525.333,171 L612,171 L612,191 L525.333,191 L525.333,171 z" fill="#009FE3"/><path d="M638.667,171 L725.333,171 L725.333,191 L638.667,191 L638.667,171 z" fill="#C7D302"/><path d="M750.5,171 L837.167,171 L837.167,191 L750.5,191 L750.5,171 z" fill="#F07E16"/><path d="M861.861,171 L948.528,171 L948.528,191 L861.861,191 L861.861,171 z" fill="#DF2815"/></g><g id="bottom_bars"><path d="M861.861,278 L948.528,278 L948.528,424.5 L861.861,424.5 L861.861,278 z" fill="#DF2815"/><path d="M750.5,278 L837.328,278 L837.328,516 L750.5,516 L750.5,278 z" fill="#F07E16"/><path d="M638.667,278 L725.328,278 L725.328,634.5 L638.667,634.5 L638.667,278 z" fill="#C7D302"/><path d="M525.333,278 L612,278 L612,712.5 L525.333,712.5 L525.333,278 z" fill="#009FE3"/></g></g><g id="pytest"><path d="M252.959,1173.846 Q240.139,1173.846 229.71,1171.021 Q219.28,1168.196 210.914,1163.525 Q202.549,1158.853 196.139,1152.552 Q189.729,1146.25 184.732,1139.297 L182.124,1139.297 Q182.776,1146.685 183.428,1153.421 Q183.862,1159.07 184.297,1165.046 Q184.732,1171.021 184.732,1174.498 L184.732,1276.404 L145.186,1276.404 L145.186,930.921 L177.344,930.921 L182.993,963.079 L184.732,963.079 Q189.729,955.474 196.03,948.847 Q202.332,942.22 210.697,937.331 Q219.063,932.442 229.492,929.509 Q239.922,926.575 252.959,926.575 Q273.384,926.575 290.115,934.397 Q306.846,942.22 318.688,957.756 Q330.53,973.292 337.048,996.324 Q343.567,1019.356 343.567,1049.776 Q343.567,1080.413 337.048,1103.554 Q330.53,1126.695 318.688,1142.339 Q306.846,1157.984 290.115,1165.915 Q273.384,1173.846 252.959,1173.846 z M245.354,959.385 Q228.84,959.385 217.433,964.383 Q206.025,969.38 198.964,979.593 Q191.902,989.805 188.534,1005.015 Q185.166,1020.225 184.732,1040.867 L184.732,1049.776 Q184.732,1071.722 187.665,1088.779 Q190.598,1105.835 197.66,1117.46 Q204.722,1129.085 216.455,1135.06 Q228.189,1141.036 245.789,1141.036 Q275.122,1141.036 288.92,1117.352 Q302.717,1093.667 302.717,1049.341 Q302.717,1004.146 288.92,981.766 Q275.122,959.385 245.354,959.385 z" fill="#696969"/><path d="M370.293,930.921 L411.36,930.921 L458.076,1064.117 Q461.118,1072.808 464.269,1082.369 Q467.42,1091.929 470.136,1101.49 Q472.852,1111.05 474.807,1119.959 Q476.763,1128.868 477.632,1136.473 L478.936,1136.473 Q480.022,1131.041 482.412,1121.697 Q484.802,1112.354 487.736,1101.816 Q490.669,1091.277 493.82,1081.065 Q496.97,1070.853 499.36,1063.682 L542.6,930.921 L583.45,930.921 L489.148,1200.572 Q483.064,1218.172 476.002,1232.187 Q468.941,1246.202 459.597,1255.979 Q450.254,1265.757 437.651,1271.081 Q425.049,1276.404 407.666,1276.404 Q396.367,1276.404 388.11,1275.209 Q379.854,1274.014 373.987,1272.71 L373.987,1241.204 Q378.55,1242.291 385.503,1243.051 Q392.456,1243.812 400.061,1243.812 Q410.491,1243.812 418.096,1241.313 Q425.701,1238.814 431.35,1234.034 Q437,1229.253 441.019,1222.3 Q445.039,1215.347 448.298,1206.438 L460.684,1171.673 z" fill="#696969"/><path d="M695.568,1141.47 Q699.479,1141.47 704.368,1141.036 Q709.257,1140.601 713.82,1139.949 Q718.383,1139.297 722.186,1138.428 Q725.988,1137.559 727.944,1136.907 L727.944,1166.893 Q725.119,1168.196 720.773,1169.5 Q716.428,1170.804 711.213,1171.781 Q705.998,1172.759 700.349,1173.302 Q694.699,1173.846 689.267,1173.846 Q675.795,1173.846 664.279,1170.369 Q652.763,1166.893 644.398,1158.418 Q636.032,1149.944 631.252,1135.495 Q626.472,1121.045 626.472,1099.1 L626.472,960.689 L592.792,960.689 L592.792,943.089 L626.472,926.141 L643.42,876.165 L666.235,876.165 L666.235,930.921 L726.206,930.921 L726.206,960.689 L666.235,960.689 L666.235,1099.1 Q666.235,1120.176 673.079,1130.823 Q679.924,1141.47 695.568,1141.47 z" fill="#009FE3"/><path d="M868.527,1173.846 Q844.626,1173.846 824.853,1165.806 Q805.08,1157.767 790.848,1142.339 Q776.616,1126.912 768.793,1104.097 Q760.971,1081.282 760.971,1051.949 Q760.971,1022.398 768.142,999.148 Q775.312,975.899 788.349,959.711 Q801.386,943.523 819.529,935.049 Q837.673,926.575 859.619,926.575 Q881.13,926.575 898.295,934.289 Q915.461,942.002 927.412,956.017 Q939.362,970.032 945.772,989.697 Q952.182,1009.361 952.182,1033.262 L952.182,1057.815 L801.821,1057.815 Q802.907,1099.751 819.529,1119.524 Q836.152,1139.297 868.962,1139.297 Q880.043,1139.297 889.495,1138.211 Q898.947,1137.125 907.747,1135.06 Q916.547,1132.996 924.804,1129.845 Q933.061,1126.695 941.535,1122.784 L941.535,1157.984 Q932.844,1162.112 924.478,1165.154 Q916.113,1168.196 907.313,1170.152 Q898.513,1172.107 889.061,1172.977 Q879.609,1173.846 868.527,1173.846 z M858.749,959.385 Q833.979,959.385 819.529,976.333 Q805.08,993.282 802.69,1025.657 L909.594,1025.657 Q909.594,1010.882 906.661,998.605 Q903.727,986.329 897.535,977.637 Q891.342,968.946 881.782,964.166 Q872.221,959.385 858.749,959.385 z" fill="#009FE3"/><path d="M1155.126,1104.097 Q1155.126,1121.48 1148.825,1134.517 Q1142.524,1147.554 1130.682,1156.354 Q1118.84,1165.154 1102.109,1169.5 Q1085.378,1173.846 1064.518,1173.846 Q1040.834,1173.846 1023.886,1170.043 Q1006.938,1166.241 994.118,1158.853 L994.118,1122.784 Q1000.854,1126.26 1009.111,1129.628 Q1017.368,1132.996 1026.494,1135.604 Q1035.62,1138.211 1045.289,1139.841 Q1054.958,1141.47 1064.518,1141.47 Q1078.642,1141.47 1088.528,1139.08 Q1098.415,1136.69 1104.608,1132.236 Q1110.8,1127.781 1113.625,1121.371 Q1116.45,1114.961 1116.45,1107.139 Q1116.45,1100.403 1114.277,1094.971 Q1112.104,1089.539 1106.346,1084.216 Q1100.588,1078.892 1090.593,1073.46 Q1080.598,1068.028 1064.953,1061.292 Q1049.308,1054.556 1036.815,1048.038 Q1024.321,1041.519 1015.629,1033.479 Q1006.938,1025.44 1002.266,1014.902 Q997.595,1004.363 997.595,989.805 Q997.595,974.595 1003.57,962.753 Q1009.545,950.911 1020.41,942.872 Q1031.274,934.832 1046.484,930.704 Q1061.694,926.575 1080.38,926.575 Q1101.457,926.575 1118.948,931.138 Q1136.44,935.701 1152.084,943.089 L1138.395,975.03 Q1124.272,968.729 1109.388,964.057 Q1094.504,959.385 1079.077,959.385 Q1056.913,959.385 1046.266,966.664 Q1035.62,973.943 1035.62,987.415 Q1035.62,995.02 1038.118,1000.669 Q1040.617,1006.319 1046.701,1011.316 Q1052.785,1016.314 1062.997,1021.42 Q1073.21,1026.526 1088.42,1032.828 Q1104.064,1039.346 1116.341,1045.865 Q1128.618,1052.383 1137.309,1060.531 Q1146,1068.68 1150.563,1079.109 Q1155.126,1089.539 1155.126,1104.097 z" fill="#009FE3"/><path d="M1285.28,1141.47 Q1289.191,1141.47 1294.08,1141.036 Q1298.969,1140.601 1303.532,1139.949 Q1308.095,1139.297 1311.898,1138.428 Q1315.7,1137.559 1317.656,1136.907 L1317.656,1166.893 Q1314.831,1168.196 1310.485,1169.5 Q1306.14,1170.804 1300.925,1171.781 Q1295.71,1172.759 1290.06,1173.302 Q1284.411,1173.846 1278.979,1173.846 Q1265.507,1173.846 1253.991,1170.369 Q1242.475,1166.893 1234.109,1158.418 Q1225.744,1149.944 1220.964,1135.495 Q1216.183,1121.045 1216.183,1099.1 L1216.183,960.689 L1182.504,960.689 L1182.504,943.089 L1216.183,926.141 L1233.132,876.165 L1255.947,876.165 L1255.947,930.921 L1315.917,930.921 L1315.917,960.689 L1255.947,960.689 L1255.947,1099.1 Q1255.947,1120.176 1262.791,1130.823 Q1269.636,1141.47 1285.28,1141.47 z" fill="#009FE3"/></g></g></svg>
    </div>
    <div data-tooltip="Selenium">
      <svg fill="#40C057" xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 50 50" width="200px" height="200px">    <path d="M47.49,4.67l-3.41-3.21l-1.47-1.39l-1.37,1.49L38.99,4h-8c-0.02,0-0.04,0-0.06,0.01C30.91,4,30.9,4,30.88,4H9 C6.24,4,4,6.24,4,9v32c0,2.76,2.24,5,5,5h32c2.76,0,5-2.24,5-5V9.22l1.6-1.74l1.33-1.46L47.49,4.67z M14.45,40 c-3.72,0-6.27-1.98-6.45-5h2.55c0.27,1.64,1.81,2.62,4.09,2.62c2.09,0,3.63-1.09,3.63-2.65c0-1.37-0.91-2.1-3.18-2.65l-2.18-0.54 c-3-0.73-4.46-2.29-4.46-4.75c0-3.02,2.46-5.03,6.19-5.03c3.45,0,6,2.01,6.09,4.93h-2.55c-0.27-1.55-1.63-2.55-3.63-2.55 c-2.1,0-3.46,1-3.46,2.55c0,1.28,0.91,1.92,3.09,2.47l1.91,0.46C19.55,30.68,21,32.14,21,34.7C21,37.99,18.45,40,14.45,40z M36,34 h-9.38v0.13c0.1,2.12,1.5,3.75,3.57,3.75c1.5,0,2.62-0.53,3.09-1.5h2.53C35.25,38.67,33.09,40,30.09,40C26.34,40,24,37.52,24,33.54 S26.34,27,30.09,27c3.66,0,5.91,2.39,5.91,6.28V34z M29.73,24L19,13.8l3.23-3.4l7.31,6.8L42.71,2.91l3.41,3.21L29.73,24z M30.09,29.05c-1.85,0-3.12,1.18-3.34,2.95h6.59C33.14,30.16,31.95,29.05,30.09,29.05z"/></svg>
    </div>
    <div data-tooltip="Fiddler">
      <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="256px" height="256px" viewBox="0 0 256 256" enable-background="new 0 0 256 256" xml:space="preserve"><image id="image0" width="256" height="256" x="0" y="0"    href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEABAMAAACuXLVVAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAIVBMVEUAAAAtskUtskUtskWW2aJixXT////l9ejL7NF8z4tHvFxGsarIAAAAA3RSTlMAEM+7bwmuAAAAAWJLR0QGYWa4fQAAAAlwSFlzAAAOwwAADsMBx2+oZAAAAAd0SU1FB+YKHQkaDFJASKMAAARzSURBVHjazd3hcdNAEMXxpAMmHWjSQQw0AJRABxlqoAA+QB00ih3bsS1Lp9v3du+Pvsfz5hf7dDrd7T48eNfTZH6AeT0+v3xAAzztdijB4/NuhxLsAVCCAwBK8AYAEhwBQIITAEZwBsAI3gEgggsARHAFgBBcAyAENwAAwS0AQDADGE4wBxhOcAcwmOAeYDDBAsBQgiWAoQSLAAMJlgEGEqwADCNYAxhGsAowiGAdYBBBA2AIQQtgCEETYABBG2AAwQZAOcEWQDnBJkAxwTZAMUEHQClBD0ApQRdAIUEfQCFBJ0AZQS9AGUE3QBFBP0ARQQCghCACUEIQAiggiAEUEAQB0gmiAOkEYYBkgjhAMoEAkEqgAKQSSACJBBpAIoEIkEagAqQRyABJBDpAEoEBkELgAKQQWAAJBB5AAoEJYBO4ADaBDWAS+AAmQQKARZABYBGkABgEOQAGQRKATJAFIBOkAYgEeQAiQSKARJAJIBGkAggEuQACQTJAmCAbIEyQDhAkyAcIEhQAhAgqAEIEJQABghqAAEERQDdBFUA3QRlAJ0EdQCdBIUAXQSVAF0EpQAdBLUAHQTHAJkE1wCZBOcAGQT3ABsEAgCbBCIAmwRCABsEYgAZBBODj1/n1zSYIAXz+Mb9ebYLQN8AKsEwQ+wZ4ARYJYj8BL8ASQfAnYAZYIAiOAWaAe4LoGOAGuCOIDoJugDlBeBC0A8wIwneBY4Cfvy/Xn+AnTBbAKcCX6J+tEcRvg36AawLhNpgQ4IpAmAckBLgQKPOAjADvBMpEKCPAmUCaCKUEOBFIM8GUAEcCbSaYE+CNQJsK5wQ4EIhT4aQAewLxWSApwJ5AA0gL8OIF+CU9FtwGsP4F+nTgfE3el9AOcPgdOj9DO8BkDkRugONYbAzFboDJvRmZAc73Y/12bAaY7AmJF+AyJ5OnZF6AyZ+UWiPh9bycnpbzDybqo5kT4PbpVHw4NQLMn8+1x3MjwHyFQlug0APcr9FISzR6gPtVKmmRSg6wtE6nLNPJAZZWKpWFSjXA8lqtsFSrBlherRYWq8UAa+v1EQIrwNobiwiBE2D9nU2AwAmw/tYqQGAEaL236ycwArTeXPYT6AHa7267CfQA7bfX3QRygK33970En74frr/ZAP/BBgZ8Cwe/iQXfxsNvZMK3cvGb2fDtfPyGRnxLJ7+pFd/Wy29sxrd285vb8e39/AEH/IgHf8gFP+bDH3TCj3rxh93w4378gUf8yCd/6BU/9ssffMaPfvOH3/Hj/3wBBLwEBF8EAy8DwhdCwUvB8MVw8HJAfEEkvCQUXxQLLwvGF0bDS8PxxfHw8oB8gUS8RCRfJBMvE8oXSsVLxfLFcvFywXzBZLxkNF80Gy8bzhdOx0vH88Xz8fYBfAMFvIUE30QDbyPCN1LBW8nwzXTwdkJ8QyW8pRTfVAtvK8Y3VsNby/HN9fD2gnyDRbzFJN9kE28zyjdaxVvN8s128XbDfMNlvOU033QbbzvON17HW8/vCViAPYEL8A8J3Uf5gBAcnAAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMi0xMC0yOVQwOToyNjoxMiswMDowMMc+2PQAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjItMTAtMjlUMDk6MjY6MTIrMDA6MDC2Y2BIAAAAAElFTkSuQmCC" /></svg>
    </div>
    <div data-tooltip="Wireshark">
      <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="277px" height="265px" viewBox="0 0 277 265" enable-background="new 0 0 277 265" xml:space="preserve"><image id="image0" width="277" height="265" x="0" y="0"    href="data:image/png;base64,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" /></svg>
    </div>
    <div data-tooltip="Jmeter">
      <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="664px" height="643px" viewBox="0 0 664 643" enable-background="new 0 0 664 643" xml:space="preserve"><image id="image0" width="664" height="643" x="0" y="0"    href="data:image/png;base64,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" /></svg>
    </div>
    <div data-tooltip="Postman">
      <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="96px" height="96px" viewBox="0 0 96 96" enable-background="new 0 0 96 96" xml:space="preserve"><image id="image0" width="96" height="96" x="0" y="0"    href="data:image/png;base64,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" /></svg>
    </div>
    <div data-tooltip="Burpsiute">
      <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="83px" height="82px" viewBox="0 0 83 82" enable-background="new 0 0 83 82" xml:space="preserve"><image id="image0" width="83" height="82" x="0" y="0"    href="data:image/png;base64,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" /></svg>
    </div>
    <div data-tooltip="Docker">
      <svg t="1667037197731" viewBox="0 0 1220 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2460" width="200" height="200"><path d="M903.830212 959.568539c27.357803-23.522597 54.971286-47.045194 82.329089-70.82347 9.460175-8.181773 19.687391-16.363546 28.891885-25.056679-7.414732-9.460175-19.943071-16.107865-30.425968-20.198752-21.221473-8.181773-42.442946-5.369288-61.874656 5.880649-25.56804 14.829463-36.562297 38.35206-35.539576 67.755306 0.25568 11.505618 3.579526 22.755556 9.715855 32.471411 1.789763 3.579526 4.346567 6.903371 6.903371 9.971535m31.70437 22.244195c13.551061 4.602247 28.891885 4.090886 42.698626 1.534082 7.159051-3.068165 25.056679-10.994257 31.70437-9.715855l1.022722 0.255681 1.022721 0.51136c4.090886 2.045443 7.926092 4.857928 9.971536 8.948814 4.857928 9.715855 2.556804 19.43171-6.903371 24.800999l-3.068165 1.789763c-35.028215 20.198752-72.357553 17.386267-107.385768-1.534082-16.619226-8.948814-29.403246-22.499875-38.86342-38.863421l-2.301124-3.835206c-22.499875-39.119101-19.43171-80.027965 5.880649-117.101623 8.693134-12.78402 20.198752-22.755556 33.749813-30.425968l5.113608-2.812484c32.982772-19.17603 68.522347-17.897628 102.52784-1.022722 18.153308 8.948814 32.982772 22.499875 43.209988 40.141823l1.789763 3.068165c7.414732 12.78402-2.301124 24.033958-12.016979 31.704369-11.505618 8.948814-23.011236 19.43171-34.005493 29.147566-25.056679 20.965793-49.601998 42.442946-74.147316 63.408739z m262.83945-177.442197h3.579526c10.994257 0 18.408989 7.414732 18.408989 18.408989 0 15.340824-14.573783 19.17603-27.357803 19.17603-16.619226 0-32.471411 9.971536-43.977029 21.221473-14.318102 14.062422-20.454432 32.21573-20.454432 51.903121v89.48814c0 10.227216-6.39201 18.408989-17.130586 18.408988h-2.812485c-10.738577 0-17.130587-8.181773-17.130587-18.408988v-94.601748c0-36.306617 17.641948-65.965543 47.300874-86.931336 17.897628-12.016979 38.09638-18.664669 59.573533-18.664669z m-460.99176 63.664419c14.318102-14.318102 28.891885-28.636205 43.465668-42.954307 4.090886-3.835206 19.43171-20.710112 25.56804-20.710112h6.64769l0.767042 0.25568c8.437453 1.789763 14.829463 7.159051 14.829463 16.107865v3.579526c0 6.13633-7.159051 13.295381-11.249938 17.641948-8.437453 8.948814-17.386267 17.641948-26.079401 26.590761L746.586767 913.801748c19.17603 19.17603 38.35206 38.60774 57.528089 58.039451 5.369288 5.369288 10.482896 10.738577 15.852185 16.107865 1.789763 2.045443 4.602247 4.346567 6.13633 6.90337 1.534082 2.556804 2.556804 5.369288 2.556804 8.437454v3.835206l-0.255681 0.767041c-2.045443 8.437453-7.414732 15.340824-16.874906 15.340824h-3.068165c-6.13633 0-13.0397-6.903371-17.130587-10.994257-8.693134-8.181773-16.874906-16.619226-25.568039-25.05668l-28.380525-27.869163v44.488389c0 10.227216-6.39201 18.408989-17.130587 18.408989h-2.812484c-10.738577 0-17.130587-8.181773-17.130587-18.408989v-251.078152c0-10.227216 6.39201-18.408989 17.130587-18.408989h2.812484c10.738577 0 17.130587 8.181773 17.130587 18.408989v115.31186z m-119.914107-25.056679c-5.624969-2.556804-16.107865-3.579526-21.988515-3.835206-30.937328-1.278402-53.181523 16.363546-66.476903 43.465668-4.602247 9.460175-6.64769 19.43171-6.647691 29.658926 0 31.70437 16.619226 53.948564 44.99975 67.499626 10.227216 4.857928 23.778277 5.880649 35.028215 5.880649 9.971536 0 24.033958-6.13633 32.727091-10.227216l1.534083-0.767041h6.903371l0.767041 0.25568c8.437453 1.789763 14.829463 7.159051 14.829463 16.107865v3.579526c0 22.499875-41.164544 27.613483-56.761049 28.891885-55.482647 3.835206-96.902871-26.590762-112.755056-79.516604-2.812484-9.204494-4.090886-18.408989-4.090886-27.869164v-7.414731c0-40.141823 19.943071-71.846192 54.204244-92.300624 16.107865-9.460175 33.749813-14.318102 52.158802-14.318103h7.414731c19.687391 0 37.840699 5.624969 54.204245 16.619226l1.278402 1.022722 0.767041 1.278402c1.789763 2.812484 3.323845 6.39201 3.323846 9.715855v3.579526c0 9.460175-7.159051 14.573783-15.596505 16.107865h-3.068165c-5.369288 0.511361-17.897628-5.113608-22.755555-7.414732z m-337.498128 70.31211c0 28.124844 13.806742 48.834956 37.585019 63.408739 11.249938 6.903371 23.522597 9.971536 36.562297 9.971536 27.869164 0 48.323596-14.062422 62.641698-37.585019 6.903371-11.249938 9.971536-23.522597 9.971536-36.562297 0-26.079401-12.52834-46.022472-34.005493-60.596255-11.761298-7.926092-25.056679-12.016979-39.119101-12.016979-30.937328 0-53.181523 15.596504-66.732585 43.465668-4.857928 9.460175-6.903371 19.43171-6.903371 29.914607z m69.80075-110.198252h5.113608c42.954307 0 75.425718 20.710112 96.13583 58.295131 8.181773 15.085144 12.78402 31.193009 12.78402 48.323595v7.414732c0 40.141823-19.687391 72.101873-54.459925 92.300624-16.107865 9.460175-33.749813 14.318102-52.158802 14.318103h-7.414731c-40.141823 0-72.101873-19.943071-92.300625-54.204245-9.460175-16.107865-14.318102-33.749813-14.318102-52.158802v-7.414731c0-40.141823 19.943071-71.846192 54.204245-92.300624 16.107865-9.971536 33.749813-14.573783 52.414482-14.573783z m-311.930088 110.198252c0 28.891885 14.062422 50.624719 39.374782 64.687141 10.227216 5.624969 21.477154 8.693134 33.238452 8.693134 28.380524 0 49.601998-13.295381 64.17578-37.585019 6.64769-11.249938 9.971536-23.522597 9.971535-36.562297 0-25.056679-12.016979-44.74407-32.21573-59.317853-12.272659-8.948814-26.079401-13.295381-41.164544-13.295381-30.937328 0-53.181523 15.596504-66.732584 43.465668-4.602247 9.460175-6.64769 19.43171-6.647691 29.914607z m146.504869-82.584769v-78.238202c0-10.227216 6.39201-18.408989 17.130587-18.408989H204.54432c10.738577 0 17.130587 8.181773 17.130586 18.408989v164.402497c0 40.141823-19.943071 72.101873-54.459925 92.300624-16.107865 9.460175-33.749813 14.318102-52.158801 14.318102h-7.670412c-40.141823 0-72.101873-19.943071-92.300624-54.204244-9.460175-16.107865-14.318102-33.749813-14.318103-52.158802v-7.414732c0-40.141823 19.943071-72.101873 54.204245-92.300624 16.107865-9.460175 33.749813-14.318102 52.158801-14.318102h7.414732c27.357803 0 50.369039 10.482896 69.800749 27.613483zM704.14382 218.351061h109.175531V329.827715h55.226966c25.56804 0 51.647441-4.602247 75.937079-12.78402 11.761298-4.090886 25.056679-9.715855 36.817977-16.619226-15.340824-20.198752-23.266916-45.511111-25.56804-70.56779-3.068165-34.005493 3.835206-78.493883 26.846442-105.084644l11.505618-13.295381 13.551061 10.994257c34.516854 27.613483 63.408739 66.221223 68.522347 110.453933 41.420225-12.272659 89.999501-9.204494 126.561798 11.761298l15.085144 8.693134-7.926093 15.340824c-30.937328 60.340574-95.624469 79.005243-158.777528 75.681398-94.601748 235.481648-300.168789 346.958302-549.712859 346.958302-128.862921 0-247.242946-48.067915-314.486891-162.612734l-1.022722-1.789763-9.715855-19.943071C153.40824 456.645194 145.737828 401.418227 150.851436 346.446941l1.534082-16.619226h93.323346V218.351061h109.175531V109.175531h218.351061V0h130.908364v218.351061z" fill="#394D54" p-id="2461"></path><path d="M1057.749813 259.515605c7.414732-56.761049-35.283895-101.505119-61.618977-122.726591-30.425968 35.283895-35.028215 127.328839 12.52834 166.192259-26.590762 23.778277-82.840449 44.99975-140.112859 44.999751H168.749064c-5.624969 60.084894 4.857928 115.31186 28.891885 162.612734l7.926092 14.573783c5.113608 8.437453 10.482896 16.874906 16.619226 24.800998 28.636205 1.789763 55.226966 2.556804 79.516604 2.045444 47.556554-1.022722 86.675655-6.64769 116.078902-16.874907 4.346567-1.534082 9.204494 0.767041 10.738577 5.113608 1.534082 4.346567-0.767041 9.204494-5.113608 10.738577-3.835206 1.278402-7.926092 2.556804-12.27266 3.835206-23.266916 6.64769-48.067915 10.994257-80.283645 13.0397 1.789763 0-2.045443 0.25568-2.045443 0.255681-1.022722 0-2.556804 0.25568-3.579526 0.25568-12.52834 0.767041-26.335081 0.767041-40.141823 0.767041-15.340824 0-30.170287-0.25568-47.045193-1.022721l-0.511361 0.25568c58.295131 65.454182 149.317353 104.828964 263.606492 104.828964 241.873658 0 446.929338-107.130087 537.69588-347.725343 64.431461 6.64769 126.306117-9.715855 154.430961-64.687142-44.48839-26.079401-102.27216-17.897628-135.510611-1.278402z" fill="#00AADA" p-id="2462"></path><path d="M1057.749813 259.515605c7.414732-56.761049-35.283895-101.505119-61.618977-122.726591-30.425968 35.283895-35.028215 127.328839 12.52834 166.192259-26.590762 23.778277-82.840449 44.99975-140.112859 44.999751H210.169288c-2.812484 91.789263 31.193009 161.590012 91.533583 203.777278 47.556554-1.022722 86.675655-6.64769 116.078902-16.874906 4.346567-1.534082 9.204494 0.767041 10.738577 5.113608 1.534082 4.346567-0.767041 9.204494-5.113608 10.738577-3.835206 1.278402-7.926092 2.556804-12.27266 3.835206-23.266916 6.64769-50.369039 11.761298-82.329088 13.551061l-0.767041-0.767042c82.329089 42.187266 201.731835 42.187266 338.520848-10.482896 153.40824-58.806492 296.077903-171.305868 395.793259-299.657428-1.789763 1.022722-3.068165 1.789763-4.602247 2.301123z" fill="#24B8EB" p-id="2463"></path><path d="M170.283146 421.105618c4.346567 32.21573 13.806742 62.130337 27.613483 89.74382l7.926093 14.573783c5.113608 8.437453 10.482896 16.874906 16.619226 24.800999 28.891885 1.789763 55.226966 2.556804 79.516604 2.045443 47.556554-1.022722 86.675655-6.64769 116.078901-16.874906 4.346567-1.534082 9.204494 0.767041 10.738577 5.113608 1.534082 4.346567-0.767041 9.204494-5.113608 10.738576-3.835206 1.278402-7.926092 2.556804-12.272659 3.835206-23.266916 6.64769-50.113358 11.249938-82.329089 13.295381-1.022722 0-3.068165 0-4.090886 0.25568-12.52834 0.767041-26.079401 1.022722-40.141823 1.022722-15.340824 0-30.937328-0.25568-47.556554-1.022722 58.295131 65.454182 150.084395 104.828964 264.373533 104.828964 207.101124 0 387.100125-78.493883 491.673408-252.100874H170.283146z" fill="#008BB8" p-id="2464"></path><path d="M216.561298 421.105618c12.272659 56.505368 42.187266 100.738077 85.397254 130.908365 47.556554-1.022722 86.675655-6.64769 116.078901-16.874907 4.346567-1.534082 9.204494 0.767041 10.738577 5.113608 1.534082 4.346567-0.767041 9.204494-5.113608 10.738577-3.835206 1.278402-7.926092 2.556804-12.272659 3.835206-23.266916 6.64769-50.624719 11.249938-82.84045 13.295381 82.329089 42.187266 201.220474 41.675905 338.009488-10.994257 82.840449-31.70437 162.357054-79.005243 233.947566-136.021973H216.561298z" fill="#039BC6" p-id="2465"></path><path d="M343.123096 244.430462h7.414732v78.749563h-7.414732V244.430462z m-14.318102 0h7.670412v78.749563h-7.670412V244.430462z m-14.318103 0h7.670412v78.749563h-7.670412V244.430462z m-14.318102 0h7.670412v78.749563h-7.670412V244.430462z m-14.318102 0h7.670412v78.749563h-7.670412V244.430462z m-14.062422 0h7.414731v78.749563h-7.414731V244.430462z m-7.926093-7.926092h94.601748v94.601747h-94.601748v-94.601747zM452.298627 135.254931h7.414731v78.749563h-7.414731V135.254931z m-14.318103 0h7.670412v78.749563h-7.670412V135.254931z m-14.318102 0h7.670412v78.749563h-7.670412V135.254931z m-14.318102 0h7.670412v78.749563h-7.670412V135.254931z m-14.318103 0h7.670412v78.749563h-7.670412V135.254931z m-14.062422 0h7.414732v78.749563H380.963795V135.254931z m-7.926092-7.926092h94.601748v94.601748h-94.601748v-94.601748z" fill="#00ACD3" p-id="2466"></path><path d="M452.298627 244.430462h7.414731v78.749563h-7.414731V244.430462z m-14.318103 0h7.670412v78.749563h-7.670412V244.430462z m-14.318102 0h7.670412v78.749563h-7.670412V244.430462z m-14.318102 0h7.670412v78.749563h-7.670412V244.430462z m-14.318103 0h7.670412v78.749563h-7.670412V244.430462z m-14.062422 0h7.414732v78.749563H380.963795V244.430462z m-7.926092-7.926092h94.601748v94.601747h-94.601748v-94.601747z" fill="#20C2EF" p-id="2467"></path><path d="M561.474157 244.430462h7.414732v78.749563h-7.414732V244.430462z m-14.318102 0h7.670412v78.749563h-7.670412V244.430462z m-14.318102 0h7.670412v78.749563h-7.670412V244.430462z m-14.318103 0h7.670412v78.749563h-7.670412V244.430462z m-14.573783 0h7.670412v78.749563h-7.670412V244.430462z m-13.806741 0h7.414731v78.749563h-7.414731V244.430462z m-7.926093-7.926092h94.601748v94.601747h-94.601748v-94.601747z" fill="#00ACD3" p-id="2468"></path><path d="M561.474157 135.254931h7.414732v78.749563h-7.414732V135.254931z m-14.318102 0h7.670412v78.749563h-7.670412V135.254931z m-14.318102 0h7.670412v78.749563h-7.670412V135.254931z m-14.318103 0h7.670412v78.749563h-7.670412V135.254931z m-14.573783 0h7.670412v78.749563h-7.670412V135.254931z m-13.806741 0h7.414731v78.749563h-7.414731V135.254931z m-7.926093-7.926092h94.601748v94.601748h-94.601748v-94.601748zM670.649688 244.430462h7.414731v78.749563h-7.414731V244.430462z m-14.318102 0h7.670412v78.749563h-7.670412V244.430462z m-14.318103 0h7.670412v78.749563h-7.670412V244.430462z m-14.573783 0h7.670412v78.749563h-7.670412V244.430462z m-14.318102 0h7.670412v78.749563h-7.670412V244.430462z m-13.806742 0h7.414732v78.749563h-7.414732V244.430462z m-7.926092-7.926092h94.601748v94.601747h-94.601748v-94.601747z" fill="#20C2EF" p-id="2469"></path><path d="M670.649688 135.254931h7.414731v78.749563h-7.414731V135.254931z m-14.318102 0h7.670412v78.749563h-7.670412V135.254931z m-14.318103 0h7.670412v78.749563h-7.670412V135.254931z m-14.573783 0h7.670412v78.749563h-7.670412V135.254931z m-14.318102 0h7.670412v78.749563h-7.670412V135.254931z m-13.806742 0h7.414732v78.749563h-7.414732V135.254931z m-7.926092-7.926092h94.601748v94.601748h-94.601748v-94.601748z" fill="#00ACD3" p-id="2470"></path><path d="M670.649688 26.079401h7.414731V104.828964h-7.414731V26.079401z m-14.318102 0h7.670412V104.828964h-7.670412V26.079401z m-14.318103 0h7.670412V104.828964h-7.670412V26.079401z m-14.573783 0h7.670412V104.828964h-7.670412V26.079401z m-14.318102 0h7.670412V104.828964h-7.670412V26.079401z m-13.806742 0h7.414732V104.828964h-7.414732V26.079401z m-7.926092-7.926093h94.601748v94.601748h-94.601748v-94.601748z" fill="#20C2EF" p-id="2471"></path><path d="M779.825218 244.430462h7.414732v78.749563H779.825218V244.430462z m-14.318102 0h7.670412v78.749563h-7.670412V244.430462z m-14.573783 0h7.670412v78.749563h-7.670412V244.430462z m-14.318102 0h7.670412v78.749563h-7.670412V244.430462z m-14.318102 0h7.670412v78.749563h-7.670412V244.430462z m-14.062422 0h7.414731v78.749563H708.234707V244.430462z m-7.670412-7.926092h94.601747v94.601747h-94.601747v-94.601747z" fill="#00ACD3" p-id="2472"></path><path d="M461.758801 484.514357c14.318102 0 26.079401 11.761298 26.079401 26.079401s-11.761298 26.079401-26.079401 26.079401-26.079401-11.761298-26.0794-26.079401 11.505618-26.079401 26.0794-26.079401" fill="#D4EDF1" p-id="2473"></path><path d="M461.758801 491.929089c2.301124 0 4.602247 0.511361 6.647691 1.278402-2.301124 1.278402-3.835206 3.835206-3.835206 6.64769 0 4.090886 3.323845 7.670412 7.670412 7.670412 2.812484 0 5.369288-1.534082 6.64769-4.090886 1.022722 2.301124 1.534082 4.602247 1.534083 7.159051 0 10.227216-8.437453 18.664669-18.66467 18.664669s-18.664669-8.437453-18.664669-18.664669 8.181773-18.664669 18.664669-18.664669M0 430.310112h1214.226217c-26.335081-6.64769-83.607491-15.852185-74.147316-50.369038-48.067915 55.738327-163.891136 39.119101-193.294382 11.505618-32.471411 47.300874-222.186267 29.403246-235.481648-7.414732-40.908864 47.812235-167.470662 47.812235-208.379525 0-13.295381 36.817978-203.010237 54.715605-235.481648 7.414732-29.147566 27.357803-145.226467 43.977029-193.294382-11.505618 9.460175 34.772534-47.812235 43.721348-74.147316 50.369038" fill="#394D54" p-id="2474"></path><path d="M531.04819 672.695131c-64.687141-30.681648-100.226717-72.357553-119.914108-117.868664-24.033958 6.903371-52.925843 11.249938-86.419975 13.0397-12.52834 0.767041-25.82372 1.022722-39.886142 1.022722-16.107865 0-32.982772-0.511361-50.880399-1.534083 59.317853 59.317853 132.186767 104.828964 267.186017 105.596005 10.227216 0.25568 19.943071 0 29.914607-0.25568z" fill="#BFDBE0" p-id="2475"></path><path d="M435.16804 596.758052c-8.948814-12.016979-17.641948-27.357803-24.033958-41.931585-24.033958 6.903371-52.925843 11.249938-86.419975 13.0397 23.011236 12.52834 55.994007 24.033958 110.453933 28.891885z" fill="#D4EDF1" p-id="2476"></path></svg>
    </div>
    <div data-tooltip="HTML 5">
      <svg t="1594449205433" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1511" width="200" height="200"><path d="M89.088 59.392l62.464 803.84c1.024 12.288 9.216 22.528 20.48 25.6L502.784 993.28c6.144 2.048 12.288 2.048 18.432 0l330.752-104.448c11.264-4.096 19.456-14.336 20.48-25.6l62.464-803.84c1.024-17.408-12.288-31.744-29.696-31.744H118.784c-17.408 0-31.744 14.336-29.696 31.744z" fill="#FC490B" p-id="1512"></path><path d="M774.144 309.248h-409.6l12.288 113.664h388.096l-25.6 325.632-227.328 71.68-227.328-71.68-13.312-169.984h118.784v82.944l124.928 33.792 123.904-33.792 10.24-132.096H267.264L241.664 204.8h540.672z" fill="#FFFFFF" p-id="1513"></path></svg>
    </div>
    <div data-tooltip="CSS 3">
      <svg t="1594449320423" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5999" width="200" height="200"><path d="M88.064 27.648l77.824 871.424L512 996.352l346.112-97.28 77.824-871.424z" fill="#2196F3" p-id="6000"></path><path d="M771.072 312.32l-10.24 109.568-29.696 328.704L512 811.008l-220.16-60.416-14.336-172.032h107.52l7.168 89.088L512 700.416l119.808-32.768 16.384-148.48-375.808 1.024-11.264-101.376 395.264-4.096 8.192-108.544-413.696 1.024-7.168-101.376h536.576z" fill="#FAFAFA" p-id="6001"></path></svg>
    </div>
    <div data-tooltip="JavaScript">
      <svg t="1594452832532" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="978" width="200" height="200"><path d="M38.56886067 38.56886067h946.86227866v946.86227866H38.56886067V38.56886067m248.81436505 791.1560377c21.04138438 44.71294135 62.5981169 81.53536248 133.61278901 81.53536246 78.9051899 0 133.08675402-42.08276753 133.08675281-134.13882281v-304.04799797h-89.42588147V775.01729921c0 45.23897512-18.41121055 56.81173672-47.34311392 56.81173673-30.51000717 0-43.13483754-21.04138438-57.33777176-45.76501015l-72.59277467 43.66087258m314.56869076-9.4686228c26.30172955 51.55139031 79.4312249 91.00398527 162.54469117 91.00398526 84.16553629 0 147.28968821-43.66087133 147.2896882-124.14416501 0-74.17087849-42.60880254-107.31105826-118.35778483-139.92520422l-22.09345319-9.46862279c-38.40052617-16.307073-54.70759791-27.35379957-54.70759912-53.65552911 0-21.56741817 16.307073-38.40052617 42.60880252-38.40052493 25.24966076 0 42.08276753 11.04672657 57.33777173 38.40052493l68.91053209-45.76501015c-28.93190337-50.49932154-69.96260211-69.96260211-126.24830382-69.96260088-79.4312249 0-130.45658021 50.49932154-130.45658019 117.30571482 0 72.5927747 42.60880254 106.78502324 106.78502324 134.13882281l22.09345315 9.46862278c41.03069875 17.88517679 65.22829073 28.93190337 65.22829072 59.44191054 0 25.24966076-23.67155698 43.66087133-60.49397931 43.66087133-43.66087133 0-68.91053209-22.61948818-87.84777766-54.18156414l-72.5927747 42.08276876z" fill="#FFCA28" p-id="979"></path></svg>
    </div>
    <div data-tooltip="Vue.js">
      <svg t="1594449992255" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1022" width="200" height="200"><path d="M627.85285817 77.66360895h185.07382266L512 598.88964363 211.07331917 77.66360895H10.45553197L512 946.33639105l501.54446803-868.78460919z" fill="#41B883" p-id="1023"></path><path d="M812.92668083 77.66360895H627.85285817L512 278.28139617 396.14714183 77.66360895H211.07331917L512 598.88964363z" fill="#34495E" p-id="1024"></path></svg>
    </div>
    <div data-tooltip="MySQL">
      <svg t="1597992373909" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="9841" width="200" height="200"><path d="M715.8 312.4l-5.6-11.7c-2.4-3.4-5.9-6-7.9-10h-0.6v-0.6c3.3-0.8 6.7-1.2 10.1-1.1 2 1.9 5.1 3.3 6.7 5.6 1.2 1.7 1.4 3.6 2.8 5 0 5.9-1.6 9.8-5.1 12.3 0.2-0.1-0.4 0.5-0.4 0.5z m251.9 251.1c-9.3-5.9-20.1-9.2-29.8-15.1-5.4-3.3-10.7-7.4-15.7-11.2-4.7-3.5-9.9-10.1-12.9-15.1-1.6-2.6-1.9-5.7-3.9-7.8 0.6-4.6 6.4-4.6 10.1-6.1 12.9-5.4 28-7.2 47.8-6.7-0.6-5-12.9-11.2-16.9-13.9-8-5.6-16.2-11.6-24.7-16.8-4.5-2.7-12.2-4.7-16.9-6.7-6.7-2.8-21.5-5.5-25.3-10.6-7.3-9.6-12.3-21.3-17.4-32.9-5.2-11.6-11.7-23.8-16.9-35.7-2.6-5.9-3.8-11.2-6.7-16.7-18.1-34.5-44.6-63.4-77-83.7-10.6-6.7-22.4-12.8-35.4-16.7-7.4-2.2-16.3-1-24.2-2.8h-5.1c-4.4-1.3-8.1-6-11.8-8.4-7.6-5-15.2-8.6-24.2-12.3-3.4-1.4-12.5-4.7-15.7-2.2-1.9 0.6-2.8 1.4-3.4 3.3-1.9 2.9-0.2 7.3 1.1 10 3.6 7.8 8.8 12.5 13.5 19 4.2 5.8 9.3 12.4 12.4 19 6.3 13.7 9.2 28.9 15.2 42.4 2.3 5.2 5.7 11.1 9 15.6 2.7 3.6 7.5 6.4 9 11.2 3.1 4.8-4.5 21.1-6.2 26.2-6.5 20-5.1 47.9 2.2 65.3 2.9 6.9 5.7 14.9 13.5 16.7 0.6-0.4 0.1-0.2 1.1-0.5 1.7-13.4 2.2-26.3 6.7-36.8 2.8-6.6 8.2-11.1 11.8-16.7 2.7 1.5 2.6 6 3.9 8.9 3.3 7.6 6.8 15.9 10.7 23.4 8.3 15.7 17.3 30.8 27.6 44.6 3.6 4.9 8.5 10.2 12.9 14.5 1.9 1.8 4.2 2.8 5.6 5h0.6v0.6c-7.6-2.6-12.1-10.1-18-14.5-11.3-8.4-24.6-21-32-32.9l-10.1-20.1v-0.6c-1.4 1.9-1 3.9-1.7 6.7-3.2 12.3-0.7 26.2-11.8 30.7-12.7 5.1-21.9-8.3-25.9-14.5-12.8-20.3-16.1-54.5-7.3-82 1.9-6.1 2.1-13.6 5.6-18.4-0.6-4.3-4.1-5.6-6.2-8.4-3.4-4.6-6.3-10-9-15.1-5.3-10.1-8.8-22-12.9-32.9-1.7-4.4-2-8.6-3.9-12.8-2.9-6.4-8.2-12.7-12.4-18.4-5.9-8.1-22.3-23.7-15.7-39.6 10.4-25.3 46.6-6.1 60.7 2.8 3.5 2.2 7.5 6.8 11.2 8.4l18.6 1.1c11.5 2.7 22.4 4.8 31.5 10 42.6 24.7 70 49.9 95.6 91.5 5.3 8.7 8.1 18.2 12.4 27.9 6.3 14.4 13 28.5 20.3 42.4 3.4 6.4 5.8 13.5 10.1 19 1.8 2.3 6.8 3.1 9.6 4.5 8.3 4.2 18 7.3 25.9 12.3 14.2 8.9 27.9 19.5 40.5 30.1 4.8 4.1 8 10 12.4 14.5v2.2c-3.9 1.1-7.9 2.2-11.8 3.3-8.7 2.2-16.3 1.7-24.7 3.9-5 1.3-11.4 3.3-16.9 3.9l0.6 0.5c3.2 8.9 20.4 16.3 28.1 21.8 9.6 6.9 18.7 15.1 25.9 24.5l7.3 7.3c1.7 2.4 2.1 5.5 3.9 7.8v0.5c-3.4-1.2-5.2-4.2-7.9-6.1-5.7-3.8-11.1-8.1-16.6-11.6zM373 728.9H271.4v-21.5h101.7c20.7-2.2 18.3-12.4 18.3-15.8v-8.4h-68.3c-31.8-0.3-52.1-14.1-52.3-29.9 0-1.5 0.7-71 0-71.6H303v69.5c-0.3 3.8 1.2 12.6 18.8 12.9 9 0.1 69.4 0 69.9 0v-82.7h32.2c0.2 0 0 112.8 0 113.3 0.2 27.7-34.8 33.7-50.9 34.2zM211.8 558.2L162 668.1c-5.9 13.3-13.6 18-29.4 18-15.8 0-23.8-4.7-29.7-18L53.2 558.2v126.1H21V558.4c0-12.3 4.9-18.2 15.2-21.3 24.4-7.6 41.1-1 48.2 15.3l47.3 108.5 48.9-108.5c7.4-16.4 23.8-22.9 48.3-15.3 10.2 3.1 15.2 9 15.2 21.3v125.9h-32.2l-0.1-126.1z" fill="#00758F" p-id="9842"></path><path d="M659.8 536.6h61.1c3.1 0 5.9 0.2 9 0.6 27 3.7 40.6 15.4 40.6 34.7v75.9c0 15.6-5.8 24-19.1 29.5l31.7 28.4h-37.3l-25.6-23-25.8 1.6H660c-6.4 0-12.8-0.9-18.9-2.7-20.5-5.5-30.4-16.2-30.4-33.8v-75.9c0-19.3 13.6-31 40.6-34.7 2.6-0.4 5.7-0.6 8.5-0.6z m-14.6 109.3c0 1 0.3 2.1 0.6 3.3 1.9 8.8 10.2 13.7 22.9 13.7H698l-26.8-24.1h37.3l23.4 21c4.3-2.3 7.2-5.8 8.2-10.3 0.3-1 0.3-2.1 0.3-3.1v-72.8c0-0.8 0-1.9-0.3-2.9-1.9-8.2-10.2-12.9-22.6-12.9h-48.7c-14.3 0-23.6 6.2-23.6 15.8v72.3z m-148.9-88.1c-11.5 1-14.9 2.9-16.4 9.4-0.3 1-0.3 1.9-0.3 2.7v14.5c0 1 0 1.8 0.3 2.9 1.5 8.6 7.7 12.5 20.7 12.5h39c9.6 0 19.5 1.6 27.5 4.7 15.2 5.7 22.9 14.3 22.9 23.5v23.3c0 11.3-6.8 19.9-20.7 26.2-8.3 3.9-18.9 6.1-29.7 6.1h-92.5v-21.3h88.8c1.2 0 2.2-0.2 3.4-0.2 6.2-0.4 10.8-2.1 13.6-4.5 3.1-2.5 4.6-5.3 4.6-7.6v-18.6c0-2.2-0.9-4.3-2.5-5.7-3.1-3.7-7.4-5.5-17.6-6.3-0.9-0.2-2.2-0.2-3.4-0.2h-33.4c-3.1 0-6.2-0.2-9.3-0.4-27.5-2.9-43.9-15.1-43.9-29.5v-18.6c0-16.4 8.4-25.8 27.5-31.7 6.2-1.8 13-2.7 26-2.7h90.3v21.3h-91.9c-0.9 0-2.1 0.2-3 0.2z m326.5 88.6c0 11.3 7.1 16 26 16h84.4v21.3h-83.8c-3.1 0-6.2-0.2-9.3-0.4-33.1-2.4-49.5-14.7-49.5-36.6V536.3h32.2v110.1z m149.2-8.2c12.5 0 23.7 9.5 23.7 23.5 0 14.1-11.2 23.5-23.7 23.5s-23.7-9.5-23.7-23.5 11.2-23.5 23.7-23.5z m0 42.2c10.2 0 18.4-8 18.4-18.6 0-10.7-8.2-18.6-18.4-18.6-10.3 0-18.4 8-18.4 18.6 0.1 10.6 8.1 18.6 18.4 18.6z m11.3-24.3c0 4.9-3.2 6.9-7.3 7.3l7.8 11.8h-5.3l-7.1-11.6h-4.2v11.6h-4.5v-26.9h10.6c6.5 0 10 2.3 10 7.8z m-16.2-4v7.7h4.9c3.4 0 6.4-0.3 6.4-4.1 0-3.1-3.3-3.6-6-3.6h-5.3z" fill="#F2A72F" p-id="9843"></path></svg>
    </div>
    <div data-tooltip="Redis">
      <svg t="1651213212000" viewBox="0 0 1173 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1281" width="200" height="200"><path d="M1.914402 656.839666L0 789.329468l516.178817 226.592549s55.03905 26.933652 151.072702-17.559685c60.369668-28.055887 505.89716-236.560641 505.897159-236.560641v-126.548555s0.775663 16.850036-12.872701 24.441629-543.69009 239.547768-543.69009 239.547767-43.024528 14.737593-80.223334 0.544615c-13.202771-5.033556-93.195056-42.182852-198.2396-87.781921-151.171723-65.601266-326.108432-139.421257-326.108432-139.421257s-8.845856-7.608097-10.100119-15.744303z" fill="#A42122" p-id="1282"></path><path d="M534.530668 426.797893s78.061381-32.792381 148.333127 0 477.808265 188.931646 477.808265 188.931646 35.911536 29.706234-14.06095 51.540315-538.706044 235.768475-538.706045 235.768475-45.268999 17.180105-110.853762-18.731431C433.611991 849.567108 38.519083 684.796532 12.757177 674.052778a6.436351 6.436351 0 0 1-2.475519-1.765871c-5.660688-6.287819-28.055887-35.564963 26.141485-54.989539 60.897779-21.867089 498.107525-190.499475 498.107525-190.499475z" fill="#D82F27" p-id="1283"></path><path d="M1.914402 450.6619L0 583.151703l516.178817 226.592549S571.217867 836.727414 667.251519 792.168063c60.369668-28.055887 505.89716-236.560641 505.897159-236.56064V429.091874s0.775663 16.850036-12.872701 24.441629S616.585887 693.147284 616.585887 693.147284s-43.024528 14.737593-80.223334 0.544615c-13.202771-5.033556-93.195056-42.182852-198.2396-87.781921-151.171723-65.601266-326.108432-139.421257-326.108432-139.421257s-8.845856-7.690614-10.100119-15.826821z" fill="#A42122" p-id="1284"></path><path d="M534.530668 220.686141s78.061381-32.792381 148.333127 0S1160.67206 409.617787 1160.67206 409.617787s35.911536 29.706234-14.06095 51.540316-538.706044 235.768475-538.706045 235.768475-45.268999 17.180105-110.853762-18.731431C433.611991 643.455357 38.519083 478.684781 12.757177 467.941026a6.436351 6.436351 0 0 1-2.475519-1.76587c-5.660688-6.287819-28.055887-35.564963 26.141485-54.98954 60.897779-21.867089 498.107525-190.499475 498.107525-190.499475z" fill="#D82F27" p-id="1285"></path><path d="M1.914402 244.550149L0 377.039951l516.178817 226.592549s55.03905 26.933652 151.072702-17.559684c60.369668-28.055887 505.89716-236.560641 505.897159-236.560641v-126.482542s0.775663 16.850036-12.872701 24.425125S616.585887 487.01903 616.585887 487.01903s-43.024528 14.737593-80.223334 0.544614c-13.202771-4.951039-93.195056-42.182852-198.2396-87.781921-151.171723-65.601266-326.108432-139.421257-326.108432-139.421256s-8.845856-7.608097-10.100119-15.810318z" fill="#A42122" p-id="1286"></path><path d="M534.530668 14.57439s78.061381-32.792381 148.333127 0 477.808265 188.931646 477.808265 188.931646 35.911536 29.706234-14.06095 51.540316S607.905065 490.814826 607.905065 490.814826s-45.268999 17.180105-110.853762-18.731431C433.611991 437.343606 38.519083 272.573029 12.757177 261.829275a6.436351 6.436351 0 0 1-2.475519-1.765871c-5.660688-6.287819-28.055887-35.564963 26.141485-54.989539C97.320922 183.190273 534.530668 14.57439 534.530668 14.57439z" fill="#D82F27" p-id="1287"></path><path d="M195.681563 239.929179a152.244448 63.505326 0 1 0 304.488895 0 152.244448 63.505326 0 1 0-304.488895 0Z" fill="#FFFFFF" p-id="1288"></path><path d="M526.708027 66.098202l20.299259 45.285503-79.629209 34.36021 119.650107 10.925293 25.563865 59.32995 26.554072-60.897779h92.122331l-68.703917-35.911536 18.731431-43.717674-67.136088 21.867089-87.451851-31.241056zM422.092574 339.362545l192.067304 85.884022 76.510055-121.795558-268.577359 35.911536z" fill="#FFFFFF" p-id="1289"></path><path d="M860.870149 169.162329L690.669933 239.929179l170.200216 63.52183V169.162329z" fill="#AD2524" p-id="1290"></path><path d="M1010.771104 228.492279l-149.900955-59.32995v134.28868l149.900955-74.95873z" fill="#791514" p-id="1291"></path></svg>
    </div>
    <div data-tooltip="Elasticsearch">
      <svg width="64px" height="64px" viewBox="0 0 64 64" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="icon-/-product-logo-/-64x64px-/-elastic-sesrch-/-color" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="logo-elastic-search-64x64-color" transform="translate(8.000000, 4.999500)"><path d="M47.7246,9.708 L47.7276,9.702 C42.7746,3.774 35.3286,0 26.9996,0 C16.4006,0 7.2326,6.112 2.8136,15 L38.0056,15 C40.5306,15 42.9886,14.13 44.9206,12.504 C45.9246,11.659 46.8636,10.739 47.7246,9.708" id="Fill-1" fill="#FEC514"></path><path d="M0,27.0005 C0,29.4225 0.324,31.7675 0.922,34.0005 L34,34.0005 C37.866,34.0005 41,30.8665 41,27.0005 C41,23.1345 37.866,20.0005 34,20.0005 L0.922,20.0005 C0.324,22.2335 0,24.5785 0,27.0005" id="Fill-4" fill="#343741"></path><path d="M47.7246,44.293 L47.7276,44.299 C42.7746,50.227 35.3286,54.001 26.9996,54.001 C16.4006,54.001 7.2326,47.889 2.8136,39.001 L38.0056,39.001 C40.5306,39.001 42.9886,39.871 44.9206,41.497 C45.9246,42.342 46.8636,43.262 47.7246,44.293" id="Fill-6" fill="#00BFB3"></path></g></g></svg>
    </div>
    <div data-tooltip="NGINX">
      <svg t="1597992219506" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2608" width="200" height="200"><path d="M512 0L68.48 256v512L512 1024l443.52-256V256z m256 707.84c0 30.08-27.552 55.04-65.248 55.04-26.912 0-57.632-10.88-76.832-34.56l-256-304.672v284.16c0 30.752-24.32 55.04-54.368 55.04H312.32c-30.752 0-55.04-25.6-55.04-55.04V316.16c0-30.08 26.88-55.04 64-55.04 27.552 0 58.88 10.88 78.08 34.56l254.72 304.672V316.16c0-30.752 25.6-55.04 55.04-55.04h3.2c30.72 0 55.04 25.6 55.04 55.04v391.68z" fill="#269539" p-id="2609"></path></svg>
    </div>
    <div data-tooltip="Git">
      <svg t="1594452867673" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="837" width="200" height="200"><path d="M63.49884471 444.72482676L339.27934283 168.4672005l80.63478137 81.1119106c-11.45109332 40.55595587 7.15693331 84.92894248 44.3729866 106.39974246v264.32940369c-28.62773329 16.22238256-47.7128892 47.23575993-47.71288806 82.54329842a95.42577726 95.42577726 0 0 0 95.42577726 95.42577726 95.42577726 95.42577726 0 0 0 95.42577726-95.42577726c0-35.30753736-19.08515589-66.32091583-47.71288806-82.54329842V388.42361757l98.76567986 99.7199384c-3.33990259 7.15693331-3.33990259 15.26812405-3.33990261 23.85644403a95.42577726 95.42577726 0 0 0 95.42577728 95.42577726 95.42577726 95.42577726 0 0 0 95.42577839-95.42577726 95.42577726 95.42577726 0 0 0-95.42577839-95.42577726c-8.58831998 0-16.69951071 0-23.85644403 3.33990146L604.0858758 297.2920003a94.47151987 94.47151987 0 0 0-54.86982251-111.64815985c-20.51654257-7.63406259-41.98734253-9.54257739-61.07249732-4.29415998L407.03164421 100.71489799l37.69318255-37.21605328c37.21605328-37.69318254 97.3342932-37.69318254 134.55034648 0l381.22598205 381.22598205c37.69318254 37.21605328 37.69318254 97.3342932 0 134.55034648l-381.22598205 381.22598205c-37.21605328 37.69318254-97.3342932 37.69318254-134.55034648 0L63.49884471 579.27517324c-37.69318254-37.21605328-37.69318254-97.3342932 0-134.55034648z" fill="#E64A19" p-id="838"></path></svg>
    </div>
    <div data-tooltip="Ubuntu">
      <svg t="1597991636564" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="10406" width="200" height="200"><path d="M1022.548 510.732c0 282.056-228.66 510.72-510.732 510.72C229.736 1021.452 1.08 792.788 1.08 510.732 1.08 228.66 229.744 0 511.816 0c282.076 0 510.732 228.66 510.732 510.732z" fill="#DD4814" p-id="10407"></path><path d="M164.532 442.532c-37.676 0-68.2 30.524-68.2 68.2 0 37.656 30.524 68.184 68.2 68.184 37.66 0 68.184-30.528 68.184-68.184 0-37.676-30.524-68.2-68.184-68.2z m486.86 309.912c-32.612 18.84-43.8 60.52-24.96 93.116 18.82 32.616 60.5 43.796 93.116 24.96 32.612-18.82 43.796-60.5 24.96-93.12-18.82-32.592-60.524-43.772-93.116-24.956z m-338.744-241.712c0-67.384 33.472-126.92 84.684-162.968L347.48 264.268c-59.656 39.88-104.048 100.816-122.496 172.188 21.528 17.56 35.304 44.3 35.304 74.272 0 29.956-13.776 56.696-35.304 74.26C243.408 656.376 287.8 717.32 347.48 757.2l49.852-83.52c-51.212-36.028-84.684-95.56-84.684-162.948z m199.168-199.188c104.052 0 189.42 79.776 198.38 181.52l97.16-1.432c-4.776-75.112-37.592-142.544-88.008-192.128-25.928 9.796-55.88 8.296-81.76-6.624-25.932-14.964-42.192-40.208-46.636-67.608a297.04 297.04 0 0 0-79.14-10.76 295.148 295.148 0 0 0-131.276 30.652l47.38 84.908a198.384 198.384 0 0 1 83.9-18.528z m0 398.36a198.404 198.404 0 0 1-83.896-18.528l-47.38 84.9a294.848 294.848 0 0 0 131.28 30.684 296.16 296.16 0 0 0 79.136-10.788c4.444-27.4 20.708-52.62 46.632-67.608 25.904-14.948 55.836-16.42 81.76-6.624 50.42-49.584 83.232-117.016 88.016-192.128l-97.188-1.432c-8.94 101.772-94.304 181.52-198.36 181.52z m139.552-440.924c32.616 18.832 74.3 7.68 93.116-24.936 18.84-32.616 7.68-74.3-24.936-93.14-32.616-18.816-74.296-7.64-93.14 24.976-18.812 32.6-7.632 74.28 24.96 93.1z" fill="#FFFFFF" p-id="10408"></path></svg>
    </div>
    <div data-tooltip="CentOS">
      <svg width="256px" height="256px" viewBox="0 0 256 256" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" preserveAspectRatio="xMidYMid"><g><path d="M107.860446,118.641168 L117.088645,127.817911 L107.860446,136.99288 L42.9010976,136.99288 L42.9010976,167.564282 L3.28602642,127.817911 L42.9010976,88.7386823 L42.9010976,118.641168 L107.860446,118.641168 L107.860446,118.641168 L107.860446,118.641168 L107.860446,118.641168 Z M136.414454,40.5732 L215.342964,40.5732 L215.342964,119.503484 L136.414454,119.503484 L136.414454,40.5732 L136.414454,40.5732 L136.414454,40.5732 L136.414454,40.5732 Z" fill="#932279"></path><path d="M137.274996,107.860446 L128.100027,117.088645 L118.925058,107.860446 L118.925058,42.9010976 L88.3518821,42.9010976 L128.100027,3.28602642 L167.177481,42.9010976 L137.274996,42.9010976 L137.274996,107.860446 L137.274996,107.860446 L137.274996,107.860446 L137.274996,107.860446 Z M136.414454,136.414454 L215.342964,136.414454 L215.342964,215.344738 L136.414454,215.344738 L136.414454,136.414454 L136.414454,136.414454 L136.414454,136.414454 L136.414454,136.414454 Z" fill="#EFA724"></path><path d="M148.057492,137.274996 L138.827519,128.100027 L148.057492,118.925058 L213.015067,118.925058 L213.015067,88.3518821 L252.631911,128.100027 L213.015067,167.177481 L213.015067,137.274996 L148.057492,137.274996 L148.057492,137.274996 L148.057492,137.274996 L148.057492,137.274996 Z M40.5732,136.414454 L119.501709,136.414454 L119.501709,215.344738 L40.5732,215.344738 L40.5732,136.414454 L40.5732,136.414454 L40.5732,136.414454 L40.5732,136.414454 Z" fill="#262577"></path><path d="M118.641168,148.057492 L127.816137,138.827519 L136.99288,148.057492 L136.99288,213.016841 L167.564282,213.016841 L127.816137,252.631911 L88.7404565,213.016841 L118.641168,213.016841 L118.641168,148.057492 L118.641168,148.057492 L118.641168,148.057492 L118.641168,148.057492 Z M40.5732,40.5732 L119.501709,40.5732 L119.501709,119.503484 L40.5732,119.503484 L40.5732,40.5732 L40.5732,40.5732 L40.5732,40.5732 L40.5732,40.5732 Z" fill="#9CCD2A"></path><path d="M37.7538176,37.7538176 L122.321092,37.7538176 L122.321092,122.321092 L37.7538176,122.321092 L37.7538176,37.7538176 L37.7538176,37.7538176 L37.7538176,37.7538176 L37.7538176,37.7538176 L37.7538176,37.7538176 Z M43.3908078,116.684101 L116.682327,116.684101 L116.682327,43.3925822 L43.3908078,43.3925822 L43.3908078,116.684101 L43.3908078,116.684101 L43.3908078,116.684101 L43.3908078,116.684101 Z M133.596846,37.7538176 L218.164121,37.7538176 L218.164121,122.321092 L133.596846,122.321092 L133.596846,37.7538176 L133.596846,37.7538176 L133.596846,37.7538176 L133.596846,37.7538176 Z M139.233837,116.684101 L212.525356,116.684101 L212.525356,43.3925822 L139.233837,43.3925822 L139.233837,116.684101 L139.233837,116.684101 L139.233837,116.684101 L139.233837,116.684101 Z M133.596846,133.596846 L218.164121,133.596846 L218.164121,218.165895 L133.596846,218.165895 L133.596846,133.596846 L133.596846,133.596846 L133.596846,133.596846 L133.596846,133.596846 Z M139.233837,212.525356 L212.525356,212.525356 L212.525356,139.233837 L139.233837,139.233837 L139.233837,212.525356 L139.233837,212.525356 L139.233837,212.525356 L139.233837,212.525356 Z M37.7538176,133.596846 L122.321092,133.596846 L122.321092,218.165895 L37.7538176,218.165895 L37.7538176,133.596846 L37.7538176,133.596846 L37.7538176,133.596846 L37.7538176,133.596846 Z M43.3908078,212.525356 L116.682327,212.525356 L116.682327,139.233837 L43.3908078,139.233837 L43.3908078,212.525356 L43.3908078,212.525356 L43.3908078,212.525356 L43.3908078,212.525356 L43.3908078,212.525356 Z" fill="#FFFFFF"></path><path d="M60.1882226,187.75773 L0.388574398,127.958082 L60.1864484,68.160208 L119.986097,127.958082 L60.1882226,187.75773 L60.1882226,187.75773 L60.1882226,187.75773 L60.1882226,187.75773 L60.1882226,187.75773 L60.1882226,187.75773 Z M8.36233399,127.958082 L60.1882226,179.78397 L112.012337,127.958082 L60.1864484,76.1339675 L8.36233399,127.958082 L8.36233399,127.958082 L8.36233399,127.958082 L8.36233399,127.958082 Z M127.958082,119.986097 L68.160208,60.1882226 L127.958082,0.388574398 L187.755956,60.1882226 L127.958082,119.986097 L127.958082,119.986097 L127.958082,119.986097 L127.958082,119.986097 Z M76.1339675,60.1882226 L127.958082,112.012337 L179.78397,60.1882226 L127.958082,8.36233399 L76.1339675,60.1882226 L76.1339675,60.1882226 L76.1339675,60.1882226 L76.1339675,60.1882226 Z M195.729716,187.75773 L135.931841,127.958082 L195.729716,68.160208 L255.527589,127.958082 L195.729716,187.75773 L195.729716,187.75773 L195.729716,187.75773 L195.729716,187.75773 Z M143.903827,127.958082 L195.729716,179.78397 L247.553829,127.958082 L195.729716,76.1339675 L143.903827,127.958082 L143.903827,127.958082 L143.903827,127.958082 L143.903827,127.958082 Z M127.958082,255.527589 L68.160208,195.729716 L127.958082,135.931841 L187.755956,195.729716 L127.958082,255.527589 L127.958082,255.527589 L127.958082,255.527589 L127.958082,255.527589 Z M76.1339675,195.729716 L127.958082,247.553829 L179.78397,195.729716 L127.958082,143.905601 L76.1339675,195.729716 L76.1339675,195.729716 L76.1339675,195.729716 L76.1339675,195.729716 L76.1339675,195.729716 L76.1339675,195.729716 Z" fill="#FFFFFF"></path></g></svg>
    </div>
  </div>
</div>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-21T12:54:44.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">docker 数据卷</title>
    <id>https://www.snowji.cn/basic-skills/docker/docker-data-volume/</id>
    <link href="https://www.snowji.cn/basic-skills/docker/docker-data-volume/"/>
    <updated>2022-08-26T03:40:33.000Z</updated>
    <content type="html"><![CDATA[<h1 id="docker-数据卷"> docker 数据卷</h1>
<h2 id="为什么要使用数据卷"> 为什么要使用数据卷</h2>
<ul>
<li>数据存储在容器中，容器被删除，数据就会丢失，希望数据能够持久化</li>
<li>每次修改文件的配置时，都要进入容器内部，比较麻烦</li>
</ul>
<h2 id="什么是容器数据卷"> 什么是容器数据卷</h2>
<ul>
<li>为了实现容器之间数据共享，将 Docker 容器中产生的数据，同步到本地</li>
<li>实际上就是目录的挂载</li>
<li>实现数据同步和数据持久化</li>
<li>可以实现容器间的数据共享，需要创建专门的数据卷容器</li>
</ul>
<p><img src="./images/data-1.png" alt="docker" /></p>
<h2 id="如何使用数据卷"> 如何使用数据卷</h2>
<h3 id="方式一-指定目录挂载"> 方式一：指定目录挂载</h3>
<div><pre><code><span>docker</span> run -it -v 主机目录：容器内目录 -p 宿主机端口:容器内端口
</code></pre>
<div><span>1</span><br></div></div><p>例子：</p>
<div><pre><code><span>docker</span> run -it -v /home/ceshi:/home centos:centos7 /bin/bash
</code></pre>
<div><span>1</span><br></div></div><p>查看挂载：</p>
<div><pre><code><span>docker</span> inspect c2baae501793
</code></pre>
<div><span>1</span><br></div></div><p>结果：</p>
<div><pre><code>  <span>"Mounts"</span><span>:</span> <span>[</span>
            <span>{</span>
                <span>"Type"</span><span>:</span> <span>"bind"</span>,
                <span>"Source"</span><span>:</span> <span>"/home/ceshi"</span>,   <span># Linux 路径</span>
                <span>"Destination"</span><span>:</span> <span>"/home"</span>,    <span># 容器中的路径</span>
                <span>"Mode"</span><span>:</span> <span>""</span>,
                <span>"RW"</span><span>:</span> true,
                <span>"Propagation"</span><span>:</span> <span>"rprivate"</span>
            <span>}</span>
        <span>]</span>,
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>挂载成功后，就可以在容器和 Linux 中相应的路径中修改文件后，会相互同步</p>
<div><p>总结</p>
<ul>
<li>
<p>要挂载多个目录，可以使用多个 -v</p>
</li>
<li>
<p>挂载成功后即可相互修改文件同步更新，即使容器被 stop</p>
</li>
</ul>
</div>
<h3 id="方式二-匿名挂载"> 方式二：匿名挂载</h3>
<div><pre><code><span>docker</span> run -it -v 容器内目录 
</code></pre>
<div><span>1</span><br></div></div><p>例子：匿名挂载 Nginx</p>
<div><pre><code><span>docker</span> run -d -p <span>80</span>:80 -v /etc/ngnix nginx
</code></pre>
<div><span>1</span><br></div></div><p>查看所有 volume 的情况：</p>
<div><pre><code><span>docker</span> volume -h

Commands:
  create      Create a volume  <span># 新增卷</span>
  inspect     Display detailed information on one or <span>more</span> volumes  <span># 显示卷的相信信息</span>
  <span>ls</span>          List volumes   <span># 列出所有的卷</span>
  prune       Remove all unused <span>local</span> volumes <span># 移除所有不可用的卷</span>
  <span>rm</span>          Remove one or <span>more</span> volumes  <span># 删除一个或多个卷</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>结果：</p>
<div><pre><code><span>[</span>root@VM-16-7-centos data<span>]</span><span># docker volume ls</span>
DRIVER    VOLUME NAME
<span>local</span>     2e9fa961b3a9439eacb947154d3a7624c0422a22da8339e01b5b7544915b98e2
<span>local</span>     1185c635a511a02e9600a632b14b229569fb73cc8280510f47a67e7f2a42f8b7
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面的方式就是匿名挂载，系统会随机生成一个卷号</p>
<h3 id="方式三-具名挂载"> 方式三：具名挂载</h3>
<div><pre><code><span>docker</span> run -it -v 卷名:容器内目录 
</code></pre>
<div><span>1</span><br></div></div><p>例子：具名挂载 Nginx</p>
<div><pre><code><span>docker</span> run -d -p <span>80</span>:80 -v juming-nginx:/etc/ngnix --name nginx01 nginx 
</code></pre>
<div><span>1</span><br></div></div><p>查看卷：</p>
<div><pre><code><span>[</span>root@VM-16-7-centos data<span>]</span><span># docker volume ls</span>
DRIVER    VOLUME NAME
<span>local</span>     2e9fa961b3a9439eacb947154d3a7624c0422a22da8339e01b5b7544915b98e2
<span>local</span>     1185c635a511a02e9600a632b14b229569fb73cc8280510f47a67e7f2a42f8b7
<span>local</span>     juming-nginx
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>查看卷具体信息：</p>
<div><pre><code><span>[</span>root@VM-16-7-centos data<span>]</span><span># docker volume inspect juming-nginx</span>
<span>[</span>
    <span>{</span>
        <span>"CreatedAt"</span><span>:</span> <span>"2022-04-05T14:12:27+08:00"</span>,
        <span>"Driver"</span><span>:</span> <span>"local"</span>,
        <span>"Labels"</span><span>:</span> null,
        <span>"Mountpoint"</span><span>:</span> <span>"/var/lib/docker/volumes/juming-nginx/_data"</span>,   <span># Linux 中生成的目录</span>
        <span>"Name"</span><span>:</span> <span>"juming-nginx"</span>,
        <span>"Options"</span><span>:</span> null,
        <span>"Scope"</span><span>:</span> <span>"local"</span>
    <span>}</span>
<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><p>总结</p>
<ul>
<li>所有的 docker 内的卷，没有指定目录的情况下，都是在 /var/lib/docker/volumes/xxx/_data</li>
<li>大多数的情况下使用具名挂载，可以方便的找到</li>
</ul>
</div>
<h4 id="拓展"> 拓展</h4>
<p>通过 ro、rw 改变读写权限</p>
<div><pre><code>-v 容器内路径:ro

-v 容器内路径:rw
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>ro：只读</li>
<li>rw: 可读写，默认</li>
</ul>
<div><pre><code><span>docker</span> run -d -p <span>80</span>:80 -v juming-nginx:/etc/ngnix:ro --name nginx01 nginx 
<span>docker</span> run -d -p <span>80</span>:80 -v juming-nginx:/etc/ngnix:rw --name nginx01 nginx

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>设置容器内的路径只读，只能通过宿主机来操作</li>
<li>设置容器内的路径可读写，能在容器内操作</li>
</ul>
<h3 id="方式四-使用-dockerfile-进行挂载"> 方式四：使用 DockerFile 进行挂载</h3>
<ul>
<li>用来构建 docker 镜像的构建文件</li>
<li>镜像是一层一层的，脚本的每个命令就是一层</li>
</ul>
<p>DockerFile 内容：</p>
<div><pre><code>FROM  cnetos
VOLUME <span>[</span><span>'volume1'</span>, <span>'volume2'</span><span>]</span>   <span># 匿名挂载</span>
CMD <span>echo</span> <span>'success'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>使用 <code>docker build</code> 构建</p>
<div><pre><code><span>docker</span> build -f dockerfile -t xuef/mycentos <span>.</span>
</code></pre>
<div><span>1</span><br></div></div><p>结果：</p>
<div><pre><code><span>[</span>root@VM-16-7-centos test-volume<span>]</span><span># docker build -f /home/dockerfile -t snowji/mycentos .</span>
Sending build context to Docker daemon  <span>1</span>.583kB
Step <span>1</span>/3 <span>:</span> FROM centos
latest: Pulling from library/centos
a1d0c7532777: Pull complete 
Digest: sha256:a27fd8080b517143cbbbab9dfb7c8571c40d67d534bbdee55bd6c473f432b177
Status: Downloaded newer image <span>for</span> centos:latest
 ---<span>></span> 5d0da3dc9764
Step <span>2</span>/3 <span>:</span> VOLUME <span>[</span><span>"volume01"</span>,<span>"volume02"</span><span>]</span>
 ---<span>></span> Running <span>in</span> 3ea0015ed7ed
Removing intermediate container 3ea0015ed7ed
 ---<span>></span> 3d795c480134
Step <span>3</span>/3 <span>:</span> CMD <span>echo</span> <span>"success"</span>
 ---<span>></span> Running <span>in</span> 24eaaa92fe2d
Removing intermediate container 24eaaa92fe2d
 ---<span>></span> 7d327e2e64f3
Successfully built 7d327e2e64f3
Successfully tagged snowji/mycentos:latest

<span>[</span>root@VM-16-7-centos test-volume<span>]</span><span># docker images</span>
REPOSITORY      TAG       IMAGE ID       CREATED              SIZE
snowji/mycentos   latest    7d327e2e64f3   About a minute ago   231MB
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>查看挂载具体信息：</p>
<div><pre><code><span># 运行刚刚构建的镜像</span>
<span>docker</span> run -it 7d327e2e64f3 /bin/bash
<span># 查看容器的元数据</span>
<span>docker</span> inspect 83d3fe414be1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>结果：</p>
<div><pre><code>        <span>"Mounts"</span><span>:</span> <span>[</span>
            <span>{</span>
                <span>"Type"</span><span>:</span> <span>"volume"</span>,
                <span>"Name"</span><span>:</span> <span>"1cf1df8a6e04c508ed272502e2de1bd83c3ccc7b91a3dc1f465b308bcceacf14"</span>,
                <span>"Source"</span><span>:</span> <span>"/var/lib/docker/volumes/1cf1df8a6e04c508ed272502e2de1bd83c3ccc7b91a3dc1f465b308bcceacf14/_data"</span>,
                <span>"Destination"</span><span>:</span> <span>"volume01"</span>,
                <span>"Driver"</span><span>:</span> <span>"local"</span>,
                <span>"Mode"</span><span>:</span> <span>""</span>,
                <span>"RW"</span><span>:</span> true,
                <span>"Propagation"</span><span>:</span> <span>""</span>
            <span>}</span>,
            <span>{</span>
                <span>"Type"</span><span>:</span> <span>"volume"</span>,
                <span>"Name"</span><span>:</span> <span>"66904eb6add3a676102e3c26ebc48d164fd706bf0ec97743552716fd5b091985"</span>,
                <span>"Source"</span><span>:</span> <span>"/var/lib/docker/volumes/66904eb6add3a676102e3c26ebc48d164fd706bf0ec97743552716fd5b091985/_data"</span>,
                <span>"Destination"</span><span>:</span> <span>"volume02"</span>,
                <span>"Driver"</span><span>:</span> <span>"local"</span>,
                <span>"Mode"</span><span>:</span> <span>""</span>,
                <span>"RW"</span><span>:</span> true,
                <span>"Propagation"</span><span>:</span> <span>""</span>
            <span>}</span>
        <span>]</span>,
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>可以看到，上面挂载成功，这种方式使用的非常多</p>
<h2 id="数据卷容器"> 数据卷容器</h2>
<div><pre><code><span># 第一步: 创建一个数据卷容器和宿主机目录进行挂载</span>
<span>docker</span> run -it -v 宿主机目录:容器内目录 --name nginx01 nginx /bin/bash

<span># 第二步：创建其他容器和数据卷容器进行挂载，使用--volumes-from命令进行指定。</span>
<span>docker</span> run -it --volumes-from nginx01 --name nginx02 nginx /bin/bash

<span># 第三步: 创建其他容器和数据卷容器进行挂载</span>
<span>docker</span> run -it --volumes-from nginx01 --name nginx03 nginx /bin/bash

<span># 此时nginx02和nginx03之间的数据就是可以共享的了。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ul>
<li>容器之间的信息传递，数据卷的生命周期一直存在到没有容器使用</li>
<li>一但数据持久化到本地，本地的数据是不会被删除</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T03:15:48.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">镜像原理</title>
    <id>https://www.snowji.cn/basic-skills/docker/docker-images/</id>
    <link href="https://www.snowji.cn/basic-skills/docker/docker-images/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="镜像原理"> 镜像原理</h1>
<h2 id="镜像是什么"> 镜像是什么</h2>
<ul>
<li>镜像是一种轻量级、可执行的独立软件保，用来打包软件运行环境和基于运行环境开发的软件</li>
<li>他包含运行某个软件所需的所有内容，包括代码、运行时库、环境变量和配置文件</li>
<li>所有应用，都可以直接打包 docker 镜像，就可以直接跑起来</li>
</ul>
<h2 id="如何得到镜像"> 如何得到镜像</h2>
<ul>
<li>从远程仓库下载</li>
<li>别人拷贝给你</li>
<li>自己制作一个镜像 DockerFile</li>
</ul>
<h2 id="unionfs-联合文件系统"> UnionFs （联合文件系统）</h2>
<ul>
<li>Union文件系统（UnionFs）是一种分层、轻量级并且高性能的文件系统</li>
<li>他支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下</li>
<li>Union文件系统是 Docker 镜像的基础</li>
<li>可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像</li>
<li>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</li>
</ul>
<h2 id="docker-镜像加载原理"> Docker 镜像加载原理</h2>
<ul>
<li>Docker 的镜像实际上由一层一层的文件系统组成，这种层级的文件系统叫 UnionFS</li>
<li>boots(boot file system）主要包含 bootloader 和 Kernel, bootloader 主要是引导加载 kernel, Linux 刚启动时会加 bootfs 文件系统，在 Docker 镜像的最底层是 boots，几乎不变</li>
<li>这一层与我们典型的 Linux/Unix 系统是一样的，包含 bootloader 和 Kernel</li>
<li>当 boot 加载完成之后，整个内核就都在内存中了，此时内存的使用权已由 bootfs 转交给内核，此时系统也会卸载 bootfs</li>
<li>rootfs（root file system),在 bootfs 之上，包含的就是典型 Linux 系统中的 /dev、/proc/bin、/etc 等标准目录和文件</li>
<li>rootfs 就是各种不同的操作系统发行版，比如 Ubuntu, Centos 等等</li>
</ul>
<p><img src="./images/images-1.png" alt="docker" /></p>
<p>平时我们安装进虚拟机的 CentOS 都是好几个 G，为什么 Docker 这里才 200M？</p>
<p><img src="./images/images-2.png" alt="docker" /></p>
<ul>
<li>对于个精简的 OS , rootfs 可以很小，只需要包合最基本的命令，工具和程序库就可以了</li>
<li>因为底层直接用主机的 kernel，自己只需要提供 rootfs 就可以了</li>
<li>由此可见对于不同的 Linux 发行版，boots 基本是一致的，rootfs 会有差別，因此不同的发行版可以公用 bootfs</li>
<li>所以虚拟机启动是分钟级别，容器是秒级！</li>
</ul>
<h2 id="docker-镜像分层"> Docker 镜像分层</h2>
<p>下载镜像时，可以看到一层一层的在下载</p>
<p><img src="./images/images-3.png" alt="docker" /></p>
<p>::: tips 为什么 Docker 镜像要采用这种分层的结构呢？</p>
<ul>
<li>最大的好处，我觉得莫过于资源共享了！</li>
<li>比如有多个镜像都从相同的 Base 镜像构建而来，那么宿主机只需在磁盘上保留一份 base 镜像，同时内存中也只需要加载一份 base 镜像</li>
<li>这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享</li>
<li>Already exists 代表宿主机已存在镜像所需的文件，所以不再需要下载，直接使用即可</li>
<li>Downloading 代表宿主机没有所需的文件，所以需要下载，下载完之后就会存在宿主机，以后下载其他镜像时如果用到这些文件就可以直接拿来用，不用二次下载了
:::</li>
</ul>
<p>查看镜像分层</p>
<div><pre><code><span>docker</span> inspect redis
</code></pre>
<div><span>1</span><br></div></div><p><img src="./images/images-4.png" alt="docker" /></p>
<h3 id="分层理解"> 分层理解：</h3>
<ul>
<li>所有的 Docker 镜像都起始于一个基础镜像层，其实就是 rootfs，像 Ubuntu、CentOS</li>
<li>当进行修改或添加新的内容时，就会在当前镜像层之上，创建新的镜像层</li>
</ul>
<p>例子：</p>
<ul>
<li>基于 Ubuntu Linux16.04 创建一个新的镜像，这就是新镜像的第一层</li>
<li>如果在该镜像中添加 Python 包，就会在基础镜像层之上创建第二个镜像层</li>
<li>如果继续添加一个安全补丁，就会创健第三个镜像层</li>
<li>该镜像当前已经包含 3 个镜像层</li>
<li>现在可以把它再次打包成一个新的镜像（commit）提供给其他人下载，其他人 pull 下来之后就会有三层东西</li>
</ul>
<p><img src="./images/images-5.png" alt="docker" /></p>
<p><strong>重点</strong>：
在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合</p>
<p>下图中举了一个简单的例子，每个镜像层包含 3 个文件，而镜像包含了来自两个镜像层的 6 个文件</p>
<p><img src="./images/images-6.png" alt="docker" /></p>
<p>上图中的镜像层跟之前图中的略有区別，主要目的是便于展示文件</p>
<p>下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有 6 个文件，这是因为最上层中的文件7 是 文件5 的一个更新版</p>
<p><img src="./images/images-7.png" alt="docker" /></p>
<p>这种情況下，上层镜像层中的文件覆盖了底层镜像层中的文件</p>
<p>这样就使得文件的更新版本作为一个新镜像层添加到镜像当中</p>
<p><strong>存储引擎</strong></p>
<ul>
<li>Docker 通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统</li>
<li>Linux 上可用的存储引撃有 AUFS、 Overlay2、 Device Mapper、Btrfs 以及 ZFS</li>
<li>每种存储引擎都基于 Linux 中对应的文件系统或者块设备技术，井且每种存储引擎都有其独有的性能特点</li>
<li>Docker 在 Windows上仅支持 windowsfilter 一种存储引擎，该引擎基于 NTFS 文件系统之上实现了分层和 CoW</li>
</ul>
<p><strong>镜像层合并</strong></p>
<ul>
<li>下图展示了与系统显示相同的三层镜像</li>
<li>所有镜像层堆并合井，对外提供统一的视图</li>
</ul>
<p><img src="./images/images-9.png" alt="docker" /></p>
<p>上面有查看 redis 镜像的 layer 是 6 层，跟上图差不多，6 个文件就是 6 个 layer</p>
<h3 id="特点"> 特点</h3>
<ul>
<li>Docker 镜像都是只读的，当容器启动时，一个新的可写层加载到镜像的顶部</li>
<li>这一层就是我们通常说的容器层，容器之下的都叫镜像层
<img src="./images/images-8.png" alt="docker" /></li>
</ul>
<h2 id="参考资料"> 参考资料</h2>
<p><a href="https://www.bilibili.com/video/BV1og4y1q7M4?p=18" target="_blank" rel="noopener noreferrer">镜像原理之联合文件系统</a></p>
<p><a href="https://www.bilibili.com/video/BV1og4y1q7M4?p=18" target="_blank" rel="noopener noreferrer">镜像原理之分层</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T03:15:48.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">DockerFile</title>
    <id>https://www.snowji.cn/basic-skills/docker/docker-file/</id>
    <link href="https://www.snowji.cn/basic-skills/docker/docker-file/"/>
    <updated>2022-08-26T03:40:33.000Z</updated>
    <content type="html"><![CDATA[<h1 id="dockerfile"> DockerFile</h1>
<h2 id="什么是-dockerfile"> 什么是 DockerFile</h2>
<ul>
<li>用来构建 docker 镜像的构建文件</li>
<li>就是命令脚本</li>
</ul>
<h2 id="构建步骤"> 构建步骤</h2>
<ul>
<li>编写一个 DockerFile 文件</li>
<li>docker build 构建成为一个镜像</li>
<li>docker run 运行镜像</li>
<li>docker push 发布镜像（DockerHub 、阿里云仓库)</li>
</ul>
<h2 id="dockerfile-构建过程"> DockerFile 构建过程</h2>
<ul>
<li>每个保留关键字(指令）都是必须是大写字母</li>
<li>执行从上到下顺序</li>
<li><code>#</code>表示注释</li>
<li>每一个指令都会创建提交一个新的镜像层，并提交</li>
</ul>
<h2 id="dockerfile-优势"> DockerFile 优势</h2>
<ul>
<li>DockerFile 是面向开发的，以后要发布项目，做镜像，就需要编写 DockerFile 文件</li>
<li>Docker 镜像逐渐成企业交付的标准，必须要掌握！</li>
<li>DockerFile 构建镜像文件，定义了一切的步骤，源代码</li>
<li>Dockerfile 的体积小，容易进行快速迁移部署</li>
<li>环境构建流程记录在 DockerFile 中，能够直观的看到镜像构建的顺序和逻辑</li>
<li>Docker Images 通过 DockerFile 构建生成的镜像，最终发布和运行产品</li>
<li>Docker 容器，镜像运行起来提供服务</li>
</ul>
<h2 id="常用指令"> 常用指令</h2>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>FROM</td>
<td>指明当前的镜像基于哪个镜像构建</td>
</tr>
<tr>
<td>ARG</td>
<td>定义构建镜像过程中使用的变量</td>
</tr>
<tr>
<td>LABEL</td>
<td>标记镜像信息，添加元数据</td>
</tr>
<tr>
<td>EXPOSE</td>
<td>暴露 Docker 容器在运行时监听指定的网络端口</td>
</tr>
<tr>
<td>ENV</td>
<td>指定环境变量</td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>指定镜像的默认入口命令</td>
</tr>
<tr>
<td>VOLUME</td>
<td>创建一个数据卷挂载点</td>
</tr>
<tr>
<td>USER</td>
<td>指定运行容器时的用户名或 UID</td>
</tr>
<tr>
<td>WORKDIR</td>
<td>配置工作目录</td>
</tr>
<tr>
<td>RUN</td>
<td>运行指定命令</td>
</tr>
<tr>
<td>CMD</td>
<td>启动容器时指定默认执行的命令</td>
</tr>
<tr>
<td>ADD</td>
<td>添加内容到镜像</td>
</tr>
<tr>
<td>COPY</td>
<td>复制内容到镜像</td>
</tr>
<tr>
<td>ONBUILD</td>
<td>创建子镜像时指定自动执行的操作指令</td>
</tr>
<tr>
<td>STOPSIGNAL</td>
<td>指定退出的信号值</td>
</tr>
<tr>
<td>HEALTHCHECK</td>
<td>配置启动容器如何进行健康检查</td>
</tr>
<tr>
<td>SHELL</td>
<td>指定默认 shell 类型</td>
</tr>
</tbody>
</table>
<h2 id="示例"> 示例</h2>
<p>构建含有 ifconfig 、vim 命令的 centos</p>
<p>DockerFile 内容：</p>
<div><pre><code>FROM centos
MAINTAINER snowji<span>&lt;</span><span>123456789</span>@qq.com<span>></span>

ENV MYPATH /usr/local
WORKDIR <span>$MYPATH</span>

RUN yum -y <span>install</span> net-tools   

EXPOSE <span>80</span>

CMD <span>echo</span> <span>$MYPATH</span>
CMD <span>echo</span> <span>"-----end-----"</span>
CMD /bin/bash
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>build 结束后，进入容器使用 <code>ifconfig</code> 命令</p>
<div><pre><code><span>[</span>root@1afccfd13f3d local<span>]</span><span># ifconfig</span>
eth0: <span>flags</span><span>=</span><span>416</span><span><span>3</span>&lt;</span>UP,BROADCAST,RUNNING,MULTICAST<span>></span>  mtu <span>1500</span>
        inet <span>127.0</span>.0.1  netmask <span>255.255</span>.0.0  broadcast <span>127.0</span>.0.2
        ether 02:42:xx:xx:00:03  txqueuelen <span>0</span>  <span>(</span>Ethernet<span>)</span>
        RX packets <span>7</span>  bytes <span>586</span> <span>(</span><span>586.0</span> B<span>)</span>
        RX errors <span>0</span>  dropped <span>0</span>  overruns <span>0</span>  frame <span>0</span>
        TX packets <span>0</span>  bytes <span>0</span> <span>(</span><span>0.0</span> B<span>)</span>
        TX errors <span>0</span>  dropped <span>0</span> overruns <span>0</span>  carrier <span>0</span>  collisions <span>0</span>

lo: <span>flags</span><span>=</span><span>7</span><span><span>3</span>&lt;</span>UP,LOOPBACK,RUNNING<span>></span>  mtu <span>65536</span>
        inet <span>127.0</span>.0.1  netmask <span>255.0</span>.0.0
        loop  txqueuelen <span>1000</span>  <span>(</span>Local Loopback<span>)</span>
        RX packets <span>0</span>  bytes <span>0</span> <span>(</span><span>0.0</span> B<span>)</span>
        RX errors <span>0</span>  dropped <span>0</span>  overruns <span>0</span>  frame <span>0</span>
        TX packets <span>0</span>  bytes <span>0</span> <span>(</span><span>0.0</span> B<span>)</span>
        TX errors <span>0</span>  dropped <span>0</span> overruns <span>0</span>  carrier <span>0</span>  collisions <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>可以使用 <code>ifconfig</code> 命令查看网络信息</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T03:15:48.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">docker inspect</title>
    <id>https://www.snowji.cn/basic-skills/docker/docker-inspect/</id>
    <link href="https://www.snowji.cn/basic-skills/docker/docker-inspect/"/>
    <updated>2022-08-26T03:40:33.000Z</updated>
    <content type="html"><![CDATA[<h1 id="docker-inspect"> docker inspect</h1>
<p>作用：获取容器的元数据（JSON 格式）</p>
<h2 id="语法格式"> 语法格式</h2>
<div><pre><code>docker inspect [OPTIONS] NAME|ID [NAME|ID...]
</code></pre>
<div><span>1</span><br></div></div><p>options 说明</p>
<table>
<thead>
<tr>
<th>option</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-f,--format</td>
<td>指定返回值的模板文件</td>
</tr>
<tr>
<td>-s,--size</td>
<td>如果类型为容器，则显示文件总大小</td>
</tr>
<tr>
<td>--type</td>
<td>返回指定类型的 JSON</td>
</tr>
</tbody>
</table>
<h2 id="实例"> 实例</h2>
<h3 id="获取-nginx-的元数据"> 获取 Nginx 的元数据</h3>
<p><img src="./images/inspect1.png" alt="inspect" /></p>
<h3 id="获取-ip-地址"> 获取 IP 地址</h3>
<div><pre><code> docker inspect --format=&#39;{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}&#39; $INSTANCE_ID
</code></pre>
<div><span>1</span><br></div></div><p><img src="./images/inspect2.png" alt="inspect" /></p>
<p>更简单的方式：</p>
<div><pre><code>docker inspect nginx01 | grep IPAddress
</code></pre>
<div><span>1</span><br></div></div><p><img src="./images/inspect3.png" alt="inspect" /></p>
<h3 id="获取指定端口映射"> 获取指定端口映射</h3>
<p>使用 index</p>
<div><pre><code>docker inspect --format=&#39;{{(index (index .NetworkSettings.Ports &quot;80/tcp&quot;) 0).HostPort}}&#39; $INSTANCE_ID
</code></pre>
<div><span>1</span><br></div></div><p><img src="./images/inspect4.png" alt="inspect" /></p>
<h3 id="获取配置"> 获取配置</h3>
<p>使用 json 格式</p>
<div><pre><code> docker inspect --format=&#39;{{json .Config}}&#39; $INSTANCE_ID
</code></pre>
<div><span>1</span><br></div></div><p><img src="./images/inspect5.png" alt="inspect" /></p>
<p>输出的结果不太友好，可以使用 Python 中的 json.tool 或 jq 美化输出</p>
<div><pre><code>#使用 Python 的 json 模块美化

docker inspect --format=&quot;{{json .Config}}&quot; container | python -m json.tool

#使用 jq 美化

docker inspect --format=&quot;{{json .Config}}&quot; container | jq
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><img src="./images/inspect6.png" alt="inspect" /></p>
<h2 id="参考资料"> 参考资料</h2>
<p><a href="https://docs.docker.com/engine/reference/commandline/inspect/" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T03:15:48.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Docker 安装</title>
    <id>https://www.snowji.cn/basic-skills/docker/docker-install/</id>
    <link href="https://www.snowji.cn/basic-skills/docker/docker-install/"/>
    <updated>2022-09-01T06:32:38.000Z</updated>
    <content type="html"><![CDATA[<h1 id="docker-安装"> Docker 安装</h1>
<h2 id="linux-环境安装"> Linux 环境安装</h2>
<p><strong>版本</strong>: centos 7</p>
<p><strong>kernel 版本</strong>: 3.10 及以上版本，查看命令：uname -r</p>
<p><strong>安装步骤</strong>：</p>
<ul>
<li>
<p>使用 sudo 或 root 权限的用户登录</p>
</li>
<li>
<p>如果有旧版本，卸载版本，如果没有旧版本，此步骤可略过</p>
<div><pre><code>yum remove docker
           docker-client
           docker-client-latest
           docker-common
           docker-latest
           docker-latest-logrotate
           docker-logrotate
           docker-engine                      
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></li>
<li>
<p>安装需要的软件包</p>
<div><pre><code>#yum-util提供yum-config-manager功能
#另外两个是devicemapper驱动依赖的
$ yum install -y yum-utils 
                 device-mapper-persistent-data 
                 lvm2

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
<li>
<p>设置 yum 源</p>
<div><pre><code>$ yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>安装 Docker</p>
<ul>
<li>
<p>安装最新版</p>
<div><pre><code>$ yum install -y docker-ce
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>安装指定版本</p>
<div><pre><code>#查询版本列表
$ yum list docker-ce --showduplicates | sort -r
已加载插件：fastestmirror, langpacks
已安装的软件包
可安装的软件包
 * updates: mirrors.163.com
Loading mirror speeds from cached hostfile
 * extras: mirrors.163.com
docker-ce.x86_64            17.09.1.ce-1.el7.centos            docker-ce-stable
docker-ce.x86_64            17.09.0.ce-1.el7.centos            docker-ce-stable
...
#指定版本安装(这里的例子是安装上面列表中的第二个)
$ yum install -y docker-ce-17.09.0.ce

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div></li>
</ul>
</li>
<li>
<p>启动 Docker</p>
<div><pre><code>$ systemctl start docker.service
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>验证是否安装成功(有 client 和 server 两部分表示安装启动成功)</p>
<div><pre><code>$ docker version
Client: Docker Engine - Community
 Version:           20.10.7
 API version:       1.41
 Go version:        go1.13.15
 Git commit:        f0df350
 Built:             Wed Jun  2 11:58:10 2021
 OS/Arch:           linux/amd64
 Context:           default
 Experimental:      true

Server: Docker Engine - Community
 Engine:
  Version:          20.10.7
  API version:      1.41 (minimum version 1.12)
  Go version:       go1.13.15
  Git commit:       b0f5bc3
  Built:            Wed Jun  2 11:56:35 2021
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          1.4.6
  GitCommit:        d71fcd7d8303cbf684402823e425e9dd2e99285d
 runc:
  Version:          1.0.0-rc95
  GitCommit:        b9ee9c6314599f1b4a7f497e1f1f856fe433d3b7
 docker-init:
  Version:          0.19.0
  GitCommit:        de40ad0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div></li>
</ul>
<h2 id="参考资料"> 参考资料</h2>
<p><a href="https://docs.docker.com/engine/install/centos/" target="_blank" rel="noopener noreferrer">官方安装文档</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-01T06:32:38.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Docker 环境安装 GitLab</title>
    <id>https://www.snowji.cn/basic-skills/docker/docker-install-gitlab/</id>
    <link href="https://www.snowji.cn/basic-skills/docker/docker-install-gitlab/"/>
    <updated>2022-09-01T06:32:38.000Z</updated>
    <content type="html"><![CDATA[<h1 id="docker-环境安装-gitlab"> Docker 环境安装 GitLab</h1>
<h2 id="前言"> 前言</h2>
<p>Linux 环境：CentOS</p>
<h2 id="安装过程"> 安装过程</h2>
<h3 id="镜像下载"> 镜像下载</h3>
<p>官方版本：gitlab/gitlab-ce:latest</p>
<div><pre><code># docker pull gitlab/gitlab-ce:latest
</code></pre>
<div><span>1</span><br></div></div><h3 id="运行镜像"> 运行镜像</h3>
<div><pre><code>docker run -d \
           -p 443:443 \
           -p 9001:80 \
           --name mygitlab \
           --restart always \
           --privileged=true \
           -v /home/gitlab/config:/etc/gitlab \
           -v /home/gitlab/logs:/var/log/gitlab \
           -v /home/gitlab/data:/var/opt/gitlab \
           gitlab/gitlab-ce
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>或生成一个 .sh 文件来执行启动</p>
<div><pre><code>#!/bin/bash
HOST_NAME=gitlab.mooc.com
GITLAB_DIR=`/home/gitlab`
docker stop gitlab
docker rm gitlab
docker run -d \\
    --hostname \${HOST_NAME} \\
    -p 443:443 -p 5000:80 -p 8022:22 \\
    --name gitlab \\
    -v \${GITLAB_DIR}/config:/etc/gitlab \\
    -v \${GITLAB_DIR}/logs:/var/log/gitlab \\
    -v \${GITLAB_DIR}/data:/var/opt/gitlab \\
    registry.cn-hangzhou.aliyuncs.com/imooc/gitlab-ce:latest
EOF

后启动 sh start.sh
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>参数解释：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td>后台运行</td>
</tr>
<tr>
<td>-p</td>
<td>将容器内部端口向外映射</td>
</tr>
<tr>
<td>--name</td>
<td>命名容器名称</td>
</tr>
<tr>
<td>-v</td>
<td>将容器内数据文件夹或日志、配置文件夹挂载到主机指定目录</td>
</tr>
</tbody>
</table>
<p>运行成功后如下：</p>
<p><img src="./images/gitlab1.png" alt="gitlab" /></p>
<h3 id="配置环境"> 配置环境</h3>
<ul>
<li>
<p>修改 ssh 端口（如果主机端口使用的不是 22 端口）</p>
<p>修改文件：${GITLAB_DIR}/config/gitlab.rb
找到这一行：# gitlab_rails['gitlab_shell_ssh_port'] = 22
把 22 修改为你的宿主机端口（这里是 2222）。然后将注释去掉</p>
</li>
<li>
<p>重新启动容器 <code>$ sh start.sh</code></p>
</li>
</ul>
<h3 id="降低-gitlab-配置"> 降低 gitlab 配置</h3>
<p>宿主机上修改配置文件</p>
<div><pre><code><span>vi</span> /home/gitlab/logs/gitlab.rb
</code></pre>
<div><span>1</span><br></div></div><p>删除以下配置的注释，并修改参数：</p>
<ul>
<li>修改 worker_processes 减少进程数</li>
</ul>
<div><pre><code><span>#官方建议 CPU 核心数加一，最小值是 2</span>
unicorn<span>[</span><span>'worker_process'</span><span>]</span><span>=</span><span>2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>减少数据库缓存，可适当改小</li>
</ul>
<div><pre><code>postgresql<span>[</span><span>'shared_buffers'</span><span>]</span><span>=</span><span>"256MB"</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>减少数据库并发数，可适当改小</li>
</ul>
<div><pre><code>postgresql<span>[</span><span>'max_worker_process'</span><span>]</span><span>=</span><span>8</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>减少 sidekiq 并发数，可适当改小</li>
</ul>
<div><pre><code>sidekiq<span>[</span><span>'concurrency'</span><span>]</span><span>=</span><span>25</span>
</code></pre>
<div><span>1</span><br></div></div><p>修改完成后，可重启容器</p>
<h3 id="访问-gitlab-页面"> 访问 gitlab 页面</h3>
<p>使用 http://IP:9001 访问</p>
<p><img src="./images/gitlab02.png" alt="gitlab" /></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-01T06:32:38.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Docker 镜像制作</title>
    <id>https://www.snowji.cn/basic-skills/docker/docker-mirror-make/</id>
    <link href="https://www.snowji.cn/basic-skills/docker/docker-mirror-make/"/>
    <updated>2022-09-01T06:32:38.000Z</updated>
    <content type="html"><![CDATA[<h1 id="docker-镜像制作"> Docker 镜像制作</h1>
<p><strong>必须文件</strong>：Dockerfile</p>
<p>以安装 JPress 为例</p>
<ul>
<li>
<p>下载 tomacat</p>
<p>docker pull hub.c.163.com/library/tomcat:latest</p>
</li>
<li>
<p>编写 Dockerfile</p>
</li>
</ul>
<div><pre><code>from hub.c.163.com/library/tomcat #将tomcat作为底层镜像

MAINTAINER xuefeng   #制作者信息

COPY jpress.war /usr/local/tomcat/webapps 将jpress.war文件拷贝至tomcat的webaps下
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li>
<p>docker build -t jpress .</p>
<p>在 Dockerfile 文件所在目录进行 build</p>
</li>
<li>
<p>运行镜像</p>
<p>docker run -d -p 8888:8080 jpress</p>
<p>访问 8888 端口：</p>
<p><img src="./images/tomcat.jpg" alt="tomcat" /></p>
<p>访问 jpress</p>
<p><img src="./images/jpress.jpg" alt="jpress" /></p>
</li>
<li>
<p>安装 mysql 数据库</p>
<p>docker pull hub.c.163.com/library/mysql:latest</p>
<p>docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=000000 -e MYSQL_DATABASE=jpress hub.c.163.com/library/mysql</p>
</li>
<li>
<p>下一步填写 mysql 信息</p>
</li>
</ul>
<p><img src="./images/安装向导.jpg" alt="安装向导" /></p>
<ul>
<li>
<p>重启 jpress 容器</p>
<p>docker restart 13</p>
<p>重新加载网页：</p>
<p><img src="./images/jpress1.jpg" alt="jpress1" /></p>
</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-01T06:32:38.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">docker logs</title>
    <id>https://www.snowji.cn/basic-skills/docker/docker-logs/</id>
    <link href="https://www.snowji.cn/basic-skills/docker/docker-logs/"/>
    <updated>2022-08-25T03:15:48.000Z</updated>
    <content type="html"><![CDATA[<h1 id="docker-logs"> docker logs</h1>
<p>作用：获取容器的日志</p>
<h2 id="语法格式"> 语法格式</h2>
<div><pre><code>docker logs [OPTIONS] CONTAINER
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T03:15:48.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">docker pull</title>
    <id>https://www.snowji.cn/basic-skills/docker/docker-pull/</id>
    <link href="https://www.snowji.cn/basic-skills/docker/docker-pull/"/>
    <updated>2022-08-26T03:40:33.000Z</updated>
    <content type="html"><![CDATA[<h1 id="docker-pull"> docker pull</h1>
<p>作用：从镜像仓库中拉取或更新镜像</p>
<h2 id="语法格式"> 语法格式</h2>
<div><pre><code> docker pull [OPTIONS] NAME[:TAG|@DIGEST]
 
 tag：默认是 latest
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>option 说明：</p>
<table>
<thead>
<tr>
<th>option</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a, --all-tags</td>
<td>拉取所有 tagged 镜像</td>
</tr>
<tr>
<td>--disable-content-trust</td>
<td>忽略镜像的校验，默认开启</td>
</tr>
<tr>
<td>--platform</td>
<td>若服务支持多平台，这里可以设置平台</td>
</tr>
<tr>
<td>--quiet，-q</td>
<td>概要输出</td>
</tr>
</tbody>
</table>
<h2 id="拉取镜像"> 拉取镜像</h2>
<p>拉取最新的 tomcat 镜像的过程</p>
<p><img src="./images/pull1.png" alt="pull1" /></p>
<div><pre><code>docker pull tomcat === docker pull docker.io/library/tomcat:latest
</code></pre>
<div><span>1</span><br></div></div><p>拉取指定 tag 的 tomcat 镜像</p>
<p><img src="./images/pull2.png" alt="pull" /></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T03:15:48.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">docker 网络</title>
    <id>https://www.snowji.cn/basic-skills/docker/docker-network/</id>
    <link href="https://www.snowji.cn/basic-skills/docker/docker-network/"/>
    <updated>2022-08-26T03:40:33.000Z</updated>
    <content type="html"><![CDATA[<h1 id="docker-网络"> docker 网络</h1>
<h2 id="网络类型"> 网络类型</h2>
<p><img src="./images/网络模式.jpg" alt="网络模式" /></p>
<ul>
<li>
<p>Bridge (默认模式)</p>
<ul>
<li>host 与容器中的服务通过 Bridge 连接</li>
<li>容器有自己的 IP 地址</li>
<li>在 Bridge 模式下，需要使用到端口映射</li>
</ul>
</li>
<li>
<p>Host</p>
<ul>
<li>
<p>host 与服务器中的服务直接连接</p>
</li>
<li>
<p>容器与 host 在同一局域网类</p>
</li>
</ul>
</li>
<li>
<p>None</p>
<p>无网络模式</p>
</li>
</ul>
<h2 id="理解-docker0"> 理解 docker0</h2>
<p>先使用 <code>ip addr</code> 查看下地址情况</p>
<p><img src="./images/net1.png" alt="docker" /></p>
<p>那 docker 是如何处理容器网络访问的？</p>
<p>先运行一个 tomcat 容器</p>
<div><pre><code><span># 运行容器</span>
<span>docker</span> run -d -P --name tomcat01 tomcat

<span># 查看 ip</span>
<span>docker</span> inspect  tomcat01
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>结果：</p>
<div><pre><code><span>"Networks"</span><span>:</span> <span>{</span>
                <span>"bridge"</span><span>:</span> <span>{</span>
                    <span>"IPAMConfig"</span><span>:</span> null,
                    <span>"Links"</span><span>:</span> null,
                    <span>"Aliases"</span><span>:</span> null,
                    <span>"NetworkID"</span><span>:</span> <span>"1a34c6878d70eff9c776795be79d3af53d90d02387738ce9cdecc9f7a7628a12"</span>,
                    <span>"EndpointID"</span><span>:</span> <span>"e945b60a33d589ea48e113b3667729469c2d798f724dcbf4fecb2511554f9b98"</span>,
                    <span>"Gateway"</span><span>:</span> <span>"123.12.0.1"</span>,
                    <span>"IPAddress"</span><span>:</span> <span>"123.12.0.2"</span>,
                    <span>"IPPrefixLen"</span><span>:</span> <span>16</span>,
                    <span>"IPv6Gateway"</span><span>:</span> <span>""</span>,
                    <span>"GlobalIPv6Address"</span><span>:</span> <span>""</span>,
                    <span>"GlobalIPv6PrefixLen"</span><span>:</span> <span>0</span>,
                    <span>"MacAddress"</span><span>:</span> <span>"02:42:xx:11:xx:02"</span>,
                    <span>"DriverOpts"</span><span>:</span> null
                <span>}</span>
            <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>上面结果中发现：</p>
<ul>
<li>容器的地址与 docker0 的地址在同一网段</li>
<li>容器的网关设置为 docker0 的地址</li>
</ul>
<p>再次在 Linux 上查看 ip</p>
<div><pre><code><span>[</span>root@VM-16-7-centos ~<span>]</span><span># ip addr</span>
<span>1</span>: lo: <span>&lt;</span>LOOPBACK,UP,LOWER_UP<span>></span> mtu <span>65536</span> qdisc noqueue state UNKNOWN group default qlen <span>1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet <span>127.0</span>.0.1/8 scope <span>host</span> lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope <span>host</span> 
       valid_lft forever preferred_lft forever
<span>2</span>: eth0: <span>&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span>></span> mtu <span>1500</span> qdisc mq state UP group default qlen <span>1000</span>
    link/ether <span>52</span>:54:00:23:33:ec brd ff:ff:ff:ff:ff:ff
    inet <span>123.0</span>.16.7/22 brd <span>10.0</span>.19.255 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::5054:ff:fe23:33ec/64 scope <span>link</span> 
       valid_lft forever preferred_lft forever
<span>3</span>: docker0: <span>&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span>></span> mtu <span>1500</span> qdisc noqueue state UP group default 
    link/ether 02:42:f8:a5:25:5b brd ff:ff:ff:ff:ff:ff
    inet <span>123.17</span>.0.1/16 brd <span>123.17</span>.255.255 scope global docker0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:f8ff:fea5:255b/64 scope <span>link</span> 
       valid_lft forever preferred_lft forever
<span>119</span>: veth705ec28@if118: <span>&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span>></span> mtu <span>1500</span> qdisc noqueue master docker0 state UP group default 
    link/ether 0e:91:3d:df:ad:20 brd ff:ff:ff:ff:ff:ff link-netnsid <span>0</span>
    inet6 fe80::c91:3dff:fedf:ad20/64 scope <span>link</span> 
       valid_lft forever preferred_lft forever
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><ul>
<li>可以看到则增加了一个接口 119：veth705ec28@if118，此接口为 tomcat01 容器的接口</li>
<li>接口是成对出现的，这是因为使用了 evth-pair 技术</li>
<li>evth-pair 技术充当桥梁，连接各种虚拟网络设备</li>
</ul>
<p>在 Linux 上使用 ping 命令测试 Linux 与 容器之间是否连通:</p>
<div><pre><code><span>[</span>root@VM-16-7-centos ~<span>]</span><span># ping 123.17.0.2</span>
PING <span>123.17</span>.0.2 <span>(</span><span>123.17</span>.0.2<span>)</span> <span>56</span><span>(</span><span>84</span><span>)</span> bytes of data.
<span>64</span> bytes from <span>123.17</span>.0.2: <span>icmp_seq</span><span>=</span><span>1</span> <span>ttl</span><span>=</span><span>64</span> <span>time</span><span>=</span><span>0.039</span> ms
<span>64</span> bytes from <span>123.17</span>.0.2: <span>icmp_seq</span><span>=</span><span>2</span> <span>ttl</span><span>=</span><span>64</span> <span>time</span><span>=</span><span>0.036</span> ms
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>发现是可以测试成功的</p>
<p>再启动一个 tomcat02 时，tomcat01 和 tomcat02 是可以相互 ping 通的</p>
<p><strong>容器网络访问（重点）</strong>：</p>
<p><img src="./images/net2.png" alt="docker" /></p>
<div><p>总结：</p>
<ul>
<li>Docker 使用 Linux 桥接</li>
<li>Dcoker 中所有的网络接口都是虚拟的，内网转发效率高</li>
<li>Docker 会给容器分配一个可用的 IP</li>
<li>默认不指定网络的情况下，所有的容器共用一个路由 docker0</li>
<li>删除容器，对应的一对网桥就没了</li>
</ul>
</div>
<p><strong>核心原理图</strong>：</p>
<p><img src="./images/net3.png" alt="docker" /></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T03:15:48.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">docker run</title>
    <id>https://www.snowji.cn/basic-skills/docker/docker-run/</id>
    <link href="https://www.snowji.cn/basic-skills/docker/docker-run/"/>
    <updated>2022-08-26T03:40:33.000Z</updated>
    <content type="html"><![CDATA[<h1 id="docker-run"> docker run</h1>
<p>作用：创建并进入容器</p>
<h2 id="语法格式"> 语法格式</h2>
<div><pre><code> docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
</code></pre>
<div><span>1</span><br></div></div><p><strong>COMMAND</strong>：需要在容器内执行的命令</p>
<p><strong>docker run 执行流程</strong>：</p>
<ul>
<li>首先在指定镜像上创建一个可写的容器层</li>
<li>然后使用指定的命令（COMMAND）启动它</li>
<li>docker run 相当于执行了两个 API：/containers/create、/containers/(id)/start</li>
</ul>
<p>常用 options 说明：</p>
<table>
<thead>
<tr>
<th>options</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-i，--interactive</td>
<td>以交互模式运行容器，通常与 -t 同时使用</td>
</tr>
<tr>
<td>-t，--tty</td>
<td>启动容器后，为容器分配一个命令行，通常与 -i 同时使用</td>
</tr>
<tr>
<td>-d, --detach</td>
<td>后台运行容器并打印容器 ID</td>
</tr>
<tr>
<td>--name</td>
<td>给容器添加名字</td>
</tr>
<tr>
<td>-p, --publish</td>
<td>指定端口映射，格式：主机(宿主)端口:容器端口</td>
</tr>
<tr>
<td>-P, --publish-all</td>
<td>随机端口映射，容器内部端口<strong>随机</strong>映射到主机的端口</td>
</tr>
<tr>
<td>-u</td>
<td>以什么用户身份创建容器</td>
</tr>
<tr>
<td>-m, --memory</td>
<td>设置容器使用内存最大值</td>
</tr>
<tr>
<td>--privileged</td>
<td>容器内是否使用真正的 root 权限</td>
</tr>
<tr>
<td>-e username=&quot;ritchie&quot;</td>
<td>设置环境变量</td>
</tr>
<tr>
<td>--dns</td>
<td>指定容器 dns 服务器</td>
</tr>
</tbody>
</table>
<h2 id="docker-run-实例"> docker run 实例</h2>
<h3 id="无-options"> 无 options</h3>
<p>使用镜像 nginx</p>
<p><img src="./images/run1.png" alt="run1" /></p>
<p>此时会将容器日志打印，无法输入其他命令</p>
<p>重新新开一个终端，使用 <code>docker ps</code> 查看容器</p>
<p><img src="./images/run2.png" alt="run" /></p>
<h3 id="带-options"> 带 options</h3>
<h4 id="d"> -d</h4>
<p>后台运行容器方式</p>
<p><img src="./images/run3.png" alt="run" /></p>
<p><strong>注意</strong>：</p>
<ul>
<li>容器使用后台运行，就必须要有一个前台进程</li>
<li>docker 发现没有应用，就会停止</li>
</ul>
<h4 id="name"> --name</h4>
<p>给容器添加名字</p>
<p><img src="./images/run4.png" alt="run" /></p>
<h4 id="端口映射"> 端口映射</h4>
<h5 id="方式一-p"> 方式一：-p</h5>
<p>3 种格式：</p>
<div><pre><code># 指定 ip 和端口
docker run -p ip:主机端口:容器端口
# 指定端口
docker run -p 主机端口:容器端口 （常用）
# 随机端口，与 -P 类似
docker run -p 容器端口
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><img src="./images/run5.png" alt="run" /></p>
<h5 id="方式二-p"> 方式二：-P</h5>
<p><img src="./images/run6.png" alt="run" /></p>
<p>可以看到将容器端口随机映射到主机主机的 49153 端口上了</p>
<h5 id="方式三-expose"> 方式三：--expose</h5>
<p><img src="./images/run7.png" alt="run" /></p>
<p>可以看到将容器端口随机映射到主机主机的 80 端口上了</p>
<h4 id="it"> -it</h4>
<h5 id="不带-bash"> 不带 bash</h5>
<p><img src="./images/run8.png" alt="run" /></p>
<p>没有进入 CLI 界面</p>
<h5 id="带-bash"> 带 bash</h5>
<p><img src="./images/run9.png" alt="run" /></p>
<p>进入了 CLI 界面，可以进行命令操作</p>
<h5 id="退出当前容器"> 退出当前容器</h5>
<div><pre><code>exit         #退出 CLI 容器直接 stop
ctrl +P +Q   #容器不停止退出     ---注意：这个很有用的操作
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T03:15:48.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">docker rmi</title>
    <id>https://www.snowji.cn/basic-skills/docker/docker-rmi/</id>
    <link href="https://www.snowji.cn/basic-skills/docker/docker-rmi/"/>
    <updated>2022-08-26T03:40:33.000Z</updated>
    <content type="html"><![CDATA[<h1 id="docker-rmi"> docker rmi</h1>
<p>作用：删除一个或多个镜像</p>
<h2 id="语法格式"> 语法格式</h2>
<div><pre><code> docker rmi [OPTIONS] IMAGE [IMAGE...]
</code></pre>
<div><span>1</span><br></div></div><p>option 说明：</p>
<table>
<thead>
<tr>
<th>option</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>--force，-f</td>
<td>强制删除镜像</td>
</tr>
<tr>
<td>--no-prune</td>
<td>不删除未标记的</td>
</tr>
</tbody>
</table>
<h2 id="删除镜像"> 删除镜像</h2>
<h3 id="不带-option"> 不带 option</h3>
<h4 id="根据镜像-id-删除"> 根据镜像 ID 删除</h4>
<p><img src="./images/rmi1.png" alt="rmi" /></p>
<h4 id="根据镜像名删除"> 根据镜像名删除</h4>
<p><img src="./images/rmi2.png" alt="rmi" /></p>
<p>默认删除的是 latest 版本</p>
<h4 id="组合删除"> 组合删除</h4>
<p><img src="./images/rmi3.png" alt="rmi" /></p>
<h4 id="强制删除"> 强制删除</h4>
<p><img src="./images/rmi4.png" alt="rmi" /></p>
<p><strong>注意</strong>:</p>
<p>如果通过某个镜像创建了容器，则该镜像无法删除</p>
<p><strong>解决办法</strong>：先删除镜像中的容器，再删除该镜像</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T03:15:48.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">docker run 流程和原理</title>
    <id>https://www.snowji.cn/basic-skills/docker/docker-run-process-principle/</id>
    <link href="https://www.snowji.cn/basic-skills/docker/docker-run-process-principle/"/>
    <updated>2022-09-01T06:32:38.000Z</updated>
    <content type="html"><![CDATA[<h1 id="docker-run-流程和原理"> docker run 流程和原理</h1>
<h2 id="dockers-run-流程"> dockers run 流程</h2>
<ul>
<li>一般学习一门语言都是从 <code>hello world</code> 开始</li>
<li>Docker 安装完成后，可以使用 <code>docker run hello-world</code> 来验证 Docker Engine 是否已正确安装</li>
</ul>
<h3 id="hello-world"> hello-world</h3>
<p><img src="./images/hello1.png" alt="hello" /></p>
<p>根据上面的结果，docker run 的流程如下：</p>
<p><img src="./images/hello2.png" alt="hello" /></p>
<h2 id="docker-底层原理"> Docker 底层原理</h2>
<h3 id="docker-是如何工作的"> Docker 是如何工作的</h3>
<ul>
<li>docker 是一个 C/S 结构的系统</li>
<li>docker 的守护进程运行在主机上</li>
<li>通过 Socket 从客户端访问</li>
<li>docker-Server 接收到 docker-Client的指令，就会执行这个命令</li>
</ul>
<p><img src="./images/拉取运行原理.jpg" alt="hello" /></p>
<ul>
<li>docker-client：可以理解为 cmd 窗口，可以敲 docker 命令</li>
<li>docker-host：其实就是 docker-server，里面包含了守护进程、容器、镜像</li>
<li>docker daemon：就是守护进程，收到命令后就会去执行命令</li>
</ul>
<p>如图：</p>
<p><img src="./images/hello3.png" alt="hello" /></p>
<ul>
<li>Linux 系统中输入 docker 命令</li>
<li>客户端访问 docker 的后台守护进程</li>
<li>后台守护进程执行命令，作用于不同的容器</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-01T06:32:38.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">docker ps</title>
    <id>https://www.snowji.cn/basic-skills/docker/docker-ps/</id>
    <link href="https://www.snowji.cn/basic-skills/docker/docker-ps/"/>
    <updated>2022-08-26T03:40:33.000Z</updated>
    <content type="html"><![CDATA[<h1 id="docker-ps"> docker ps</h1>
<p>作用：查看容器</p>
<h2 id="语法格式"> 语法格式</h2>
<div><pre><code> docker ps [OPTIONS]
</code></pre>
<div><span>1</span><br></div></div><p>option 说明：</p>
<table>
<thead>
<tr>
<th>option</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a,--a</td>
<td>显示所有容器(默认显示运行中的)</td>
</tr>
<tr>
<td>-f,--filter</td>
<td>查看指定条件的容器</td>
</tr>
<tr>
<td>--format string</td>
<td>使用 Go 模板优美的输出</td>
</tr>
<tr>
<td>-n,--last int</td>
<td>查看最近创建的 n 个容器（默认 -1，代表全部）</td>
</tr>
<tr>
<td>-l,--latest</td>
<td>显示最近创建的容器（包括所有状态的容器）</td>
</tr>
<tr>
<td>--no-trunc</td>
<td>显示完整的镜像 ID</td>
</tr>
<tr>
<td>-q,--quit</td>
<td>静默模式，只显示容器 ID</td>
</tr>
<tr>
<td>-s,--size</td>
<td>显示总的文件大小</td>
</tr>
</tbody>
</table>
<h2 id="实例"> 实例</h2>
<h3 id="不带-options"> 不带 options</h3>
<p><img src="./images/ps1png.png" alt="ps" /></p>
<h3 id="带-options"> 带 options</h3>
<p><img src="./images/ps2.png" alt="ps" /></p>
<p><strong>列表字段</strong>：</p>
<ul>
<li><code>CONTAINER ID</code>：容器 ID</li>
<li><code>IMAGE</code>：所属镜像</li>
<li><code>COMMAND</code>：启动容器时后，容器运行的命令</li>
<li><code>CREATED</code>：容器创建时间</li>
<li><code>STATUS</code>：容器状态</li>
<li><code>PORTS</code>：实际运行端口，若有指定运行端口则会显示指定的端口和默认运行端口，以及连接类型（ tcp / udp ）</li>
<li><code>NAMES</code>：容器名称</li>
<li><code>SIZE</code>：容器全部文件的总大小，也会显示容器大小</li>
</ul>
<h4 id="filter"> filter</h4>
<table>
<thead>
<tr>
<th>filter</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>容器 ID</td>
</tr>
<tr>
<td>name</td>
<td>容器名称</td>
</tr>
<tr>
<td>lable</td>
<td>键或键值对的任意字符串，如 <code>&lt;key&gt;</code> 或 <code>&lt;key&gt;=&lt;value&gt;</code></td>
</tr>
<tr>
<td>exited</td>
<td>显示容器退出码，仅对 -a 参数有效</td>
</tr>
<tr>
<td>status</td>
<td>容器状态</td>
</tr>
<tr>
<td>ancestor</td>
<td>显示共享容器的子容器</td>
</tr>
<tr>
<td>before or since</td>
<td>显示在给定容器 ID 或名称之前或之后创建的容器</td>
</tr>
<tr>
<td>volume</td>
<td>显示已经挂在的在运行中的容器</td>
</tr>
<tr>
<td>network</td>
<td>显示连接到网络的在运行中的容器</td>
</tr>
<tr>
<td>publish or expose</td>
<td>显示指定端口的容器</td>
</tr>
<tr>
<td>health</td>
<td>根据容器的健康状态过滤</td>
</tr>
<tr>
<td>isolation</td>
<td>仅限 Windows 守护进程</td>
</tr>
<tr>
<td>is-task</td>
<td>显示作为服务的容器</td>
</tr>
</tbody>
</table>
<p><strong>容器的状态</strong>：</p>
<ul>
<li>created：已创建</li>
<li>restarting：重启中</li>
<li>running：运行中</li>
<li>removing：迁移中</li>
<li>paused：暂停</li>
<li>exited：停止</li>
<li>dead：死亡</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T03:15:48.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">docker search</title>
    <id>https://www.snowji.cn/basic-skills/docker/docker-search/</id>
    <link href="https://www.snowji.cn/basic-skills/docker/docker-search/"/>
    <updated>2022-08-26T03:40:33.000Z</updated>
    <content type="html"><![CDATA[<h1 id="docker-search"> docker search</h1>
<p>作用：从 Docker Hub 搜索镜像</p>
<h2 id="语法格式"> 语法格式</h2>
<div><pre><code> docker search [OPTIONS] TERM
</code></pre>
<div><span>1</span><br></div></div><p>options 说明：</p>
<table>
<thead>
<tr>
<th>option</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-f, --filter filter</td>
<td>根据提供的 filter 过滤输出</td>
</tr>
<tr>
<td>--limit</td>
<td>搜索结果的最大数目（默认25）</td>
</tr>
<tr>
<td>--no-trunc</td>
<td>显示完整的镜像 description</td>
</tr>
<tr>
<td>--format</td>
<td>使用 Go 模板进行美观打印</td>
</tr>
</tbody>
</table>
<h2 id="搜索镜像"> 搜索镜像</h2>
<h3 id="不带-options"> 不带 options</h3>
<p>通过搜索镜像名</p>
<p><img src="./images/search1.png" alt="search" /></p>
<p><strong>列表含义</strong>:</p>
<ul>
<li><code>NAME</code>：镜像名称</li>
<li><code>DESCRIPTION</code>：镜fil像描述</li>
<li><code>STARS</code>：用户评价，反映一个镜像的受欢迎程度</li>
<li><code>OFFICIAL</code>：是否为官方构建</li>
<li><code>AUTOMATED</code>：自动构建，表示该镜像由 Docker Hub 自动构建流程创建的</li>
</ul>
<h2 id="带-options"> 带 options</h2>
<h4 id="limit"> limit</h4>
<p>限制返回结果数</p>
<p><img src="./images/search2.png" alt="search" /></p>
<h4 id="no-trunc"> --no-trunc</h4>
<p>搜索 star 数量 &gt;=3 的 busybox 镜像并打印详细描述</p>
<p><img src="./images/search3.png" alt="search" /></p>
<h4 id="filter"> filter</h4>
<h5 id="stars"> stars</h5>
<p>搜索 star 数量 &gt;=3 的 busybox 镜像</p>
<p><img src="./images\search4.png" alt="search" /></p>
<h5 id="is-automated"> is-automated</h5>
<p>搜索自动构建的 busybox 镜像</p>
<p><img src="./images/search5.png" alt="search" /></p>
<p>看到 AUTOMATED 都是【OK】</p>
<h5 id="is-official"> is-official</h5>
<p>搜索 star 数量 &gt;=3 且是官方版本的 busybox 镜像</p>
<p><img src="./images/search6.png" alt="search" /></p>
<p>看到 OFFICIAL 都是【OK】</p>
<h5 id="format"> --format</h5>
<p>输出 name：StarCount 格式的 nginx 镜像</p>
<p><img src="./images/search7.png" alt="search" /></p>
<p>输出表格格式的 nginx 镜像</p>
<p><img src="./images/search8.png" alt="search" /></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T03:15:48.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">docker stop/pause</title>
    <id>https://www.snowji.cn/basic-skills/docker/docker-stop-pause/</id>
    <link href="https://www.snowji.cn/basic-skills/docker/docker-stop-pause/"/>
    <updated>2022-08-26T03:40:33.000Z</updated>
    <content type="html"><![CDATA[<h1 id="docker-stop-pause"> docker stop/pause</h1>
<p>作用：停止/暂停一个或多个容器</p>
<h2 id="语法格式"> 语法格式</h2>
<div><pre><code> docker stop [OPTIONS] CONTAINER [CONTAINER...]
 docker pause CONTAINER [CONTAINER...]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>stop option 说明：</p>
<table>
<thead>
<tr>
<th>option</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>--time, -t</td>
<td>设置等多杀秒后停止容器，默认是 10 秒</td>
</tr>
</tbody>
</table>
<h2 id="docker-stop-pause-实例"> docker stop/pause 实例</h2>
<h3 id="停止-暂停单个容器"> 停止/暂停单个容器</h3>
<div><pre><code># 使用容器名停止
docker stop mynginx   
# 使用容器ID 停止
docker stop e8bc9f7aa299
# 使用容器名暂停
docker pause mynginx
# 使用容器ID 暂停
docker pause e8bc9f7aa299
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><img src="./images/run12.png" alt="run" /></p>
<p><img src="./images/pause1.png" alt="run" /></p>
<h3 id="停止-暂停多个容器"> 停止/暂停多个容器</h3>
<p>使用 <code>docker ps -a -q</code> 获取所有容器的 ID</p>
<p><img src="./images/run13.png" alt="run" /></p>
<p><img src="./images/pause2.png" alt="run" /></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T03:15:48.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">docker start/restart</title>
    <id>https://www.snowji.cn/basic-skills/docker/docker-start-restart/</id>
    <link href="https://www.snowji.cn/basic-skills/docker/docker-start-restart/"/>
    <updated>2022-08-26T03:40:33.000Z</updated>
    <content type="html"><![CDATA[<h1 id="docker-start-restart"> docker start/restart</h1>
<p>作用：启动/重启一个或多个容器</p>
<h2 id="语法格式"> 语法格式</h2>
<div><pre><code>docker start [OPTIONS] CONTAINER [CONTAINER...]
docker restart [OPTIONS] CONTAINER [CONTAINER...]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>restart 的常用 options：</p>
<table>
<thead>
<tr>
<th>option</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>--time, -t</td>
<td>设置等多杀秒后重启容器，默认是 10 秒</td>
</tr>
</tbody>
</table>
<h2 id="docker-start-restat-实例"> docker start/restat 实例</h2>
<h3 id="启动-重启单个容器"> 启动/重启单个容器</h3>
<div><pre><code># 使用容器名启动
docker start mynginx   
# 使用容器ID 启动
docker start e8bc9f7aa299
# 使用容器名重启
docker restart mynginx
# 使用容器ID 重启
docker restart e8bc9f7aa299
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><img src="./images/run10.png" alt="run" /></p>
<p><img src="./images/run14.png" alt="run" /></p>
<h3 id="启动-重启多个容器"> 启动/重启多个容器</h3>
<div><pre><code>docker start $(docker ps -a -q)
docker restart $(docker ps -a -q)
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>使用 <code>docker ps -a -q</code> 获取所有容器的 ID</p>
<p><img src="./images/run11.png" alt="run" /></p>
<p><img src="./images/run15.png" alt="run" /></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T03:15:48.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">docker version/info</title>
    <id>https://www.snowji.cn/basic-skills/docker/docker-version/</id>
    <link href="https://www.snowji.cn/basic-skills/docker/docker-version/"/>
    <updated>2022-08-26T03:40:33.000Z</updated>
    <content type="html"><![CDATA[<h1 id="docker-version-info"> docker version/info</h1>
<p>version：查看 Docker 的版本信息</p>
<p>info：显示 Docker 系统信息，包括镜像和容器数</p>
<h2 id="docker-version"> docker version</h2>
<h3 id="语法格式"> 语法格式</h3>
<div><pre><code>docker version [OPTIONS]
</code></pre>
<div><span>1</span><br></div></div><p>options 说明：</p>
<table>
<thead>
<tr>
<th>option</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>--format,-f</td>
<td>使用 Go 模板进行美观打印</td>
</tr>
<tr>
<td>--kubeconfig</td>
<td>Kubernetes 配置文件</td>
</tr>
</tbody>
</table>
<h3 id="实例"> 实例</h3>
<h4 id="不带-option"> 不带 option</h4>
<p><img src="./images/version1.png" alt="version" /></p>
<p>可以看到 Docker Client 和 Docker Server 信息</p>
<h4 id="带-option"> 带 option</h4>
<h5 id="format"> --format</h5>
<p>获取 Server 版本</p>
<p><img src="./images/version2.png" alt="version" /></p>
<h2 id="docker-info"> docker info</h2>
<h3 id="语法格式-2"> 语法格式</h3>
<div><pre><code>docker info [OPTIONS]
</code></pre>
<div><span>1</span><br></div></div><p>options 说明：</p>
<table>
<thead>
<tr>
<th>-f</th>
<th>：使用给定的模板格式化输出（一般不用）</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p><img src="./images/info.png" alt="info" /></p>
<ul>
<li>Client：docker 客户端信息</li>
<li>Server：docker 服务端信息</li>
<li>Containers：容器数量</li>
<li>Images：镜像数量</li>
<li>Server Version：docker 版本</li>
<li>Docker Root Dir：docker 根目录</li>
<li>Registry Mirrors：当前使用的镜像源</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T03:15:48.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">docker top</title>
    <id>https://www.snowji.cn/basic-skills/docker/docker-top/</id>
    <link href="https://www.snowji.cn/basic-skills/docker/docker-top/"/>
    <updated>2022-08-26T03:40:33.000Z</updated>
    <content type="html"><![CDATA[<h1 id="docker-top"> docker top</h1>
<p>作用：显示容器的运行进程</p>
<h2 id="语法格式"> 语法格式</h2>
<div><pre><code> docker top CONTAINER [ps OPTIONS]
</code></pre>
<div><span>1</span><br></div></div><h2 id="实例"> 实例</h2>
<p>列出所有进程</p>
<div><pre><code>docker top topdemo
</code></pre>
<div><span>1</span><br></div></div><p><img src="./images/top1.png" alt="top" /></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T03:15:48.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">docker images 命令</title>
    <id>https://www.snowji.cn/basic-skills/docker/images-command/</id>
    <link href="https://www.snowji.cn/basic-skills/docker/images-command/"/>
    <updated>2022-09-01T06:32:38.000Z</updated>
    <content type="html"><![CDATA[<h1 id="docker-images-命令"> docker images 命令</h1>
<p>作用：列出本机所有镜像</p>
<h2 id="语法格式"> 语法格式:</h2>
<div><pre><code> docker images [OPTIONS] [REPOSITORY[:TAG]]
</code></pre>
<div><span>1</span><br></div></div><p>options 说明:</p>
<table>
<thead>
<tr>
<th>options</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a, --all</td>
<td>列出本地所有的镜像（含中间镜像层，默认情况下，过滤掉中间映像层）</td>
</tr>
<tr>
<td>--digests</td>
<td>显示镜像的摘要信息</td>
</tr>
<tr>
<td>-f, --filter</td>
<td>显示满足条件（filter）的镜像</td>
</tr>
<tr>
<td>--format</td>
<td>使用模板格式化输出</td>
</tr>
<tr>
<td>--no-trunc</td>
<td>显示完整的镜像信息</td>
</tr>
<tr>
<td>-q, --quiet</td>
<td>只显示镜像 ID</td>
</tr>
</tbody>
</table>
<h2 id="查看镜像"> 查看镜像：</h2>
<div><pre><code>docker images
</code></pre>
<div><span>1</span><br></div></div><p><img src="./images/images1.png" alt="images" /></p>
<p><strong>列表含义</strong>：</p>
<ul>
<li><code>REPOSITORY</code>：镜像在仓库中的名称</li>
<li><code>TAG</code>：镜像标签</li>
<li><code>IMAGE ID</code>：镜像 ID</li>
<li><code>CREATED</code>：镜像的创建日期（不是获取该镜像的日期）</li>
<li><code>SIZE</code>：镜像大小</li>
</ul>
<h3 id="带-option"> 带 option</h3>
<h4 id="a"> -a</h4>
<p><img src="./images/images2.png" alt="images" /></p>
<h4 id="digests"> --digests</h4>
<p><img src="./images/images3.png" alt="images" /></p>
<h4 id="no-trunc"> --no-trunc</h4>
<p><img src="./images/images5.png" alt="images" /></p>
<h4 id="q"> -q</h4>
<p><img src="./images/images4.png" alt="images" /></p>
<h4 id="指定镜像名或tag"> 指定镜像名或tag</h4>
<p><img src="./images/images6.png" alt="images" /></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-01T06:32:38.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">配置镜像加速</title>
    <id>https://www.snowji.cn/basic-skills/docker/mirror-accelerate/</id>
    <link href="https://www.snowji.cn/basic-skills/docker/mirror-accelerate/"/>
    <updated>2022-09-01T06:32:38.000Z</updated>
    <content type="html"><![CDATA[<h1 id="配置镜像加速"> 配置镜像加速</h1>
<h2 id="为什么要配置镜像加速"> 为什么要配置镜像加速</h2>
<ul>
<li>Docker 从 Docker Hub 拉取镜像，因为是从国外获取，所以速度较慢</li>
<li>配置国内镜像源的方式，从国内获取镜像，提高拉取速度</li>
</ul>
<h2 id="配置"> 配置</h2>
<p>编辑/新建文件 daemon.json</p>
<div><pre><code>vi /etc/docker/daemon.json
</code></pre>
<div><span>1</span><br></div></div><p>文件中输入以下内容</p>
<div><pre><code><span>{</span>
  <span>"registry-mirrors"</span><span>:</span> <span>[</span><span>"https://docker.mirrors.ustc.edu.cn"</span><span>,</span> 
                       <span>"http://hub-mirror.c.163.com"</span><span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>重新加载配置信息及重启 Docker 服务</p>
<div><pre><code><span># 重新加载某个服务的配置文件</span>
<span>sudo</span> systemctl daemon-reload
<span># 重新启动 docker</span>
<span>sudo</span> systemctl restart <span>docker</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-01T06:32:38.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Jenkins 容器中搭建 Python+Pytest+Allure 环境</title>
    <id>https://www.snowji.cn/basic-skills/docker/jenkins-pytest-allure/</id>
    <link href="https://www.snowji.cn/basic-skills/docker/jenkins-pytest-allure/"/>
    <updated>2022-09-01T06:32:38.000Z</updated>
    <content type="html"><![CDATA[<h1 id="jenkins-容器中搭建-python-pytest-allure-环境"> Jenkins 容器中搭建 Python+Pytest+Allure 环境</h1>
<h2 id="前言"> 前言</h2>
<p>需要了解 Docker 中搭建 Jenkins 环境，可参考 <a href="/basic-skills/docker/jenkins">Jenkins 应用安装</a></p>
<h2 id="搭建-python-pytest-allure-环境"> 搭建 Python+Pytest+Allure 环境</h2>
<h3 id="前期准备"> 前期准备</h3>
<p>Jenkins 容器开启</p>
<p>使用 root 权限进入 Jenkins 容器中</p>
<div><pre><code><span>docker</span> <span>exec</span> -it -uroot myjenkins /bin/bsah
</code></pre>
<div><span>1</span><br></div></div><p>更新容器的软件包</p>
<div><pre><code>
<span># 获取最新的软件包</span>
<span>apt-get</span> update

<span># 升级已安装的软件包</span>
<span>apt-get</span> upgrade

<span># 提前安装，以便接下来的配置操作</span>
<span>apt-get</span> -y <span>install</span> gcc automake autoconf libtool <span>make</span>
<span>apt-get</span> -y <span>install</span> make*
<span>apt-get</span> -y <span>install</span> zlib*
<span>apt-get</span> -y <span>install</span> openssl libssl-dev
<span>apt-get</span> <span>install</span> <span>sudo</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="安装-python-环境"> 安装 Python 环境</h3>
<h4 id="下载-python"> 下载 Python</h4>
<div><pre><code><span>cd</span> /usr/local/src
<span>wget</span> https://www.python.org/ftp/python/3.9.10/Python-3.9.10.tgz
<span>tar</span> -zxvf Python-3.9.10.tgz
<span>mv</span> Python-3.9.10 py3.9
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><p>注意</p>
<p>如果容器中没有 wget 命令，可以使用 apt-get 命令安装即可</p>
</div>
<h4 id="make-编译安装"> make 编译安装</h4>
<p>在 <code>/usr/local/src/py3.9</code> 安装目录下执行下面的命令</p>
<div><pre><code><span>cd</span> py3.9
./configure --prefix<span>=</span>/usr/local/src/py3.6
<span>make</span> <span>&amp;&amp;</span> <span>make</span> <span>install</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id="添加软连接"> 添加软连接</h4>
<p>添加 Python3 的软连接</p>
<div><pre><code><span>ln</span> -s /usr/local/src/py3.9/bin/python3.9 /usr/bin/python3
</code></pre>
<div><span>1</span><br></div></div><p>添加 pip3 的软连接</p>
<div><pre><code><span>ln</span> -s /usr/local/src/py3.9/bin/pip3 /usr/bin/pip3
</code></pre>
<div><span>1</span><br></div></div><h4 id="验证-python3-环境"> 验证 Python3 环境</h4>
<div><pre><code>root@92d5bc74c71d:/usr/local/src/py3.9<span># python3</span>
Python <span>3.9</span>.10 <span>(</span>main, Apr <span>23</span> <span>2022</span>, 06:54:19<span>)</span> 
<span>[</span>GCC <span>10.2</span>.1 <span>20210110</span><span>]</span> on linux
Type <span>"help"</span>, <span>"copyright"</span>, <span>"credits"</span> or <span>"license"</span> <span>for</span> <span>more</span> information.
<span>>></span><span>></span> ^Z
<span>[</span><span>2</span><span>]</span>+  Stopped                 python3
root@92d5bc74c71d:/usr/local/src/py3.9<span># pip3</span>

Usage:   
  pip3 <span>&lt;</span>command<span>></span> <span>[</span>options<span>]</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h4 id="安装相应的库"> 安装相应的库</h4>
<p>将 Python 项目中生成的 requirement.txt 复制到容器的 <code>/usr/local/src</code> 目录下</p>
<div><pre><code><span>docker</span> <span>cp</span> requirement.txt jenkins1:/usr/local/src 
</code></pre>
<div><span>1</span><br></div></div><p>通过 requirement.txt 安装</p>
<div><pre><code>pip3 <span>install</span> -r requirement.txt
</code></pre>
<div><span>1</span><br></div></div><h3 id="安装-allure-环境"> 安装 Allure 环境</h3>
<h4 id="下载-allure-安装包"> 下载 Allure 安装包</h4>
<p>官网下载：https://github.com/allure-framework/allure2/releases</p>
<p>自己可以选择一个 tgz 版本进行下载</p>
<h4 id="将压缩包传送到容器内"> 将压缩包传送到容器内</h4>
<ul>
<li>下载完成后，先将下载的安装包传送到服务器上</li>
</ul>
<div><pre><code>rz -b
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>将服务器上的安装包复制到容器内，并解压</li>
</ul>
<div><pre><code><span>docker</span> <span>cp</span> allure-2.17.3.tgz myjenkins:/usr/local/src

<span>tar</span> -zxvf allure-2.17.3.tgz
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>给该文件赋予最高权限</li>
</ul>
<div><pre><code><span>mv</span> allure-2.17.3 allure
<span>chmod</span> -R <span>777</span> allure
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h4 id="配置-allure-和-py-环境变量"> 配置 allure 和 py 环境变量</h4>
<div><pre><code><span>cat</span> <span>>></span> /root/.bashrc <span>&lt;&lt;</span> <span>"EOF" 
export PATH=/usr/local/src/allure/bin:$PATH 
export PATH=/usr/local/src/py3.6/bin:$PATH 
EOF</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>重新加载环境</p>
<div><pre><code><span>source</span> /root/.bashrc
</code></pre>
<div><span>1</span><br></div></div><p>验证环境</p>
<div><pre><code>allure --version
python3 --version
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="配置-jdk-环境"> 配置 JDK 环境</h3>
<p>查看 JDK 环境</p>
<div><pre><code><span>export</span>

root@92d5bc74c71d:/usr/local/src<span># export</span>
<span>declare</span> -x <span>COPY_REFERENCE_FILE_LOG</span><span>=</span><span>"/var/jenkins_home/copy_reference_file.log"</span>
<span>declare</span> -x <span><span>HOME</span></span><span>=</span><span>"/root"</span>
<span>declare</span> -x <span><span>HOSTNAME</span></span><span>=</span><span>"92d5bc74c71d"</span>
<span>declare</span> -x <span>JAVA_HOME</span><span>=</span><span>"/opt/java/openjdk"</span>
<span>declare</span> -x <span>JENKINS_HOME</span><span>=</span><span>"/var/jenkins_home"</span>
<span>declare</span> -x <span>JENKINS_INCREMENTALS_REPO_MIRROR</span><span>=</span><span>"https://repo.jenkins-ci.org/incrementals"</span>
<span>declare</span> -x <span>JENKINS_SLAVE_AGENT_PORT</span><span>=</span><span>"50000"</span>
<span>declare</span> -x <span>JENKINS_UC</span><span>=</span><span>"https://updates.jenkins.io"</span>
<span>declare</span> -x <span>JENKINS_UC_EXPERIMENTAL</span><span>=</span><span>"https://updates.jenkins.io/experimental"</span>
<span>declare</span> -x <span>JENKINS_VERSION</span><span>=</span><span>"2.328"</span>
<span>declare</span> -x <span><span>LANG</span></span><span>=</span><span>"C.UTF-8"</span>
<span>declare</span> -x <span><span>OLDPWD</span></span><span>=</span><span>"/usr/local/src/allure-2.17.3"</span>
<span>declare</span> -x <span><span>PATH</span></span><span>=</span><span>"/usr/local/src/py3.9/bin:/usr/local/src/allure/bin:/opt/java/openjdk/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span>
<span>declare</span> -x <span><span>PWD</span></span><span>=</span><span>"/usr/local/src"</span>
<span>declare</span> -x <span>REF</span><span>=</span><span>"/usr/share/jenkins/ref"</span>
<span>declare</span> -x <span><span>SHLVL</span></span><span>=</span><span>"1"</span>
<span>declare</span> -x <span><span>TERM</span></span><span>=</span><span>"xterm"</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>这里可以看到很多容器本身自带的环境变量</p>
<ul>
<li>Jenkins 的版本</li>
<li>JDK 的安装路径</li>
</ul>
<p>配置 JDK 环境变量</p>
<div><pre><code><span>cat</span> <span>>></span> /root/.bashrc<span>&lt;&lt;</span> <span>"EOF" 
export PATH=$JAVA_HOME/bin:$PATH 
EOF</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>重新加载环境</p>
<div><pre><code><span>source</span> /root/.bashrc
</code></pre>
<div><span>1</span><br></div></div><p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-01T06:32:38.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">使用 Jenkins 构建 Pytest 项目生成 Allure 报告</title>
    <id>https://www.snowji.cn/basic-skills/docker/jenkins-allure-actual-combat1/</id>
    <link href="https://www.snowji.cn/basic-skills/docker/jenkins-allure-actual-combat1/"/>
    <updated>2022-08-26T03:40:33.000Z</updated>
    <content type="html"><![CDATA[<h1 id="使用-jenkins-构建-pytest-项目生成-allure-报告"> 使用 Jenkins 构建 Pytest 项目生成 Allure 报告</h1>
<h2 id="前言"> 前言</h2>
<ul>
<li>docker 中安装 Jenkins，可参考 <a href="/basic-skills/docker/jenkins.html">Jenkins 安装</a></li>
<li>Jenkins 容器中配置好 Python+Pytest+Allure 环境</li>
</ul>
<h2 id="安装插件"> 安装插件</h2>
<h3 id="安装插件-allure"> 安装插件 Allure</h3>
<p>左边列表中选择 Manage Jenkins</p>
<p><img src="./images/jenkins3.png" alt="jenkins" /></p>
<p>System Configuration 中选择 Manage Plugins</p>
<p><img src="./images/jenkins4.png" alt="jenkins" /></p>
<p>在插件管理中，选择可安装的选项，并在搜索框中输入 allure，选择 Allure 并安装</p>
<p><img src="./images/jenkins11.png" alt="jenkins" /></p>
<p>完成后，在全局工具配置中，设置 Allure 的路径，并保存</p>
<p><img src="./images/jenkins12.png" alt="jenkins" /></p>
<h2 id="jenkins-配置"> Jenkins 配置</h2>
<h3 id="上传项目"> 上传项目</h3>
<ul>
<li>
<p>将本地已有的 Pytest 项目上传到服务器 <code>/var/jenkins_node/pytest_project</code>中</p>
</li>
<li>
<p>因为这个目录在创建 Jenkins 容器时已经映射到容器的内部了</p>
</li>
<li>
<p>进入容器中的此目录下，执行 <code>pytest -sq --alluredir=./allure-results --clean-alluredir</code>，执行成功</p>
</li>
</ul>
<h3 id="jenkins-中配置"> Jenkins 中配置</h3>
<p><strong>第一步</strong>：新建一个任务，填入名称并选择”构建一个自由风格的软件项目“，并确定</p>
<p><img src="./images/jenkins8.png" alt="jenkins" /></p>
<p><strong>第二步</strong>：进入配置页进行配置</p>
<p>构建：配置要执行的 Pytest 的命令</p>
<p><img src="./images/jenkins9.png" alt="jenkins" /></p>
<p>构建后操作：输入要生成报告的文件目录</p>
<p><img src="./images/jenkins10.png" alt="jenkins" /></p>
<p>完成配置后，在创建的项目中点击构建，构建成功后，可以看到 console 控制台的输出</p>
<p><img src="./images/jenkins13.png" alt="jenkins" /></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T03:15:48.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Docker 安装 Jenkins</title>
    <id>https://www.snowji.cn/basic-skills/docker/jenkins/</id>
    <link href="https://www.snowji.cn/basic-skills/docker/jenkins/"/>
    <updated>2022-08-26T03:40:33.000Z</updated>
    <content type="html"><![CDATA[<h1 id="docker-安装-jenkins"> Docker 安装 Jenkins</h1>
<h2 id="安装步骤"> 安装步骤</h2>
<ul>
<li>下载 Jenkins 镜像</li>
</ul>
<div><pre><code><span>docker</span> pull jenkins/jenkins
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>在 Linux 服务器中创建个目录用于后面做目录映射</li>
</ul>
<div><pre><code><span>mkdir</span> -p /var/jenkins_mount

<span>chmod</span> <span>777</span> /var/jenkins_mount
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>创建容器</li>
</ul>
<div><pre><code><span>docker</span> run -d -p <span>8080</span>:8080 -p <span>5000</span>:50000 -v /var/jenkins_mount:/var/jenkins_home -v /etc/localtime:/etc/localtime --name myjenkins jenkins/jenkins
</code></pre>
<div><span>1</span><br></div></div><p>创建成功后，查看</p>
<div><pre><code><span>[</span>root@VM-16-7-centos ~<span>]</span><span># docker ps</span>
CONTAINER ID   IMAGE                 COMMAND                  CREATED         STATUS         PORTS                                                                                             NAMES
044b1cd93ce8   jenkins/jenkins:lts   <span>"/sbin/tini -- /usr/…"</span>   <span>8</span> seconds ago   Up <span>6</span> seconds   <span>0.0</span>.0.0:5000-<span>></span><span>5000</span>/tcp, :::5000-<span>></span><span>5000</span>/tcp, <span>0.0</span>.0.0:8080-<span>></span><span>8080</span>/tcp, :::8080-<span>></span><span>8080</span>/tcp, <span>50000</span>/tcp   myjenkins
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>配置镜像加速
进入 /var/jenkins_mount 目录，修改 hudson.model.UpdateCenter.xml 里的内容</li>
</ul>
<p>将 url 修改为 https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</p>
<ul>
<li>访问 Jenkins 页面，使用 IP:8080</li>
</ul>
<p><img src="./images/jenkins1.png" alt="jenkins" /></p>
<p>打开上图中提示的 /var/jenkins_mount/secrets/initialAdminPassword 文件获取密码</p>
<p>输入密码，并确定</p>
<ul>
<li>进入安装插件页，这里选择第一种种方式，并选择推荐的插件安装</li>
</ul>
<p>插件安装完成后，后面按照提示的进行就行啦</p>
<ul>
<li>Jenkins 安装完成后，成功进入界面</li>
</ul>
<p><img src="./images/jenkins2.png" alt="jenkins" /></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T03:15:48.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Nginx 部署</title>
    <id>https://www.snowji.cn/basic-skills/docker/nginx-deploy/</id>
    <link href="https://www.snowji.cn/basic-skills/docker/nginx-deploy/"/>
    <updated>2022-09-01T06:32:38.000Z</updated>
    <content type="html"><![CDATA[<h1 id="nginx-部署"> Nginx 部署</h1>
<h2 id="搜索镜像"> 搜索镜像</h2>
<p>建议可以去 DockerHub 上去搜索</p>
<div><pre><code>docker search nginx
</code></pre>
<div><span>1</span><br></div></div><h2 id="拉取镜像"> 拉取镜像</h2>
<div><pre><code>docker pull nginx
</code></pre>
<div><span>1</span><br></div></div><h2 id="运行镜像"> 运行镜像</h2>
<div><pre><code>docker run -d --name nginx01 -p 3344:80 nginx
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>-d：后台运行</li>
<li>-p：端口映射，将容器内部的 80 端口映射到宿主机的 3344 端口</li>
<li>--name：给容器命名</li>
</ul>
<h2 id="验证容器运行成功"> 验证容器运行成功</h2>
<p><img src="./images/nginx2.png" alt="nginx" /></p>
<h2 id="进入容器内部"> 进入容器内部</h2>
<div><pre><code>docker exec -it nginx01 bash
</code></pre>
<div><span>1</span><br></div></div><h2 id="运行原理"> 运行原理</h2>
<p><img src="./images/nginx1.png" alt="nginx" /></p>
<ul>
<li>外网访问 Linux 的 3344 端口，需要阿里云安全组先开放 3344 端口，才能正常访问</li>
<li>打通宿主机和 Docker 容器，通过宿主机的 3344 端口访问容器内部的 80 端口，就是端口映射</li>
</ul>
<h2 id="每次改动配置文件-都要-exec-进入容器内部吗"> 每次改动配置文件，都要 exec 进入容器内部吗？</h2>
<ul>
<li>不需要</li>
<li>docker run 命令提供了 -v 参数，它可以做到目录映射，即数据卷挂载</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-01T06:32:38.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Git</title>
    <id>https://www.snowji.cn/basic-skills/git/</id>
    <link href="https://www.snowji.cn/basic-skills/git/"/>
    <updated>2022-08-25T08:02:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="git"> Git</h1>
<p>在实际开发中，我们会使用 Git（GitLab/GitHub）作为版本控制工具来完成团队协作。因此，熟悉 Git 的日常操作也是一名开发者的基本功。这个系列对一些术语或者理论基础不作赘述，可以参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener noreferrer">廖雪峰老师的博文</a>。我主要对常用操作及命令做归纳总结，并就实际工作中遇到的一些问题点作记录，方便日后查询</p>
<hr>
<p>必备知识点：</p>
<div style="text-align: center;">
  <img src="./images/git.png" alt="Git 通用操作流程图" style="width: 640px;">
</div>
<p>最常用的就是图中的 6 个命令，但在使用之前首先要弄清楚几个名词概念：</p>
<ul>
<li><strong>Remote</strong>：远程仓库</li>
<li><strong>Repository</strong>：本地仓库</li>
<li><strong>Index/Stage</strong>：Git 追踪树，暂存区</li>
<li><strong>workspace</strong>：本地工作区（即你编辑器的代码）</li>
</ul>
<hr>
<p>在实际开发过程中，经常会借助一些图形化 Git 客户端来完成一些操作，比如 TortoiseGit，Sourcetree 和 IDE 中集成的插件。但也有需要命令行操作的时候，比如一些复杂的回滚操作、线上出问题、Linux 服务器上没有图形化客户端等。所以命令行操作是一项不可或缺的基本技能</p>
<hr>
<p>关于 Git 的知识点，主要参考：</p>
<ul>
<li><a href="https://git-scm.com/book" target="_blank" rel="noopener noreferrer">官方文档</a></li>
<li>《Git权威指南第二版》</li>
<li>工作生产实践</li>
</ul>
<div style="text-align: right">
  <svg t="1637141435644" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1168" width="64" height="64"><path d="M63.49884471 444.72482676L339.27934283 168.4672005l80.63478137 81.1119106c-11.45109332 40.55595587 7.15693331 84.92894248 44.3729866 106.39974246v264.32940369c-28.62773329 16.22238256-47.7128892 47.23575993-47.71288806 82.54329842a95.42577726 95.42577726 0 0 0 95.42577726 95.42577726 95.42577726 95.42577726 0 0 0 95.42577726-95.42577726c0-35.30753736-19.08515589-66.32091583-47.71288806-82.54329842V388.42361757l98.76567986 99.7199384c-3.33990259 7.15693331-3.33990259 15.26812405-3.33990261 23.85644403a95.42577726 95.42577726 0 0 0 95.42577728 95.42577726 95.42577726 95.42577726 0 0 0 95.42577839-95.42577726 95.42577726 95.42577726 0 0 0-95.42577839-95.42577726c-8.58831998 0-16.69951071 0-23.85644403 3.33990146L604.0858758 297.2920003a94.47151987 94.47151987 0 0 0-54.86982251-111.64815985c-20.51654257-7.63406259-41.98734253-9.54257739-61.07249732-4.29415998L407.03164421 100.71489799l37.69318255-37.21605328c37.21605328-37.69318254 97.3342932-37.69318254 134.55034648 0l381.22598205 381.22598205c37.69318254 37.21605328 37.69318254 97.3342932 0 134.55034648l-381.22598205 381.22598205c-37.21605328 37.69318254-97.3342932 37.69318254-134.55034648 0L63.49884471 579.27517324c-37.69318254-37.21605328-37.69318254-97.3342932 0-134.55034648z" fill="#E64A19" p-id="1169"></path></svg>
</div>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:02:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">配置密钥实现免密操作</title>
    <id>https://www.snowji.cn/basic-skills/git/add-ssh-key/</id>
    <link href="https://www.snowji.cn/basic-skills/git/add-ssh-key/"/>
    <updated>2022-08-25T08:02:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="配置密钥实现免密操作"> 配置密钥实现免密操作</h1>
<blockquote>
<p>本文介绍如何在本地电脑上生成 ssh 秘钥并配置到 GitHub，实现免密 pull、push 代码</p>
</blockquote>
<p>Git 支持 https 和 git 两种传输协议，例如在 GitHub 在 clone 代码时会有两种协议可选：</p>
<ul>
<li>Clone with HTTPS：<code>https://github.com/[your-github-id]/[repo-name].git</code></li>
<li>Clone with SSH：<code>git@github.com:[your-github-id]/[repo-name].git</code></li>
</ul>
<p>若使用 https 协议，每次 pull、push 代码均提示要输入密码；若使用 git 协议，然后通过 ssh 密钥对认证，即可实现免密操作。</p>
<p><strong>本文面向使用 git 协议的情况</strong>，我平时不是通过该协议操作的，因此仅是验证了一下操作步骤。</p>
<p>配置 Git 通过 ssh 协议免密需要三个步骤：</p>
<ul>
<li>生成密钥对</li>
<li>配置远程仓库（这里使用 GitHub）上的公钥</li>
<li>把 Git 的 remote url 修改为 git 协议
<ul>
<li>上面两个步骤初次设置过以后，以后使用都不需要再次设置；此步骤视以后项目的 remote url 而定，如果以后其他项目的协议为 https 则需要此步骤。</li>
</ul>
</li>
</ul>
<p>下面具体介绍每一步骤：</p>
<h3 id="本地生成-ssh-秘钥"> 本地生成 ssh 秘钥</h3>
<p>打开终端，执行 <code>ssh-keygen -t rsa -C &quot;你在GitHub上使用的邮箱地址&quot;</code>，如果执行成功，切换到 <code>~/.ssh</code> 目录下，此时目录应该如下所示。</p>
<div><pre><code>├── id_rsa       # 私钥
├── id_rsa.pub   # 公钥
└── known_hosts  # 记录每个你访问过的计算机的公钥(public key)，防止 DNS 攻击
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="添加公钥到自己的远程仓库-github"> 添加公钥到自己的远程仓库（GitHub）</h3>
<p>复制公钥（<code>id_rsa.pub</code>）的内容，访问 GitHub，依次进入：<code>Settings --&gt; SSH and GPG keys --&gt; New SSH key</code>。</p>
<p><code>Title</code> 随便填写（有意义方便区分即可），公钥粘贴到的 <code>Key</code> 文本域内，点击 <code>Add SSH key</code> 按钮，这一步就完成了将你的公钥放到了 Github 上进行托管。</p>
<div style="text-align: center;">
  <img src="./images/github-add-ssh-key.png" alt="Add SSH key">
</div>
<h3 id="修改-git-的-remote-url"> 修改 git 的 remote url</h3>
<p>在本地的某个仓库目录内使用命令 <code>git remote -v</code> 查看你当前的 remote url：</p>
<div><pre><code>origin  https://github.com/<span>[</span>your-github-id<span>]</span>/<span>[</span>repo-name<span>]</span>.git <span>(</span>fetch<span>)</span>
origin  https://github.com/<span>[</span>your-github-id<span>]</span>/<span>[</span>repo-name<span>]</span>.git <span>(</span>push<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果是以上的结果那么说明此项目是使用 https 协议进行访问的（如果地址是 git 开头则表示是 git 协议）。</p>
<p>登陆你的 GitHub，在上面可以看到仓库的 ssh 协议相应的 url，复制查询到的 ssh 链接，然后使用命令 <code>git remote set-url</code> 来调整 url：</p>
<div><pre><code><span>git</span> remote set-url origin git@github.com:<span>[</span>your-github-id<span>]</span>/<span>[</span>repo-name<span>]</span>.git
</code></pre>
<div><span>1</span><br></div></div><p>再次使用命令 <code>git remote -v</code> 查看一下，url 是否已经变成了 ssh 地址：</p>
<div><pre><code>origin git@github.com:<span>[</span>your-github-id<span>]</span>/<span>[</span>repo-name<span>]</span>.git <span>(</span>fetch<span>)</span>
origin git@github.com:<span>[</span>your-github-id<span>]</span>/<span>[</span>repo-name<span>]</span>.git <span>(</span>push<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>接下来就可以愉快地使用 git fetch，git pull，git push，不用再输入密码</p>
<h3 id="后记"> 后记</h3>
<p>和 https 拉取方式不同的是，https 方式需要每次提交前都手动输入用户名和密码，ssh 的方式配置完毕后 Git 都会使用你本地的私钥和远程仓库的公钥进行验证是否是一对秘钥，从而简化了操作流程。</p>
<p>但是如果使用的是 Windows 电脑，在使用 ssh 的方式登录过一次后，Windows 操作系统的凭据管理器会记录我们的登录信息，下次操作就不用频繁输入账号密码了。这很方便，所以我一般还是采用 ssh 的方式来操作 Git</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:02:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">常用命令清单</title>
    <id>https://www.snowji.cn/basic-skills/git/common-command-manual/</id>
    <link href="https://www.snowji.cn/basic-skills/git/common-command-manual/"/>
    <updated>2022-08-25T08:02:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="常用命令清单"> 常用命令清单</h1>
<h2 id="本地配置"> 本地配置</h2>
<p>Git 的配置文件为 <code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
<p>下面只整理常用的 Git 配置操作：</p>
<div><pre><code><span># 查看全局配置列表</span>
<span>git</span> config --global -l
<span># 查看局部配置列表</span>
<span>git</span> config --local -l

<span># 查看已设置的全局用户名/邮箱</span>
<span>git</span> config --global --get user.name
<span>git</span> config --global --get user.email

<span># 设置全局用户名/邮箱</span>
<span>git</span> config --global user.name <span>"输入你的用户名"</span>
<span>git</span> config --global user.email <span>"输入你的邮箱"</span>

<span># 设置本地当前工作区仓库用户名/邮箱</span>
<span>git</span> config --local user.name <span>"输入你的用户名"</span>
<span>git</span> config --local user.email <span>"输入你的邮箱"</span>

<span># 删除配置</span>
<span>git</span> config --unset --global user.name
<span>git</span> config --unset --global user.email

<span># 文件权限的变动也会视为改动，可通过以下配置忽略文件权限变动</span>
<span>git</span> config core.fileMode <span>false</span>

<span># 文件大小写设为敏感，git 默认是忽略大小写</span>
<span>git</span> config --global core.ignorecase <span>false</span>

<span># 提交时转换成 unix 风格的换行符，检出时不转换(看各人习惯设置)</span>
<span>git</span> config --global core.autocrlf input
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h2 id="初始化仓库"> 初始化仓库</h2>
<p>在 GitHub 上手动创建一个仓库，一般创建完的仓库会包括一个 <code>README.md</code> 文件。</p>
<p>将远程仓库克隆到本地：</p>
<div><pre><code><span># https 协议</span>
<span>git</span> clone https://github.com/<span>[</span>your-github-id<span>]</span>/<span>[</span>repo-name<span>]</span>.git

<span># 或 SSH 协议(一般不用)</span>
<span>git</span> clone git@github.com:<span>[</span>your-github-id<span>]</span>/<span>[</span>repo-name<span>]</span>.git
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="增加-删除文件"> 增加/删除文件</h2>
<p>以下命令默认在本地克隆下来的仓库目录下执行：</p>
<div><pre><code><span># 添加指定文件到暂存区</span>
<span>git</span> <span>add</span> <span>[</span>file1<span>]</span> <span>[</span>file2<span>]</span> <span>..</span>.

<span># 添加指定目录到暂存区，包括子目录</span>
<span>git</span> <span>add</span> <span>[</span>dir<span>]</span>

<span># 添加当前目录的所有文件到暂存区</span>
<span>git</span> <span>add</span> <span>.</span>

<span># 添加每个变化前，都会要求确认</span>
<span># 对于同一个文件的多处变化，可以实现分次提交</span>
<span>git</span> <span>add</span> -p

<span># 删除工作区文件，并且将这次删除放入暂存区</span>
<span>git</span> <span>rm</span> <span>[</span>file1<span>]</span> <span>[</span>file2<span>]</span> <span>..</span>.

<span># 停止追踪指定文件，但该文件会保留在工作区</span>
<span>git</span> <span>rm</span> --cached <span>[</span>file<span>]</span>

<span># 改名文件，并且将这个改名放入暂存区</span>
<span># 实际上是新建一个相同的文件，删除旧文件，然后将新旧文件都放入暂存区</span>
<span>git</span> <span>mv</span> <span>[</span>file-original<span>]</span> <span>[</span>file-renamed<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h2 id="代码提交"> 代码提交</h2>
<p>这个过程一般用可视化工具进行，因为可以很方便的核对每个文件的改动，不过命令行操作也要了解，如需要修改上一次的 commit 信息，就可以通过命令行快速搞定。</p>
<div><pre><code><span># 提交暂存区到仓库区</span>
<span>git</span> commit -m <span>[</span>message<span>]</span>

<span># 提交暂存区的指定文件到仓库区</span>
<span>git</span> commit <span>[</span>file1<span>]</span> <span>[</span>file2<span>]</span> <span>..</span>. -m <span>[</span>message<span>]</span>

<span># 提交工作区自上次 commit 之后的变化，直接到仓库区</span>
<span>git</span> commit -a

<span># 提交时显示所有 diff 信息</span>
<span>git</span> commit -v

<span># 使用一次新的 commit，替代上一次提交</span>
<span># 如果代码没有任何新变化，则用来改写上一次 commit 的提交信息</span>
<span>git</span> commit --amend -m <span>[</span>message<span>]</span>

<span># 重做上一次 commit，并包括指定文件的新变化</span>
<span>git</span> commit --amend <span>[</span>file1<span>]</span> <span>[</span>file2<span>]</span> <span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id="分支操作"> 分支操作</h2>
<div><pre><code><span># 列出所有本地分支</span>
<span>git</span> branch

<span># 列出所有远程分支</span>
<span>git</span> branch -r

<span># 列出所有本地分支和远程分支</span>
<span>git</span> branch -a

<span># 新建一个分支，但依然停留在当前分支</span>
<span>git</span> branch <span>[</span>branch-name<span>]</span>

<span># 新建一个分支，并切换到该分支</span>
<span>git</span> checkout -b <span>[</span>branch-name<span>]</span>

<span># 新建一个分支，指向指定 commit</span>
<span>git</span> branch <span>[</span>branch-name<span>]</span> <span>[</span>commit-id<span>]</span>

<span># 新建一个分支，与指定的远程分支建立追踪关系</span>
<span>git</span> branch --track <span>[</span>branch-name<span>]</span> <span>[</span>remote-branch-name<span>]</span>

<span># 切换到指定分支，并更新工作区</span>
<span>git</span> checkout <span>[</span>branch-name<span>]</span>

<span># 切换到上一个分支</span>
<span>git</span> checkout -

<span># 建立追踪关系，在现有分支与指定的远程分支之间</span>
<span>git</span> branch --set-upstream <span>[</span>branch-name<span>]</span> <span>[</span>remote-branch-name<span>]</span>

<span># 合并指定分支到当前分支</span>
<span>git</span> merge <span>[</span>branch-name<span>]</span>

<span># 从其它分支上挑选一个指定 commit，合并进当前分支</span>
<span>git</span> cherry-pick <span>[</span>commit-id<span>]</span>

<span># 保留原有作者信息进行合并</span>
<span>git</span> cherry-pick -x <span>[</span>commit-id<span>]</span>

<span># 删除分支</span>
<span>git</span> branch -d <span>[</span>branch-name<span>]</span>

<span># 删除远程分支</span>
<span>git</span> push origin --delete <span>[</span>branch-name<span>]</span>
<span>git</span> branch -dr <span>[</span>remote/branch<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><h2 id="标签操作"> 标签操作</h2>
<div><pre><code><span># 列出所有 tag</span>
<span>git</span> tag

<span># 新建一个 tag 在当前 commit</span>
<span>git</span> tag <span>[</span>tag-name<span>]</span>

<span># 新建一个 tag 在指定 commit</span>
<span>git</span> tag <span>[</span>tag-name<span>]</span> <span>[</span>commit-id<span>]</span>

<span># 删除本地 tag</span>
<span>git</span> tag -d <span>[</span>tag-name<span>]</span>

<span># 删除远程 tag</span>
<span>git</span> push origin :refs/tags/<span>[</span>tag-name<span>]</span>

<span># 查看 tag 信息</span>
<span>git</span> show <span>[</span>tag-name<span>]</span>

<span># 提交指定 tag</span>
<span>git</span> push <span>[</span>remote-repo-name, 默认是 origin<span>]</span> <span>[</span>tag-name<span>]</span>

<span># 提交所有 tag</span>
<span>git</span> push <span>[</span>remote-repo-name, 默认是 origin<span>]</span> --tags

<span># 基于某个 tag 新建一个分支，并切换到这个分支</span>
<span>git</span> checkout -b <span>[</span>branch-name<span>]</span> <span>[</span>tag-name<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h2 id="查看信息"> 查看信息</h2>
<p>查看日志是经常用的命令，而查看文件 diff 的功能我更倾向于用可视化工具，因为比对起来更加直观。</p>
<div><pre><code><span># 显示有变更的文件</span>
<span>git</span> status

<span># 显示当前分支的版本历史</span>
<span>git</span> log

<span># 查看指定作者历史记录</span>
<span>git</span> log --author<span>=</span><span>[</span>author-name<span>]</span>

<span># 只显示合并日志</span>
<span>git</span> log --merges

<span># 以图形查看日志记录，--oneline 可选，表示输出概要日志</span>
<span>git</span> log --graph --oneline

<span># 显示 commit 历史，以及每次 commit 发生变更的文件</span>
<span>git</span> log --stat

<span># 搜索提交历史，根据关键词</span>
<span>git</span> log -S <span>[</span>keyword<span>]</span>

<span># 显示某个 commit 之后的所有变动，每个 commit 占据一行</span>
<span>git</span> log <span>[</span>tag<span>]</span> HEAD --pretty<span>=</span>format:%s

<span># 显示某个 commit 之后的所有变动，其"提交说明"必须符合搜索条件</span>
<span>git</span> log <span>[</span>tag<span>]</span> HEAD --grep feature

<span># 显示某个文件的版本历史，包括文件改名</span>
<span>git</span> log --follow <span>[</span>file<span>]</span>
<span>git</span> whatchanged <span>[</span>file<span>]</span>

<span># 显示指定文件相关的每一次 diff</span>
<span>git</span> log -p <span>[</span>file<span>]</span>

<span># 显示过去 5 次提交</span>
<span>git</span> log -5 --pretty --oneline

<span># 显示所有提交过的用户，按提交次数排序</span>
<span>git</span> shortlog -sn

<span># 显示指定文件是什么人在什么时间修改过</span>
<span>git</span> blame <span>[</span>file<span>]</span>

<span># 显示暂存区和工作区的差异</span>
<span>git</span> <span>diff</span>

<span># 显示暂存区和上一个 commit 的差异</span>
<span>git</span> <span>diff</span> --cached <span>[</span>file<span>]</span>

<span># 显示工作区与当前分支最新 commit 之间的差异</span>
<span>git</span> <span>diff</span> HEAD

<span># 显示两次提交之间的差异</span>
<span>git</span> <span>diff</span> <span>[</span>first-branch<span>]</span><span>..</span>.<span>[</span>second-branch<span>]</span>

<span># 显示今天你写了多少行代码</span>
<span>git</span> <span>diff</span> --shortstat <span>"@{0 day ago}"</span>

<span># 显示某次提交的元数据和内容变化</span>
<span>git</span> show <span>[</span>commit<span>]</span>

<span># 显示某次提交发生变化的文件</span>
<span>git</span> show --name-only <span>[</span>commit<span>]</span>

<span># 显示某次提交时，某个文件的内容</span>
<span>git</span> show <span>[</span>commit<span>]</span>:<span>[</span>filename<span>]</span>

<span># 显示当前分支的最近几次提交</span>
<span>git</span> reflog
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br></div></div><h2 id="远程同步"> 远程同步</h2>
<div><pre><code><span># 下载远程仓库的所有变动</span>
<span>git</span> fetch <span>[</span>remote<span>]</span>

<span># 显示所有远程仓库</span>
<span>git</span> remote -v

<span># 显示某个远程仓库的信息</span>
<span>git</span> remote show <span>[</span>remote<span>]</span>

<span># 增加一个新的远程仓库，并命名</span>
<span># shortname 是在本地仓库中对远程仓库 url 起的别名，一般习惯就设置为 origin 就行了</span>
<span># 别名的作用就是接下来使用涉及远程仓库的命令时，不用再输入很长的仓库链接了，比较省事</span>
<span>git</span> remote <span>add</span> <span>[</span>shortname<span>]</span> <span>[</span>url<span>]</span>

<span># 取回远程仓库的变化，并与本地分支合并</span>
<span>git</span> pull <span>[</span>remote<span>]</span> <span>[</span>branch<span>]</span>

<span># 上传本地指定分支到远程仓库</span>
<span>git</span> push <span>[</span>remote<span>]</span> <span>[</span>branch<span>]</span>

<span># 强行推送当前分支到远程仓库，即使有冲突</span>
<span>git</span> push <span>[</span>remote<span>]</span> --force

<span># 推送所有分支到远程仓库</span>
<span>git</span> push <span>[</span>remote<span>]</span> --all
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h2 id="文件临存"> 文件临存</h2>
<p>有一种场景，在当前分支开发时，临时需要切换到其他分支修改 Bug，但此时又不想提交当前分支上开发到一半的代码（切换分支必须把当前工作内容提交，否则无法切换），这个时候就可以用到 <code>git stash</code> 将代码临时储藏起来。</p>
<p>强烈建议给每个 stash 添加描述信息！！！</p>
<div><pre><code><span># 暂存当前工作区内容</span>
<span>git</span> stash

<span># 暂存时添加描述信息，推荐使用此命令</span>
<span>git</span> stash push -m <span>"更改了 xx"</span>

<span># 暂存包含没有被 Git 追踪的文件</span>
<span>git</span> stash -u

<span># 查看当前暂存列表</span>
<span>git</span> stash list

<span># 恢复修改工作区内容，会从 git stash list 移除掉</span>
<span>git</span> stash pop           <span># 恢复最近一次保存内容到工作区，默认会把暂存区的改动恢复到工作区</span>
<span>git</span> stash pop stash@<span>{</span><span>1</span><span>}</span> <span># 恢复指定 id，通过 git stash list 可查到</span>

<span># 与 pop 命令一致，唯一不同的是不会从 git stash list 移除掉</span>
<span>git</span> stash apply

<span># 清空所有保存(慎用)</span>
<span>git</span> stash <span>clear</span>

<span># 清空指定 stash id，如果 drop 后面不指定 id 则清除最近的一次</span>
<span>git</span> stash drop stash@<span>{</span><span>0</span><span>}</span>
<span>git</span> stash drop  <span># 清除最近一次</span>

<span># 想看 stash 做了什么改动，类似简化版的 git diff</span>
<span>git</span> stash show stash@<span>{</span><span>0</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>关于 stash 的补充：</p>
<div><p>git stash 信息存储到哪了？</p>
<p>项目路径下的 <code>.git</code> 文件中存储着版本管理的所有信息，在文件 <code>.git/log/refs/stash</code> 中可以看到全部的 stash 记录信息</p>
</div>
<div><p>在有新增文件（不是新增代码）时，git stash 并不会储藏新增的文件?</p>
<p>也就是说，没有在 Git 版本控制中的文件，是不能被 <code>git stash</code> 存起来的，此时需要先执行下 <code>git add</code> 将新增文件加到 Git 版本控制中，然后再 <code>git stash</code> 就可以了。</p>
</div>
<h2 id="撤销操作"> 撤销操作</h2>
<div><pre><code><span># 恢复暂存区的指定文件到工作区</span>
<span>git</span> checkout <span>[</span>file<span>]</span>

<span># 恢复某个 commit 的指定文件到暂存区和工作区</span>
<span>git</span> checkout <span>[</span>commit<span>]</span> <span>[</span>file<span>]</span>

<span># 恢复暂存区的所有文件到工作区</span>
<span>git</span> checkout <span>.</span>

<span># 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变</span>
<span>git</span> reset <span>[</span>file<span>]</span>

<span># 重置暂存区与工作区，与上一次 commit 保持一致</span>
<span>git</span> reset --hard

<span># 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变</span>
<span>git</span> reset <span>[</span>commit<span>]</span>

<span># 重置当前分支的 HEAD 为指定 commit，同时重置暂存区和工作区，与指定 commit 一致</span>
<span>git</span> reset --hard <span>[</span>commit<span>]</span>

<span># 重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变</span>
<span>git</span> reset --keep <span>[</span>commit<span>]</span>

<span># 新建一个 commit，用来撤销指定 commit</span>
<span># 后者的所有变化都将被前者抵消，并且应用到当前分支</span>
<span>git</span> revert <span>[</span>commit<span>]</span>

<span># 暂时将未提交的变化移除，稍后再移入</span>
<span>git</span> stash
<span>git</span> stash pop
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:02:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">如何修改历史 commits 中的用户名和邮箱</title>
    <id>https://www.snowji.cn/basic-skills/git/solution-to-change-name-and-email-in-history-commits/</id>
    <link href="https://www.snowji.cn/basic-skills/git/solution-to-change-name-and-email-in-history-commits/"/>
    <updated>2022-08-25T08:02:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="如何修改历史-commits-中的用户名和邮箱"> 如何修改历史 commits 中的用户名和邮箱</h1>
<h2 id="问题描述"> 问题描述</h2>
<p>出于某些需求，想要：</p>
<ul>
<li>修改某个仓库历史 commit 的用户 name 和 email 信息</li>
<li>将历史提交记录中的指定 name/email 修改为新的 name/email</li>
</ul>
<h2 id="解决方案"> 解决方案</h2>
<p>主要分为四个步骤：</p>
<ul>
<li>确认本地全局邮箱/用户名</li>
<li>查看仓库的历史提交信息</li>
<li>批量修改历史记录中的信息</li>
<li>将修改结果推送到远程</li>
</ul>
<h3 id="确认本地全局邮箱-用户名"> 确认本地全局邮箱/用户名</h3>
<p>使用下面两个命令查看 Git 在本地的全局邮箱和用户名：</p>
<div><pre><code><span>git</span> config user.name
<span>git</span> config user.email
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果需要修改 Git 在本地的全局邮箱和用户名，执行下面的命令：</p>
<div><pre><code><span>git</span> config --global user.name <span>"输入你的用户名"</span>
<span>git</span> config --global user.email <span>"输入你的邮箱"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>现在我们已经设置好了本地 Git 的 <code>user.name</code> 和 <code>user.email</code> 信息。</p>
<h3 id="查看仓库的历史提交信息"> 查看仓库的历史提交信息</h3>
<p>进入目标仓库目录，打开 git bash 界面，执行以下命令查看历史提交信息（重点关注 Author）：</p>
<div><pre><code><span>git</span> log
</code></pre>
<div><span>1</span><br></div></div><h3 id="批量修改历史记录中的信息"> 批量修改历史记录中的信息</h3>
<p>打开一个文本编辑器，粘贴下面代码。</p>
<p>主要需要把 <code>OLD_EMAIL</code>，<code>CORRECT_NAME</code>，<code>CORRECT_EMAIL</code> 改成自己的新旧邮箱和新用户名。</p>
<div><pre><code><span>git</span> filter-branch -f --env-filter <span>'
OLD_EMAIL="原来的邮箱"
CORRECT_NAME="现在的名字"
CORRECT_EMAIL="现在的邮箱"
if [ "$GIT_COMMITTER_EMAIL" = "$OLD_EMAIL" ]
then
    export GIT_COMMITTER_NAME="$CORRECT_NAME"
    export GIT_COMMITTER_EMAIL="$CORRECT_EMAIL"
fi
if [ "$GIT_AUTHOR_EMAIL" = "$OLD_EMAIL" ]
then
    export GIT_AUTHOR_NAME="$CORRECT_NAME"
    export GIT_AUTHOR_EMAIL="$CORRECT_EMAIL"
fi
'</span> --tag-name-filter <span>cat</span> -- --branches --tags
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>回到 git bash 界面，复制粘贴上面的代码并按回车执行。</p>
<p>如果 commit 记录比较多的话执行的时间会比较长。</p>
<p>等待执行完成后，再查看 <code>git log</code> 可以看到已经修改成功。</p>
<div><p>注意</p>
<p>如果上面的批量修改命令执行失败的话，执行一下这段命令：</p>
<div><pre><code><span>git</span> filter-branch -f --index-filter <span>'git rm --cached --ignore-unmatch Rakefile'</span> HEAD
</code></pre>
<div><span>1</span><br></div></div><p>再次复制粘贴批量修改的代码并按回车执行</p>
</div>
<h3 id="将修改结果推送到远程"> 将修改结果推送到远程</h3>
<p>这时候虽然本地修改成功了，但是你还没有推送到远程</p>
<p>所以再执行一下命令：</p>
<div><pre><code><span>git</span> push origin --force --all
</code></pre>
<div><span>1</span><br></div></div><p>去看一下 Github 你就会发现之前的提交记录中，name 和 email 信息都更新了</p>
<h2 id="linux-mac下可以写个脚本"> Linux/Mac下可以写个脚本</h2>
<p>在项目根目录下创建 <code>git-email.sh</code>，写入下面这段代码：</p>
<div><pre><code><span>#!/bin/sh</span>

<span>git</span> filter-branch --env-filter <span>'

OLD_EMAIL="原来的邮箱"
CORRECT_NAME="现在的名字"
CORRECT_EMAIL="现在的邮箱"

if [ "$GIT_COMMITTER_EMAIL" = "$OLD_EMAIL" ]
then
    export GIT_COMMITTER_NAME="$CORRECT_NAME"
    export GIT_COMMITTER_EMAIL="$CORRECT_EMAIL"
fi
if [ "$GIT_AUTHOR_EMAIL" = "$OLD_EMAIL" ]
then
    export GIT_AUTHOR_NAME="$CORRECT_NAME"
    export GIT_AUTHOR_EMAIL="$CORRECT_EMAIL"
fi
'</span> --tag-name-filter <span>cat</span> -- --branches --tags
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>然后需要赋予执行权限：</p>
<div><pre><code><span>chmod</span> +x git-email.sh
</code></pre>
<div><span>1</span><br></div></div><p>执行一下这个 <code>.sh</code> 文件：</p>
<div><pre><code>./git-email.sh
</code></pre>
<div><span>1</span><br></div></div><p><code>git log</code> 检查修改成功后，就可以推送到远程仓库了</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:02:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">git pull 报错</title>
    <id>https://www.snowji.cn/basic-skills/git/problems/</id>
    <link href="https://www.snowji.cn/basic-skills/git/problems/"/>
    <updated>2022-08-25T08:02:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="git-pull-报错"> git pull 报错</h1>
<p><strong>问题</strong>：git pull 时报错</p>
<div><pre><code>error: Your local changes to the following files would be overwritten by merge:
        docs/python/继承.md
Please commit your changes or stash them before you merge.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>原因</strong>：本地修改已经使用 add 添加到缓存区了</p>
<p><strong>解决方法：</strong></p>
<ul>
<li>
<p>不保存当前修改内容</p>
<div><pre><code>1. 先回退到上一次提交的版本
git resert --hard
2. 重新 git pull
git pull
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
<li>
<p>需要保留当前的修改</p>
<div><pre><code>1. 先把本地的修改进行快照
git stash
2. 重新拉取
git pull
3. 将快照还原
git stash pop
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
</ul>
<p><strong>注意：</strong> 没有在 git 版本控制中的文件，是不能被 git stash 存起来的</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:02:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">clone 速度过慢</title>
    <id>https://www.snowji.cn/basic-skills/git/solution-to-clone-too-slow/</id>
    <link href="https://www.snowji.cn/basic-skills/git/solution-to-clone-too-slow/"/>
    <updated>2022-08-25T08:02:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="clone-速度过慢"> clone 速度过慢</h1>
<h2 id="问题描述"> 问题描述</h2>
<p>想从 GitHub 上面 clone 项目，很多情况下会慢的离谱，等待好久后报错：</p>
<div style="color: #FF6827;">
fatal: early EOF  <br>
fatal: the remote end hung up unexpectedly  <br>
fatal: index-pack failed  <br>
error: RPC failed; curl 18 transfer closed with outstanding read data remaining
</div>
<p>网上有一些方法：复制项目到码云（比较麻烦），修改 hosts 文件（以前有用），调整 Git 的传输缓存（仅用于解决文件过大导致的下载慢问题，不能解决网络本身带来的问题）</p>
<p>最终方案还得是给 Git 设置代理模式</p>
<h2 id="解决方案"> 解决方案</h2>
<p>需要用到几个命令，注意下面的端口 <code>1080</code> 和 <code>1081</code> 都是我自行配置的，每个人情况可能不一样</p>
<ul>
<li>1080：SOCKS 端口</li>
<li>1081：HTTP 端口（某些软件默认的 SOCKS + 1）</li>
</ul>
<h3 id="设置代理"> 设置代理</h3>
<div><p>小贴士</p>
<p>我推荐使用专用代理里中 http 代理，这是不容易有负面影响且切实有效的，因为 GitHub 在某次更新后，socks 代理有时候会被拒绝。<br>
但其它代理模式的命令还是要整理一下的，万一需要用到呢~</p>
</div>
<p>全局代理：使用后作用于全局环境，太极端，一般不推荐</p>
<div><pre><code><span># 使用 http 协议(推荐)</span>
<span>git</span> config --global http.proxy <span>127.0</span>.0.1:1081
<span># 或使用 socks 协议(不推荐，忘记会有什么坑了)</span>
<span>git</span> config --global http.proxy socks5://127.0.0.1:1080
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>局部代理：在 github clone 的仓库内执行，不是很方便，一般不推荐</p>
<div><pre><code><span># 使用 http 协议(推荐)</span>
<span>git</span> config --local http.proxy <span>127.0</span>.0.1:1081
<span># 或使用 socks 协议(不推荐，忘记会有什么坑了)</span>
<span>git</span> config --local http.proxy socks5://127.0.0.1:1080
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>专用代理：只对 github 进行代理，对国内的仓库不影响，推荐！</p>
<div><pre><code><span># 使用 http 协议(推荐)</span>
<span>git</span> config --global http.https://github.com.proxy <span>127.0</span>.0.1:1081
<span># 或使用 socks 协议(不推荐，忘记会有什么坑了)</span>
<span>git</span> config --global http.https://github.com.proxy socks5://127.0.0.1:1080
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="查询目前是否使用了代理"> 查询目前是否使用了代理</h3>
<p>查询当前的 Git 环境是否使用了代理</p>
<p>查询全局代理：</p>
<div><pre><code><span>git</span> config --global http.proxy
</code></pre>
<div><span>1</span><br></div></div><p>查询局部代理：</p>
<div><pre><code><span>git</span> config --local http.proxy
</code></pre>
<div><span>1</span><br></div></div><p>查询专用代理（对 github 进行的代理）：</p>
<div><pre><code><span>git</span> config --global http.https://github.com.proxy
</code></pre>
<div><span>1</span><br></div></div><h3 id="取消代理"> 取消代理</h3>
<p>取消当前 Git 环境使用的代理，恢复直连模式</p>
<p>取消全局代理：</p>
<div><pre><code><span>git</span> config --global --unset http.proxy
</code></pre>
<div><span>1</span><br></div></div><p>取消局部代理：</p>
<div><pre><code><span>git</span> config --local --unset http.proxy
</code></pre>
<div><span>1</span><br></div></div><p>取消专用代理（对 github 进行的代理）：</p>
<div><pre><code><span>git</span> config --global --unset http.https://github.com.proxy
</code></pre>
<div><span>1</span><br></div></div><h2 id="补充-关于调整-git-的传输缓存"> 补充：关于调整 Git 的传输缓存</h2>
<p>网上很多文章多 clone 过慢或 push 时因为文件过大导致报错时，可以调整 Git 的传输缓存：</p>
<div><pre><code><span># Git 默认设置 http post 的缓存为 1M，很多文章建议调大一点，例如 500M。</span>
<span>git</span> config --global http.postBuffer <span>524288000</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>但我发现这非但解决不了本文提到的问题，而且即使真遇到大文件的情况，官方也并不推荐这么做，详见：</p>
<p>《<a href="https://docs.microsoft.com/en-us/azure/devops/repos/git/rpc-failures-http-postbuffer?view=azure-devops" target="_blank" rel="noopener noreferrer">Git: Stop changing http.postBuffer...</a>》</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:02:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">修改 commit 信息</title>
    <id>https://www.snowji.cn/basic-skills/git/solution-to-commit-info-mistake/</id>
    <link href="https://www.snowji.cn/basic-skills/git/solution-to-commit-info-mistake/"/>
    <updated>2022-08-25T08:02:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="修改-commit-信息"> 修改 commit 信息</h1>
<h2 id="问题描述"> 问题描述</h2>
<p>刚刚做了一次提交，发现 <code>commit info</code> 填写错了，想要修改</p>
<h2 id="解决方案"> 解决方案</h2>
<p>分为两种情况，未推送到远程仓库和已推送到远程仓库</p>
<h3 id="情况一-已-commit-未-push"> 情况一：已 commit 未 push</h3>
<p>已经执行 <code>commit</code>，但还没有 <code>push</code>，要想更改 commit 信息（修改最近一次提交）</p>
<div><pre><code><span>git</span> commit --amend
</code></pre>
<div><span>1</span><br></div></div><p>执行上述命令后，进入注释页面进行修改，修改后保存退出</p>
<p>然后使用 <code>git log --pretty=oneline</code> 查看内容，可以发现已经成功修改了</p>
<p><strong>需要注意的是此项命令会修改提交时的 <code>commit-id</code>，即会覆盖原本的提交，需要谨慎操作</strong></p>
<h3 id="情况二-已-commit-已-push"> 情况二：已 commit 已 push</h3>
<p>已经执行 <code>commit</code>，且已经 <code>push</code> 的提交（修改最近一次提交）</p>
<div><pre><code><span>git</span> commit --amend
</code></pre>
<div><span>1</span><br></div></div><p>执行上述命令后，进入注释页面进行修改，修改后保存退出</p>
<p>然后执行强制推送命令：</p>
<div><pre><code><span>git</span> push --force-with-lease origin master
</code></pre>
<div><span>1</span><br></div></div><p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:02:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">git rebase 的两种用法</title>
    <id>https://www.snowji.cn/basic-skills/git/git-rebase/</id>
    <link href="https://www.snowji.cn/basic-skills/git/git-rebase/"/>
    <updated>2022-08-25T08:02:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="git-rebase-的两种用法"> git rebase 的两种用法</h1>
<h2 id="前言"> 前言</h2>
<p>rebase 在 Git 中是一个非常有魅力的命令，使用得当会极大提高自己的工作效率；相反，如果乱用会给团队中其他人带来麻烦</p>
<p>它的作用简要概括为：可以对某一段线性提交历史进行编辑、删除、复制、粘贴；因此，合理使用 rebase 命令可以使我们的提交历史干净、简洁</p>
<h2 id="用法一-合并当前分支的多个-commit-记录"> 用法一: 合并当前分支的多个 commit 记录</h2>
<p>有时候会遇到对同一处代码进行多次处理的场景。这会导致如下提交记录：</p>
<div><pre><code>$ <span>git</span> log --pretty<span>=</span>format:<span>'%h: %s'</span>
ad3593c: feat: modify c
21511a4: feat: modify b
a7b8f93: feat: modify b
89ab26f: feat: modify b
5f5d89a: feat: modify a
7092a92: Initial commit
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>其实，中间的对 b 的 3 次提交 完全可以合并成一次 commit，这个时候 rebase 就很有用了</p>
<h3 id="_1-执行-rebase-i-命令"> 1. 执行 rebase -i 命令</h3>
<p>找到想要合并的 commit，使用 rebase -i：</p>
<div><pre><code><span>git</span> rebase -i 5f5d89a
</code></pre>
<div><span>1</span><br></div></div><p><strong>注意</strong>：</p>
<ul>
<li><code>git rebase -i [startPoint] [endPoint]</code></li>
<li>前开后闭区间，这里的 <code>[startPoint]</code> 指目标 commit 的前一个 commit（即上述示例中的 <code>5f5d89a: feat: modify a</code>)。 因为三个 commit 肯定要基于上一个 commit 来合并成新的 commit</li>
<li><strong>谨慎使用 <code>[endPoint]</code></strong>，省略即默认表示从起始 commit 一直到最后一个，但是一旦填写了，则表示 <code>[endPoint]</code> 后面的 commit 全部不要</li>
</ul>
<h3 id="_2-进入-interact-交互界面"> 2. 进入 Interact 交互界面</h3>
<p>终端会进入选择交互界面，让你进行变基选择操作：</p>
<div style="text-align: center;">
  <img src="./images/git-rebase-interact.png" alt="git rebase 交互界面">
</div>
<p><strong>说明</strong>：</p>
<ul>
<li>最上面三行，就是刚刚选中的三个 commit，按时间先后顺序依次往下排序(<strong>和 git log 的展示顺序是反的</strong>，查看的时候需要注意)</li>
<li>前面的三个 pick 就是下面 Commands 展示的一系列命令中的第一个 p，也就是使用 commit
<ul>
<li>pick：保留该 commit（缩写：p）</li>
<li>reword：保留该 commit，但我需要修改该 commit 的注释（缩写：r）</li>
<li>edit：保留该 commit，但我要停下来修改该提交（不仅仅修改注释）（缩写：e）</li>
<li>squash：将该 commit 和前一个 commit 合并（缩写：s）</li>
<li>fixup：将该 commit 和前一个 commit 合并，但我不要保留该提交的注释信息（缩写：f）</li>
<li>exec：执行 shell 命令（缩写：x）</li>
<li>drop：丢弃该 commit（缩写：d）</li>
</ul>
</li>
</ul>
<h3 id="_3-使用-s-命令合并-commit"> 3. 使用 s 命令合并 commit</h3>
<p>使用 s 命令，合并到上一个commit（编辑时就跟操作 vim 一样）：</p>
<ul>
<li>按 <code>i</code> 进入操作，将<strong>第二、三个 commit 的 pick 改成 s</strong></li>
<li>按 <code>Esc</code> 退出操作</li>
<li>输入 <code>:wq</code> 保存并退出</li>
</ul>
<div style="text-align: center;">
  <img src="./images/git-rebase-interact-squash.png" alt="使用 s 命令合并 commit">
</div>
<h3 id="_4-修改-commit-记录"> 4. 修改 commit 记录</h3>
<p>接下来会弹出第二个页面，分别展示三个 commit 的提交信息：</p>
<div style="text-align: center;">
  <img src="./images/git-rebase-interact-commit-list.png" alt="相关的 commit 信息列表">
</div>
<p>在这次的示例中，三个 commit 信息都是一样的。选用第一个的提交信息（也可以编辑下），将其余的全部注释掉，重复上述步骤，保存退出即可</p>
<div style="text-align: center;">
  <img src="./images/git-rebase-interact-modify-commit-info.png" alt="编辑提交信息">
</div>
<h3 id="_5-查看最新合并情况"> 5. 查看最新合并情况</h3>
<p>查看最新合并情况，会发现原来三个一样的提交现在合并成了一个新的 commit</p>
<div style="text-align: center;">
  <img src="./images/git-rebase-result.png" alt="commit 合并前后对比">
</div>
<h2 id="用法二-避免出现分叉合并"> 用法二: 避免出现分叉合并</h2>
<p>接下来，将通过实际示例和场景，来分析 rebase 是如何解决分叉合并的。在此之前，我先做如下规定：</p>
<ul>
<li>有两个分支: develop（主分支），feature（feature 分支）</li>
<li>新需求按时间顺序叫 <code>a</code> 、<code>b</code>……等(a 需求最早，b 其次，以此类推)</li>
<li>原 commit <code>a</code> 变基之后（hashId 改变）叫 <code>a'</code></li>
</ul>
<h3 id="场景-1-合并时-最舒服的情况"> 场景 1：合并时，最舒服的情况</h3>
<p>这种场景是基于 develop 分支没有新的提交，feature 分支有新的提交后，把 feature 分支的改动合并到 develop 分支</p>
<div style="text-align: center;">
  <svg id="SvgjsSvg1006" width="298" height="146.75" xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.com/svgjs"><defs id="SvgjsDefs1007"><marker id="SvgjsMarker1030" markerWidth="14" markerHeight="10" refX="10" refY="5" viewBox="0 0 14 10" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1031" d="M0,0 L14,5 L0,10 L0,0" fill="#f44336" stroke="#f44336" stroke-width="1"></path></marker><marker id="SvgjsMarker1040" markerWidth="14" markerHeight="10" refX="10" refY="5" viewBox="0 0 14 10" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1041" d="M0,0 L14,5 L0,10 L0,0" fill="#f44336" stroke="#f44336" stroke-width="1"></path></marker><marker id="SvgjsMarker1044" markerWidth="14" markerHeight="10" refX="10" refY="5" viewBox="0 0 14 10" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1045" d="M0,0 L14,5 L0,10 L0,0" fill="#f44336" stroke="#f44336" stroke-width="1"></path></marker></defs><g id="SvgjsG1008" transform="translate(25,26.25)"><path id="SvgjsPath1009" d="M 0 0L 82 0L 82 27.5L 0 27.5Z" stroke="none" fill="none"></path><g id="SvgjsG1010"><text id="SvgjsText1011" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="82px" fill="#f44336" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="1.75" transform="rotate(0)"><tspan id="SvgjsTspan1012" dy="20" x="41"><tspan id="SvgjsTspan1013" style="text-decoration:;">develop</tspan></tspan></text></g></g><g id="SvgjsG1014" transform="translate(25,92.75)"><path id="SvgjsPath1015" d="M 0 0L 82 0L 82 28.75L 0 28.75Z" stroke="none" fill="none"></path><g id="SvgjsG1016"><text id="SvgjsText1017" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="82px" fill="#f44336" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="2.375" transform="rotate(0)"><tspan id="SvgjsTspan1018" dy="20" x="41"><tspan id="SvgjsTspan1019" style="text-decoration:;">feature</tspan></tspan></text></g></g><g id="SvgjsG1020"><path id="SvgjsPath1021" d="M66 54.75L66 73.25L66 73.25L66 91.75" stroke="#f44336" stroke-width="2" fill="none"></path></g><g id="SvgjsG1022" transform="translate(180,25)"><path id="SvgjsPath1023" d="M 0 0L 35 0L 35 30L 0 30Z" stroke="none" fill="none"></path><g id="SvgjsG1024"><text id="SvgjsText1025" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="35px" fill="#f44336" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="3" transform="rotate(0)"><tspan id="SvgjsTspan1026" dy="20" x="17.5"><tspan id="SvgjsTspan1027" style="text-decoration:;">a</tspan></tspan></text></g></g><g id="SvgjsG1028"><path id="SvgjsPath1029" d="M108 40L143.5 40L143.5 40L176.39999999999998 40" stroke="#f44336" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1030)"></path></g><g id="SvgjsG1032" transform="translate(160,94.875)"><path id="SvgjsPath1033" d="M 0 0L 32 0L 32 24.5L 0 24.5Z" stroke="none" fill="none"></path><g id="SvgjsG1034"><text id="SvgjsText1035" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="32px" fill="#f44336" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="0.25" transform="rotate(0)"><tspan id="SvgjsTspan1036" dy="20" x="16"><tspan id="SvgjsTspan1037" style="text-decoration:;">a</tspan></tspan></text></g></g><g id="SvgjsG1038"><path id="SvgjsPath1039" d="M108 107.125L133.5 107.125L133.5 107.125L156.39999999999998 107.125" stroke="#f44336" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1040)"></path></g><g id="SvgjsG1042"><path id="SvgjsPath1043" d="M176.4745933782927 93.99479483909673L195.7914638381464 58.168738579251766" stroke="#f44336" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1044)"></path></g><g id="SvgjsG1046" transform="translate(153,60.5)"><path id="SvgjsPath1047" d="M 0 0L 120 0L 120 40L 0 40Z" stroke="none" fill="none"></path><g id="SvgjsG1048"><text id="SvgjsText1049" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="120px" fill="#f44336" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="8" transform="rotate(0)"><tspan id="SvgjsTspan1050" dy="20" x="60"><tspan id="SvgjsTspan1051" style="text-decoration:;">合并</tspan></tspan></text></g></g></svg>
</div>
<p>此时的合并有两点好处：</p>
<ul>
<li>没有冲突</li>
<li>没有多余的 commit 提交</li>
</ul>
<p>其实这种情况下，rebase 和 merge 的效果是一样的。而后面所有的 rebase 都是奔着这个目标来的</p>
<h3 id="场景-2-各分支都有自己新的-commit"> 场景 2：各分支都有自己新的 commit</h3>
<p>develop 新增需求 a: &quot;feat: a&quot;</p>
<div style="text-align: center;">
  <img src="./images/develop-branch-feat-a.png" alt="develop 分支的 log">
</div>
<p>feature  新增需求 b: &quot;feat: b&quot;</p>
<div style="text-align: center;">
  <img src="./images/feature-branch-feat-b.png" alt="feature 分支的 log">
</div>
<h4 id="_1-develop-merge-feature"> 1）develop merge feature</h4>
<p>develop 直接 merge feature：切换到 develop 分支执行命令 <code>git merge feature</code></p>
<div style="text-align: center;">
  <img src="./images/develop-merge-feature-directly.png" alt="develop 直接 merge feature">
</div>
<p>会出现以下结果：</p>
<ul>
<li>会保留所有的 commit（hashId 不变）</li>
<li>按提交顺序排序</li>
<li>产生新的 commit 点（Merge branch 'xxx' into develop）</li>
</ul>
<div style="text-align: center;">
  <svg id="SvgjsSvg1052" width="611" height="146.75" xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.com/svgjs"><defs id="SvgjsDefs1053"><marker id="SvgjsMarker1076" markerWidth="14" markerHeight="10" refX="10" refY="5" viewBox="0 0 14 10" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1077" d="M0,0 L14,5 L0,10 L0,0" fill="#f44336" stroke="#f44336" stroke-width="1"></path></marker><marker id="SvgjsMarker1086" markerWidth="14" markerHeight="10" refX="10" refY="5" viewBox="0 0 14 10" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1087" d="M0,0 L14,5 L0,10 L0,0" fill="#f44336" stroke="#f44336" stroke-width="1"></path></marker><marker id="SvgjsMarker1096" markerWidth="14" markerHeight="10" refX="10" refY="5" viewBox="0 0 14 10" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1097" d="M0,0 L14,5 L0,10 L0,0" fill="#f44336" stroke="#f44336" stroke-width="1"></path></marker><marker id="SvgjsMarker1100" markerWidth="14" markerHeight="10" refX="10" refY="5" viewBox="0 0 14 10" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1101" d="M0,0 L14,5 L0,10 L0,0" fill="#f44336" stroke="#f44336" stroke-width="1"></path></marker><marker id="SvgjsMarker1110" markerWidth="14" markerHeight="10" refX="10" refY="5" viewBox="0 0 14 10" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1111" d="M0,0 L14,5 L0,10 L0,0" fill="#f44336" stroke="#f44336" stroke-width="1"></path></marker></defs><g id="SvgjsG1054" transform="translate(25,26.25)"><path id="SvgjsPath1055" d="M 0 0L 82 0L 82 27.5L 0 27.5Z" stroke="none" fill="none"></path><g id="SvgjsG1056"><text id="SvgjsText1057" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="82px" fill="#f44336" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="1.75" transform="rotate(0)"><tspan id="SvgjsTspan1058" dy="20" x="41"><tspan id="SvgjsTspan1059" style="text-decoration:;">develop</tspan></tspan></text></g></g><g id="SvgjsG1060" transform="translate(25,92.75)"><path id="SvgjsPath1061" d="M 0 0L 82 0L 82 28.75L 0 28.75Z" stroke="none" fill="none"></path><g id="SvgjsG1062"><text id="SvgjsText1063" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="82px" fill="#f44336" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="2.375" transform="rotate(0)"><tspan id="SvgjsTspan1064" dy="20" x="41"><tspan id="SvgjsTspan1065" style="text-decoration:;">feature</tspan></tspan></text></g></g><g id="SvgjsG1066"><path id="SvgjsPath1067" d="M66 54.75L66 73.25L66 73.25L66 91.75" stroke="#f44336" stroke-width="2" fill="none"></path></g><g id="SvgjsG1068" transform="translate(160,25)"><path id="SvgjsPath1069" d="M 0 0L 35 0L 35 30L 0 30Z" stroke="none" fill="none"></path><g id="SvgjsG1070"><text id="SvgjsText1071" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="35px" fill="#f44336" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="3" transform="rotate(0)"><tspan id="SvgjsTspan1072" dy="20" x="17.5"><tspan id="SvgjsTspan1073" style="text-decoration:;">a</tspan></tspan></text></g></g><g id="SvgjsG1074"><path id="SvgjsPath1075" d="M108 40L133.5 40L133.5 40L156.39999999999998 40" stroke="#f44336" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1076)"></path></g><g id="SvgjsG1078" transform="translate(160,94.875)"><path id="SvgjsPath1079" d="M 0 0L 32 0L 32 24.5L 0 24.5Z" stroke="none" fill="none"></path><g id="SvgjsG1080"><text id="SvgjsText1081" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="32px" fill="#f44336" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="0.25" transform="rotate(0)"><tspan id="SvgjsTspan1082" dy="20" x="16"><tspan id="SvgjsTspan1083" style="text-decoration:;">b</tspan></tspan></text></g></g><g id="SvgjsG1084"><path id="SvgjsPath1085" d="M108 107.125L133.5 107.125L133.5 107.125L156.39999999999998 107.125" stroke="#f44336" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1086)"></path></g><g id="SvgjsG1088" transform="translate(240,25)"><path id="SvgjsPath1089" d="M 0 0L 35 0L 35 30L 0 30Z" stroke="none" fill="none"></path><g id="SvgjsG1090"><text id="SvgjsText1091" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="35px" fill="#f44336" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="3" transform="rotate(0)"><tspan id="SvgjsTspan1092" dy="20" x="17.5"><tspan id="SvgjsTspan1093" style="text-decoration:;">b</tspan></tspan></text></g></g><g id="SvgjsG1094"><path id="SvgjsPath1095" d="M196 40L236.39999999999998 40" stroke="#f44336" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1096)"></path></g><g id="SvgjsG1098"><path id="SvgjsPath1099" d="M192.7824687641022 106.50231016291866L254.68311244923206 57.24168341349278" stroke="#f44336" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1100)"></path></g><g id="SvgjsG1102" transform="translate(325,26.25)"><path id="SvgjsPath1103" d="M 0 0L 261 0L 261 27.5L 0 27.5Z" stroke="none" fill="none"></path><g id="SvgjsG1104"><text id="SvgjsText1105" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="261px" fill="#f44336" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="1.75" transform="rotate(0)"><tspan id="SvgjsTspan1106" dy="20" x="130.5"><tspan id="SvgjsTspan1107" style="text-decoration:;">Merge branch 'xxx' into develop</tspan></tspan></text></g></g><g id="SvgjsG1108"><path id="SvgjsPath1109" d="M276 40L321.4 40" stroke="#f44336" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1110)"></path></g></svg>
</div>
<h4 id="_2-develop-rebase-feature"> 2）develop rebase feature</h4>
<p>如果在 develop 分支没有直接执行 merge 命令，而是执行的 rebase 命令 <code>git rebase -i feature</code></p>
<div style="text-align: center;">
  <img src="./images/develop-rebase-feature.png" alt="develop rebase feature">
</div>
<p>会出现以下结果：</p>
<ul>
<li>develop 分支的 a 会被排在合进来的 feature 分支 b 的上面（尽管 a 是先完成的）</li>
<li>develop 的原 commit a 被移除，产生了新的 commit a'（hashId 已变）</li>
<li>从 feature 合进来的 b 不变（不会对合进来的 commit 进行变基）</li>
</ul>
<div style="text-align: center;">
  <svg id="SvgjsSvg1112" width="385" height="176.75" xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.com/svgjs"><defs id="SvgjsDefs1113"><marker id="SvgjsMarker1140" markerWidth="14" markerHeight="10" refX="10" refY="5" viewBox="0 0 14 10" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1141" d="M0,0 L14,5 L0,10 L0,0" fill="#f44336" stroke="#f44336" stroke-width="1"></path></marker><marker id="SvgjsMarker1150" markerWidth="14" markerHeight="10" refX="10" refY="5" viewBox="0 0 14 10" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1151" d="M0,0 L14,5 L0,10 L0,0" fill="#f44336" stroke="#f44336" stroke-width="1"></path></marker><marker id="SvgjsMarker1160" markerWidth="14" markerHeight="10" refX="10" refY="5" viewBox="0 0 14 10" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1161" d="M0,0 L14,5 L0,10 L0,0" fill="#f44336" stroke="#f44336" stroke-width="1"></path></marker><marker id="SvgjsMarker1170" markerWidth="14" markerHeight="10" refX="10" refY="5" viewBox="0 0 14 10" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1171" d="M0,0 L14,5 L0,10 L0,0" fill="#f44336" stroke="#f44336" stroke-width="1"></path></marker><marker id="SvgjsMarker1174" markerWidth="14" markerHeight="10" refX="10" refY="5" viewBox="0 0 14 10" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1175" d="M0,0 L14,5 L0,10 L0,0" fill="#f44336" stroke="#f44336" stroke-width="1"></path></marker></defs><g id="SvgjsG1114" transform="translate(165,56.5)"><path id="SvgjsPath1115" d="M 0 13.5C 0 -4.5 27 -4.5 27 13.5C 27 31.5 0 31.5 0 13.5Z" stroke="rgba(244,67,54,1)" stroke-width="2" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1116"><text id="SvgjsText1117" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="7px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="3.875" transform="rotate(0)"></text></g></g><g id="SvgjsG1118" transform="translate(158.5,55)"><path id="SvgjsPath1119" d="M 0 0L 35 0L 35 30L 0 30Z" stroke="none" fill="none"></path><g id="SvgjsG1120"><text id="SvgjsText1121" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="35px" fill="#f44336" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="3" transform="rotate(0)"><tspan id="SvgjsTspan1122" dy="20" x="17.5"><tspan id="SvgjsTspan1123" style="text-decoration:;">a</tspan></tspan></text></g></g><g id="SvgjsG1124" transform="translate(25,56.25)"><path id="SvgjsPath1125" d="M 0 0L 82 0L 82 27.5L 0 27.5Z" stroke="none" fill="none"></path><g id="SvgjsG1126"><text id="SvgjsText1127" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="82px" fill="#f44336" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="1.75" transform="rotate(0)"><tspan id="SvgjsTspan1128" dy="20" x="41"><tspan id="SvgjsTspan1129" style="text-decoration:;">develop</tspan></tspan></text></g></g><g id="SvgjsG1130" transform="translate(25,122.75)"><path id="SvgjsPath1131" d="M 0 0L 82 0L 82 28.75L 0 28.75Z" stroke="none" fill="none"></path><g id="SvgjsG1132"><text id="SvgjsText1133" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="82px" fill="#f44336" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="2.375" transform="rotate(0)"><tspan id="SvgjsTspan1134" dy="20" x="41"><tspan id="SvgjsTspan1135" style="text-decoration:;">feature</tspan></tspan></text></g></g><g id="SvgjsG1136"><path id="SvgjsPath1137" d="M66 84.75L66 103.25L66 103.25L66 121.75" stroke="#f44336" stroke-width="2" fill="none"></path></g><g id="SvgjsG1138"><path id="SvgjsPath1139" d="M108 70L132.75 70L132.75 70L154.89999999999998 70" stroke="#f44336" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1140)"></path></g><g id="SvgjsG1142" transform="translate(160,124.875)"><path id="SvgjsPath1143" d="M 0 0L 32 0L 32 24.5L 0 24.5Z" stroke="none" fill="none"></path><g id="SvgjsG1144"><text id="SvgjsText1145" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="32px" fill="#f44336" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="0.25" transform="rotate(0)"><tspan id="SvgjsTspan1146" dy="20" x="16"><tspan id="SvgjsTspan1147" style="text-decoration:;">b</tspan></tspan></text></g></g><g id="SvgjsG1148"><path id="SvgjsPath1149" d="M108 137.125L133.5 137.125L133.5 137.125L156.39999999999998 137.125" stroke="#f44336" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1150)"></path></g><g id="SvgjsG1152" transform="translate(240,55)"><path id="SvgjsPath1153" d="M 0 0L 35 0L 35 30L 0 30Z" stroke="none" fill="none"></path><g id="SvgjsG1154"><text id="SvgjsText1155" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="35px" fill="#f44336" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="3" transform="rotate(0)"><tspan id="SvgjsTspan1156" dy="20" x="17.5"><tspan id="SvgjsTspan1157" style="text-decoration:;">b</tspan></tspan></text></g></g><g id="SvgjsG1158"><path id="SvgjsPath1159" d="M276 70L325 70" stroke="#f44336" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1160)"></path></g><g id="SvgjsG1162" transform="translate(325,55)"><path id="SvgjsPath1163" d="M 0 0L 35 0L 35 30L 0 30Z" stroke="none" fill="none"></path><g id="SvgjsG1164"><text id="SvgjsText1165" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="35px" fill="#f44336" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="3" transform="rotate(0)"><tspan id="SvgjsTspan1166" dy="20" x="17.5"><tspan id="SvgjsTspan1167" style="text-decoration:;">a'</tspan></tspan></text></g></g><g id="SvgjsG1168"><path id="SvgjsPath1169" d="M176 54L176 25L342.5 25L342.5 51.400000000000006" stroke="#f44336" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1170)"></path></g><g id="SvgjsG1172"><path id="SvgjsPath1173" d="M193 137.125L257.5 137.125L257.5 88.6" stroke="#f44336" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1174)"></path></g></svg>
</div>
<h4 id="_3-rebase-两步走-正确姿势"> 3）rebase 两步走 - 正确姿势</h4>
<ul>
<li>Step 1：切换到 feature 分支，去 rebase develop，即 <code>git rebase -i develop</code>
<ul>
<li>feature 的 commit b 会重新生成一个 b'，排在 develop 的新需求 a 的后面</li>
<li>这一步相当于回到场景 1 的模式，我在当前 feature 先把自己的 b 拎出来，同步完最新的 develop，再把需求 b 放在最后面</li>
<li>接下来回到 develop 进行 merge 的时候就很舒服了</li>
</ul>
</li>
<li>Step 2：切换到 develop 分支，去 merge feature，即 <code>git merge feature</code>
<ul>
<li>合并后查看 log，可以发现 develop 分支作为主分支，本次合并没有影响自己原来的 commit 历史，只在后面新增了 feature 的新内容，并没有多余的 commit</li>
</ul>
</li>
</ul>
<div style="text-align: center;">
  <svg id="SvgjsSvg1176" width="457.25" height="226.5" xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.com/svgjs"><defs id="SvgjsDefs1177"><marker id="SvgjsMarker1224" markerWidth="14" markerHeight="10" refX="10" refY="5" viewBox="0 0 14 10" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1225" d="M0,0 L14,5 L0,10 L0,0" fill="#f44336" stroke="#f44336" stroke-width="1"></path></marker><marker id="SvgjsMarker1228" markerWidth="14" markerHeight="10" refX="10" refY="5" viewBox="0 0 14 10" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1229" d="M0,0 L14,5 L0,10 L0,0" fill="#f44336" stroke="#f44336" stroke-width="1"></path></marker><marker id="SvgjsMarker1232" markerWidth="14" markerHeight="10" refX="10" refY="5" viewBox="0 0 14 10" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1233" d="M0,0 L14,5 L0,10 L0,0" fill="#f44336" stroke="#f44336" stroke-width="1"></path></marker><marker id="SvgjsMarker1254" markerWidth="14" markerHeight="10" refX="10" refY="5" viewBox="0 0 14 10" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1255" d="M0,0 L14,5 L0,10 L0,0" fill="#f44336" stroke="#f44336" stroke-width="1"></path></marker><marker id="SvgjsMarker1258" markerWidth="14" markerHeight="10" refX="10" refY="5" viewBox="0 0 14 10" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1259" d="M0,0 L14,5 L0,10 L0,0" fill="#f44336" stroke="#f44336" stroke-width="1"></path></marker><marker id="SvgjsMarker1262" markerWidth="14" markerHeight="10" refX="10" refY="5" viewBox="0 0 14 10" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1263" d="M0,0 L14,5 L0,10 L0,0" fill="#f44336" stroke="#f44336" stroke-width="1"></path></marker></defs><g id="SvgjsG1178" transform="translate(245,53.5)"><path id="SvgjsPath1179" d="M 0 0L 152 0L 152 148L 0 148Z" stroke="rgba(186,104,200,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1180"><text id="SvgjsText1181" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="132px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="64.375" transform="rotate(0)"></text></g></g><g id="SvgjsG1182" transform="translate(25,53.5)"><path id="SvgjsPath1183" d="M 0 0L 216 0L 216 148L 0 148Z" stroke="rgba(251,192,45,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1184"><text id="SvgjsText1185" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="196px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="64.375" transform="rotate(0)"></text></g></g><g id="SvgjsG1186" transform="translate(176.5,126.625)"><path id="SvgjsPath1187" d="M 0 13.5C 0 -4.5 27 -4.5 27 13.5C 27 31.5 0 31.5 0 13.5Z" stroke="rgba(158,158,158,1)" stroke-width="2" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1188"><text id="SvgjsText1189" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="7px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="3.875" transform="rotate(0)"></text></g></g><g id="SvgjsG1190" transform="translate(141.75,79.578125)"><path id="SvgjsPath1191" d="M 0 0L 96.5 0L 96.5 115.921875L 0 115.921875Z" stroke="none" fill="none"></path><g id="SvgjsG1192"><text id="SvgjsText1193" font-family="微软雅黑" text-anchor="middle" font-size="35px" width="97px" fill="#9e9e9e" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="35px" weight="400" font-style="" opacity="1" y="29.5859375" transform="rotate(0)"><tspan id="SvgjsTspan1194" dy="43" x="48.5"><tspan id="SvgjsTspan1195" style="text-decoration:;">×</tspan></tspan></text></g></g><g id="SvgjsG1196" transform="translate(174,127.875)"><path id="SvgjsPath1197" d="M 0 0L 32 0L 32 24.5L 0 24.5Z" stroke="none" fill="none"></path><g id="SvgjsG1198"><text id="SvgjsText1199" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="32px" fill="#f44336" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="0.25" transform="rotate(0)"><tspan id="SvgjsTspan1200" dy="20" x="16"><tspan id="SvgjsTspan1201" style="text-decoration:;">b</tspan></tspan></text></g></g><g id="SvgjsG1202" transform="translate(172.5,58)"><path id="SvgjsPath1203" d="M 0 0L 35 0L 35 30L 0 30Z" stroke="none" fill="none"></path><g id="SvgjsG1204"><text id="SvgjsText1205" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="35px" fill="#f44336" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="3" transform="rotate(0)"><tspan id="SvgjsTspan1206" dy="20" x="17.5"><tspan id="SvgjsTspan1207" style="text-decoration:;">a</tspan></tspan></text></g></g><g id="SvgjsG1208" transform="translate(39,59.25)"><path id="SvgjsPath1209" d="M 0 0L 82 0L 82 27.5L 0 27.5Z" stroke="none" fill="none"></path><g id="SvgjsG1210"><text id="SvgjsText1211" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="82px" fill="#f44336" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="1.75" transform="rotate(0)"><tspan id="SvgjsTspan1212" dy="20" x="41"><tspan id="SvgjsTspan1213" style="text-decoration:;">develop</tspan></tspan></text></g></g><g id="SvgjsG1214" transform="translate(39,125.75)"><path id="SvgjsPath1215" d="M 0 0L 82 0L 82 28.75L 0 28.75Z" stroke="none" fill="none"></path><g id="SvgjsG1216"><text id="SvgjsText1217" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="82px" fill="#f44336" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="2.375" transform="rotate(0)"><tspan id="SvgjsTspan1218" dy="20" x="41"><tspan id="SvgjsTspan1219" style="text-decoration:;">feature</tspan></tspan></text></g></g><g id="SvgjsG1220"><path id="SvgjsPath1221" d="M80 87.75L80 106.25L80 106.25L80 124.75" stroke="#f44336" stroke-width="2" fill="none"></path></g><g id="SvgjsG1222"><path id="SvgjsPath1223" d="M122 73L146.75 73L146.75 73L168.89999999999998 73" stroke="#f44336" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1224)"></path></g><g id="SvgjsG1226"><path id="SvgjsPath1227" d="M122 140.125L147.5 140.125L147.5 140.125L170.39999999999998 140.125" stroke="#f44336" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1228)"></path></g><g id="SvgjsG1230"><path id="SvgjsPath1231" d="M254 73L339 73" stroke="#f44336" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1232)"></path></g><g id="SvgjsG1234" transform="translate(339,58)"><path id="SvgjsPath1235" d="M 0 0L 35 0L 35 30L 0 30Z" stroke="none" fill="none"></path><g id="SvgjsG1236"><text id="SvgjsText1237" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="35px" fill="#f44336" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="3" transform="rotate(0)"><tspan id="SvgjsTspan1238" dy="20" x="17.5"><tspan id="SvgjsTspan1239" style="text-decoration:;">b'</tspan></tspan></text></g></g><g id="SvgjsG1240" transform="translate(254,125.125)"><path id="SvgjsPath1241" d="M 0 0L 35 0L 35 30L 0 30Z" stroke="none" fill="none"></path><g id="SvgjsG1242"><text id="SvgjsText1243" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="35px" fill="#f44336" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="3" transform="rotate(0)"><tspan id="SvgjsTspan1244" dy="20" x="17.5"><tspan id="SvgjsTspan1245" style="text-decoration:;">b'</tspan></tspan></text></g></g><g id="SvgjsG1246" transform="translate(212.5,125.125)"><path id="SvgjsPath1247" d="M 0 0L 35 0L 35 30L 0 30Z" stroke="none" fill="none"></path><g id="SvgjsG1248"><text id="SvgjsText1249" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="35px" fill="#f44336" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="3" transform="rotate(0)"><tspan id="SvgjsTspan1250" dy="20" x="17.5"><tspan id="SvgjsTspan1251" style="text-decoration:;">a</tspan></tspan></text></g></g><g id="SvgjsG1252"><path id="SvgjsPath1253" d="M208.5 73L230 73L230 121.525" stroke="#f44336" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1254)"></path></g><g id="SvgjsG1256"><path id="SvgjsPath1257" d="M190 153.375L190 185.125L271.5 185.125L271.5 158.725" stroke="#f44336" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1258)"></path></g><g id="SvgjsG1260"><path id="SvgjsPath1261" d="M289.7914783660376 139.51380281733762L353.65067788226463 90.20030985758456" stroke="#f44336" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1262)"></path></g><g id="SvgjsG1264" transform="translate(28.5,25)"><path id="SvgjsPath1265" d="M 0 0L 193.5 0L 193.5 28.5L 0 28.5Z" stroke="none" fill="none"></path><g id="SvgjsG1266"><text id="SvgjsText1267" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="194px" fill="#fbc02d" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="2.25" transform="rotate(0)"><tspan id="SvgjsTspan1268" dy="20" x="97"><tspan id="SvgjsTspan1269" style="text-decoration:;">feature rebase develop</tspan></tspan></text></g></g><g id="SvgjsG1270" transform="translate(238.25,25)"><path id="SvgjsPath1271" d="M 0 0L 193.5 0L 193.5 28.5L 0 28.5Z" stroke="none" fill="none"></path><g id="SvgjsG1272"><text id="SvgjsText1273" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="194px" fill="#ba68c8" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="2.25" transform="rotate(0)"><tspan id="SvgjsTspan1274" dy="20" x="97"><tspan id="SvgjsTspan1275" style="text-decoration:;">develop merge feature </tspan></tspan></text></g></g></svg>
</div>
<p>以上就是 rebase 为什么不会产生多余 commit 记录的原因了</p>
<h3 id="rebase-时如何解决冲突"> rebase 时如何解决冲突</h3>
<p>如果两个分支修改了同一文件的同一位置，在 rebase 的时候会提示发生冲突，较为优雅的解决方案：</p>
<ul>
<li>先解决冲突，再保存</li>
<li><code>git add .</code></li>
<li><code>git rebase --continue</code></li>
</ul>
<h2 id="使用-rebase-的注意点"> 使用 rebase 的注意点</h2>
<div><p>注意</p>
<p>如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。<br>
如果你遵循这条金科玉律，就不会出差错。否则，<strong>人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你</strong>。
—— 引用自<a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA" target="_blank" rel="noopener noreferrer">官网</a></p>
</div>
<h3 id="不要基于即将-rebase-的分支去切新分支"> 不要基于即将 rebase 的分支去切新分支</h3>
<div style="text-align: center;">
  <svg id="SvgjsSvg1440" width="500.328125" height="228" xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.com/svgjs"><defs id="SvgjsDefs1441"><marker id="SvgjsMarker1474" markerWidth="14" markerHeight="10" refX="10" refY="5" viewBox="0 0 14 10" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1475" d="M0,0 L14,5 L0,10 L0,0" fill="#f44336" stroke="#f44336" stroke-width="1"></path></marker><marker id="SvgjsMarker1478" markerWidth="14" markerHeight="10" refX="10" refY="5" viewBox="0 0 14 10" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1479" d="M0,0 L14,5 L0,10 L0,0" fill="#1976d2" stroke="#1976d2" stroke-width="1"></path></marker><marker id="SvgjsMarker1494" markerWidth="14" markerHeight="10" refX="10" refY="5" viewBox="0 0 14 10" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1495" d="M0,0 L14,5 L0,10 L0,0" fill="#1976d2" stroke="#1976d2" stroke-width="1"></path></marker><marker id="SvgjsMarker1504" markerWidth="14" markerHeight="10" refX="10" refY="5" viewBox="0 0 14 10" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1505" d="M0,0 L14,5 L0,10 L0,0" fill="#1976d2" stroke="#1976d2" stroke-width="1"></path></marker></defs><g id="SvgjsG1442" transform="translate(163.5,93)"><path id="SvgjsPath1443" d="M 0 14.5C 0 -4.833333333333333 27 -4.833333333333333 27 14.5C 27 33.833333333333336 0 33.833333333333336 0 14.5Z" stroke="rgba(25,118,210,1)" stroke-width="2" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1444"><text id="SvgjsText1445" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="7px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="4.875" transform="rotate(0)"></text></g></g><g id="SvgjsG1446" transform="translate(159.5,93)"><path id="SvgjsPath1447" d="M 0 0L 35 0L 35 29L 0 29Z" stroke="none" fill="none"></path><g id="SvgjsG1448"><text id="SvgjsText1449" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="35px" fill="#1976d2" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="2.5" transform="rotate(0)"><tspan id="SvgjsTspan1450" dy="20" x="17.5"><tspan id="SvgjsTspan1451" style="text-decoration:;">b</tspan></tspan></text></g></g><g id="SvgjsG1452" transform="translate(159.5,25)"><path id="SvgjsPath1453" d="M 0 0L 35 0L 35 29L 0 29Z" stroke="none" fill="none"></path><g id="SvgjsG1454"><text id="SvgjsText1455" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="35px" fill="#f44336" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="2.5" transform="rotate(0)"><tspan id="SvgjsTspan1456" dy="20" x="17.5"><tspan id="SvgjsTspan1457" style="text-decoration:;">a</tspan></tspan></text></g></g><g id="SvgjsG1458" transform="translate(25,25)"><path id="SvgjsPath1459" d="M 0 0L 82 0L 82 29L 0 29Z" stroke="none" fill="none"></path><g id="SvgjsG1460"><text id="SvgjsText1461" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="82px" fill="#f44336" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="2.5" transform="rotate(0)"><tspan id="SvgjsTspan1462" dy="20" x="41"><tspan id="SvgjsTspan1463" style="text-decoration:;">develop</tspan></tspan></text></g></g><g id="SvgjsG1464" transform="translate(25,93)"><path id="SvgjsPath1465" d="M 0 0L 82 0L 82 29L 0 29Z" stroke="none" fill="none"></path><g id="SvgjsG1466"><text id="SvgjsText1467" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="82px" fill="#1976d2" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="2.5" transform="rotate(0)"><tspan id="SvgjsTspan1468" dy="20" x="41"><tspan id="SvgjsTspan1469" style="text-decoration:;">feature</tspan></tspan></text></g></g><g id="SvgjsG1470"><path id="SvgjsPath1471" d="M66 55L66 72.25L66 72.25L66 92" stroke="#1976d2" stroke-width="2" fill="none"></path></g><g id="SvgjsG1472"><path id="SvgjsPath1473" d="M108 39.5L132.75 39.5L132.75 39.5L155.89999999999998 39.5" stroke="#f44336" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1474)"></path></g><g id="SvgjsG1476"><path id="SvgjsPath1477" d="M108 107.5L133.5 107.5L133.5 107.5L155.89999999999998 107.5" stroke="#1976d2" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1478)"></path></g><g id="SvgjsG1480" transform="translate(291.5,96.47916666666666)"><path id="SvgjsPath1481" d="M 0 0L 35 0L 35 22.041666666666686L 0 22.041666666666686Z" stroke="none" fill="none"></path><g id="SvgjsG1482"><text id="SvgjsText1483" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="35px" fill="#1976d2" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="-0.9791666666666572" transform="rotate(0)"><tspan id="SvgjsTspan1484" dy="20" x="17.5"><tspan id="SvgjsTspan1485" style="text-decoration:;">b'</tspan></tspan></text></g></g><g id="SvgjsG1486" transform="translate(228.5,93)"><path id="SvgjsPath1487" d="M 0 0L 35 0L 35 29L 0 29Z" stroke="none" fill="none"></path><g id="SvgjsG1488"><text id="SvgjsText1489" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="35px" fill="#f44336" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="2.5" transform="rotate(0)"><tspan id="SvgjsTspan1490" dy="20" x="17.5"><tspan id="SvgjsTspan1491" style="text-decoration:;">a</tspan></tspan></text></g></g><g id="SvgjsG1492"><path id="SvgjsPath1493" d="M195.5 39.5L246 39.5L246 89.4" stroke="#1976d2" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1494)"></path></g><g id="SvgjsG1496" transform="translate(136,167.00000000000003)"><path id="SvgjsPath1497" d="M 0 0L 82 0L 82 29L 0 29Z" stroke="none" fill="none"></path><g id="SvgjsG1498"><text id="SvgjsText1499" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="82px" fill="#388e3c" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="2.5" transform="rotate(0)"><tspan id="SvgjsTspan1500" dy="20" x="41"><tspan id="SvgjsTspan1501" style="text-decoration:;">feature_b</tspan></tspan></text></g></g><g id="SvgjsG1502"><path id="SvgjsPath1503" d="M184.5 123L184.5 141.9583333333333L309 141.9583333333333L309 122.12083333333334" stroke="#1976d2" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1504)"></path></g><g id="SvgjsG1506"><path id="SvgjsPath1507" d="M177 123L177 142.08333333333334L177 142.08333333333334L177 166.00000000000003" stroke="#388e3c" stroke-width="2" fill="none"></path></g><g id="SvgjsG1508" transform="translate(257,68.16666666666663)"><path id="SvgjsPath1509" d="M 0 0L 120 0L 120 43L 0 43Z" stroke="none" fill="none"></path><g id="SvgjsG1510"><text id="SvgjsText1511" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="120px" fill="#1976d2" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="11.875" transform="rotate(0)"><tspan id="SvgjsTspan1512" dy="16" x="60"><tspan id="SvgjsTspan1513" style="text-decoration:;">rebase develop</tspan></tspan></text></g></g><g id="SvgjsG1514" transform="translate(224.33333333333337,159.99999999999997)"><path id="SvgjsPath1515" d="M 0 0L 250.83333333333337 0L 250.83333333333337 43L 0 43Z" stroke="none" fill="none"></path><g id="SvgjsG1516"><text id="SvgjsText1517" font-family="微软雅黑" text-anchor="start" font-size="13px" width="251px" fill="#388e3c" font-weight="400" align="middle" lineHeight="125%" anchor="start" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="3.375" transform="rotate(0)"><tspan id="SvgjsTspan1518" dy="16" x="0"><tspan id="SvgjsTspan1519" style="text-decoration:;">此时 feature_b 还在 b 节点</tspan></tspan><tspan id="SvgjsTspan1520" dy="16" x="0"><tspan id="SvgjsTspan1521" style="text-decoration:;">然而 feature rebase 完，已经没有 b 了</tspan></tspan></text></g></g></svg>
</div>
<p>如上图所示：</p>
<ul>
<li>feature 通过场景 2 中的 rebase 两步走之后，与 develop 实现了同步</li>
<li>但是原先基于 feature 切出去的新分支 feature_b 还是原来的 commit b</li>
<li>此时无论 develop 还是 feature，再合并 feature_b 的时候，都会产生冲突，形成两个相同的提交记录（其实就是 b 和 b'）</li>
</ul>
<p>所以，首先要确保你的分支已经完成新需求，然后在 rebase 操作结束之后，再去切新分支，这时他们才是同步的</p>
<h3 id="不要对已经合并到主分支的本地修改进行变基"> 不要对已经合并到主分支的本地修改进行变基</h3>
<p>首先，自己的分支，如果想对已经推送的 commit 进行修改，可以在修改完后，使用 <code>git push -f</code> 强行 push 并覆盖远程对应分支</p>
<p>但是如果这些修改已经被合到了其他分支（比如主分支），那又会出现冲突，因为其他分支保存的是你 rebase 之前合进去的 commit</p>
<p>典型操作（应避免）：</p>
<ul>
<li>feature 分支有三个新需求（a，b，c）</li>
<li>develop 合并 feature 后，保持同步完成</li>
<li>这个时候 feature 分支使用 <code>rebase -i</code>，对中间 b 进行修改，导致 b 和 c 的 commit-id 都发生了改变</li>
<li>develop 再合并 feature 时，就会产生冲突，解决后，会多出两次重复的提交记录（以前就有 b，c，现在又多了 b'，c'）</li>
</ul>
<h3 id="不要在预发布-正式分支上使用-rebase-i"> 不要在预发布/正式分支上使用 rebase -i</h3>
<p>从变基的那个节点开始往后的所有节点的 commit-id 都会发生变化，这个就不再赘述了。</p>
<p>所以可以想象一下，master 上有 100 个 commit，你悄悄改了第 50 个 commit，那从 50—100 的所有 commit 全部改变了。这时别人的分支合进来，就会有 51 个冲突，解决完冲突之后，就会产生 51*2 个相同的提交记录，恐怖如斯！</p>
<h2 id="总结"> 总结</h2>
<p>总的原则是，<strong>只对尚未推送或未分享给别人的本地修改执行变基操作清理历史，永远不要对已推送至别处的提交执行变基操作</strong>。这样，你才能享受到两种方式（rebase 和 merge）带来的便利</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:02:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">pull 时发现代码冲突，如何解决</title>
    <id>https://www.snowji.cn/basic-skills/git/solution-to-code-conflict/</id>
    <link href="https://www.snowji.cn/basic-skills/git/solution-to-code-conflict/"/>
    <updated>2022-08-25T08:02:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="pull-时发现代码冲突-如何解决"> pull 时发现代码冲突，如何解决</h1>
<h2 id="冲突产生的原因"> 冲突产生的原因</h2>
<p>多人协作的开发模式，在代码合并/更新代码时经常会遇到冲突的情况，最常见的是在 <code>push</code> 时，Git 发现本地修改的某个文件在远端也做了修改，那么就会提示需要先进行 <code>pull</code></p>
<p><code>pull</code> 后会有两种情况：</p>
<ul>
<li>Git 自动做了合并（无需理会）</li>
<li>提示有文件存在冲突 - CONFLICT</li>
</ul>
<p>还有一种情况就是同一个文件，在合并分支的时候，如果同一行被多个分支或者不同人都修改了，合并的时候也会出现冲突</p>
<h2 id="解决冲突的步骤"> 解决冲突的步骤</h2>
<p>解决冲突需要自己去判断到底要保留远端代码还是本地代码或者两端都保留。</p>
<p>这个操作一般借助可视化工具进行比较方便，具体步骤如下：</p>
<ul>
<li>查看冲突文件内容</li>
<li>确定冲突内容保留哪些部分，修改文件</li>
<li>重新提交，done</li>
</ul>
<h2 id="冲突标记介绍"> 冲突标记介绍</h2>
<p>Git 提示冲突后，我们切换到对应文件，可以看到冲突内容被标记出来了</p>
<div><pre><code><span>&lt;&lt;&lt;</span><span>&lt;&lt;&lt;</span><span>&lt;</span> HEAD:file.txt

Hello world

<span>==</span><span>==</span><span>==</span><span>=</span>

Goodbye

<span>>></span><span>>></span><span>>></span><span>></span> 77976da35a11db4580b80ae27e8d65caf5208086:file.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>可以看到Git用 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 将代码分成了三个区域</p>
<ul>
<li><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code> 和 <code>=======</code> 之间的内容表示你本地的分支</li>
<li><code>=======</code> 和 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 之间的表示本次 <code>pull</code> 下来或 <code>merge</code> 过来的内容</li>
</ul>
<h2 id="两种方式解决冲突"> 两种方式解决冲突</h2>
<h3 id="方案一-用-merge-来解决冲突"> 方案一：用 merge 来解决冲突</h3>
<p>假设小甲和小乙是同事，两个人一起维护一个项目。某天小甲修改了一份文件（<code>conflict-resolve.md</code>）的第一行代码，提交并推送到了远程分支</p>
<p>此时小乙并不知情，在没有事先 pull 最新代码的前提下，他也修改了同一份文件的同一行代码。那么在小乙操作的时候，必然会遇到代码冲突的情况了</p>
<p>此时对小乙来说，他的操作顺序如下：</p>
<ul>
<li>本地开发完，提交代码：<code>git commit</code></li>
<li>将代码推送到远程分支：<code>git push</code>（但由于小甲先一步往远程分支提交了代码，此时本地代码不是最新的，这步 push 操作会提示和远端版本不一致而中断）</li>
<li>拉取最新远程分支代码：<code>git pull</code>（执行完命令，会提示有代码冲突，需要先解决冲突）</li>
<li>解决代码冲突，然后使用 <code>git add conflict-resolve.md</code> 标注冲突已解决</li>
<li>重新提交代码：<code>git commit</code>（解决冲突的过程其实存在一个 merge 操作）</li>
<li>将代码推送到远程分支：<code>git push</code></li>
</ul>
<p>通过在当前仓库目录下输入 <code>gitk</code> 或 <code>git log --oneline --graph --decorate --all</code> 命令查看节点树，也可以通过其它一些可视化工具获取更好的展示效果</p>
<p>这里我在 GitHub 上查看到的 commit 记录和使用 Sourcetree 获得到的节点树界面如下：</p>
<div style="text-align: center;">
  <img src="./images/conflict-resolve-commits.png" alt="解决代码冲突产生的 commit 记录">
</div>
<div style="text-align: center;">
  <img src="./images/conflict-resolve-tree.png" alt="解决代码冲突产生的节点树">
</div>
<p>观察上述两张图的最新 3 条记录（小甲 1 条，小乙 2 条），可以发现解决代码冲突的过程其实也是一次 merge 操作</p>
<p>小乙将代码推送到 Git 服务器后，整个过程他的操作一共产生了 2 个 commit 记录（一个是对第一行代码修改的提交：<code>8ee4fbe</code>，一个是刚才的 merge 动作）。同时在节点树可以看到提交历史产生了分叉，这种分叉再汇合的结构会让有些人觉得混乱而难以管理</p>
<h3 id="方案二-用-git-rebase-消除分叉"> 方案二：用 git rebase 消除分叉</h3>
<p>如果你不希望 commit 历史出现分叉，可以借助 rebase 命令来消除分叉</p>
<p>此时小乙的操作操作流程如下：</p>
<ul>
<li>本地开发完，提交代码：<code>git commit</code></li>
<li>将代码推送到远程分支：<code>git push</code>（但由于小甲先一步往远程分支提交了代码，此时本地代码不是最新的，这步 push 操作会提示和远端版本不一致而中断）</li>
<li>拉取最新远程分支代码：<code>git pull --rebase</code>（执行完命令，可以看到冲突，并且进入了 rebase 状态）</li>
<li>解决代码冲突，然后使用 <code>git add conflict-resolve.md</code> 标注冲突已解决</li>
<li>合并冲突，执行命令：<code>git rebase --continue</code>（执行这步操作会先进入 commit 信息确认界面，通过输入 <code>:wq</code> 退出信息确认界面完成命令的执行）</li>
<li>将代码推送到远程分支：<code>git push</code></li>
</ul>
<p>这时再登录 GitHub 查看到的 commit 记录和使用 Sourcetree 获得到的节点树界面如下：</p>
<div style="text-align: center;">
  <img src="./images/conflict-resolve-using-rebase-commits.png" alt="使用 rebase 命令解决代码冲突产生的 commit 记录">
</div>
<div style="text-align: center;">
  <img src="./images/conflict-resolve-using-rebase-tree.png" alt="使用 rebase 命令解决代码冲突产生的节点树">
</div>
<p>观察上述两张图的最新 2 条记录（小甲 1 条，小乙 1 条），可以发现此时小乙解决代码冲突的过程只产生了一个 commit 记录，而且节点树中的提交历史也没有产生分叉</p>
<p>事实上，小乙在第一次 <code>git commit</code> 的时候，他的 commit 编号是 <code>37dc33a</code>，经过解决冲突后这个编号被新的编号 <code>e93c9c6</code> 所取代，commit 的内容不变</p>
<h3 id="rebase-的优点和缺点"> rebase 的优点和缺点</h3>
<p><strong>优点</strong>：</p>
<ul>
<li>rebase 最大的好处是你的项目历史会非常整洁</li>
<li>rebase 导致最后的项目历史呈现出完美的线性 —— 你可以从项目终点到起点浏览而不需要任何的 fork。这让你更容易使用 git log、git bisect 和 gitk 来查看项目历史</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>安全性，如果你违反了 rebase 黄金法则，重写项目历史可能会给你的协作工作流带来灾难性的影响</li>
<li>可跟踪性，rebase 不会有合并提交中附带的信息 —— 你看不到 feature 分支中并入了上游的哪些更改</li>
</ul>
<h2 id="推荐操作"> 推荐操作</h2>
<p>在多人协作的开发模式中，为了避免一些麻烦，我一般会有两个习惯：</p>
<ul>
<li>准备开始编写代码了，先看看版本库里有没有别人提交的记录，不管怎样先在本地 <code>pull</code> 一下。</li>
<li>代码编写完成了，本地环境先 <code>commit</code>，然后 <code>pull</code>，再 <code>push</code></li>
</ul>
<div><p>为什么要先 commit，然后 pull，再 push？</p>
<p><code>commit</code> 是告诉 Git，这次提交改了哪些东西，不然只是自己改了，Git 不知道你改了，无从判断比较</p>
<p><code>pull</code> 是为了本地 <code>commit</code> 和远程 <code>commit</code> 的对比记录，Git 按照文件的行数操作进行对比，如果同时操作了某文件的同一行那么就会产生冲突，这时候需要手动解决，保留本地分支代码还是保留远程分支代码</p>
<p>本地代码进行 <code>commit</code> 后，仓库不会将本地代码与远程仓库代码进行比较，不会识别是否存在代码冲突，必须进行 <code>pull</code> 命令后，才会将本地代码与仓库远程代码进行比较，如果存在冲突，必须要解决冲突后重新 <code>commit</code> 和 <code>push</code>。不存在冲突，会在 <code>pull</code> 时直接合并代码，不会将本地代码覆盖掉</p>
</div>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:02:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">如何使用 GitFlow 工作流进行团队协作</title>
    <id>https://www.snowji.cn/basic-skills/git/solution-to-gitflow/</id>
    <link href="https://www.snowji.cn/basic-skills/git/solution-to-gitflow/"/>
    <updated>2022-08-25T08:02:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="如何使用-gitflow-工作流进行团队协作"> 如何使用 GitFlow 工作流进行团队协作</h1>
<blockquote>
<p>以博客项目为例，记录一下应用 GitFlow 工作流进行团队协作的主要步骤和命令</p>
</blockquote>
<h2 id="初始化项目"> 初始化项目</h2>
<p>首先创建项目，并创建一个 <code>develop</code> 分支，以后更多操作是在 <code>develop</code> 分支上进行的：</p>
<div><pre><code><span># 创建项目</span>
<span>mkdir</span> blog <span>&amp;&amp;</span> <span>cd</span> blog
<span># 初始化 Git 版本库</span>
<span>git</span> init
<span># 添加远程版本库</span>
<span>git</span> remote <span>add</span> origin https://github.com/<span>[</span>your-github-id<span>]</span>/blog.git
<span># 新建 develop 分支并切换</span>
<span>git</span> checkout -b develop

<span># 初始化项目</span>
<span>echo</span> <span>'# 个人博客'</span> <span>></span> README.md
<span># 创建 .gitignore 文件，用于忽略一些临时文件或自动编译生成文件</span>
<span>touch</span> .gitignore
<span># ...</span>
<span>git</span> <span>add</span> <span>.</span>
<span>git</span> commit -m <span>"init repo"</span>
<span># 推送到远程开发分支</span>
<span>git</span> push -u origin develop
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id="功能开发"> 功能开发</h2>
<p>我和小明开始独立开发自己的功能。比如，我开发<code>角色模块</code>，小明开发<code>文章模块</code>。我们都新建自己的功能分支，独立开发、独立测试，互不干扰</p>
<div><pre><code><span># (我)克隆版本库</span>
<span>git</span> clone https://github.com/<span>[</span>your-github-id<span>]</span>/blog.git

<span># (我)切换到 develop 分支</span>
<span>git</span> checkout develop

<span># (我)创建功能分支，功能分支是从开发分支分叉出去的</span>
<span>git</span> checkout -b feature/role

<span># (我)现在可以愉快地开发新功能了</span>
<span>..</span><span>..</span>
<span># (我)将分支推送到远程版本库</span>
<span>git</span> push origin feature/role
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="代码-review-和合并"> 代码 Review 和合并</h2>
<p>现在，我已经完成角色模块，而且基本功能也通过了测试，是时候合并到开发分支了。我发起了 Pull Request，接受群众 Review。项目负责人可以接收 Pull Request 并将分支合并到开发分支</p>
<p>当然 Pull Request 只是一个可选的步骤，你可以直接将分支合并到开发分支</p>
<h2 id="发布分支"> 发布分支</h2>
<p>现在角色模块和文章模块都开发完毕了，项目负责人小甲掐指一算，发布新版本吉时已到，假设是 v0.1.0，从开发分支中拉取出一个发布分支：</p>
<div><pre><code><span># 保持是最新代码</span>
<span>git</span> pull
<span>git</span> checkout develop
<span>git</span> checkout -b release/v0.1.0
<span>git</span> push -u origin release/v0.1.0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>我们已经开始新的功能了，突然间测试报了个 bug，我得优先处理这个 bug：</p>
<div><pre><code><span># 但是(我)在切换分支时报了个错:</span>
<span>git</span> checkout release/v0.1.0
error: Your <span>local</span> changes to the following files would be overwritten by checkout:
  xxx.js
Please commit your changes or stash them before you switch branches.
Aborting
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>意思是，你的本地已经修改了一些文件，如果就这样 <code>checkout</code> 过去，将会被覆盖。你可以提交（<code>commit</code>）你的变更，或者暂存（<code>stash</code>）起来。因为我的代码写到一半，不能将没有意义的代码提交到版本库，所以只能使用后者：</p>
<div><pre><code><span># 推荐在暂存时添加描述信息,</span>
<span>git</span> stash push -m <span>"更改了 xx"</span>
<span>git</span> checkout release/v0.1.0

<span># 修复完 bug 回到原来的功能分支</span>
<span># 恢复暂存</span>
<span>git</span> stash pop
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="合并发布分支"> 合并发布分支</h2>
<p>发布分支在经过几次迭代之后，稳定性已经足以合并到 master 了：</p>
<div><pre><code><span># 切换到 master 分支</span>
<span>git</span> checkout master

<span># 合并分支</span>
<span>git</span> merge release/v0.1.0
<span># 打个 tag</span>
<span>git</span> tag -a v0.1.0 -m <span>"v0.1.0: 包含了角色模块和文章模块等功能更新"</span>
<span># 推送版本库</span>
<span>git</span> push
<span># 推送 tags</span>
<span>git</span> push --tags

<span># 切换到开发分支</span>
<span>git</span> checkout develop
<span>git</span> merge release/v0.1.0
<span>git</span> push

<span># 删除发布分支</span>
<span>git</span> branch -d release/v0.1.0
<span># 删除远程发布分支</span>
<span>git</span> push -d release/v0.1.0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h2 id="修复-bug"> 修复 bug</h2>
<p>客户报了一个生产版本的 bug，这 bug 影响使用，我们必须马上修复这个 bug 并发个版：</p>
<div><pre><code><span># 切换到 master 分支</span>
<span>git</span> checkout master
<span># 创建 bug 修复分支</span>
<span>git</span> checkout -b bug/B20220212
<span># 修复 bug 并提交</span>
<span>git</span> commit -m <span>"紧急修复xxxbug"</span>

<span># 合并到 master</span>
<span>git</span> checkout master
<span>git</span> merge bug/B20220212
<span>git</span> tag -a v0.1.1 -m <span>"紧急修复xxxbug"</span>
<span>git</span> push

<span># 合并到开发分支，因为开发分支同样有这个 bug</span>
<span>git</span> checkout develop
<span>git</span> merge bug/B20220212
<span>git</span> push

<span># 删除 bug 分支</span>
<span>git</span> branch -d bug/B20220212
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:02:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">已 commit 未 push，想修改代码</title>
    <id>https://www.snowji.cn/basic-skills/git/solution-to-last-commit-code-mistake/</id>
    <link href="https://www.snowji.cn/basic-skills/git/solution-to-last-commit-code-mistake/"/>
    <updated>2022-08-25T08:02:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="已-commit-未-push-想修改代码"> 已 commit 未 push，想修改代码</h1>
<h2 id="问题描述"> 问题描述</h2>
<p>刚刚 <code>commit</code> 了一个代码文件（<code>test.js</code>），发现有几个字写错了，此时还未 <code>push</code></p>
<p>比较粗糙的处理方式是再做一个专门修复这几个错别字的 commit。可以是可以，不过还有一个更加优雅和简单的解决方法</p>
<h2 id="解决方案"> 解决方案</h2>
<p>使用 <code>commit -—amend</code> 命令</p>
<div><p>命令解释</p>
<p>&quot;amend&quot; 是「修正」的意思。在提交时，如果加上 <code>--amend</code> 参数，Git 不会在当前 <code>commit</code> 上增加 <code>commit</code>，而是会把当前 <code>commit</code> 里的内容和暂存区（stageing area）里的内容合并起来后创建一个新的 <code>commit</code>，<strong>用这个新的 <code>commit</code> 把当前 <code>commit</code> 替换掉</strong>。所以 <code>commit --amend</code> 做的事就是它的字面意思：对最新一条 <code>commit</code> 进行修正</p>
</div>
<p>具体地，对于上面提到的这种小错误，你就可以把文件（<code>test.js</code>）中的错别字修改好之后，输入：</p>
<div><pre><code><span>git</span> <span>add</span> test.js
<span>git</span> commit --amend
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>Git 会把你带到提交信息编辑界面。可以看到，提交信息默认是当前提交的提交信息。你可以修改或者保留它，然后保存退出。最后，你的最近一次 commit 就被更新了</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:02:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">如何迁移仓库并保留 commits 记录</title>
    <id>https://www.snowji.cn/basic-skills/git/solution-to-migrate-repository-without-losing-history-commits/</id>
    <link href="https://www.snowji.cn/basic-skills/git/solution-to-migrate-repository-without-losing-history-commits/"/>
    <updated>2022-08-25T08:02:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="如何迁移仓库并保留-commits-记录"> 如何迁移仓库并保留 commits 记录</h1>
<h2 id="问题描述"> 问题描述</h2>
<p>假设我们需要在支持 Git 的代码托管平台间进行仓库的迁移，并保留历史 commit 记录</p>
<p>例如：</p>
<p>将 Gitlab 上的仓库迁移到 GitHub，将 Coding 上的仓库迁移到 GitHub，将 Gitee 上的仓库迁移到 GitHub……</p>
<p>迁移前后保留历史 commit 记录，可以确保在迁移后的新仓库中能查询历史提交信息，便于将来出现问题时追溯过去的代码变更记录</p>
<h2 id="解决方案"> 解决方案</h2>
<p>主要分为三个步骤：</p>
<ul>
<li>建立新仓库</li>
<li>克隆旧仓库</li>
<li>推送新仓库</li>
</ul>
<p>下面以 Coding 迁移到 GitHub 为例，介绍两种迁移方式（命令行和可视化工具）的操作步骤</p>
<h2 id="使用-git-bash-操作"> 使用 Git Bash 操作</h2>
<h3 id="在-github-建立新仓库"> 在 GitHub 建立新仓库</h3>
<p>在 GitHub 中新建一个同名项目（不同名也可以），不要添加 <code>README.md</code>，以及任何 <code>License</code> 和 <code>.gitignore</code> 文件，只需要新建一个空的仓库</p>
<h3 id="克隆-coding-上的项目"> 克隆 Coding 上的项目</h3>
<p>将 Coding 上想要迁移的项目完整克隆到本地，执行命令：</p>
<div><pre><code><span>git</span> clone https://git.coding.net/<span>[</span>your-coding-id<span>]</span>/<span>[</span>repo-name<span>]</span>.git  --bare
</code></pre>
<div><span>1</span><br></div></div><h3 id="将克隆下来的仓库推送到-github"> 将克隆下来的仓库推送到 GitHub</h3>
<p>进入刚才克隆下来的文件目录，使用新仓库页面提供的仓库地址（web URL），推送所有的分支和对象：</p>
<div><pre><code><span>cd</span> <span>[</span>repo-name<span>]</span>.git
<span>git</span> push https://github.com/<span>[</span>your-github-id<span>]</span>/<span>[</span>repo-name<span>]</span>.git --all
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="完成后-再执行推送所有的-tags"> 完成后，再执行推送所有的 Tags</h3>
<div><pre><code><span>git</span> push https://github.com/<span>[</span>your-github-id<span>]</span>/<span>[</span>repo-name<span>]</span>.git --tags
</code></pre>
<div><span>1</span><br></div></div><p>这样，整个仓库就全部迁移到 GitHub 了，如果这些 commit 关联的邮箱也同时在 GitHub 的配置中，可以看到小绿点也一起迁移过来了</p>
<h2 id="使用-tortoisegit-操作"> 使用 TortoiseGit 操作</h2>
<p>这种简单的操作我不是很喜欢用可视化工具，不过这里也记录下怎么用「小乌龟」来完成仓库的迁移</p>
<h3 id="在-github-建立新仓库-2"> 在 GitHub 建立新仓库</h3>
<p>同上，不赘述了</p>
<h3 id="克隆-coding-上的项目-2"> 克隆 Coding 上的项目</h3>
<p>同上，不赘述了</p>
<h3 id="将克隆下来的仓库推送到-github-2"> 将克隆下来的仓库推送到 GitHub</h3>
<p>进入项目文件夹，鼠标右键 -&gt; Git Sync...</p>
<div style="text-align: center;">
  <img src="./images/tortoisegit-sync.png" alt="TortoiseGit 同步">
</div>
<p>点击 Manage</p>
<div style="text-align: center;">
  <img src="./images/tortoisegit-sync-manage.png" alt="TortoiseGit 同步-管理">
</div>
<p>填写 GitHub 远程仓库的信息，并 Add New/Save，应用，确认</p>
<div style="text-align: center;">
  <img src="./images/tortoisegit-sync-manage_remote.png" alt="TortoiseGit 同步-管理-远程信息">
</div>
<p>Remote URL 选择刚刚添加的 GitHub，然后 Push</p>
<div style="text-align: center;">
  <img src="./images/tortoisegit-sync-manage-push.png" alt="TortoiseGit 同步-管理-推送">
</div>
<p>最后再提交 Tags</p>
<div style="text-align: center;">
  <img src="./images/tortoisegit-sync-manage-push-tags.png" alt="TortoiseGit 同步-管理-推送标签">
</div>
<h2 id="all-和-mirror-区别"> --all 和 --mirror 区别</h2>
<p>上面在推送代码至 GitHub（新仓库）时，我们用到了下面这个命令：</p>
<p><code>git push https://github.com/[your-github-id]/[repo-name].git --all</code></p>
<p>其实还有另外一个命令：</p>
<p><code>git push https://github.com/[your-github-id]/[repo-name].git --mirror</code></p>
<p>关于这两个命令的区别，可以参见 <a href="https://stackoverflow.com/questions/49343025/git-push-all-vs-mirror" title="Git push --all vs --mirror" target="_blank" rel="noopener noreferrer">Git push --all vs --mirror</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:02:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">已 commit 未 push，漏提交文件</title>
    <id>https://www.snowji.cn/basic-skills/git/solution-to-missed-file-in-last-commit/</id>
    <link href="https://www.snowji.cn/basic-skills/git/solution-to-missed-file-in-last-commit/"/>
    <updated>2022-08-25T08:02:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="已-commit-未-push-漏提交文件"> 已 commit 未 push，漏提交文件</h1>
<h2 id="问题描述"> 问题描述</h2>
<p>已经 <code>commit</code> 但还未 <code>push</code> 时，发现遗漏了部分文件没有提交</p>
<h2 id="解决方案"> 解决方案</h2>
<p>有两种解决方案：</p>
<h3 id="方案一-再次-commit"> 方案一：再次 commit</h3>
<div><pre><code><span>git</span> commit -m <span>"commit info"</span>
</code></pre>
<div><span>1</span><br></div></div><p>此时，Git 上会出现两次 <code>commit</code></p>
<h3 id="方案二-将遗漏文件提交到之前-commit-上"> 方案二：将遗漏文件提交到之前 commit 上</h3>
<div><pre><code><span>git</span> <span>add</span> <span>[</span>missed-file<span>]</span>  <span># missed-file 为遗漏提交的文件</span>
<span>git</span> commit --amend --no-edit
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>--no-edit</code> 表示提交消息不会更改，该操作会修改上一次提交的内容，但不会要求你编辑提交信息，仍保持上一次 <code>commit</code> 的 message</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:02:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">如何参与开源项目 - 提交 PR 与更新 Fork 分支</title>
    <id>https://www.snowji.cn/basic-skills/git/solution-to-participate-in-open-source-projects/</id>
    <link href="https://www.snowji.cn/basic-skills/git/solution-to-participate-in-open-source-projects/"/>
    <updated>2022-08-25T08:02:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="如何参与开源项目-提交-pr-与更新-fork-分支"> 如何参与开源项目 - 提交 PR 与更新 Fork 分支</h1>
<blockquote>
<p>总结一下如何参加一个开源项目，包括 Fork 代码，提出 PR，更新 Fork 分支等主要步骤</p>
</blockquote>
<h2 id="fork-代码"> Fork 代码</h2>
<p>以 vue 代码举例，首先需要将 vue 官方仓库通过 GitHub 的 Fork 功能复制一份到自己的 GitHub</p>
<div style="text-align: center;">
  <img src="./images/fork-vue.png" alt="Fork vuejs/vue">
</div>
<p>复制后的结果：</p>
<div style="text-align: center;">
  <img src="./images/forked-vue.png" alt="Forked [your-github-id]/vue">
</div>
<ul>
<li>原仓库路径：<code>https://github.com/vuejs/vue</code></li>
<li>Fork 后的仓库路径：<code>https://github.com/[your-github-id]/vue</code>（注意该代码仓库是挂在自己的用户名下的）</li>
</ul>
<h2 id="clone-到本地"> Clone 到本地</h2>
<p>下载刚才 Fork 的代码（我比较喜欢 SSH 方式，即 Clone with SSH）：</p>
<div><pre><code><span>git</span> clone https://github.com/<span>[</span>your-github-id<span>]</span>/vue.git
</code></pre>
<div><span>1</span><br></div></div><h2 id="开发前同步官方最新代码"> 开发前同步官方最新代码</h2>
<p>Fork 的代码需要随时拉取官方最新的代码更新，保持同步</p>
<h3 id="添加原作者远程分支"> 添加原作者远程分支</h3>
<p>这个操作只需要做一次，目的是添加原作者 remote-repo（远程库）</p>
<div><pre><code><span>git</span> remote <span>add</span> upstream https://github.com/vuejs/vue
</code></pre>
<div><span>1</span><br></div></div><p>这个时候输入 <code>git remote -v</code>，会得到结果：</p>
<div style="text-align: center;">
  <img src="./images/add-remote-repo.png" alt="Add Remote Repo">
</div>
<h3 id="拉取合并远程分支到-master-分支"> 拉取合并远程分支到 master 分支</h3>
<p>这个需要随时做，保持你的 master 分支永远跟官方最新代码保持一致</p>
<div><pre><code><span># fetch 源仓库最新的 master 分支到本地的 upstream/master</span>
<span>git</span> fetch upstream master

<span># 切换到本地的 master 分支</span>
<span>git</span> checkout master

<span># 将来自 upstream/master 的更改合并到本地 master 分支中</span>
<span>git</span> merge upstream/master
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="提交-pr-pull-request"> 提交 PR（Pull Request）</h2>
<p>在本地修改完代码后，接下来就是最后一步 Pull Request，即 PR</p>
<h3 id="推送本地分支到-github"> 推送本地分支到 GitHub</h3>
<p>先 commit，后 push</p>
<h3 id="pull-request"> Pull Request</h3>
<p>当你在上一步 push 代码后，再访问你自己的 GitHub 主页时，会有 pull request 提示：</p>
<div style="text-align: center;">
  <img src="./images/pull-request.png" alt="Compare & pull request 提示">
</div>
<p>点击 <strong>Compare &amp; pull request</strong> 后，就会到下面这个页面，文本框中的内容要遵循统一的规定（一般符和该项目作者的规范即可），然后点击 <strong>Create pull request</strong></p>
<div style="text-align: center;">
  <img src="./images/create-pull-request.png" alt="Create pull request">
</div>
<p>最后就可以等待源仓库作者的处理结果了</p>
<h2 id="参考资料"> 参考资料</h2>
<ul>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/collaborating-with-issues-and-pull-requests/syncing-a-fork" target="_blank" rel="noopener noreferrer">GitHub Docs</a></li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:02:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">刚刚的 commit 有误，想要撤回</title>
    <id>https://www.snowji.cn/basic-skills/git/solution-to-withdraw-last-commit/</id>
    <link href="https://www.snowji.cn/basic-skills/git/solution-to-withdraw-last-commit/"/>
    <updated>2022-08-25T08:02:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="刚刚的-commit-有误-想要撤回"> 刚刚的 commit 有误，想要撤回</h1>
<h2 id="问题描述"> 问题描述</h2>
<p>出于某种原因，发现刚才的一次 <code>commit</code> 是错的，需要回退到上一个 <code>commit</code> 版本，进行修复后再重新 <code>commit</code></p>
<p>这里可以用到的有两个命令：<code>git reset</code> 和 <code>git revert</code>，它们的区别还挺大的</p>
<h2 id="解决方案"> 解决方案</h2>
<h3 id="方案一-git-reset"> 方案一：git reset</h3>
<p>直接删除指定的 commit</p>
<p>代码回滚中这个命令用的很多，而且是 <code>--hard</code> 用的比较多：</p>
<p><code>--hard</code>：硬性回滚，简单粗暴，直接抛弃上次提交后的所有本次修改，回滚到之前的样子
<code>--soft</code>：软性回滚，可以理解为撤销指定的 commit 记录</p>
<div><pre><code><span># 修改版本库，保留暂存区，保留工作区</span>
<span># 软回退表示将本地版本库的头指针全部重置到指定版本，且将这次提交之后的所有变更都移动到暂存区</span>
<span># 将版本库软回退一个版本</span>
<span>git</span> reset --soft HEAD~1 <span># 或 git reset --soft HEAD^</span>
<span># 将版本库软回退 N 个版本</span>
<span>git</span> reset --soft HEAD~N

<span># 修改版本库，修改暂存区，修改工作区</span>
<span># 不仅仅是将本地版本库的头指针全部重置到指定版本，也会重置暂存区，并且会将工作区代码也回退到这个版本</span>
<span># 将版本库回退一个版本</span>
<span>git</span> reset --hard HEAD^
<span># 将版本库回退两个版本</span>
<span>git</span> reset --hard HEAD^^
<span># 将版本库回退到特定的 commit-id 版本，可以通过 git log 查看每次 commit 对应的 ID</span>
<span>git</span> reset --hard <span>[</span>commit-id<span>]</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>如果需要撤销已经 <code>push</code> 到远端的 <code>commit</code>，使远端的仓库也回退到相应的版本，需要在 <code>push</code> 时加上参数 <code>--force</code>：</p>
<div><pre><code><span>git</span> push origin <span>[</span>branch-name<span>]</span> --force
</code></pre>
<div><span>1</span><br></div></div><h3 id="方案二-git-revert"> 方案二：git revert</h3>
<p>撤销某次操作，此次操作之前和之后的 commit 和 history 都会保留，并且把这次撤销作为一次最新的提交</p>
<div><pre><code><span># 撤销前一次 commit</span>
<span>git</span> revert HEAD

<span>#  撤销前前一次 commit</span>
<span>git</span> revert HEAD^

<span># 撤销指定的版本，撤销动作本身也会作为一次提交进行保存</span>
<span>git</span> revert <span>[</span>commit-id<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><code>git revert</code> 是提交一个新的版本，将需要 revert 的版本的内容作为一次新的 <code>commit</code> 再反向修改回去，版本会递增，不影响之前提交的内容</p>
<h2 id="区别-revert-和-reset"> 区别：revert 和 reset</h2>
<ul>
<li><code>git revert</code> 是用一次新的 commit 来回滚之前的 commit，<code>git reset</code> 是直接删除指定的 commit</li>
<li>在回滚这一操作上看，效果差不多。但是在日后继续 merge 以前的老版本时有区别。因为 <code>git revert</code> 是用一次逆向的 commit「中和」之前的提交，因此日后合并老的 branch 时，导致这部分改变不会再次出现，但是 <code>git reset</code> 是直接把某些 commit 在某个 branch 上删除，因而和老的 branch 再次 merge 时，这些被回滚的 commit 应该还会被引入</li>
<li><code>git reset</code> 是把 HEAD 向后移动了一下，而 <code>git revert</code> 是 HEAD 继续前进，只是新的 commit 的内容和要 revert 的内容正好相反，能够抵消要被 revert 的内容</li>
</ul>
<h2 id="总结"> 总结</h2>
<ul>
<li>使用 reset 回退版本后，需要其他所有人手动用远程 master 分支覆盖本地 master 分支。显然，这不是优雅的回退方法</li>
<li>使用 revert 撤销某次提交后，它会产生一个新的提交，虽然代码回退了，但是版本依然是向前的。所以当你用这种方式回退之后，其他人 pull 完，他们的代码也自动的回退了</li>
</ul>
<p>相对之下，<code>git revert</code> 更加优雅。但是，要注意以下几点：</p>
<ul>
<li>revert 是撤销一次提交，所以后面的 commit-id 是你想要抵达的版本的后一次提交。</li>
<li>使用 <code>revert HEAD</code> 是撤销最近的一次提交，如果你最近一次提交是用 revert 命令产生的，那么你再执行一次，就相当于撤销了上次的撤销操作，换句话说，你连续执行两次 <code>revert HEAD</code> 命令，就跟没执行是一样的</li>
<li>使用 <code>revert HEAD~1</code> 表示撤销最近 2 次提交，这个数字是从 0 开始的，如果你之前撤销过产生了 commit-id，那么也会计算在内的</li>
<li>如果使用 revert 撤销的不是最近一次提交，那么一定会有代码冲突，需要你合并代码，合并代码只需要把当前的代码全部去掉，保留之前版本的代码就可以了</li>
</ul>
<p><code>git revert</code> 命令的好处就是不会丢掉别人的提交，即使你撤销后覆盖了别人的提交，他更新代码后，可以在本地用 reset 向前回滚，找到自己的代码，然后拉一下分支，再回来合并上去就可以找回被你覆盖的提交了</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:02:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Linux</title>
    <id>https://www.snowji.cn/basic-skills/linux/</id>
    <link href="https://www.snowji.cn/basic-skills/linux/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="linux"> Linux</h1>
<h2 id="简介"> 简介</h2>
<p>Linux 是一种自由和开放源码的类 UNIX 操作系统，任何个人和机构都可以自由地使用 Linux 的所有底层源代码，也可以自由地修改和再发布</p>
<p><strong>目前主流 Linux 版本</strong>：</p>
<ul>
<li>Debian（及其派生版本Ubuntu、Linux Mint）</li>
<li>Fedora（及其相关版本Red Hat Enterprise Linux、CentOS）</li>
<li>openSUSE</li>
</ul>
<h2 id="目的"> 目的</h2>
<p>介绍一些常用的 Linux 命令，帮助大家在日常的测试中，能够使用这些命令进行排错</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:22:04.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">刚刚的 push 有误，想要撤回</title>
    <id>https://www.snowji.cn/basic-skills/git/solution-to-withdraw-last-push/</id>
    <link href="https://www.snowji.cn/basic-skills/git/solution-to-withdraw-last-push/"/>
    <updated>2022-08-25T08:02:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="刚刚的-push-有误-想要撤回"> 刚刚的 push 有误，想要撤回</h1>
<h2 id="问题描述"> 问题描述</h2>
<p>出于某种原因，不小心把错误的或者不完整的代码 commit 并且 push 到了远程，可能会影响到远程上代码的正确性</p>
<p>Git 提供了撤回远程代码的方法</p>
<h2 id="解决方案"> 解决方案</h2>
<p>按下面的步骤进行：</p>
<ul>
<li><code>git log</code> 查看提交记录，找到<strong>需要撤回到的提交 id</strong>（即有问题的那次提交的上一个 commit）</li>
<li><code>git reset --soft [commit-id]</code>，id 为需要回退到的 commit-id</li>
<li><code>git push origin [本地当前分支名] --force</code>，强制提交当前版本号</li>
</ul>
<p>这个时候查看本地和远程的 log，发现有错误的那次记录已经查不到了，表示撤销成功了</p>
<div><p>注意：关于 git reset</p>
<p>--hard 会丢弃本地修改，请谨慎使用，否则你辛苦写的代码会全部丢失</p>
<ul>
<li>--soft 撤销 commit，保留工作区的代码变更，不会撤销 git add</li>
<li>--mixed 撤销 commit，保留工作区的代码变更，撤销 git add</li>
<li>--hard 撤销 commit，删除工作区的代码变更，撤销 git add</li>
</ul>
</div>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:02:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">常用目录操作命令</title>
    <id>https://www.snowji.cn/basic-skills/linux/linux/common-commands/</id>
    <link href="https://www.snowji.cn/basic-skills/linux/linux/common-commands/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="常用目录操作命令"> 常用目录操作命令</h1>
<h2 id="目录管理"> 目录管理</h2>
<ul>
<li>
<p>Linux 的目录结构为树状结构，最顶级的目录为根目录 /</p>
</li>
<li>
<p>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们</p>
</li>
</ul>
<h3 id="绝对路径"> 绝对路径：</h3>
<p>路径的写法，由根目录 / 写起，例如：<code>/usr/share/doc</code> 这个目录</p>
<h3 id="相对路径"> 相对路径：</h3>
<ul>
<li>
<p>路径的写法，不是由 / 写起</p>
</li>
<li>
<p>例如由 <code>/usr/share/doc</code> 要到 <code>/usr/share/man</code> 底下时，可以写成：<code>cd ../man</code> 这就是相对路径的写法啦</p>
</li>
</ul>
<h2 id="处理目录的常用命令"> 处理目录的常用命令</h2>
<p>接下来我们就来看几个常见的处理目录的命令吧：</p>
<ul>
<li>ls: 列出目录</li>
<li>cd：切换目录</li>
<li>pwd：显示目前的目录</li>
<li>mkdir：创建一个新的目录</li>
<li>rmdir：删除一个空的目录</li>
<li>cp: 复制文件或目录</li>
<li>rm: 移除文件或目录</li>
<li>mv: 移动文件与目录，或修改文件与目录的名称</li>
</ul>
<p>你可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp</p>
<h3 id="ls-列出目录"> ls （列出目录）</h3>
<p>在 Linux 系统当中，<code>ls</code> 命令可能是最常被运行的</p>
<p><strong>语法</strong>：</p>
<div><pre><code><span>[</span>root@www ~<span>]</span><span># ls [-aAdfFhilnrRSt] 目录名称</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>选项与参数</strong>：</p>
<ul>
<li>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li>
<li>-l ：长数据串列出，包含文件的属性与权限等等数据(常用)</li>
</ul>
<p>将目录下的所有文件列出来(含属性与隐藏档)</p>
<div><pre><code><span>[</span>root@www ~<span>]</span><span># ls -al ~</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="cd-切换目录"> cd （切换目录）</h3>
<p>cd 是 Change Directory 的缩写，这是用来变换工作目录的命令</p>
<p><strong>语法</strong>：</p>
<div><pre><code><span>cd</span> <span>[</span>相对路径或绝对路径<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>示例</strong>：</p>
<div><pre><code><span># 切换到用户目录下</span>
<span>[</span>root@VM-16-7-centos /<span>]</span><span># cd home  </span>

<span># 使用 mkdir 命令创建 kuangstudy 目录</span>
<span>[</span>root@VM-16-7-centos home<span>]</span><span># mkdir kuangstudy</span>

<span># 进入 kuangstudy 目录</span>
<span>[</span>root@VM-16-7-centos home<span>]</span><span># cd kuangstudy</span>

<span># 回到上一级</span>
<span>[</span>root@VM-16-7-centos kuangstudy<span>]</span><span># cd ..</span>

<span># 回到根目录</span>
<span>[</span>root@VM-16-7-centos kuangstudy<span>]</span><span># cd /</span>

<span># 表示回到自己的家目录，亦即是 /root 这个目录</span>
<span>[</span>root@VM-16-7-centos kuangstudy<span>]</span><span># cd ~</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id="pwd-显示目前所在的目录"> pwd ( 显示目前所在的目录 )</h3>
<p><code>pwd</code> 是 <strong>Print Working Directory</strong> 的缩写，也就是显示目前所在目录的命令</p>
<p><strong>语法</strong>：</p>
<div><pre><code><span>[</span>root@VM-16-7-centos kuangstudy<span>]</span><span>#pwd [-P]</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>选项与参数</strong>：</p>
<p>-P ：显示出确实的路径，而非使用连接(link) 路径</p>
<p><strong>示例</strong>：</p>
<div><pre><code><span># 单纯显示出目前的工作目录</span>
<span>[</span>root@VM-16-7-centos ~<span>]</span><span># pwd</span>
/root

<span># 如果是链接，要显示真实地址，可以使用 -P参数</span>
<span>[</span>root@VM-16-7-centos /<span>]</span><span># cd bin</span>
<span>[</span>root@VM-16-7-centos bin<span>]</span><span># pwd -P</span>
/usr/bin
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="mkdir-创建新目录"> mkdir （创建新目录）</h3>
<p>如果想要创建新的目录的话，可以使用 <code>mkdir</code> (make directory)</p>
<p><strong>语法</strong>：</p>
<div><pre><code><span>mkdir</span> <span>[</span>-mp<span>]</span> 目录名称
</code></pre>
<div><span>1</span><br></div></div><p><strong>选项与参数</strong>：</p>
<ul>
<li>-m ：配置文件的权限，直接配置，不需要看默认权限 (umask)</li>
<li>-p ：可以将所需要的目录(包含上一级目录)递归创建起来</li>
</ul>
<p><strong>示例</strong>：</p>
<div><pre><code><span># 进入我们用户目录下</span>
<span>[</span>root@VM-16-7-centos /<span>]</span><span># cd /home</span>

<span># 创建一个 test 文件夹</span>
<span>[</span>root@VM-16-7-centos home<span>]</span><span># mkdir test</span>

<span># 创建多层级目录</span>
<span>[</span>root@VM-16-7-centos home<span>]</span><span># mkdir test1/test2/test3/test4</span>
mkdir: cannot create directory ‘test1/test2/test3/test4’:
No such <span>file</span> or directory  <span># &lt;== 没办法直接创建此目录啊！</span>

<span># 加了这个 -p 的选项，可以自行帮你创建多层目录！</span>
<span>[</span>root@VM-16-7-centos home<span>]</span><span># mkdir -p test1/test2/test3/test4</span>

<span># 创建权限为 rwx--x--x 的目录。</span>
<span>[</span>root@VM-16-7-centos home<span>]</span><span># mkdir -m 711 test2</span>
<span>[</span>root@VM-16-7-centos home<span>]</span><span># ls -l</span>
drwxr-xr-x <span>2</span> root root  <span>4096</span> Mar <span>12</span> <span>21</span>:55 <span>test</span>
drwxr-xr-x <span>3</span> root root  <span>4096</span> Mar <span>12</span> <span>21</span>:56 test1
drwx--x--x <span>2</span> root root  <span>4096</span> Mar <span>12</span> <span>21</span>:58 test2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h3 id="rmdir-删除空的目录"> rmdir ( 删除空的目录 )</h3>
<p><strong>语法</strong>：</p>
<div><pre><code><span>rmdir</span> <span>[</span>-p<span>]</span> 目录名称
</code></pre>
<div><span>1</span><br></div></div><p><strong>选项与参数</strong>：</p>
<p>-p ：连同上一级『空的』目录也一起删除</p>
<p><strong>示例</strong>：</p>
<div><pre><code><span># 看看有多少目录存在</span>
<span>[</span>root@VM-16-7-centos home<span>]</span><span># ls -l</span>
drwxr-xr-x <span>2</span> root root  <span>4096</span> Mar <span>12</span> <span>21</span>:55 <span>test</span>
drwxr-xr-x <span>3</span> root root  <span>4096</span> Mar <span>12</span> <span>21</span>:56 test1
drwx--x--x <span>2</span> root root  <span>4096</span> Mar <span>12</span> <span>21</span>:58 test2

<span># 可直接删除掉，没问题</span>
<span>[</span>root@VM-16-7-centos home<span>]</span><span># rmdir test</span>

<span># 因为尚有内容，所以无法删除！</span>
<span>[</span>root@VM-16-7-centos home<span>]</span><span># rmdir test1</span>
rmdir: failed to remove ‘test1’: Directory not empty

<span># 利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 依次删除。</span>
<span>[</span>root@VM-16-7-centos home<span>]</span><span># rmdir -p test1/test2/test3/test4</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><div><p>注意</p>
<ul>
<li>
<p><code>rmdir</code> 仅能删除空的目录</p>
</li>
<li>
<p>非空目录可以使用 <code>rm</code> 命令来删除</p>
</li>
</ul>
</div>
<h3 id="cp-复制文件或目录"> cp ( 复制文件或目录 )</h3>
<p><strong>语法</strong>：</p>
<div><pre><code><span>[</span>root@www ~<span>]</span><span># cp [-adfilprsu] 来源档(source) 目标档(destination)</span>
<span>[</span>root@www ~<span>]</span><span># cp [options] source1 source2 source3 .... directory</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>选项与参数</strong>：</p>
<ul>
<li>-a：相当於 -pdr 的意思，至於 pdr 请参考下列说明(常用)</li>
<li>-p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)</li>
<li>-d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身</li>
<li>-r：递归持续复制，用於目录的复制行为(常用)</li>
<li>-f：为强制(force) 的意思，若目标文件已经存在且无法开启，则移除后再尝试一次</li>
<li>-i：若目标档(destination) 已经存在时，在覆盖时会先询问动作的进行(常用)</li>
<li>-l：进行硬式连结(hard link) 的连结档创建，而非复制文件本身</li>
<li>-s：复制成为符号连结档 (symbolic link)，亦即『捷径』文件</li>
<li>-u：若 destination 比 source 旧才升级 destination</li>
</ul>
<p><strong>示例</strong>：</p>
<div><pre><code><span># 找一个有文件的目录，我这里找到 root目录</span>
<span>[</span>root@VM-16-7-centos home<span>]</span><span># cd /root</span>
<span>[</span>root@VM-16-7-centos ~<span>]</span><span># ls</span>
install.sh
<span>[</span>root@VM-16-7-centos ~<span>]</span><span># cd /home</span>

<span># 复制 root目录下的install.sh 到 home目录下</span>
<span>[</span>root@VM-16-7-centos home<span>]</span><span># cp /root/install.sh /home</span>
<span>[</span>root@VM-16-7-centos home<span>]</span><span># ls</span>
install.sh

<span># 再次复制，加上-i参数，增加覆盖询问？</span>
<span>[</span>root@VM-16-7-centos home<span>]</span><span># cp -i /root/install.sh /home</span>
cp: overwrite ‘/home/install.sh’? y <span># n不覆盖，y为覆盖</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="rm-移除文件或目录"> rm ( 移除文件或目录 )</h3>
<p><strong>语法</strong>：</p>
<div><pre><code><span>rm</span> <span>[</span>-fir<span>]</span> 文件或目录
</code></pre>
<div><span>1</span><br></div></div><p><strong>选项与参数</strong>：</p>
<ul>
<li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li>
<li>-i ：互动模式，在删除前会询问使用者是否动作</li>
<li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li>
</ul>
<p><strong>示例</strong>：</p>
<div><pre><code><span># 将刚刚在 cp 的实例中创建的 install.sh删除掉！</span>
<span>[</span>root@VM-16-7-centos home<span>]</span><span># rm -i install.sh</span>
rm: remove regular <span>file</span> ‘install.sh’? y
<span># 如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！</span>

<span># 尽量不要在服务器上使用 rm -rf /</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="mv-移动文件与目录-或修改名称"> mv  ( 移动文件与目录，或修改名称 )</h3>
<p><strong>语法</strong>：</p>
<div><pre><code><span>[</span>root@www ~<span>]</span><span># mv [-fiu] source destination</span>
<span>[</span>root@www ~<span>]</span><span># mv [options] source1 source2 source3 .... directory</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>选项与参数</strong>：</p>
<ul>
<li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖</li>
<li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖</li>
<li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li>
</ul>
<p><strong>示例</strong>：</p>
<div><pre><code><span># 复制一个文件到当前目录</span>
<span>[</span>root@VM-16-7-centos home<span>]</span><span># cp /root/install.sh /home</span>

<span># 创建一个文件夹 test</span>
<span>[</span>root@VM-16-7-centos home<span>]</span><span># mkdir test</span>

<span># 将复制过来的文件移动到我们创建的目录，并查看</span>
<span>[</span>root@VM-16-7-centos home<span>]</span><span># mv install.sh test</span>
<span>[</span>root@VM-16-7-centos home<span>]</span><span># ls</span>
<span>test</span>
<span>[</span>root@VM-16-7-centos home<span>]</span><span># cd test</span>
<span>[</span>root@VM-16-7-centos test<span>]</span><span># ls</span>
install.sh

<span># 将文件夹重命名，然后再次查看！</span>
<span>[</span>root@VM-16-7-centos test<span>]</span><span># cd ..</span>
<span>[</span>root@VM-16-7-centos home<span>]</span><span># mv test mvtest</span>
<span>[</span>root@VM-16-7-centos home<span>]</span><span># ls</span>
mvtest
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div>]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:22:04.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Crontab</title>
    <id>https://www.snowji.cn/basic-skills/linux/linux/crontab/</id>
    <link href="https://www.snowji.cn/basic-skills/linux/linux/crontab/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="crontab"> Crontab</h1>
<h2 id="简介"> 简介</h2>
<p>作用：用于设置周期性被执行的指令</p>
<p>定时任务包含：</p>
<ul>
<li>cron：服务名称</li>
<li>crond：后台进程</li>
<li>crontab：计划任务表</li>
</ul>
<h2 id="任务分类"> 任务分类</h2>
<h3 id="系统任务调度"> 系统任务调度</h3>
<p>系统周期性所要执行的工作</p>
<p>在 /etc 目录下有一个 crontab 文件，如下：</p>
<p><img src="./images/crontab.png" alt="crontab" /></p>
<p>前四行用来配置 crontab 任务运行的环境变量：</p>
<ul>
<li>
<p>SHELL</p>
<p>指定了系统要使用哪个 shell</p>
</li>
<li>
<p>PATH</p>
<p>指定了系统执行命令的路径</p>
</li>
<li>
<p>MAILTO</p>
<p>指定了crond 的任务执行信息将通过电子邮件发送给 root 用户，如果 MAILTO 变量的值为空，则表示不发送任务执行信息给用户</p>
</li>
<li>
<p>HOME</p>
<p>指定了在执行命令或者脚本时使用的主目录</p>
</li>
</ul>
<h3 id="用户任务调度"> 用户任务调度</h3>
<p>用户定期要执行的工作</p>
<p>使用 crontab 来定制自己的计划任务</p>
<p>所有用户定义的 crontab 文件都被保存在 <code>/var/spool/cron</code> 目录下</p>
<h2 id="crontab-命令"> Crontab 命令</h2>
<ul>
<li>
<p>crontab [-u user] file</p>
<p>将 file 做为 crontab 的任务列表文件并载入 crontab</p>
<p>如果没有指定这个文件，crontab 命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab</p>
</li>
<li>
<p>crontab [-u user] -e</p>
<p>编辑某个用户的 crontab 文件内容</p>
<p>如果不指定用户，则表示编辑当前用户的 crontab 文件内容。</p>
</li>
<li>
<p>crontab [-u user] -l</p>
<p>显示某个用户的 crontab 文件内容</p>
<p>如果不指定用户，则表示显示当前用户的c rontab 文件内容。</p>
</li>
<li>
<p>crontab [-u user] -[i]r</p>
<p>从 <code>/var/spool/cron</code> 目录中删除某个用户的 crontab 文件</p>
<p>如果不指定用户，则默认删除当前用户的 crontab 文件</p>
<p>-i 参数指定在删除用户的 crontab 文件时是否给确认提示</p>
</li>
</ul>
<h2 id="crontab-内容格式"> Crontab 内容格式</h2>
<p>任务格式：</p>
<div><pre><code>minute   hour   day   month   week   command     
</code></pre>
<div><span>1</span><br></div></div><p><img src="./images/crontab1.png" alt="crontab1" /></p>
<ul>
<li>
<p>minute： 表示分钟，可以是从 0 到 59 之间的任何整数</p>
</li>
<li>
<p>hour：表示小时，可以是从 0 到 23 之间的任何整数</p>
</li>
<li>
<p>day：表示日期，可以是从 1 到 31 之间的任何整数</p>
</li>
<li>
<p>month：表示月份，可以是从 1 到 12 之间的任何整数</p>
</li>
<li>
<p>week：表示星期几，可以是从 0 到 7 之间的任何整数，这里的 0 或 7 代表星期日</p>
</li>
<li>
<p>command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件</p>
</li>
</ul>
<p><strong>在以上各个字段中，还可以使用以下特殊字符：</strong></p>
<p>星号（*）：代表所有可能的值，例如 month 字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作</p>
<p>逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”</p>
<p>中杠（-）：可以用整数之间的中杠表示一个整数范围，例如 “2-6” 表示 “2,3,4,5,6”</p>
<p>正斜线（/）：可以用正斜线指定时间的间隔频率，例如 “0-23/2” 表示每两小时执行一次，同时正斜线可以和星号一起使用，例如 */10，如果用在 minute字段，表示每十分钟执行一次</p>
<h3 id="使用实例"> 使用实例</h3>
<p><strong>实例1</strong>：每 1 分钟执行一次 command</p>
<p><strong>命令：</strong></p>
<div><pre><code>* * * * * command
</code></pre>
<div><span>1</span><br></div></div><p><strong>实例2</strong>： 每小时的第 3 和第 15 分钟执行</p>
<p><strong>命令：</strong></p>
<div><pre><code>3,15 * * * * command
</code></pre>
<div><span>1</span><br></div></div><p><strong>实例3</strong>：每隔两天的上午 8点 到 11点 的第 3 和第 15 分钟执行</p>
<p><strong>命令：</strong></p>
<div><pre><code>3,15 8-11 */2 * * command
</code></pre>
<div><span>1</span><br></div></div><p><strong>实例4</strong>：每周六、周日的 1 : 10 重启 smb</p>
<p><strong>命令：</strong></p>
<div><pre><code>10 1 * * 6,0 /etc/init.d/smb restart
</code></pre>
<div><span>1</span><br></div></div><h2 id="crond服务操作命令"> Crond服务操作命令</h2>
<ul>
<li>
<p><code>yum install crontabs</code>   安装 crontab</p>
</li>
<li>
<p><code>/sbin/service crond start</code>     启动服务</p>
</li>
<li>
<p><code>/sbin/service crond stop</code>     关闭服务</p>
</li>
<li>
<p><code>/sbin/service crond restart</code>     重启服务</p>
</li>
<li>
<p><code>/sbin/service crond reload</code>     重新载入配置</p>
</li>
<li>
<p><code>/sbin/service crond status</code>    服务是否运行</p>
</li>
</ul>
<h2 id="使用注意事项"> 使用注意事项</h2>
<h3 id="环境变量问题"> 环境变量问题</h3>
<p>问题：任务无法自动执行，但却可以手动执行</p>
<p>原因：在 crontab 文件中没有指定环境变量，而系统执行任务时，不会加载任何环境变量</p>
<p>注意：</p>
<ul>
<li>
<p>脚本中涉及文件路径时写全局路径</p>
</li>
<li>
<p>脚本执行需要用到 Java 或其他环境变量时，通过 source 命令引入环境变量，如：</p>
<div><pre><code>cat start_cbp.sh

#!/bin/sh

source /etc/profile

export RUN_CONF=/home/d139/conf/platform/cbp/cbp_jboss.conf

/usr/local/jboss-4.0.5/bin/run.sh -c mev &amp;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></li>
<li>
<p>手动执行脚本 OK 时，但是 crontab 不执行，可以尝试在 crontab 中直接引入环境变量解决问题，如：</p>
<div><pre><code>0 * * * * . /etc/profile;/bin/sh /var/www/java/audit_no_count/bin/restart_audit.sh
</code></pre>
<div><span>1</span><br></div></div></li>
</ul>
<h3 id="清理系统用户的邮件日志"> <strong>清理系统用户的邮件日志</strong></h3>
<p>问题：系统调度执行完成后，会输出信息，长期执行时，会导致日志信息会非常大</p>
<p>解决：将输出进行重定向</p>
<div><pre><code>0 */3 * * * /usr/local/apache2/apachectl restart &gt;/dev/null 2&gt;&amp;1
</code></pre>
<div><span>1</span><br></div></div><p><code>/dev/null 2&gt;&amp;1</code> ： 先将标准输出重定向到 <code>/dev/null</code>，然后将标准错误重定向到标准输出</p>
<h3 id="系统级与用户级任务调度"> 系统级与用户级任务调度</h3>
<ul>
<li>可以将用户级任务调度放到系统级任务调度中完成，一般不建议做</li>
<li>不可以将系统级任务调度放到用户级任务调度中完成</li>
<li>要定义一个定时重启系统的任务，就必须将任务放到 <code>/etc/crontab</code>文件，即使在 root 用户下创建一个定时重启系统的任务也是无效的</li>
</ul>
<h3 id="其他注意事项"> 其他注意事项</h3>
<ul>
<li>新创建的 job 在不重启 cron 时，不会马上执行，至少要过 2 分钟才执行</li>
<li>当 crontab 突然失效时，可以尝试 <code>/etc/init.d/crond restart</code> 或者查看日志看某个 job 有没有执行报错 <code>tail -f /var/log/cron</code></li>
<li>谨慎使用  <code>crontab -r</code>，会删除用户的 Crontab 文件</li>
<li>在 crontab 中 % 是有特殊含义的，需要使用 <code>\%</code> 转义</li>
</ul>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:22:04.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">账号管理</title>
    <id>https://www.snowji.cn/basic-skills/linux/linux/accounts/</id>
    <link href="https://www.snowji.cn/basic-skills/linux/linux/accounts/"/>
    <updated>2022-08-25T08:22:04.000Z</updated>
    <content type="html"><![CDATA[<h1 id="账号管理"> 账号管理</h1>
<ul>
<li>Linux 系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统</li>
<li>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护</li>
<li>每个用户账号都拥有一个唯一的用户名和各自的口令</li>
<li>用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录</li>
<li>实现用户账号的管理，要完成的工作主要有如下几个方面：
<ul>
<li>用户账号的添加、删除与修改</li>
<li>用户口令的管理</li>
<li>用户组的管理</li>
</ul>
</li>
</ul>
<h2 id="用户账号的管理"> 用户账号的管理</h2>
<ul>
<li>用户账号的管理工作主要涉及到用户账号的添加、修改和删除</li>
<li>添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录 Shell 等资源</li>
</ul>
<h3 id="useradd-添加账号"> useradd  添加账号</h3>
<p><strong>语法</strong>：</p>
<div><pre><code><span>useradd</span> 选项 用户名
</code></pre>
<div><span>1</span><br></div></div><p><strong>选项</strong> :</p>
<ul>
<li>-c ：comment 指定一段注释性描述</li>
<li>-d ：目录 指定用户主目录，如果此目录不存在，则同时使用 -m 选项，可以创建主目录</li>
<li>-g ：用户组 指定用户所属的用户组</li>
<li>-G ：用户组，用户组 指定用户所属的附加组</li>
<li>-m：使用者目录如不存在则自动建立</li>
<li>-s ：Shell 文件 指定用户的登录 Shell</li>
<li>-u ：用户号 指定用户的用户号，如果同时有 -o 选项，则可以重复使用其他用户的标识号</li>
</ul>
<p><strong>示例</strong>：</p>
<div><pre><code><span># 此命令创建了一个用户 snowji，其中-m选项用来为登录名 snowji 产生一个主目录 /home/kuangshen</span>
<span>[</span>root@VM-16-7-centos home<span>]</span><span># useradd -m snowji</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>增加用户账号就是在 <code>/etc/passwd</code> 文件中为新用户增加一条记录，同时更新其他系统文件如 <code>/etc/shadow</code>, <code>/etc/group</code> 等</p>
<h3 id="linux-下切换用户"> Linux 下切换用户</h3>
<ul>
<li>切换用户的命令为：<code>su username</code></li>
<li>从普通用户切换到 root 用户，还可以使用命令：<code>sudo su</code></li>
<li>在终端输入 exit 或 logout 或使用快捷方式 <code>ctrl+d</code>，可以退回到原来用户，其实 <code>ctrl+d</code> 也是执行的 exit 命令</li>
<li>在切换用户时，如果想在切换用户之后使用新用户的工作环境，可以在 su 和 username 之间加<code>-</code>，如：【su - root】</li>
<li><code>$</code>表示普通用户</li>
<li><code>#</code>表示超级用户，也就是 root 用户</li>
</ul>
<h3 id="删除帐号"> 删除帐号</h3>
<p>删除用户账号就是要将 <code>/etc/passwd</code> 等系统文件中的该用户记录删除，必要时还删除用户的主目录</p>
<p>删除一个已有的用户账号使用 userdel 命令，其格式如下：</p>
<div><pre><code><span>userdel</span> 选项 用户名
</code></pre>
<div><span>1</span><br></div></div><p>常用的选项是 -r，它的作用是把用户的主目录一起删除</p>
<div><pre><code><span>[</span>root@VM-16-7-centos home<span>]</span><span># userdel -r snowji</span>
</code></pre>
<div><span>1</span><br></div></div><p>此命令删除用户 snowji在系统文件中（主要是 <code>/etc/passwd</code>、<code>/etc/shadow</code>、<code>/etc/group</code> 等）的记录，同时删除用户的主目录</p>
<h3 id="修改帐号"> 修改帐号</h3>
<p>修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录 Shell 等。</p>
<p>修改已有用户的信息使用 usermod 命令，其格式如下：</p>
<div><pre><code><span>usermod</span> 选项 用户名
</code></pre>
<div><span>1</span><br></div></div><p><strong>常用的选项</strong>:</p>
<ul>
<li>-c：comment 指定一段注释性描述</li>
<li>-d：目录 指定用户主目录，如果此目录不存在，则同时使用 -m 选项，可以创建主目录</li>
<li>-m：使用者目录如不存在则自动建立</li>
<li>-g：指定用户所属的用户组</li>
<li>-G：用户组，用户组 指定用户所属的附加组</li>
<li>-s：Shell 文件 指定用户的登录 Shell</li>
<li>-u：指定用户的用户号，如果同时有 -o 选项，则可以重复使用其他用户的标识号</li>
</ul>
<p>例如：</p>
<div><pre><code><span>#usermod -s /bin/ksh -d /home/z –g developer snowji</span>
</code></pre>
<div><span>1</span><br></div></div><p>此命令将用户 snowji 的登录 Shell 修改为 ksh，主目录改为 <code>/home/z</code>，用户组改为 developer</p>
<h3 id="设置用户密码"> 设置用户密码</h3>
<ul>
<li>用户管理的一项重要内容是用户口令的管理，用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令</li>
<li>指定和修改用户口令的 Shell 命令是 passwd，超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令</li>
</ul>
<p><strong>语法</strong>：</p>
<div><pre><code><span>passwd</span> 选项 用户名
</code></pre>
<div><span>1</span><br></div></div><p><strong>可使用的选项</strong>：</p>
<ul>
<li>-l ：锁定口令，即禁用账号</li>
<li>-u： 口令解锁</li>
<li>-d ：使账号无口令</li>
<li>-f ：强迫用户下次登录时修改口令</li>
</ul>
<p>如果默认用户名，则修改当前用户的口令</p>
<p>例如：</p>
<p>假设当前用户是 snowji，则下面的命令修改该用户自己的口令：</p>
<div><pre><code>$ <span>passwd</span>
Old password:******
New password:*******
Re-enter new password:*******
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果是超级用户，可以用下列形式指定任何用户的口令：</p>
<div><pre><code><span>#passwd snowji</span>
New password:*******
Re-enter new password:*******
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>普通用户修改自己的口令时，passwd 命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户</li>
<li>而超级用户为用户指定口令时，就不需要知道原口令</li>
<li>为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用 8 位长的口令，口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同</li>
</ul>
<p>为用户指定空口令时，执行下列形式的命令：</p>
<div><pre><code><span>#passwd -d snowji</span>
</code></pre>
<div><span>1</span><br></div></div><p>此命令将用户 snowji 的口令删除，这样用户 snowji 下一次登录时，系统就不再允许该用户登录了</p>
<p>passwd 命令还可以用 <code>-l(lock)</code> 选项锁定某一用户，使其不能登录，例如：</p>
<div><pre><code><span>#passwd -l snowji</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:22:04.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">常用文件查看命令</title>
    <id>https://www.snowji.cn/basic-skills/linux/linux/file-view/</id>
    <link href="https://www.snowji.cn/basic-skills/linux/linux/file-view/"/>
    <updated>2022-08-25T08:22:04.000Z</updated>
    <content type="html"><![CDATA[<h1 id="常用文件查看命令"> 常用文件查看命令</h1>
<p>Linux 系统中使用以下命令来查看文件的内容：</p>
<ul>
<li>cat 由第一行开始显示文件内容</li>
<li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写</li>
<li>nl  显示的时候，顺道输出行号</li>
<li>more 一页一页的显示文件内容</li>
<li>less 与 more 类似，但是比 more 更好的是，可以往前翻页</li>
<li>head 只看头几行</li>
<li>tail 只看尾巴几行</li>
</ul>
<p>你可以使用 man [命令]来查看各个命令的使用文档，如 ：man cp。</p>
<h2 id="cat"> cat</h2>
<p>由第一行开始显示文件内容</p>
<p><strong>语法</strong>：</p>
<div><pre><code><span>cat</span> <span>[</span>-AbEnTv<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>选项与参数</strong>：</p>
<ul>
<li>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已</li>
<li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号</li>
<li>-E ：将结尾的断行字节 $ 显示出来</li>
<li>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同</li>
<li>-T ：将 [tab] 按键以 ^I 显示出来</li>
<li>-v ：列出一些看不出来的特殊字符</li>
</ul>
<p><strong>示例</strong>：</p>
<div><pre><code><span># 查看网络配置: 文件地址 /etc/sysconfig/network-scripts/</span>
<span>[</span>root@VM-16-7-centos ~<span>]</span><span># cat /etc/sysconfig/network-scripts/ifcfg-eth0</span>
<span>DEVICE</span><span>=</span>eth0
<span>BOOTPROTO</span><span>=</span>dhcp
<span>ONBOOT</span><span>=</span>yes
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="tac"> tac</h2>
<p>tac 与 cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：</p>
<div><pre><code><span>[</span>root@VM-16-7-centos ~<span>]</span><span># tac /etc/sysconfig/network-scripts/ifcfg-eth0</span>
<span>ONBOOT</span><span>=</span>yes
<span>BOOTPROTO</span><span>=</span>dhcp
<span>DEVICE</span><span>=</span>eth0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="nl"> nl</h2>
<p>显示行号</p>
<p><strong>语法</strong>：</p>
<div><pre><code><span>nl</span> <span>[</span>-bnw<span>]</span> 文件
</code></pre>
<div><span>1</span><br></div></div><p><strong>选项与参数</strong>：</p>
<ul>
<li>-b ：指定行号指定的方式，主要有两种：
<ul>
<li>-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)</li>
<li>-b t ：如果有空行，空的那一行不要列出行号(默认值)</li>
</ul>
</li>
<li>-n ：列出行号表示的方法，主要有三种：
<ul>
<li>-n ln ：行号在荧幕的最左方显示</li>
<li>-n rn ：行号在自己栏位的最右方显示，且不加 0</li>
<li>-n rz ：行号在自己栏位的最右方显示，且加 0</li>
</ul>
</li>
<li>-w ：行号栏位的占用的位数</li>
</ul>
<p><strong>示例</strong>：</p>
<div><pre><code><span>[</span>root@VM-16-7-centos ~<span>]</span><span># nl /etc/sysconfig/network-scripts/ifcfg-eth0</span>
<span>1DEVICE</span><span>=</span>eth0
<span>2BOOTPROTO</span><span>=</span>dhcp
<span>3ONBOOT</span><span>=</span>yes
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="more"> more</h2>
<p>一页一页翻动</p>
<p>在 more 这个程序的运行过程中，你有几个按键可以按的：</p>
<ul>
<li>空白键 (space)：代表向下翻一页</li>
<li>Enter     ：代表向下翻『一行』</li>
<li>/字串     ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字</li>
<li>:f      ：立刻显示出档名以及目前显示的行数</li>
<li>q       ：代表立刻离开 more ，不再显示该文件内容</li>
<li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li>
</ul>
<div><pre><code><span>[</span>root@VM-16-7-centos etc<span>]</span><span># more /etc/csh.login</span>
<span>..</span><span>..</span><span>(</span>中间省略<span>)</span><span>..</span><span>..</span>
--More--<span>(</span><span>28</span>%<span>)</span> <span># 重点在这一行喔！你的光标也会在这里等待你的命令</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="less"> less</h2>
<p>一页一页翻动，以下实例输出 /etc/man.config 文件的内容：</p>
<p>less 运行时可以输入的命令有：</p>
<ul>
<li>空白键  ：向下翻动一页</li>
<li>[pagedown]：向下翻动一页</li>
<li>[pageup] ：向上翻动一页</li>
<li>/字串 ：向下搜寻『字串』的功能</li>
<li>?字串 ：向上搜寻『字串』的功能</li>
<li>n ：重复前一个搜寻 (与 / 或 ? 有关！)</li>
<li>N ：反向的重复前一个搜寻 (与 / 或 ? 有关！)</li>
<li>q ：离开 less 这个程序；</li>
</ul>
<div><pre><code><span>[</span>root@VM-16-7-centos etc<span>]</span><span># more /etc/csh.login</span>
<span>..</span><span>..</span><span>(</span>中间省略<span>)</span><span>..</span><span>..</span>
<span>:</span>   <span># 这里可以等待你输入命令！</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="head"> head</h2>
<p>取出文件前面几行</p>
<p><strong>语法</strong>：</p>
<div><pre><code><span>head</span> <span>[</span>-n number<span>]</span> 文件
</code></pre>
<div><span>1</span><br></div></div><p><strong>选项与参数</strong>：</p>
<p>-n 后面接数字，代表显示几行的意思</p>
<p>默认显示前面 10 行，若要显示前 20 行，需要指定行数：</p>
<div><pre><code><span>[</span>root@VM-16-7-centos etc<span>]</span><span># head -n 20 /etc/csh.login</span>

</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="tail"> tail</h2>
<p>取出文件后面几行</p>
<p><strong>语法</strong>：</p>
<div><pre><code><span>tail</span> <span>[</span>-n number<span>]</span> 文件
</code></pre>
<div><span>1</span><br></div></div><p><strong>选项与参数</strong>：</p>
<p>-n ：后面接数字，代表显示几行的意思</p>
<p>默认显示最后 10 行！若要显示最后 20 行，需要指定行数：</p>
<div><pre><code><span>[</span>root@VM-16-7-centos etc<span>]</span><span># tail -n 20 /etc/csh.login</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:22:04.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">用户组管理</title>
    <id>https://www.snowji.cn/basic-skills/linux/linux/group/</id>
    <link href="https://www.snowji.cn/basic-skills/linux/linux/group/"/>
    <updated>2022-08-25T08:22:04.000Z</updated>
    <content type="html"><![CDATA[<h1 id="用户组管理"> 用户组管理</h1>
<p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建</p>
<p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新</p>
<p>增加一个新的用户组使用 <code>groupadd</code> 命令</p>
<p><code>groupadd</code> 选项 用户组
可以使用的选项有：</p>
<p>-g GID 指定新用户组的组标识号（GID）</p>
<p>-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同</p>
<p>实例1：</p>
<h2 id="groupadd-group1"> groupadd group1</h2>
<p>此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1</p>
<p>实例2：</p>
<h2 id="groupadd-g-101-group2"> groupadd -g 101 group2</h2>
<p>此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101</p>
<p>如果要删除一个已有的用户组，使用groupdel命令</p>
<p>groupdel 用户组
例如：</p>
<h2 id="groupdel-group1"> groupdel group1</h2>
<p>此命令从系统中删除组group1</p>
<p>修改用户组的属性使用groupmod命令</p>
<p>groupmod 选项 用户组
常用的选项有：</p>
<p>-g GID 为用户组指定新的组标识号。</p>
<p>-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</p>
<p>-n新用户组 将用户组的名字改为新名字</p>
<h2 id="此命令将组group2的组标识号修改为102"> 此命令将组group2的组标识号修改为102</h2>
<p>groupmod -g 102 group2</p>
<h2 id="将组group2的标识号改为10000-组名修改为group3"> 将组group2的标识号改为10000，组名修改为group3</h2>
<p>groupmod –g 10000 -n group3 group2</p>
<p>切换组</p>
<p>如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。</p>
<p>用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如：</p>
<p>$ newgrp root
这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。</p>
<p>/etc/passwd</p>
<p>完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。</p>
<p>与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等。</p>
<p>下面分别介绍这些文件的内容。</p>
<p>/etc/passwd文件是用户管理工作涉及的最重要的一个文件。</p>
<p>Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。</p>
<p>这个文件对所有用户都是可读的。它的内容类似下面的例子：</p>
<p>＃ cat /etc/passwd</p>
<p>root❌0:0:Superuser:/:
daemon❌1:1:System daemons:/etc:
bin❌2:2:Owner of system commands:/bin:
sys❌3:3:Owner of system files:/usr/sys:
adm❌4:4:System accounting:/usr/adm:
uucp❌5:5:UUCP administrator:/usr/lib/uucp:
auth❌7:21:Authentication administrator:/tcb/files/auth:
cron❌9:16:Cron daemon:/usr/spool/cron:
listen❌37:4:Network daemon:/usr/net/nls:
lp❌71:18:Printer administrator:/usr/spool/lp:
从上面的例子我们可以看到，/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：</p>
<p>用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell
1）&quot;用户名&quot;是代表用户账号的字符串。</p>
<p>通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(😃，因为冒号在这里是分隔符。</p>
<p>为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。</p>
<p>2）“口令”一些系统中，存放着加密后的用户口令字。</p>
<p>虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。</p>
<p>3）“用户标识号”是一个整数，系统内部用它来标识用户。</p>
<p>一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。</p>
<p>通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。</p>
<p>4）“组标识号”字段记录的是用户所属的用户组。</p>
<p>它对应着/etc/group文件中的一条记录。</p>
<p>5)“注释性描述”字段记录着用户的一些个人情况。</p>
<p>例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用作finger命令的输出。</p>
<p>6)“主目录”，也就是用户的起始工作目录。</p>
<p>它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。</p>
<p>7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。</p>
<p>Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。</p>
<p>系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。</p>
<p>用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。</p>
<p>利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。</p>
<p>8)系统中有一类用户称为伪用户（pseudo users）。</p>
<p>这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。</p>
<p>常见的伪用户如下所示：</p>
<p>伪 用 户 含 义
bin 拥有可执行的用户命令文件
sys 拥有系统文件
adm 拥有帐户文件
uucp UUCP使用
lp lp或lpd子系统使用
nobody NFS使用
/etc/shadow</p>
<p>1、除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要。</p>
<p>由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是/etc/shadow文件。有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。</p>
<p>2、/etc/shadow中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据/etc/passwd中的数据自动产生</p>
<p>它的文件格式与/etc/passwd类似，由若干个字段组成，字段之间用&quot;:&quot;隔开。这些字段是：</p>
<p>登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志
&quot;登录名&quot;是与/etc/passwd文件中的登录名相一致的用户账号</p>
<p>&quot;口令&quot;字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。</p>
<p>&quot;最后一次修改时间&quot;表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。</p>
<p>&quot;最小时间间隔&quot;指的是两次修改口令之间所需的最小天数。</p>
<p>&quot;最大时间间隔&quot;指的是口令保持有效的最大天数。</p>
<p>&quot;警告时间&quot;字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。</p>
<p>&quot;不活动时间&quot;表示的是用户没有登录活动但账号仍能保持有效的最大天数。</p>
<p>&quot;失效时间&quot;字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。</p>
<p>/etc/group</p>
<p>用户组的所有信息都存放在/etc/group文件中。</p>
<p>将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。</p>
<p>每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。</p>
<p>当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。</p>
<p>用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。</p>
<p>用户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有：</p>
<p>组名:口令:组标识号:组内用户列表
&quot;组名&quot;是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。</p>
<p>&quot;口令&quot;字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。</p>
<p>&quot;组标识号&quot;与用户标识号类似，也是一个整数，被系统内部用来标识组。</p>
<p>&quot;组内用户列表&quot;是属于这个组的所有用户的列表/b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:22:04.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Linux 链接</title>
    <id>https://www.snowji.cn/basic-skills/linux/linux/linux-link/</id>
    <link href="https://www.snowji.cn/basic-skills/linux/linux/linux-link/"/>
    <updated>2022-08-25T08:22:04.000Z</updated>
    <content type="html"><![CDATA[<h1 id="linux-链接"> Linux 链接</h1>
<p>Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）</p>
<h2 id="硬链接"> 硬链接</h2>
<h3 id="什么是硬链接"> 什么是硬链接</h3>
<ul>
<li>硬链接指通过索引节点来进行连接</li>
<li>在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)</li>
<li>在 Linux 中，多个文件名指向同一索引节点是存在的</li>
</ul>
<h3 id="为什么要使用硬链接"> 为什么要使用硬链接</h3>
<p>允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能</p>
<p>例如：</p>
<p>A 是 B 的硬链接（A 和 B 都是文件名）</p>
<ul>
<li>A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同</li>
<li>一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的</li>
<li>删除其中任何一个都不会影响另外一个的访问</li>
<li>当所有硬链接被删除后，文件才会被真正删除</li>
</ul>
<h3 id="语法"> 语法</h3>
<p>使用 ln 命令</p>
<div><pre><code><span>[</span>root@VM-16-7-centos home<span>]</span><span># ln f1 f2</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="软链接"> 软链接</h2>
<h3 id="什么是软链接"> 什么是软链接</h3>
<ul>
<li>软链接文件有类似于 Windows 的快捷方式</li>
<li>实际上是一个特殊的文件</li>
<li>包含的有另一文件的位置信息</li>
</ul>
<p>例如：</p>
<p>A 是 B 的软链接（A 和 B 都是文件名）</p>
<ul>
<li>A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同</li>
<li>A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块</li>
<li>A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）</li>
<li>A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接</li>
</ul>
<h3 id="语法-2"> 语法</h3>
<p>使用 ln -s 命令</p>
<div><pre><code><span>[</span>root@VM-16-7-centos home<span>]</span><span># ln -s f1 f2</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="示例"> 示例</h2>
<div><pre><code><span>[</span>root@VM-16-7-centos /<span>]</span><span># cd /home</span>
<span>[</span>root@VM-16-7-centos home<span>]</span><span># touch f1 # 创建一个测试文件f1</span>
<span>[</span>root@VM-16-7-centos home<span>]</span><span># ls</span>
f1
<span>[</span>root@VM-16-7-centos home<span>]</span><span># ln f1 f2     # 创建f1的一个硬连接文件f2</span>
<span>[</span>root@VM-16-7-centos home<span>]</span><span># ln -s f1 f3   # 创建f1的一个符号连接文件f3</span>
<span>[</span>root@VM-16-7-centos home<span>]</span><span># ls -li       # -i参数显示文件的inode节点信息</span>
<span>397247</span> -rw-r--r-- <span>2</span> root root     <span>0</span> Mar <span>13</span> 00:50 f1
<span>397247</span> -rw-r--r-- <span>2</span> root root     <span>0</span> Mar <span>13</span> 00:50 f2
<span>397248</span> lrwxrwxrwx <span>1</span> root root     <span>2</span> Mar <span>13</span> 00:50 f3 -<span>></span> f1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ul>
<li>硬连接文件 f2 与原文件 f1 的 inode 节点相同，均为 397247</li>
<li>软连接文件的 inode 节点不同</li>
</ul>
<div><pre><code><span># echo 字符串输出 >> f1 输出到 f1文件</span>
<span>[</span>root@VM-16-7-centos home<span>]</span><span># echo "I am f1 file" >>f1</span>
<span>[</span>root@VM-16-7-centos home<span>]</span><span># cat f1</span>
I am f1 <span>file</span>
<span>[</span>root@VM-16-7-centos home<span>]</span><span># cat f2</span>
I am f1 <span>file</span>
<span>[</span>root@VM-16-7-centos home<span>]</span><span># cat f3</span>
I am f1 <span>file</span>
<span>[</span>root@VM-16-7-centos home<span>]</span><span># rm -f f1</span>
<span>[</span>root@VM-16-7-centos home<span>]</span><span># cat f2</span>
I am f1 <span>file</span>
<span>[</span>root@VM-16-7-centos home<span>]</span><span># cat f3</span>
cat: f3: No such <span>file</span> or directory
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>结论：</p>
<ul>
<li>删除符号连接 f3,对 f1,f2 无影响</li>
<li>删除硬连接 f2，对 f1,f3 也无影响</li>
<li>删除原文件 f1，对硬连接 f2 没有影响，导致符号连接 f3 失效</li>
<li>同时删除原文件 f1,硬连接 f2，整个文件会真正的被删除</li>
</ul>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:22:04.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">kill/killall/pkill</title>
    <id>https://www.snowji.cn/basic-skills/linux/linux/kill-killall-pkill/</id>
    <link href="https://www.snowji.cn/basic-skills/linux/linux/kill-killall-pkill/"/>
    <updated>2022-08-25T08:22:04.000Z</updated>
    <content type="html"><![CDATA[<h1 id="kill-killall-pkill"> kill/killall/pkill</h1>
<h2 id="kill"> kill</h2>
<ul>
<li>用于删除执行中的程序或工作</li>
<li>kill 可将指定的信息送至程序，预设的信息为 SIGTERM(15)，可将指定程序终止</li>
<li>若仍无法终止该程序，可使用 SIGKILL(9) 信息尝试强制删除程序</li>
<li>程序或工作的编号可利用 ps 指令或 jobs 指令查看</li>
</ul>
<h3 id="语法"> 语法:</h3>
<div><pre><code><span>kill</span> <span>[</span>-s <span>&lt;</span>信息名称或编号<span>></span><span>]</span><span>[</span>程序<span>]</span>
或
<span>kill</span> <span>[</span>-l <span>&lt;</span>信息编号<span>></span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>参数说明</strong>：</p>
<ul>
<li>-l &lt;信息编号&gt; ：若不加 &lt;信息编号&gt; 选项，则 -l 参数会列出全部的信息名称</li>
<li>-s &lt;信息名称或编号&gt; ：指定要送出的信息。</li>
<li>[程序] ：可以是程序的 PID 或是 PGID，也可以是工作编号</li>
</ul>
<p>可以使用 <code>kill -l</code> 列出所有可用信号</p>
<p>常用的信号：</p>
<ul>
<li>1 (HUP)：重新加载进程</li>
<li>9 (KILL)：杀死一个进程</li>
<li>15 (TERM)：正常停止一个进程</li>
</ul>
<h3 id="示例"> 示例</h3>
<h4 id="显示信号"> 显示信号</h4>
<div><pre><code><span># kill -l</span>
<span>1</span><span>)</span> SIGHUP     <span>2</span><span>)</span> SIGINT     <span>3</span><span>)</span> SIGQUIT     <span>4</span><span>)</span> SIGILL     <span>5</span><span>)</span> SIGTRAP
<span>6</span><span>)</span> SIGABRT     <span>7</span><span>)</span> SIGBUS     <span>8</span><span>)</span> SIGFPE     <span>9</span><span>)</span> SIGKILL    <span>10</span><span>)</span> SIGUSR1
<span>11</span><span>)</span> SIGSEGV    <span>12</span><span>)</span> SIGUSR2    <span>13</span><span>)</span> SIGPIPE    <span>14</span><span>)</span> SIGALRM    <span>15</span><span>)</span> SIGTERM
<span>16</span><span>)</span> SIGSTKFLT    <span>17</span><span>)</span> SIGCHLD    <span>18</span><span>)</span> SIGCONT    <span>19</span><span>)</span> SIGSTOP    <span>20</span><span>)</span> SIGTSTP
<span>21</span><span>)</span> SIGTTIN    <span>22</span><span>)</span> SIGTTOU    <span>23</span><span>)</span> SIGURG    <span>24</span><span>)</span> SIGXCPU    <span>25</span><span>)</span> SIGXFSZ
<span>26</span><span>)</span> SIGVTALRM    <span>27</span><span>)</span> SIGPROF    <span>28</span><span>)</span> SIGWINCH    <span>29</span><span>)</span> SIGIO    <span>30</span><span>)</span> SIGPWR
<span>31</span><span>)</span> SIGSYS    <span>34</span><span>)</span> SIGRTMIN    <span>35</span><span>)</span> SIGRTMIN+1    <span>36</span><span>)</span> SIGRTMIN+2    <span>37</span><span>)</span> SIGRTMIN+3
<span>38</span><span>)</span> SIGRTMIN+4    <span>39</span><span>)</span> SIGRTMIN+5    <span>40</span><span>)</span> SIGRTMIN+6    <span>41</span><span>)</span> SIGRTMIN+7    <span>42</span><span>)</span> SIGRTMIN+8
<span>43</span><span>)</span> SIGRTMIN+9    <span>44</span><span>)</span> SIGRTMIN+10    <span>45</span><span>)</span> SIGRTMIN+11    <span>46</span><span>)</span> SIGRTMIN+12    <span>47</span><span>)</span> SIGRTMIN+13
<span>48</span><span>)</span> SIGRTMIN+14    <span>49</span><span>)</span> SIGRTMIN+15    <span>50</span><span>)</span> SIGRTMAX-14    <span>51</span><span>)</span> SIGRTMAX-13    <span>52</span><span>)</span> SIGRTMAX-12
<span>53</span><span>)</span> SIGRTMAX-11    <span>54</span><span>)</span> SIGRTMAX-10    <span>55</span><span>)</span> SIGRTMAX-9    <span>56</span><span>)</span> SIGRTMAX-8    <span>57</span><span>)</span> SIGRTMAX-7
<span>58</span><span>)</span> SIGRTMAX-6    <span>59</span><span>)</span> SIGRTMAX-5    <span>60</span><span>)</span> SIGRTMAX-4    <span>61</span><span>)</span> SIGRTMAX-3    <span>62</span><span>)</span> SIGRTMAX-2
<span>63</span><span>)</span> SIGRTMAX-1    <span>64</span><span>)</span> SIGRTMAX
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h4 id="杀死进程"> 杀死进程</h4>
<div><pre><code><span># kill 12345</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="强制杀死进程"> 强制杀死进程</h4>
<div><pre><code><span># kill -KILL 123456</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="发送-sighup-信号-可以使用一下信号"> 发送 SIGHUP 信号，可以使用一下信号</h4>
<div><pre><code><span># kill -HUP pid</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="彻底杀死进程"> 彻底杀死进程</h4>
<div><pre><code><span># kill -9 123456</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="杀死指定用户所有进程"> 杀死指定用户所有进程</h4>
<div><pre><code>//方法一 过滤出 hnlinux 用户进程 
<span>#kill -9 $(ps -ef | grep hnlinux) </span>
//方法二
<span>#kill -u hnlinux </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="killall"> killall</h2>
<ul>
<li>用于杀死一个进程，与 kill 不同的是它会杀死指定名字的所有进程</li>
<li>kill 命令杀死指定进程 PID，需要配合 ps 使用，而 killall 直接对进程对名字进行操作，更加方便</li>
</ul>
<h3 id="语法-2"> 语法</h3>
<div><pre><code> <span>killall</span> <span>[</span>选项<span>]</span>  name
</code></pre>
<div><span>1</span><br></div></div><p><strong>参数说明</strong>：</p>
<p>name ： 进程名</p>
<p>选项包含如下几个参数：</p>
<ul>
<li>-e | --exact ： 进程需要和名字完全相符</li>
<li>-I | --ignore-case ：忽略大小写</li>
<li>-g | --process-group ：结束进程组</li>
<li>-i | --interactive ：结束之前询问</li>
<li>-l | --list ：列出所有的信号名称</li>
<li>-q | --quite ：进程没有结束时，不输出任何信息</li>
<li>-r | --regexp ：将进程名模式解释为扩展的正则表达式</li>
<li>-s | --signal ：发送指定信号</li>
<li>-u | --user ：结束指定用户的进程</li>
<li>-v | --verbose ：显示详细执行过程</li>
<li>-w | --wait ：等待所有的进程都结束</li>
<li>-V |--version ：显示版本信息</li>
<li>--help ：显示帮助信息</li>
</ul>
<h3 id="示例-2"> 示例</h3>
<div><pre><code><span># killall -9 php-fpm          //结束所有的 php-fpm 进程</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="pkill"> pkill</h2>
<p>pkill 用于杀死一个进程，与 kill 不同的是它会杀死指定名字的所有进程，类似于 killall命令</p>
<h3 id="语法-3"> 语法</h3>
<div><pre><code>  <span>pkill</span> <span>[</span>选项<span>]</span>  name
</code></pre>
<div><span>1</span><br></div></div><p><strong>参数说明</strong>：</p>
<p>name ： 进程名</p>
<p>选项包含如下几个参数：</p>
<ul>
<li>-P 指定父进程号发送信号</li>
<li>-g 指定进程组</li>
<li>-t 指定开启进程的终端</li>
<li>-o 仅向找到的最小（起始）进程号发送信号 -n 仅向找到的最大（结束）进程号发送信号</li>
</ul>
<h3 id="示例-3"> 示例</h3>
<div><pre><code># pkill -9  php-fpm          //结束所有的 php-fpm 进程
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:22:04.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">查看端口占用情况</title>
    <id>https://www.snowji.cn/basic-skills/linux/linux/port-take-up/</id>
    <link href="https://www.snowji.cn/basic-skills/linux/linux/port-take-up/"/>
    <updated>2022-08-25T08:22:04.000Z</updated>
    <content type="html"><![CDATA[<h1 id="查看端口占用情况"> 查看端口占用情况</h1>
<h2 id="losf-命令"> losf 命令</h2>
<p><strong>语法格式</strong>：</p>
<div><pre><code>lsof -i:端口号
</code></pre>
<div><span>1</span><br></div></div><p>示例：</p>
<div><pre><code># lsof -i:8000
COMMAND   PID USER   FD   TYPE   DEVICE SIZE/OFF NODE NAME
nodejs  26993 root   10u  IPv4 37999514      0t0  TCP *:8000 (LISTEN)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src="./images/lsof.png" alt="img" /></p>
<p><strong>注意</strong>：losf -i 需要 root 用户的权限来执行</p>
<p><strong>其他常用的命令</strong>：</p>
<div><pre><code>lsof -i:8080：查看8080端口占用
lsof abc.txt：显示开启文件abc.txt的进程
lsof -c abc：显示abc进程现在打开的文件
lsof -c -p 1234：列出进程号为1234的进程所打开的文件
lsof -g gid：显示归属gid的进程情况
lsof +d /usr/local/：显示目录下被进程开启的文件
lsof +D /usr/local/：同上，但是会搜索目录下的目录，时间较长
lsof -d 4：显示使用fd为4的进程
lsof -i -U：显示所有打开的端口和UNIX domain文件
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="netstat-命令"> netstat 命令</h2>
<p><strong>语法格式</strong>：</p>
<div><pre><code>netstat -tnlp | grep 端口号
</code></pre>
<div><span>1</span><br></div></div><p><strong>常见参数</strong>：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-t</td>
<td>显示 tcp 相关协议的端口情况</td>
</tr>
<tr>
<td>-u</td>
<td>显示 udp 相关协议的端口情况</td>
</tr>
<tr>
<td>-n</td>
<td>不显示别名，显示 IP 地址</td>
</tr>
<tr>
<td>-l</td>
<td>仅列出除与 listen 状态的服务状态</td>
</tr>
<tr>
<td>-p</td>
<td>显示建立相关链接的程序名</td>
</tr>
<tr>
<td>-a</td>
<td>显示所有的端口信息</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<div><pre><code># netstat -tunlp | grep 8000
tcp        0      0 0.0.0.0:8000            0.0.0.0:*               LISTEN      26993/nodejs  
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:22:04.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">权限操作</title>
    <id>https://www.snowji.cn/basic-skills/linux/linux/permission/</id>
    <link href="https://www.snowji.cn/basic-skills/linux/linux/permission/"/>
    <updated>2022-08-25T08:22:04.000Z</updated>
    <content type="html"><![CDATA[<h1 id="权限操作"> 权限操作</h1>
<p><strong>目的</strong>：限制用户对文件的操作</p>
<h2 id="基本权限"> 基本权限</h2>
<p>Linux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定</p>
<p>在 Linux 中我们可以使用 <code>ll</code> 或者<code>ls –l</code> 命令来显示一个文件的属性以及文件所属的用户和组，如：</p>
<div><pre><code><span>[</span>root@test /<span>]</span><span># ls -la</span>
total <span>40</span>
drwxr-xr-x    <span>1</span> root root    <span>84</span> Nov <span>12</span> <span>18</span>:04 <span>.</span>
drwxr-xr-x    <span>1</span> root root    <span>84</span> Nov <span>12</span> <span>18</span>:04 <span>..</span>
-rw-r--r--    <span>1</span> root root    <span>11</span> Jan  <span>7</span>  <span>2019</span> <span>123</span>
lrwxrwxrwx    <span>1</span> root root     <span>7</span> Jun  <span>1</span>  <span>2018</span> bin -<span>></span> usr/bin
drwxr-xr-x    <span>5</span> root root   <span>360</span> Nov <span>12</span> <span>18</span>:04 dev
-rwxr-xr-x    <span>1</span> root root     <span>0</span> Nov <span>12</span> <span>18</span>:04 .dockerenv
drwxr-xr-x    <span>1</span> root root   <span>219</span> Jan <span>21</span> <span>10</span>:52 etc
drwxr-xr-x    <span>3</span> root root    <span>19</span> Nov  <span>5</span>  <span>2019</span> home
lrwxrwxrwx    <span>1</span> root root     <span>7</span> Jun  <span>1</span>  <span>2018</span> lib -<span>></span> usr/lib
lrwxrwxrwx    <span>1</span> root root     <span>9</span> Jun  <span>1</span>  <span>2018</span> lib64 -<span>></span> usr/lib64
drwxr-xr-x    <span>2</span> root root     <span>6</span> Apr <span>11</span>  <span>2018</span> media
drwxr-xr-x    <span>2</span> root root     <span>6</span> Apr <span>11</span>  <span>2018</span> mnt
drwxr-xr-x    <span>1</span> root root    <span>32</span> Dec <span>26</span>  <span>2018</span> opt
dr-xr-xr-x <span>1273</span> root root     <span>0</span> Nov <span>12</span> <span>18</span>:04 proc
-rw-r--r--    <span>1</span> root root  <span>8944</span> Jan  <span>7</span>  <span>2019</span> .readahead
dr-xr-x---    <span>1</span> root root   <span>106</span> Apr  <span>6</span> <span>15</span>:00 root
drwxr-xr-x    <span>1</span> root root    <span>64</span> Jan <span>21</span> <span>11</span>:18 run
lrwxrwxrwx    <span>1</span> root root     <span>8</span> Jun  <span>1</span>  <span>2018</span> sbin -<span>></span> usr/sbin
drwxr-xr-x    <span>2</span> root root     <span>6</span> Apr <span>11</span>  <span>2018</span> srv
dr-xr-xr-x   <span>13</span> root root     <span>0</span> Jul <span>20</span>  <span>2020</span> sys
drwxrwxrwt    <span>1</span> root root <span>20480</span> Apr  <span>7</span> 00:00 tmp
drwxr-xr-x    <span>1</span> root root    <span>94</span> Jun  <span>1</span>  <span>2018</span> usr
drwxr-xr-x    <span>1</span> root root    <span>68</span> Dec <span>26</span>  <span>2018</span> var
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>第一个字符代表这个文件是目录、文件或链接文件等等：</p>
<ul>
<li>[ d ] ：表示目录</li>
<li>[ - ] ：表示文件</li>
<li>[ l ] ：表示为链接文档 ( link file )</li>
<li>[ b ]：表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )</li>
<li>[ c ]：表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )</li>
</ul>
<p>接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合</p>
<ul>
<li>[ r ]：代表可读(read)</li>
<li>[ w ]：代表可写(write)</li>
<li>[ x ]：代表可执行(execute)</li>
</ul>
<div><p>注意</p>
<p>这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已</p>
</div>
<p>每个文件的属性由左边第一部分的 10 个字符来确定（如下图）：</p>
<p><img src="./images/qx.png" alt="linux" /></p>
<p>从左至右用 0-9 这些数字来表示</p>
<ul>
<li>第 0 位确定文件类型</li>
<li>第 1-3 位确定属主（该文件的所有者）拥有该文件的权限</li>
<li>第 4-6 位确定属组（所有者的同组用户）拥有该文件的权限</li>
<li>第 7-9 位确定其他用户拥有该文件的权限</li>
</ul>
<h2 id="修改文件属性"> 修改文件属性</h2>
<h3 id="chgrp"> chgrp</h3>
<p>更改文件属组</p>
<p><strong>语法</strong>:</p>
<div><pre><code><span>chgrp</span> <span>[</span>-R<span>]</span> 属组名 文件名
</code></pre>
<div><span>1</span><br></div></div><p><strong>参数</strong>:
-R：递归更改文件属组，在更改某个目录文件的属组时，加上 -R 的参数，那么该目录下的所有文件的属组都会更改</p>
<h3 id="chown"> chown</h3>
<p>更改文件属主，也可以同时更改文件属组</p>
<p><strong>语法</strong>：</p>
<div><pre><code><span>chown</span> <span>[</span>–R<span>]</span> 属主名 文件名
<span>chown</span> <span>[</span>-R<span>]</span> 属主名：属组名 文件名
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="chmod"> chmod</h3>
<p>更改文件 9 个属性</p>
<p><strong>语法</strong>:</p>
<div><pre><code><span>chmod</span> <span>[</span>-cfvR<span>]</span> <span>[</span>--help<span>]</span> <span>[</span>--version<span>]</span> mode file<span>..</span>.
</code></pre>
<div><span>1</span><br></div></div><p><strong>参数</strong>：</p>
<p>mode：权限设定字串，格式如下 :</p>
<div><pre><code><span>[</span>ugoa<span>..</span>.<span>]</span><span>[</span><span>[</span>+-<span>=</span><span>]</span><span>[</span>rwxX<span>]</span><span>..</span>.<span>]</span><span>[</span>,<span>..</span>.<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>u 表示该文件的拥有者</li>
<li>g 表示与该文件的拥有者属于同一个群体(group)者</li>
<li>o 表示其他以外的人</li>
<li>a 表示这三者皆是</li>
<li><code>\+</code> 表示增加权限</li>
<li><code>-</code>  表示取消权限</li>
<li><code>=</code> 表示唯一设定权限</li>
<li>r 表示可读取，w 表示可写入，x 表示可执行</li>
<li>X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行</li>
</ul>
<p>其他参数说明：</p>
<ul>
<li>-c : 若该文件权限确实已经更改，才显示其更改动作</li>
<li>-f : 若该文件权限无法被更改也不要显示错误讯息</li>
<li>-v : 显示权限变更的详细资料</li>
<li>-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递归的方式逐个变更)</li>
<li>--help : 显示辅助说明</li>
<li>--version : 显示版本</li>
</ul>
<p>Linux 文件属性有两种设置方法，一种是数字，一种是符号:</p>
<ul>
<li>Linux 文件的基本权限就有九个，分别是 <code>owner/group/others</code> 三种身份各有自己的 <code>read/write/execute</code> 权限</li>
<li>数字表示：r : 4、 w : 2、x : 1</li>
<li>每种身份（<code>owner/group/others</code>）各自的三个权限（r/w/x）分数是需要累加的，例如当权限为：[-rwxrwx---] 分数则是：</li>
<li>owner = rwx = 4+2+1 = 7</li>
<li>group = rwx = 4+2+1 = 7</li>
<li>others= --- = 0+0+0 = 0</li>
</ul>
<p><strong>示例</strong>:</p>
<p>将文件 file1.txt 设为所有人皆可读取 :</p>
<div><pre><code><span>chmod</span> ugo+r file1.txt
</code></pre>
<div><span>1</span><br></div></div><p>将文件 file1.txt 设为所有人皆可读取 :</p>
<div><pre><code><span>chmod</span> a+r file1.txt
</code></pre>
<div><span>1</span><br></div></div><p>将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 :</p>
<div><pre><code><span>chmod</span> ug+w,o-w file1.txt file2.txt
</code></pre>
<div><span>1</span><br></div></div><p>为 ex1.py 文件拥有者增加可执行权限:</p>
<div><pre><code><span>chmod</span> u+x ex1.py
</code></pre>
<div><span>1</span><br></div></div><p>将目前目录下的所有文件与子目录皆设为任何人可读取 :</p>
<div><pre><code><span>chmod</span> -R a+r *
</code></pre>
<div><span>1</span><br></div></div><p>此外 chmod 也可以用数字来表示权限如 :</p>
<div><pre><code><span>chmod</span> <span>777</span> <span>file</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:22:04.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Shell 函数</title>
    <id>https://www.snowji.cn/basic-skills/linux/shell/function/</id>
    <link href="https://www.snowji.cn/basic-skills/linux/shell/function/"/>
    <updated>2022-08-25T08:22:04.000Z</updated>
    <content type="html"><![CDATA[<h1 id="shell-函数"> Shell 函数</h1>
<p><strong>函数格式：</strong></p>
<div><pre><code><span>[</span> <span>function</span> <span>]</span> funname <span>[</span><span>(</span><span>)</span><span>]</span>

<span>{</span>

    action<span>;</span>

    <span>[</span>return int<span>;</span><span>]</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>说明：</p>
<ul>
<li>可以带 function fun() 定义，也可以直接 fun() 定义,不带任何参数</li>
<li>return 值返回，如果不加，将以最后一条命令运行结果，作为返回值</li>
</ul>
<p>例：</p>
<div><pre><code><span>#!/bin/bash</span>

<span>funWithReturn</span><span>(</span><span>)</span><span>{</span>
    <span>echo</span> <span>"这个函数会对输入的两个数字进行相加运算..."</span>
    <span>echo</span> <span>"输入第一个数字: "</span>
    <span>read</span> aNum
    <span>echo</span> <span>"输入第二个数字: "</span>
    <span>read</span> anotherNum
    <span>echo</span> <span>"两个数字分别为 <span>$aNum</span> 和 <span>$anotherNum</span> !"</span>
    <span>return</span> <span><span>$((</span>$aNum<span>+</span>$anotherNum<span>))</span></span>
<span>}</span>
funWithReturn
<span>echo</span> <span>"输入的两个数字之和为 <span>$?</span> !"</span>

------------------------------------
结果：
这个函数会对输入的两个数字进行相加运算<span>..</span>.
输入第一个数字: 
<span>1</span>
输入第二个数字: 
<span>2</span>
两个数字分别为 <span>1</span> 和 <span>2</span> <span>!</span>
输入的两个数字之和为 <span>3</span> <span>!</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p><strong>注意：</strong></p>
<ul>
<li>函数返回值通过 $? 获取</li>
<li>所有函数在使用前必须定义</li>
</ul>
<h2 id="函数参数"> 函数参数</h2>
<p>**获取方式：**通过  $n 的形式来获取参数的值</p>
<p>例：</p>
<div><pre><code><span>#!/bin/bash</span>

<span>funWithParam</span><span>(</span><span>)</span><span>{</span>
    <span>echo</span> <span>"第一个参数为 <span>$1</span> !"</span>
    <span>echo</span> <span>"第二个参数为 <span>$2</span> !"</span>
    <span>echo</span> <span>"第十个参数为 <span>$10</span> !"</span>
    <span>echo</span> <span>"第十个参数为 <span>${10}</span> !"</span>
    <span>echo</span> <span>"第十一个参数为 <span>${11}</span> !"</span>
    <span>echo</span> <span>"参数总数有 <span>$#</span> 个!"</span>
    <span>echo</span> <span>"作为一个字符串输出所有参数 <span>$*</span> !"</span>
<span>}</span>
funWithParam <span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span> <span>6</span> <span>7</span> <span>8</span> <span>9</span> <span>34</span> <span>73</span>

---------------------------------------------------
结果：
第一个参数为 <span>1</span> <span>!</span>
第二个参数为 <span>2</span> <span>!</span>
第十个参数为 <span>10</span> <span>!</span>
第十个参数为 <span>34</span> <span>!</span>
第十一个参数为 <span>73</span> <span>!</span>
参数总数有 <span>11</span> 个<span>!</span>
作为一个字符串输出所有参数 <span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span> <span>6</span> <span>7</span> <span>8</span> <span>9</span> <span>34</span> <span>73</span> <span>!</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p><strong>注意：</strong> 当 n&gt;=10 时，需要使用 ${n} 来获取参数</p>
<p><strong>特殊字符处理参数：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">参数处理</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$#</td>
<td style="text-align:left">传递到脚本或函数的参数个数</td>
</tr>
<tr>
<td style="text-align:left">$*</td>
<td style="text-align:left">以一个单字符串显示所有向脚本传递的参数</td>
</tr>
<tr>
<td style="text-align:left">$$</td>
<td style="text-align:left">脚本运行的当前进程ID号</td>
</tr>
<tr>
<td style="text-align:left">$!</td>
<td style="text-align:left">后台运行的最后一个进程的ID号</td>
</tr>
<tr>
<td style="text-align:left">$@</td>
<td style="text-align:left">与$*相同，但是使用时加引号，并在引号中返回每个参数。</td>
</tr>
<tr>
<td style="text-align:left">$-</td>
<td style="text-align:left">显示Shell使用的当前选项，与set命令功能相同。</td>
</tr>
<tr>
<td style="text-align:left">$?</td>
<td style="text-align:left">显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td>
</tr>
</tbody>
</table>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:22:04.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">循环控制</title>
    <id>https://www.snowji.cn/basic-skills/linux/shell/loop/</id>
    <link href="https://www.snowji.cn/basic-skills/linux/shell/loop/"/>
    <updated>2022-08-25T08:22:04.000Z</updated>
    <content type="html"><![CDATA[<h1 id="循环控制"> 循环控制</h1>
<h2 id="for-循环"> for 循环</h2>
<p><strong>语法格式：</strong></p>
<div><pre><code><span>for</span> <span>var</span> <span>in</span> item1 item2 <span>..</span>. itemN
<span>do</span>
    command1
    command2
    <span>..</span>.
    commandN
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>例：</p>
<div><pre><code><span>for</span> <span>loop</span> <span>in</span> <span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span>
<span>do</span>
    <span>echo</span> <span>"The value is: <span>$loop</span>"</span>
<span>done</span>

--------------------------
结果：
The value is: <span>1</span>
The value is: <span>2</span>
The value is: <span>3</span>
The value is: <span>4</span>
The value is: <span>5</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><pre><code><span>#!/bin/bash</span>

<span>for</span> <span>str</span> <span>in</span> This is a string
<span>do</span>
    <span>echo</span> <span>$str</span>
<span>done</span>

-----------------------------
结果：
This
is
a
string
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="while-循环"> while 循环</h2>
<p><strong>语法格式：</strong></p>
<div><pre><code>while condition
do
    command
done
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>例：</p>
<div><pre><code><span>#!/bin/bash</span>
<span>int</span><span>=</span><span>1</span>
<span>while</span><span><span>((</span> $int<span>&lt;=</span><span>5</span> <span>))</span></span>
<span>do</span>
    <span>echo</span> <span>$int</span>
    <span>let</span> <span>"int++"</span>
<span>done</span>

-------------------------------------
结果：
<span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><strong>注意：</strong></p>
<p>上述例子中使用了 Bash let 命令，在变量计算中不需要加上 $ 进行引用</p>
<p><strong>无限循环：</strong></p>
<div><pre><code><span>while</span> <span>:</span>
<span>do</span>
    <span>command</span>
<span>done</span>
或
<span>while</span> <span>true</span>
<span>do</span>
    <span>command</span>
<span>done</span>
或
<span>for</span> <span><span>((</span> <span>;</span> <span>;</span> <span>))</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="until-循环"> until 循环</h2>
<p>until 循环执行一系列命令直至条件为 true 时停止</p>
<p>一般 while 循环优于 until 循环，在某些情况下，until 循环更加有用</p>
<p><strong>语法格式：</strong></p>
<div><pre><code><span>until</span> condition
<span>do</span>
    <span>command</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>例：</p>
<div><pre><code><span>#!/bin/bash</span>

<span>a</span><span>=</span><span>0</span>

<span>until</span> <span>[</span> <span>!</span> <span>$a</span> -lt <span>10</span> <span>]</span>
<span>do</span>
   <span>echo</span> <span>$a</span>
   <span>a</span><span>=</span><span><span>`</span><span>expr</span> $a + <span>1</span><span>`</span></span>
<span>done</span>


----------------------------------
结果：
<span>0</span>
<span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id="case-esac"> case ... esac</h2>
<p><strong>特点：</strong></p>
<ul>
<li>多选择分支语句</li>
<li>取值后面必须为单词 <strong>in</strong>，每一模式必须以右括号结束</li>
</ul>
<p><strong>语法格式：</strong></p>
<div><pre><code><span>case</span> 值 <span>in</span>
模式1<span>)</span>
    command1
    command2
    <span>..</span>.
    commandN
    <span>;</span><span>;</span>
模式2）
    command1
    command2
    <span>..</span>.
    commandN
    <span>;</span><span>;</span>
<span>esac</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>例：</p>
<div><pre><code><span>#!/bin/sh</span>

<span>site</span><span>=</span><span>"runoob"</span>

<span>case</span> <span>"<span>$site</span>"</span> <span>in</span>
   <span>"runoob"</span><span>)</span> <span>echo</span> <span>"菜鸟教程"</span>
   <span>;</span><span>;</span>
   <span>"google"</span><span>)</span> <span>echo</span> <span>"Google 搜索"</span>
   <span>;</span><span>;</span>
   <span>"taobao"</span><span>)</span> <span>echo</span> <span>"淘宝网"</span>
   <span>;</span><span>;</span>
<span>esac</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="break"> break</h2>
<p>break 命令允许跳出所有循环</p>
<p>例：</p>
<div><pre><code><span>#!/bin/bash</span>
<span>while</span> <span>:</span>
<span>do</span>
    <span>echo</span> -n <span>"输入 1 到 5 之间的数字:"</span>
    <span>read</span> aNum
    <span>case</span> <span>$aNum</span> <span>in</span>
        <span>1</span><span>|</span><span>2</span><span>|</span><span>3</span><span>|</span><span>4</span><span>|</span><span>5</span><span>)</span> <span>echo</span> <span>"你输入的数字为 <span>$aNum</span>!"</span>
        <span>;</span><span>;</span>
        *<span>)</span> <span>echo</span> <span>"你输入的数字不是 1 到 5 之间的! 游戏结束"</span>
            <span>break</span>
        <span>;</span><span>;</span>
    <span>esac</span>
<span>done</span>


---------------------------------------------
结果：
输入 <span>1</span> 到 <span>5</span> 之间的数字:3
你输入的数字为 <span>3</span><span>!</span>
输入 <span>1</span> 到 <span>5</span> 之间的数字:7
你输入的数字不是 <span>1</span> 到 <span>5</span> 之间的<span>!</span> 游戏结束
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h2 id="continue"> continue</h2>
<p>跳出所有循环，仅仅跳出当前循环</p>
<p>例：</p>
<div><pre><code><span>#!/bin/bash</span>
<span>while</span> <span>:</span>
<span>do</span>
    <span>echo</span> -n <span>"输入 1 到 5 之间的数字: "</span>
    <span>read</span> aNum
    <span>case</span> <span>$aNum</span> <span>in</span>
        <span>1</span><span>|</span><span>2</span><span>|</span><span>3</span><span>|</span><span>4</span><span>|</span><span>5</span><span>)</span> <span>echo</span> <span>"你输入的数字为 <span>$aNum</span>!"</span>
        <span>;</span><span>;</span>
        *<span>)</span> <span>echo</span> <span>"你输入的数字不是 1 到 5 之间的!"</span>
            <span>continue</span>
            <span>echo</span> <span>"游戏结束"</span>
        <span>;</span><span>;</span>
    <span>esac</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div>]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:22:04.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Shell 运算符</title>
    <id>https://www.snowji.cn/basic-skills/linux/shell/operator/</id>
    <link href="https://www.snowji.cn/basic-skills/linux/shell/operator/"/>
    <updated>2022-08-25T08:22:04.000Z</updated>
    <content type="html"><![CDATA[<h1 id="shell-运算符"> Shell 运算符</h1>
<h2 id="算术运算符"> 算术运算符</h2>
<p><strong>常见运算符：</strong></p>
<p>假定变量 a 为 10，变量 b 为 20</p>
<ul>
<li>
<p>+：加法</p>
<div><pre><code><span><span>`</span><span>expr</span> $a + $b<span>`</span></span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>-：减法</p>
<div><pre><code><span><span>`</span><span>expr</span> $a - $b<span>`</span></span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>*：乘法</p>
<div><pre><code><span><span>`</span><span>expr</span> $a <span>\</span>* $b<span>`</span></span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>/：除法</p>
<div><pre><code><span><span>`</span><span>expr</span> $b / $a<span>`</span></span> 
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>%：取余</p>
<div><pre><code><span><span>`</span><span>expr</span> $b % $a<span>`</span></span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>=：赋值</p>
<div><pre><code><span>a</span><span>=</span><span>$b</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>==：比较两数，相同返回 true</p>
<div><pre><code><span>[</span> <span>$a</span> <span>==</span> <span>$b</span> <span>]</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>!=1：比较两数，不相同返回 true</p>
<div><pre><code><span>[</span> <span>$a</span> <span>!=</span> <span>$b</span> <span>]</span>
</code></pre>
<div><span>1</span><br></div></div></li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>
<p>乘号 * 前边必须加反斜杠 \ 才能实现乘法运算</p>
</li>
<li>
<p>条件表达式要放在括号中</p>
</li>
<li>
<p>条件表达式与括号之间要有空格</p>
</li>
</ul>
<h2 id="关系运算符"> 关系运算符</h2>
<p><strong>特点：</strong></p>
<ul>
<li>只支持数字，不支持字符串</li>
<li>字符串的值是数字，可支持</li>
</ul>
<p><strong>常见运算符：</strong></p>
<p>假定变量 a 为 10，变量 b 为 20</p>
<ul>
<li>
<p>-eq：两数相等，返回 true</p>
<div><pre><code><span>[</span> <span>$a</span> -eq <span>$b</span> <span>]</span> 
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>-ne：两数不相等，返回 true</p>
<div><pre><code><span>[</span> <span>$a</span> -ne <span>$b</span> <span>]</span> 
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>-gt：大于</p>
<div><pre><code><span>[</span> <span>$a</span> -gt <span>$b</span> <span>]</span> 
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>-lt：小于</p>
<div><pre><code><span>[</span> <span>$a</span> -lt <span>$b</span> <span>]</span> 
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>-ge：大于等于</p>
<div><pre><code><span>[</span> <span>$a</span> -ge <span>$b</span> <span>]</span> 
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>-le：小于等于</p>
<div><pre><code><span>[</span> <span>$a</span> -le <span>$b</span> <span>]</span> 
</code></pre>
<div><span>1</span><br></div></div></li>
</ul>
<h2 id="布尔运算符"> 布尔运算符</h2>
<p><strong>常见运算符：</strong></p>
<p>假定变量 a 为 10，变量 b 为 20</p>
<ul>
<li>
<p>！：非运算，表达式为 true 时，返回 false</p>
<div><pre><code><span>[</span> <span>!</span> <span>false</span> <span>]</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>-o：或运算，一个表达式为 true，则返回 true</p>
<div><pre><code><span>[</span> <span>$a</span> -lt <span>20</span> -o <span>$b</span> -gt <span>100</span> <span>]</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>-a：与运算，两个都为 true 才返回 true</p>
<div><pre><code><span>[</span> <span>$a</span> -lt <span>20</span> -a <span>$b</span> -gt <span>100</span> <span>]</span>
</code></pre>
<div><span>1</span><br></div></div></li>
</ul>
<h2 id="逻辑运算符"> 逻辑运算符</h2>
<p><strong>常见运算符：</strong></p>
<p>假定变量 a 为 10，变量 b 为 20</p>
<ul>
<li>
<p>&amp;&amp;：逻辑 and</p>
<div><pre><code><span>[</span><span>[</span> <span>$a</span> -lt <span>100</span> <span>&amp;&amp;</span> <span>$b</span> -gt <span>100</span> <span>]</span><span>]</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>||：逻辑 or</p>
<div><pre><code><span>[</span><span>[</span> <span>$a</span> -lt <span>100</span> <span>||</span> <span>$b</span> -gt <span>100</span> <span>]</span><span>]</span> 
</code></pre>
<div><span>1</span><br></div></div></li>
</ul>
<h2 id="字符串运算符"> 字符串运算符</h2>
<p><strong>常见运算符：</strong></p>
<p>假定变量 a 为 &quot;abc&quot;，变量 b 为 &quot;efg&quot;</p>
<ul>
<li>
<p>=：字符串相等，返回 true</p>
<div><pre><code><span>[</span> <span>$a</span> <span>=</span> <span>$b</span> <span>]</span> 
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>!=：字符串不相等，返回 true</p>
<div><pre><code><span>[</span> <span>$a</span> <span>!=</span> <span>$b</span> <span>]</span> 
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>-z：字符串长度为 0 时，返回 true</p>
<div><pre><code><span>[</span> -z <span>$a</span> <span>]</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>-n：字符串长度不为 0 时，返回 true</p>
<div><pre><code><span>[</span> -n <span>$a</span> <span>]</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>$： 字符串是否为空，不为空返回 true</p>
<div><pre><code><span>[</span> <span>$a</span> <span>]</span>
</code></pre>
<div><span>1</span><br></div></div></li>
</ul>
<h2 id="文件测试运算符"> 文件测试运算符</h2>
<table>
<thead>
<tr>
<th>-b file</th>
<th>检测文件是否是块设备文件，如果是，则返回 true。</th>
<th>[ -b $file ] 返回 false。</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c file</td>
<td>检测文件是否是字符设备文件，如果是，则返回 true。</td>
<td>[ -c $file ] 返回 false。</td>
</tr>
<tr>
<td>-d file</td>
<td>检测文件是否是目录，如果是，则返回 true。</td>
<td>[ -d $file ] 返回 false。</td>
</tr>
<tr>
<td>-f file</td>
<td>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td>
<td>[ -f $file ] 返回 true。</td>
</tr>
<tr>
<td>-g file</td>
<td>检测文件是否设置了 SGID 位，如果是，则返回 true。</td>
<td>[ -g $file ] 返回 false。</td>
</tr>
<tr>
<td>-k file</td>
<td>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td>
<td>[ -k $file ] 返回 false。</td>
</tr>
<tr>
<td>-p file</td>
<td>检测文件是否是有名管道，如果是，则返回 true。</td>
<td>[ -p $file ] 返回 false。</td>
</tr>
<tr>
<td>-u file</td>
<td>检测文件是否设置了 SUID 位，如果是，则返回 true。</td>
<td>[ -u $file ] 返回 false。</td>
</tr>
<tr>
<td>-r file</td>
<td>检测文件是否可读，如果是，则返回 true。</td>
<td>[ -r $file ] 返回 true。</td>
</tr>
<tr>
<td>-w file</td>
<td>检测文件是否可写，如果是，则返回 true。</td>
<td>[ -w $file ] 返回 true。</td>
</tr>
<tr>
<td>-x file</td>
<td>检测文件是否可执行，如果是，则返回 true。</td>
<td>[ -x $file ] 返回 true。</td>
</tr>
<tr>
<td>-s file</td>
<td>检测文件是否为空（文件大小是否大于0），不为空返回 true。</td>
<td>[ -s $file ] 返回 true。</td>
</tr>
<tr>
<td>-e file</td>
<td>检测文件（包括目录）是否存在，如果是，则返回 true。</td>
<td>[ -e $file ] 返回 true。</td>
</tr>
</tbody>
</table>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:22:04.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Shell 参数</title>
    <id>https://www.snowji.cn/basic-skills/linux/shell/parameter/</id>
    <link href="https://www.snowji.cn/basic-skills/linux/shell/parameter/"/>
    <updated>2022-08-25T08:22:04.000Z</updated>
    <content type="html"><![CDATA[<h1 id="shell-参数"> Shell 参数</h1>
<p>脚本获取参数：$n</p>
<p>n：代表参数的位置</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> <span>"Shell 传递参数实例！"</span><span>;</span>
<span>echo</span> <span>"执行的文件名：<span>$0</span>"</span><span>;</span>
<span>echo</span> <span>"第一个参数为：<span>$1</span>"</span><span>;</span>
<span>echo</span> <span>"第二个参数为：<span>$2</span>"</span><span>;</span>
<span>echo</span> <span>"第三个参数为：<span>$3</span>"</span><span>;</span>

$ <span>chmod</span> +x test.sh 
$ ./test.sh <span>1</span> <span>2</span> <span>3</span>
------------------------------------
结果：
Shell 传递参数实例！
执行的文件名：./test.sh
第一个参数为：1
第二个参数为：2
第三个参数为：3
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p><strong>处理参数的特殊字符：</strong></p>
<ul>
<li>
<p>$#：传递到脚本的参数个数</p>
<div><pre><code><span>#!/bin/bash</span>
<span>echo</span> <span>"第一个参数为：<span>$#</span>"</span><span>;</span>

$ ./test.sh <span>1</span> <span>2</span> <span>3</span>
---------------------------------
结果：
参数个数为：3
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
<li>
<p>$*： 以一个单字符串显示所有向脚本传递的参数</p>
<div><pre><code><span>#!/bin/bash</span>
<span>echo</span> <span>"传递的参数作为一个字符串显示：<span>$*</span>"</span><span>;</span>

$ ./test.sh <span>1</span> <span>2</span> <span>3</span>
------------------------------------
结果：
传递的参数作为一个字符串显示：1 <span>2</span> <span>3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
<li>
<p>$$： 脚本运行的当前进程 ID 号</p>
<div><pre><code><span>#!/bin/bash</span>
<span>echo</span> <span>"当前脚本id：<span>$$</span>"</span><span>;</span>

$ ./test.sh <span>1</span> <span>2</span> <span>3</span>
------------------------------------
结果：
当前脚本id：11105
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
<li>
<p>$!： 后台运行的最后一个进程的 ID 号</p>
<div><pre><code><span>#!/bin/bash</span>
<span>echo</span> <span>"最后一个进程id：<span>$$</span>"</span><span>;</span>

$ ./test.sh <span>1</span> <span>2</span> <span>3</span>
------------------------------------
结果：
最后一个进程id：11107
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
<li>
<p>$@： 与 $* 相同，但是使用时加引号，并在引号中返回每个参数</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> <span>"-- \<span>$*</span> 演示 ---"</span>
<span>for</span> <span>i</span> <span>in</span> <span>"<span>$*</span>"</span><span>;</span> <span>do</span>
    <span>echo</span> <span>$i</span>
<span>done</span>

<span>echo</span> <span>"-- \<span>$@</span> 演示 ---"</span>
<span>for</span> <span>i</span> <span>in</span> <span>"<span>$@</span>"</span><span>;</span> <span>do</span>
    <span>echo</span> <span>$i</span>
<span>done</span>

$ ./test.sh <span>1</span> <span>2</span> <span>3</span>
-----------------------------------
结果：
-- <span>$*</span> 演示 ---
<span>1</span> <span>2</span> <span>3</span>
-- <span>$@</span> 演示 ---
<span>1</span>
<span>2</span>
<span>3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div></li>
<li>
<p>$-： 显示 Shell 使用的当前选项</p>
</li>
<li>
<p>$?： 显示最后命令的退出状态，0 表示没有错误</p>
</li>
</ul>
<p><em><em>$</em> 与 $@ 区别：</em>*</p>
<ul>
<li>相同点：都是引用所有参数</li>
<li>不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 &quot; * &quot; 等价于 &quot;1 2 3&quot;（传递了一个参数），而 &quot;@&quot; 等价于 &quot;1&quot; &quot;2&quot; &quot;3&quot;（传递了三个参数）</li>
</ul>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:22:04.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">流程控制</title>
    <id>https://www.snowji.cn/basic-skills/linux/shell/process_control/</id>
    <link href="https://www.snowji.cn/basic-skills/linux/shell/process_control/"/>
    <updated>2022-08-25T08:22:04.000Z</updated>
    <content type="html"><![CDATA[<h1 id="流程控制"> 流程控制</h1>
<h2 id="if-语句"> if 语句</h2>
<p><strong>语法格式：</strong></p>
<div><pre><code><span>if</span> condition
<span>then</span>
    command1 
    command2
    <span>..</span>.
    commandN 
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>例：</p>
<div><pre><code><span>if</span> <span>[</span> <span><span>$(</span><span>ps</span> -ef <span>|</span> <span>grep</span> -c <span>"ssh"</span><span>)</span></span> -gt <span>1</span> <span>]</span>
<span>then</span> 
  <span>echo</span> <span>"true"</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="if-else-语句"> if  else 语句</h2>
<p><strong>语法格式：</strong></p>
<div><pre><code><span>if</span> condition
<span>then</span>
    command1 
    command2
    <span>..</span>.
    commandN
<span>else</span>
    <span>command</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>例：</p>
<div><pre><code><span>num1</span><span>=</span>$<span>[</span><span>2</span>*3<span>]</span>
<span>num2</span><span>=</span>$<span>[</span><span>1</span>+5<span>]</span>
<span>if</span> <span>test</span> $<span>[</span>num1<span>]</span> -eq $<span>[</span>num2<span>]</span>
<span>then</span>
    <span>echo</span> <span>'两个数字相等!'</span>
<span>else</span>
    <span>echo</span> <span>'两个数字不相等!'</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><strong>注意：</strong> 如果 else 分支没有语句执行，就不要写这个 else</p>
<h2 id="if-else-if-else-语句"> if  else-if else 语句</h2>
<p><strong>语法格式：</strong></p>
<div><pre><code><span>if</span> condition1
<span>then</span>
    command1
<span>elif</span> condition2 
<span>then</span> 
    command2
<span>else</span>
    commandN
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>例：</p>
<div><pre><code><span>a</span><span>=</span><span>10</span>
<span>b</span><span>=</span><span>20</span>
<span>if</span> <span>[</span> <span>$a</span> <span>==</span> <span>$b</span> <span>]</span>
<span>then</span>
   <span>echo</span> <span>"a 等于 b"</span>
<span>elif</span> <span>[</span> <span>$a</span> -gt <span>$b</span> <span>]</span>
<span>then</span>
   <span>echo</span> <span>"a 大于 b"</span>
<span>elif</span> <span>[</span> <span>$a</span> -lt <span>$b</span> <span>]</span>
<span>then</span>
   <span>echo</span> <span>"a 小于 b"</span>
<span>else</span>
   <span>echo</span> <span>"没有符合的条件"</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div>]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:22:04.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">EOF</title>
    <id>https://www.snowji.cn/basic-skills/linux/linux/eof/</id>
    <link href="https://www.snowji.cn/basic-skills/linux/linux/eof/"/>
    <updated>2022-08-25T08:22:04.000Z</updated>
    <content type="html"><![CDATA[<h1 id="eof"> EOF</h1>
<p>作用：向文件中自动追加内容(追加的内容比较多)</p>
<h2 id="语法格式"> 语法格式</h2>
<div><pre><code>&lt;&lt;EOF    //开始
....
EOF     //结束
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>PS</strong>：</p>
<ul>
<li>EOF 不是固定的，可以自定义其他</li>
<li>自定义的起始符和结束符要保持一致</li>
</ul>
<h2 id="重定向符号"> 重定向符号</h2>
<div><pre><code>&lt; :输入重定向
&gt; :输出重定向
&gt;&gt; :输出重定向,追加,不覆盖之前内容
&lt;&lt; :标准输入来自命令行的一对分隔号的中间内容.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="实例"> 实例</h2>
<h3 id="以覆盖方式向文件中写入内容"> 以覆盖方式向文件中写入内容</h3>
<div><pre><code>cat &lt;&lt; EOF &gt; test.txt
或
cat &gt; test.txt &lt;&lt; EOF
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src="./images/eof1.png" alt="eof" /></p>
<p>可以看到 test.txt 中的内容被覆盖了</p>
<h3 id="以追加方式向文件中写入内容"> 以追加方式向文件中写入内容</h3>
<p>自定义了 EOF</p>
<div><pre><code>cat &lt;&lt; BEGIN &gt; test.txt
或
cat &gt; test.txt &lt;&lt; BEGIN
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src="./images/eof2.png" alt="eof" /></p>
<p>可以看到 test.txt 中的内容没有被覆盖</p>
<p><strong>重点</strong>：</p>
<ul>
<li>输出的文件如果不存在，会自动创建</li>
</ul>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:22:04.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">文件打包与压缩</title>
    <id>https://www.snowji.cn/basic-skills/linux/linux/compress/</id>
    <link href="https://www.snowji.cn/basic-skills/linux/linux/compress/"/>
    <updated>2022-08-25T08:22:04.000Z</updated>
    <content type="html"><![CDATA[<h1 id="文件打包与压缩"> 文件打包与压缩</h1>
<h2 id="常见压缩文件后缀"> 常见压缩文件后缀</h2>
<table>
<thead>
<tr>
<th>文件后缀</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>.bz2</td>
<td>用 bizp2 压缩的文件</td>
</tr>
<tr>
<td>.gz</td>
<td>用 gizp 压缩的文件</td>
</tr>
<tr>
<td>.xz</td>
<td>用 xz 压缩的文件</td>
</tr>
<tr>
<td>.tar</td>
<td>用 tar 打包的文件</td>
</tr>
<tr>
<td>.tbz</td>
<td>tar 打包时用 bizp2 压缩的文件</td>
</tr>
<tr>
<td>.tgz</td>
<td>tar 打包时用 gzip 压缩的文件</td>
</tr>
<tr>
<td>.zip</td>
<td>用 zip/winzip 压缩的文件</td>
</tr>
<tr>
<td>.rar</td>
<td>用 rar 压缩的文件</td>
</tr>
<tr>
<td>.7z</td>
<td>用 7za 压缩的文件</td>
</tr>
</tbody>
</table>
<h2 id="常用压缩与解压命令"> 常用压缩与解压命令</h2>
<p>压缩的方式有很多种，但常用的有以下几种：</p>
<h3 id="压缩命令"> 压缩命令</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>gzip filename</td>
<td>使用 gzip 压缩</td>
</tr>
<tr>
<td>bzip filename</td>
<td>使用 bzip 压缩</td>
</tr>
<tr>
<td>tar -czvf filename</td>
<td>使用 tar 压缩</td>
</tr>
</tbody>
</table>
<h3 id="常用解压命令"> 常用解压命令</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>gzip -d filename.gz</td>
<td>解压 .gz 格式的文件</td>
</tr>
<tr>
<td>bzip2 -d filename.bz2</td>
<td>解压 .bz2 格式的文件</td>
</tr>
<tr>
<td>tar -xzvf filename.tar.gz</td>
<td>解压 .tar 格式的文件</td>
</tr>
</tbody>
</table>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:22:04.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">DNS 协议</title>
    <id>https://www.snowji.cn/basic-skills/network/dns-protocol/</id>
    <link href="https://www.snowji.cn/basic-skills/network/dns-protocol/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="dns-协议"> DNS 协议</h1>
<h2 id="概述"> 概述</h2>
<p>DNS：Domain Name System，域名系统解析，应用层协议</p>
<p>作用：实现网络 IP 地址和主机域名的映射</p>
<p>端口号：53</p>
<p>使用协议：UDP</p>
<h2 id="域名结构"> 域名结构</h2>
<p><img src="./images/dns.png" alt="dns" /></p>
<h3 id="域名层次结构"> 域名层次结构</h3>
<p>目的：保持唯一性</p>
<p>方法：采用层次结构的命名方法</p>
<ul>
<li>每一个域名都是一个标号序列，用字母、数字和链接符组成</li>
<li>标号序列总长度不能超过 255 个字符，由点号分割成一个个的标号</li>
<li>每个标号应该在 63 个字符之内，可以看成一个层次的域名</li>
<li>级别最低的域名写在左边，最高的域名写在右边</li>
</ul>
<p>例子：常用的 www.baidu.com</p>
<ul>
<li>com：一级域名，表示一个企业域名</li>
<li>baidu：二级域名，指公司名</li>
<li>www：指主机名</li>
</ul>
<h3 id="域名分级"> 域名分级</h3>
<p>域名可以划分为各个子域，子域还可以继续划分为子域的子域，这样形成了顶级域、二级域等</p>
<p>例：xxx.yyy.zzz.com</p>
<p>com：顶级域名</p>
<p>zzz：二级域名</p>
<p>yyy：三级域名</p>
<p>xxx：四级域名</p>
<p>顶级域名分为：</p>
<ul>
<li>国家顶级域名，如：
<ul>
<li>中国：cn</li>
<li>美国：us</li>
<li>英国：uk</li>
</ul>
</li>
<li>通用顶级域名，如：
<ul>
<li>com：公司企业</li>
<li>edu：教育机构</li>
<li>gov：政府部门</li>
<li>int：国际组织</li>
</ul>
</li>
<li>反向域名，如：
<ul>
<li>arpa：用于 PTR 查询(IP 地址转换为域名)</li>
</ul>
</li>
</ul>
<h2 id="域名解析过程"> 域名解析过程</h2>
<p>域名解析总体可分为以下过程：</p>
<ul>
<li>输入域名后，先查找自己主机对应的域名服务器，域名服务器先查找自己的数据库中的数据</li>
<li>如果没有，就向上级域名服务器进行查找，依次类推</li>
<li>最多回溯到根域名服务器, 肯定能找到这个域名的 IP 地址</li>
<li>域名服务器自身也会进行一些缓存，把曾经访问过的域名和对应的 IP 地址缓存起来, 可以加速查找过程，具体可描述如下：</li>
<li>主机先向本地域名服务器进行递归查询</li>
<li>本地域名服务器采用迭代查询，向一个根域名服务器进行查询</li>
<li>根域名服务器告诉本地域名服务器，下一次应该查询的顶级域名服务器的 IP 地址</li>
<li>本地域名服务器向顶级域名服务器进行查询</li>
<li>顶级域名服务器告诉本地域名服务器，下一步查询权限服务器的 IP 地址</li>
<li>本地域名服务器向权限服务器进行查询</li>
<li>权限服务器告诉本地域名服务器所查询的主机的 IP 地址</li>
<li>本地域名服务器最后把查询结果告诉主机</li>
</ul>
<p><strong>递归查询</strong>：</p>
<p>本机向本地域名服务器发出一次查询请求，就静待最终的结果。如果本地域名服务器无法解析，自己会以 DNS 客户机的身份向其它域名服务器查询，直到得到最终的 IP 地址告诉本机</p>
<p><strong>迭代查询</strong>：</p>
<p>本地域名服务器向根域名服务器查询，根域名服务器告诉它下一步到哪里去查询，然后它再去查，每次它都是以客户机的身份去各个服务器查询</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T02:21:36.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">数据类型</title>
    <id>https://www.snowji.cn/basic-skills/linux/shell/type_of_data/</id>
    <link href="https://www.snowji.cn/basic-skills/linux/shell/type_of_data/"/>
    <updated>2022-08-25T08:22:04.000Z</updated>
    <content type="html"><![CDATA[<h1 id="数据类型"> 数据类型</h1>
<h2 id="shell-字符串"> Shell 字符串</h2>
<h3 id="单引号"> 单引号</h3>
<div><pre><code><span>str</span><span>=</span><span>'this is a string'</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>限制：</strong></p>
<ul>
<li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的</li>
</ul>
<div><pre><code><span>greeting_3</span><span>=</span><span>'hello, ${your_name} !'</span>
<span>echo</span> <span>$greeting_3</span>
-----------------------
结果：
hello, runoob <span>!</span> hello, <span>${your_name}</span> <span>!</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li>单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用</li>
</ul>
<h3 id="双引号"> 双引号</h3>
<div><pre><code><span>your_name</span><span>=</span><span>'runoob'</span>
<span>str</span><span>=</span><span>"Hello, I know you are <span title="\&quot;">\"</span><span>$your_name</span><span title="\&quot;">\"</span>! <span title="\n">\n</span>"</span>
<span>echo</span> -e <span>$str</span>

-------------
结果：
Hello, I know you are <span>"runoob"</span><span>!</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><strong>优点：</strong></p>
<ul>
<li>双引号里可以有变量</li>
<li>双引号里可以出现转义字符</li>
</ul>
<h3 id="拼接字符串"> 拼接字符串</h3>
<div><pre><code><span>your_name</span><span>=</span><span>"runoob"</span>
<span># 使用双引号拼接</span>
<span>greeting</span><span>=</span><span>"hello, "</span><span>$your_name</span><span>" !"</span>
<span>greeting_1</span><span>=</span><span>"hello, <span>${your_name}</span> !"</span>
<span>echo</span> <span>$greeting</span>  <span>$greeting_1</span>
<span># 使用单引号拼接</span>
<span>greeting_2</span><span>=</span><span>'hello, '</span><span>$your_name</span><span>' !'</span>
<span>greeting_3</span><span>=</span><span>'hello, ${your_name} !'</span>
<span>echo</span> <span>$greeting_2</span>  <span>$greeting_3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>结果：</p>
<div><pre><code>hello, runoob <span>!</span> hello, runoob <span>!</span>
hello, runoob <span>!</span> hello, <span>${your_name}</span> <span>!</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="字符串常见操作"> 字符串常见操作</h3>
<p><strong>获取字符串长度：</strong></p>
<div><pre><code><span>string</span><span>=</span><span>"abcd"</span>
<span>echo</span> <span>${<span>#</span>string}</span> 
<span>#输出 4</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>提取子字符串：</strong></p>
<p>从字符串第 <strong>2</strong> 个字符开始截取 <strong>4</strong> 个字符 :</p>
<div><pre><code><span>string</span><span>=</span><span>"runoob is a great site"</span>
<span>echo</span> <span>${string<span>:</span>1<span>:</span>4}</span>
<span># 输出 unoo</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>查找子字符串：</strong></p>
<p>查找字符 <strong>i</strong> 或 <strong>o</strong> 的位置(哪个字母先出现就计算哪个) ：</p>
<div><pre><code><span>string</span><span>=</span><span>"runoob is a great site"</span>
<span>echo</span> <span><span>`</span><span>expr</span> index <span>"<span>$string</span>"</span> io<span>`</span></span> 
<span># 输出 4</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>注意</strong>：位置是从 1 开始</p>
<h2 id="shell-数组"> Shell 数组</h2>
<p><strong>特点：</strong></p>
<ul>
<li>支持一维数组，不限定数组大小</li>
<li>数组下标从 0 开始</li>
</ul>
<p><strong>语法：</strong></p>
<p>数组用 () 表示，元素用空格分开</p>
<div><pre><code>数组名<span>=</span><span>(</span>值1 值2 <span>..</span>. 值n<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="数组操作"> 数组操作：</h3>
<p><strong>获取数组元素：</strong></p>
<p><strong>语法：</strong></p>
<ul>
<li>获取单独元素</li>
</ul>
<div><pre><code><span>${数组名<span>[</span>下标<span>]</span>}</span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>valuen</span><span>=</span><span>${array_name<span>[</span>n<span>]</span>}</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>获取所有元素</li>
</ul>
<div><pre><code><span>${array_name<span>[</span>@<span>]</span>}</span> <span>||</span> <span>${array_name<span>[</span>*<span>]</span>}</span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>echo</span> <span>${array_name<span>[</span>@<span>]</span>}</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>获取数组长度：</strong></p>
<div><pre><code><span># 取得数组元素的个数</span>
<span>length</span><span>=</span><span>${<span>#</span>array_name<span>[</span>@<span>]</span>}</span>
<span># 或者</span>
<span>length</span><span>=</span><span>${<span>#</span>array_name<span>[</span>*<span>]</span>}</span>
<span># 取得数组单个元素的长度</span>
<span>lengthn</span><span>=</span><span>${<span>#</span>array_name<span>[</span>n<span>]</span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="注释"> 注释</h2>
<p><strong>单行注释：</strong></p>
<p>以 # 开头</p>
<p><strong>多行注释：</strong></p>
<ul>
<li>
<p>每行以 # 开头</p>
</li>
<li>
<div><pre><code>:<span>&lt;&lt;</span><span>EOF
注释内容...
注释内容...
注释内容...
EOF</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<div><pre><code>:<span>&lt;&lt;</span><span>'
注释内容...
注释内容...
注释内容...
'</span>
或
:<span>&lt;&lt;</span><span>!</span>
注释内容<span>..</span>.
注释内容<span>..</span>.
注释内容<span>..</span>.
<span>!</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></li>
</ul>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:22:04.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Shell 变量</title>
    <id>https://www.snowji.cn/basic-skills/linux/shell/variable/</id>
    <link href="https://www.snowji.cn/basic-skills/linux/shell/variable/"/>
    <updated>2022-08-25T08:22:04.000Z</updated>
    <content type="html"><![CDATA[<h1 id="shell-变量"> Shell 变量</h1>
<h2 id="变量定义"> 变量定义</h2>
<p><strong>语法：</strong></p>
<div><pre><code><span>you_name</span><span>=</span><span>'linux'</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>注意：</strong></p>
<ul>
<li>变量名与等号之间不能有空格</li>
<li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li>
<li>中间不能有空格，可以使用下划线（_）。</li>
<li>不能使用标点符号。</li>
<li>不能使用bash里的关键字（可用help命令查看保留关键字</li>
</ul>
<p><strong>隐式赋值：</strong></p>
<div><pre><code><span>for</span> <span>file</span> <span>in</span> <span><span>`</span><span>ls</span> /etc<span>`</span></span>
或
<span>for</span> <span>file</span> <span>in</span> <span><span>$(</span><span>ls</span> /etc<span>)</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="变量引用"> 变量引用</h2>
<p><strong>语法</strong>：在变量名前加 $ 符号</p>
<div><pre><code><span>your_name</span><span>=</span><span>"qinjx"</span>
<span>echo</span> <span>$your_name</span>
<span>echo</span> <span>${your_name}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>{}：用来识别变量边界</p>
<div><pre><code><span>for</span> <span>file</span> <span>in</span> <span><span>`</span><span>ls</span> /ect<span>`</span></span> 
<span>do</span>
    <span>echo</span> <span>"this is <span>${file}</span>file"</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>变量重新赋值：</strong></p>
<div><pre><code><span>your_name</span><span>=</span><span>"tom"</span>
<span>echo</span> <span>$your_name</span>
<span>your_name</span><span>=</span><span>"alibaba"</span>
<span>echo</span> <span>$your_name</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="只读变量"> 只读变量：</h3>
<p><strong>修饰关键字</strong>：readonly</p>
<p><strong>特点</strong>：值不能被改变</p>
<div><pre><code><span>#!/bin/bash</span>
<span>myUrl</span><span>=</span><span>"https://www.google.com"</span>
<span>readonly</span> myUrl
<span>myUrl</span><span>=</span><span>"https://www.runoob.com"</span>

--------------------
结果：
/bin/sh: NAME: This variable is <span>read</span> only.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="删除变量"> 删除变量</h3>
<p><strong>语法：</strong><code>unset variable_name</code></p>
<div><pre><code><span>#!/bin/sh</span>
<span>myUrl</span><span>=</span><span>"https://www.runoob.com"</span>
<span>unset</span> myUrl
<span>echo</span> <span>$myUrl</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>注意：</strong></p>
<ul>
<li>变量删除后不能被使用</li>
<li>unset 不能删除只读变量</li>
</ul>
<h2 id="变量类型"> 变量类型</h2>
<p>运行 shell 会存在三种变量：</p>
<ul>
<li>
<p>局部变量</p>
<p>当前脚本种定义的变量，仅限于当前脚本访问</p>
</li>
<li>
<p>环境变量</p>
<p>所有的程序都能访问</p>
</li>
<li>
<p>shell 变量</p>
<p>由 shell 程序设置的特殊变量</p>
<p>一部分是局部变量，一部分是环境变量</p>
</li>
</ul>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T08:22:04.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">DHCP 协议</title>
    <id>https://www.snowji.cn/basic-skills/network/dhcp-protocol/</id>
    <link href="https://www.snowji.cn/basic-skills/network/dhcp-protocol/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="dhcp-协议"> DHCP 协议</h1>
<h2 id="概述"> 概述</h2>
<p>DHCP：Dynamic Host Configuration Protocol ，动态主机配置协议</p>
<p>作用：集中管理、动态分配 IP 地址给客户端</p>
<p>端口号：67（服务器）、68（客户端）</p>
<p>使用协议：UDP</p>
<h2 id="dhcp-报文"> DHCP 报文</h2>
<h3 id="报文种类"> 报文种类</h3>
<p>DHCP 中一共有 8 种报文：</p>
<ul>
<li>DHCP  Discover
<ul>
<li>客户端以广播方式发送该报文用来发现 DHCP 服务器，源地址为 0.0.0.0，目的地址为 255.255.255.255</li>
<li>DHCP 服务器收到该报文后发送应答报文，客户端据此知道服务器位置</li>
<li>如果没有得到服务器的回应，客户端会从 169.254.0.0/16 这个地址段中选择一个地址，并每隔 5 分钟重新广播一次</li>
</ul>
</li>
<li>DHCP  Offer
<ul>
<li>服务器收到 Discover 报文后，会在配置的地址池中查找一个合适的 IP 地址，加上租约期限和其他信息，构造成该报文，发送给客户端，源地址为服务器地址，目标地址 255.255.255.255</li>
<li>该报文只是告诉客户端可以提供地址，还需检测该地址是否重复</li>
</ul>
</li>
<li>DHCP  Request
<ul>
<li>未获得 IP 地址的客户端在收到的 Offer 报文中，通常选择第一个应答报文的服务器为自己的目标服务器，随后发送一个广播的 Request 请求报文，告知服务器希望获得的 IP 地址</li>
<li>源地址为 0.0.0.0，目标地址为 255.255.255.255</li>
<li>已获得 IP 地址的客户端在租约期过 50% 时，重新发送 Request 请求延续租约，如果没有收到 ACK 报文，在租期达到 87.5% 时，会再次发送广播的 Request 请求报文以请求续延租约</li>
</ul>
</li>
<li>DHCP  ACK
<ul>
<li>DHCP 服务器收到 Request 请求报文后，根据 Request 报文中携带的用户 MAC 来查找有没有相应的租约记录，如果有则发送 ACK 应答报文，通知用户可以使用分配的 IP 地址</li>
<li>客户端收到该报文时，会发送三个针对此 IP 地址的 ARP 解析请求执行冲突检测</li>
</ul>
</li>
<li>DHCP  NAK
<ul>
<li>如果 DHCP 服务器收到 Request 请求报文后，没有发现有相应的租约记录或者由于某些原因无法正常分配IP地址，则向 DHCP 客户端发送 NAK 应答报文，通知用户无法分配合适的 IP 地址</li>
</ul>
</li>
<li>DHCP  Release
<ul>
<li>DHCP 客户端不再需要使用分配 IP 地址时( 一般出现在客户端关机、下线等状况 )，主动向 DHCP 服务器发送 RELEASE 请求报文，告知服务器用户不再需要分配 IP 地址，请求 DHCP 服务器释放对应的IP地址</li>
</ul>
</li>
<li>DHCP  Decline
<ul>
<li>DHCP 客户端收到 DHCP 服务器 ACK 应答报文后，通过地址冲突检测发现服务器分配的地址冲突或者由于其他原因导致不能使用，则会向 DHCP 服务器发送 Decline 请求报文，通知服务器所分配的 IP 地址不可用，以期望获得新的 IP 地址</li>
</ul>
</li>
<li>DHCP  Inform
<ul>
<li>DHCP 客户端如果需要从 DHCP 服务器端获取更为详细的配置信息，则向 DHCP 服务器发送Inform 请求报文</li>
<li>DHCP 服务器在收到该报文后，将根据租约进行查找到相应的配置信息后，向 DHCP 客户端发送 ACK 应答报文</li>
</ul>
</li>
</ul>
<h3 id="工作过程"> 工作过程</h3>
<p>正常的获取 IP 地址的过程如下：</p>
<p><svg id="SvgjsSvg1006" width="631" height="227" xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.com/svgjs"><defs id="SvgjsDefs1007"><marker id="SvgjsMarker1022" markerWidth="14" markerHeight="10" refX="10" refY="5" viewBox="0 0 14 10" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1023" d="M0,0 L14,5 L0,10 L0,0" fill="#323232" stroke="#323232" stroke-width="1"></path></marker><marker id="SvgjsMarker1032" markerWidth="14" markerHeight="10" refX="10" refY="5" viewBox="0 0 14 10" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1033" d="M0,0 L14,5 L0,10 L0,0" fill="#323232" stroke="#323232" stroke-width="1"></path></marker><marker id="SvgjsMarker1042" markerWidth="14" markerHeight="10" refX="10" refY="5" viewBox="0 0 14 10" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1043" d="M0,0 L14,5 L0,10 L0,0" fill="#323232" stroke="#323232" stroke-width="1"></path></marker><marker id="SvgjsMarker1052" markerWidth="14" markerHeight="10" refX="10" refY="5" viewBox="0 0 14 10" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1053" d="M0,0 L14,5 L0,10 L0,0" fill="#323232" stroke="#323232" stroke-width="1"></path></marker></defs><g id="SvgjsG1008" transform="translate(25,46)"><path id="SvgjsPath1009" d="M 0 4Q 0 0 4 0L 96 0Q 100 0 100 4L 100 148Q 100 152 96 152L 4 152Q 0 152 0 148Z" stroke="rgba(50,50,50,1)" stroke-width="2" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1010"><text id="SvgjsText1011" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="80px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="66.375" transform="rotate(0)"><tspan id="SvgjsTspan1012" dy="16" x="50"><tspan id="SvgjsTspan1013" style="text-decoration:;">DHCP 客户端</tspan></tspan></text></g></g><g id="SvgjsG1014" transform="translate(504,50)"><path id="SvgjsPath1015" d="M 0 4Q 0 0 4 0L 98 0Q 102 0 102 4L 102 148Q 102 152 98 152L 4 152Q 0 152 0 148Z" stroke="rgba(50,50,50,1)" stroke-width="2" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1016"><text id="SvgjsText1017" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="82px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="66.375" transform="rotate(0)"><tspan id="SvgjsTspan1018" dy="16" x="51"><tspan id="SvgjsTspan1019" style="text-decoration:;">DHCP 服务端</tspan></tspan></text></g></g><g id="SvgjsG1020"><path id="SvgjsPath1021" d="M146 56L315.5 56L315.5 56L485 56" stroke="#323232" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1022)"></path></g><g id="SvgjsG1024" transform="translate(156,25)"><path id="SvgjsPath1025" d="M 0 0L 317 0L 317 25L 0 25Z" stroke="none" fill="none"></path><g id="SvgjsG1026"><text id="SvgjsText1027" font-family="微软雅黑" text-anchor="middle" font-size="14px" width="317px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="14px" weight="400" font-style="" opacity="1" y="1.75" transform="rotate(0)"><tspan id="SvgjsTspan1028" dy="17" x="158.5"><tspan id="SvgjsTspan1029" style="text-decoration:;">第 1 步：客户端发送 Discover 广播消息</tspan></tspan></text></g></g><g id="SvgjsG1030"><path id="SvgjsPath1031" d="M486 103L316.5 103L316.5 103L147 103" stroke="#323232" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1032)"></path></g><g id="SvgjsG1034" transform="translate(156,73)"><path id="SvgjsPath1035" d="M 0 0L 317 0L 317 25L 0 25Z" stroke="none" fill="none"></path><g id="SvgjsG1036"><text id="SvgjsText1037" font-family="微软雅黑" text-anchor="middle" font-size="14px" width="317px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="14px" weight="400" font-style="" opacity="1" y="1.75" transform="rotate(0)"><tspan id="SvgjsTspan1038" dy="17" x="158.5"><tspan id="SvgjsTspan1039" style="text-decoration:;">第 2 步：服务端回应 Offer，提供地址租约</tspan></tspan></text></g></g><g id="SvgjsG1040"><path id="SvgjsPath1041" d="M147 147L316.5 147L316.5 147L486 147" stroke="#323232" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1042)"></path></g><g id="SvgjsG1044" transform="translate(156,121)"><path id="SvgjsPath1045" d="M 0 0L 317 0L 317 25L 0 25Z" stroke="none" fill="none"></path><g id="SvgjsG1046"><text id="SvgjsText1047" font-family="微软雅黑" text-anchor="middle" font-size="14px" width="317px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="14px" weight="400" font-style="" opacity="1" y="1.75" transform="rotate(0)"><tspan id="SvgjsTspan1048" dy="17" x="158.5"><tspan id="SvgjsTspan1049" style="text-decoration:;">第 3 步：客户端选择并发送 Request 请求地址租用</tspan></tspan></text></g></g><g id="SvgjsG1050"><path id="SvgjsPath1051" d="M486 188L318 188L318 188L150 188" stroke="#323232" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1052)"></path></g><g id="SvgjsG1054" transform="translate(156,161)"><path id="SvgjsPath1055" d="M 0 0L 329 0L 329 23L 0 23Z" stroke="none" fill="none"></path><g id="SvgjsG1056"><text id="SvgjsText1057" font-family="微软雅黑" text-anchor="middle" font-size="14px" width="329px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="14px" weight="400" font-style="" opacity="1" y="0.75" transform="rotate(0)"><tspan id="SvgjsTspan1058" dy="17" x="164.5"><tspan id="SvgjsTspan1059" style="text-decoration:;">第 4 步：服务端发送 ACK 确认将地址租用给客户端</tspan></tspan></text></g></g></svg>
如果地址租约快到期时，会重新发送 Request 请求续约</p>
<h3 id="数据包"> 数据包</h3>
<p>使用 wireshark 进行数据抓包：</p>
<p><img src="./images/DHCP1.png" alt="discover" /></p>
<p>Discover 包数据：</p>
<p><img src="./images/DHCP2.png" alt="dhcp2" /></p>
<p>Offer 数据包：</p>
<p><img src="./images/DHCP3.png" alt="dhcp3" /></p>
<p>Request 数据包：</p>
<p><img src="./images/DHCP4.png" alt="dhcp4" /></p>
<p>ACK 数据包：</p>
<p><img src="./images/DHCP5.png" alt="dhcp5" /></p>
<h2 id="dhcp-中继"> DHCP 中继</h2>
<p><strong>作用</strong>：在处于不同网段的 DHCP 服务器和客户端之间转发 DHCP 数据包</p>
<p><strong>过程</strong>：</p>
<p>服务端与客户端属于不同网段</p>
<p><img src="./images/DHCP6.png" alt="dhcp6" /></p>
<ul>
<li>客户端发送的报文均由中继发送到 DHCP 服务器</li>
<li>DHCP 发送的消息由中继转发给客户端</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T02:21:36.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">ARP 协议</title>
    <id>https://www.snowji.cn/basic-skills/network/arp-protocol/</id>
    <link href="https://www.snowji.cn/basic-skills/network/arp-protocol/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="arp-协议"> ARP 协议</h1>
<p>简介：ARP 全称 Address Resolution Protocol，地址解析协议</p>
<p>目的：实现 IP 地址到 MAC 地址的转换</p>
<p><strong>MAC 地址</strong>：</p>
<ul>
<li>设备的唯一标识，基本在出厂时就已经固定，且不易更改，一般为48 位</li>
<li>是数据链路层能够识别的地址</li>
</ul>
<p>Windows 查看 MAC 地址：</p>
<div><pre><code>ipconfig /all
</code></pre>
<div><span>1</span><br></div></div><p><img src="./images/mac.jpg" alt="mac" /></p>
<p><strong>IP 地址</strong>：</p>
<ul>
<li>是网络层标识的地址</li>
<li>一般都是人为指定的，32 位，常用点分十进制表示</li>
</ul>
<p>在 OSI 模型中，一方发送数据时，需要从上到下对数据进行封装，另一方收到数据时需要对数据从上到下进行解包，但是网络层识别的是 IP 地址，数据链路层识别的是 MAC 地址，因此需要对 IP 和 MAC 进行映射。</p>
<p>具体介绍可以参考<a href="/basic-skills/network/IP%E5%9C%B0%E5%9D%80">IP地址</a></p>
<h2 id="arp-原理之请求应答"> ARP 原理之请求应答</h2>
<p><strong>ping 命令之 ARP 请求应答例子</strong>：</p>
<p>发送方：PC1，IP 地址为 IP1，MAC 地址为 MAC1</p>
<p>接收方：PC2，IP 地址为 IP2，MAC 地址为 MAC2</p>
<p><img src="./../network/images/ARP.png" alt="arp" /></p>
<p>步骤：</p>
<ul>
<li>
<p>PC1 发送 ping IP2，由上到下封装数据</p>
</li>
<li>
<p>数据链路层封装 PC2 的 MAC</p>
</li>
<li>
<p>PC1 先在本地的 ARP 缓存表中查找</p>
</li>
<li>
<p>本地缓存中没有找到，在同一广播域内发送广播消息寻求 PC2 MAC，如果同一广播域内没有回应，则会通过二层交换机进行转发到其他的局域网内</p>
</li>
<li>
<p>等收到 PC2 的 MAC 地址后，封装到数据中，随后存入本地的缓存表中</p>
</li>
<li>
<p>数据封装完成后，将数据发送给 PC2</p>
</li>
<li>
<p>PC2 收到数据后，开始解包，拿到 PC1 的 MAC 后存入自己本地的缓存</p>
</li>
</ul>
<p><strong>查看 arp 缓存表</strong>：</p>
<div><pre><code>arp -a
</code></pre>
<div><span>1</span><br></div></div><p><img src="./images/ARP.jpg" alt="arp" /></p>
<h2 id="arp-报文"> ARP 报文</h2>
<p><strong>报文格式</strong>：</p>
<p><img src="./images/arp报文格式.jpg" alt="报文格式" /></p>
<p><strong>硬件类型</strong>：表明 ARP 协议实现在哪种类型的网络上<br>
<strong>协议类型</strong>：表示解析协议（上层协议）。这里一般是 0800，即 IP<br>
<strong>硬件地址长度</strong>：MAC 地址长度，此处为 6 个字节<br>
<strong>协议地址长度</strong>：IP 地址长度，此处为 4 个字节<br>
<strong>操作类型</strong>：表示 ARP 协议数据类型。1 表示 ARP 协议请求数据报，2 表示 ARP 协议应答数据报<br>
<strong>源MAC地址</strong>：发送端 MAC 地址<br>
<strong>源IP地址</strong>：发送端 IP 地址<br>
<strong>目标MAC地址</strong>：接收端 MAC 地址<br>
<strong>目标IP地址</strong>：接收端 IP 地址</p>
<p>根据原理描述的过程，在 PC1 ping PC2 时使用 wireshark 抓包如下：</p>
<ul>
<li>
<p>ARP请求包</p>
<p>PC1 本地 ARP 缓存表中未有 PC2 MAC 地址时，会进行广播</p>
<p><img src="./images/arp请求包.jpg" alt="请求" /></p>
</li>
<li>
<p>ARP 响应包</p>
<p>PC2 收到广播消息后，以单播的形式回复给 PC1</p>
<p><img src="./images/arp响应包.jpg" alt="响应" /></p>
</li>
</ul>
<p>以上所述均在局域网中，跨局域网的需要 代理 ARP 实现</p>
<h2 id="arp-类型"> ARP 类型</h2>
<h3 id="普通-arp"> 普通 ARP</h3>
<p>功能：通过 IP 获得 MAC 地址</p>
<p>工作过程：</p>
<ul>
<li>A 发数据给 B ，先查 ARP 缓存表</li>
<li>缓存表中没有时，发送广播请求</li>
<li>B 收到广播消息后，将 MAC 以单播的形式发给 A</li>
</ul>
<h3 id="翻转-arp-rarp"> 翻转 ARP(RARP)</h3>
<p>功能：通过 MAC 获取 IP 地址</p>
<h3 id="免费-arp"> 免费 ARP</h3>
<p>功能：查询想使用的 IP 地址是否在局域网中已被占用
报文介绍：源目 IP 都是写本机的 IP，源 MAC 写本机的 MAC，目的 MAC 写广播地址
用途：</p>
<ul>
<li>确定设备的 IP 是否与其他设备 IP 冲突，当其他设备接收到免费 ARP 时，就会核对是否与本机 IP冲突，如果冲突了就会返回一个 ARP 应答包告知 IP 地址已被占用</li>
<li>设备改变物理地址时，可以通过免费 ARP 报文通知其他设备更新 ARP 表项</li>
</ul>
<h3 id="代理-arp"> 代理 ARP</h3>
<p>功能：在跨局域网获取 MAC 地址时，由路由器或三层交换机会将自己连接查询者的端口的 MAC 回复给查询者，同时将广播消息发送到其他广播域中</p>
<p>工作过程：</p>
<ul>
<li>网段 A 的设备广播 ARP request 包，源 MAC 写自己的 MAC 地址，目的 MAC 写 FFFF.FFFF.FFFF,网关收到后返回接口的 MAC 地址</li>
<li>A 收到网关返回的 ARP reply 包后更新自己的 ARP 缓存表</li>
<li>A 发出去的包都要通过网关路由器转发，网关路由器再在从网段 B 中广播得到 B 的 MAC 地址</li>
</ul>
<h3 id="逆向-arp"> 逆向 ARP</h3>
<p>功能：通过物理地址获得 IP 地址
一般存在于帧中继网络中，用于实现 IP 和 DLCI 地址的映射</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T02:21:36.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">网络基础</title>
    <id>https://www.snowji.cn/basic-skills/network/</id>
    <link href="https://www.snowji.cn/basic-skills/network/"/>
    <updated>2022-08-26T02:37:12.000Z</updated>
    <content type="html"><![CDATA[<h1 id="网络基础"> 网络基础</h1>
<h2 id="简介"> 简介</h2>
<p>网络是由若干节点和链接这些节点的链路构成，是信息传输、接收、共享的虚拟平台，实现了资源共享。</p>
<h2 id="网络四要素"> 网络四要素</h2>
<ul>
<li>通信线路和通信设备</li>
<li>有独立功能的计算机</li>
<li>网络软件支持</li>
<li>实现数据通信与资源共享</li>
</ul>
<h2 id="网络分类"> 网络分类</h2>
<h3 id="按拓扑结构分类"> 按拓扑结构分类</h3>
<ul>
<li>总线型</li>
<li>环型</li>
<li>星型</li>
<li>网状</li>
</ul>
<h3 id="按覆盖范围分类"> 按覆盖范围分类</h3>
<ul>
<li>局域网（LAN）：作用范围一般为几米到几十公里</li>
<li>城域网（MAN）：介于 LAN 和 WAN 之间</li>
<li>广域网（WAN）：作用范围一般为几十到几千公里</li>
</ul>
<h3 id="按信息交换方式分类"> 按信息交换方式分类</h3>
<ul>
<li>电路交换</li>
<li>报文交换</li>
<li>报文分组交换</li>
</ul>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T02:37:12.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">HTTP 协议</title>
    <id>https://www.snowji.cn/basic-skills/network/http-protocol/</id>
    <link href="https://www.snowji.cn/basic-skills/network/http-protocol/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="http-协议"> HTTP 协议</h1>
<h2 id="简介"> 简介</h2>
<p>HTTP：Hyper Text Transfer Protocol，超文本传输协议，应用层协议</p>
<p>作用：用于从服务器传输超文本到本地浏览器的传送协议</p>
<p>构成：请求 + 响应</p>
<p>端口号：默认 80，基于 TCP 协议</p>
<p>无状态：协议对于事务处理没有记忆能力</p>
<p>版本：</p>
<ul>
<li>HTTP/1.0 ，发送请求，创建一次连接，获得一个 web 资源，断开连接</li>
<li>HTTP/1.1 ，发送请求，创建一次连接，获得多个 web 资源，断开连接</li>
</ul>
<h2 id="http-请求报文"> HTTP 请求报文</h2>
<p>组成：请求行 + 请求头 + 请求体</p>
<p><img src="./images/http1.png" alt="header" /></p>
<h3 id="请求行"> 请求行</h3>
<p><strong>格式</strong>：请求方式 资源路径 协议版本</p>
<p>如：<code>post /api/ HTTP/1.1</code></p>
<h4 id="请求方式"> 请求方式</h4>
<p>在 REST 架构分隔中，有严格规定对于不同的请求类型要设置合适的请求方法，可参考 <a href="/test/interface-test/Restful规范/">Restful规范</a></p>
<ul>
<li>GET
<ul>
<li>将请求参数追加在 URL 后面，不安全</li>
<li>URL 长度限制 GET 请求方式数据的大小</li>
<li>没有请求体</li>
</ul>
</li>
<li>POST
<ul>
<li>请求参数在请求体中，相对于 GET 来说较安全</li>
<li>请求数据大小没有限制</li>
</ul>
</li>
<li>HEAD
<ul>
<li>服务端值返回响应头，没有响应内容</li>
</ul>
</li>
<li>DELETE
<ul>
<li>删除一个资源</li>
</ul>
</li>
<li>OPTIONS
<ul>
<li>用于获取当前 URL 所支持的方法</li>
<li>请求成功后，会在HTTP头中包含一个名为 “Allow” 的头，值是所支持的方法</li>
</ul>
</li>
<li>TRACE
<ul>
<li>回显服务器收到的请求，主要用于测试或诊断</li>
</ul>
</li>
<li>CONNECT
<ul>
<li>HTTP/1.1 协议预留的，能够将连接改为管道方式的代理服务器</li>
<li>通常用于 SSL 加密服务器的链接与非加密的 HTTP 代理服务器的通信</li>
</ul>
</li>
</ul>
<h3 id="请求头"> 请求头</h3>
<p>如：<code>Host:39.108.107.149:8080</code></p>
<p>请求头从第二行开始，到第一个空格结束</p>
<p>常以键值对 {key:value} 方式</p>
<p><strong>常见请求头</strong>：</p>
<table>
<thead>
<tr>
<th style="text-align:left">请求头</th>
<th>解释</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Referer</td>
<td>表示从哪个 URL 跳转来的</td>
<td>Referer: http://www.zcmhi.com/archives/71.html</td>
</tr>
<tr>
<td style="text-align:left">Accept</td>
<td>指定客户端能够接收的内容类型</td>
<td>Accept: text/plain, text/html</td>
</tr>
<tr>
<td style="text-align:left">Cokkie</td>
<td>HTTP 请求发送时，会把保存在该请求域名下的所有cookie 值一起发送给web服务器</td>
<td>Cookie: $Version=1; Skin=new;</td>
</tr>
<tr>
<td style="text-align:left">User-Agent</td>
<td>User-Agent的内容包含发出请求的用户信息</td>
<td>User-Agent: Mozilla/5.0 (Linux; X11)</td>
</tr>
<tr>
<td style="text-align:left">Connection</td>
<td>表示是否需要持久连接，HTTP 1.1 默认进行持久连接</td>
<td>Connection: close</td>
</tr>
<tr>
<td style="text-align:left">Host</td>
<td>指定请求的服务器的域名和端口号</td>
<td>Host: www.zcmhi.com</td>
</tr>
<tr>
<td style="text-align:left">Content-Type</td>
<td>请求的与实体对应的 MIME 信息</td>
<td>Content-Type: application/x-www-form-urlencoded</td>
</tr>
<tr>
<td style="text-align:left">Accept-Encoding</td>
<td>指定浏览器可以支持的 web 服务器返回内容压缩编码类型</td>
<td>Accept-Encoding: compress, gzip</td>
</tr>
<tr>
<td style="text-align:left">Cache-Control</td>
<td>指定请求和响应遵循的缓存机制</td>
<td>Cache-Control: no-cache</td>
</tr>
</tbody>
</table>
<p>更多请求头属性可参考 <a href="http://tools.jb51.net/table/http_header" target="_blank" rel="noopener noreferrer">HTTP请求头信息对照表</a></p>
<h3 id="请求体"> 请求体</h3>
<p>当请求方式是 POST 时，请求体会有请求的参数，格式如下：</p>
<div><pre><code><span>{</span>
    'username'<span>:</span> 'zhangsan'<span>,</span>
    'password'<span>:</span> '<span>123456</span>'
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="http-响应报文"> HTTP 响应报文</h2>
<p>组成：响应行 + 响应头 + 响应体</p>
<p><img src="./images/http2.png" alt="response" /></p>
<h3 id="响应行"> 响应行</h3>
<p>格式：HTTP 版本 返回状态码  状态码描述</p>
<p>如：</p>
<div><pre><code>HTTP/1.1 200 OK
</code></pre>
<div><span>1</span><br></div></div><h4 id="状态码"> 状态码</h4>
<ul>
<li>1xx: 信息，请求收到了，继续处理</li>
<li>2xx: 代表成功. 行为被成功地接收、理解及采纳
<ul>
<li>200 OK [GET]: 服务器端成功返回用户请求的数据</li>
<li>201 CREATED [POST/PUT/PATCH]: 用户新建或修改数据成功</li>
<li>202 Accepted: 表示一个请求已经进入后台排队（一般是异步任务）</li>
<li>204 NO CONTENT -[DELETE]: 用户删除数据成功</li>
</ul>
</li>
<li>3xx: 重定向</li>
<li>4xx: 客户端错误，请求包含语法错误或请求无法实现
<ul>
<li>400：Bad Request - [POST/PUT/PATCH]: 用户发出的请求有错误，服务器不理解客户端的请求，未做任何处理</li>
<li>401: Unauthorized 表示用户没有权限(令牌、用户名、密码错误)</li>
<li>403：Forbidden: 表示用户得到授权了，但是访问被禁止了, 也可以理解为不具有访问资源的权限</li>
<li>404：Not Found: 所请求的资源不存在，或不可用</li>
<li>405：Method Not Allowed: 用户已经通过了身份验证, 但是所用的 HTTP 方法不在它的权限之内</li>
<li>406：Not Acceptable: 用户的请求的格式不可得(比如用户请求的是 JSON 格式，但是只有XML 格式)</li>
<li>410：Gone - [GET]: 用户请求的资源被转移或被删除，且不会再得到的</li>
<li>415: Unsupported Media Type: 客户端要求的返回格式不支持，比如，API 只能返回 JSON 格式，但是客户端要求返回 XML 格式</li>
<li>422：Unprocessable Entity: 客户端上传的附件无法处理，导致请求失败</li>
<li>429：Too Many Requests: 客户端的请求次数超过限额</li>
</ul>
</li>
<li>5xx: 服务器端错误
<ul>
<li>500：INTERNAL SERVER ERROR 服务器发生错误</li>
<li>502：网关错误</li>
<li>503: Service Unavailable 服务器端当前无法处理请求</li>
<li>504：网关超时</li>
</ul>
</li>
</ul>
<h3 id="响应头"> 响应头</h3>
<p>响应头也是用键值对 <code>k：v</code></p>
<p><strong>常见响应头</strong>：</p>
<table>
<thead>
<tr>
<th>常见响应头</th>
<th>解释</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Location</td>
<td>用来重定向接收方到非请求 URL 的位置来完成请求或标识新的资源</td>
<td>Location: http://www.zcmhi.com/archives/94.html</td>
</tr>
<tr>
<td>Content-Type</td>
<td>返回内容的 MIME 类型</td>
<td>Content-Type: text/html; charset=utf-8</td>
</tr>
<tr>
<td>Set-Cookie</td>
<td>设置 Http Cookie</td>
<td>Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>web 服务器支持的返回内容压缩编码类型</td>
<td>Content-Encoding: gzip</td>
</tr>
<tr>
<td>Content-length</td>
<td>响应体的长度</td>
<td>Content-Length: 348</td>
</tr>
<tr>
<td>Refresh</td>
<td>应用于重定向或一个新的资源被创造，在 5 秒之后重定向（由网景提出，被大部分浏览器支持）</td>
<td>Refresh: 5; url=http://www.zcmhi.com/archives/94.html</td>
</tr>
<tr>
<td>Server</td>
<td>web 服务器软件名称</td>
<td>Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>告诉所有的缓存机制是否可以缓存及哪种类型</td>
<td>Cache-Control: no-cache</td>
</tr>
</tbody>
</table>
<p>更多响应头属性可参考 <a href="http://tools.jb51.net/table/http_header" target="_blank" rel="noopener noreferrer">HTTP响应头信息对照表</a></p>
<h3 id="响应体"> 响应体</h3>
<p>是服务器回写给客户端的页面正文，浏览器将正文加载到内存，然后解析渲染显示页面内容</p>
<h2 id="http-扩展"> HTTP 扩展</h2>
<h3 id="传输文件过大"> 传输文件过大</h3>
<p>对于服务器返回的资源文件过大时，通常有以下方式解决方法：</p>
<h4 id="压缩文件"> 压缩文件</h4>
<ul>
<li>服务端需要能支持文件的压缩功能，浏览器能够针对被压缩的文件进行解压缩</li>
<li>浏览器可以指定 Accept-Encoding 来告诉服务器我当前支持的编码类型 <code>Accept-Encoding:gzip,deflate</code>，那服务端会根据支持的编码类型，选择合适的类型进行压缩</li>
<li>常见的编码方式有：<code>gzip/deflate</code></li>
</ul>
<h4 id="分割传输"> 分割传输</h4>
<p>传输大容量数据时，通过分块传输编码 ，把数据分割成多块，能够让浏览器逐步显示页面</p>
<h3 id="请求连接"> 请求连接</h3>
<p>HTTP 1.0 版本：</p>
<ul>
<li>每一次通信都必须重新进行一次 TCP 连接，增加了通信开销</li>
<li>发送请求后需等待并收到响应，才能发送下一个请求</li>
</ul>
<p>HTTP 1.1 版本：</p>
<ul>
<li>通过 <code>Connection:Keep-Alive</code> 字段保持持久链接，即只需要进行一次 TCP 连接，极大减少了连接开销</li>
<li>事务处理结束之后将连接关闭，必须向报文中显示地添加一个 <code>Connection：close</code> 首部</li>
<li>允许在持久连接上使用请求管道，能同时并行发送多个请求</li>
</ul>
<h3 id="无状态"> 无状态</h3>
<p>HTTP 协议本身不会对请求和响应之间的通信状态做保存</p>
<p>无状态例子：</p>
<p>访问一个 电商网站，先登录，然后去选购商品，当点击一个商品加入购物车以后又提示你登录</p>
<p><strong>通常使用以下解决方案解决 HTTP 无状态</strong>：</p>
<ul>
<li>Cookies(客户端支持)</li>
<li>Session(服务端支持)</li>
<li>token</li>
</ul>
<p>具体原理请参考 <a href="/test/interface-test/三种状态机制.html">三种状态机制</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T02:21:36.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">HTTPS 协议</title>
    <id>https://www.snowji.cn/basic-skills/network/https-protocol/</id>
    <link href="https://www.snowji.cn/basic-skills/network/https-protocol/"/>
    <updated>2022-09-02T02:21:36.000Z</updated>
    <content type="html"><![CDATA[<h1 id="https-协议"> HTTPS 协议</h1>
<h2 id="什么是-https-协议"> 什么是 HTTPS 协议</h2>
<p>HTTPS：Hyper Text Transfer Protocol over SecureSocket Layer</p>
<ul>
<li>在 HTTP 上建立 SSL 加密层，并对传输数据进行加密</li>
<li>是 HTTP 协议的安全版</li>
</ul>
<p>HTTPS 主要作用是：</p>
<ul>
<li>对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全</li>
<li>对网站服务器进行真实身份认证</li>
</ul>
<p>组成部分：HTTP + SSL/TLS</p>
<p><img src="./images/https1.png" alt="https" /></p>
<h2 id="https-连接建立过程"> HTTPS 连接建立过程</h2>
<p>通过 Wireshark 抓包了解 HTTPS 建立过程</p>
<p><img src="./images/https2.png" alt="https" /></p>
<p>可以看出连接建立过程：</p>
<ul>
<li>TCP 三次握手</li>
<li>SSL/TLS 握手</li>
<li>数据传输</li>
</ul>
<h3 id="tcp-三次握手"> TCP 三次握手</h3>
<p>这里就不重点展开了，可以参考 <a href="/docs/basic-skills/network/TCP%E5%8D%8F%E8%AE%AE">TCP 三次握手</a></p>
<h3 id="ssl-tls-建立过程"> SSL/TLS 建立过程</h3>
<p><img src="./images/https3.jpg" alt="ssl/tls" /></p>
<h4 id="tsl-第一次握手"> TSL 第一次握手</h4>
<ul>
<li>
<p>客户端向服务器发起加密通信请求，也就是 ClientHello 消息</p>
</li>
<li>
<p>消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的随机数（Client Random）</p>
</li>
<li>
<p>这个随机数会被服务端保留，它是生成对称加密密钥的材料之一</p>
<p><img src="./images/https4.png" alt="ssl/tls" /></p>
</li>
</ul>
<h4 id="tsl-第二次握手"> TSL 第二次握手</h4>
<ul>
<li>
<p>服务端收到 Client Hello 消息后，确认 TSL 版本号是否支持，从密码套件列表中选择一个密码套件，以及生成随机数</p>
</li>
<li>
<p>服务端返回 Server Hello 消息，消息里面有服务器确认的 TLS 版本号，也给出了随机数（Server Random），然后从客户端的密码套件列表选择了一个合适的密码套件</p>
<p><img src="./images/https5.png" alt="ssl/tls" /></p>
</li>
<li>
<p>服务端发送 Server Hello Done 消息，告诉客户端相关信息已给，本次打招呼完毕</p>
<p><img src="./images/https6.png" alt="ssl/tls" /></p>
</li>
<li>
<p>客户端进行证书验证</p>
</li>
</ul>
<h4 id="tsl-第三次握手"> TSL 第三次握手</h4>
<ul>
<li>
<p>客户端验证完证书后，认为可信则继续</p>
</li>
<li>
<p>客户端生成一个新的随机数，并用服务器的 RSA 公钥加密该随机数</p>
</li>
<li>
<p>客户端发送 Change Cipher Key Exchange 消息传送给服务端</p>
<p><img src="./images/https7.png" alt="ssl/tls" /></p>
</li>
<li>
<p>服务端收到后，用 RSA 私钥解密，得到客户端发来的随机数 (pre-master)</p>
</li>
<li>
<p>客户端和服务端双方都共享了三个随机数，分别是 Client Random、Server Random、pre-master</p>
</li>
<li>
<p>双方根据已经得到的三个随机数，生成对称会话密钥（Master Secret），用于对后续的 HTTP 请求/响应的数据加解密</p>
</li>
<li>
<p>生成完会话密钥后，客户端会发送 Change Cipher Spec，告诉服务端开始使用加密方式发送消息</p>
<p><img src="./images/https8.png" alt="ssl/tls" /></p>
</li>
<li>
<p>客户端再发送 Encrypted Handshake Message（Finishd）消息，把之前所有发送的数据做个摘要，再用会话密钥（master secret）加密一下，让服务器做个验证，验证加密通信是否可用和之前握手信息是否有被中途篡改过</p>
<p><img src="./images/https9.png" alt="ssl/tls" /></p>
</li>
</ul>
<p>可以发现，Change Cipher Spec 之前传输的 TLS 握手数据都是明文，之后都是对称密钥加密的密文</p>
<h4 id="tsl-第四次握手"> TSL 第四次握手</h4>
<ul>
<li>服务器同样发送 Change Cipher Spec 和 Encrypted Handshake Message 消息</li>
<li>如果双方都验证加密和解密没问题，那么握手正式完成</li>
<li>握手完成后，使用用会话密钥加解密 HTTP 请求和响应</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T02:21:36.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">IP 地址</title>
    <id>https://www.snowji.cn/basic-skills/network/ip-address/</id>
    <link href="https://www.snowji.cn/basic-skills/network/ip-address/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="ip-地址"> IP 地址</h1>
<h2 id="简介"> 简介</h2>
<p>IP：Internet Protocol Addres ，网际协议地址，是 IP Adress 的缩写</p>
<p>作用：</p>
<ul>
<li>是 IP 协议提供的一种统一的地址格式</li>
<li>为互联网的每一个网络和主机分配一个逻辑地址</li>
</ul>
<p>分类：IPV4 和 IPV6</p>
<h2 id="ipv4"> IPV4</h2>
<p>组成：是一个 32 位的二进制数，通常被分成 4 个 8 位二进制，常用点分十进制进行表示</p>
<h3 id="ipv4-地址类型"> IPV4 地址类型</h3>
<ul>
<li>公有地址
<ul>
<li>由 Inter NIC（Internet Network Information Center 因特网信息中心）负责</li>
<li>IP 地址分配要向 Inter NIC 进行申请</li>
<li>通过公有地址可以直接访问互联网</li>
</ul>
</li>
<li>私有地址
<ul>
<li>属于非注册的地址，为组织机构内部使用</li>
<li>预留了 A B C 三大类地址为内部私有地址</li>
</ul>
</li>
</ul>
<h3 id="ipv4-地址分类"> IPV4 地址分类</h3>
<p>结构：网络号（标识网络）+ 主机号（标识主机）</p>
<h4 id="五大类型地址"> 五大类型地址：</h4>
<ul>
<li>
<p>A 类地址</p>
<p>结构：1 字节的网络地址 + 3 字节的主机地址，最高位必须是 0</p>
<p>地址范围：0.0.0.0 ~ 127.255.255.255</p>
<p>最大网络数：126 = 2^7 -2</p>
<p>最大主机数：16777244</p>
<p>私有地址范围：10.0.0.0 ~ 10.255.255.255</p>
<p>可用 A 类 IP 地址子网掩码：255.0.0.0</p>
</li>
<li>
<p>B 类地址</p>
<p>结构：2 字节的网络地址 + 2 字节的主机地址，最高位必须是 10</p>
<p>地址范围：128.0.0.0 ~ 191.255.255.255</p>
<p>最大网络数：16384 = 2^14 -2</p>
<p>最大主机数：65534</p>
<p>私有地址范围：172.16.0.0 ~ 172.31.255.255</p>
<p>可用 B 类 IP 地址子网掩码：255.255.0.0</p>
</li>
<li>
<p>C 类地址</p>
<p>结构：3 字节的网络地址 + 1 字节的主机地址，最高位必须是 110</p>
<p>地址范围：192.0.0.0 ~ 223.255.255.255</p>
<p>最大网络数：2097125 = 2^21 -2</p>
<p>最大主机数：254</p>
<p>私有地址范围：192.168.0.0 ~ 192.168.255.255</p>
<p>可用 C 类 IP 地址子网掩码：255.255.255.0</p>
</li>
<li>
<p>D 类地址</p>
<p>结构：第一个字节以 ‘1110’ 开始，是一个专门保留的地址</p>
<p>地址范围：224.0.0.0 ~ 239.255.255.255</p>
<p>作用：被用于多点广播中，一次寻址一组计算机</p>
</li>
<li>
<p>E 类地址</p>
<p>结构：第一个字节以 ‘11110’ 开始。是一个专门保留的地址</p>
<p>地址范围：240.0.0.0 ~ 255.255.255.255</p>
<p>作用：保留实验，全 1 的 IP 地址为广播地址</p>
</li>
</ul>
<h2 id="ipv6"> IPV6</h2>
<p>组成：地址长度为 128 位，表示为 X:X:X:X:X:X:X:X，每个 X 是地址的 8个 16位部分的十六进制</p>
<p>范围：0000:0000:0000:0000:0000:0000:0000:0000~ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff</p>
<p>目的：为了补充 IPV4 的地址不足</p>
<p><strong>两种短格式写法</strong>：</p>
<ul>
<li>
<p>省略前导零</p>
<p>例子：1050:0000:0000:0000:0005:0600:300c:326b</p>
<p>简写：1050:0:0:0:5:600:300c:326b</p>
</li>
<li>
<p>双冒号</p>
<p>例子：ff06:0:0:0:0:0:0:c3</p>
<p>简写：ff06::c3</p>
<p><strong>注意</strong>：一个 IP 地址中只可使用一次双冒号</p>
</li>
</ul>
<p><strong>替代格式</strong>：</p>
<ul>
<li>
<p>结构</p>
<p>组合了冒号和点分表示法，将 IPV4 嵌入到 IPV6中</p>
</li>
<li>
<p>作用</p>
<p>混合网络中确保两者之间的兼容性</p>
</li>
</ul>
<p>例子：0:0:0:0:0:ffff:192.1.56.10 或  ::ffff:192.1.56.10/96</p>
<h3 id="ipv6-地址类型"> IPV6 地址类型</h3>
<ul>
<li>
<p>单点广播地址</p>
<p>指定单个接口，发送的信息从发送者送至目标主机</p>
<p><strong>常规两类</strong>：</p>
<ul>
<li>本地链路地址
<ul>
<li>设计本地链路地址以供在单个本地链路（本地网络）上使用</li>
<li>在所有接口上自动配置本地链路地址</li>
<li>用于本地链路地址的前缀是 fe80::/10</li>
<li>路由器不转发目标或源地址信息包含本地链路地址的信息包</li>
</ul>
</li>
<li>全局地址
<ul>
<li>设计全局地址以在任何网络上使用</li>
<li>用于全局地址的前缀以二进制 001 开头</li>
</ul>
</li>
</ul>
<p><strong>特殊两类</strong>：</p>
<ul>
<li>未指定地址
<ul>
<li>未指定地址为 0:0:0:0:0:0:0:0 ，可使用两个冒号（::）来缩写地址</li>
<li>表示没有地址且决不会将其分配给主机</li>
<li>可由尚未对其分配地址的 IPv6 主机使用</li>
</ul>
</li>
<li>回送地址
<ul>
<li>回送地址为 0:0:0:0:0:0:0:1，可缩写为  ::1</li>
<li>节点使用该回送地址向其自身发送信息包</li>
</ul>
</li>
</ul>
</li>
<li>
<p>任意广播地址</p>
<ul>
<li>指定可能在不同位置但共享单个地址的一组接口</li>
<li>发送至任意广播地址的信息包只发往该任意广播组中最近的成员</li>
</ul>
</li>
<li>
<p>多点广播地址</p>
<ul>
<li>指定一组可能在多个位置的接口</li>
<li>用于多点广播地址的前缀是 ff</li>
<li>向多点广播地址发送信息包，那么向该组的每个成员都传递该信息包的一个副本</li>
</ul>
</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T02:21:36.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">ACK Flood 攻击</title>
    <id>https://www.snowji.cn/basic-skills/network/ipsec-internet/ack/</id>
    <link href="https://www.snowji.cn/basic-skills/network/ipsec-internet/ack/"/>
    <updated>2022-09-02T02:21:36.000Z</updated>
    <content type="html"><![CDATA[<h1 id="ack-flood-攻击"> ACK Flood 攻击</h1>
<h2 id="什么是-ack-flood-攻击"> 什么是 ACK Flood 攻击</h2>
<p>是在 TCP 连接建立之后，所有传输的 TCP 报文都是带有 ACK 标志位的数据包</p>
<h2 id="攻击原理"> 攻击原理</h2>
<ul>
<li>接收端在接收到一个带有 ACK 标志位的数据包的时候，需要检查数据包所表示的四元组（源/目的 IP 、源/目的端口）是否存在</li>
<li>如果存在则检查该数据包所表示的状态是否合法，然后再向应用层传递该数据包</li>
<li>如发现数据包不合法，如所指向的目的端口未开放，则操作系统协议栈会回应 RST 包告诉对方此端口不存在</li>
<li>服务器要做两个动作，查表和回应 ACK/RST</li>
</ul>
<h2 id="攻击危害"> 攻击危害</h2>
<ul>
<li>这种攻击方式没有 SYN Flood 给服务器带来的冲击大（SYN Flood 会占用连接）</li>
<li>随机源 IP 的 ACK 小包会被 Server 很快丢弃，所有一定大流量的 ACK 小包冲击才会对 Server 造成影响</li>
<li>几十kpps 的 ACK Flood 不会构成威胁，但更高数量的 ACK Flood 冲击会造成网卡中断频率过高负载过重而停止响应</li>
<li>带有超大载荷的 ACK Flood 攻击，会导致链路拥塞</li>
<li>攻击报文到达服务器导致处理性能耗尽，从而拒绝正常服务</li>
<li>极高速率的变源变端口 ACK Flood 攻击，很容易导致依靠会话转发的设备转发性能降低甚至成网络瘫痪</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T02:21:36.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">网络分层模型</title>
    <id>https://www.snowji.cn/basic-skills/network/network-layer/</id>
    <link href="https://www.snowji.cn/basic-skills/network/network-layer/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="网络分层模型"> 网络分层模型</h1>
<h2 id="osi-七层模型"> OSI 七层模型</h2>
<p><strong>OSI（Open System Interconnect ）</strong>：</p>
<p>开放式系统互联，是 ISO（国际标准化组织）组织的网络互联模型</p>
<h3 id="模型划分及各层功能定义"> 模型划分及各层功能定义</h3>
<p><img src="./../network/images/OSI.jpg" alt="OSI" /></p>
<h4 id="物理层"> 物理层</h4>
<p>所属层级：第一层</p>
<p>作用：通过物理介质传输比特流，实现信号的传输</p>
<p>常用设备：集线器、中继器、调制解调器、网线、双绞线、同轴电缆等传输介质</p>
<h4 id="数据链路层"> 数据链路层</h4>
<p>所属层级：第二层</p>
<p>作用：将比特流组成字节，再将字节组合成帧，使用链路层地址（MAC 地址）来访问介质，并进行差错检测</p>
<p><strong>链路层的 2 个子层</strong>：</p>
<ul>
<li>
<p>逻辑链路控制子层（LLC）</p>
<p>定义了一些字段使上次协议能共享数据链路层，此子层并非必需</p>
</li>
<li>
<p>媒体访问控制子层（MAC）</p>
<p>主要处理 CSMA/CD（带有冲突检测的载波侦听多路访问 ） 算法、数据出错校验、成帧等</p>
</li>
</ul>
<p>常用设备：二层交换机</p>
<p>常见协议：ARP、RARP等</p>
<h4 id="网络层"> 网络层</h4>
<p>所属层级：第三层</p>
<p>作用：通过 IP 地址进行寻址，通过交换机或路由设备选择合适的路由，将源端送来的分组传送给目的端</p>
<p>常用设备：三层交换机、路由器</p>
<p>常见协议：IP、ICMP、IGMP等</p>
<h4 id="传输层"> 传输层</h4>
<p>所属层级：第四层</p>
<p>作用：建立主机端到端的链接，为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题</p>
<p>常见协议：TCP、UDP</p>
<h4 id="会话层"> 会话层</h4>
<p>所属层级：第五层</p>
<p>作用：负责建立、管理、和终止表示层实体之间的通信会话，该层的通信由不同设备中的应用程序之间的服务请求和响应组成</p>
<h4 id="表示层"> 表示层</h4>
<p>所属层级：第六层</p>
<p>作用：</p>
<ul>
<li>提供各种用于应用层数据的编码和转换功能，确保一个系统的应用层发送的数据能被另一个系统的应用层识别。</li>
<li>如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式</li>
<li>数据压缩和加密也是表示层可提供的转换功能之一</li>
</ul>
<h4 id="应用层"> 应用层</h4>
<p>所属层级：第七层</p>
<p>作用：是最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务</p>
<p>常见网络服务协议：HTTP，HTTPS，FTP，POP3、SMTP等</p>
<h3 id="通信特点"> 通信特点</h3>
<p>对等通信：为了使数据分组从源传送到目的地，源端 OSI 模型的每一层都必须与目的端的对等层进行通信，在每一层通信过程中，使用本层自己协议进行通信</p>
<h2 id="tcp-ip-模型"> TCP/IP 模型</h2>
<p>OSI  是理想中的网络参考模型，实际中使用的还是 TCP/IP 五层模型。</p>
<p>TCP/IP 五层协议和OSI的七层协议对应关系如下：</p>
<p><img src="./../network/images/tcp-osi.jpg" alt="tcp" /></p>
<p>由上可以看出，TCP/IP 是将 OSI 最上面的三层统称为应用层，其他每层的功能及协议与 OSI 基本一致。</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T02:21:36.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">ARP 欺骗</title>
    <id>https://www.snowji.cn/basic-skills/network/ipsec-internet/arp-ipsec/</id>
    <link href="https://www.snowji.cn/basic-skills/network/ipsec-internet/arp-ipsec/"/>
    <updated>2022-09-02T02:21:36.000Z</updated>
    <content type="html"><![CDATA[<h1 id="arp-欺骗"> ARP 欺骗</h1>
<p>前提：了解什么是 ARP，可以参考 <a href="/basic-skills/network/ARP%E5%8D%8F%E8%AE%AE">ARP协议</a></p>
<p><strong>注意</strong>：ARP 欺骗是内网（局域网）的一种攻击手段</p>
<h2 id="什么是-arp-欺骗"> 什么是 ARP 欺骗</h2>
<h3 id="正常数据传输"> 正常数据传输：</h3>
<p><img src="./../images/arpqp.png" alt="arp" /></p>
<p>client1 与 client2 通信的过程：</p>
<p><strong>第一步</strong>:</p>
<p>client1 检测到要通信的地址是同一网段的，会发出消息“谁是 192.168.1.3”</p>
<p><strong>第二步</strong>：</p>
<p>交换机端口收到消息后，会将该消息在全局域网类进行关播，并将 client1 连接的端口与 MAC 写入 MAC 地址表中</p>
<p><strong>第三步</strong>：</p>
<ul>
<li>client2 接收到消息后，会回复 client1 “我是 192.168.1.3，MAC 地址是 10-e9-53-15-8b-4c”</li>
<li>client2 会将 client1 的 IP 与 MAC 写入 ARP 缓存表中</li>
<li>交换机收到该消息后，会将 client2 连接的端口与 MAC 写入 MAC 地址表中</li>
<li>client1 会将 client2 的 IP 与 MAC 写入 ARP 缓存表中</li>
</ul>
<p><strong>第四步</strong>:</p>
<p>client1 将数据发送给 client2时，交换机会进行相应端口转发</p>
<p><strong>重点</strong>：</p>
<ul>
<li>ARP 缓存表有失效时间</li>
<li>client1 的缓存未失效时，不会重新发送消息查询 client2 的 MAC 地址</li>
</ul>
<h3 id="被欺骗-的数据传输"> “被欺骗”的数据传输</h3>
<p><img src="./../images/arpqp1.png" alt="arp" /></p>
<p>client1 与 client2 通信的过程：</p>
<p><strong>第一步</strong>:</p>
<p>client1 检测到要通信的地址是同一网段的，会发出消息“谁是 192.168.1.3”</p>
<p><strong>第二步</strong>：</p>
<p>交换机端口收到消息后，会将该消息在全局域网类进行关播，并将 client1 连接的端口与 MAC 写入 MAC 地址表中</p>
<p><strong>第三步</strong>：</p>
<ul>
<li>client3 接收到消息后，疯狂的回复 client1 “我是 192.168.1.3，MAC 地址是 10-e9-53-15-8b-4b”</li>
<li>client3 会将 client1 的 IP 与 MAC 写入 ARP 缓存表中</li>
<li>交换机收到该消息后，会将 client3 连接的端口与 MAC 写入 MAC 地址表中</li>
<li>client1 会将 client3 的 IP 与 MAC 写入 ARP 缓存表中</li>
</ul>
<p><strong>第四步</strong>:</p>
<p>client1 将数据发送给 client2 时，交换机会进行相应端口转发，此时就会转发给 client3</p>
<h3 id="arp-欺骗的原因"> ARP 欺骗的原因</h3>
<p>根据上面的例子可以看出，ARP 存在的原因：</p>
<ul>
<li>在 ARP回复时，发送请求包的主机 client1 并不会验证 ARP 回复包的真实性</li>
<li>client1 不能判断回复自己的是不是主机 client2</li>
<li>由此引出一个局域网攻击方式 ARP 欺骗</li>
</ul>
<h2 id="arp-欺骗的分类"> ARP 欺骗的分类</h2>
<ul>
<li>主机欺骗
如同上面的例子，client3 欺骗 client1</li>
<li>网关欺骗
局域网中的主机欺骗网关，从而获取其他主机的进流量</li>
</ul>
<h2 id="arp-攻击的危害"> ARP 攻击的危害</h2>
<ul>
<li>造成局域网中的其他主机断网</li>
<li>劫持局域网中其他主机或网关的流量，获取敏感信息等</li>
</ul>
<h2 id="如何防御-arp-欺骗"> 如何防御 ARP 欺骗</h2>
<p>ARP 欺骗是通过重复应答实现的，只需要在本机添加一条静态的 ARP 映射，这样就不需要询问网关 MAC 地址了，<strong>这种方法只对主机欺骗有效</strong></p>
<h3 id="步骤"> 步骤</h3>
<h4 id="查看网络"> 查看网络</h4>
<p>用管理身份运行命令提示符，输入 <code>netsh i i show in</code> 查看一下本机有哪些网络连接</p>
<div><pre><code>netsh i i show <span>in</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="查询网关-mac"> 查询网关 MAC</h4>
<p>输入 <code>arp -a</code> 查询本机的网关信息</p>
<div><pre><code>arp -a
</code></pre>
<div><span>1</span><br></div></div><div><p>注意</p>
<p>如果正遭受 ARP 欺骗攻击，通过此方法查处的可能是虚假的 MAC 地址</p>
</div>
<h4 id="绑定-ip-和-mac"> 绑定 IP 和 MAC</h4>
<p>输入以下命令对网关的 IP 和 MAC 添加静态映射</p>
<div><pre><code>netsh -c <span>"i i"</span> <span>add</span> neighbors 连接的Idx号 网关IP 网关MAC
netsh -c <span>"i i"</span> <span>add</span> neighbors <span>9</span> <span>10.60</span>.12.1 4c-5e-0c-64-73-f5
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T02:21:36.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">TCP 协议</title>
    <id>https://www.snowji.cn/basic-skills/network/tcp-protocol/</id>
    <link href="https://www.snowji.cn/basic-skills/network/tcp-protocol/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="tcp-协议"> TCP 协议</h1>
<h2 id="简介"> 简介</h2>
<p>TCP：Transmission Control Protocol，传输控制协议，是一种面向连接（连接导向）的、可靠的、 基于 IP 的传输层协议</p>
<p>网络层级：在 OSI 模型中属于第四层</p>
<p>具体网络层级及功能可以参考 <a href="/basic-skills/network/网络分层/">网络分层</a></p>
<h2 id="tcp-头部结构和字段"> TCP 头部结构和字段</h2>
<p>TCP 报文：TCP 协议是封装在 IP 数据包中</p>
<p><img src="./images/tcp报文.png" alt="TCP报文" /></p>
<p>TCP 报文格式：</p>
<p><img src="./images/TCP1.png" alt="TCPpackage" /></p>
<p>字段解释：</p>
<ul>
<li>源端口和目的端口
<ul>
<li>各占 2 个字节</li>
<li>端口加上源/目的 IP 唯一确定一个 TCP 连接</li>
</ul>
</li>
<li>序号
<ul>
<li>占 4 个字节，是本报文段所发送的数据项目组第一个字节的序号</li>
<li>TCP 传送的数据流中，每一个字节都有一个序号(包含了数据的字节数)</li>
</ul>
</li>
<li>确认序号
<ul>
<li>占 4 个字节，是期望收到对方下次发送的数据的第一个字节的序号</li>
<li>确认序号应该是上次已成功收到数据字节序号 +1</li>
<li>只有 ACK 标志为 1 时，确认序号才有效</li>
</ul>
</li>
<li>数据偏移
<ul>
<li>占 4 比特，表示数据开始的地方离 TCP 段的起始处有多远，即 TCP 段首部的长度</li>
<li>由于首部长度不固定，因此数据偏移字段是必要的</li>
<li>数据偏移以 4 个字节为长度单位</li>
<li>TCP首部的最大长度是 60 个字节，即偏移最大为 15 个长度单位=1532位=154字节</li>
</ul>
</li>
<li>保留
<ul>
<li>6 比特，供以后应用，现在置为 0</li>
</ul>
</li>
<li>6个标志位比特
<ul>
<li>URG：当 URG=1 时，注解此报文应尽快传送，而不要按本来的列队次序来传送。与“紧急指针”字段共同应用，紧急指针指出在本报文段中的紧急数据的最后一个字节的序号，使接管方可以知道紧急数据共有多长</li>
<li>ACK：只有当 ACK=1 时，确认序号字段才有效</li>
<li>PSH：当 PSH=1 时，接收方应该尽快将本报文段立即传送给其应用层</li>
<li>RST：当 RST=1 时，表示出现连接错误，必须释放连接，然后再重建传输连接。复位比特还用来拒绝一个不法的报文段或拒绝打开一个连接</li>
<li>SYN：SYN=1,ACK=0 时表示请求建立一个连接，携带 SYN 标志的 TCP 报文段为同步报文段</li>
<li>FIN：发端完成发送任务</li>
</ul>
</li>
<li>窗口
<ul>
<li>TCP通过滑动窗口的概念来进行流量控制，解决发送端发送数据的速度和接收端接收速度却不一致的情况</li>
<li>滑动窗口可以理解成接收端所能提供的缓冲区大小</li>
<li>TCP 利用一个滑动的窗口来告诉发送端对它所发送的数据能提供多大的缓冲区</li>
<li>窗口大小是一个 16bit 字段，因而窗口大小最大为 65535 字节</li>
</ul>
</li>
<li>校验和
<ul>
<li>检验 TCP 首部和数据，是一个强制性的字段</li>
<li>一定是由发端计算和存储，并由收端进行验证</li>
</ul>
</li>
<li>紧急指针
<ul>
<li>只有当 URG 标志置 1 时紧急指针才有效</li>
<li>紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号</li>
</ul>
</li>
</ul>
<h2 id="tcp-连接"> TCP 连接</h2>
<h3 id="三次握手"> 三次握手</h3>
<p><img src="./images/三次握手.png" alt="三次握手" /></p>
<p><strong>第一次握手</strong>：</p>
<ul>
<li>客户端向服务器发出连接请求报文</li>
<li>报文首部中的同步位 SYN 置为 1，同时随机生成初始序列号 seq=x</li>
<li>TCP 客户端进程进入 SYN-SENT（同步已发送）状态</li>
<li>报文不携带数据</li>
</ul>
<p><strong>第二次握手</strong>：</p>
<ul>
<li>TCP 服务器收到请求报文后，如果同意连接则发出确认报文</li>
<li>确认报文中将 ACK/SYN 置为1，确认号 <code>ack=x+1</code> ，随机初始化一个序列号 <code>seq=y</code></li>
<li>TCP 服务进程进入了 SYN-RCVD（同步收到）状态</li>
<li>报文不携带数据</li>
</ul>
<p><strong>第三次握手</strong>：</p>
<ul>
<li>TCP 客户进程收到确认后，给出确认报文  <code>ACK=1</code>，<code>ack=y+1</code></li>
<li>TCP 连接建立，客户端进入 ESTABLISHED（已建立连接）状态</li>
<li>ACK 报文段可以携带数据</li>
</ul>
<p><strong>思考</strong>：为什么要三次握手，两次握手不行么？</p>
<p>例子：已失效的连接请求报文</p>
<ul>
<li>client 发送了第一个连接的请求报文，由于网络不好，请求没有立即送达服务端，直到某个时间才到达 server</li>
<li>server 收到这个请求报文后，仍向 client 发出确认报文，同意连接</li>
</ul>
<p>不采用三次握手：</p>
<ul>
<li>只要 server 发出确认，新的连接就建立了，不管是否这个请求是已经失效的请求</li>
<li>client 不需要向 server 发送确认请求，server 在连接建立后一直等待 client 发送数据，会导致很多资源被占用</li>
</ul>
<h3 id="四次挥手"> 四次挥手</h3>
<p>目的：为了确保数据能够完成传输</p>
<p>原因：</p>
<ul>
<li>当 server 收到 client 的 FIN 报文时，说明 client 已经没有数据发送到 server 了，但 server 端已经将所有的数据发往 client 了，所以不会立马关闭 SOCKET</li>
<li>先发送 ACK 确认报文，告诉 client FIN 报文收到了</li>
<li>server 发送完所有数据后，发送 FIN 表示可以关闭连接，因此需要 4 次挥手</li>
</ul>
<p>过程：</p>
<p><img src="./images/tcp-fin.png" alt="fin" /></p>
<p><strong>第一次挥手</strong>：</p>
<ul>
<li>TCP 发送一个 FIN（结束），用来关闭 client 到 server 的连接</li>
<li>client 发出连接释放报文，<code>FIN=1</code>，其序列号为 <code>seq=u</code> ，并停止发送数据</li>
<li>client 进入 FIN-WAIT-1（终止等待 1）状态</li>
</ul>
<p><strong>第二次挥手</strong>：</p>
<ul>
<li>server 收到这个 FIN ，发出确认报文 <code>ACK=1</code>，<code>ack=u+1</code>，并且带上自己的序列号 <code>seq=v</code></li>
<li>server 端进入 CLOSE-WAIT（关闭等待）状态</li>
<li>client 收到确认后，client 端进入 FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文</li>
<li>在释放连接请求发送前，client 需要接受 server 发送的最后的数据</li>
</ul>
<p><strong>第三次挥手</strong>：</p>
<ul>
<li>server 发送最后的数据后，发送释放报文，<code>FIN=1</code>，<code>ack=u+1</code></li>
<li>server 进入 LAST-ACK（最后确认）状态，等待 client 确认</li>
</ul>
<p><strong>第四次挥手</strong>：</p>
<ul>
<li>client 收到释放报文后，发出确认报文，<code>ACK=1</code>，<code>ack=w+1</code></li>
<li>client 进入 TIME-WAIT（时间等待）状态</li>
<li>TCP 连接没有立即释放，等报文段寿命（2**MSL）的时间过后，client 撤销相应的 TCP 连接，进入 CLOSED 状态</li>
<li>server 在接收到确认后，立即撤销 TCP 连接，进入 CLOSED 状态</li>
</ul>
<p><strong>思考</strong>：客户端突然挂掉了怎么办？</p>
<p>问题：</p>
<p>正常连接时，client 突然挂掉了，如果没有措施处理这种情况，那么就会出现 client 和 server 端出现长时期的空闲</p>
<p>解决办法：</p>
<p>是在服务器端设置保活计时器，每当服务器收到客户端的消息，就将计时器复位。超时时间通常设置为 2 小时。若服务器超过 2 小时没收到客户的信息，他就发送探测报文段。若发送了 10 个探测报文段，每一个相隔 75 秒，还没有响应就认为客户端出了故障，因而终止该连接</p>
<h2 id="tcp-流量控制"> TCP 流量控制</h2>
<p>解决问题：接受端与发送端速度不一致，可能导致缓存溢出</p>
<p>解决方法：滑动窗口协议，通过<strong>接收方</strong>来控制流量的一种方式</p>
<h3 id="什么是滑动窗口"> 什么是滑动窗口</h3>
<p>接受数据端使用的窗口大小，用于告诉发送端接收端的缓存大小，控制发送端发送数据的大小，达到流量控制的目的</p>
<p><img src="./images/tcp流量控制.png" alt="tcp流量控制" /></p>
<p>过程：</p>
<ul>
<li>发送方接收到了对方发来的报文  <code>ack = 33</code>, <code>win = 10</code>，知道对方收到了 33 号前的数据，现在期望接收 [33, 43) 号数据，那我们开始发送[33, 43) 号的数据</li>
<li>[33, 43) 号的数据你是已经发送了，但接受方并没有接受到 [36,37] 数据，所以接收方发送回对报文段 A 的确认：<code>ack = 35</code>, <code>win = 10</code></li>
<li>发送方收到了 <code>ack = 35</code>, <code>win = 10</code>，对方期望接收 [35, 45) 号数据，那么发送方再发送 [35, 45)</li>
<li>接收方接收到了报文段 [35, 41)，接收方发送：<code>ack = 41</code>, <code>win = 10</code></li>
<li>发送方收到了 <code>ack = 41</code>, <code>win = 10</code>，对方期望接收 [41, 51) 号数据</li>
<li>这样一直传输数据，直到数据发送完成，如果某数据没有获取到，那么ack永远不会跳过它，保证了数据数据的可靠性</li>
</ul>
<p><strong>思考</strong>：</p>
<ul>
<li>第一步发送了 [33, 43)，如果这次发送 [35, 45)，那中间重叠部分不是发送了两次，所以这里要思考重叠的部分是全部重新发送还是只发送接收端没有收到的数据，如果全部发送，那么重复发送的数据接收端怎么处理？</li>
<li>如果某一数据一直没有获取到，会一直这样堵塞在这里？</li>
</ul>
<h2 id="tcp-拥塞控制"> TCP 拥塞控制</h2>
<p>目的：解决发送方可能因为 IP 网络的拥塞而被遏制</p>
<p>解决方法：拥塞控制，通过<strong>发送方</strong>来控制流量的一种方式</p>
<p><strong>拥塞窗口</strong>：</p>
<p>概念：</p>
<ul>
<li>发送方维持一个叫拥塞窗口 cwnd 的状态变量，拥塞窗口的大小取决于网络的拥塞程度，并且动态变化</li>
<li>发送方的让自己的发送窗口 = min（cwnd，接受端接收窗口大小）</li>
<li>发送方取拥塞窗口与滑动窗口的最小值作为发送的上限</li>
</ul>
<h3 id="tcp-拥塞控制几种方法"> TCP 拥塞控制几种方法</h3>
<h4 id="慢启动"> 慢启动</h4>
<p>概念：
TCP 在连接过程的三次握手完成后，开始传数据，为防止网络问题，导致数据包积攒发生拥塞，不能够一开始向网络通道中发送大量的数据包</p>
<p>策略：
在数据发送被对方确认的过程中去计算对方的计算速度，逐步增加每次发送的数据量，达到某一稳定值后，进入高速传输阶段</p>
<p>原理：</p>
<p><img src="./images/man.png" alt="慢启动" /></p>
<h5 id="慢启动的性能"> 慢启动的性能</h5>
<p>存在问题：对拷贝海量小文件的需求会造成重大性能损失</p>
<p>举个例子说明：</p>
<p>对每个文件都采用独立的 TCP 连接传输</p>
<p>工作过程：</p>
<ul>
<li>每传输一个文件建立一个连接，然后连接处于慢启动阶段，传输小文件，每个小文件几乎都处于独立连接的慢启动阶段被传输，这样传输过程所用的 TCP 包的总量就会增多</li>
<li>在慢启动中传输小文件，可能需要 2~3 个小包在一个已经完成慢启动的 TCP 通道中，传输这个文件可能只需要 1个大包</li>
<li>网络文件的拷贝时间基本上都是消耗在网络传输的过程中，如果文件的数量足够大，传输的时间就会被放大</li>
</ul>
<p>如何避免慢启动：</p>
<p>尽量把大量小文件放在一个 TCP 连接中排队传输</p>
<ul>
<li>这种方式减少了发包的数量，降低了时间消耗</li>
<li>避免了大量的 3 次握手和 4 次握手</li>
</ul>
<h4 id="拥塞避免"> 拥塞避免</h4>
<p>前置：慢启动中的拥塞窗口的 cwnd 值开始是 1 ，之后呈指数型增长</p>
<p>方法：TCP 使用了一个叫 <strong>慢启动门限（ssthresh）的变量</strong>，当 <code>cwnd&gt;=ssthresh</code>，慢启动过程结束，进入拥塞避免阶段</p>
<p>拥塞避免：cwnd 的值不再指数级往上升，开始加法增加</p>
<p><img src="./images/cwnd.png" alt="cwnd" /></p>
<p>当窗口中所有的报文段都被确认时，cwnd 的大小加 1，cwnd 的值随 RTT 开始线性增加</p>
<p>逻辑如下：</p>
<ul>
<li>把 ssthresh 降低为 cwnd 值的一半</li>
<li>把 cwnd 重新设置为 1</li>
<li>重新进入慢启动过程</li>
</ul>
<h4 id="快速重传"> 快速重传</h4>
<p>目的：TCP 要保证所有的数据包都可以到达，必须有重传机制</p>
<p>注意：SeqNum 和 Ack 是以字节数为单位，所以 ack 的时候，不能跳着确认，只能确认最大的连续收到的包，不然，发送端就以为之前的都收到了</p>
<p>例子：</p>
<p>发送端发了 1,2,3,4,5 一共五份数据，接收端收到了 1，2，于是回 ack 3，然后收到了 4（注意此时3没收到）此时的 TCP 会怎么办？</p>
<h5 id="超时重传机制"> 超时重传机制</h5>
<p><strong>方法</strong>：</p>
<p>不回 ack，死等 3，当发送方发现收不到 3 的 ack 超时后，会重传 3</p>
<p>存在问题：</p>
<p>因为要死等 3，所以会导致 4 和 5 即便已经收到了，而发送方也完全不知道发生了什么事，因为没有收到Ack，所以，发送方可能会悲观地认为也丢了，所以有可能也会导致 4 和 5 的重传</p>
<p>针对存在的问题有有以下 2 种选择：</p>
<ul>
<li>
<p>仅重传 timeout 的包，即第 3 份数据</p>
<p>会节省带宽，但是慢</p>
</li>
<li>
<p>重传 timeout 后所有的数据，即 3、4、5 三份数据</p>
<p>会快一点，但是很浪费带宽</p>
</li>
</ul>
<h5 id="快速重传机制"> 快速重传机制</h5>
<p>概念：如果包没有连续到达，发送方连续收到 3 次 相同的 ack，就重传</p>
<p>好处：不用等 timeout 了再重传，而是只是三次相同的 ack 就重传</p>
<p>举个例子：</p>
<p>如果发送方发出了 1，2，3，4，5 份数据，第一份先到送了，于是就 ack 回 2，结果 2 因为某些原因没收到，3 到达了，于是还是 ack 回 2，后面的 4 和 5 都到了，但是还是 ack 回 2 ，因为 2 还是没有收到，于是发送端收到了三个 ack=2 的确认，知道了 2 还没有到，于是就马上重转 2。然后，接收端收到了 2，此时因为 3，4，5 都收到了，于是 ack 回 6</p>
<p><img src="./images/fast.png" alt="fast" /></p>
<p>虽然快速重传解决了 timeout 的问题，但依然存在问题：</p>
<p>对于上面的例子还说，是重传 2 还是需要重传 2、3、4、5？因为不知道连续 3 次的 ack2 是谁发的</p>
<p><strong>总结</strong>：不管是超时重传还是快速重传，都只是保证了数据的可靠性，不能解决重传哪些数据的问题</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T02:21:36.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">UDP 协议</title>
    <id>https://www.snowji.cn/basic-skills/network/udp-protocol/</id>
    <link href="https://www.snowji.cn/basic-skills/network/udp-protocol/"/>
    <updated>2022-09-02T02:21:36.000Z</updated>
    <content type="html"><![CDATA[<h1 id="udp-协议"> UDP 协议</h1>
<h2 id="简介"> 简介</h2>
<p>UDP：User Datagram Protocol，用户数据报协议，是一种无连接的传输协议</p>
<p>网络层级：在 OSI 模型中属于第四层</p>
<h2 id="udp-首部格式"> UDP 首部格式</h2>
<p><img src="./images/udp1.png" alt="UDP头部" /></p>
<p>共 8 个字节，一共 4 个字段，每个字段的长度都是 2 个字节：</p>
<ul>
<li>16 位源端口号
发送方的端口号，不用的话可以置为 0</li>
<li>16 位目的端口号
接收方的端口号</li>
<li>16 位 UDP 长度
<ul>
<li>首部 + 数据的总长度，单位为字节</li>
<li>一个 UDP 能传输的数据最大长度是 64k（包含 UDP 首部）</li>
<li>当我们需要传输的数据超过 64k 时，就需要在应用层手动分包，多次发送，并在接收端手动拼接</li>
</ul>
</li>
<li>16 位 UDP 校验和
<ul>
<li>为了接收方进行数据校验设计的</li>
<li>如果校验不通过的话数据会被丢弃</li>
</ul>
</li>
</ul>
<h2 id="udp-的特点"> UDP 的特点</h2>
<ul>
<li>
<p>无连接</p>
<ul>
<li>进行数据传输之前不需要先建立连接</li>
<li>没有各种重传机制、拥塞机制和流量控制</li>
<li>传输速度快，消耗低，延迟小，数据传输效率高</li>
<li>适合对可靠性要求不高或可以保障可靠性的应用程序，如：DNS、TFTP、SNMP 等</li>
</ul>
</li>
<li>
<p>不可靠</p>
<ul>
<li>只负责数据的发送，不关心数据是否到达</li>
<li>没有确认机制，主机收到数据也不会有响应</li>
</ul>
</li>
<li>
<p>面向报文</p>
<ul>
<li>对于应用层交下来的报文段不进行拆分合并，直接保留原有报文段的边界后添加 UDP 的首部就交给网络层</li>
<li>不论报文的长短，UDP 都不会进程处理</li>
<li>避免报文段过短降低传输效率以及报文段过长导致网络层对 IP 数据进行分片操作，应用层应该选择合适长度的报文交付给运输层的 UDP</li>
</ul>
</li>
<li>
<p>没有拥塞控制</p>
</li>
<li>
<p>支持一对一、一对多、多对一和多对多的交互通信</p>
</li>
<li>
<p>首部开销小</p>
<ul>
<li>TCP 的首部字节是 20，UDP 的首部是 8 字节</li>
</ul>
</li>
</ul>
<h2 id="udp-应用"> UDP 应用</h2>
<ul>
<li>
<p>多媒体应用</p>
<ul>
<li>IP 电话</li>
<li>实时视频会议</li>
<li>流媒体</li>
</ul>
</li>
<li>
<p>应用层协议</p>
<ul>
<li>DNS（域名服务）</li>
<li>DHCP（动态主机配置协议）</li>
<li>TFTP（简单文件传输协议）</li>
<li>SNMP（简单网络管理协议）</li>
<li>RIP（路由协议）</li>
</ul>
</li>
</ul>
<h2 id="参考资料"> 参考资料</h2>
<p><a href="http://docs.52im.net/extend/docs/book/tcpip/vol1/11/" target="_blank" rel="noopener noreferrer">UDP 协议</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T02:21:36.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Nginx</title>
    <id>https://www.snowji.cn/basic-skills/nginx/</id>
    <link href="https://www.snowji.cn/basic-skills/nginx/"/>
    <updated>2022-08-26T03:26:17.000Z</updated>
    <content type="html"><![CDATA[<h1 id="nginx"> Nginx</h1>
<blockquote>
<p>本系列以 Nginx 1.18.0 作为安装版本进行知识点梳理，该版本目前属于 Legacy versions（老版本的稳定版）</p>
</blockquote>
<p>Nginx（engine x）是一个高性能的 HTTP 和反向代理 web 服务器，同时也提供了 IMAP/POP3/SMTP 服务。其特点是占有内存少，并发能力强</p>
<p>Nginx 是一个安装非常的简单、配置文件非常简洁（还能够支持 perl 语法）、Bug 非常少的服务Nginx 启动特别容易，并且几乎可以做到 7*24 不间断运行，即使运行数个月也不需要重新启动。你还能够不间断服务的情况下进行软件版本的升级</p>
<p>Nginx 代码完全用C语言从头写成。官方数据测试表明能够支持高达 50,000 个并发连接数的响应</p>
<hr>
<p>Nginx 的主要作用：</p>
<ul>
<li>正向代理和反向代理</li>
<li>负载均衡</li>
<li>HTTP 服务器（动静分离）</li>
</ul>
<hr>
<p>Nginx 处理访问请求的原理：</p>
<ol>
<li>浏览器输入域名：<code>www.baidu.com</code></li>
<li>浏览器将请求添加协议</li>
<li>针对访问的域名进行解析（DNS 解析：把域名解析成对应 IP 的过程）</li>
<li>发起 TCP 连接请求，发送 http 请求报文</li>
<li>服务端中 Nginx 通过端口接收到 http 报文请求之后，通过报文中请求域名与自己配置文件中的 server 模块中的 <code>server_name</code> 进行匹配</li>
<li>交由 location 模块匹配所请求的 uri 信息，根据响应规则进行处理</li>
<li>通过调用内核，由内核调用磁盘，取得相应资源，封装后返回给用户</li>
</ol>
<hr>
<p>关于 Nginx 的知识点，主要参考：</p>
<ul>
<li>网上各种资料</li>
<li>工作生产实践</li>
</ul>
<div style="text-align: right">
  <svg t="1624981822388" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1252" width="64" height="64"><path d="M512 0L68.48 256v512L512 1024l443.52-256V256z m256 707.84c0 30.08-27.552 55.04-65.248 55.04-26.912 0-57.632-10.88-76.832-34.56l-256-304.672v284.16c0 30.752-24.32 55.04-54.368 55.04H312.32c-30.752 0-55.04-25.6-55.04-55.04V316.16c0-30.08 26.88-55.04 64-55.04 27.552 0 58.88 10.88 78.08 34.56l254.72 304.672V316.16c0-30.752 25.6-55.04 55.04-55.04h3.2c30.72 0 55.04 25.6 55.04 55.04v391.68z" fill="#269539" p-id="1253"></path></svg>
</div>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T03:26:17.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Nginx 常用命令</title>
    <id>https://www.snowji.cn/basic-skills/nginx/common-commands/</id>
    <link href="https://www.snowji.cn/basic-skills/nginx/common-commands/"/>
    <updated>2022-08-26T03:26:17.000Z</updated>
    <content type="html"><![CDATA[<h1 id="nginx-常用命令"> Nginx 常用命令</h1>
<h2 id="nginx-操作的命令"> Nginx 操作的命令</h2>
<div><pre><code><span># 查看 Nginx 版本</span>
/usr/local/nginx/sbin/nginx -v

<span># 检查配置文件 ngnix.conf 的正确性</span>
/usr/local/nginx/sbin/nginx -t

<span># 启动 Nginx 服务</span>
/usr/local/nginx/sbin/nginx

<span># 启动 Nginx 服务，-c 指定配置文件的路径</span>
/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf

<span># 重新加载配置</span>
/usr/local/nginx/sbin/nginx -s reload

<span># 停止 Nginx 服务（快速关闭，不管有没有正在处理的请求）</span>
/usr/local/nginx/sbin/nginx -s stop

<span># 安全退出 Nginx 服务（在退出前会完成已经接受的连接请求，比较优雅）</span>
/usr/local/nginx/sbin/nginx -s quit
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h2 id="linux-检查的命令"> Linux 检查的命令</h2>
<div><pre><code><span># 查看 Nginx 进程</span>
<span>ps</span> -ef <span>|</span> <span>grep</span> nginx

<span># 检查 Nginx 启动的端口</span>
<span>netstat</span> -lntup <span>|</span> <span>grep</span> nginx
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="服务器防火墙相关命令"> 服务器防火墙相关命令</h2>
<p>如果 Nginx 启动成功后，从浏览器访问还是连接不上，按如下步骤排查：</p>
<ul>
<li>检查阿里云安全组是否开放端口（通过阿里云后台）</li>
<li>服务器防火墙是否开放端口</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T03:26:17.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">DHCP Snooping</title>
    <id>https://www.snowji.cn/basic-skills/network/ipsec-internet/dhcp-snooping/</id>
    <link href="https://www.snowji.cn/basic-skills/network/ipsec-internet/dhcp-snooping/"/>
    <updated>2022-09-02T02:21:36.000Z</updated>
    <content type="html"><![CDATA[<h1 id="dhcp-snooping"> DHCP Snooping</h1>
<h2 id="什么是-dhcp-snooping"> 什么是 DHCP Snooping</h2>
<ul>
<li>是 DHCP 的一种安全特性，常用于二层交换机</li>
<li>启用了该功能的交换机，可以屏蔽接入网络中的非法 DHCP 服务器，只能从指定的 DHCP 服务器获取 IP 地址、</li>
</ul>
<h2 id="dhcp-snooping-原理"> DHCP Snooping 原理</h2>
<p>前提需要先了解 DHCP 协议，可参考：<a href="/basic-skills/network/DHCP%E5%8D%8F%E8%AE%AE">DHCP 协议</a></p>
<h3 id="原理"> 原理</h3>
<ul>
<li>DHCP Snooping 将交换机上的端口分为信任（trusted）和非信任（untrusted）两种类型</li>
<li>交换机只转发信任端口的 DHCP OFFER/ACK/NAK 报文</li>
<li>丢弃非信任端口的 DHCP OFFER/ACK/NAK 报文，从而达到阻断非法 DHCP 服务器的目的</li>
<li>启动了 DHCP Snooping，则 DHCP 服务器只能通过信任端口发送 DHCP OFFER 报文</li>
</ul>
<h3 id="dhcp-snooping-主要工作"> DHCP Snooping 主要工作</h3>
<ul>
<li>验证从非信任途径接收的 DHCP 报文，并丢弃不符合要求的报文</li>
<li>生成并维护 DHCP Binding Table 记录表</li>
<li>根据 DHCP Binding Table 记录表中的信息来验证非信任主机发来的 DHCP 报文</li>
</ul>
<h2 id="dhcp-snooping-可防御的攻击种类"> DHCP Snooping 可防御的攻击种类</h2>
<h3 id="spoofing-攻击"> Spoofing 攻击</h3>
<ul>
<li>恶意攻击者想探听用户和网关之间的通信，给用户发送伪造的 ARP 应答报文，使用户误认为自己就是默认网关或 DNS 服务器</li>
<li>用户和网关之间看似“直接”的通信，实际上都是通过黑客所在的用户间接进行的，即黑客担当了“中间人”的角色，可以对信息进行了窃取和篡改</li>
</ul>
<h3 id="仿冒-dhcp-报文攻击"> 仿冒 DHCP 报文攻击</h3>
<ul>
<li>如果攻击者冒充合法用户不断向 DHCP Server 发送 DHCP REQUEST 报文来续租 IP 地址</li>
<li>导致这些到期的 IP 地址无法正常回收，以致一些合法用户不能获得 IP 地址</li>
<li>而若攻击者仿冒合法用户的 DHCP Release 报文发往 DHCP Server，将会导致用户异常下线</li>
</ul>
<h2 id="如何开启dhcp-snooping"> 如何开启DHCP Snooping</h2>
<ul>
<li>如果接入交换机上连接了有线终端，那就需要开启 DHCP Snooping 功能</li>
<li>在想要保护的 VLAN 上启用 DHCP Snooping 之前，需要先设置信任端口，这些端口允许来自合法 DHCP 服务器数据包的流通</li>
<li>在 CLI 命令行界面和 Web 界面都可以完成该配置</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T02:21:36.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">子网掩码</title>
    <id>https://www.snowji.cn/basic-skills/network/subnet-mask/</id>
    <link href="https://www.snowji.cn/basic-skills/network/subnet-mask/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="子网掩码"> 子网掩码</h1>
<p>前情提要：了解 IP 地址的结构，可参考 <a href="/basic-skills/network/IP地址/">IP地址</a></p>
<h2 id="简介"> 简介</h2>
<p>目的：</p>
<ul>
<li>方便管理，不同的子网可以相互隔离</li>
<li>缓解 IP 地址资源紧张</li>
</ul>
<p>原理：</p>
<ul>
<li>
<p>一般 IP 分为 2 个部分：网络号 + 主机号</p>
</li>
<li>
<p>网络号：一般是将网络部分和子网部分合并</p>
</li>
</ul>
<p>表示：32 位的二进制，1 表示网络号，0 表示主机号</p>
<h2 id="网络号和主机号计算"> 网络号和主机号计算</h2>
<p>规则：将 IP 地址与子网掩码均转换为二进制后，按位进行<strong>与运算</strong></p>
<p><strong>例子</strong>：</p>
<p>IP : 一个 C 类的地址，192.168.0.3</p>
<p>子网掩码: 255.255.255.0</p>
<p><strong>计算步骤</strong>：</p>
<ul>
<li>
<p>转成二进制</p>
<div><pre><code>ip:   192.168.0.3   &gt;  11000000 10101000 00000000 00000011
网掩码：255.255.255.0 &gt;  11111111 11111111 11111111 00000000
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>两个二进制按位做与计算</p>
</li>
</ul>
<div><pre><code>11000000 10101000 00000000 00000011
&amp;
11111111 11111111 11111111 00000000
=
11000000 10101000 00000000 00000000
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li>
<p>将上面的结果每个 8 位转为十进制为</p>
<div><pre><code>11000000 10101000 00000000 00000000 &gt; 192.168.0.0
结论：192.168.0.0 为网络号(网络段)
     3 为主机号(主机在子网中的标识)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
</ul>
<h2 id="cidr-vlsm"> CIDR/VLSM</h2>
<p><strong>CIDR</strong>：无类别域间路由</p>
<div><pre><code>192.168.0.3/24
24: 表示 IP 前 24 位是网络号，剩下的 8 位是主机号
主机号：全 0 表示网络标识，全 1 表示广播地址，其他的是该子网的可用地址
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>例子：</p>
<div><pre><code>192.168.0.3   =&gt;  11000000 10101000 00000000 00000011

网络标识的前缀：11000000 10101000 00000000 --（前24位）换算位10进制：192.168.0
网络标识: 11000000 10101000 00000000 00000000 --剩下8位全是0，转10进制是：192.168.0.0
广播地址  11000000 10101000 00000000 11111111 --剩下8位全是1，转10进制是：192.168.0.255
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>VLSM</strong>：可变长子网掩码</p>
<p><strong>例子</strong>：</p>
<p>IP 地址：192.168.0.3/24</p>
<ul>
<li>这个地址前 24 位全 1 ，也就是 255.255.255.0 是这个网络的子网掩码</li>
<li>无类别域间路由是基于可变长子网掩码来进行任意长度的前缀分配的，所以 24 可以变成其他数，如 16、20 等</li>
</ul>
<div><pre><code>192.168.0.3/16
只有前16位是网络，后面是地址16标识,换算如下：
192.168.0.0 是网络标识（后16位二进制全位0）
192.168.255.255这个是域内广播地址（后16位二进制全为1）
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="反掩码"> 反掩码</h2>
<h3 id="什么是反掩码"> 什么是反掩码</h3>
<ul>
<li>32 位点分十进制数</li>
<li>反掩码就是通配符掩码</li>
<li>通过标记 0 和 1 告诉设备匹配到哪位</li>
<li>检查相应位为 0 的，忽略相应位为 1 的</li>
</ul>
<p>例子：</p>
<div><pre><code>CIDR  子网掩码           反掩码
/30   <span>255.255</span>.255.252   <span>0.0</span>.0.3
/24   <span>255.255</span>.255.0     <span>0.0</span>.0.255
/16   <span>255.255</span>.0.0       <span>0.0</span>.255.255
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="反掩码的使用"> 反掩码的使用</h3>
<p>通常在设置路由时，会使用到反掩码与源或目的地址一起匹配 IP 地址所属网络</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T02:21:36.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Ngixn 配置文件模板</title>
    <id>https://www.snowji.cn/basic-skills/nginx/config-file-generic-template/</id>
    <link href="https://www.snowji.cn/basic-skills/nginx/config-file-generic-template/"/>
    <updated>2022-08-26T03:26:17.000Z</updated>
    <content type="html"><![CDATA[<h1 id="ngixn-配置文件模板"> Ngixn 配置文件模板</h1>
<p>本文基于 Nginx 1.18.0，整理一份配置文件 nginx.conf 的通用模板</p>
<h2 id="模块拆分"> 模块拆分</h2>
<p>当项目或业务越来越多的时候，Nginx 的配置文件 nginx.conf 会越来越大和复杂，不便于管理，所以需要拆分出多个子配置文件</p>
<p>以下命令，如果你是 root 账户，直接执行即可，不是的话前面加 <code>sudo</code> 获取权限</p>
<p>首先建立子配置文件目录：</p>
<div><pre><code><span>cd</span> /usr/local/nginx/conf
<span>mkdir</span> vhosts
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>然后在 nginx.conf 中使用 <code>include</code> 引入文件：</p>
<div><pre><code>http <span>{</span>
    <span>..</span>.

    include /usr/local/nginx/conf/vhosts/*.conf<span>;</span>   <span># *.conf 代表所有 server 配置文件</span>
    include /usr/local/nginx/conf/vhosts/*.proxy<span>;</span>  <span># *.proxy 代表所有做反向代理的 server（看情况可选）</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>最后把 server 模块移入子配置文件中：</p>
<div><pre><code><span># web.conf</span>
server<span>{</span>   
    listen <span>80</span><span>;</span>
    server_name localhost<span>;</span>
    <span>..</span>.
<span>}</span>

<span># api.conf</span>
server<span>{</span>   
    listen <span>81</span><span>;</span>
    server_name localhost<span>;</span>
    <span>..</span>.
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>此时的 Nginx 文件目录结构：</p>
<div><pre><code>├── nginx
    │── html
    │── logs
    │── sbin
    │── ...
    └── conf
        ├── ...
        ├── nginx.conf         # 主配置文件
        └── vhosts             # 子配置文件的目录
            ├── web.conf       # 子配置文件 1
            └── api.conf       # 子配置文件 2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>思路就是上面介绍的这样，下面是实际生产环境中的通用模板</p>
<h2 id="主配置文件"> 主配置文件</h2>
<p>我在这份主配置文件中仅设置了几个核心参数，如果有特定需求可自行定制，如下所示：</p>
<div><pre><code>user  nginx nginx<span>;</span>
worker_processes  <span>1</span><span>;</span>

error_log  /var/log/nginx/error.log crit<span>;</span>

pid        /var/run/nginx.pid<span>;</span>

events <span>{</span>
    worker_connections  <span>1024</span><span>;</span>
<span>}</span>

http <span>{</span>
    include       mime.types<span>;</span>
    default_type  application/octet-stream<span>;</span>

    charset utf-8<span>;</span>

    access_log  off<span>;</span>

    sendfile        on<span>;</span>
    tcp_nopush     on<span>;</span>
    tcp_nodelay on<span>;</span>

    keepalive_timeout  <span>65</span><span>;</span>

    fastcgi_connect_timeout <span>300</span><span>;</span>
    fastcgi_send_timeout <span>300</span><span>;</span>
    fastcgi_read_timeout <span>300</span><span>;</span>
    fastcgi_buffer_size 64k<span>;</span>
    fastcgi_buffers <span>4</span> 64k<span>;</span>
    fastcgi_busy_buffers_size 128k<span>;</span>
    fastcgi_temp_file_write_size 128k<span>;</span>

    <span>gzip</span> on<span>;</span>
    gzip_min_length 1k<span>;</span>
    gzip_buffers <span>4</span> 16k<span>;</span>
    gzip_http_version <span>1.0</span><span>;</span>
    gzip_comp_level <span>2</span><span>;</span>
    gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/bmp application/x-bmp image/x-ms-bmp application/vnd.ms-fontobject font/ttf font/opentype font/x-woff<span>;</span>
    gzip_vary on<span>;</span>
    <span># limit_zone crawler $binary_remote_addr 10m;    # 开启限制 IP 连接数的时候需要使用</span>

    log_format  main  <span>'$remote_addr - $remote_user [$time_local] "$request" '</span>
                      <span>'$status $body_bytes_sent "$http_referer" '</span>
                      <span>'"$http_user_agent" "$http_x_forwarded_for"'</span><span>;</span>

    include /usr/local/nginx/conf/vhosts/*.conf<span>;</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><h2 id="子配置文件"> 子配置文件</h2>
<p>首先别忘了创建文件夹：</p>
<div><pre><code><span>cd</span> /usr/local/nginx/conf
<span>mkdir</span> vhosts
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>在该文件夹下所有以 <code>.conf</code> 结尾的文件都是子配置文件，在主配置文件的末尾被 <code>include</code> 引入了</p>
<p>这里只做一份最基础的子配置文件（server 部分）模板，实现一个静态网站的部署配置</p>
<div><pre><code>server <span>{</span>
    listen <span>80</span><span>;</span>
    server_name  www.fedbook.cn fedbook.cn<span>;</span>

    root /sites/fedbook<span>;</span>
    index index.html<span>;</span>

    location / <span>{</span>
        try_files <span>$uri</span> <span>$uri</span>/ /index.html<span>;</span>
    <span>}</span>

    location ~* <span>\</span>.<span>(</span>html<span>|</span>htm<span>)</span>$ <span>{</span>
        expires 24h<span>;</span>
        add_header Cache-Control <span>"public"</span><span>;</span>
    <span>}</span>
    
    location ~* <span>\</span>.<span>(</span>css<span>|</span>js<span>|</span>jpg<span>|</span>jpeg<span>|</span>gif<span>|</span>png<span>|</span>ico<span>|</span>cur<span>|</span>gz<span>|</span>svg<span>|</span>svgz<span>|</span>map<span>|</span>mp4<span>|</span>ogg<span>|</span>ogv<span>|</span>webm<span>|</span>htc<span>)</span>$ <span>{</span>
        expires 24h<span>;</span>
        access_log off<span>;</span>
        add_header Cache-Control <span>"public"</span><span>;</span>
    <span>}</span>

    access_log  /var/log/nginx/access/fedbook.log<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>上面配置文件我们指定了这个子模块的日志输出路径，所以需要创建该路径的文件夹，否则在写入日志时会因文件夹不存在而报错：</p>
<div><pre><code><span>mkdir</span> -p /var/log/nginx/access/
</code></pre>
<div><span>1</span><br></div></div><p>检查 Nginx 配置文件的正确性：</p>
<div><pre><code>/usr/local/nginx/sbin/nginx -t
</code></pre>
<div><span>1</span><br></div></div><p>最后重新加载 Nginx 配置即可上线该静态网站：</p>
<div><pre><code><span># 如果已将 Nginx 加入开机自启（有 Nginx 开机自启脚本）</span>
/etc/init.d/nginx reload

<span># 如果未将 Nginx 加入开机自启</span>
/usr/local/nginx/sbin/nginx -s reload
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>对于如何配置来实现更多强大的功能，会在后面章节一一展开介绍</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T03:26:17.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Nginx 部署 Https 安全认证</title>
    <id>https://www.snowji.cn/basic-skills/nginx/deploy-https-security-auth/</id>
    <link href="https://www.snowji.cn/basic-skills/nginx/deploy-https-security-auth/"/>
    <updated>2022-09-01T09:03:09.000Z</updated>
    <content type="html"><![CDATA[<h1 id="nginx-部署-https-安全认证"> Nginx 部署 Https 安全认证</h1>
<blockquote>
<p>本文不介绍 https 相关知识，仅分享 Nginx 配置 https 服务的步骤。并且假设你已经购买了服务器、域名和 SSL 证书</p>
</blockquote>
<h2 id="模块介绍"> 模块介绍</h2>
<p>网站启用 https 以后会在 SEO 和安全性方面都有一定的好处，这里不展开讲。已经启用 https 的网站，一个比较直观的变化就是浏览器的域名前面有一把小锁的图标，如下所示：</p>
<div style="text-align: center;">
  <img src="./images/web-sites-with-https-enabled.png" height="200" alt="Web sites with HTTPS enabled">
</div>
<p>该功能用到了 <code>http_ssl_module</code> 这个模块，默认情况下 ssl 模块并未被安装，如果要使用该模块则需要在编译 Nginx 时指定 <code>--with-http_ssl_module</code> 参数，详见《<a href="/basic-skills/nginx/installation-of-nginx/#编译安装" title="Nginx 编译安装">Nginx 编译安装</a>》</p>
<h2 id="购买并下载-ca-证书"> 购买并下载 CA 证书</h2>
<p>配置 SSL 模块首先需要 CA 证书，CA 证书可以自己手动颁发也可以在阿里云申请（<a href="https://help.aliyun.com/document_detail/28542.html" title="阿里云购买 CA 证书" target="_blank" rel="noopener noreferrer">阿里云购买 CA 证书</a>），普通用户可以在阿里云申请免费的 <code>Symantec</code> 的 <code>DV SSL</code></p>
<p>购买成功后，通过阿里云后台依次进入 控制台 =&gt; 产品与服务 =&gt; 安全（云盾）=&gt; SSL 证书（应用安全），找到自己将要使用的证书，点击下载，然后选择对应 Nginx 服务器的证书，如下图所示：</p>
<div style="text-align: center;">
  <img src="./images/download-ssl-for-nginx.png" height="350" alt="下载用于 Nginx 服务器的证书">
</div>
<p>证书下载下来后解压，有两份文件：</p>
<ul>
<li>证书名称.key：存储的是私钥 base64 加密</li>
<li>证书名称.pem：存储的是证书 base64 加密</li>
</ul>
<h2 id="上传证书到服务器"> 上传证书到服务器</h2>
<p>在 Nginx 的配置文件所在的目录下创建 cert 文件夹，并且将下载的全部文件拷贝到 cert 目录中：</p>
<div><pre><code><span>cd</span> /usr/local/nginx/
<span>mkdir</span> cert
<span>cd</span> cert/
rz -be  <span># 上传文件</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>此时的 Nginx 文件目录结构：</p>
<div><pre><code>├── nginx
    │── html
    │── logs
    │── sbin
    │── ...
    │── cert
    │   ├── 证书名称.key        # 存储私钥
    │   └── 证书名称.pem        # 存储证书
    └── conf
        ├── ...
        ├── nginx.conf         # 主配置文件
        └── vhosts             # 子配置文件的目录
            ├── web.conf       # 子配置文件 1
            └── api.conf       # 子配置文件 2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id="配置案例"> 配置案例</h2>
<p>前端我们已经下载并上传了 SSL 证书，接下来在 Nginx 配置文件中进行配置</p>
<div><div><br><div>&nbsp;</div><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br></div><pre><code>server <span>{</span>
    listen <span>443</span> ssl<span>;</span>
    server_name  www.fedbook.cn fedbook.cn<span>;</span>

    root /sites/fedbook<span>;</span>
    index index.html<span>;</span>

    ssl_certificate  /usr/local/nginx/cert/证书名称.pem<span>;</span>
    ssl_certificate_key  /usr/local/nginx/cert/证书名称.key<span>;</span>
    ssl_session_timeout 5m<span>;</span>
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:<span>!</span>NULL:<span>!</span>aNULL:<span>!</span>MD5:<span>!</span>ADH:<span>!</span>RC4<span>;</span>
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2<span>;</span>
    ssl_prefer_server_ciphers on<span>;</span>

    location / <span>{</span>
        <span>..</span><span>..</span><span>..</span>
    <span>}</span>
<span>}</span>

server <span>{</span>
    listen <span>80</span><span>;</span>
    server_name  www.fedbook.cn fedbook.cn<span>;</span>
    <span>return</span> <span>301</span> https://<span>$host</span><span>$request_uri</span><span>;</span>
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T03:26:17.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Ngixn 配置文件详解</title>
    <id>https://www.snowji.cn/basic-skills/nginx/config-file-params-explanation/</id>
    <link href="https://www.snowji.cn/basic-skills/nginx/config-file-params-explanation/"/>
    <updated>2022-08-26T03:26:17.000Z</updated>
    <content type="html"><![CDATA[<h1 id="ngixn-配置文件详解"> Ngixn 配置文件详解</h1>
<p>本文基于 Nginx 1.18.0，介绍其配置文件 <code>nginx.conf</code> 的主要配置参数。</p>
<h2 id="核心参数详解"> 核心参数详解</h2>
<div><pre><code>user  nginx nginx<span>;</span>                 <span># 指定 Nginx 服务运行的用户和用户组</span>
worker_processes  <span>1</span><span>;</span>               <span># 定义 Nginx 的 worker 进程数，建议等于 CPU 总核心数</span>

<span># 全局指定 Nginx 错误日志，定义类型，[ debug | info | notice | warn | error | crit ]</span>
<span># 如果要关闭 error log，需要写成 error_log /dev/null;</span>
<span># 而不是 error_log off; 否则错误日志会写到一个叫做 off 的文件中</span>
error_log  /var/log/nginx/error.log warn<span>;</span>

pid        /var/run/nginx.pid<span>;</span>     <span># 指定 Nginx PID 进程号文件</span>

<span># 一个 Nginx 进程打开的最多文件描述符数目</span>
<span># 理论值应该是最多打开文件数（系统的值 ulimit -n）与 Nginx 进程数相除</span>
<span># 但是 Nginx 分配请求并不均匀，所以建议与 ulimit -n 的值保持一致</span>
worker_rlimit_nofile <span>65535</span><span>;</span>

<span># 工作模式与连接数上限</span>
events <span>{</span>
    <span># 参考事件模型</span>
    <span># use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]</span>
    <span># epoll 模型是 Linux 2.6 以上版本内核中的高性能网络 I/O 模型</span>
    <span># 如果跑在 FreeBSD 上面，就用 kqueue 模型</span>
    use epoll<span>;</span>
    <span># 单个进程最大连接数（最大连接数=连接数*进程数），默认值为 1024</span>
    worker_connections  <span>65535</span><span>;</span>
<span>}</span>

<span># 设定 http 服务器</span>
http <span>{</span>
    <span># 文件扩展名与文件类型映射表</span>
    <span># Nginx 会根据 mime.type 定义的对应关系来告诉浏览器如何处理当前返回的文件（打开或下载）</span>
    include       mime.types<span>;</span>

    <span># 当 Nginx 无法识别当前访问页面内容时（未定义的扩展名），默认触发下载动作</span>
    <span># 浏览器访问到未定义的扩展名的时候，就默认为下载该文件</span>
    <span># 如果将这个设置改成 default_type text/html; 即把所有未设置的扩展名当 HTML 文件打开</span>
    default_type  application/octet-stream<span>;</span>

    charset utf-8<span>;</span>                         <span># 默认编码</span>

    <span># 服务器名字的 hash 表大小（看不懂的参数默认即可）</span>
    server_names_hash_bucket_size <span>128</span><span>;</span>
    <span># 客户端请求头部的缓冲区大小</span>
    client_header_buffer_size 32k<span>;</span>
    <span># 客户请求头缓冲大小</span>
    <span># Nginx 默认会用 client_header_buffer_size 这个 buffer 来读取 header 值</span>
    <span># 如果 header 过大，它会使用 large_client_header_buffers 来读取</span>
    large_client_header_buffers <span>4</span> 64k<span>;</span>
    <span># 设定通过 Nginx 上传文件的大小</span>
    client_max_body_size 8m<span>;</span>

    <span># 开启高效文件传输模式</span>
    <span># sendfile 指令指定 Nginx 是否调用 sendfile 函数来输出文件</span>
    <span># 对于普通应用设为 on，如果用来进行下载等应用磁盘 IO 重负载应用，可设置为 off，以平衡磁盘与网络 I/O 处理速度，降低系统的负载</span>
    <span># 注意：如果图片显示不正常把这个改成 off</span>
    sendfile on<span>;</span>
    <span># 开启目录列表访问，适合下载服务器，默认关闭</span>
    autoindex on<span>;</span>
    <span># 防止网络阻塞：数据包会先累积到最大后一次性传输，可以最大化利用网络资源，但会有一点点延迟（默认开启）</span>
    tcp_nopush on<span>;</span>
    <span># 防止网络阻塞：小的数据包不等待直接传输（与 tcp_nopush 互斥，但两者可同为 on ，Nginx 会平衡这两个功能，默认开启）</span>
    tcp_nodelay on<span>;</span>

    keepalive_timeout <span>65</span><span>;</span>                  <span># 长连接超时时间，单位是秒</span>

    <span># FastCGI 相关参数是为了改善网站的性能：减少资源占用，提高访问速度。</span>
    <span># 参考1：https://blog.csdn.net/luozhonghua2014/article/details/37737823</span>
    <span># 参考2：https://blog.51cto.com/blief/1739655</span>
    fastcgi_connect_timeout <span>300</span><span>;</span>        <span># 连接到后端 fastcgi 超时时间（秒）</span>
    fastcgi_send_timeout <span>300</span><span>;</span>           <span># 指 Nginx 进程向 fastcgi 进程发送 request 的整个过程的超时时间（秒）</span>
    fastcgi_read_timeout <span>300</span><span>;</span>           <span># 指 fastcgi 进程向 Nginx 进程发送 response 的整个过程的超时时间（秒）</span>
    fastcgi_buffer_size 64k<span>;</span>            <span># 读取 fastcgi 应答第一部分需要多大缓冲区</span>
    fastcgi_buffers <span>4</span> 64k<span>;</span>              <span># 指定本地需要多少和多大的缓冲区来缓冲 fastcgi 应答请求</span>
    fastcgi_busy_buffers_size 128k<span>;</span>     <span># 默认值是 fastcgi_buffer 的 2 倍</span>
    fastcgi_temp_file_write_size 128k<span>;</span>  <span># 写入缓存文件使用多大的数据块，默认值是 fastcgi_buffer 的 2 倍</span>

    <span># gzip 模块设置</span>
    <span>gzip</span> on<span>;</span>                               <span># 开启 gzip 压缩输出</span>
    gzip_min_length 1k<span>;</span>                    <span># 最小压缩文件大小</span>
    gzip_buffers <span>4</span> 16k<span>;</span>                    <span># 压缩缓冲区</span>
    gzip_http_version <span>1.0</span><span>;</span>                 <span># 压缩版本（默认 1.1，前端如果是 squid2.5 请使用 1.0）</span>
    gzip_comp_level <span>2</span><span>;</span>                     <span># 压缩等级</span>
    <span># 压缩类型，默认就已经包含 text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个 warn</span>
    <span># 图片压缩：建议不对 gif、jpge 等图片进行压缩，因为其压缩比例极低，反而耗费 CPU，但 bmp 可以压缩，因为 bmp 压缩比例较大</span>
    <span># 字体压缩：只需要为 ttf、otf 和 svg 字体启用 gzip，对其他字体格式进行 gzip 压缩时效果不明显</span>
    <span># 参考：https://blog.csdn.net/liupeifeng3514/article/details/79018334</span>
    gzip_types text/plain application/x-javascript text/css application/xml<span>;</span>
    gzip_vary on<span>;</span>                          <span># 是否在 http header 中添加 Vary: Accept-Encoding，建议开启</span>
    <span># limit_zone crawler $binary_remote_addr 10m;    # 开启限制 IP 连接数的时候需要使用</span>

    <span># upstream 的负载均衡，weight 是权重，可以根据机器配置定义权重</span>
    <span># weigth 参数表示权值，权值越高被分配到的几率越大</span>
    <span># Nginx 的 upstream 目前支持 4 种方式的分配，这里演示一种，后面章节会分别演示</span>
    upstream www.baidu.com <span>{</span>
        server <span>192.168</span>.80.121:80 <span>weight</span><span>=</span><span>3</span><span>;</span>
        server <span>192.168</span>.80.122:80 <span>weight</span><span>=</span><span>2</span><span>;</span>
        server <span>192.168</span>.80.123:80 <span>weight</span><span>=</span><span>3</span><span>;</span>
    <span>}</span>

    <span># 全局指定 Nginx 访问日志的格式</span>
    log_format  main  <span>'$remote_addr - $remote_user [$time_local] "$request" '</span>
                      <span>'$status $body_bytes_sent "$http_referer" '</span>
                      <span>'"$http_user_agent" "$http_x_forwarded_for"'</span><span>;</span>
    <span># 全局定义 Nginx 访问日志的位置</span>
    access_log  logs/access.log  main<span>;</span>
    <span># 一般上面两个不配置，只设置 access_log off; 然后在需要的 server 下配置日志</span>
    <span># 这么做可以避免日志产生过大（如果 http 和 server 都不配置，默认会写入 logs/access.log）</span>
    access_log  off<span>;</span>

    <span># 虚拟主机的配置，一个 server 配置段一般对应一个域名</span>
    <span># 在实际生产中一般会将这部分拆出来形成子配置文件，后面的章节会讲</span>
    server <span>{</span>
        listen       <span>80</span><span>;</span>                     <span># 指定监听端口</span>
        server_name  www.baidu.com<span>;</span>          <span># 指定当前网站的访问域名</span>

        location / <span>{</span>
            root   html<span>;</span>                     <span># 指定代码位置</span>
            index  index.html index.htm<span>;</span>     <span># 指定首页文件</span>
        <span>}</span>

        <span>#  定义 404 错误页面，如果是 404 错误，则把站点根目录下的 404.html 返回给用户 </span>
        error_page  <span>404</span>                    /404.html<span>;</span>
        <span>#  定义 50x 错误页面，可以配合 location 使用，用 location 调用实际的错误页面</span>
        error_page      <span>500</span> <span>502</span> <span>503</span> <span>504</span>    /50x.html<span>;</span>
        location <span>=</span> /50x.html <span>{</span> 
            root  /usr/share/nginx/html<span>;</span> 
        <span>}</span> 
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br></div></div><h2 id="全局日志的关闭"> 全局日志的关闭</h2>
<p>为了避免日志产生过大，也是处于模块化的思想，我们一般不在全局中（http 中）指定日志格式和输出位置，而是在子配置文件中（每个 server 中）单独配置。</p>
<p>但是如果 http 和 server 都不配置，默认会写入 <code>logs/access.log</code>，即全局的形式。所以需要关闭全局日志。</p>
<p>网上很多博客中展示的都是错误示例，这里演示正确的关闭方式，包括 <code>error_log</code> 和 <code>access_log</code>：</p>
<div><pre><code><span># 错误示例，会产生名字为 off/on 的日志文件</span>
error_log off<span>;</span>
access_log on<span>;</span>

正确关闭方式
error_log /dev/null<span>;</span>
access_log off<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="日志-log-format-可选项"> 日志 log_format 可选项</h2>
<p>默认格式：</p>
<div><pre><code>log_format  main  <span>'$remote_addr - $remote_user [$time_local] "$request" '</span>
                  <span>'$status $body_bytes_sent "$http_referer" '</span>
                  <span>'"$http_user_agent" "$http_x_forwarded_for"'</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>参数释义表：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>$remote_addr</td>
<td>客户端地址</td>
</tr>
<tr>
<td>$remote_user</td>
<td>客户端用户名称</td>
</tr>
<tr>
<td>$time_local</td>
<td>访问时间和时区</td>
</tr>
<tr>
<td>$request</td>
<td>请求的 URI 和 HTTP 协议</td>
</tr>
<tr>
<td>$http_host</td>
<td>请求地址，即浏览器中你输入的地址（IP 或域名）</td>
</tr>
<tr>
<td>$status</td>
<td>HTTP 请求状态</td>
</tr>
<tr>
<td>$upstream_status</td>
<td>upstream 状态</td>
</tr>
<tr>
<td>$body_bytes_sent</td>
<td>发送给客户端文件内容大小</td>
</tr>
<tr>
<td>$http_referer</td>
<td>url 跳转来源</td>
</tr>
<tr>
<td>$http_user_agent</td>
<td>用户终端浏览器等信息</td>
</tr>
<tr>
<td>$ssl_protocol</td>
<td>SSL协议版本</td>
</tr>
<tr>
<td>$ssl_cipher</td>
<td>交换数据中的算法</td>
</tr>
<tr>
<td>$upstream_addr</td>
<td>后台 upstream 的地址，即真正提供服务的主机地址</td>
</tr>
<tr>
<td>$request_time</td>
<td>整个请求的总时间</td>
</tr>
<tr>
<td>$upstream_response_time</td>
<td>请求过程中，upstream 响应时间</td>
</tr>
</tbody>
</table>
<h2 id="http、server、location-之间的关系"> http、server、location 之间的关系</h2>
<ul>
<li>http：主要用于解决用户请求中的报文信息</li>
<li>server：用于配置一个具体的网站响应操作</li>
<li>location：用于匹配 uri</li>
</ul>
<p>由上至下是包含关系。</p>
<h2 id="更多其它参数"> 更多其它参数</h2>
<p>server 中的参数配置项其实有很多，它们可以实现一些丰富的功能。上面只列举了最基础的几个参数，后面的章节会单独讲解如何配置来实现各种功能。</p>
<h2 id="参考资料"> 参考资料</h2>
<ul>
<li><a href="https://www.nginx.com/resources/wiki/start/topics/examples/full/" title="Full Example Configuration" target="_blank" rel="noopener noreferrer">Full Example Configuration</a></li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T03:26:17.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">正向代理与反向代理</title>
    <id>https://www.snowji.cn/basic-skills/nginx/forward-proxy-and-reverse-proxy/</id>
    <link href="https://www.snowji.cn/basic-skills/nginx/forward-proxy-and-reverse-proxy/"/>
    <updated>2022-08-26T03:26:17.000Z</updated>
    <content type="html"><![CDATA[<h1 id="正向代理与反向代理"> 正向代理与反向代理</h1>
<h2 id="正向代理"> 正向代理</h2>
<p>正向代理其实相当于请求的中继，比如说，如果某个网站国内无法访问，也就是被墙了，这时我们可以通过一台可以访问到这个网站的服务器，也就是代理服务器，来进行访问。这台代理服务器，分析我们请求的信息，然后去对应的要去的网站上将内容取回来发给我，这样我就能读到想要访问的网站上的内容了</p>
<p>基于这种技术原理，VPN 就是这样产生的。通过 VPN，我们可以在家里访问公司的内网，也可以在电信宽带的环境下更好地玩网通区地 LOL（游戏加速器）</p>
<p>通过以下图片，可以很清晰的看出正向代理的原理：</p>
<div style="text-align: center;">
  <svg id="SvgjsSvg1006" width="603.0124816894531" height="278" xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.com/svgjs"><defs id="SvgjsDefs1007"><pattern id="SvgjsPattern1014" x="0" y="0" width="63" height="63" patternUnits="userSpaceOnUse"><image id="SvgjsImage1015" xlink:href="https://iconsapi.com/5ee27816e4b0b788a934aa1e.svg" width="63" height="63" preserveAspectRatio="none" crossOrigin="anonymous" x="0" y="0"></image></pattern><pattern id="SvgjsPattern1018" x="0" y="0" width="90" height="90" patternUnits="userSpaceOnUse"><image id="SvgjsImage1019" xlink:href="https://iconsapi.com/5ee268b1e4b0b788a9338b53.svg" width="90" height="90" preserveAspectRatio="none" crossOrigin="anonymous" x="0" y="0"></image></pattern><pattern id="SvgjsPattern1034" x="0" y="0" width="63" height="63" patternUnits="userSpaceOnUse"><image id="SvgjsImage1035" xlink:href="https://iconsapi.com/5ee27816e4b0b788a934aa1e.svg" width="63" height="63" preserveAspectRatio="none" crossOrigin="anonymous" x="0" y="0"></image></pattern></defs><g id="SvgjsG1008" transform="translate(25.012481689453125,25)"><path id="SvgjsPath1009" d="M 0 0L 331 0L 331 228L 0 228Z" stroke="rgba(100,181,246,1)" stroke-width="2" fill="none"></path><g id="SvgjsG1010"><text id="SvgjsText1011" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="311px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="104.375" transform="rotate(0)"></text></g></g><g id="SvgjsG1012" transform="translate(264.5124816894531,99)"><path id="SvgjsPath1013" d="M 0 0L 63 0L 63 63L 0 63Z" stroke="none" fill="url(#SvgjsPattern1014)"></path></g><g id="SvgjsG1016" transform="translate(59.012481689453125,88.5)"><path id="SvgjsPath1017" d="M 0 0L 90 0L 90 90L 0 90Z" stroke="none" fill="url(#SvgjsPattern1018)"></path></g><g id="SvgjsG1020" transform="translate(44.012481689453125,156.5)"><path id="SvgjsPath1021" d="M 0 0L 120 0L 120 40L 0 40Z" stroke="none" fill="none"></path><g id="SvgjsG1022"><text id="SvgjsText1023" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="120px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="8" transform="rotate(0)"><tspan id="SvgjsTspan1024" dy="20" x="60"><tspan id="SvgjsTspan1025" style="text-decoration:;">客户端</tspan></tspan></text></g></g><g id="SvgjsG1026" transform="translate(236.01248168945312,156.5)"><path id="SvgjsPath1027" d="M 0 0L 120 0L 120 40L 0 40Z" stroke="none" fill="none"></path><g id="SvgjsG1028"><text id="SvgjsText1029" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="120px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="8" transform="rotate(0)"><tspan id="SvgjsTspan1030" dy="20" x="60"><tspan id="SvgjsTspan1031" style="text-decoration:;">正向代理</tspan></tspan></text></g></g><g id="SvgjsG1032" transform="translate(486.5124816894531,99)"><path id="SvgjsPath1033" d="M 0 0L 63 0L 63 63L 0 63Z" stroke="none" fill="url(#SvgjsPattern1034)"></path></g><g id="SvgjsG1036" transform="translate(458.0124816894531,156.5)"><path id="SvgjsPath1037" d="M 0 0L 120 0L 120 40L 0 40Z" stroke="none" fill="none"></path><g id="SvgjsG1038"><text id="SvgjsText1039" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="120px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="8" transform="rotate(0)"><tspan id="SvgjsTspan1040" dy="20" x="60"><tspan id="SvgjsTspan1041" style="text-decoration:;">目标服务器</tspan></tspan></text></g></g><g id="SvgjsG1042" transform="translate(164.01248168945312,116.89805825242718)"><path id="SvgjsPath1043" d="M 0 10.95728155339806L 78.39805825242718 10.95728155339806L 78.39805825242718 0L 95 16.601941747572816L 78.39805825242718 33.20388349514563L 78.39805825242718 22.246601941747574L 0 22.246601941747574L 0 10.95728155339806Z" stroke="rgba(100,181,246,1)" stroke-width="2" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1044"><text id="SvgjsText1045" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="95px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="6.976941747572818" transform="rotate(0)"></text></g></g><g id="SvgjsG1046" transform="translate(377.0124816894531,116.89805825242718)"><path id="SvgjsPath1047" d="M 0 10.95728155339806L 78.39805825242718 10.95728155339806L 78.39805825242718 0L 95 16.601941747572816L 78.39805825242718 33.20388349514563L 78.39805825242718 22.246601941747574L 0 22.246601941747574L 0 10.95728155339806Z" stroke="rgba(100,181,246,1)" stroke-width="2" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1048"><text id="SvgjsText1049" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="95px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="6.976941747572818" transform="rotate(0)"></text></g></g></svg>
  <p style="text-align:center; color: #888;">（正向代理）</p>
</div>
<h2 id="反向代理"> 反向代理</h2>
<p>反向代理，其实客户端对代理是无感知的，因为客户端并不知道访问的是代理服务器。当客户端请求一个网址的时候，由反向代理服务器去选择目标服务器并获取数据，再返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器 IP 地址</p>
<p>反向代理的原理如图：</p>
<div style="text-align: center;">
  <svg id="SvgjsSvg1006" width="602.0124816894531" height="278" xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.com/svgjs"><defs id="SvgjsDefs1007"><pattern id="SvgjsPattern1014" x="0" y="0" width="63" height="63" patternUnits="userSpaceOnUse"><image id="SvgjsImage1015" xlink:href="https://iconsapi.com/5ee27816e4b0b788a934aa1e.svg" width="63" height="63" preserveAspectRatio="none" crossOrigin="anonymous" x="0" y="0"></image></pattern><pattern id="SvgjsPattern1018" x="0" y="0" width="90" height="90" patternUnits="userSpaceOnUse"><image id="SvgjsImage1019" xlink:href="https://iconsapi.com/5ee268b1e4b0b788a9338b53.svg" width="90" height="90" preserveAspectRatio="none" crossOrigin="anonymous" x="0" y="0"></image></pattern><pattern id="SvgjsPattern1034" x="0" y="0" width="63" height="63" patternUnits="userSpaceOnUse"><image id="SvgjsImage1035" xlink:href="https://iconsapi.com/5ee27816e4b0b788a934aa1e.svg" width="63" height="63" preserveAspectRatio="none" crossOrigin="anonymous" x="0" y="0"></image></pattern></defs><g id="SvgjsG1008" transform="translate(257.0124816894531,25)"><path id="SvgjsPath1009" d="M 0 0L 320 0L 320 228L 0 228Z" stroke="rgba(100,181,246,1)" stroke-width="2" fill="none"></path><g id="SvgjsG1010"><text id="SvgjsText1011" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="300px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="104.375" transform="rotate(0)"></text></g></g><g id="SvgjsG1012" transform="translate(285.5124816894531,99)"><path id="SvgjsPath1013" d="M 0 0L 63 0L 63 63L 0 63Z" stroke="none" fill="url(#SvgjsPattern1014)"></path></g><g id="SvgjsG1016" transform="translate(40.012481689453125,88.5)"><path id="SvgjsPath1017" d="M 0 0L 90 0L 90 90L 0 90Z" stroke="none" fill="url(#SvgjsPattern1018)"></path></g><g id="SvgjsG1020" transform="translate(25.012481689453125,156.5)"><path id="SvgjsPath1021" d="M 0 0L 120 0L 120 40L 0 40Z" stroke="none" fill="none"></path><g id="SvgjsG1022"><text id="SvgjsText1023" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="120px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="8" transform="rotate(0)"><tspan id="SvgjsTspan1024" dy="20" x="60"><tspan id="SvgjsTspan1025" style="text-decoration:;">客户端</tspan></tspan></text></g></g><g id="SvgjsG1026" transform="translate(257.0124816894531,156.5)"><path id="SvgjsPath1027" d="M 0 0L 120 0L 120 40L 0 40Z" stroke="none" fill="none"></path><g id="SvgjsG1028"><text id="SvgjsText1029" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="120px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="8" transform="rotate(0)"><tspan id="SvgjsTspan1030" dy="20" x="60"><tspan id="SvgjsTspan1031" style="text-decoration:;">反向代理</tspan></tspan></text></g></g><g id="SvgjsG1032" transform="translate(467.5124816894531,99)"><path id="SvgjsPath1033" d="M 0 0L 63 0L 63 63L 0 63Z" stroke="none" fill="url(#SvgjsPattern1034)"></path></g><g id="SvgjsG1036" transform="translate(439.0124816894531,156.5)"><path id="SvgjsPath1037" d="M 0 0L 120 0L 120 40L 0 40Z" stroke="none" fill="none"></path><g id="SvgjsG1038"><text id="SvgjsText1039" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="120px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="8" transform="rotate(0)"><tspan id="SvgjsTspan1040" dy="20" x="60"><tspan id="SvgjsTspan1041" style="text-decoration:;">目标服务器</tspan></tspan></text></g></g><g id="SvgjsG1042" transform="translate(145.01248168945312,116.89805825242718)"><path id="SvgjsPath1043" d="M 0 10.95728155339806L 78.39805825242718 10.95728155339806L 78.39805825242718 0L 95 16.601941747572816L 78.39805825242718 33.20388349514563L 78.39805825242718 22.246601941747574L 0 22.246601941747574L 0 10.95728155339806Z" stroke="rgba(100,181,246,1)" stroke-width="2" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1044"><text id="SvgjsText1045" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="95px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="6.976941747572818" transform="rotate(0)"></text></g></g><g id="SvgjsG1046" transform="translate(364.0124816894531,116.89805825242718)"><path id="SvgjsPath1047" d="M 0 10.95728155339806L 78.39805825242718 10.95728155339806L 78.39805825242718 0L 95 16.601941747572816L 78.39805825242718 33.20388349514563L 78.39805825242718 22.246601941747574L 0 22.246601941747574L 0 10.95728155339806Z" stroke="rgba(100,181,246,1)" stroke-width="2" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1048"><text id="SvgjsText1049" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="95px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="6.976941747572818" transform="rotate(0)"></text></g></g></svg>
  <p style="text-align:center; color: #888;">（反向代理）</p>
</div>
<p><strong>总的来说</strong>：</p>
<p>正向代理代理的是客户端（如通过代理访问谷歌），我们需要在客户端进行一些代理的设置；反向代理代理的是服务器（如 Nginx 代理 Tomcat 服务器），作为客户端的我们是无法感知到服务器的真实存在的</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T03:26:17.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Nginx 的安装</title>
    <id>https://www.snowji.cn/basic-skills/nginx/installation-of-nginx/</id>
    <link href="https://www.snowji.cn/basic-skills/nginx/installation-of-nginx/"/>
    <updated>2022-08-26T03:26:17.000Z</updated>
    <content type="html"><![CDATA[<h1 id="nginx-的安装"> Nginx 的安装</h1>
<h2 id="windows-下安装"> Windows 下安装</h2>
<blockquote>
<p>Windows 下的 Nginx 不能用于生产，一般用于开发目的或者尝鲜体验</p>
</blockquote>
<h3 id="下载-nginx"> 下载 Nginx</h3>
<p>从 <a href="http://nginx.org/en/download.html" target="_blank" rel="noopener noreferrer">官方网站</a> 下载稳定版本</p>
<p>以 nginx/Windows-1.18.0 为例，直接下载 nginx-1.18.0.zip</p>
<p>下载后解压，解压后如下：</p>
<div style="text-align: center;">
  <img src="./images/nginx-for-windows.png" alt="Nginx for Windows">
</div>
<h3 id="启动-nginx"> 启动 Nginx</h3>
<p>有两种方法启动 Nginx：</p>
<ul>
<li>直接双击 nginx.exe，双击后一个黑色的弹窗一闪而过（不建议用这种方式）</li>
<li>打开 cmd 命令窗口，切换到 Nginx 解压目录下，输入命令 <code>nginx.exe</code>，回车即可</li>
</ul>
<h3 id="检查-nginx-是否启动成功"> 检查 Nginx 是否启动成功</h3>
<p>直接在浏览器地址栏输入网址 <code>http://localhost:80</code> 回车，出现以下页面说明启动成功：</p>
<div style="text-align: center;">
  <img src="./images/welcome-to-nginx.png" alt="Welcome to nginx">
</div>
<h3 id="配置监听"> 配置监听</h3>
<p>Nginx 的配置文件是 <code>conf/</code> 目录下的 <code>nginx.conf</code>，默认配置的 Nginx 监听的端口为 80，如果 80 端口被占用可以修改为未被占用的端口即可</p>
<div><pre><code>server {
    listen       80;
    server_name  localhost;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>当我们修改了 Nginx 的配置文件 <code>nginx.conf</code> 时，不需要关闭 Nginx 后重新启动 Nginx，只需要执行命令 <code>nginx -s reload</code> 即可让改动生效</p>
<h3 id="关闭-nginx"> 关闭 Nginx</h3>
<p>如果使用 cmd 命令窗口启动 Nginx，关闭 cmd 窗口是不能结束 Nginx 进程的，可使用两种方法关闭 Nginx：</p>
<ul>
<li>输入 Nginx 命令 <code>nginx -s stop</code>（快速停止 Nginx）或 <code>nginx -s quit</code>（完整有序的停止 Nginx）</li>
<li>使用 taskkill：<code>taskkill /f /t /im nginx.exe</code></li>
</ul>
<blockquote>
<p>taskkill 是用来终止进程的<br>
/f 是强制终止<br>
/t 终止指定的进程和任何由此启动的子进程<br>
/im 根据名字指定要终止的进程</p>
</blockquote>
<h2 id="linux-下安装"> Linux 下安装</h2>
<p>有三种安装方式：</p>
<ul>
<li>编译安装：根据源码，根据实际业务需求，需要什么功能，编译时添加相应的模块。这种方式可以让 Nginx 最轻量化安装</li>
<li>自动化安装：配置好安装源，直接通过自动化安装工具安装。这种方式有可能会因为缺少相关依赖而安装失败
<ul>
<li>CentOS：<code>yum install nginx</code></li>
<li>Ubuntu：<code>apt-get install nginx</code></li>
</ul>
</li>
<li>二进制安装：类似于绿色免安装版，把编译安装好的程序封装起来的一个包</li>
</ul>
<p>一般采用第一种<strong>编译安装</strong>的方式</p>
<h3 id="准备依赖环境"> 准备依赖环境</h3>
<blockquote>
<p>以下命令，如果你是 root 账户，直接执行即可，不是的话前面加 <code>sudo</code> 获取权限</p>
</blockquote>
<p>Ubuntu（16.04、18.04、20.04）：</p>
<div><pre><code><span># 建议先执行下 apt-get 的更新</span>
<span>apt-get</span> update

<span># 安装 gcc 和 g++ 依赖库</span>
<span>apt-get</span> <span>install</span> build-essential
<span>apt-get</span> <span>install</span> libtool

<span># 安装 PCRE pcre-devel 依赖库</span>
<span>apt-get</span> <span>install</span> libpcre3 libpcre3-dev

<span># 安装 zlib 依赖库（注意 lib 后面是阿拉伯数字 1，不是字母 l）</span>
<span>apt-get</span> <span>install</span> zlib1g-dev

<span># 安装 OpenSSL 依赖库</span>
<span>apt-get</span> <span>install</span> openssl
<span>apt-get</span> <span>install</span> libssl-dev  <span># 未安装该库会报 SSL modules require the OpenSSL library.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>CentOS（7.6）：</p>
<div><pre><code><span># 安装 gcc 依赖库</span>
yum <span>install</span> gcc-c++

<span># 安装 PCRE pcre-devel 依赖库</span>
yum <span>install</span> -y pcre pcre-devel

<span># 安装 zlib 依赖库</span>
yum <span>install</span> -y zlib zlib-devel

<span># 安装 OpenSSL 依赖库</span>
yum <span>install</span> -y openssl openssl-devel
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><blockquote>
<p><strong>gcc 依赖库</strong>：安装 Nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装。<br>
<strong>PCRE pcre-devel 依赖库</strong>：PCRE（Perl Compatible Regular Expressions）是一个 Perl 库，包括 perl 兼容的正则表达式库。Nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 Linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库，Nginx 也需要此库</p>
<p><strong>zlib 依赖库</strong>：lib 库提供了很多种压缩和解压缩的方式，Nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要安装 zlib 库</p>
<p><strong>OpenSSL 依赖库</strong>：OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。Nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要安装 OpenSSL 库</p>
</blockquote>
<h3 id="准备源码包"> 准备源码包</h3>
<blockquote>
<p>以下命令，如果你是 root 账户，直接执行即可，不是的话前面加 <code>sudo</code> 获取权限</p>
</blockquote>
<p>从 <a href="http://nginx.org/en/download.html" target="_blank" rel="noopener noreferrer">官方网站</a> 下载稳定版本到任意目录（例如我一般会把软件放到 <code>/opt</code>），并解压</p>
<div><pre><code><span># 下载</span>
<span>wget</span> http://nginx.org/download/nginx-1.18.0.tar.gz

<span># 解压</span>
<span>tar</span> -zxvf nginx-1.18.0.tar.gz
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="编译安装"> 编译安装</h3>
<p>以下命令，如果你是 root 账户，直接执行即可，不是的话前面加 <code>sudo</code> 获取权限</p>
<p>首先进入 Nginx 安装包的解压目录：</p>
<div><pre><code><span>cd</span> nginx-1.18.0/
</code></pre>
<div><span>1</span><br></div></div><p>下面开始安装 Nginx：</p>
<div><pre><code><span># 预编译</span>
./configure --prefix<span>=</span>/usr/local/nginx --sbin-path<span>=</span>/usr/local/nginx/sbin/nginx --user<span>=</span>nginx --group<span>=</span>nginx --with-http_ssl_module --with-http_stub_status_module --with-http_gzip_static_module

<span># 检查是否编译正确</span>
<span>echo</span> <span>$?</span>  <span># 如果返回值是 0，就是执行成功；如果是返回值是 0 以外的值，就是失败。</span>

<span># 编译</span>
<span>make</span>

<span># 安装</span>
<span>make</span> <span>install</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><blockquote>
<p>在 ./configure 命令后跟了一堆参数，它们分别表示：</p>
<ul>
<li>--prefix：指定当前要安装的 Nginx 主程序目录</li>
<li>--sbin-path：安装完成后，使用 Nginx 的命令放在该目录下</li>
<li>--user：运行 Nginx 的用户</li>
<li>--group：运行 Nginx 的用户组</li>
<li>--with-(模块名)：为 Nginx 添加的模块</li>
<li>比较完整的配置项的含义请参见<a href="http://nginx.org/en/docs/configure.html" target="_blank" rel="noopener noreferrer">官方网站</a></li>
</ul>
</blockquote>
<h3 id="添加-nginx-用户"> 添加 Nginx 用户</h3>
<p>一般我们会创建一个不能 ssh 登录的帐号，这类账号专门用于启动服务，只是让服务启动起来，但是不能登录系统（提升安全性）</p>
<div><pre><code><span># 为 Nginx 创建一个不能 ssh 登陆的用户（预编译命令中指定的用户和用户组）</span>
<span>useradd</span> nginx -s /sbin/nologin -M
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><blockquote>
<p>在 useradd 命令后跟了两个参数，它们分别表示：</p>
<ul>
<li>-s：表示指定用户所用的 shell，此处为 <code>/sbin/nologin</code>，表示不登录</li>
<li>-M：表示不创建用户主目录</li>
</ul>
</blockquote>
<h3 id="验证安装成功"> 验证安装成功</h3>
<p>主要通过 Nginx 能否启动来验证是否安装成功，一般我会运行以下这些命令来测试</p>
<div><pre><code><span># 查找安装路径</span>
<span>whereis</span> nginx

<span># 查看 Nginx 的安装目录</span>
<span>cd</span> /usr/local/nginx  <span># 预编译命令中指定的路径</span>
<span>ls</span>

<span># 查看 Nginx 程序管理命令</span>
<span>cd</span> /usr/local/nginx/sbin  <span># 预编译命令中指定的路径</span>
<span>ls</span>

<span># 查看 Nginx 版本</span>
/usr/local/nginx/sbin/nginx -v

<span># 启动 Nginx</span>
/usr/local/nginx/sbin/nginx

<span># 查看 Nginx 进程</span>
<span>ps</span> -ef <span>|</span> <span>grep</span> nginx

<span># 检查 Nginx 启动的端口（默认 0.0.0.0:80）</span>
<span>netstat</span> -lntup <span>|</span> <span>grep</span> nginx
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>接下来通过浏览器访问 Nginx（服务器 IP:80），出现以下页面说明启动成功：</p>
<div style="text-align: center;">
  <img src="./images/welcome-to-nginx.png" alt="Welcome to nginx">
</div>
<p>如果不能访问，就要先看下服务器是不是开启了防火墙但又没开放端口（你可以选择不开防火墙，或者开完防火墙后记得开需要的端口）</p>
<div><pre><code><span># 查看状态, 发现当前是 dead 状态, 即防火墙未开启</span>
systemctl status firewalld

<span># 开启防火墙, 没有任何提示即开启成功</span>
<span># 再次查看状态, 显示 running 即已开启了</span>
systemctl start firewalld

<span># 开放默认端口号 80, 提示 success, 表示设置成功</span>
firewall-cmd --permanent --zone<span>=</span>public --add-port<span>=</span><span>80</span>/tcp

<span># 修改后需要重新加载配置才生效</span>
firewall-cmd --reload<span>;</span>

<span># 查看已经开放的端口</span>
firewall-cmd --permanent --list-port

<span># 关闭默认的端口号 80(如果需要的话, 执行这个命令就行了)</span>
firewall-cmd --permanent --zone<span>=</span>public --remove-port<span>=</span><span>80</span>/tcp

<span># 关闭防火墙(如果需要的话, 执行这个命令就行了)</span>
systemctl stop firewalld
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>如果使用的是阿里云等云厂家的服务器，<code>80</code> 端口是默认开启的，如果用了其它端口，则需要去云管理平台进行一些设置。大致的入口是：</p>
<p>进入云服务管理控制平台 ——&gt; 进入云服务器 ——&gt; 选择实例 ——&gt; 管理</p>
<ul>
<li>阿里云就找到：本实例安全组 --&gt; 配置规则 --&gt; 添加安全组规则</li>
<li>腾讯云就找到：防火墙 --&gt; 管理规则 --&gt; 添加规则</li>
<li>新增的规则就参考自带的 <code>80</code> 端口写就好了</li>
</ul>
<p>这里就是测一下能不能启停，生产环境要把 Nginx 加到系统自启。现在先关闭 Nginx</p>
<div><pre><code><span># 关闭 Nginx</span>
/usr/local/nginx/sbin/nginx -s stop
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T03:26:17.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">负载均衡</title>
    <id>https://www.snowji.cn/basic-skills/nginx/load-balancing/</id>
    <link href="https://www.snowji.cn/basic-skills/nginx/load-balancing/"/>
    <updated>2022-08-26T03:26:17.000Z</updated>
    <content type="html"><![CDATA[<h1 id="负载均衡"> 负载均衡</h1>
<h2 id="前言"> 前言</h2>
<p>当一台服务器的性能达到极限时，我们可以使用服务器集群来提高网站的整体性能。那么，在服务器集群中，需要有一台服务器充当调度者的角色，用户的所有请求都会首先由它接收，调度者再根据每台服务器的负载情况将请求分配给某一台后端服务器去处理</p>
<p>那么在这个过程中，调度者如何合理分配任务，保证所有后端服务器都将性能充分发挥，从而保持服务器集群的整体性能最优，这就是负载均衡问题</p>
<p>负载均衡的实现方式可以依托于多种调度算法，常见的有：</p>
<ul>
<li>轮循（Round Robin）</li>
<li>加权轮循（Weighted Round Robin）</li>
<li>最少连接数（Least Connection）</li>
<li>最少连接数慢启动时间（Least Connection Slow Start Time）</li>
<li>加权最少连接（Weighted Least Connection）</li>
<li>基于代理的自适应负载均衡（Agent Based Adaptive Balancing）</li>
<li>固定权重（Fixed Weighted）</li>
<li>加权响应（Weighted Response）</li>
<li>源IP哈希（Source IP Hash）</li>
</ul>
<h2 id="轮询"> 轮询</h2>
<ul>
<li>这种方法会将收到的请求循环分配到服务器集群中的每台机器，即有效服务器</li>
<li>如果使用这种方式，所有的标记进入虚拟服务的服务器应该有相近的资源容量以及负载形同的应用程序</li>
<li>如果所有的服务器有相同或者相近的性能那么选择这种方式会使服务器负载形同</li>
<li>基于这个前提，轮循调度是一个简单而有效的分配请求的方式</li>
<li>对于服务器不同的情况，选择这种方式就意味着能力比较弱的服务器也会在下一轮循环中接受轮循，即使这个服务器已经不能再处理当前这个请求了。这可能导致能力较弱的服务器超载</li>
</ul>
<h2 id="加权轮循"> 加权轮循</h2>
<p>这种算法解决了简单轮循调度算法的缺点：</p>
<ul>
<li>传入的请求按顺序被分配到集群中服务器，但是会考虑提前为每台服务器分配的权重</li>
<li>管理员只是简单的通过服务器的处理能力来定义各台服务器的权重。例如，能力最强的服务器A给的权重是100，同时能力最低的服务器给的权重是 50</li>
<li>意味着在服务器 B 接收到第一个请求之前前，服务器 A 会连续的接受到 2 个请求，以此类推</li>
</ul>
<h2 id="最少连接数"> 最少连接数</h2>
<p>以上两种方法都没有考虑的是系统不能识别在给定的时间里保持了多少连接，因此可能发生：</p>
<ul>
<li>服务器 B 服务器收到的连接比服务器 A 少但是它已经超载，因为服务器 B 上的用户打开连接持续的时间更长。这就是说连接数即服务器的负载是累加的</li>
<li>这种潜在的问题可以通过「最少连接数」算法来避免：
<ul>
<li>传入的请求是根据每台服务器当前所打开的连接数来分配的。即活跃连接数最少的服务器会自动接收下一个传入的请求</li>
<li>基本上和简单轮询的原则相同：所有拥有虚拟服务的服务器资源容量应该相近</li>
<li>值得注意的是，在流量率低的配置环境中，各服务器的流量并不是相同的，会优先考虑第一台服务器。这是因为，如果所有的服务器是相同的，那么第一个服务器优先，直到第一台服务器有连续的活跃流量，否则总是会优先选择第一台服务器</li>
</ul>
</li>
</ul>
<h2 id="最少连接数慢启动时间"> 最少连接数慢启动时间</h2>
<p>对最少连接数和带权重的最小连接数调度方法来说，当一个服务器刚加入线上环境是，可以为其配置一个时间段，在这段时间内连接数是有限制的而且是缓慢增加的。这为服务器提供了一个「过渡时间」以保证这个服务器不会因为刚启动后因为分配的连接数过多而超载。这个值在 L7 配置界面设置</p>
<h2 id="加权最少连接"> 加权最少连接</h2>
<p>如果服务器的资源容量各不相同，那么「加权最少连接」方法更合适：</p>
<ul>
<li>由管理员根据服务器情况定制的权重所决定的活跃连接数一般提供了一种对服务器非常平衡的利用，因为他它借鉴了最少连接和权重两者的优势。</li>
<li>一般这是一个非常公平的分配方式，因为它使用了连接数和服务器权重比例；集群中比例最低的服务器自动接收下一个请求。但是请注意，在低流量情况中使用这种方法时，请参考「最小连接数」方法中的注意事项</li>
</ul>
<h2 id="基于代理的自适应负载均衡"> 基于代理的自适应负载均衡</h2>
<p>除了上述方法之外，负载主机包含一个自适用逻辑用来定时监测服务器状态和该服务器的权重。对于非常强大的「基于代理的自适应负载均衡」方法来说，负载主机以这种方式来定时检测所有服务器负载情况：</p>
<ul>
<li>每台服务器都必须提供一个包含文件，这个文件包含一个 0~99 的数字用来标明改服务器的实际负载情况（0=空前，99=超载，101=失败，102=管理员禁用），而服务器同构 http get 方法来获取这个文件；同时对集群中服务器来说，以二进制文件形式提供自身负载情况也是该服务器工作之一，然而，并没有限制服务器如何计算自身的负载情况</li>
<li>根据服务器整体负载情况，有两种策略可以选择：在常规的操作中，调度算法通过收集的服务器负载值和分配给该服务器的连接数的比例计算出一个权重比例</li>
<li>因此，如果一个服务器负载过大，权重会通过系统透明的作重新调整。和加权轮循调度方法一样，不正确的分配可以被记录下来使得可以有效的为不同服务器分配不同的权重</li>
<li>然而，在流量非常低的环境下，服务器报上来的负载值将不能建立一个有代表性的样本；那么基于这些值来分配负载的话将导致失控以及指令震荡。因此，在这种情况下更合理的做法是基于静态的权重比来计算负载分配</li>
<li>当所有服务器的负载低于管理员定义的下限时，负载主机就会自动切换为加权轮循方式来分配请求；如果负载大于管理员定义的下限，那么负载主机又会切换回自适应方式</li>
</ul>
<h2 id="固定权重"> 固定权重</h2>
<ul>
<li>最高权重只有在其他服务器的权重值都很低时才使用</li>
<li>如果最高权重的服务器下降，则下一个最高优先级的服务器将为客户端服务</li>
<li>这种方式中每个真实服务器的权重需要基于服务器优先级来配置</li>
</ul>
<h2 id="加权响应"> 加权响应</h2>
<p>流量的调度是通过加权轮循方式：</p>
<ul>
<li>加权轮循中所使用的权重是根据服务器有效性检测的响应时间来计算</li>
<li>每个有效性检测都会被计时，用来标记它响应成功花了多长时间</li>
<li>但是需要注意的是，这种方式假定服务器心跳检测是基于机器的快慢，但是这种假设也许不总是能够成立</li>
<li>所有服务器在虚拟服务上的响应时间的总和加在一起，通过这个值来计算单个服务物理服务器的权重；这个权重值大约每 15 秒计算一次</li>
</ul>
<h2 id="源ip哈希"> 源IP哈希</h2>
<ul>
<li>
<p>这种方式通过生成请求源 IP 的哈希值，并通过这个哈希值来找到正确的真实服务器</p>
</li>
<li>
<p>这意味着对于同一主机来说他对应的服务器总是相同</p>
</li>
<li>
<p>使用这种方式，你不需要保存任何源IP。但是需要注意，这种方式可能导致服务器负载不平衡</p>
</li>
</ul>
<h2 id="参考资料"> 参考资料</h2>
<ul>
<li><a href="https://www.runoob.com/w3cnote/balanced-algorithm.html" title="负载均衡调度算法大全" target="_blank" rel="noopener noreferrer">负载均衡调度算法大全</a>（转载）</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T03:26:17.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Nginx 安全访问控制</title>
    <id>https://www.snowji.cn/basic-skills/nginx/ngx-http-access-module/</id>
    <link href="https://www.snowji.cn/basic-skills/nginx/ngx-http-access-module/"/>
    <updated>2022-08-26T03:26:17.000Z</updated>
    <content type="html"><![CDATA[<h1 id="nginx-安全访问控制"> Nginx 安全访问控制</h1>
<h2 id="模块介绍"> 模块介绍</h2>
<p>有时候我们需要根据客户端 IP 来限制访问，如果是不允许的 IP 则返回 403 Forbidden，如下所示：</p>
<div style="text-align: center;">
  <img src="./images/nginx-403-forbidden.png" height="200" alt="403 Forbidden">
</div>
<p>该功能用到了 <code>ngx_http_access_module</code> 这个模块，该模块默认是关闭的。</p>
<p>语法：</p>
<ul>
<li>配置允许访问：<code>allow 地址值;</code></li>
<li>配置拒绝访问：<code>deny 地址值;</code></li>
<li>地址值的形式支持：address | CIDR | unix: | all</li>
</ul>
<p>可以将它配置在 <code>http</code>，<code>server</code>，<code>location</code>，<code>limit_except</code> 中的任一位置。</p>
<h2 id="配置案例"> 配置案例</h2>
<p>假设我们有个网站，要限制外人不能访问管理页面（只允许指定 IP 访问 <code>/admin</code> 开始的 uri）。</p>
<div><div><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><br><br><br></div><pre><code>server <span>{</span>
    listen <span>80</span><span>;</span>
    server_name  www.fedbook.cn<span>;</span>
    root /sites/fedbook<span>;</span>
    index index.html<span>;</span>

    location /admin <span>{</span>
        allow <span>192.168</span>.10.50<span>;</span>
        deny all<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="参考资料"> 参考资料</h2>
<ul>
<li><a href="http://nginx.org/en/docs/http/ngx_http_access_module.html" title="Module ngx_http_access_module" target="_blank" rel="noopener noreferrer">Module ngx_http_access_module</a></li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T03:26:17.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Nginx 部署前后端分离项目</title>
    <id>https://www.snowji.cn/basic-skills/nginx/practice-in-front-end-separation-project/</id>
    <link href="https://www.snowji.cn/basic-skills/nginx/practice-in-front-end-separation-project/"/>
    <updated>2022-08-26T03:26:17.000Z</updated>
    <content type="html"><![CDATA[<h1 id="nginx-部署前后端分离项目"> Nginx 部署前后端分离项目</h1>
<h2 id="部署目标"> 部署目标</h2>
<ul>
<li>解决前后端分离项目的跨域问题</li>
<li>前端路由采用 HTML5 History 模式</li>
<li>配置反向代理 Websocket</li>
</ul>
<h2 id="部署前准备"> 部署前准备</h2>
<ul>
<li>将前端代码打包成为纯静态文件，上传至服务器</li>
<li>后端代码启动在服务器，监听 <code>30000</code> 端口</li>
</ul>
<h2 id="nginx-配置"> Nginx 配置</h2>
<ul>
<li><code>location</code> 为代理接口，可以转发代理后端的请求接口域名或者 ip，即可解决接口跨域问题</li>
<li>升级 Http1.1 到 Websocket 协议</li>
</ul>
<div><pre><code>upstream http_proxy <span>{</span>
    server <span>127.0</span>.0.1:30000<span>;</span>
<span>}</span>

upstream ws_proxy <span>{</span>
    server <span>127.0</span>.0.1:30000<span>;</span>
<span>}</span>

server <span>{</span>
    listen       <span>80</span><span>;</span>
    server_name  www.wenyuanblog.com wenyuanblog.com<span>;</span>

    root /home/spa-project/wenyuanblog<span>;</span>
    index index.html<span>;</span>

    <span># 将 404 错误页面重定向到 index.html 可以解决 history 模式访问不到页面问题</span>
    error_page    <span>404</span>         /index.html<span>;</span>

    location / <span>{</span>
        try_files <span>$uri</span> <span>$uri</span>/ /index.html<span>;</span>
    <span>}</span>

    location ^~ /api/ <span>{</span>
        proxy_pass http://http_proxy<span>;</span>
        <span># timeout</span>
        proxy_connect_timeout <span>75</span><span>;</span>
        proxy_read_timeout <span>150</span><span>;</span>
        proxy_send_timeout <span>150</span><span>;</span>
        client_max_body_size 50m<span>;</span>
        <span># redefine request header to backend</span>
        proxy_set_header  Host              <span>$http_host</span><span>;</span>
        proxy_set_header  X-Real-IP         <span>$remote_addr</span><span>;</span>
        proxy_set_header  X-Forwarded-For   <span>$proxy_add_x_forwarded_for</span><span>;</span>
        proxy_set_header  X-Forwarded-Proto <span>$scheme</span><span>;</span>
    <span>}</span>

    location ^~ /ws/ <span>{</span>
        proxy_pass http://ws_proxy<span>;</span>
        <span># timeout</span>
        proxy_connect_timeout <span>75</span><span>;</span>
        proxy_read_timeout <span>600</span><span>;</span>  <span># Websocket 保持长连接</span>
        proxy_send_timeout <span>150</span><span>;</span>
        client_max_body_size 50m<span>;</span>
        <span># http => websocket</span>
        proxy_http_version <span>1.1</span><span>;</span>
        proxy_set_header Upgrade <span>$http_upgrade</span><span>;</span>
        proxy_set_header Connection <span>"Upgrade"</span><span>;</span>
        <span># redefine request header to backend</span>
        proxy_set_header  Host              <span>$host</span><span>;</span>
        proxy_set_header  X-Real-IP         <span>$remote_addr</span><span>;</span>
        proxy_set_header  X-Forwarded-For   <span>$proxy_add_x_forwarded_for</span><span>;</span>
        proxy_set_header  X-Forwarded-Proto <span>$scheme</span><span>;</span>
    <span>}</span>

    location ~* <span>\</span>.<span>(</span>html<span>|</span>htm<span>)</span>$ <span>{</span> 
        expires 1h<span>;</span>
        add_header Cache-Control <span>"public"</span><span>;</span> 
    <span>}</span>
    
    location ~* <span>\</span>.<span>(</span>css<span>|</span>js<span>|</span>jpg<span>|</span>jpeg<span>|</span>gif<span>|</span>png<span>|</span>ico<span>|</span>cur<span>|</span>gz<span>|</span>svg<span>|</span>svgz<span>|</span>map<span>|</span>mp4<span>|</span>ogg<span>|</span>ogv<span>|</span>webm<span>|</span>htc<span>)</span>$ <span>{</span> 
        expires 24h<span>;</span>
        access_log off<span>;</span> 
        add_header Cache-Control <span>"public"</span><span>;</span> 
    <span>}</span> 
    
    access_log  /var/log/nginx/access/wenyuanblog.log<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br></div></div><p>部分配置项解析：</p>
<ul>
<li>
<p><code>proxy_connect_timeout</code>：后端服务器连接的超时时间，发起握手等候响应超时时间（默认为 60 秒，官方推荐最长不要超过 75 秒）</p>
</li>
<li>
<p><code>proxy_read_timeout</code>：连接成功后，Nginx 能够等待后端服务器响应的时间（默认 60 秒）</p>
</li>
<li>
<p><code>proxy_send_timeout</code>：后端服务器数据回传时间，就是在规定时间之内后端服务器必须传完所有的数据（默认 60 秒）</p>
</li>
<li>
<p><code>client_max_body_size</code>：Nginx 对上传文件大小的限制（默认是 1M）</p>
</li>
<li>
<p><code>proxy_set_header</code>：用来重定义发往后端服务器的请求头</p>
<ul>
<li><code>Host $http_host;</code>：将原 http 请求 Header 中的 Host 字段也放到转发的请求</li>
<li><code>X-Real-IP $remote_addr;</code>：前一节点的 IP（并不一定是用户的真实 IP）</li>
<li><code>X-Forwarded-For $proxy_add_x_forwarded_for;</code>：前一节点的 X-Forwarded-For 的值</li>
</ul>
<blockquote>
<p>X-Real-IP 一般是最后一级代理将上游 IP 地址添加到该头中，X-Forwarded-For 是多个 IP 地址，而 X-Real-IP 是一个</p>
</blockquote>
<ul>
<li><code>X-Forwarded-Proto $scheme;</code>：拿到来源的传输协议（HTTP 或 HTTPS）</li>
</ul>
</li>
</ul>
<h2 id="参考资料"> 参考资料</h2>
<ul>
<li><a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_set_header" title="Module ngx_http_proxy_module：proxy_set_header" target="_blank" rel="noopener noreferrer">Module ngx_http_proxy_module：proxy_set_header</a></li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T03:26:17.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Nginx 页面安全认证</title>
    <id>https://www.snowji.cn/basic-skills/nginx/ngx-http-auth-basic-module/</id>
    <link href="https://www.snowji.cn/basic-skills/nginx/ngx-http-auth-basic-module/"/>
    <updated>2022-08-26T03:26:17.000Z</updated>
    <content type="html"><![CDATA[<h1 id="nginx-页面安全认证"> Nginx 页面安全认证</h1>
<h2 id="模块介绍"> 模块介绍</h2>
<p>有时候出于权限和安全考虑，我们希望某些页面不允许随便访问，必须通过用户认证才可以访问，如下所示：</p>
<div style="text-align: center;">
  <img src="./images/nginx-http-auth-basic.png" height="200" alt="Nginx Http Auth Basic">
</div>
<p>该功能用到了 <code>ngx_http_auth_basic_module</code> 这个模块，该模块默认是关闭的。</p>
<p>语法：</p>
<ul>
<li>配置弹框提示：<code>auth_basic &quot;提示语&quot;;</code></li>
<li>配置密码路径：<code>auth_basic_user_file 密码文件路径;</code></li>
</ul>
<p>可以将它配置在 <code>http</code>，<code>server</code>，<code>location</code>，<code>limit_except</code> 中的任一位置。</p>
<h2 id="htpasswd-创建密码文件"> htpasswd 创建密码文件</h2>
<p>首先需要准备用户文件，用户名密码格式为：<code>用户名:密码</code>，其中密码不是明文。我们需要借助于 htpasswd 加密工具生成。</p>
<p>查看服务器中是否已经安装了 htpasswd：</p>
<div><pre><code><span>whereis</span> htpasswd
</code></pre>
<div><span>1</span><br></div></div><p>如果没有安装，需要先进行安装：</p>
<div><pre><code><span># Ubuntu 系统下安装 htpasswd</span>
<span>sudo</span> <span>apt-get</span> <span>install</span> apache2-utils

<span># CentOS 系统下安装 htpasswd</span>
<span>sudo</span> yum <span>install</span> -y httpd-tools
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>htpasswd 工具的语法为：</p>
<ul>
<li>htpasswd(选项)(参数)</li>
</ul>
<blockquote>
<ul>
<li><code>-c</code>：创建一个加密文件；</li>
<li><code>-n</code>：不更新加密文件，只将加密后的用户名密码显示在屏幕上；</li>
<li><code>-m</code>：默认采用 MD5 算法对密码进行加密；</li>
<li><code>-d</code>：采用 CRYPT 算法对密码进行加密；</li>
<li><code>-p</code>：不对密码进行进行加密，即明文密码；</li>
<li><code>-s</code>：采用 SHA 算法对密码进行加密；</li>
<li><code>-b</code>：在命令行中一并输入用户名和密码而不是根据提示输入密码；</li>
<li><code>-D</code>：删除指定的用户。</li>
</ul>
</blockquote>
<p>通过 htpasswd 工具生成用户名密码文件给 Nginx 使用：</p>
<div><pre><code><span># 进入 Nginx 文件</span>
<span>cd</span> /usr/local/nginx/

<span># 如果是首次创建，通过 -c 选项可以在当前目录创建一个加密文件</span>
htpasswd -bc passwd.db admin <span>123456</span>

<span># 去掉 -c 选项，即可在第一个用户之后添加第二个用户</span>
htpasswd -b passwd.db <span>test</span> <span>123456</span>

<span># 利用 htpasswd 命令删除用户名和密码</span>
htpasswd -D passwd.db <span>test</span>

<span># 如果要利用 htpasswd 命令修改密码</span>
<span># 先删除指定用户，再创建用户即可实现修改密码的功能</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>出于安全考虑，我们最好修改一下用户文件 <code>passwd.db</code> 的权限：</p>
<div><pre><code><span># 修改用户文件权限 </span>
<span>chmod</span> <span>400</span> /usr/local/nginx/passwd.db

<span># 修改用户文件属主和属组</span>
<span>chown</span> root:root /usr/local/nginx/passwd.db
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>此时的 Nginx 文件目录结构：</p>
<div><pre><code>├── nginx
    │── html
    │── logs
    │── sbin
    │── ...
    │── passwd.db              # 用户文件，存储用户认证信息
    └── conf
        ├── ...
        ├── nginx.conf         # 主配置文件
        └── vhosts             # 子配置文件的目录
            ├── web.conf       # 子配置文件 1
            └── api.conf       # 子配置文件 2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="配置案例"> 配置案例</h2>
<p>前端我们已经通过使用 htpasswd 工具，在 <code>/usr/local/nginx/</code> 目录下生成了用户文件 <code>passwd.db</code>，接下来在 Nginx 配置文件中进行配置</p>
<p>假设我们有个网站，要限制外人不能访问管理页面（只允许指定 IP 访问 <code>/admin</code> 开始的 uri）</p>
<div><div><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><br><br><br></div><pre><code>server <span>{</span>
    listen <span>80</span><span>;</span>
    server_name  www.fedbook.cn<span>;</span>
    root /sites/fedbook<span>;</span>
    index index.html<span>;</span>

    location /download <span>{</span>
        autoindex on<span>;</span>
        auth_basic           <span>"请输入用户名及密码"</span><span>;</span>
        auth_basic_user_file /usr/local/nginx/passwd.db<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="参考资料"> 参考资料</h2>
<ul>
<li><a href="https://nginx.org/en/docs/http/ngx_http_auth_basic_module.html" title="Module ngx_http_auth_basic_module" target="_blank" rel="noopener noreferrer">Module ngx_http_auth_basic_module</a></li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T03:26:17.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Nginx 文件列表功能</title>
    <id>https://www.snowji.cn/basic-skills/nginx/ngx-http-autoindex-module/</id>
    <link href="https://www.snowji.cn/basic-skills/nginx/ngx-http-autoindex-module/"/>
    <updated>2022-08-26T03:26:17.000Z</updated>
    <content type="html"><![CDATA[<h1 id="nginx-文件列表功能"> Nginx 文件列表功能</h1>
<h2 id="模块介绍"> 模块介绍</h2>
<p>有时候我们需要搭建一个文件下载平台，类似镜像站的内容列表，供用户下载，如下所示：</p>
<div style="text-align: center;">
  <img src="./images/mirrors-of-ustc.png" height="200" alt="中国科学技术大学开源镜像站">
</div>
<p>该功能用到了 <code>ngx_http_autoindex_module</code> 这个模块，该模块默认是关闭的</p>
<p>语法：</p>
<ul>
<li>开启文件列表功能：<code>autoindex on;</code></li>
</ul>
<p>可以将它配置在 <code>http</code>，<code>server</code>，<code>location</code> 中的任一位置</p>
<h2 id="配置案例"> 配置案例</h2>
<p>需要将 <code>/sites/fedbook/download/</code> 目录变成可下载的内容列表，只需配置如下 <code>location</code>：</p>
<div><div><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br></div><pre><code>server <span>{</span>
    listen <span>80</span><span>;</span>
    server_name  www.fedbook.cn<span>;</span>
    root /sites/fedbook<span>;</span>
    index index.html<span>;</span>

    location /download <span>{</span>
        autoindex on<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="参考资料"> 参考资料</h2>
<ul>
<li><a href="https://nginx.org/en/docs/http/ngx_http_autoindex_module.html" title="Module ngx_http_autoindex_module" target="_blank" rel="noopener noreferrer">Module ngx_http_autoindex_module</a></li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T03:26:17.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">SYN Flood 攻击</title>
    <id>https://www.snowji.cn/basic-skills/network/ipsec-internet/syn-attack/</id>
    <link href="https://www.snowji.cn/basic-skills/network/ipsec-internet/syn-attack/"/>
    <updated>2022-09-02T02:21:36.000Z</updated>
    <content type="html"><![CDATA[<h1 id="syn-flood-攻击"> SYN Flood 攻击</h1>
<p>需要先了解 TCP 连接的三次握手机制，可参考：<a href="/basic-skills/network/TCP%E5%8D%8F%E8%AE%AE">TCP 协议</a></p>
<h2 id="背景"> 背景</h2>
<ul>
<li>Client 发送 SYN 包给 Server 后，Server 回给 Client 的 SYN-ACK 一直没收到 Client 的 ACK 确认</li>
<li>此时这个连接既没建立起来，也不能算失败</li>
<li>需要有一个超时时间让 Server 将这个连接断开，否则这个连接就会一直占用 Server 的 SYN 连接队列中的一个位置</li>
<li>大量这样的连接就会将 Server 的 SYN 连接队列耗尽，让正常的连接无法得到处理</li>
<li>目前 Linux 下默认会进行 5次 重发 SYN-ACK 包</li>
<li>重试的间隔时间从 1s 开始，下次的重试间隔时间是前一次的双倍</li>
<li>5次 的重试时间间隔为 1s, 2s, 4s, 8s, 16s，总共 31s</li>
<li>第 5次 发出后还要等 32s 就知道第 5次 超时了，所以总共需要 <code>1s + 2s + 4s+ 8s+ 16s + 32s = 63s</code>，TCP 才会把断开这个连接</li>
<li>由于 SYN 超时需要 63秒，那么就给攻击者一个攻击服务器的机会，攻击者在短时间内发送大量的 SYN 包给 Server(俗称 SYN flood 攻击)，用于耗尽 Server 的 SYN 队列</li>
</ul>
<h2 id="什么是-syn-攻击"> 什么是 SYN 攻击</h2>
<ul>
<li>攻击客户端在短时间内伪造大量不存在的 IP 地址，向服务器不断地发送 SYN 包，服务器回复确认包，并等待客户端的确认</li>
<li>由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的 SYN 包将长时间占用未连接队列，正常的 SYN 请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪</li>
<li>SYN 攻击是一种典型的 DoS 攻击</li>
</ul>
<h2 id="如何检测-syn-攻击"> 如何检测 SYN 攻击</h2>
<ul>
<li>当在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击</li>
<li>在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击</li>
</ul>
<h2 id="如何防御-syn-攻击"> 如何防御 SYN 攻击</h2>
<ul>
<li>SYN 攻击不能完全被阻止，除非将 TCP 协议重新设计</li>
<li>我们所做的是尽可能的减轻 SYN 攻击的危害，常见的防御 SYN 攻击的方法有如下几种：
<ul>
<li>缩短超时（SYN Timeout）</li>
<li>时间增加最大半连接数</li>
<li>过滤网关防护 SYN</li>
<li>cookies 技术</li>
</ul>
</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T02:21:36.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Nginx 设置开机自启</title>
    <id>https://www.snowji.cn/basic-skills/nginx/set-auto-start-after-server-reboot/</id>
    <link href="https://www.snowji.cn/basic-skills/nginx/set-auto-start-after-server-reboot/"/>
    <updated>2022-08-26T03:26:17.000Z</updated>
    <content type="html"><![CDATA[<h1 id="nginx-设置开机自启"> Nginx 设置开机自启</h1>
<p>在生产环境中，如果我们的服务器意外重启，此时要是 Nginx 没有随服务器启动起来，我们的 Web 站点就会是无应答的状态，这会给我们带来不同程度损失</p>
<p>因此我们需要设置 Nginx 开机自启</p>
<h2 id="ubuntu-设置开机自启"> Ubuntu 设置开机自启</h2>
<blockquote>
<p>以下所有命令，如果你是 root 账户，直接执行即可，不是的话前面加 <code>sudo</code> 获取权限</p>
</blockquote>
<p>在 Ubuntu 和 Debian 下，我们通过 update-rc.d 设置 Nginx 的开机启动</p>
<p>经实验，以下步骤适用于 Ubuntu 16.04、18.04、20.04 版本的系统</p>
<h3 id="创建启动脚本"> 创建启动脚本</h3>
<p>在 Linux 系统的 <code>/etc/init.d/</code> 目录下创建 <code>nginx</code> 文件：</p>
<div><pre><code><span>vim</span> /etc/init.d/nginx
</code></pre>
<div><span>1</span><br></div></div><p>往该文件内写入以下脚本内容（该脚本内容来自网络）：</p>
<div><pre><code><span>#! /bin/sh</span>
<span># chkconfig: 2345 55 25</span>
<span># Description: Startup script for nginx webserver on Debian. Place in /etc/init.d and</span>
<span># run 'update-rc.d -f nginx defaults', or use the appropriate command on your</span>
<span># distro. For CentOS/Redhat run: 'chkconfig --add nginx'</span>

<span>### BEGIN INIT INFO</span>
<span># Provides:          nginx</span>
<span># Required-Start:    $all</span>
<span># Required-Stop:     $all</span>
<span># Default-Start:     2 3 4 5</span>
<span># Default-Stop:      0 1 6</span>
<span># Short-Description: starts the nginx web server</span>
<span># Description:       starts nginx using start-stop-daemon</span>
<span>### END INIT INFO</span>

<span># Author:   licess</span>
<span># website:  http://lnmp.org</span>

<span><span>PATH</span></span><span>=</span>/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
<span>NAME</span><span>=</span>nginx
<span>NGINX_BIN</span><span>=</span>/usr/local/nginx/sbin/<span>$NAME</span>
<span>CONFIGFILE</span><span>=</span>/usr/local/nginx/conf/<span>$NAME</span>.conf
<span>PIDFILE</span><span>=</span>/usr/local/nginx/logs/<span>$NAME</span>.pid

<span>case</span> <span>"<span>$1</span>"</span> <span>in</span>
    start<span>)</span>
        <span>echo</span> -n <span>"Starting <span>$NAME</span>... "</span>

        <span>if</span> <span>netstat</span> -tnpl <span>|</span> <span>grep</span> -q nginx<span>;</span><span>then</span>
            <span>echo</span> <span>"<span>$NAME</span> (pid <span><span>`</span>pidof $NAME<span>`</span></span>) already running."</span>
            <span>exit</span> <span>1</span>
        <span>fi</span>

        <span>$NGINX_BIN</span> -c <span>$CONFIGFILE</span>

        <span>if</span> <span>[</span> <span>"<span>$?</span>"</span> <span>!=</span> <span>0</span> <span>]</span> <span>;</span> <span>then</span>
            <span>echo</span> <span>" failed"</span>
            <span>exit</span> <span>1</span>
        <span>else</span>
            <span>echo</span> <span>" done"</span>
        <span>fi</span>
        <span>;</span><span>;</span>

    stop<span>)</span>
        <span>echo</span> -n <span>"Stoping <span>$NAME</span>... "</span>

        <span>if</span> <span>!</span> <span>netstat</span> -tnpl <span>|</span> <span>grep</span> -q nginx<span>;</span> <span>then</span>
            <span>echo</span> <span>"<span>$NAME</span> is not running."</span>
            <span>exit</span> <span>1</span>
        <span>fi</span>

        <span>$NGINX_BIN</span> -s stop

        <span>if</span> <span>[</span> <span>"<span>$?</span>"</span> <span>!=</span> <span>0</span> <span>]</span> <span>;</span> <span>then</span>
            <span>echo</span> <span>" failed. Use force-quit"</span>
            <span>exit</span> <span>1</span>
        <span>else</span>
            <span>echo</span> <span>" done"</span>
        <span>fi</span>
        <span>;</span><span>;</span>

    status<span>)</span>
        <span>if</span> <span>netstat</span> -tnpl <span>|</span> <span>grep</span> -q nginx<span>;</span> <span>then</span>
            <span>PID</span><span>=</span><span><span>`</span>pidof nginx<span>`</span></span>
            <span>echo</span> <span>"<span>$NAME</span> (pid <span>$PID</span>) is running..."</span>
        <span>else</span>
            <span>echo</span> <span>"<span>$NAME</span> is stopped"</span>
            <span>exit</span> <span>0</span>
        <span>fi</span>
        <span>;</span><span>;</span>

    force-quit<span>)</span>
        <span>echo</span> -n <span>"Terminating <span>$NAME</span>... "</span>

        <span>if</span> <span>!</span> <span>netstat</span> -tnpl <span>|</span> <span>grep</span> -q nginx<span>;</span> <span>then</span>
            <span>echo</span> <span>"<span>$NAME</span> is not running."</span>
            <span>exit</span> <span>1</span>
        <span>fi</span>

        <span>kill</span> <span><span>`</span>pidof $NAME<span>`</span></span>

        <span>if</span> <span>[</span> <span>"<span>$?</span>"</span> <span>!=</span> <span>0</span> <span>]</span> <span>;</span> <span>then</span>
            <span>echo</span> <span>" failed"</span>
            <span>exit</span> <span>1</span>
        <span>else</span>
            <span>echo</span> <span>" done"</span>
        <span>fi</span>
        <span>;</span><span>;</span>

    restart<span>)</span>
        <span>$0</span> stop
        <span>sleep</span> <span>1</span>
        <span>$0</span> start
        <span>;</span><span>;</span>

    reload<span>)</span>
        <span>echo</span> -n <span>"Reload service <span>$NAME</span>... "</span>

        <span>if</span> <span>netstat</span> -tnpl <span>|</span> <span>grep</span> -q nginx<span>;</span> <span>then</span>
            <span>$NGINX_BIN</span> -s reload
            <span>echo</span> <span>" done"</span>
        <span>else</span>
            <span>echo</span> <span>"<span>$NAME</span> is not running, can't reload."</span>
            <span>exit</span> <span>1</span>
        <span>fi</span>
        <span>;</span><span>;</span>

    configtest<span>)</span>
        <span>echo</span> -n <span>"Test <span>$NAME</span> configure files... "</span>

        <span>$NGINX_BIN</span> -t
        <span>;</span><span>;</span>

    *<span>)</span>
        <span>echo</span> <span>"Usage: <span>$0</span> {start|stop|force-quit|restart|reload|status|configtest}"</span>
        <span>exit</span> <span>1</span>
        <span>;</span><span>;</span>

<span>esac</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br></div></div><h3 id="修改部分参数"> 修改部分参数</h3>
<p>如果你的 Nginx 是通过编译安装的，则需要根据实际安装时的设置，修改启动脚本中的几个参数（大约在第）：</p>
<div><pre><code><span># 如果是按照我方式编译安装的，则不用修改，默认参数值就是我的实际安装位置</span>
<span>NGINX_BIN</span><span>=</span>/usr/local/nginx/sbin/<span>$NAME</span>
<span>CONFIGFILE</span><span>=</span>/usr/local/nginx/conf/<span>$NAME</span>.conf
<span>PIDFILE</span><span>=</span>/usr/local/nginx/logs/<span>$NAME</span>.pid
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="添加执行权限"> 添加执行权限</h3>
<p>上述脚本保存为 <code>/etc/init.d/nginx</code>，然后设置文件的执行权限：</p>
<div><pre><code><span># 给所有用户给予可执行权限</span>
<span>chmod</span> a+x /etc/init.d/nginx
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>至此就可以通过下面指令控制 Nginx 的启动、停止和重新加载了：</p>
<div><pre><code><span># 启动</span>
/etc/init.d/nginx start

<span># 停止</span>
/etc/init.d/nginx stop

<span># 重新加载配置</span>
/etc/init.d/nginx reload
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="添加至开机自启动"> 添加至开机自启动</h3>
<p>现在将 Nginx 服务加入开机自启动：</p>
<div><pre><code><span># 设置开机启动</span>
<span>sudo</span> update-rc.d nginx defaults

<span># 启动 Nginx</span>
<span>sudo</span> /etc/init.d/nginx start
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>当然了，如果需要关闭开机启动的功能：</p>
<div><pre><code><span># 取消开机启动</span>
<span>sudo</span> update-rc.d -f nginx remove
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="centos-6-x-设置开机自启"> CentOS 6.x 设置开机自启</h2>
<blockquote>
<p>以下所有命令，如果你是 root 账户，直接执行即可，不是的话前面加 <code>sudo</code> 获取权限</p>
</blockquote>
<h3 id="创建启动脚本-2"> 创建启动脚本</h3>
<p>在 Linux 系统的 <code>/etc/init.d/</code> 目录下创建 <code>nginx</code> 文件：</p>
<div><pre><code><span>vim</span> /etc/init.d/nginx
</code></pre>
<div><span>1</span><br></div></div><p>往该文件内写入以下脚本内容（该脚本内容来自<a href="https://www.nginx.com/resources/wiki/start/topics/examples/redhatnginxinit/" target="_blank" rel="noopener noreferrer">官方网站 - Red Hat NGINX Init Script</a>）：</p>
<div><pre><code><span>#!/bin/sh</span>
<span>#</span>
<span># nginx - this script starts and stops the nginx daemon</span>
<span>#</span>
<span># chkconfig:   - 85 15</span>
<span># description:  NGINX is an HTTP(S) server, HTTP(S) reverse \</span>
<span>#               proxy and IMAP/POP3 proxy server</span>
<span># processname: nginx</span>
<span># config:      /etc/nginx/nginx.conf</span>
<span># config:      /etc/sysconfig/nginx</span>
<span># pidfile:     /var/run/nginx.pid</span>

<span># Source function library.</span>
<span>.</span> /etc/rc.d/init.d/functions

<span># Source networking configuration.</span>
<span>.</span> /etc/sysconfig/network

<span># Check that networking is up.</span>
<span>[</span> <span>"<span>$NETWORKING</span>"</span> <span>=</span> <span>"no"</span> <span>]</span> <span>&amp;&amp;</span> <span>exit</span> <span>0</span>

<span>nginx</span><span>=</span><span>"/usr/sbin/nginx"</span>
<span>prog</span><span>=</span><span><span>$(</span><span>basename</span> $nginx<span>)</span></span>

<span>NGINX_CONF_FILE</span><span>=</span><span>"/etc/nginx/nginx.conf"</span>

<span>[</span> -f /etc/sysconfig/nginx <span>]</span> <span>&amp;&amp;</span> <span>.</span> /etc/sysconfig/nginx

<span>lockfile</span><span>=</span>/var/lock/subsys/nginx

<span>make_dirs</span><span>(</span><span>)</span> <span>{</span>
   <span># make required directories</span>
   <span>user</span><span>=</span><span><span>`</span>$nginx -V <span><span>2</span>></span><span>&amp;1</span> <span>|</span> <span>grep</span> <span>"configure arguments:.*--user="</span> <span>|</span> <span>sed</span> <span>'s/[^*]*--user=\([^ ]*\).*/\1/g'</span> -<span>`</span></span>
   <span>if</span> <span>[</span> -n <span>"<span>$user</span>"</span> <span>]</span><span>;</span> <span>then</span>
      <span>if</span> <span>[</span> -z <span>"<span><span>`</span><span>grep</span> $user /etc/passwd<span>`</span></span>"</span> <span>]</span><span>;</span> <span>then</span>
         <span>useradd</span> -M -s /bin/nologin <span>$user</span>
      <span>fi</span>
      <span>options</span><span>=</span><span><span>`</span>$nginx -V <span><span>2</span>></span><span>&amp;1</span> <span>|</span> <span>grep</span> <span>'configure arguments:'</span><span>`</span></span>
      <span>for</span> <span>opt</span> <span>in</span> <span>$options</span><span>;</span> <span>do</span>
          <span>if</span> <span>[</span> <span><span>`</span><span>echo</span> $opt <span>|</span> <span>grep</span> <span>'.*-temp-path'</span><span>`</span></span> <span>]</span><span>;</span> <span>then</span>
              <span>value</span><span>=</span><span><span>`</span><span>echo</span> $opt <span>|</span> <span>cut</span> -d <span>"="</span> -f <span>2</span><span>`</span></span>
              <span>if</span> <span>[</span> <span>!</span> -d <span>"<span>$value</span>"</span> <span>]</span><span>;</span> <span>then</span>
                  <span># echo "creating" $value</span>
                  <span>mkdir</span> -p <span>$value</span> <span>&amp;&amp;</span> <span>chown</span> -R <span>$user</span> <span>$value</span>
              <span>fi</span>
          <span>fi</span>
       <span>done</span>
    <span>fi</span>
<span>}</span>

<span>start</span><span>(</span><span>)</span> <span>{</span>
    <span>[</span> -x <span>$nginx</span> <span>]</span> <span>||</span> <span>exit</span> <span>5</span>
    <span>[</span> -f <span>$NGINX_CONF_FILE</span> <span>]</span> <span>||</span> <span>exit</span> <span>6</span>
    make_dirs
    <span>echo</span> -n $<span>"Starting <span>$prog</span>: "</span>
    daemon <span>$nginx</span> -c <span>$NGINX_CONF_FILE</span>
    <span>retval</span><span>=</span><span>$?</span>
    <span>echo</span>
    <span>[</span> <span>$retval</span> -eq <span>0</span> <span>]</span> <span>&amp;&amp;</span> <span>touch</span> <span>$lockfile</span>
    <span>return</span> <span>$retval</span>
<span>}</span>

<span>stop</span><span>(</span><span>)</span> <span>{</span>
    <span>echo</span> -n $<span>"Stopping <span>$prog</span>: "</span>
    killproc <span>$prog</span> -QUIT
    <span>retval</span><span>=</span><span>$?</span>
    <span>echo</span>
    <span>[</span> <span>$retval</span> -eq <span>0</span> <span>]</span> <span>&amp;&amp;</span> <span>rm</span> -f <span>$lockfile</span>
    <span>return</span> <span>$retval</span>
<span>}</span>

<span>restart</span><span>(</span><span>)</span> <span>{</span>
    configtest <span>||</span> <span>return</span> <span>$?</span>
    stop
    <span>sleep</span> <span>1</span>
    start
<span>}</span>

<span>reload</span><span>(</span><span>)</span> <span>{</span>
    configtest <span>||</span> <span>return</span> <span>$?</span>
    <span>echo</span> -n $<span>"Reloading <span>$prog</span>: "</span>
    killproc <span>$prog</span> -HUP
    <span>retval</span><span>=</span><span>$?</span>
    <span>echo</span>
<span>}</span>

<span>force_reload</span><span>(</span><span>)</span> <span>{</span>
    restart
<span>}</span>

<span>configtest</span><span>(</span><span>)</span> <span>{</span>
  <span>$nginx</span> -t -c <span>$NGINX_CONF_FILE</span>
<span>}</span>

<span>rh_status</span><span>(</span><span>)</span> <span>{</span>
    status <span>$prog</span>
<span>}</span>

<span>rh_status_q</span><span>(</span><span>)</span> <span>{</span>
    rh_status <span>></span>/dev/null <span><span>2</span>></span><span>&amp;1</span>
<span>}</span>

<span>case</span> <span>"<span>$1</span>"</span> <span>in</span>
    start<span>)</span>
        rh_status_q <span>&amp;&amp;</span> <span>exit</span> <span>0</span>
        <span>$1</span>
        <span>;</span><span>;</span>
    stop<span>)</span>
        rh_status_q <span>||</span> <span>exit</span> <span>0</span>
        <span>$1</span>
        <span>;</span><span>;</span>
    restart<span>|</span>configtest<span>)</span>
        <span>$1</span>
        <span>;</span><span>;</span>
    reload<span>)</span>
        rh_status_q <span>||</span> <span>exit</span> <span>7</span>
        <span>$1</span>
        <span>;</span><span>;</span>
    force-reload<span>)</span>
        force_reload
        <span>;</span><span>;</span>
    status<span>)</span>
        rh_status
        <span>;</span><span>;</span>
    condrestart<span>|</span>try-restart<span>)</span>
        rh_status_q <span>||</span> <span>exit</span> <span>0</span>
            <span>;</span><span>;</span>
    *<span>)</span>
        <span>echo</span> $<span>"Usage: <span>$0</span> {start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest}"</span>
        <span>exit</span> <span>2</span>
<span>esac</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br></div></div><h3 id="修改部分参数-2"> 修改部分参数</h3>
<p>如果你的 Nginx 是通过编译安装的，则需要根据实际安装时的设置，修改启动脚本中的两个参数（大约在第 22 行和第 25 行）：</p>
<div><pre><code><span># 修改成 Nginx 执行程序的路径，例如我的一般是：/usr/local/nginx/sbin/nginx</span>
<span>nginx</span><span>=</span><span>"/usr/sbin/nginx"</span>

<span># 修改成配置文件的路径，例如我的一般是：/usr/local/nginx/conf/nginx.conf</span>
<span>NGINX_CONF_FILE</span><span>=</span><span>"/etc/nginx/nginx.conf"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>还需要修改 PID 文件路径，大约在启动脚本中的第 11 行可以看到被注释的默认路径，在下面加一行，手动指定成和 nginx.conf 文件中的 PID 路径一致即可：</p>
<div><pre><code>设置成和 nginx.conf 中一致。例如我的一般是：/usr/local/nginx/logs/nginx.pid
<span># pidfile:     /var/run/nginx.pid</span>
pidfile:     /usr/local/nginx/logs/nginx.pid
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="添加执行权限-2"> 添加执行权限</h3>
<p>上述脚本保存为 <code>/etc/init.d/nginx</code>，然后设置文件的执行权限：</p>
<div><pre><code><span># 给所有用户给予可执行权限</span>
<span>chmod</span> a+x /etc/init.d/nginx
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>至此就可以通过下面指令控制 Nginx 的启动、停止和重新加载了：</p>
<div><pre><code><span># 启动</span>
/etc/init.d/nginx start

<span># 停止</span>
/etc/init.d/nginx stop

<span># 重新加载配置</span>
/etc/init.d/nginx reload
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="添加至开机自启动-2"> 添加至开机自启动</h3>
<p>现在将 Nginx 服务加入 chkconfig 管理列表：</p>
<div><pre><code><span># 添加 Nginx 启动脚本为 chkconfig 管理的一个服务</span>
<span>chkconfig</span> --add /etc/init.d/nginx

<span># 将 Nginx 加入开机自启</span>
<span>chkconfig</span> /etc/init.d/nginx on
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>当然了，如果需要关闭开机启动的功能：</p>
<div><pre><code><span># 查看该服务进程状态</span>
<span>chkconfig</span> --list nginx

<span># 关闭 Nginx 开机自启</span>
<span>chkconfig</span> /etc/init.d/nginx off

<span># 删除 chkconfig 管理的的 Nginx 启动服务（如果确实不需要了）</span>
<span>chkconfig</span> --del /etc/init.d/nginx
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="开机自启脚本提供的快捷命令"> 开机自启脚本提供的快捷命令</h3>
<p>通过 Nginx 开机自启脚本本身提供了一些 Nginx 常用操作的快捷命令，一旦我们通过这个脚本实现开机自启后，就可以通过这些快捷命令来操作 Nginx 了：</p>
<div><pre><code><span># 启动 Nginx</span>
/etc/init.d/nginx start

<span># 重新加载 Nginx 配置</span>
/etc/init.d/nginx reload

<span># 停止 Nginx</span>
/etc/init.d/nginx stop
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>这些命令通过看脚本代码就能找到</p>
<h2 id="centos-7-x-设置开机自启"> CentOS 7.x 设置开机自启</h2>
<blockquote>
<p>以下所有命令，如果你是 root 账户，直接执行即可，不是的话前面加 <code>sudo</code> 获取权限</p>
</blockquote>
<p>在 CentOS 7.x 版本的系统开始，就不太好通过 chkconfig + <a href="https://www.nginx.com/resources/wiki/start/topics/examples/redhatnginxinit/" target="_blank" rel="noopener noreferrer">Red Hat NGINX Init Script</a> 的方式来设置 Nginx 的开机启动了</p>
<p>因为会留下了一个 bug：通过 <code>/etc/init.d/nginx</code> 脚本方式来控制 Nginx 的启动、停止时，start 一直卡着（实际端口是开启了，必须通过 Ctrl + C 强制关闭），stop 不生效（提示成功，但是端口没关闭）</p>
<p>那么对于 CentOS 7.x 系统，可以通过 systemd 来管理 Nginx</p>
<h3 id="建立服务文件"> 建立服务文件</h3>
<p>新建文件：</p>
<div><pre><code><span>vim</span> /usr/lib/systemd/system/nginx.service
</code></pre>
<div><span>1</span><br></div></div><p>往该文件内写入以下内容（内容模版参考官网 <a href="https://www.nginx.com/resources/wiki/start/topics/examples/systemd/" target="_blank" rel="noopener noreferrer">NGINX systemd service file</a>）：</p>
<div><pre><code><span>[</span>Unit<span>]</span>
<span>Description</span><span>=</span>The NGINX HTTP and reverse proxy server
<span>After</span><span>=</span>syslog.target network-online.target remote-fs.target nss-lookup.target
<span>Wants</span><span>=</span>network-online.target

<span>[</span>Service<span>]</span>
<span>Type</span><span>=</span>forking
<span>PIDFile</span><span>=</span>/run/nginx.pid
<span>ExecStartPre</span><span>=</span>/usr/sbin/nginx -t
<span>ExecStart</span><span>=</span>/usr/sbin/nginx
<span>ExecReload</span><span>=</span>/usr/sbin/nginx -s reload
<span>ExecStop</span><span>=</span>/bin/kill -s QUIT <span>$MAINPID</span>
<span>PrivateTmp</span><span>=</span>true

<span>[</span>Install<span>]</span>
<span>WantedBy</span><span>=</span>multi-user.target
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>文件内容解释：</p>
<div><pre><code><span>[</span>Unit<span>]</span>:服务的说明
Description:描述服务
After:描述服务类别

<span>[</span>Service<span>]</span>服务运行参数的设置
<span>Type</span><span>=</span>forking是后台运行的形式
ExecStart为服务的具体运行命令
ExecReload为重启命令
ExecStop为停止命令
<span>PrivateTmp</span><span>=</span>True表示给服务分配独立的临时空间
注意：启动、重启、停止命令全部要求使用绝对路径

<span>[</span>Install<span>]</span>服务安装的相关设置，可设置为多用户
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="修改部分参数-3"> 修改部分参数</h3>
<p>如果你的 Nginx 是通过编译安装的，则需要根据实际安装时的设置，修改文件中的部分参数，修改后的示例如下：</p>
<div><pre><code><span>[</span>Unit<span>]</span>
<span>Description</span><span>=</span>The NGINX HTTP and reverse proxy server
<span>After</span><span>=</span>syslog.target network-online.target remote-fs.target nss-lookup.target
<span>Wants</span><span>=</span>network-online.target

<span>[</span>Service<span>]</span>
<span>Type</span><span>=</span>forking
<span>PIDFile</span><span>=</span>/usr/local/nginx/logs/nginx.pid
<span>ExecStartPre</span><span>=</span>/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf
<span>ExecStart</span><span>=</span>/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf
<span>ExecReload</span><span>=</span>/usr/local/nginx/sbin/nginx -s reload
<span>ExecStop</span><span>=</span>/usr/local/nginx/sbin/nginx -s quit
<span>PrivateTmp</span><span>=</span>true

<span>[</span>Install<span>]</span>
<span>WantedBy</span><span>=</span>multi-user.target
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="添加执行权限-3"> 添加执行权限</h3>
<p>给上述文件添加执行权限：</p>
<div><pre><code><span>chmod</span> +x /usr/lib/systemd/system/nginx.service
</code></pre>
<div><span>1</span><br></div></div><h3 id="添加至开机自启动-3"> 添加至开机自启动</h3>
<p>设置开机自启动：</p>
<div><pre><code>systemctl <span>enable</span> nginx.service
</code></pre>
<div><span>1</span><br></div></div><h3 id="nginx-服务管理"> Nginx 服务管理</h3>
<p>此时可以使用一些快捷命令进行 Nginx 服务管理：</p>
<div><pre><code><span># Nginx 启动</span>
systemctl start nginx.service

<span># 查看 Nginx 服务当前状态</span>
systemctl status nginx.service

<span># Nginx 重载</span>
systemctl reload nginx.service

<span># Nginx 停止</span>
systemctl stop nginx.service

<span># 重新启动 Nginx 服务</span>
systemctl restart nginx.service

<span># 停止 Nginx 的开机自启动</span>
systemctl disable nginx.service
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>Nginx 启动日志查看：</p>
<div><pre><code>journalctl -f -u nginx.service
</code></pre>
<div><span>1</span><br></div></div><h3 id="systemd-提供的一些命令"> systemd 提供的一些命令</h3>
<p>查看所有已启动的服务：</p>
<div><pre><code>systemctl list-units --type<span>=</span>service
</code></pre>
<div><span>1</span><br></div></div><p>命令集合：</p>
<div><pre><code><span># 查看所有开机启动项</span>
systemctl list-unit-files --type<span>=</span>service <span>|</span> <span>grep</span> enabled

<span># 查询服务是否开机启动</span>
systemctl is-enabled servicename.service

<span># 开机运行服务</span>
systemctl <span>enable</span> *.service

<span># 取消开机运行</span>
systemctl disable *.service

<span># 启动服务</span>
systemctl start *.service

<span># 停止服务</span>
systemctl stop *.service

<span># 重启服务</span>
systemctl restart *.service

<span># 重新加载服务配置文件</span>
systemctl reload *.service

<span># 查询服务运行状态</span>
systemctl status *.service

<span># 显示启动失败的服务</span>
systemctl --failed
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>注：<code>*</code> 代表某个服务的名字，如 http 的服务名为 httpd</p>
<h2 id="参考文档"> 参考文档</h2>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html" target="_blank" rel="noopener noreferrer">Systemd 入门教程：命令篇</a></li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T03:26:17.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Nginx 限流常用模块</title>
    <id>https://www.snowji.cn/basic-skills/nginx/traffic-limiting-modules/</id>
    <link href="https://www.snowji.cn/basic-skills/nginx/traffic-limiting-modules/"/>
    <updated>2022-08-26T03:26:17.000Z</updated>
    <content type="html"><![CDATA[<h1 id="nginx-限流常用模块"> Nginx 限流常用模块</h1>
<p>限流是一个比较常见的需求，它可以限制某个用户在一定时间内产生的 HTTP 请求数。常用于安全方面，通过限制请求速度来防止外部暴力扫描，或者减慢暴力密码破解攻击，可以结合日志标记出目标 URL 来帮助防范 DDoS 攻击，也可以解决流量突发的问题（如整点活动）</p>
<h2 id="模块介绍"> 模块介绍</h2>
<p>Nginx 有两个限流常用模块：</p>
<ul>
<li><code>ngx_http_limit_conn_module</code>：该模块用于限制并发连接数
<ul>
<li>在配置文件中，使用 <code>limit_conn_zone</code> 和 <code>limit_conn</code> 指令</li>
</ul>
</li>
<li><code>ngx_http_limit_req_module</code>：该模块用于限制一段时间内同一 IP 的访问频率
<ul>
<li>在配置文件中，使用 <code>limit_req_zone</code> 和 <code>limit_req</code> 指令</li>
</ul>
</li>
</ul>
<p>下面是配置案例。</p>
<h2 id="限制并发"> 限制并发</h2>
<p>限制 IP 并发数，也是说限制同一个 IP 同时连接服务器的数量。可以防止一瞬间的并发访问过高导致服务器崩掉</p>
<h3 id="_1-添加-limit-conn-zone"> 1. 添加 <code>limit_conn_zone</code></h3>
<p>这个变量只能配置在 <code>http</code> 中</p>
<div><pre><code>http <span>{</span>
    <span>..</span>.

    <span># 定义一个名为 addr 的 limit_req_zone 用来存储 session，大小是 10M 内存</span>
    <span># 以 $binary_remote_addr 为 key</span>
    <span># nginx 1.18 以后用 limit_conn_zone 替换了 limit_conn</span>
    <span># 且只能放在 http{} 代码段</span>
    limit_conn_zone <span>$binary_remote_addr</span> <span>zone</span><span>=</span>addr:10m<span>;</span>

    <span>..</span>.
    include /usr/local/nginx/conf/vhosts/*.conf<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="_2-添加-limit-conn"> 2. 添加 <code>limit_conn</code></h3>
<p>这个变量可以配置在 <code>http</code>，<code>server</code>，<code>location</code> 中的任一位置。因为我这里只限制一个站点，所以添加到 <code>server</code> 里面</p>
<div><pre><code>server<span>{</span>
    <span>..</span>.

    limit_conn addr <span>10</span><span>;</span>      <span># 连接数限制</span>
    <span># 设置给定键值的共享内存区域和允许的最大连接数。超出此限制时，服务器将返回 503（服务临时不可用）错误.</span>
    <span># 如果区域存储空间不足，服务器将返回503（服务临时不可用）错误</span>

    <span>..</span>.
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面的配置能达到的效果就是，一瞬间访问的时候，只会有 10 个 IP 能得到响应，后面的 IP 直接就返回 503 状态</p>
<h2 id="限制-ip-访问频率"> 限制 IP 访问频率</h2>
<p>限制同一个 IP 在一段时间里连接服务器的次数，可以一定程度上防止类似 CC 这种快速频率请求的攻击。</p>
<h3 id="_1-添加-limit-req-zone"> 1. 添加 <code>limit_req_zone</code></h3>
<p>这个变量只能配置在 <code>http</code> 中。</p>
<div><pre><code>http <span>{</span>
    <span>..</span>.

    <span># 定义一个名为 allips 的 limit_req_zone 用来存储 session，大小是 10M 内存，</span>
    <span># 以 $binary_remote_addr 为 key，限制平均每秒的请求为 20 个，</span>
    <span># 1M 能存储 16000 个状态，rate 的值必须为整数，</span>
    <span># 如果限制两秒钟一个请求，可以设置成 30r/m</span>
    limit_req_zone <span>$binary_remote_addr</span> <span>zone</span><span>=</span>allips:10m <span>rate</span><span>=</span>20r/s<span>;</span>

    <span>..</span>.
    include /usr/local/nginx/conf/vhosts/*.conf<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="_2-添加-limit-req"> 2. 添加 <code>limit_req</code></h3>
<p>这个变量可以配置在 <code>http</code>，<code>server</code>，<code>location</code> 中的任一位置。因为我这里只限制一个站点，所以添加到 <code>server</code> 里面</p>
<div><pre><code>server<span>{</span>
    <span>..</span>.

    <span># 限制每 IP 每秒不超过 20 个请求，漏桶数 burst 为 5</span>
    <span># brust 的意思就是，如果第 1、2、3、4 秒请求为 19 个，</span>
    <span># 第 5 秒的请求为 25 个是被允许的。</span>
    <span># 但是如果第 1 秒就 25 个请求，第 2 秒超过 20 的请求返回 503 错误。</span>
    <span># nodelay，如果不设置该选项，严格使用平均速率限制请求数，</span>
    <span># 第 1 秒 25 个请求时，5 个请求放到第 2 秒执行，</span>
    <span># 设置 nodelay，25 个请求将在第 1 秒执行。</span>
    limit_req <span>zone</span><span>=</span>allips <span>burst</span><span>=</span><span>5</span> nodelay<span>;</span>

    <span>..</span>.
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>此时能达到的效果，同一个 IP 在一秒钟只能获得 20 个访问，超过 20 个请求，后面的也是直接返回 503</p>
<h2 id="限制并发-限制-ip-访问频率"> 限制并发 + 限制 IP 访问频率</h2>
<p>上面的两个配置加在一起就可以做到：<strong>一秒只有 10 个连接，每个连接只能发送 20 个请求</strong></p>
<p>注意：对 request 的访问限制，一定要注意数量的配置，否则一不小心就会 503（ERR_ABORTED 503 (Service Temporarily Unavailable)），这会导致很多静态资源类型被拦截，使得页面加载不完整</p>
<h2 id="总结"> 总结</h2>
<p>通过 Nginx 的这两个模块实现限流是挺好用的功能，但是这两个配置也不是绝对安全，只要有足够的耐心来尝试，摸索出间接等待的时长，一样可以绕过这些校验，所以最好的方式还是在服务端做校验，防止不法分子对后台端口进行疯狂调用</p>
<h2 id="参考资料"> 参考资料</h2>
<ul>
<li><a href="https://nginx.org/en/docs/http/ngx_http_limit_conn_module.html" title="Module ngx_http_limit_conn_module" target="_blank" rel="noopener noreferrer">Module ngx_http_limit_conn_module</a></li>
<li><a href="https://nginx.org/en/docs/http/ngx_http_limit_req_module.html" title="Module ngx_http_limit_req_module" target="_blank" rel="noopener noreferrer">Module ngx_http_limit_req_module</a></li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T03:26:17.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Nginx 的卸载</title>
    <id>https://www.snowji.cn/basic-skills/nginx/uninstallation-of-nginx/</id>
    <link href="https://www.snowji.cn/basic-skills/nginx/uninstallation-of-nginx/"/>
    <updated>2022-08-26T03:26:17.000Z</updated>
    <content type="html"><![CDATA[<h1 id="nginx-的卸载"> Nginx 的卸载</h1>
<p>我一般都是通过源码编译安装的方式，所以这里主要介绍如何卸载编译安装的 Nginx</p>
<p>编译安装的 Nginx 卸载非常方便，直接将 Nginx 的安装目录删除即可，同时可以把 Nginx 使用的日志目录和临时目录一并删除</p>
<h2 id="停止-nginx-服务"> 停止 Nginx 服务</h2>
<p>首先输入命令 <code>ps -ef | grep nginx</code> 检查一下 Nginx 服务是否在运行，在卸载之前需要先停止服务</p>
<h2 id="删除-nginx-安装目录"> 删除 Nginx 安装目录</h2>
<div><pre><code><span># 查找安装路径</span>
<span>whereis</span> nginx

<span># 如果是按照我上一篇介绍的步骤安装，删除安装目录的命令如下：</span>
<span>rm</span> -rf /usr/local/nginx
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="ubuntu-删除-nginx-自启动"> Ubuntu 删除 Nginx 自启动</h2>
<p>如果安装了 Nginx 自启动（后面章节会讲），按照如下命令将自启动脚本删除</p>
<div><pre><code><span># 进入 /etc/init.d 查看哪些服务进程是开机自启动的</span>
<span>cd</span> /etc/init.d
<span>ls</span>

<span># 取消 Nginx 开机启动</span>
update-rc.d -f nginx remove

<span># 删除 Nginx 自启动脚本</span>
<span>rm</span> /etc/init.d/nginx
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="centos-7-x-删除-nginx-自启动"> CentOS 7.x 删除 Nginx 自启动</h2>
<p>在 CentOS 7.x 中，如果你跟我一样是通过 systemd 实现 Nginx 自启动的（后面章节会讲），按照如下命令将自启动脚本删除</p>
<div><pre><code><span># 查看开机启动项里有没有 nginx.service</span>
systemctl list-unit-files --type<span>=</span>service <span>|</span> <span>grep</span> enabled

<span># 停止 Nginx 服务进程</span>
systemctl stop nginx.service

<span># 使 Nginx 开机不启动</span>
systemctl disable nginx.service

<span># 删除 Nginx 服务文件</span>
<span>rm</span> /usr/lib/systemd/system/nginx.service
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="find-查找相关文件并删除"> find 查找相关文件并删除</h2>
<p>查找并删除 Nginx 相关文件，如日志目录和临时目录等</p>
<div><pre><code><span># 查找相关文件</span>
<span>find</span> / -name nginx

<span># 判断是否能删除后，执行删除命令</span>
<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T03:26:17.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">语法</title>
    <id>https://www.snowji.cn/basic-skills/regular/regular-character-syntax/</id>
    <link href="https://www.snowji.cn/basic-skills/regular/regular-character-syntax/"/>
    <updated>2022-08-26T03:28:08.000Z</updated>
    <content type="html"><![CDATA[<h1 id="语法"> 语法</h1>
<h2 id="匹配普通字符"> 匹配普通字符</h2>
<p>包括所有大小写字母、数字、所有标点符号和一些其他符号</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>[ABC]</td>
<td>匹配 [...] 中的所有字符</td>
<td>字符串：&quot;google runoob taobao&quot;<br />匹配字符：[aeiou]<br />结果：o,o,e,u,o,o,a,o,a,o</td>
</tr>
<tr>
<td>[^ABC]</td>
<td>匹配除了 [...] 中的所有字符</td>
<td>字符串：&quot;google runoob taobao&quot;<br/>匹配字符：<code>[^aeiou]</code><br/>结果：g,g,l, ,r,n,b, ,t,b</td>
</tr>
<tr>
<td>[A-Z]<br />[a-z]</td>
<td>[A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母</td>
<td>字符串：&quot;Google Runoob Taobao&quot;<br/>匹配字符：[A-Z]<br/>结果：G,R,T</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符（\n、\r）之外的任何单个字符,相当于<code>[^\n\r]</code></td>
<td>字符串：&quot;google runoob taobao&quot;<br/>匹配字符：.<br/>结果：g,o,o,g,l,e, ,r,u,n,o,o,b, ,t,a,o,b,a,o</td>
</tr>
<tr>
<td>[\s\S]</td>
<td>匹配所有, \s 是匹配所有空白符，包括换行，\S 非空白符，不包括换行</td>
<td>字符串：&quot;google runoob taobao\nRUnoob\ntaobao&quot;<br/>匹配字符：[\s\S]<br/>结果：g,o,o,g,l,e, ,r,u,n,o,o,b, ,t,a,o,b,a,o, ,R,U,n,o,o,b, ,t,a,o,b,a,o</td>
</tr>
<tr>
<td>\w</td>
<td>匹配字母、数字、下划线,等价于 [A-Za-z0-9_]</td>
<td>字符串：&quot;Google Runoob 123Taobao&quot;<br/>匹配字符：[\s\S]<br/>结果：G,o,o,g,l,e,R,u,n,o,o,b,1,2,3,T,a,o,b,a,o</td>
</tr>
</tbody>
</table>
<h2 id="特殊字符"> 特殊字符</h2>
<ul>
<li>一些有特殊含义的字符，可以表示任何字符串</li>
<li>如果要查找字符串中的特殊字符，则需要对特殊字符进行转义</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$</td>
<td style="text-align:left">匹配输入字符串的结尾位置<br />如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\n' 或 '\r'<br />要匹配 $ 字符本身，请使用 $</td>
</tr>
<tr>
<td style="text-align:center">( )</td>
<td style="text-align:left">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:left">匹配前面的子表达式零次或多次<br />要匹配 * 字符，请使用 *</td>
</tr>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:left">匹配前面的子表达式一次或多次<br />要匹配 + 字符，请使用 +</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:left">匹配除换行符 \n 之外的任何单字符<br />要匹配 . ，请使用 .</td>
</tr>
<tr>
<td style="text-align:center">[</td>
<td style="text-align:left">标记一个中括号表达式的开始<br />要匹配 [，请使用 [</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:left">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符<br />要匹配 ? 字符，请使用 ?</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符<br /> 'n' 匹配字符 'n'<br />'\n' 匹配换行符<br />序列 '\' 匹配 &quot;&quot;，而 '(' 则匹配 &quot;(&quot;</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:left">匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合<br />要匹配 ^ 字符本身，请使用 ^</td>
</tr>
<tr>
<td style="text-align:center">{</td>
<td style="text-align:left">标记限定符表达式的开始<br />要匹配 {，请使用 {</td>
</tr>
<tr>
<td style="text-align:center">|</td>
<td style="text-align:left">指明两项之间的一个选择<br />要匹配 |，请使用 |</td>
</tr>
</tbody>
</table>
<h2 id="限定符"> 限定符</h2>
<p>用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配</p>
<p>有 ***** 或 <strong>+</strong> 或 <strong>?</strong> 或 <strong>{n}</strong> 或 <strong>{n,}</strong> 或 <strong>{n,m}</strong> 共6种</p>
<table>
<thead>
<tr>
<th style="text-align:left">字符</th>
<th style="text-align:left">描述</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">匹配前面的子表达式零次或多次</td>
<td><code>zo*</code> 能匹配 <code>z</code> 以及 <code>zoo</code><br /><code>*</code> 等价于{0,}</td>
</tr>
<tr>
<td style="text-align:left">+</td>
<td style="text-align:left">匹配前面的子表达式一次或多次</td>
<td><code>zo+</code> 能匹配 <code>zo</code> 以及 <code>zoo</code>，但不能匹配 <code>z</code><br /><code>+</code> 等价于 {1,}</td>
</tr>
<tr>
<td style="text-align:left">?</td>
<td style="text-align:left">匹配前面的子表达式零次或一次</td>
<td><code>do(es)?</code> 可以匹配 <code>do</code> 、 <code>does</code> 中的 <code>does</code> 、 <code>doxy</code> 中的 <code>do</code> <br /><code>?</code> 等价于 {0,1}</td>
</tr>
<tr>
<td style="text-align:left">{n}</td>
<td style="text-align:left">n 是一个非负整数。匹配确定的 n 次</td>
<td><code>o{2}</code> 不能匹配 <code>Bob</code> 中的 <code>o</code>，但是能匹配 <code>food</code> 中的两个 <code>o</code></td>
</tr>
<tr>
<td style="text-align:left">{n,}</td>
<td style="text-align:left">n 是一个非负整数。至少匹配 n 次</td>
<td><code>o{2,}</code> 不能匹配 <code>Bob</code> 中的 <code>o</code>，但能匹配 <code>foooood</code> 中的所有 <code>o</code><br /><code>o{1,}</code> 等价于 <code>o+</code><br /><code>o{0,}</code> 则等价于 <code>o*</code></td>
</tr>
<tr>
<td style="text-align:left">{n,m}</td>
<td style="text-align:left">m 和 n 均为非负整数，其中 n &lt;= m。最少匹配 n 次且最多匹配 m 次</td>
<td><code>o{1,3}</code> 将匹配 <code>fooooood</code> 中的前三个 o<br /><code>o{0,1}</code> 等价于 <code>o?</code><br />请注意在逗号和两个数之间不能有空格</td>
</tr>
</tbody>
</table>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T03:28:08.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">第三选择</title>
    <id>https://www.snowji.cn/books/3rd-choice/</id>
    <link href="https://www.snowji.cn/books/3rd-choice/"/>
    <updated>2022-08-25T01:58:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="第三选择"> 第三选择</h1>
<p>作者简介：史蒂芬科维
阅读时间：2021.11<br>
内容简介：用于解决一切问题的方法</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T01:58:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">读书笔记</title>
    <id>https://www.snowji.cn/books/</id>
    <link href="https://www.snowji.cn/books/"/>
    <updated>2022-08-25T01:58:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="读书笔记"> 读书笔记</h1>
<p>聆听书中的精华，记录书中的经典语录，并进行思考和总结自身所存在的问题。</p>
<h2 id="已读书名"> 已读书名</h2>
<ul>
<li>《掌控习惯》：2020.07</li>
<li>《数据思维》：2020.08</li>
<li>《终身成长》：2020.08</li>
<li>《刻意练习》：2020.08</li>
</ul>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T01:58:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">正则简介</title>
    <id>https://www.snowji.cn/basic-skills/regular/</id>
    <link href="https://www.snowji.cn/basic-skills/regular/"/>
    <updated>2022-08-26T03:28:08.000Z</updated>
    <content type="html"><![CDATA[<h1 id="正则简介"> 正则简介</h1>
<h2 id="什么是正则表达式"> 什么是正则表达式</h2>
<ul>
<li>是一种文本模式，包括普通字符和特殊字符</li>
<li>使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串</li>
<li>写法繁琐，功能强大，能大大提高效率</li>
</ul>
<h2 id="为什么要使用正则表达式"> 为什么要使用正则表达式</h2>
<ul>
<li>传统技术对静态文本执行简单搜索和替换任务，缺乏灵活性</li>
<li>使用正则表达式，可以
<ul>
<li>测试字符串内的模式</li>
<li>替换文本</li>
<li>基于模式匹配从字符串中提取子字符串</li>
</ul>
</li>
</ul>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T03:28:08.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">《终结拖延症》</title>
    <id>https://www.snowji.cn/books/end-procrastination/</id>
    <link href="https://www.snowji.cn/books/end-procrastination/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="《终结拖延症》"> 《终结拖延症》</h1>
<p>作者简介：威廉·克瑙斯 ，美国著名心理治疗专家<br>
阅读时间：2020.10<br>
内容简介：了解造成拖延症的原因，治疗拖延症。</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T01:58:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">《掌控习惯》</title>
    <id>https://www.snowji.cn/books/control-habits/</id>
    <link href="https://www.snowji.cn/books/control-habits/"/>
    <updated>2022-08-25T01:58:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="《掌控习惯》"> 《掌控习惯》</h1>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T01:58:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">《游戏改变世界》</title>
    <id>https://www.snowji.cn/books/games-change-the-world/</id>
    <link href="https://www.snowji.cn/books/games-change-the-world/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="《游戏改变世界》"> 《游戏改变世界》</h1>
<p>作者简介：简·麦戈尼格尔，著名未来学家<br>
阅读时间：2021.10
内容简介：游戏化，可以重塑人类积极的未来</p>
<h2 id="_1-游戏的四大特征"> 1. 游戏的四大特征</h2>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T01:58:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">《终身成长》</title>
    <id>https://www.snowji.cn/books/mind-set/</id>
    <link href="https://www.snowji.cn/books/mind-set/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="《终身成长》"> 《终身成长》</h1>
<p>作者简介：卡罗尔·德韦克 ，哥伦比亚大学心里学教授<br>
阅读时间：2020.08<br>
内容简介：通过对不同领域，如体育、婚姻等具体示例讲解，讲述了固定型思维和成长型思维这两种思维模式之间的差异</p>
<h2 id="_1-两种思维模式"> 1. 两种思维模式</h2>
<ul>
<li>固定型思维：相信自己的才能是不变的，关键词就是证明</li>
<li>成长性思维：认为自己的基本能力可以通过努力来培养</li>
</ul>
<h2 id="_2-两种模式的区别"> 2. 两种模式的区别</h2>
<ul>
<li>
<p>对自身的评价准确度差别很大</p>
<p>成长型思维会很客观的看待自己的水平和状况，固定型思维的人就是自视过高</p>
</li>
<li>
<p>脑波不同</p>
</li>
<li>
<p>对努力与否的看法不一致</p>
<p>固定型思维的人认为努力是一件很丢脸的事，只相信天分。而成长型思维的人不在乎暴露自己的努力</p>
</li>
<li>
<p>对成功和失败的看法不同</p>
<p>固定型思维的人认为成功就是成功，失败就是失败。而成长型思维的人会认为失败并不是件坏事，反而让自己知道自己的差距，哪里需要提升</p>
</li>
</ul>
<h2 id="_3-两种思维模式的应用"> 3. 两种思维模式的应用</h2>
<ul>
<li>
<p>学习上</p>
<p>固定型：死记硬背</p>
<p>成长型：会归纳总结思考</p>
</li>
<li>
<p>教育类</p>
<p>固定型：</p>
<p>成长型：</p>
</li>
<li>
<p>体育类</p>
<p>固定型：</p>
<p>成长型：</p>
</li>
<li>
<p>恋爱婚姻</p>
<p>固定型：</p>
<p>成长型：</p>
</li>
</ul>
<h2 id="_4-成长型领导力培训问题"> 4. 成长型领导力培训问题</h2>
<ul>
<li>为什么要相信人的能力是可以发展的</li>
<li>我们要想出一个自己以前能力很差，但现在表现很好的领域</li>
<li>给你在工作上感到困难的员工们写一封信，告诉他们能力是可以发展的</li>
<li>回想过去是否有过原本认定某个人无法完成某件事，但该人最终学会的情况</li>
</ul>
<h2 id="_5-如何成为成长型思维"> 5. 如何成为成长型思维</h2>
<ul>
<li>
<p>接纳：</p>
<p>当身上出现了固定型思维的模式，不要急于批评自己，要接纳自己有这个问题</p>
</li>
<li>
<p>觉醒</p>
<p>要有觉察力，能不能感受到自己此刻的思维模式</p>
</li>
<li>
<p>行为</p>
<p>做出一些行动去逐渐改变</p>
</li>
</ul>
<h2 id="_6-思考"> 6. 思考</h2>
<p>通过对本书的阅读，觉察到自身也存在固定型思维模式。比如，不敢在人多的时候上台发言，害怕丢脸，不敢在领导开会的时候发表自己的意见，有时候莫名奇妙的就跟伴侣吵架生气等等，就是因为固定型思维的方式来思考问题。在以后的时间，需要通过实际行动来转变为成长型思维模式。</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T01:58:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">《数据思维》</title>
    <id>https://www.snowji.cn/books/data-thinking/</id>
    <link href="https://www.snowji.cn/books/data-thinking/"/>
    <updated>2022-08-25T01:58:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="《数据思维》"> 《数据思维》</h1>
<p>作者简介：王汉生，北京大学光华管理学院商务统计与经济计量系教授<br>
阅读时间：2020.08<br>
内容简介：阐述数据与价值之间的关系，分析数据使其产生价值。</p>
<h2 id="_1-为什么要做数据分析"> 1. 为什么要做数据分析</h2>
<p>唯一目的是要解决业务问题、创造商业价值，让数据变成商业价值</p>
<h2 id="_2-数据思维有哪些方面"> 2. 数据思维有哪些方面</h2>
<ul>
<li>
<p>理解数据和价值之间的关系</p>
<p>数据：能够被电子化记录的叫数据</p>
<p>价值：数据能够对我们本身的核心业务产生影响的叫价值（关乎我们自己工作运营中最核心的业务述求）</p>
</li>
<li>
<p>回归分析：通常在数理统计上讲的 x 和 y 的关系</p>
</li>
<li>
<p>数据产品化</p>
<p>所谓产品并不是一定指一个真实的看的见的东西，在商业环境中，任何东西被实施而产生价值的都叫产品</p>
</li>
</ul>
<h2 id="_3-感悟"> 3. 感悟</h2>
<p>对于数据的理解仅仅为数据，没有思考过数据转变为价值。对于数据的分析也只是表面的数据分析，没有想过数据分析就是为了解决实际业务需求。</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T01:58:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">《刻意练习》</title>
    <id>https://www.snowji.cn/books/deliberate-practice/</id>
    <link href="https://www.snowji.cn/books/deliberate-practice/"/>
    <updated>2022-08-25T01:58:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="《刻意练习》"> 《刻意练习》</h1>
<p>作者简介：安德斯·埃里克森，美国佛罗里达州大学心理学教授<br>
阅读时间：2020.08<br>
内容简介：通过一系列的示例讲解，所谓的天才表面上看起来似乎有着不可企及的高度，但唯一的秘密就是在于刻意练习，形成一套系统性的方法，不断突破边界。</p>
<h2 id="_1-天才的背后"> 1. 天才的背后</h2>
<p>通过对莫扎特和帕格尼尼例子的解析，得出结论，所谓的天才都是经过一定时间的刻意练习，形成一套系统性的学习方法，不断突破自我的边界。</p>
<h2 id="_2-什么是真正的刻意练习"> 2. 什么是真正的刻意练习</h2>
<ul>
<li>首先要具有明确的目标<br>
所做的每一件事都应该是有目标性的</li>
<li>专注</li>
<li>每一次练习要有反馈</li>
<li>反馈时有问题时及时改正</li>
</ul>
<h2 id="_3-什么是心里表征"> 3. 什么是心里表征</h2>
<p>一种下意识的反应，比如说打字可以不用看键盘，就能打出。</p>
<h2 id="_4-训练的目的"> 4. 训练的目的</h2>
<p>训练的目的就是为了把我们训练成对这件事情的下意识的反应。</p>
<h2 id="_5-一万小时理论产生的三个误导"> 5. 一万小时理论产生的三个误导</h2>
<ul>
<li>不能够随便承诺，就是不能给任何人承诺说只要 1 万小时就能怎么样</li>
<li>有时候做成一件事不需要 1 万小时</li>
<li>要知道有时练了也没用</li>
</ul>
<h2 id="_6-如何把刻意练习应用到工作中"> 6. 如何把刻意练习应用到工作中</h2>
<ul>
<li>把每一次的工作都视作是一次训练</li>
<li>突破三种错误思想
<ul>
<li>基因限制思想</li>
<li>足够长的时间</li>
<li>只需要足够努力</li>
</ul>
</li>
</ul>
<h2 id="_7-刻意练习经历四个阶段"> 7. 刻意练习经历四个阶段</h2>
<ul>
<li>产生兴趣</li>
<li>变得认真</li>
<li>全力投入</li>
<li>开拓创新</li>
</ul>
<h2 id="_8-思考"> 8. 思考</h2>
<p>在没有听这本书之前，总觉着天才离我遥不可及，那些优秀的人就是天才。书中提到的 3 个误区，自己也存在有这方面的错误思想，认为只要自己比别人更加努力，付出的时间更多，就会有回报。然后，现在看来，真的是错了。时间只是来区别优秀、优异与杰出，而努力也只是促进刻意练习后的反馈。</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T01:58:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">幸福的方法</title>
    <id>https://www.snowji.cn/books/%E5%B9%B8%E7%A6%8F%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <link href="https://www.snowji.cn/books/%E5%B9%B8%E7%A6%8F%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <updated>2022-08-25T01:58:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="幸福的方法"> 幸福的方法</h1>
<p>作者简介：泰勒·本·沙哈尔，心理学博士
阅读时间：2021.12<br>
内容简介：幸福不是一种状态，幸福是一种能力</p>
<h2 id="结论"> 结论</h2>
<ul>
<li>
<p>幸福与状态无关，幸福是一种能力</p>
</li>
<li>
<p>幸福的能力是一种对快乐的感知力</p>
</li>
</ul>
<h2 id="幸福四象限"> 幸福四象限</h2>
<h3 id="及时行乐型"> 及时行乐型</h3>
<h3 id="无助型"> 无助型</h3>
<h3 id="忍辱负重型"> 忍辱负重型</h3>
<h3 id="幸福型"> 幸福型</h3>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T01:58:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">管理十戒</title>
    <id>https://www.snowji.cn/books/%E7%AE%A1%E7%90%86%E5%8D%81%E6%88%92/</id>
    <link href="https://www.snowji.cn/books/%E7%AE%A1%E7%90%86%E5%8D%81%E6%88%92/"/>
    <updated>2022-08-25T01:58:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="管理十戒"> 管理十戒</h1>
<p>作者简介：基奥
阅读时间：2021.12<br>
内容简介：</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T01:58:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">能力陷阱</title>
    <id>https://www.snowji.cn/books/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/</id>
    <link href="https://www.snowji.cn/books/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/"/>
    <updated>2022-08-25T01:58:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="能力陷阱"> 能力陷阱</h1>
<p>作者简介：
阅读时间：2021.12<br>
内容简介：</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T01:58:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">认知天性</title>
    <id>https://www.snowji.cn/books/%E8%AE%A4%E7%9F%A5%E5%A4%A9%E6%80%A7/</id>
    <link href="https://www.snowji.cn/books/%E8%AE%A4%E7%9F%A5%E5%A4%A9%E6%80%A7/"/>
    <updated>2022-08-25T01:58:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="认知天性"> 认知天性</h1>
<p>作者简介：基奥
阅读时间：2021.12<br>
内容简介：</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T01:58:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">集群管理 API</title>
    <id>https://www.snowji.cn/databases/es/cluster-manage-apis/</id>
    <link href="https://www.snowji.cn/databases/es/cluster-manage-apis/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="集群管理-api"> 集群管理 API</h1>
<h2 id="简介"> 简介</h2>
<p>Cerebro 为我们提供了简单的集群管理功能，这些监控、管理的功能本质上也都是通过 ES 提供的 API 来实现的</p>
<h2 id="cat-apis"> cat APIs</h2>
<p><code>_cat</code> APIs 提供查看集群相关信息的同时，其特别之处在于它返回的结果不是 JSON，而是非常适合人类阅读的格式</p>
<p>当使用 <code>_cat</code> 时其后面不跟任何子节点，返回结果是各个 API 的目录（URL），在忘记有啥接口的时候这个功能非常好用：</p>
<div><pre><code><span># 使用 _cat API 获取所有可用的目录</span>
GET /_cat/

<span># 结果</span>
/_cat/allocation
/_cat/shards
/_cat/shards/<span>{</span>index<span>}</span>
/_cat/master
/_cat/nodes
/_cat/tasks
/_cat/indices
/_cat/indices/<span>{</span>index<span>}</span>
/_cat/segments
/_cat/segments/<span>{</span>index<span>}</span>
/_cat/count
/_cat/count/<span>{</span>index<span>}</span>
<span>..</span><span>..</span><span>..</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>上述这些 API 都可以加入下面几个参数：</p>
<ul>
<li><strong>v 参数</strong>：每个命令都可以使用 v 参数来打印详细信息如：<code>GET /_cat/nodes?v</code></li>
<li><strong>h 参数</strong>：使用 h 参数可以强制只显示某些列如：<code>GET /_cat/nodes?h=node.role,port,name</code></li>
<li><strong>help 参数</strong>：使用 help 参数可以输出这个接口可用的列名和其解析如：<code>GET /_cat/master?help</code></li>
</ul>
<h3 id="查看索引文档总数和整个集群文档总数"> 查看索引文档总数和整个集群文档总数</h3>
<div><pre><code><span># 获取索引 books 的文档总数</span>
GET /_cat/count/books?v

<span># 获取整个集群所有索引的文档总数</span>
GET /_cat/count?v
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="查看集群健康状态"> 查看集群健康状态</h3>
<div><pre><code><span># 查看集群健康状态</span>
GET /_cat/health?v
GET /_cat/health?v<span>&amp;</span><span>ts</span><span>=</span>false
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>ts=false</code> 的参数是返回结果中去除时间戳</p>
<h3 id="查看磁盘使用情况"> 查看磁盘使用情况</h3>
<div><pre><code><span># 获取各个节点磁盘的使用情况</span>
GET /_cat/allocation?v
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>更多的关于 <code>_cat</code> APIs 的使用示例，可以参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/cat.html" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<h2 id="集群管理-api-2"> 集群管理 API</h2>
<p>集群管理的 API 提供了获取或者更改集群信息的功能，例如集群节点过滤、查看集群信息、查看节点信息、更新集群设置、重置路由等</p>
<h3 id="集群节点过滤"> 集群节点过滤</h3>
<div><pre><code><span># 获取所有节点</span>
GET /_nodes/_all
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>除了 <code>_all</code> 外，ES 支持的节点过滤器有如下几个：</p>
<ul>
<li><strong><code>_all</code></strong>：列出所有节点</li>
<li><strong><code>_local</code></strong>：列出本地节点</li>
<li><strong><code>_master</code></strong>：列出主节点</li>
<li><strong>IP 或者主机名字</strong>：列出指定 IP 或者主机名字的节点</li>
<li><strong>节点 ID 或者名称</strong>：列出指定 ID 或者名称的节点</li>
<li><strong><code>*</code></strong>：IP、主机名字、节点 ID、名称都可以包括通配符</li>
<li><strong><code>master:true/false</code></strong>：列出主节点 / 不列出主节点</li>
<li><strong><code>data:true/false</code></strong>：列出数据节点 / 不列出数据节点</li>
<li><strong><code>ingest:true/false</code></strong>：列出索引预处理节点 / 不列出索引预处理节点</li>
<li><strong><code>coordinating_only:true/false</code></strong>：列出协调节点 / 不列出协调节点</li>
</ul>
<p>比如：</p>
<div><pre><code><span># 节点类型过滤：过滤出 master、data、ingest、coordinating 节点的信息</span>
GET /_nodes/master:true,data:true,ingest:true,coordinating:true
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果只想返回某个节选部分的结果，可以使用以下示例：</p>
<div><pre><code><span># 列出 process 节选信息</span>
GET /_nodes/master:true,data:true,ingest:true,coordinating:true/process
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>更多的使用示例你可以参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/cluster-nodes-info.html" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<h3 id="查看集群信息"> 查看集群信息</h3>
<p>可以使用集群信息查看的接口<strong>查看集群健康状态、集群状态、集群统计信息、集群的设置</strong>等，示例如下：</p>
<div><pre><code><span># 查看集群健康状态</span>
GET /_cluster/health

<span># 查看集群状态</span>
GET /_cluster/state

<span># 查看集群统计信息</span>
GET /_cluster/stats?human<span>&amp;</span>pretty

<span># 查看集群的设置</span>
GET /_cluster/settings?include_defaults<span>=</span>true
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="查看节点信息"> 查看节点信息</h3>
<p>查看节点信息的 API 比较简单，示例如下：</p>
<div><pre><code><span># 获取节点信息的请求格式</span>
GET /_nodes
GET /_nodes/<span>&lt;</span>node_id<span>></span>
GET /_nodes/<span>&lt;</span>metric<span>></span>
GET /_nodes/<span>&lt;</span>node_id<span>></span>/<span>&lt;</span>metric<span>></span>

<span># 获取节点信息的示例</span>
GET /_nodes
GET /_nodes/node_id1,node_id2       <span># 获取 node_id1 和 node_id2 的信息</span>
GET /_nodes/stats 
GET /_nodes/node_id1,node_id2/stats <span># 获取 node_id1 和 node_id2 的统计信息</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>其中 metric 可以指定获取结果中的每个部分，其选项比较多，参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/cluster-nodes-info.html" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<h3 id="更新集群设置"> 更新集群设置</h3>
<p>更新集群设置的示例如下：</p>
<div><pre><code>PUT /_cluster/settings
<span>{</span>
  <span>"persistent"</span><span>:</span> <span>{</span>
    <span>"indices.recovery.max_bytes_per_sec"</span><span>:</span> <span>"100m"</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>如上示例，我们设置了集群恢复时的吞吐量，其默认值为 0 的时候为无限制</p>
<h3 id="重置路由"> 重置路由</h3>
<p>reroute API 可以允许用户手动修改集群中分片的分配情况使用 reroute API 可以将一个分片从某个节点移到另一个节点，也可以将未分配的分片指定分配到某个节点</p>
<p>官方的示例：</p>
<div><pre><code>POST /_cluster/reroute
<span>{</span>
  <span>"commands"</span><span>:</span> <span>[</span>
    <span>{</span>
      <span>"move"</span><span>:</span> <span>{</span>
        <span>"index"</span><span>:</span> <span>"test"</span>, <span>"shard"</span><span>:</span> <span>0</span>,
        <span>"from_node"</span><span>:</span> <span>"node1"</span>, <span>"to_node"</span><span>:</span> <span>"node2"</span>
      <span>}</span>
    <span>}</span>,
    <span>{</span>
      <span>"allocate_replica"</span><span>:</span> <span>{</span>
        <span>"index"</span><span>:</span> <span>"test"</span>, <span>"shard"</span><span>:</span> <span>1</span>,
        <span>"node"</span><span>:</span> <span>"node3"</span>
      <span>}</span>
    <span>}</span>
  <span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>如上示例，使用 <code>&quot;move&quot;</code> 指令，将索引 <code>&quot;test&quot;</code> 的分片 0 从节点 <code>&quot;node1&quot;</code> 移动到了 <code>&quot;node2&quot;</code>使用 <code>&quot;allocate_replica&quot;</code> 指令将 <code>&quot;test&quot;</code> 索引未分配的分片 1 的副本分配到节点 <code>&quot;node3&quot;</code></p>
<p>需要注意的是，在执行了任何路由重置指令后，ES 将会执行重新平衡数据的操作来保持平衡状态，但是这个操作受 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/modules-cluster.html#cluster-shard-allocation-settings" target="_blank" rel="noopener noreferrer">cluster.routing.rebalance.enable</a>（是否允许重新平衡）设置值的影响</p>
<p>reroute API 在 ES 集群运维的时候经常用到，更详细的使用示例可以参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/cluster-reroute.html" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<h2 id="参考资料"> 参考资料</h2>
<ul>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/cluster.html" target="_blank" rel="noopener noreferrer">Cluster APIs</a></li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">统计语法：聚合查询</title>
    <id>https://www.snowji.cn/databases/es/aggregations/</id>
    <link href="https://www.snowji.cn/databases/es/aggregations/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="统计语法-聚合查询"> 统计语法：聚合查询</h1>
<h2 id="前言"> 前言</h2>
<p>聚合就是按照某些条件从数据集合中统计一些信息，例如统计销量前十的书本、统计每个出版社书本的数量、统计有多少个出版社等</p>
<p>可以使用 ES 提供的聚合计算 API，来满足对数据进行统计分析的需求</p>
<p>ES 中聚合的类型主要有以下 3 种：</p>
<ul>
<li><strong>Metric Aggregations</strong>：提供求 sum（求总和）、average（求平均数） 等数学运算，可以对字段进行统计分析</li>
<li><strong>Bucket Aggregations</strong>：对满足特定条件的文档进行分组，例如将 A 出版社的书本分为一组，将 B 出版社的书本分为一组，类似于 SQL 里的 Group By 功能</li>
<li><strong>Pipeline Aggregations</strong>：对其他聚合输出的结果进行再次聚合</li>
</ul>
<p>ES 的聚合<strong>可以进行多种组合来构建的统计查询</strong>，从而解决复杂的统计分析的需求下面是聚合查询的通用语法结构：</p>
<div><pre><code><span># 聚合查询的语法</span>
POST your_index/_search
<span>{</span>
  <span>"aggs"</span><span>:</span> <span>{</span>             <span># 和 "query" 同级别的关键词</span>
    <span>"aggs_name1"</span><span>:</span> <span>{</span>     <span># 自定义的聚合名字，会从聚合结果中返回</span>
      <span>"aggs_type"</span><span>:</span> <span>{</span>    <span># 聚合的定义：聚合类型 + 聚合body</span>
          aggs body
      <span>}</span>,
      <span>"aggs"</span><span>:</span> <span>{</span>         <span># 子聚合</span>
        <span>"aggs_name"</span><span>:</span> <span>{</span>
          <span>"aggs_type"</span><span>:</span> <span>{</span>
            aggs body
          <span>}</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>,
    <span>"aggs_name2"</span><span>:</span> <span>{</span>     <span># 第二个聚合的名字，可以进行多个同级别的聚合查询</span>
        <span>..</span><span>..</span><span>..</span>
    <span>}</span>
  <span>}</span>,
  <span>"size"</span><span>:</span> <span>0</span>             <span># 建议设置为0，这样不会返回 _source</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><ul>
<li><code>&quot;aggs&quot;</code> 是与 <code>&quot;query&quot;</code> 同级的关键词，同时使用时类似 MySQL 里的 <code>where condition group by column</code></li>
<li>一个聚合里可以同时开启多个聚合查询，每个聚合查询的名字不一样，例如 <code>&quot;aggs_name1&quot;</code> 和 <code>&quot;aggs_name2&quot;</code></li>
<li>上例中的 <code>&quot;aggs_type&quot; : {}</code> 这个键值对是聚合的定义，实际的 DSL 语法里 key 就是 <code>max</code>、<code>buckets</code> 这些，value 就是聚合的具体内容（字段名等等）</li>
<li>用到聚合时，大部分情况下我们只关心聚合后的结果，不关心返回的匹配文档，所以可以设置 <code>&quot;size&quot;</code> 为 0</li>
</ul>
<h2 id="metric-aggregations"> Metric Aggregations</h2>
<p>Metric Aggregations 可以计算一组文档中的某个指标，它分为单值分析和多值分析两类：</p>
<ul>
<li><strong>单值分析</strong>：只输出一个分析结果的聚合操作，例如：<code>min</code>、<code>max</code>、<code>sum</code>、<code>avg</code>、<code>cardinality</code>（类似于 SQL 中的 distinct count）等</li>
<li><strong>多值分析</strong>：会输出多个分析结果的聚合操作，例如：<code>stats</code>、<code>extended_stats</code>、<code>percentiles</code>、<code>percentile ranks</code>、<code>top hits</code> 等</li>
</ul>
<p>下面是几个例子</p>
<h3 id="查看最高售价"> 查看最高售价</h3>
<p>要找出书本的最高售价，可以使用 <code>max</code> 聚合，其示例如下：</p>
<div><pre><code><span># 查看最高售价</span>
POST books/_search
<span>{</span>
  <span>"aggs"</span><span>:</span> <span>{</span>
    <span>"most-expensive"</span><span>:</span> <span>{</span>
      <span>"max"</span><span>:</span> <span>{</span> <span>"field"</span><span>:</span> <span>"price"</span> <span>}</span>
    <span>}</span>
  <span>}</span>,
  <span>"size"</span><span>:</span> <span>0</span>
<span>}</span>

<span># 结果</span>
<span>{</span>
  <span>..</span><span>..</span><span>..</span>
  <span>"aggregations"</span> <span>:</span> <span>{</span>
    <span>"most-expensive"</span> <span>:</span> <span>{</span>
      <span>"value"</span> <span>:</span> <span>20.9</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h3 id="同时查看最高售价、最低售价、平均售价"> 同时查看最高售价、最低售价、平均售价</h3>
<p>一次聚合查询中可以发起多个同级别的聚合操作，所有可以同时查询最高售价、最低售价、平均售价，其示例如下：</p>
<div><pre><code><span># 一个请求里同时获取 最高售价、最低售价、平均售价</span>
POST books/_search
<span>{</span>
  <span>"aggs"</span><span>:</span> <span>{</span>
    <span>"most-expensive"</span><span>:</span> <span>{</span>
      <span>"max"</span><span>:</span> <span>{</span> <span>"field"</span><span>:</span> <span>"price"</span> <span>}</span>
    <span>}</span>,
    <span>"cheapest"</span><span>:</span> <span>{</span>
      <span>"min"</span><span>:</span> <span>{</span> <span>"field"</span><span>:</span> <span>"price"</span> <span>}</span>
    <span>}</span>,
    <span>"avg-price"</span><span>:</span> <span>{</span>
      <span>"avg"</span><span>:</span> <span>{</span> <span>"field"</span><span>:</span> <span>"price"</span> <span>}</span>
    <span>}</span>
  <span>}</span>,
  <span>"size"</span><span>:</span> <span>0</span>
<span>}</span>

<span># 结果</span>
<span>{</span>
  <span>..</span><span>..</span><span>..</span>
  <span>"aggregations"</span> <span>:</span> <span>{</span>
    <span>"cheapest"</span> <span>:</span> <span>{</span> <span>"value"</span> <span>:</span> <span>9.9</span> <span>}</span>,
    <span>"avg-price"</span> <span>:</span> <span>{</span> <span>"value"</span> <span>:</span> <span>15.471428571428572</span> <span>}</span>,
    <span>"most-expensive"</span> <span>:</span> <span>{</span> <span>"value"</span> <span>:</span> <span>20.9</span> <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>不过除了上述方法外，还可以使用 <code>stat``stats</code> 聚合除了返回最高售价、最低售价、平均售价外还有售价之和（<code>sum</code>）、文档个数的信息其示例如下：</p>
<div><pre><code><span># 使用 stat 查询 最高售价、最低售价、平均售价</span>
POST books/_search
<span>{</span>
  <span>"aggs"</span><span>:</span> <span>{</span>
    <span>"stat_price"</span><span>:</span> <span>{</span>
      <span>"stats"</span><span>:</span> <span>{</span>
        <span>"field"</span><span>:</span> <span>"price"</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>,
  <span>"size"</span><span>:</span> <span>0</span>
<span>}</span>

<span># 结果</span>
<span>{</span>
  <span>..</span><span>..</span><span>..</span>
  <span>"aggregations"</span> <span>:</span> <span>{</span>
    <span>"stat_price"</span> <span>:</span> <span>{</span>
      <span>"count"</span> <span>:</span> <span>7</span>,
      <span>"min"</span> <span>:</span> <span>9.9</span>,
      <span>"max"</span> <span>:</span> <span>20.9</span>,
      <span>"avg"</span> <span>:</span> <span>15.471428571428572</span>,
      <span>"sum"</span> <span>:</span> <span>108.3</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h3 id="统计出版社的数量"> 统计出版社的数量</h3>
<p>可以使用 <code>cardinality</code> 聚合获取出版社的数量，其作用类似于 SQL 中的 distinct count其示例如下：</p>
<div><pre><code><span># 统计出版社的数量</span>
POST books/_search
<span>{</span>
  <span>"aggs"</span><span>:</span> <span>{</span>
    <span>"cardinality_publisher"</span><span>:</span> <span>{</span>
      <span>"cardinality"</span><span>:</span> <span>{</span>
        <span>"field"</span><span>:</span> <span>"publisher"</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>,
  <span>"size"</span><span>:</span> <span>0</span>
<span>}</span>

<span># 结果</span>
<span>{</span>
  <span>..</span><span>..</span><span>..</span>
  <span>"aggregations"</span> <span>:</span> <span>{</span>
    <span>"cardinality_publisher"</span> <span>:</span> <span>{</span>
      <span>"value"</span> <span>:</span> <span>3</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>更多 Metric Aggregations 的使用案例可以参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/search-aggregations-metrics.html" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<h2 id="bucket-aggregations"> Bucket Aggregations</h2>
<p>Bucket 可以理解为一个桶，或者一个分组，当遍历文档库的时候会把符合条件的文档放到一个分组里面去，分组就相当于 SQL 中的 Group By</p>
<p>对数据进行分组后，我们还可以组合 Metric Aggregations 的聚合操作来完成复杂的统计需求，例如找出每个出版社最贵的售价是多少</p>
<p>ES 提供的 Bucket Aggregations 中常用的有以下几个：</p>
<ul>
<li><strong>Terms</strong>：根据某个字段进行分组，例如根据出版社进行分组</li>
<li><strong>Range、Data Range</strong>：根据用户指定的范围参数作为分组的依据来进行聚合操作</li>
<li><strong>Histogram</strong>、<strong>Date Histogram</strong>：可以指定间隔区间来进行聚合操作</li>
</ul>
<p>下面是几个例子</p>
<h3 id="统计每个出版社的书本数量"> 统计每个出版社的书本数量</h3>
<p>使用 Terms Aggregations，以出版社作为分组条件，然后计算每个分组中文档的个数，得出的结果就是每个出版社拥有的书本数量了：</p>
<div><pre><code><span># Terms Aggregations 统计每个出版社拥有的书本数量</span>
POST books/_search
<span>{</span>
  <span>"aggs"</span><span>:</span> <span>{</span>
    <span>"publisher_book_count"</span><span>:</span> <span>{</span>
      <span>"terms"</span><span>:</span> <span>{</span>               <span># 使用 "terms" 关键字</span>
        <span>"field"</span><span>:</span> <span>"publisher"</span>,
        <span>"size"</span><span>:</span> <span>3</span>              <span># 只返回聚合后前三组的结果</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>,
  <span>"size"</span><span>:</span> <span>0</span>
<span>}</span>

<span># 结果</span>
<span>{</span>
  <span>..</span><span>..</span><span>..</span>
  <span>"aggregations"</span> <span>:</span> <span>{</span>
    <span>"publisher_book_count"</span> <span>:</span> <span>{</span>
      <span>"doc_count_error_upper_bound"</span> <span>:</span> <span>0</span>,
      <span>"sum_other_doc_count"</span> <span>:</span> <span>0</span>,
      <span>"buckets"</span> <span>:</span> <span>[</span>
        <span>{</span> <span>"key"</span> <span>:</span> <span>"linux publisher"</span>, <span>"doc_count"</span> <span>:</span> <span>3</span> <span>}</span>,
        <span>{</span> <span>"key"</span> <span>:</span> <span>"autobiography publisher"</span>, <span>"doc_count"</span> <span>:</span> <span>2</span> <span>}</span>,
        <span>{</span> <span>"key"</span> <span>:</span> <span>"science publisher"</span>, <span>"doc_count"</span> <span>:</span> <span>2</span> <span>}</span>
      <span>]</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>返回结果中，还有两个字段，它们是对本次聚合的评估结果：</p>
<ul>
<li><strong><code>doc_count_error_upper_bound</code></strong>：没有在本次聚合返回的分桶中，包含文档数的<strong>可能最大值</strong>的和如果是 0，说明聚合结果是准确的</li>
<li><strong><code>sum_other_doc_count</code></strong>：除了返回结果中的 terms 外，其他没有返回的 terms 的文档数量之和</li>
</ul>
<h3 id="统计每个价格区间的书本数量"> 统计每个价格区间的书本数量</h3>
<p>Range Aggregations 可以根据用户指定的范围参数作为分组的依据来进行聚合操作</p>
<p>所以可以指定 0 ~ 10，10 ~ 20，20 ~ 30 这样的 3 个区间来作为分组，然后统计数据，使用示例如下：</p>
<div><pre><code><span># 价格区间统计</span>
POST books/_search
<span>{</span>
  <span>"aggs"</span><span>:</span> <span>{</span>
    <span>"price_range"</span><span>:</span> <span>{</span>
      <span>"range"</span><span>:</span> <span>{</span>           <span># 使用 "range" 关键字</span>
        <span>"field"</span><span>:</span> <span>"price"</span>,
        <span>"keyed"</span><span>:</span> true,     <span># true 使得我们可以对每个区间进行命名</span>
        <span>"ranges"</span><span>:</span> <span>[</span>
          <span>{</span> <span>"key"</span><span>:</span> <span>"cheap"</span>, <span>"from"</span><span>:</span> <span>0.0</span>, <span>"to"</span><span>:</span> <span>10.0</span> <span>}</span>,  <span># "key" 表示区间的名字</span>
          <span>{</span> <span>"key"</span><span>:</span> <span>"average"</span>, <span>"from"</span><span>:</span> <span>10.0</span>, <span>"to"</span><span>:</span> <span>20.0</span> <span>}</span>,
          <span>{</span> <span>"key"</span><span>:</span> <span>"expensive"</span>, <span>"from"</span><span>:</span> <span>20.0</span>, <span>"to"</span><span>:</span> <span>30.0</span> <span>}</span>
        <span>]</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>,
  <span>"size"</span><span>:</span> <span>0</span>
<span>}</span>

<span># 结果</span>
<span>{</span>
  <span>..</span><span>..</span><span>..</span>
  <span>"aggregations"</span> <span>:</span> <span>{</span>
    <span>"range_price"</span> <span>:</span> <span>{</span>
      <span>"buckets"</span> <span>:</span> <span>{</span>
        <span>"cheap"</span> <span>:</span> <span>{</span> <span>"from"</span> <span>:</span> <span>0.0</span>, <span>"to"</span> <span>:</span> <span>10.0</span>, <span>"doc_count"</span> <span>:</span> <span>1</span> <span>}</span>,
        <span>"average"</span> <span>:</span> <span>{</span> <span>"from"</span> <span>:</span> <span>10.0</span>, <span>"to"</span> <span>:</span> <span>20.0</span>, <span>"doc_count"</span> <span>:</span> <span>5</span> <span>}</span>,
        <span>"expensive"</span> <span>:</span> <span>{</span> <span>"from"</span> <span>:</span> <span>20.0</span>, <span>"to"</span> <span>:</span> <span>30.0</span>, <span>"doc_count"</span> <span>:</span> <span>1</span> <span>}</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><blockquote>
<p>注意点：关键字 <code>from</code> 和 <code>to</code> 指定了区间的开始值和结束值，其取值范围为前闭后开：<code>[from, to)</code></p>
</blockquote>
<p>当区间值非常多的时候，为了避免手写冗长的查询语句，可以使用 Histogram Aggregation它也可以对区间进行分组，但这个区间是固定间隔的，例如上例的间隔是 10，那可以这样实现：</p>
<div><pre><code><span># 使用 Histogram Aggregation</span>
POST books/_search
<span>{</span>
  <span>"aggs"</span><span>:</span> <span>{</span>
    <span>"price_histogram"</span><span>:</span> <span>{</span>
      <span>"histogram"</span><span>:</span> <span>{</span>
        <span>"field"</span><span>:</span> <span>"price"</span>,
        <span>"interval"</span><span>:</span> <span>10</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>,
  <span>"size"</span><span>:</span> <span>0</span>
<span>}</span>

<span># 结果</span>
<span>{</span>
  <span>"aggregations"</span> <span>:</span> <span>{</span>
    <span>"price_histogram"</span> <span>:</span> <span>{</span>
      <span>"buckets"</span> <span>:</span> <span>[</span>
        <span>{</span> <span>"key"</span> <span>:</span> <span>0.0</span>, <span>"doc_count"</span> <span>:</span> <span>1</span> <span>}</span>,
        <span>{</span> <span>"key"</span> <span>:</span> <span>10.0</span>, <span>"doc_count"</span> <span>:</span> <span>5</span> <span>}</span>,
        <span>{</span> <span>"key"</span> <span>:</span> <span>20.0</span>, <span>"doc_count"</span> <span>:</span> <span>1</span> <span>}</span>
      <span>]</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>Histogram Aggregation 返回的结果比较简单，其并不能像 Range Aggregation 那样手动指定每个区间的名字，所以更多时候用在显示图表的需求上</p>
<h3 id="统计每个出版社书本的销售量"> 统计每个出版社书本的销售量</h3>
<p>要统计每个出版社书本的销售量的话，需要先按每个出版社进行分组，然后最每个分组所有文档的销售量求和，所以使用 Terms Aggregation 和 Sum Aggregation 可以解决这个需求，其示例如下：</p>
<div><pre><code><span># 使用子聚合 组合 Terms Aggregation 和 Sum Aggregation </span>
POST books/_search
<span>{</span>
  <span>"aggs"</span><span>:</span> <span>{</span>
    <span>"publisher_sales_total"</span><span>:</span> <span>{</span>
      <span>"terms"</span><span>:</span> <span>{</span> <span>"field"</span><span>:</span> <span>"publisher"</span> <span>}</span>,
      <span>"aggs"</span><span>:</span> <span>{</span>
        <span>"sales_total"</span><span>:</span> <span>{</span>
          <span>"sum"</span><span>:</span> <span>{</span> <span>"field"</span><span>:</span> <span>"sales"</span> <span>}</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>,
  <span>"size"</span><span>:</span> <span>0</span>
<span>}</span>

<span># 结果</span>
<span>{</span>
  <span>..</span><span>..</span><span>..</span>
  <span>"aggregations"</span> <span>:</span> <span>{</span>
    <span>"publisher_sales_total"</span> <span>:</span> <span>{</span>
      <span>"doc_count_error_upper_bound"</span> <span>:</span> <span>0</span>,
      <span>"sum_other_doc_count"</span> <span>:</span> <span>0</span>,
      <span>"buckets"</span> <span>:</span> <span>[</span>
        <span>{</span>
          <span>"key"</span> <span>:</span> <span>"linux publisher"</span>,
          <span>"doc_count"</span> <span>:</span> <span>3</span>,
          <span>"sales_total"</span> <span>:</span> <span>{</span> <span>"value"</span> <span>:</span> <span>400.0</span> <span>}</span>
        <span>}</span>,
        <span>{</span>
          <span>"key"</span> <span>:</span> <span>"autobiography publisher"</span>,
          <span>"doc_count"</span> <span>:</span> <span>2</span>,
          <span>"sales_total"</span> <span>:</span> <span>{</span> <span>"value"</span> <span>:</span> <span>5140.0</span> <span>}</span>
        <span>}</span>,
        <span>{</span>
          <span>"key"</span> <span>:</span> <span>"science publisher"</span>,
          <span>"doc_count"</span> <span>:</span> <span>2</span>,
          <span>"sales_total"</span> <span>:</span> <span>{</span> <span>"value"</span> <span>:</span> <span>19800.0</span> <span>}</span>
        <span>}</span>
      <span>]</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><p>从结果可以看出，查询以出版社名称为分组，然后求得每个分组中书本的销售量的总和，并放在了 <code>&quot;sales_total&quot;</code> 中</p>
<p>更多 Bucket Aggregations 的使用案例可以参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/search-aggregations-bucket.html" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<h2 id="pipeline-aggregations"> Pipeline Aggregations</h2>
<p>Pipeline Aggregations 可以对其他聚合输出的结果进行再次聚合，下面通过一个例子来说明其使用方式</p>
<p>现在有这样一个需求，在销售量最好的 2 个出版社里，找出平均价格最低的出版社其示例如下：</p>
<div><pre><code>POST books/_search
<span>{</span>
  <span>"aggs"</span><span>:</span> <span>{</span>
    <span>"publisher"</span><span>:</span> <span>{</span>
      <span>"terms"</span><span>:</span> <span>{</span>
        <span>"field"</span><span>:</span> <span>"publisher"</span>,
        <span>"size"</span><span>:</span> <span>2</span>,
        <span>"order"</span><span>:</span> <span>{</span> <span>"sales_total"</span><span>:</span> <span>"desc"</span> <span>}</span>
      <span>}</span>,
      <span>"aggs"</span><span>:</span> <span>{</span>
        <span>"sales_total"</span><span>:</span> <span>{</span>
          <span>"sum"</span><span>:</span> <span>{</span> <span>"field"</span><span>:</span> <span>"sales"</span> <span>}</span>
        <span>}</span>,
        <span>"avg_price"</span><span>:</span> <span>{</span>
          <span>"avg"</span><span>:</span> <span>{</span> <span>"field"</span><span>:</span> <span>"price"</span> <span>}</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>,
    <span>"min_avg_price"</span><span>:</span> <span>{</span>
      <span>"min_bucket"</span><span>:</span> <span>{</span>
        <span>"buckets_path"</span><span>:</span> <span>"publisher>avg_price"</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>,
  <span>"size"</span><span>:</span> <span>0</span>
<span>}</span>

<span># 结果</span>
<span>{</span>
  <span>"aggregations"</span> <span>:</span> <span>{</span>
    <span>"publisher"</span> <span>:</span> <span>{</span> <span>..</span><span>..</span><span>..</span> <span>}</span>,
    <span>"min_avg_price"</span> <span>:</span> <span>{</span>
      <span>"value"</span> <span>:</span> <span>14.399999999999999</span>,
      <span>"keys"</span> <span>:</span> <span>[</span> <span>"science publisher"</span> <span>]</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><p>如上示例，在 <code>&quot;publisher&quot;</code> 中我们做了以下几件事：</p>
<ol>
<li>按出版社进行分桶</li>
<li>执行子聚合，计算每个出版社的销售总额和书本平均价格</li>
<li>排序结果按 <code>&quot;sales_total&quot;</code>（销售额）倒序排序，并且获取排序后的前两个结果</li>
</ol>
<p>最终在 <code>&quot;publisher&quot;</code> 中我们得出了销售额最多的两个出版社和它们书本的平均售价、销售额</p>
<p>最后使用 Pipeline Aggregations 找出平均售价最低的出版社即可上面的示例是一个简单的例子，<code>&quot;min_avg_price&quot;</code> 是我们指定的名字，使用 <code>&quot;min_bucket&quot;</code> 求出之前结果的最小值，并且通过 <code>&quot;buckets_path&quot;</code> 关键字来指定路径，例子中我们的路径为 <code>&quot;publisher&quot;</code> 下的 <code>&quot;avg_price&quot;</code></p>
<p>Pipeline 分析的结果会输出到原查询的结果中，根据位置的不同可以分为两类：</p>
<ul>
<li><strong>Sibling</strong>：结果和原结果同级，如上面的列子就是 SiblingSibling 可以有 Max Bucket、Min Bucket、Avg Bucket、Sum Bucket 等</li>
<li><strong>Parent</strong>：结果会内嵌到现有的聚合分析结果中提供如 Derivative （求导）、Moving Function （滑动窗口）等功能</li>
</ul>
<p>更多 Pipeline Aggregations 的使用案例可以参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/search-aggregations-pipeline.html" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<h2 id="参考文档"> 参考文档</h2>
<ul>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/search-aggregations.html" target="_blank" rel="noopener noreferrer">Aggregations</a></li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">分词器的原理和使用</title>
    <id>https://www.snowji.cn/databases/es/analyzer/</id>
    <link href="https://www.snowji.cn/databases/es/analyzer/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="分词器的原理和使用"> 分词器的原理和使用</h1>
<h2 id="前言"> 前言</h2>
<p>我们存储到 ES 中的数据大致可以分为以下两种：</p>
<ul>
<li><strong>全文本</strong>，例如文章内容、通知内容等</li>
<li><strong>精确值</strong>，如实体 ID 等</li>
</ul>
<p>在对这两类值进行查询的时候，精确值类型会比较它们的二进制值，其结果只有相等或者不相等。而对全文本类型进行等值比较是不太现实的，一是用相关性评分来评估两个文本是否相似。<strong>而要得到相关性评分，我们就需要对全文本进行分词处理，然后得到统计数据才能进行评估</strong></p>
<h2 id="分词与分词器"> 分词与分词器</h2>
<p><strong>分词</strong>（Analysis）是将全文本转换为一系列单词的过程，这些单词称为 <strong>term 或者 token</strong></p>
<p>分词是通过<strong>分词器</strong>（Analyzer）来实现的，比如用于中文分词的 IK 分词器等。ES 内置了一些常用的分词器，如果不能满足需求，也可以安装第三方的分词器或者定制化自己的分词器</p>
<p><strong>除了在数据写入的时候对数据进行分词，在对全文本进行查询的时候也需要使用相同的分词器对检索内容进行分析</strong>。例如，查询 <code>&quot;Java Book&quot;</code> 的时候会分为 <code>&quot;java&quot;</code> 和 <code>&quot;book&quot;</code> 这两个单词</p>
<h2 id="分词器的组成"> 分词器的组成</h2>
<p>分词器主要由 3 部分组成</p>
<ul>
<li><strong>Character Filter</strong>：主要对原文本进行格式处理，如去除 html 标签等</li>
<li><strong>Tokenize</strong>r：按照指定的规则对文本进行切分，比如按空格来切分单词，同时也负责标记出每个单词的顺序、位置以及单词在原文本中开始和结束的偏移量</li>
<li><strong>Token Filter</strong>：对切分后的单词进行处理，如转换为小写、删除停用词、增加同义词、词干化等</li>
</ul>
<p>如下图就是分词器工作的流程，<strong>需要进行分词的文本依次通过 Character Filter、Tokenizer、Token Filter，最后得出切分后的词项</strong></p>
<div style="text-align: center;">
  <svg id="SvgjsSvg1006" width="453" height="320" xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.com/svgjs"><defs id="SvgjsDefs1007"><marker id="SvgjsMarker1058" markerWidth="14" markerHeight="10" refX="10" refY="5" viewBox="0 0 14 10" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1059" d="M0,0 L14,5 L0,10 L0,0" fill="#323232" stroke="#323232" stroke-width="1"></path></marker><marker id="SvgjsMarker1062" markerWidth="14" markerHeight="10" refX="10" refY="5" viewBox="0 0 14 10" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1063" d="M0,0 L14,5 L0,10 L0,0" fill="#323232" stroke="#323232" stroke-width="1"></path></marker></defs><g id="SvgjsG1008" transform="translate(25,25)"><path id="SvgjsPath1009" d="M 0 0L 403 0L 403 44L 0 44Z" stroke="rgba(50,50,50,1)" stroke-width="2" fill-opacity="1" fill="#f5f5f5"></path><g id="SvgjsG1010"><text id="SvgjsText1011" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="383px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="11.375" transform="rotate(0)"><tspan id="SvgjsTspan1012" dy="16" x="201.5"><tspan id="SvgjsTspan1013" style="text-decoration:;">需要处理的文本：张三是中国人</tspan></tspan></text></g></g><g id="SvgjsG1014" transform="translate(25,124)"><path id="SvgjsPath1015" d="M 0 0L 403 0L 403 90L 0 90Z" stroke="rgba(50,50,50,1)" stroke-width="2" fill-opacity="1" fill="#ffe0b2"></path><g id="SvgjsG1016"><text id="SvgjsText1017" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="383px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="34.375" transform="rotate(0)"></text></g></g><g id="SvgjsG1018" transform="translate(44,149)"><path id="SvgjsPath1019" d="M 0 4Q 0 0 4 0L 111 0Q 115 0 115 4L 115 36Q 115 40 111 40L 4 40Q 0 40 0 36Z" stroke="rgba(50,50,50,1)" stroke-width="2" fill-opacity="1" fill="#ffcdd2"></path><g id="SvgjsG1020"><text id="SvgjsText1021" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="95px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="9.375" transform="rotate(0)"><tspan id="SvgjsTspan1022" dy="16" x="57.5"><tspan id="SvgjsTspan1023" style="text-decoration:;">Character Filter</tspan></tspan></text></g></g><g id="SvgjsG1024" transform="translate(194,149)"><path id="SvgjsPath1025" d="M 0 4Q 0 0 4 0L 78 0Q 82 0 82 4L 82 36Q 82 40 78 40L 4 40Q 0 40 0 36Z" stroke="rgba(50,50,50,1)" stroke-width="2" fill-opacity="1" fill="#b2ebf2"></path><g id="SvgjsG1026"><text id="SvgjsText1027" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="62px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="9.375" transform="rotate(0)"><tspan id="SvgjsTspan1028" dy="16" x="41"><tspan id="SvgjsTspan1029" style="text-decoration:;">Tokenizer</tspan></tspan></text></g></g><g id="SvgjsG1030" transform="translate(311,149)"><path id="SvgjsPath1031" d="M 0 4Q 0 0 4 0L 93 0Q 97 0 97 4L 97 36Q 97 40 93 40L 4 40Q 0 40 0 36Z" stroke="rgba(50,50,50,1)" stroke-width="2" fill-opacity="1" fill="#fff9c4"></path><g id="SvgjsG1032"><text id="SvgjsText1033" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="77px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="9.375" transform="rotate(0)"><tspan id="SvgjsTspan1034" dy="16" x="48.5"><tspan id="SvgjsTspan1035" style="text-decoration:;">Token Filter</tspan></tspan></text></g></g><g id="SvgjsG1036" transform="translate(73,267)"><path id="SvgjsPath1037" d="M 0 4Q 0 0 4 0L 96 0Q 100 0 100 4L 100 24Q 100 28 96 28L 4 28Q 0 28 0 24Z" stroke="rgba(50,50,50,1)" stroke-width="2" fill-opacity="1" fill="#f5f5f5"></path><g id="SvgjsG1038"><text id="SvgjsText1039" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="80px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="3.375" transform="rotate(0)"><tspan id="SvgjsTspan1040" dy="16" x="50"><tspan id="SvgjsTspan1041" style="text-decoration:;">张三</tspan></tspan></text></g></g><g id="SvgjsG1042" transform="translate(280,267)"><path id="SvgjsPath1043" d="M 0 4Q 0 0 4 0L 96 0Q 100 0 100 4L 100 24Q 100 28 96 28L 4 28Q 0 28 0 24Z" stroke="rgba(50,50,50,1)" stroke-width="2" fill-opacity="1" fill="#f5f5f5"></path><g id="SvgjsG1044"><text id="SvgjsText1045" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="80px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="3.375" transform="rotate(0)"><tspan id="SvgjsTspan1046" dy="16" x="50"><tspan id="SvgjsTspan1047" style="text-decoration:;">中国人</tspan></tspan></text></g></g><g id="SvgjsG1048" transform="matrix(-1,1.2246467991473532e-16,-1.2246467991473532e-16,-1,246,117)"><path id="SvgjsPath1049" d="M 16.5 0L 33 16.5L 22.110000000000003 16.5L 22.110000000000003 42L 10.89 42L 10.89 16.5L 0 16.5L 16.5 0Z" stroke="rgba(50,50,50,1)" stroke-width="2" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1050"><text id="SvgjsText1051" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="47px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="12.474999999999998" transform="rotate(0)"></text></g></g><g id="SvgjsG1052" transform="matrix(-1,1.2246467991473532e-16,-1.2246467991473532e-16,-1,245,260)"><path id="SvgjsPath1053" d="M 16.5 0L 33 16.5L 22.110000000000003 16.5L 22.110000000000003 42L 10.89 42L 10.89 16.5L 0 16.5L 16.5 0Z" stroke="rgba(50,50,50,1)" stroke-width="2" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1054"><text id="SvgjsText1055" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="47px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="12.474999999999998" transform="rotate(0)"></text></g></g><g id="SvgjsG1056"><path id="SvgjsPath1057" d="M160 169L190.39999999999998 169" stroke="#323232" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1058)"></path></g><g id="SvgjsG1060"><path id="SvgjsPath1061" d="M277 169L307.4 169" stroke="#323232" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1062)"></path></g></svg>
</div>
<h2 id="es-内置的分词器"> ES 内置的分词器</h2>
<p>为了方便用户使用，ES 为用户提供了多个内置的分词器，常见的有以下 8 种</p>
<ul>
<li><strong>Standard Analyzer</strong>：这个是默认的分词器，使用 Unicode 文本分割算法，将文本按单词切分并且转为小写</li>
<li><strong>Simple Analyzer</strong>：按照非字母切分并且进行小写处理</li>
<li><strong>Stop Analyzer</strong>：与 Simple Analyzer 类似，但增加了停用词过滤（如 <code>a</code>、<code>an</code>、<code>and</code>、<code>are</code>、<code>as</code>、<code>at</code>、<code>be</code>、<code>but</code> 等）</li>
<li><strong>Whitespace Analyzer</strong>：使用空格对文本进行切分，并不进行小写转换</li>
<li><strong>Pattern Analyzer</strong>：使用正则表达式切分，默认使用 <code>\W+</code>（非字符分隔）。支持小写转换和停用词删除</li>
<li><strong>Keyword Analyzer</strong>：不进行分词</li>
<li><strong>Language Analyzer</strong>：提供了多种常见语言的分词器。如 Irish、Italian、Latvian 等</li>
<li><strong>Customer Analyzer</strong>：自定义分词器</li>
</ul>
<h3 id="analyze-api"> _analyze API</h3>
<p><code>_analyze</code> API 是一个非常有用的工具，它可以<strong>帮助我们查看分词器是如何工作的</strong>。<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/test-analyzer.html" target="_blank" rel="noopener noreferrer"><code>_analyze</code></a> API 提供了 3 种方式来查看分词器是如何工作的</p>
<h4 id="第一种方式"> 第一种方式</h4>
<p>使用 <code>_analyze</code> API 直接指定 Analyzer 来进行测试，示例如下：</p>
<div><pre><code>GET _analyze
<span>{</span>
  <span>"analyzer"</span><span>:</span> <span>"standard"</span>,
  <span>"text"</span><span>:</span> <span>"Your cluster could be accessible to anyone."</span>
<span>}</span>

<span># 结果</span>
<span>{</span>
  <span>"tokens"</span><span>:</span> <span>[</span>
    <span>{</span>
      <span>"token"</span><span>:</span> <span>"your"</span>,
      <span>"start_offset"</span><span>:</span> <span>0</span>,
      <span>"end_offset"</span><span>:</span> <span>4</span>,
      <span>"type"</span><span>:</span> <span>"&lt;ALPHANUM>"</span>,
      <span>"position"</span><span>:</span> <span>0</span>
    <span>}</span>,
    <span>{</span>
      <span>"token"</span><span>:</span> <span>"cluster"</span>,
      <span>"start_offset"</span><span>:</span> <span>5</span>,
      <span>"end_offset"</span><span>:</span> <span>12</span>,
      <span>"type"</span><span>:</span> <span>"&lt;ALPHANUM>"</span>,
      <span>"position"</span><span>:</span> <span>1</span>
    <span>}</span>
    <span>..</span><span>..</span><span>..</span>
  <span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>如上示例，在这段代码中我们可以看到它将 text 的内容用 standard 分词器进行分词，text 的内容按单词进行了切分并且 <code>Your</code> 转为了小写</p>
<h4 id="第二种方式"> 第二种方式</h4>
<p>对指定的索引进行测试，示例如下：</p>
<div><pre><code><span># 创建和设置索引</span>
PUT my-index
<span>{</span>
  <span>"mappings"</span><span>:</span> <span>{</span>
    <span>"properties"</span><span>:</span> <span>{</span>
      <span>"my_text"</span><span>:</span> <span>{</span>
        <span>"type"</span><span>:</span> <span>"text"</span>,
        <span>"analyzer"</span><span>:</span> <span>"standard"</span>  <span># my_text字段使用了standard分词器</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

GET my-index/_analyze 
<span>{</span>
  <span>"field"</span><span>:</span> <span>"my_text"</span>, <span># 直接使用my_text字段已经设置的分词器</span>
  <span>"text"</span><span>:</span>  <span>"Is this déjà vu?"</span>
<span>}</span>

<span># 结果：</span>
<span>{</span>
  <span>"tokens"</span><span>:</span> <span>[</span>
    <span>{</span>
      <span>"token"</span><span>:</span> <span>"is"</span>,
      <span>"start_offset"</span><span>:</span> <span>0</span>,
      <span>"end_offset"</span><span>:</span> <span>2</span>,
      <span>"type"</span><span>:</span> <span>"&lt;ALPHANUM>"</span>,
      <span>"position"</span><span>:</span> <span>0</span>
    <span>}</span>,
    <span>..</span><span>..</span><span>..</span>
  <span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>如上示例可以看到，text 字段的内容使用了 my-index 索引设置的 standard 分词器来进行分词</p>
<h4 id="第三种方式"> 第三种方式</h4>
<p>组合 tokenizer、filters、character filters 进行测试，示例如下：</p>
<div><pre><code>GET _analyze 
<span>{</span>
  <span>"tokenizer"</span><span>:</span> <span>"standard"</span>,                    <span># 指定一个tokenizer</span>
  <span>"filter"</span><span>:</span>  <span>[</span> <span>"lowercase"</span>, <span>"asciifolding"</span> <span>]</span>, <span># 可以组合多个token filter</span>
  <span># "char_filter":"html_strip", 可以指定零个 Character Filter</span>
  <span>"text"</span><span>:</span> <span>"java app"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>从上面的示例可以看到，tokenizer 使用了 standard 而 token filter 使用了 lowercase 和 asciifolding 来对 text 的内容进行切分。用户可以组合一个 tokenizer、零个或多个 token filter、零个或多个 character filter</p>
<h3 id="分词器工作流程"> 分词器工作流程</h3>
<p>下面以 Standard Analyzer 为例演示分词器的工作流程</p>
<p>Standard Analyzer 是 ES 默认的分词器，它会将输入的内容按词切分，并且将切分后的词进行小写转换，默认情况下停用词（Stop Word）过滤功能是关闭的</p>
<div style="text-align: center;">
  <svg id="SvgjsSvg1064" width="424" height="499" xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.com/svgjs"><defs id="SvgjsDefs1065"><marker id="SvgjsMarker1084" markerWidth="14" markerHeight="10" refX="10" refY="5" viewBox="0 0 14 10" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1085" d="M0,0 L14,5 L0,10 L0,0" fill="#323232" stroke="#323232" stroke-width="1"></path></marker><marker id="SvgjsMarker1098" markerWidth="14" markerHeight="10" refX="10" refY="5" viewBox="0 0 14 10" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1099" d="M0,0 L14,5 L0,10 L0,0" fill="#323232" stroke="#323232" stroke-width="1"></path></marker><marker id="SvgjsMarker1132" markerWidth="14" markerHeight="10" refX="10" refY="5" viewBox="0 0 14 10" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1133" d="M0,0 L14,5 L0,10 L0,0" fill="#323232" stroke="#323232" stroke-width="1"></path></marker></defs><g id="SvgjsG1066" transform="translate(39.25,94.5)"><path id="SvgjsPath1067" d="M 0 0L 345 0L 345 78L 0 78Z" stroke="rgba(158,158,158,1)" stroke-width="2" fill-opacity="1" fill="#f5f5f5"></path><g id="SvgjsG1068"><text id="SvgjsText1069" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="325px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="28.375" transform="rotate(0)"></text></g></g><g id="SvgjsG1070" transform="translate(45.25,25)"><path id="SvgjsPath1071" d="M 0 0L 333 0L 333 28L 0 28Z" stroke="none" fill="none"></path><g id="SvgjsG1072"><text id="SvgjsText1073" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="333px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="0" transform="rotate(0)"><tspan id="SvgjsTspan1074" dy="20" x="166.5"><tspan id="SvgjsTspan1075" style="text-decoration:;">Your cluster could be accessible to anyone.</tspan></tspan></text></g></g><g id="SvgjsG1076" transform="translate(38.25,98)"><path id="SvgjsPath1077" d="M 0 0L 78 0L 78 28L 0 28Z" stroke="none" fill="none"></path><g id="SvgjsG1078"><text id="SvgjsText1079" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="78px" fill="#323232" font-weight="700" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="700" font-style="" opacity="1" y="3.375" transform="rotate(0)"><tspan id="SvgjsTspan1080" dy="16" x="39"><tspan id="SvgjsTspan1081" style="text-decoration:;">Tokenizer</tspan></tspan></text></g></g><g id="SvgjsG1082"><path id="SvgjsPath1083" d="M211.75 54L211.75 90.9" stroke="#323232" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1084)"></path></g><g id="SvgjsG1086" transform="translate(38.25,214)"><path id="SvgjsPath1087" d="M 0 0L 347 0L 347 191L 0 191Z" stroke="rgba(158,158,158,1)" stroke-width="2" fill-opacity="1" fill="#f5f5f5"></path><g id="SvgjsG1088"><text id="SvgjsText1089" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="327px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="84.875" transform="rotate(0)"></text></g></g><g id="SvgjsG1090" transform="translate(38.25,216)"><path id="SvgjsPath1091" d="M 0 0L 97 0L 97 28L 0 28Z" stroke="none" fill="none"></path><g id="SvgjsG1092"><text id="SvgjsText1093" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="97px" fill="#323232" font-weight="700" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="700" font-style="" opacity="1" y="3.375" transform="rotate(0)"><tspan id="SvgjsTspan1094" dy="16" x="48.5"><tspan id="SvgjsTspan1095" style="text-decoration:;">Token Filters</tspan></tspan></text></g></g><g id="SvgjsG1096"><path id="SvgjsPath1097" d="M211.75 173.5L211.75 210.39999999999998" stroke="#323232" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1098)"></path></g><g id="SvgjsG1100" transform="translate(133.75,296.5)"><path id="SvgjsPath1101" d="M 0 4Q 0 0 4 0L 152 0Q 156 0 156 4L 156 37Q 156 41 152 41L 4 41Q 0 41 0 37Z" stroke="rgba(255,152,0,1)" stroke-width="2" fill-opacity="1" fill="#ffe0b2"></path><g id="SvgjsG1102"><text id="SvgjsText1103" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="136px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="9.875" transform="rotate(0)"><tspan id="SvgjsTspan1104" dy="16" x="78"><tspan id="SvgjsTspan1105" style="text-decoration:;">Lower Case：小写转换</tspan></tspan></text></g></g><g id="SvgjsG1106" transform="translate(131.25,116)"><path id="SvgjsPath1107" d="M 0 4Q 0 0 4 0L 152 0Q 156 0 156 4L 156 37Q 156 41 152 41L 4 41Q 0 41 0 37Z" stroke="rgba(255,152,0,1)" stroke-width="2" fill-opacity="1" fill="#ffe0b2"></path><g id="SvgjsG1108"><text id="SvgjsText1109" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="136px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="9.875" transform="rotate(0)"><tspan id="SvgjsTspan1110" dy="16" x="78"><tspan id="SvgjsTspan1111" style="text-decoration:;">Standard：按词切分</tspan></tspan></text></g></g><g id="SvgjsG1112" transform="translate(133.75,241)"><path id="SvgjsPath1113" d="M 0 4Q 0 0 4 0L 152 0Q 156 0 156 4L 156 37Q 156 41 152 41L 4 41Q 0 41 0 37Z" stroke="rgba(255,152,0,1)" stroke-width="2" fill-opacity="1" fill="#ffe0b2"></path><g id="SvgjsG1114"><text id="SvgjsText1115" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="136px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="9.875" transform="rotate(0)"><tspan id="SvgjsTspan1116" dy="16" x="78"><tspan id="SvgjsTspan1117" style="text-decoration:;">Standard</tspan></tspan></text></g></g><g id="SvgjsG1118" transform="translate(133.75,352)"><path id="SvgjsPath1119" d="M 0 4Q 0 0 4 0L 152 0Q 156 0 156 4L 156 37Q 156 41 152 41L 4 41Q 0 41 0 37Z" stroke="rgba(255,152,0,1)" stroke-width="2" fill-opacity="1" fill="#ffe0b2"></path><g id="SvgjsG1120"><text id="SvgjsText1121" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="136px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="9.875" transform="rotate(0)"><tspan id="SvgjsTspan1122" dy="16" x="78"><tspan id="SvgjsTspan1123" style="text-decoration:;">Stop Word (默认关闭)</tspan></tspan></text></g></g><g id="SvgjsG1124" transform="translate(25,442)"><path id="SvgjsPath1125" d="M 0 0L 373.5 0L 373.5 32L 0 32Z" stroke="none" fill="none"></path><g id="SvgjsG1126"><text id="SvgjsText1127" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="374px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="2" transform="rotate(0)"><tspan id="SvgjsTspan1128" dy="20" x="187"><tspan id="SvgjsTspan1129" style="text-decoration:;">[your, cluster, could, be, accessible, to, anyone]</tspan></tspan></text></g></g><g id="SvgjsG1130"><path id="SvgjsPath1131" d="M211.75 406L211.75 438.4" stroke="#323232" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1132)"></path></g></svg>
</div>
<p>在 Kibana 中运行这个例子：</p>
<div><pre><code>GET _analyze
<span>{</span>
  <span>"analyzer"</span><span>:</span> <span>"standard"</span>, <span># 设定分词器为 standard</span>
  <span>"text"</span><span>:</span> <span>"Your cluster could be accessible to anyone."</span>
<span>}</span>

<span># 结果</span>
<span>{</span>
  <span>"tokens"</span><span>:</span> <span>[</span>
    <span>{</span>
      <span>"token"</span><span>:</span> <span>"your"</span>,
      <span>"start_offset"</span><span>:</span> <span>0</span>,
      <span>"end_offset"</span><span>:</span> <span>4</span>,
      <span>"type"</span><span>:</span> <span>"&lt;ALPHANUM>"</span>,
      <span>"position"</span><span>:</span> <span>0</span>
    <span>}</span>,
    <span>{</span>
      <span>"token"</span><span>:</span> <span>"cluster"</span>,
      <span>"start_offset"</span><span>:</span> <span>5</span>,
      <span>"end_offset"</span><span>:</span> <span>12</span>,
      <span>"type"</span><span>:</span> <span>"&lt;ALPHANUM>"</span>,
      <span>"position"</span><span>:</span> <span>1</span>
    <span>}</span> 
    <span>..</span><span>..</span><span>..</span>
  <span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>如上示例，从其结果中可以看出，单词 <code>You</code> 做了小写转换，停用词 <code>be</code> 没有被去掉，并且返回结果里记录了这个单词在原文本中的开始偏移、结束偏移以及这个词出现的位置</p>
<p>其他内置分词器的使用与 Standard Analyzer 没有太多的差异，但各有各的特点，可以参考官方文档：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-analyzers.html" target="_blank" rel="noopener noreferrer">Text analysis</a></p>
<h2 id="自定义分词器"> 自定义分词器</h2>
<p>除了使用内置的分词器外，我们还可以通过组合 Tokenizer、Filters、Character Filters 来自定义分词器。其用例如下：</p>
<div><pre><code>PUT my-index-001
<span>{</span>
  <span>"settings"</span><span>:</span> <span>{</span>
    <span>"analysis"</span><span>:</span> <span>{</span>
      <span>"char_filter"</span><span>:</span> <span>{</span>             <span># 自定义char_filter</span>
        <span>"and_char_filter"</span><span>:</span> <span>{</span>
          <span>"type"</span><span>:</span> <span>"mapping"</span>,
          <span>"mappings"</span><span>:</span> <span>[</span><span>"&amp; => and"</span><span>]</span> <span># 将 '&amp;' 转换为 'and'</span>
        <span>}</span>
      <span>}</span>,
      <span>"filter"</span><span>:</span> <span>{</span>                  <span># 自定义 filter</span>
        <span>"an_stop_filter"</span><span>:</span> <span>{</span>
          <span>"type"</span><span>:</span> <span>"stop"</span>,
          <span>"stopwords"</span><span>:</span> <span>[</span><span>"an"</span><span>]</span>      <span># 设置 "an" 为停用词</span>
        <span>}</span>
      <span>}</span>,
      <span>"analyzer"</span><span>:</span> <span>{</span>                <span># 自定义分词器为 custom_analyzer</span>
        <span>"custom_analyzer"</span><span>:</span> <span>{</span>
          <span>"type"</span><span>:</span> <span>"custom"</span>,
          <span># 使用内置的html标签过滤和自定义的 my_char_filter</span>
          <span>"char_filter"</span><span>:</span> <span>[</span><span>"html_strip"</span>, <span>"and_char_filter"</span><span>]</span>,
          <span>"tokenizer"</span><span>:</span> <span>"standard"</span>,
          <span># 使用内置的 lowercase filter 和自定义的 my_filter</span>
          <span>"filter"</span><span>:</span> <span>[</span><span>"lowercase"</span>, <span>"an_stop_filter"</span><span>]</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>


GET my-index-001/_analyze
<span>{</span>
  <span>"analyzer"</span><span>:</span> <span>"custom_analyzer"</span>,
  <span>"text"</span><span>:</span> <span>"Tom &amp; Gogo bought an orange &lt;span> at an orange shop"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><p>可以在 Kibana 中运行上述的语句并且查看结果是否符合预期，<code>Tom</code> 和 <code>Gogo</code> 将会变成小写，而 <code>&amp;</code> 会转为 <code>and</code>，<code>an</code> 这个停用词和 <code>&lt;span&gt;</code> 这个 html 标签将会被处理掉，但 <code>at</code> 不会</p>
<p>ES 的内置分词器可以很方便地处理英文字符，但对于中文却并不那么好使，一般我们需要依赖第三方的分词器插件才能满足日常需求</p>
<h2 id="中文分词器"> 中文分词器</h2>
<p>中文分词不像英文分词那样可以简单地以空格来分隔，而是要分成有含义的词汇，但相同的词汇在不同的语境下有不同的含义。社区中有很多优秀的分词器，这里列出几个日常用得比较多的</p>
<ul>
<li><a href="https://github.com/elastic/elasticsearch/tree/master/plugins/analysis-icu" target="_blank" rel="noopener noreferrer">analysis-icu</a>：这是官方的插件，其将 Lucene ICU module 融入了 ES 中，使用 ICU 函数库来提供处理 Unicode 的工具</li>
<li><a href="https://github.com/medcl/elasticsearch-analysis-ik" target="_blank" rel="noopener noreferrer">IK</a>：支持自定义词典和词典热更新</li>
<li><a href="https://github.com/microbun/elasticsearch-thulac-plugin" target="_blank" rel="noopener noreferrer">THULAC</a>：其安装和使用官方文档中有详细的说明，这里就不再赘述了</li>
</ul>
<h3 id="analysis-icu-分词器"> analysis-icu 分词器</h3>
<p>analysis-icu 是官方的插件，安装如下：</p>
<div><pre><code><span># 进入脚本目录</span>
<span># 参见ES 的安装一节我们安装在 /opt/elasticsearch-7.13.0</span>
<span># 多节点集群需要对每个节点分别进行安装</span>

<span>cd</span> /opt/elasticsearch-7.13.0

bin/elasticsearch-plugin <span>install</span> https://artifacts.elastic.co/downloads/elasticsearch-plugins/analysis-icu/analysis-icu-7.13.0.zip

<span># 如果安装出错，并且提示你没有权限，请加上 sudo：</span>

<span>sudo</span> bin/elasticsearch-plugin <span>install</span> https://artifacts.elastic.co/downloads/elasticsearch-plugins/analysis-icu/analysis-icu-7.13.0.zip
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>使用示例如下：</p>
<div><pre><code>POST _analyze
<span>{</span>  
    <span>"analyzer"</span><span>:</span> <span>"icu_analyzer"</span>,
    <span>"text"</span><span>:</span> <span>"Linus 在90年代开发出了linux操作系统"</span>  
<span>}</span>

<span># 结果</span>
<span>{</span>
  <span>"tokens"</span> <span>:</span> <span>[</span>
    <span>..</span><span>..</span><span>..</span>
    <span>{</span>
      <span>"token"</span> <span>:</span> <span>"开发"</span>,
      <span>"start_offset"</span> <span>:</span> <span>11</span>,
      <span>"end_offset"</span> <span>:</span> <span>13</span>,
      <span>"type"</span> <span>:</span> <span>"&lt;IDEOGRAPHIC>"</span>,
      <span>"position"</span> <span>:</span> <span>4</span>
    <span>}</span>,
    <span>{</span>
      <span>"token"</span> <span>:</span> <span>"出了"</span>,
      <span>"start_offset"</span> <span>:</span> <span>13</span>,
      <span>"end_offset"</span> <span>:</span> <span>15</span>,
      <span>"type"</span> <span>:</span> <span>"&lt;IDEOGRAPHIC>"</span>,
      <span>"position"</span> <span>:</span> <span>5</span>
    <span>}</span>,
    <span>{</span>
      <span>"token"</span> <span>:</span> <span>"linux"</span>,
      <span>"start_offset"</span> <span>:</span> <span>15</span>,
      <span>"end_offset"</span> <span>:</span> <span>20</span>,
      <span>"type"</span> <span>:</span> <span>"&lt;ALPHANUM>"</span>,
      <span>"position"</span> <span>:</span> <span>6</span>
    <span>}</span>
    <span>..</span><span>..</span><span>..</span>
  <span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><p>通过在 Kibana 上运行上述查询语句，可以看到结果与 Standard Analyzer 是不一样的，同样你可以将得出的结果和下面的 IK 分词器做一下对比，看看哪款分词器更适合你的业务。更详细的使用文档可以查看：<a href="https://www.elastic.co/guide/en/elasticsearch/plugins/current/analysis-icu-analyzer.html" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<h3 id="ik-分词器"> IK 分词器</h3>
<p>IK 的算法是基于词典的，其支持自定义词典和词典热更新。下面来安装 IK 分词器插件：</p>
<div><pre><code><span># 还是一样，多节点集群需要对每个节点分别进行安装</span>

<span>cd</span> /opt/elasticsearch-7.13.0

<span># 如果因为没有权限而安装失败的话，使用 sudo 命令来安装</span>
./bin/elasticsearch-plugin <span>install</span> https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.13.0/elasticsearch-analysis-ik-7.13.0.zip
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>在每个节点</strong>执行完上述指令后，需要<strong>重启服务才能使插件生效</strong>。重启后，可以在 Kibana 中测试一下 IK 中文分词器的效果了</p>
<div><pre><code>POST _analyze
<span>{</span>  
    <span>"analyzer"</span><span>:</span> <span>"ik_max_word"</span>,
    <span>"text"</span><span>:</span> <span>"Linus 在90年代开发出了linux操作系统"</span>  
<span>}</span>

POST _analyze
<span>{</span>  
    <span>"analyzer"</span><span>:</span> <span>"ik_smart"</span>,
    <span>"text"</span><span>:</span> <span>"Linus 在90年代开发出了linux操作系统"</span>  
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>如上示例可以看到，<strong>IK 有两种模式：<code>ik_max_word</code> 和 <code>ik_smart</code></strong>，它们的区别可总结为如下（以下是 IK 项目的原文）</p>
<ul>
<li><strong><code>ik_max_word</code></strong>：会将文本做最细粒度的拆分，比如会将 <code>&quot;中华人民共和国国歌&quot;</code> 拆分为 <code>&quot;中华人民共和国、中华人民、中华、华人、人民共和国、人民、人、民、共和国、共和、和、国国、国歌&quot;</code>，会穷尽各种可能的组合，适合 Term Query</li>
<li><strong><code>ik_smart</code></strong>：会做最粗粒度的拆分，比如会将 <code>&quot;中华人民共和国国歌&quot;</code> 拆分为 <code>&quot;中华人民共和国、国歌&quot;</code>，适合 Phrase 查询</li>
</ul>
<p>关于 IK 分词器插件更详细的使用信息，可以参考 <a href="https://github.com/medcl/elasticsearch-analysis-ik/tree/v7.13.0" target="_blank" rel="noopener noreferrer">IK 项目</a>的文档</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">组合查询语法</title>
    <id>https://www.snowji.cn/databases/es/compound-query/</id>
    <link href="https://www.snowji.cn/databases/es/compound-query/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="组合查询语法"> 组合查询语法</h1>
<h2 id="前言"> 前言</h2>
<p>复杂的搜索需求往往需要组合各种搜索 API 来进行操作</p>
<p>带有组合功能的 API 有以下几个：</p>
<ul>
<li><strong>Bool Query</strong>：布尔查询，可以组合多个过滤语句来过滤文档</li>
<li><strong>Boosting Query</strong>：在 <code>positive</code> 块中指定匹配文档的语句，同时降低在 <code>negative</code> 块中也匹配的文档的得分，提供调整相关性算分的能力</li>
<li><strong>Constant Score Query</strong>：包装了一个过滤器查询，不进行算分</li>
<li><strong>Dis Max Query</strong>：返回匹配了一个或者多个查询语句的文档，但只将最佳匹配的评分作为相关性算分返回</li>
<li><strong>Function Score Query</strong>：支持使用函数来修改查询返回的分数</li>
</ul>
<h2 id="bool-query"> Bool Query</h2>
<p>Bool Query 使用一个或者多个布尔查询子句进行构建，每个子句都有一个类型，有如下类型：</p>
<ul>
<li><strong><code>must</code></strong>：查询的内容必须在匹配的文档中出现，并且会进行相关性算分（与 AND 等价）</li>
<li><strong><code>filter</code></strong>：查询的内容必须在匹配的文档中出现，但它的相关性算分是会被忽略的，并且子句将被考虑用于缓存（与 AND 等价）</li>
<li><strong><code>should</code></strong>：查询的内容应该在匹配的文档中出现，可以指定最小匹配的数量（与 OR 等价）</li>
<li><strong><code>must_not</code></strong>：查询的内容不能在匹配的文档中出现与 filter 一样其相关性算分也会被忽略（与 NOT 等价）</li>
</ul>
<p>must 示例：</p>
<div><pre><code>POST books/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"bool"</span><span>:</span> <span>{</span>
      <span>"must"</span><span>:</span> <span>[</span>
        <span>{</span>
          <span>"term"</span><span>:</span> <span>{</span>
            <span>"author"</span><span>:</span> <span>{</span>
              <span>"value"</span><span>:</span> <span>"Wolfgang Mauerer"</span>
            <span>}</span>
          <span>}</span>
        <span>}</span>,
        <span>{</span>
          <span>"term"</span><span>:</span> <span>{</span>
            <span>"date"</span><span>:</span> <span>{</span>
              <span>"value"</span><span>:</span> <span>"2010-06-01"</span>
            <span>}</span>
          <span>}</span>
        <span>}</span>
      <span>]</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>同样的需求，也可以用 should 子句来实现，但因为 should 默认只要匹配到一个就行了，所以需要借助 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/query-dsl-minimum-should-match.html" target="_blank" rel="noopener noreferrer"><code>minimum_should_match</code></a> 这个属性，可以指定最少匹配的查询数量或者百分比此处把它指定为 2 就可以了，示例：</p>
<div><pre><code>POST books/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"bool"</span><span>:</span> <span>{</span>
      <span>"should"</span><span>:</span> <span>[</span>
        <span>{</span>
          <span>"term"</span><span>:</span> <span>{</span>
            <span>"author"</span><span>:</span> <span>{</span>
              <span>"value"</span><span>:</span> <span>"Wolfgang Mauerer"</span>
            <span>}</span>
          <span>}</span>
        <span>}</span>,
        <span>{</span>
          <span>"term"</span><span>:</span> <span>{</span>
            <span>"date"</span><span>:</span> <span>{</span>
              <span>"value"</span><span>:</span> <span>"2010-06-01"</span>
            <span>}</span>
          <span>}</span>
        <span>}</span>
      <span>]</span>,
      <span>"minimum_should_match"</span><span>:</span> <span>2</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>但要注意，当在 Bool Query 里面使用了 should ，但同时还有 must 或者 filter 的情况下，<code>minimum_should_match</code> 默认就不是 1 而是 0 了因为这时候只看 must 、filter 的结果</p>
<p>就像这样的一种情况：</p>
<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br></div><pre><code><span># should 与 must 共用，should 失效</span>
POST books/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"bool"</span><span>:</span> <span>{</span>
      <span>"must"</span><span>:</span> <span>[</span>
        <span>{</span>
          <span>"match_all"</span><span>:</span> <span>{</span><span>}</span>
        <span>}</span>
      <span>]</span>,
      <span>"must_not"</span><span>:</span> <span>[</span><span>]</span>,
      <span>"should"</span><span>:</span> <span>[</span>
        <span>{</span>
          <span>"match_phrase"</span><span>:</span> <span>{</span>
            <span>"basicName"</span><span>:</span> <span>"测试"</span>
          <span>}</span>
        <span>}</span>
      <span>]</span>,
      <span>"filter"</span><span>:</span> <span>[</span><span>]</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

<span># 指定 "minimum_should_match": 1，即可解决这个问题</span>
POST books/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"bool"</span><span>:</span> <span>{</span>
      <span>"must"</span><span>:</span> <span>[</span>
        <span>{</span>
          <span>"match_all"</span><span>:</span> <span>{</span><span>}</span>
        <span>}</span>
      <span>]</span>,
      <span>"must_not"</span><span>:</span> <span>[</span><span>]</span>,
      <span>"should"</span><span>:</span> <span>[</span>
        <span>{</span>
          <span>"match_phrase"</span><span>:</span> <span>{</span>
            <span>"basicName"</span><span>:</span> <span>"测试"</span>
          <span>}</span>
        <span>}</span>
      <span>]</span>,
      <span>"minimum_should_match"</span><span>:</span> <span>1</span>,
      <span>"filter"</span><span>:</span> <span>[</span><span>]</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><p>同样的需求，甚至可以用 must 子句和 filter 子句的组合来实现，虽然对于这个需求来说这么做自找麻烦示例：</p>
<div><pre><code>POST books/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"bool"</span><span>:</span> <span>{</span>
      <span>"must"</span><span>:</span> <span>[</span>
        <span>{</span>
          <span>"term"</span><span>:</span> <span>{</span>
            <span>"author"</span><span>:</span> <span>{</span>
              <span>"value"</span><span>:</span> <span>"Wolfgang Mauerer"</span>
            <span>}</span>
          <span>}</span>
        <span>}</span>
      <span>]</span>,
      <span>"filter"</span><span>:</span> <span>[</span>
        <span>{</span>
          <span>"term"</span><span>:</span> <span>{</span>
            <span>"date"</span><span>:</span> <span>{</span>
              <span>"value"</span><span>:</span> <span>"2010-06-01"</span>
            <span>}</span>
          <span>}</span>
        <span>}</span>
      <span>]</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h2 id="boosting-query"> Boosting Query</h2>
<p>Boosting Query 可以指定两个块：<code>positive</code> 块和 <code>negative</code> 块</p>
<p>可以在 positive 块来指定匹配文档的语句，而在 negative 块中匹配的文档其相关性算分将会降低相关性算分降低的程度将由 <code>negative_boost</code> 参数决定，其取值范围为：<code>[0.0, 1.0]</code></p>
<p>在 negative 块中匹配的文档，其相关性算分为：在 positive 中匹配时的算分 * <code>negative_boost</code></p>
<div><pre><code>POST books/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"boosting"</span><span>:</span> <span>{</span>
      <span>"positive"</span><span>:</span> <span>{</span>
        <span>"term"</span><span>:</span> <span>{</span>
          <span>"name"</span><span>:</span> <span>{</span>
            <span>"value"</span><span>:</span> <span>"linux"</span>
          <span>}</span>
        <span>}</span>
      <span>}</span>,
      <span>"negative"</span><span>:</span> <span>{</span>
        <span>"term"</span><span>:</span> <span>{</span>
          <span>"name"</span><span>:</span> <span>{</span>
            <span>"value"</span><span>:</span> <span>"programming"</span>
          <span>}</span>
        <span>}</span>
      <span>}</span>,
      <span>"negative_boost"</span><span>:</span> <span>0.5</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h2 id="constant-score-query"> Constant Score Query</h2>
<p>Constant Score 其实就是包装了一个过滤器查询，不进行算分可以将 query 转化为 filter，可以忽略相关性算分的环节，并且 filter 可以有效利用缓存，从而提高查询的性能</p>
<div><pre><code><span># 使用 Range 查询，并且不进行相关性算分</span>
POST /books/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"constant_score"</span><span>:</span> <span>{</span>
      <span>"filter"</span><span>:</span> <span>{</span>
        <span>"range"</span><span>:</span> <span>{</span>
          <span>"price"</span><span>:</span> <span>{</span>
            <span>"gte"</span><span>:</span> <span>10</span>,
            <span>"lte"</span><span>:</span> <span>20</span>
          <span>}</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="dis-max-query"> Dis Max Query</h2>
<p>Disjunction Max Query 的简称，是分离最大化查询的意思</p>
<ul>
<li>disjunction（分离）：表示把同一个文档中的每个字段上的查询都分开，分别进行算分操作</li>
<li>max（最大化）：是将多个字段查询的得分的最大值作为最终评分返回</li>
</ul>
<p>它的效果是：<strong>将所有与任一查询匹配的文档作为结果返回，但是只将最佳匹配的得分作为查询的算分结果进行返回</strong>不过其他匹配的字段可以使用 <code>tie_breaker</code> 参数来进行「维权」</p>
<p>示例如下：</p>
<div><pre><code><span># 最终返回的相关性评分将以匹配 "linux" 或者匹配 "kernel" 中最大的那个评分为准</span>
POST books/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"dis_max"</span><span>:</span> <span>{</span>
      <span>"queries"</span><span>:</span> <span>[</span>
        <span>{</span>
          <span>"term"</span><span>:</span> <span>{</span>
            <span>"name"</span><span>:</span> <span>{</span>
              <span>"value"</span><span>:</span> <span>"linux"</span>
            <span>}</span>
          <span>}</span>
        <span>}</span>,
        <span>{</span>
          <span>"term"</span><span>:</span> <span>{</span>
            <span>"intro"</span><span>:</span> <span>{</span>
              <span>"value"</span><span>:</span> <span>"kernel"</span>
            <span>}</span>
          <span>}</span>
        <span>}</span>
      <span>]</span>,
      <span>"tie_breaker"</span><span>:</span> <span>0.9</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><blockquote>
<p>维权算法</p>
<ul>
<li>令算分最高的字段的得分为 s1</li>
<li>令其他匹配的字段的算分 * <code>tie_breaker</code> 的和为 s2</li>
<li>最终算分为：s1 + s2</li>
</ul>
<p><code>tie_breaker</code> 的取值范围为：<code>[0.0, 1.0]</code>当其为 0.0 的时候，表示使用最佳匹配字段的得分作为相关性算分当其为 1.0 的时候，表示所有字段的得分同等重要</p>
</blockquote>
<h2 id="function-score-query"> Function Score Query</h2>
<p>Function Score Query 允许你在查询结束以后去修改每一个匹配文档的相关性算分，所以使用算分函数可以改变或者替换原来的相关性算分结果</p>
<p>它提供了以下几种算分函数：</p>
<ul>
<li><code>script_score</code>：利用自定义脚本完全控制算分逻辑</li>
<li><code>weight</code>：为每一个文档设置一个简单且不会被规范化的权重</li>
<li><code>random_score</code>：为每个用户提供一个不同的随机算分，对结果进行排序</li>
<li><code>field_value_factor</code>：使用文档字段的值来影响算分，例如将好评数量这个字段作为考虑因数</li>
<li><code>decay functions</code>：衰减函数，以某个字段的值为标准，距离指定值越近，算分就越高例如我想让书本价格越接近 10 元，算分越高排序越靠前</li>
</ul>
<h3 id="field-value-factor"> field_value_factor</h3>
<p><code>field_value_factor</code> 的作用是用文档某个字段的值来影响相关性算分，它可以解决这样的需求：价格优惠的优先推荐、点赞数多的优先推荐、购买量多的优先推荐等</p>
<p>它提供了以下几个参数选项：</p>
<ul>
<li><strong>field</strong>：文档的字段</li>
<li><strong>factor</strong>：指定文档的值将会乘以这个因子，默认为 1</li>
<li><strong>modifier</strong>：修改最终值的函数，其值可以为：none、log、log1p、log2p、ln、ln1p、ln2p、square、 sqrt、reciprocal，默认为 none</li>
</ul>
<p>假如我想让 <code>price</code> 影响相关性算分，随着价格的增加，相关性算分将相应地降低，要满足这个需求可以这样做：</p>
<div><pre><code>POST books/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"function_score"</span><span>:</span> <span>{</span>
      <span>"query"</span><span>:</span> <span>{</span>
        <span>"term"</span><span>:</span> <span>{</span>
          <span>"name"</span><span>:</span> <span>{</span>
            <span>"value"</span><span>:</span> <span>"linux"</span>
          <span>}</span>
        <span>}</span>
      <span>}</span>,
      <span>"field_value_factor"</span><span>:</span> <span>{</span>
        <span>"field"</span><span>:</span> <span>"price"</span>,
        <span>"factor"</span><span>:</span> <span>1.2</span>,
        <span>"modifier"</span><span>:</span> <span>"reciprocal"</span>,
        <span>"missing"</span><span>:</span> <span>1</span>
      <span>}</span>,
      <span>"boost_mode"</span><span>:</span> <span>"multiply"</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>上述示例中，使用价格字段来影响相关性算分，其中 <code>factor</code> 为 1.2，将会乘以价格</p>
<p><code>modifier</code> 使用的是 <code>reciprocal</code>，其作用类似于 <code>1/x</code>，这里 x 的值就是 price * factor 了</p>
<p><code>boost_mode</code> 为 <code>multiply</code>，其作用是使得旧算分与 <code>field_value_factor</code> 产生的算分相乘</p>
<p>所以最终得分的计算过程如下：<code>新算分 = 匹配过程产生的旧算分 * reciprocal(1.2 * doc['price'].value)</code></p>
<p>对于 <code>boost_mode</code> 参数，它的值有以下几种：</p>
<ul>
<li><strong>multiply</strong>：算分与函数值的积，multiply 是默认值</li>
<li><strong>replace</strong>：使用函数值作为最终的算分结果</li>
<li><strong>sum</strong>：算分与函数值的和</li>
<li><strong>avg</strong>：算分与函数值的平均数</li>
<li><strong>min</strong>：在算分与函数值中取最小值</li>
<li><strong>max</strong>：在算分与函数值中去最大值</li>
</ul>
<h3 id="random-score"> random_score</h3>
<p><code>random_score</code> 算分函数可以实现为每一个用户推荐随机数据的需求，但是希望一段时间内同一个用户访问的时候，这部分内容的排序都是一样的</p>
<div><pre><code>POST books/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"function_score"</span><span>:</span> <span>{</span>
      <span>"random_score"</span><span>:</span> <span>{</span>
        <span>"seed"</span><span>:</span> <span>81819</span>,
        <span>"field"</span><span>:</span> <span>"_seq_no"</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上述示例中，当 <code>seed</code> 的值不变的时候，随机内容的排序结果将不会变化</p>
<p>需要注意的是，在使用 <code>random_score</code> 算分函数的时候，需要指定 <code>seed</code> 和 <code>field</code>，如果只指定 seed，需要在 <code>_id</code> 字段上加载 <code>fielddata</code>，这样将会消耗大量的内存</p>
<p>一般来说，使用 <code>_seq_no</code> 作为 field 的值是比较推荐的，但是如果 seed 不变的情况下，文档被更新了，这个时候文档的 <code>_seq_no</code> 是会变化的，将会导致排序结果的变化</p>
<h3 id="其他算分函数"> 其他算分函数</h3>
<p>参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/query-dsl-function-score-query.html" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<h2 id="参考资料"> 参考资料</h2>
<ul>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/compound-queries.html" target="_blank" rel="noopener noreferrer">Compound queries</a></li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">ES 的安装</title>
    <id>https://www.snowji.cn/databases/es/installation-of-elasticsearch/</id>
    <link href="https://www.snowji.cn/databases/es/installation-of-elasticsearch/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="es-的安装"> ES 的安装</h1>
<h2 id="ubuntu-下安装-es"> Ubuntu 下安装 ES</h2>
<h3 id="下载、解压-es-安装包"> 下载、解压 ES 安装包</h3>
<p>可以在<a href="https://www.elastic.co/cn/downloads/elasticsearch" target="_blank" rel="noopener noreferrer">官方下载页面</a>进行下载，然后上传到服务器</p>
<p>也可以在 Ubuntu 上使用 <code>wget</code> 指令进行下载，然后解压：</p>
<div><pre><code><span># 我一般将 ES 安装在 /opt 目录下</span>
<span>cd</span> /opt

<span>wget</span> https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.13.0-linux-x86_64.tar.gz

<span>tar</span> -zxvf elasticsearch-7.13.0-linux-x86_64.tar.gz
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>解压后可以看到 ES 的文件目录结构如下：</p>
<div><pre><code>├── elasticsearch-7.13.0
    │── bin              # 包含一些执行脚本，其中 ES 的启动文件和脚本安装文件就在这里
    │── config           # 包含集群的配置文件（elasticsearch.yml）、jvm配置（jvm.options）、user等相关配置
    │── jdk              # 7.0 后自带 jdk，java 运行环境
    │── lib              # java 的类库
    │── LICENSE.txt
    │── logs
    │── modules          # 包含所有 ES 的模块
    │── NOTICE.txt
    │── plugins          # 插件安装的目录
    └── README.asciidoc
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="修改-es-服务配置"> 修改 ES 服务配置</h3>
<p>虽然 ES 可以开箱即用，但这里我们还是需要修改部分配置的ES 的配置文件在 config 目录内，我们主要关注两个配置文件：<code>elasticsearch.yml</code> 和 <code>jvm.options</code></p>
<p>elasticsearch.yml 是用来配置 ES 服务的各种参数的，而 jvm.options 主要保存 JVM 相关的配置</p>
<p>编辑配置文件 <code>vim /config/elasticsearch.yml</code>，在最后添加如下配置项：</p>
<div><pre><code><span># 建议和前面的内容之间加个空行，可以更清晰些</span>

cluster.name: my_app
node.name: my_node_1
path.data: ./data
path.logs: ./logs
http.port: <span>9211</span>
network.host: <span>0.0</span>.0.0  <span># 线上一定不能配置为 0.0.0.0</span>
discovery.seed_hosts: <span>[</span><span>"localhost"</span><span>]</span>
cluster.initial_master_nodes: <span>[</span><span>"my_node_1"</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>配置项解析：</p>
<ul>
<li><code>discovery.seed_hosts</code>：在开箱即用的场景下（本机环境）无需配置，ES 会自动扫描本机的 9300 到9305 端口一旦进行了网络环境配置，这个自动扫描操作就不会执行
<ul>
<li>将它的值配置为 master 候选者节点即可如果需要指定端口的话，其值可以为：<code>[&quot;localhost:9300&quot;, &quot;localhost:9301&quot;]</code></li>
</ul>
</li>
<li><code>cluster.initial_master_nodes</code>：指定新集群 master 候选者列表，其值为节点的名字列表
<ul>
<li>这里配置了 <code>node.name: my_node_1</code>，所以其值为 <code>[&quot;my_node_1&quot;]</code>，而不是 ip 列表</li>
</ul>
</li>
<li><code>network.host</code> 和 <code>http.port</code>：这是 ES 提供服务的监听地址和端口
<ul>
<li>线上一定不能配置 ip 为 0.0.0.0，这是非常危险的行为！！！</li>
</ul>
</li>
</ul>
<blockquote>
<p>怎么样来理解这个 <code>discovery.seed_hosts</code> 和 <code>cluster.initial_master_nodes</code> 呢？</p>
<ul>
<li>
<p><code>cluster.initial_master_nodes</code> 是候选者列表，一般我们线上环境候选者的数量会比较少，毕竟是用来做备用的而且这个配置只跟选举 master 有关，也就是跟其他类型的节点没有关系，其他类型的节点不需要配置这个也是可以的</p>
</li>
<li>
<p><code>discovery.seed_hosts</code> 这个可以理解为是做服务或者节点发现的，其他节点必须知道他们才能进入集群，一般配置为集群的 master 候选者的列表</p>
</li>
</ul>
<p>在现实环境中是这些 master 候选者（组织联系人）可能会经常变化，那怎么办呢？</p>
<p><code>discovery.seed_hosts</code> 这个配置项除了支持 ip 外还支持域名，所以可以用域名来解决这个问题其他类型节点的配置上写的是域名，域名解析到对应的 ip，如果机器挂了，新的节点 ip 换了，就把域名解析到新的 ip 即可，这样其他节点的配就不用修改了所以非 master 候选节点要配 <code>discovery.seed_hosts</code>（组织联系人）才能顺利加入到集群中来</p>
</blockquote>
<h3 id="修改-jvm-参数"> 修改 JVM 参数</h3>
<p>除了修改 ES 服务配置外，还需要在 jvm.options 文件中配置 JVM 的参数，我们主要配置服务占用的堆内存的大小：</p>
<p>编辑配置文件 <code>vim /config/jvm.options</code>，在最后添加如下配置项：</p>
<div><pre><code><span># 建议和前面的内容之间加个空行，可以更清晰些</span>

<span># 设置堆内存最小值</span>
-Xms1g
<span># 设置堆内存最大值</span>
-Xmx1g
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>JVM 配置需要注意以下几点：</p>
<ul>
<li><strong>-Xms 和 -Xmx 这两个 JVM 的参数必须配置为一样的数值</strong>服务在启动的时候就分配好内存空间，避免运行时申请分配内存造成系统抖动</li>
<li><strong>Xmx 不要超过机器内存的 50%，留下些内存供 JVM 堆外内存使用</strong></li>
<li><strong>并且 Xmx 不要超过 32G，建议最大配置为 30G</strong>接近 32G，JVM 会启用压缩对象指针的功能，导致性能下降具体可以参考：<a href="https://www.elastic.co/cn/blog/a-heap-of-trouble" target="_blank" rel="noopener noreferrer">a-heap-of-trouble</a></li>
</ul>
<h3 id="配置系统环境"> 配置系统环境</h3>
<p>如果就上面的配置进行启动，ES 会报错：</p>
<div><pre><code>bootstrap check failure <span>[</span><span>1</span><span>]</span> of <span>[</span><span>1</span><span>]</span>:

max virtual memory areas vm.max_map_count <span>[</span><span>65530</span><span>]</span> is too low, increase to at least <span>[</span><span>262144</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>按照提示进行操作系统配置就可以了，执行 <code>vim /etc/sysctl.conf</code> 指令，添加如下内容来配置系统环境：</p>
<div><pre><code><span># 建议和前面的内容之间加个空行，可以更清晰些</span>

vm.max_map_count<span>=</span><span>262144</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>然后执行 <code>sysctl -p</code></p>
<h3 id="创建用户并赋予权限"> 创建用户并赋予权限</h3>
<p>创建一个名为 elasticsearch 的用户：</p>
<div><pre><code><span># 为 ES 创建一个不能 ssh 登陆的用户，且不创建用户主目录</span>
<span>useradd</span> elasticsearch -s /sbin/nologin -M
<span># 修改文件所有者</span>
<span>chown</span> -R elasticsearch:elasticsearch /opt/elasticsearch-7.13.0/
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="前台运行-es"> 前台运行 ES</h3>
<p>注意，ES 不能使用 root 来运行！！！！</p>
<div><pre><code><span># 前台运行，可以直接查看日志</span>
.bin/elasticsearch

<span># 后台运行，日志在 ./logs/my_app.log</span>
<span># 查看日志的话可以：tail -n 100 -f logs/my_app.log</span>
.bin/elasticsearch -d
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>在浏览器中访问 localhost:9211，可以看到有关节点信息的内容即运行成功</p>
<h2 id="ubuntu-下安装-kibana"> Ubuntu 下安装 Kibana</h2>
<h3 id="下载、解压"> 下载、解压</h3>
<p>Kibana 是官方的数据分析和可视化平台，但现在我们只需要把它当作 ES 查询的调试工具即可Kibana 与 ES 的版本是有对应关系的，所以需要下载与 ES 同版本的 Kibana，在这里下载 <a href="https://www.elastic.co/cn/downloads/kibana" target="_blank" rel="noopener noreferrer">Kibana</a></p>
<p>下面是使用 <code>wget</code> 下载并且解压安装 Kibana 的指令（版本与前面安装的 ES 一致，都是 7.13.0）：</p>
<div><pre><code><span># 还是安装在 /opt 目录</span>
<span>cd</span> /opt

<span>wget</span> https://artifacts.elastic.co/downloads/kibana/kibana-7.13.0-linux-x86_64.tar.gz

<span>tar</span> -zxvf kibana-7.13.0-linux-x86_64.tar.gz

<span># 重命名</span>
<span>mv</span> kibana-7.13.0-linux-x86_64 kibana-7.13.0

<span># 进入安装目录，准备做一些配置</span>
<span>cd</span> kibana-7.13.0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="修改服务配置"> 修改服务配置</h3>
<p>编辑配置文件 <code>vim /config/kibana.yml</code>，在最后添加如下配置项：</p>
<div><pre><code><span># 建议和前面的内容之间加个空行，可以更清晰些</span>

server.host: <span>"0.0.0.0"</span>  <span># 线上一定不能配置ip为 0.0.0.0，这是非常危险的行为！！！</span>

elasticsearch.hosts: <span>[</span><span>"http://localhost:9211"</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>前面创建过一个名为 elasticsearch 的用户，这里的 Kibana 也用这个用户来运行吧，保持一致</p>
<div><pre><code><span># 修改文件所有者</span>
<span>chown</span> -R elasticsearch:elasticsearch /opt/kibana-7.13.0/
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="前台运行-kibana"> 前台运行 Kibana</h3>
<div><pre><code>./bin/kibana <span>>></span> run.log <span><span>2</span>></span><span>&amp;1</span> <span>&amp;</span>
</code></pre>
<div><span>1</span><br></div></div><p>安装完成后，在浏览器中访问 localhost:5601，如果运行成功可以进入到可视化操作界面</p>
<p>打开 Dev Tools 即可开始你的查询了，新版的 Kibana 加入了很多功能，比我之前用的 5.x 丰富很多</p>
<h2 id="安装-cerebro"> 安装 Cerebro</h2>
<p><a href="https://github.com/lmenezes/cerebro" target="_blank" rel="noopener noreferrer">Cerebro</a> 是一个简单的 ES 集群管理工具，其安装如下：</p>
<div><pre><code><span>cd</span> /opt

<span>wget</span> https://github.com//lmenezes/cerebro/releases/download/v0.9.4/cerebro-0.9.4.tgz

<span>tar</span> -zxvf cerebro-0.9.4.tgz

<span>mv</span> cerebro-0.9.4 cerebro

<span>cd</span> cerebro

<span>sed</span> -i <span>'s/server.http.port = ${?CEREBRO_PORT}/server.http.port = 9800/g'</span> conf/application.conf

<span>echo</span> -e <span>'\nhosts = [
    {
        host = "http://localhost:9211"
        name = "my_app"
    }
]'</span> <span>>></span> conf/application.conf
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>配置完成后，运行以下指令启动 Cerebro：</p>
<div><pre><code><span># 启动，在 run.log 中查看日志</span>
.bin/cerebro <span>>></span> run.log <span><span>2</span>></span><span>&amp;1</span> <span>&amp;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果启动成功，在浏览器中访问 localhost:9800 即可访问 Cerebro</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">ES 中的概念与名词</title>
    <id>https://www.snowji.cn/databases/es/concepts-and-noun/</id>
    <link href="https://www.snowji.cn/databases/es/concepts-and-noun/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="es-中的概念与名词"> ES 中的概念与名词</h1>
<p>下面将自上而下介绍几个 ES 中常用的概念与名词</p>
<h2 id="集群层面的基本概念"> 集群层面的基本概念</h2>
<h3 id="集群-cluster"> 集群（Cluster）</h3>
<p>一台服务器安装一个 ES 称为单机 ES，因为它是支持分布式的，多个协同工作的 ES 实例就组合成了集群分布式的 ES 集群可以存储海量的数据，也可以从容地面对更高的并发量</p>
<p>得益于分布式系统的架构设计，使得 ES 集群拥有高可用性和可扩展性</p>
<ul>
<li>高可用性，分为服务可用性、数据可用性
<ul>
<li>服务可用性，在有部分节点挂掉的情况下系统还可以对外提供服务</li>
<li>数据可用性，部分节点挂掉，并且这些节点的数据无法恢复的情况下，也能保证数据不丢失</li>
</ul>
</li>
<li>可扩展性，当并发量提升，或者数据量增多的情况下，可以通过增加节点数来解决问题</li>
</ul>
<h3 id="节点-node"> 节点（Node）</h3>
<p>在集群中，每一个 ES 服务实例就是一个节点（Node1、Node2、Node3），本质上就是一个 Java 进程每个实例都有自己的名字，就是配置里的 <code>'node.name'</code> 设置的内容为了标识每个节点，每个节点启动后都会分配一个 UID，存储在 data 目录各个节点受到集群的管理，我们可以通过增加或者减少节点来达到扩容或减容的目的</p>
<p>集群里的节点是有分类的，就好像一家公司的不同部门，负责不同的业务和工作，主要的节点类型如下：</p>
<ul>
<li><strong>主节点（Master）</strong>：主节点在整个集群是唯一的，Master 从有资格进行选举的节点（Master Eligible）中选举出来主节点主要负责管理集群变更、元数据的更改</li>
<li><strong>数据节点（Data Node）</strong>：负责保存数据，要扩充存储时候需要扩展这类节点数据节点还负责执行数据相关的操作，如：搜索、聚合、CURD 等所以对服务器的 CPU、内存、I/O 要求都比较高</li>
<li><strong>协调节点（Coordinating Node）</strong>：负责接受客户端的请求，将请求路由到对应的节点进行处理，并且把最终结果汇总到一起返回给客户端因为需要处理结果集和对其进行排序，需要较高的 CPU 和内存资源</li>
<li><strong>预处理节点（Ingest Node）</strong>：预处理操作允许在写入文档前通过定义好的一些 processors（处理器）和管道对数据进行转换默认情况下节点启动后就是预处理节点</li>
<li><strong>部落节点（Tribe Node）</strong>：部落节点可以连接到不同集群，并且支持将这些集群当成一个单独的集群处理但它在未来的版本中将会被淘汰</li>
<li><strong>Hot &amp; Warm Node</strong>：不同硬件配置的 Data Node，用来实现 Hot &amp; Warm 架构的节点，有利于降低集群部署成本例如，在硬件资源好的机器中部署 Hot 类型的数据节点，而在硬件资源一般的机器上部署 Warm Node 节点</li>
</ul>
<p>在生产环境中建议将每个节点设置为单一角色如果业务量或者并发量不大的情况下，为了节省成本可以调整为一个节点多种角色的集群在开发环境中的话，为了节省资源，一个节点可以设置多种角色（伪集群模式）</p>
<p>ES 版本变化比较快，所以各个节点类型的配置方式也会变动，具体的可以参考 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/modules-node.html" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<h3 id="分片-shard"> 分片（Shard）</h3>
<p>一般来说，面对海量数据的时候，分布式系统可以通过增加机器数量来进行水平扩展所以，系统需要将数据分成多个小块数据，并且尽量均匀地分配到各个机器上，然后可以通过某种策略找到对应数据块所在的位置</p>
<p>分片（Shard）是 ES 底层基本的读写单元，分片是为了分割巨大的索引数据，让读写可以由多台机器来完成，从而提高系统的吞吐量</p>
<div style="text-align: center;">
  <img src="./images/shard.jpg" alt="Shard 示例" style="height: 240px;">
</div>
<p>如上图，数据集 Data 按某些规则分为 4 个部分，然后被存储到 4 个节点上面（一个节点一个分片）</p>
<h3 id="副本-replica"> 副本（Replica）</h3>
<p>为了保证数据可靠性，一般分布式系统都会对数据进行冗余备份，这个备份也就是副本了</p>
<p>ES 将数据副本分为主从两类型：主分片（primary shard）和副分片（replica shard）</p>
<p>在写入的过程中，先写主分片，成功后并发写副分片，在数据恢复时以主分片为主多个副本除了可以保证数据可靠性外，还有一个好处是可以承担系统的读负载</p>
<p>可以在 Kibana 中运行下面指令来设置分片数量和副本数量：</p>
<div><pre><code><span># 创建 mapping 的时候定义好分片和副本数量</span>
PUT books
<span>{</span>
  <span>"mappings"</span><span>:</span> <span>{</span>
    <span>"properties"</span><span>:</span> <span>{</span>
        <span>"book_id"</span><span>:</span> <span>{</span>
          <span>"type"</span><span>:</span> <span>"keyword"</span>
        <span>}</span>,
        <span>"name"</span><span>:</span> <span>{</span>
          <span>"type"</span><span>:</span> <span>"text"</span>
        <span>}</span>
      <span>}</span>
  <span>}</span>,
  <span>"settings"</span><span>:</span> <span>{</span>
    <span>"number_of_shards"</span><span>:</span> <span>2</span>, <span># 定义了 2 个分片</span>
    <span>"number_of_replicas"</span><span>:</span> <span>2</span> <span># 定义了每个分片 2 个副分片</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>用上述指令创建 books 索引后，其在 Cerebro 中显示如下图，在红色箭头处 shards: 2 * 3 的意思是共有 2 个分片，每个分片一个主分片和 2 个副分片，加起来就是 3 个副本了图中黄色箭头处的 0 和 1 代表的是两个分片：分片 0 、分片 1，实线代表主分片，虚线代表分片副本</p>
<div style="text-align: center;">
  <img src="./images/shards-and-replicas.jpg" alt="主分片和副分片示例">
</div>
<h3 id="集群健康状态"> 集群健康状态</h3>
<p>通过集群的健康状态，我们可以了解集群是不是出现问题了集群健康状态有以下 3 种</p>
<ul>
<li><strong>Green</strong>，集群处于健康状态，所有的主分片和副本分片都正常运行</li>
<li><strong>Yellow</strong>，所有的主分片都运行正常，但是有部分副本分片不正常，意味着可能存在单点故障的风险（如果部分主分片没有备份了，一旦这个主分片数据丢失，将导致这些数据永久丢失）如果集群只有 3 个数据节点，但是分配了 4 个副本（主分片 + 副本分片的总数），这个时候有一个副本无法分配的，因为相同的两份数据不应该被分配到同一个节点上</li>
<li><strong>Red</strong>，有部分主分片没有正常运行</li>
</ul>
<p>需要注意的是，每个索引也有这三种状态，<strong>如果索引丢失了一个副本分片，那么这个索引和集群的状态都变为 Yellow 状态，但是其他索引的的状态仍为 Green</strong></p>
<h2 id="集群层面的基本概念-2"> 集群层面的基本概念</h2>
<h3 id="索引-index"> 索引（Index）</h3>
<blockquote>
<p>可以简单认为索引是类似于 MySQL 数据库的表</p>
</blockquote>
<p>索引是一类相似文档的集合ES 将数据存储在一个或者多个 Index 中，例如将用户数据存储在 User Index 中，而将订单数据存储在 Order Index 中一个索引有一个或者多个分片，索引的数据会以某种方式分散到各个分片上去存储</p>
<div style="text-align: center;">
  <img src="./images/index.jpg" alt="Index 示例" style="height: 240px;">
</div>
<p>如上图，索引有 3 个分片主分片分别是 P1、P2、P3，对应的副本分片为 R1、R2、R3它们分别位于 3 个节点中</p>
<p>可以发现主分片和其副本分片不会同时分配在同一个节点上，这样是为了保证当一个节点上的主分片下线时，其他节点上的从副本可以升级为主分片，保证数据的可靠性</p>
<h3 id="mapping"> Mapping</h3>
<blockquote>
<p>可以简单认为 Mapping 是类似于 MySQL 数据库表结构的定义</p>
</blockquote>
<p>Mapping 定义了索引里的文档到底有哪些字段及这些字段的类型，类似于数据库中表结构的定义Mapping 有两种作用：</p>
<ul>
<li>定义了索引中各个字段的名称和对应的类型</li>
<li>定义各个字段、倒排索引的相关设置，如使用什么分词器等</li>
</ul>
<p>需要注意的是，Mapping 一旦定义后，已经定义的字段的类型是不能更改的</p>
<h3 id="文档-doc"> 文档（Doc）</h3>
<p>我们向 ES 中写入的每一条数据都是一个文档（类似数据库中的一条记录），并且我们搜索也是以文档为单位的，所以文档是 ES 中的主要实体</p>
<p>在 Kibana 中运行下面指令来插入一条书本的记录：</p>
<div><pre><code><span># 我们指定了文档的 id 为1</span>
POST /books/_doc/1
<span>{</span>
  <span>"book_id"</span><span>:</span><span>"123"</span>,
  <span>"name"</span><span>:</span><span>"linux 从入门到放弃"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>在 Kibana 中运行以下命令来查询指定 key-value 的数据：</p>
<div><pre><code><span># 搜索</span>
POST books/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"match_phrase"</span><span>:</span> <span>{</span>
      <span>"book_id"</span><span>:</span> <span>"123"</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

<span># 返回的结果</span>
<span>{</span>
  <span>..</span><span>..</span><span>..</span>
  <span>"hits"</span> <span>:</span> <span>{</span>
    <span>..</span><span>..</span><span>..</span>
    <span>"max_score"</span> <span>:</span> <span>0.2876821</span>,
    <span>"hits"</span> <span>:</span> <span>[</span>
      <span>{</span>
        <span>"_index"</span> <span>:</span> <span>"books"</span>,
        <span>"_type"</span> <span>:</span> <span>"_doc"</span>,
        <span>"_id"</span> <span>:</span> <span>"1"</span>,
        <span>"_score"</span> <span>:</span> <span>0.2876821</span>,
        <span>"_source"</span> <span>:</span> <span>{</span>
          <span>"book_id"</span> <span>:</span> <span>"123"</span>,
          <span>"name"</span> <span>:</span> <span>"linux 从入门到放弃"</span>
        <span>}</span>
      <span>}</span>
    <span>]</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>从返回结果中可以看到，之前插入的数据包含在 <code>_source</code> 字段里，结果中还带有其他字段，这些额外的字段都是 ES 为文档加上的元数据，下面是这些字段的解析</p>
<ul>
<li><strong><code>_index</code></strong>：文档所属的索引名字，上述是 books</li>
<li><strong><code>_type</code></strong>：文档所属的类型名字，现在 ES 7.x 版本的类型统一为 &quot;<code>_doc</code>&quot;</li>
<li><strong><code>_id</code></strong>：文档的唯一 id如果我们插入时不指定文档 id，ES 会随机分配，这样有利于数据均匀分散到各个分片</li>
<li><strong><code>_version</code></strong>：文档的版本信息，并发读写时可以解决文档冲突</li>
<li><strong><code>_score</code></strong>：相关性算分，代表着查询的匹配性，用来排序</li>
<li><strong><code>_seq_no</code></strong> 和 <strong><code>_primary_term</code></strong>：是 ES 内部用来保证主分片和副本数据一致性的</li>
</ul>
<p>总体来说，文档有以下几个特性</p>
<ul>
<li>ES 是面向文档的并且以文档为单位进行搜索的，如一条书本记录</li>
<li>文档以 JSON 格式进行序列化存储</li>
<li>每个文档都有唯一的 ID插入数据时不手动指定 ID 的性能会好点，因为系统不需要进一步判断这个 ID 是否已经存在</li>
</ul>
<h3 id="字段-field"> 字段（Field）</h3>
<p>每个文档都有一个或者多个字段，例如 books 索引指定了书本的记录有 <code>book_id</code> 和 <code>name</code> 两个字段，这些字段都有指定的类型字段本质上就是 JSON 中的 Key</p>
<h3 id="词项-term"> 词项（Term）</h3>
<p>将全文本的内容进行分词后得到的词语就是词项了例如 &quot;<code>Programmers Love Cat</code>&quot; 使用标准分词器分词后得到 <code>[programmer, love, cat]</code> 这 3 个词项需要注意的是：分词器除了进行分词外还会进行大小写转换等其他操作</p>
<h3 id="倒排索引与正排索引"> 倒排索引与正排索引</h3>
<p>这是两种数据结构</p>
<p>正排索引保存了实体 ID 到实体数据的关联关系MySQL InnoDB 的索引就是正排索引，使用的是 B+ 树来实现</p>
<div style="text-align: center;">
  <img src="./images/forward-index.jpg" alt="正排索引示例" style="height: 160px;">
</div>
<p>正排索引保存了词项到文档实体的关联关系倒排索引的具体实现先不展开，先简单了解一下这个概念就可以了</p>
<div style="text-align: center;">
  <img src="./images/inverted-index.jpg" alt="倒排索引示例" style="height: 160px;">
</div>
<h2 id="系统层面上的基本概念"> 系统层面上的基本概念</h2>
<h3 id="近实时系统"> 近实时系统</h3>
<p>ES 是一个近实时系统，我们写入的数据默认的情况下会在 1 秒后才能被查询到</p>
<p>ES 每秒都会把缓存中的数据写入到 Segment 文件中（写入到 Segment 中才能被检索），然后根据某些规则进行刷盘，并且合并这些 Segment所以需要注意的是，不能在写入数据成功后，立刻进行查询，这个时候可能会出现查询不到数据或者获取到旧数据的情况</p>
<h3 id="lucene-与-es-的关系"> Lucene 与 ES 的关系</h3>
<p>Lucene 是一个用于全文检索的开源项目，ES 在搜索的底层实现上用的就是 Lucene可以简单认为，ES 就是在 Lucene 上增加了分布式特性的系统服务</p>
<p>Lucene 也有索引，那 Lucene 的索引和 ES 的索引是个怎么样的关系呢？其实 ES 上的分片（Shard）就是一个完整的 Lucene 索引</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">全文搜索语法</title>
    <id>https://www.snowji.cn/databases/es/match-query/</id>
    <link href="https://www.snowji.cn/databases/es/match-query/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="全文搜索语法"> 全文搜索语法</h1>
<h2 id="前言"> 前言</h2>
<p>ES 在写入数据的时候，会先使用分词器把文本数据进行分词（比如 <code>hello world</code> -&gt; <code>hello</code> 和 <code>world</code>），并且统计每个词语出现的次数等信息</p>
<p>当我们检索文本数据（比如查询 <code>hello java</code>）的时候，会使用同样的分词器对检索内容进行分词，然后与文本内容匹配，根据统计信息给每个词语打分，最后根据公式算出相关性评分（内容的相似性），并且返回相关性最高的 TopN 个文档给用户</p>
<p>这种检索方式就是全文搜索，它就跟使用百度搜索一下，当我们在查询一些文本内容的时候一般不会做精确匹配，一来性能开销大，二来实际意义不大，正所谓吃力不讨好</p>
<p>ES 支持全文搜索的 API 主要有以下几个：</p>
<ul>
<li><strong>match</strong>：匹配查询可以处理全文本、精确字段（日期、数字等）</li>
<li><strong>match phrase</strong>：短语匹配会将检索内容分词，这些词语必须全部出现在被检索内容中，并且顺序必须一致，默认情况下这些词都必须连续</li>
<li><strong>match phrase prefix</strong>：与 match phrase 类似，但最后一个词项会作为前缀，并且匹配这个词项开头的任何词语</li>
<li><strong>multi match</strong>：通过 multi match 可以在多个字段上执行相同的查询语句</li>
</ul>
<h2 id="match-匹配查询"> match（匹配查询）</h2>
<h3 id="match-all"> match all</h3>
<p>match all 是我最常见使用的 API，用于查询目标 index 的大体数据结构（有哪些字段）：</p>
<div><pre><code><span># 匹配所有文档，如果不指定 from size 则在 Kibana 中默认返回前十条</span>
POST books/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"match_all"</span><span>:</span> <span>{</span><span>}</span>
  <span>}</span>,
  <span>"from"</span><span>:</span> <span>0</span>,
  <span>"size"</span><span>:</span> <span>100</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><pre><code><span># 按时间倒叙查询</span>
POST books/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"match_all"</span><span>:</span> <span>{</span><span>}</span>
  <span>}</span>,
  <span>"sort"</span><span>:</span> <span>[</span>
    <span>{</span>
      <span>"@timestamp"</span><span>:</span> <span>{</span>
        <span>"order"</span><span>:</span> <span>"desc"</span>
      <span>}</span>
    <span>}</span>
  <span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="匹配字段"> 匹配字段</h3>
<p>可以通过指定字段名和字段值，使用 match 进行一次全文本字段的查询：</p>
<div><pre><code><span># 匹配查询</span>
POST books/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"match"</span><span>:</span> <span>{</span>
      <span>"name"</span><span>:</span> <span>"linux architecture"</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>在进行全文本字段检索的时候，match 这个 API 提供了 <code>operator</code> 和 <code>minimum_should_match</code> 参数：</p>
<ul>
<li><strong><code>operator</code></strong>：参数值可以为 <code>or</code> 或者 <code>and</code> 来控制检索词项间的关系默认值为 <code>or</code>，表示被分词后，只要含有部分词项的文档都可以匹配上</li>
<li><strong><code>minimum_should_match</code></strong>：可以指定词项的最少匹配个数，其值可以指定为某个具体的数字，但因为我们无法预估检索内容的词项数量，一般将其设置为一个百分比</li>
</ul>
<div><pre><code><span># 匹配查询，表示只要含有下述四个词项中的三个，就可以匹配上</span>
POST books/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"match"</span><span>:</span> <span>{</span>
      <span>"name"</span><span>:</span> <span>{</span>
        <span>"query"</span><span>:</span> <span>"Dive linux kernea architecture"</span>,
        <span>"operator"</span><span>:</span> <span>"or"</span>,
        <span>"minimum_should_match"</span><span>:</span> <span>"75%"</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>除了处理全文本外，我们还可以使用 match 查询包含精确字段的文档：</p>
<div><pre><code>POST books/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"match"</span><span>:</span> <span>{</span>
      <span>"date"</span><span>:</span> <span>"2010-06-01"</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="match-phrase-短语匹配"> match phrase（短语匹配）</h2>
<h3 id="匹配完整短语"> 匹配完整短语</h3>
<p>短语匹配会将检索内容进行分词，这些词语必须全部出现在被检索内容中，并且顺序必须一致，默认情况下这些词都必须连续</p>
<div><pre><code><span># 短语匹配</span>
POST books/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"match_phrase"</span><span>:</span> <span>{</span>
      <span>"name"</span><span>:</span> <span>"linux architecture"</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="slop-参数"> slop 参数</h3>
<p>上述查询语法只能查询出 <code>name</code> 中带有 <code>linux architecture</code> 短语的文档，但无法查询出 <code>Linux kernel architecture</code>，因为当中隔了一个词项</p>
<p>这个时候可以使用 <code>slop</code> 参数，这个参数默认是 <code>0</code>，表示移动次数</p>
<blockquote>
<ul>
<li>比如文档中是 <code>You know, for search.</code></li>
<li>搜索 <code>you search</code> （有间隔词项）时，需要把 <code>search</code> 往后移动 2 个词，所以 slop 至少为 2 才能匹配</li>
<li>搜索 <code>know you时</code>（顺序不一致），把搜索词中的 <code>know</code> 往后移动 1 位，把 <code>you</code> 往前移动1位（移动后变成 <code>you know</code>），需要移动 2 次，所以 slop 为2时可以匹配到</li>
</ul>
</blockquote>
<p>那么用 slop 改写上面的语法，使得搜索 <code>linux architecture</code> 时可以查询出值为 <code>Linux kernel architecture</code> 的文档：</p>
<div><pre><code><span># match_phrase 使用 slop</span>
POST books/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"match_phrase"</span><span>:</span> <span>{</span>
      <span>"name"</span><span>:</span> <span>{</span>
        <span>"query"</span><span>:</span> <span>"linux architecture"</span>,
        <span>"slop"</span><span>:</span> <span>1</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="match-phrase-prefix-短语前缀匹配"> match phrase prefix（短语前缀匹配）</h2>
<h3 id="短语前缀匹配"> 短语前缀匹配</h3>
<p>match phrase prefix 与 match phrase 类似，但最后一个词项会作为前缀，并且匹配这个词项开头的任何词语</p>
<p>可以使用 <code>max_expansions</code> 参数来控制最后一个词项的匹配数量，此参数默认值为 <code>50</code></p>
<p>下面这个例子可以匹配到 <code>name</code> 中含有 <code>linux kernea</code>、<code>linux kerneb</code> 等短语的文档</p>
<div><pre><code><span># 匹配以 "linux kerne" 开头的短语</span>
POST books/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"match_phrase_prefix"</span><span>:</span> <span>{</span>
      <span>"name"</span><span>:</span> <span>"linux kerne"</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="限制返回文档数"> 限制返回文档数</h3>
<p>下面这个例子中限制了最后一个词项的通配匹配个数为 <code>2</code>，因为 <strong><code>max_expansions</code> 参数是分片级别的</strong>，也就是当前规定了每个分片最多匹配 2 个文档，如果有 3 个分片的话，最多返回 6 个匹配的文档</p>
<div><pre><code><span># 匹配以 "linux kerne" 开头的短语，最多匹配 2 个</span>
POST books/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"match_phrase_prefix"</span><span>:</span> <span>{</span>
      <span>"name"</span><span>:</span> <span>{</span>
        <span>"query"</span><span>:</span> <span>"linux kern"</span>,
         <span>"max_expansions"</span><span>:</span> <span>2</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>一般来说，<code>match_phrase_prefix</code> 可以实现比较粗糙的自动建议功能，但要实现自动建议的功能，可以使用 Suggest API（后面再单独介绍）</p>
<h2 id="multi-match"> multi match</h2>
<h3 id="多字段查询"> 多字段查询</h3>
<p>multi-match 构建在 match 查询的基础上，可以允许在多个字段上执行相同的查询</p>
<div><pre><code><span># multi match API</span>
GET /books/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"multi_match"</span><span>:</span> <span>{</span>
      <span>"query"</span><span>:</span> <span>"linux architecture"</span>,
      <span>"fields"</span><span>:</span> <span>[</span><span>"nam*"</span>, <span>"intro^2"</span><span>]</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><code>fields</code> 参数是一个列表，里面的元素是需要查询的字段名字<code>fields</code> 中的值既可以支持以通配符方式匹配文档的字段，又可以支持提升字段的权重</p>
<ul>
<li>如 <code>nam*</code> 就是使用了通配符匹配的方式，其可以匹配到 <code>name</code> 字段</li>
<li>而 <code>intro^2</code> 就是对 <code>intro</code> 这个字段的相关性评分乘以 2，其他字段不变</li>
</ul>
<h3 id="设置计分方式"> 设置计分方式</h3>
<p>multi-match 还提供了多种类型来设置其执行的方式：</p>
<ul>
<li><strong><code>best_fields</code></strong>：默认的类型，会执行 match 查询并且将所有与查询匹配的文档作为结果返回，但是只使用评分最高的字段的评分来作为评分结果返回</li>
<li><strong><code>most_fields</code></strong>：会执行 match 查询并且将所有与查询匹配的文档作为结果返回，并将所有匹配字段的评分加起来作为评分结果</li>
<li><strong><code>phrase</code></strong>：在指定的每个字段上均执行 <code>match_phrase</code> 查询，并将最佳匹配字段的评分作为结果返回</li>
<li><strong><code>phrase_prefix</code></strong>：在指定的每个字段上均执行 <code>match_phrase_prefix</code> 查询，并将最佳匹配字段的评分作为结果返回</li>
<li><strong><code>cross_fields</code></strong>：它将所有字段当成一个大字段，并在每个字段中查找每个词例如当需要查询英文人名的时候，可以将名和姓两个字段组合起来当作全名来查询</li>
<li><strong><code>bool_prefix</code></strong>：在每个字段上创建一个 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/query-dsl-match-bool-prefix-query.html" target="_blank" rel="noopener noreferrer"><code>match_bool_prefix</code></a> 查询，并且合并每个字段的评分作为评分结果</li>
</ul>
<p>上述的这几种类型，无非就是设置算分的方式和匹配文档的方式不一样，可以使用 <code>type</code> 字段来指定这些类型，以 <code>best_fields</code> 为例，示例如下：</p>
<div><pre><code><span># multi match API</span>
<span># 此查询将会在 books 索引中查找 "name" 字段</span>
<span># 包含 "linux " 或者 "architecture" 的文档</span>
<span># 或者在 "intro" 字段中包含 "linux " 或者 "architecture" 的文档</span>
GET /books/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"multi_match"</span><span>:</span> <span>{</span>
      <span>"query"</span><span>:</span> <span>"linux architecture"</span>,
      <span>"fields"</span><span>:</span> <span>[</span><span>"name"</span>, <span>"intro"</span><span>]</span>,
      <span>"type"</span><span>:</span> <span>"best_fields"</span>,  <span># 指定对应的类型</span>
      <span>"tie_breaker"</span><span>:</span> <span>0.3</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><blockquote>
<p>关于 <code>tie_breaker</code>：</p>
<p>一般来说文档的相关性算分是由得分最高的字段来决定的，但当指定 <code>tie_breaker</code> 的时候，算分结果将会由以下算法来决定：</p>
<ul>
<li>令算分最高的字段的得分为 s1</li>
<li>令其他匹配的字段的算分 * <code>tie_breaker</code> 的和为 s2</li>
<li>最终算分为：s1 + s2</li>
</ul>
</blockquote>
<p><code>tie_breaker</code> 的取值范围为：<code>[0.0, 1.0]</code></p>
<ul>
<li>当其为 0.0 的时候，按照上述公式来计算，表示使用最佳匹配字段的得分作为相关性算分</li>
<li>当其为 1.0 的时候，表示所有字段的得分同等重要</li>
<li>当其在 0.0 到 1.0 之间的时候，代表其他字段的得分也需要参与到总得分的计算当中去</li>
</ul>
<p>通俗来说就是其他字段可以使用 <code>tie_breaker</code> 来进行「维权」</p>
<h2 id="参考文档"> 参考文档</h2>
<ul>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/query-dsl-multi-match-query.html" target="_blank" rel="noopener noreferrer">multi-match</a></li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">文档基本操作</title>
    <id>https://www.snowji.cn/databases/es/document-crud/</id>
    <link href="https://www.snowji.cn/databases/es/document-crud/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="文档基本操作"> 文档基本操作</h1>
<blockquote>
<p>在 Kibana 的 Dev Tools 中，以在线书店业务为例，展示 DSL 语法</p>
</blockquote>
<h2 id="索引管理"> 索引管理</h2>
<p>文档是存在于索引里面的，所以要先创建一个索引并定义其 Mapping（就像使用 MySQL 数据库插入数据前，肯定要先创建表）</p>
<p>现在定义如下 Mapping，并且创建索引（主要字段：书本的 ID、名字、作者、简介）：</p>
<div><pre><code><span># 创建 books 索引</span>
PUT books
<span>{</span>
  <span>"mappings"</span><span>:</span> <span>{</span>
    <span>"properties"</span><span>:</span> <span>{</span>
        <span>"book_id"</span><span>:</span> <span>{</span>
          <span>"type"</span><span>:</span> <span>"keyword"</span>
        <span>}</span>,
        <span>"name"</span><span>:</span> <span>{</span>
          <span>"type"</span><span>:</span> <span>"text"</span>
        <span>}</span>,
        <span>"author"</span><span>:</span> <span>{</span>
          <span>"type"</span><span>:</span> <span>"keyword"</span>
        <span>}</span>,
        <span>"intro"</span><span>:</span> <span>{</span>
          <span>"type"</span><span>:</span> <span>"text"</span>
        <span>}</span>
      <span>}</span>
  <span>}</span>,
  <span>"settings"</span><span>:</span> <span>{</span>
    <span>"number_of_shards"</span><span>:</span> <span>3</span>,
    <span>"number_of_replicas"</span><span>:</span> <span>1</span>
  <span>}</span>
<span>}</span>

<span># 返回结果</span>
<span>{</span>
  <span>"acknowledged"</span> <span>:</span> true,
  <span>"shards_acknowledged"</span> <span>:</span> true,
  <span>"index"</span> <span>:</span> <span>"books"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>上述操作创建了 books 索引，它包含 <code>book_id</code>（书本 ID）、<code>name</code>（书本名字）、<code>author</code>（作者）、<code>intro</code>（简介）四个字段其中 books 索引还有 3 个分片和 1 个副本备份</p>
<p>如果之前已经创建过 books 索引的话，这里再次创建会报错，此时需要先将之前的索引删除，然后再重新创建在 Kibana 执行以下示例可以删除索引：</p>
<div><pre><code><span># 删除索引 books</span>
DELETE books

<span># 返回结果</span>
<span>{</span>
  <span>"acknowledged"</span> <span>:</span> <span>true</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="新建文档"> 新建文档</h2>
<p>ES 提供了两种创建文档的方式，一种是使用 Index API 索引文档，一种是使用 Create API 创建文档</p>
<h3 id="使用-index-api-索引文档"> 使用 Index API 索引文档</h3>
<div><pre><code><span># 使用 Index API 索引文档</span>
PUT books/_doc/1
<span>{</span>
  <span>"book_id"</span><span>:</span> <span>"4ee82462"</span>,
  <span>"name"</span><span>:</span> <span>"深入Linux内核架构"</span>,
  <span>"author"</span><span>:</span> <span>"Wolfgang Mauerer"</span>,
  <span>"intro"</span><span>:</span> <span>"内容全面深入，领略linux内核的无限风光"</span>
<span>}</span>

<span># 结果</span>
<span>{</span>
  <span>"_index"</span> <span>:</span> <span>"books"</span>,
  <span>"_type"</span> <span>:</span> <span>"_doc"</span>,
  <span>"_id"</span> <span>:</span> <span>"1"</span>,
  <span>"_version"</span> <span>:</span> <span>1</span>,
  <span>"result"</span> <span>:</span> <span>"created"</span>,
  <span>"_shards"</span> <span>:</span> <span>{</span>
    <span>"total"</span> <span>:</span> <span>2</span>,
    <span>"successful"</span> <span>:</span> <span>2</span>,
    <span>"failed"</span> <span>:</span> <span>0</span>
  <span>}</span>,
  <span>"_seq_no"</span> <span>:</span> <span>0</span>,
  <span>"_primary_term"</span> <span>:</span> <span>1</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>索引一个文档比较简单，将 Mapping 中对应的字段做成 Json Object 对应的 Key 即可，并且上面的例子中我们指定文档 ID 为 1需要说明的是，在 ES 7.0 版本后 <code>type</code> 统一为 <code>_doc</code></p>
<p>如果索引的文档已经存在，比如在不改变文档 ID 的情况下多次执行上面的索引文档的语句，系统并不会报错，而是将返回结果中 <code>_version</code> 字段的值自加</p>
<p>那是因为在索引一个文档的时候，如果文档 ID 已经存在，会先删除旧文档，然后再写入新文档的内容，并且增加文档版本号</p>
<h3 id="使用-create-api-创建文档"> 使用 Create API 创建文档</h3>
<p>使用 Create API 创建文档有两种写法：PUT 和 POST 方式，其示例分别如下：</p>
<p>使用 PUT 的方式创建文档需要指定文档的 ID，如果文档 ID 已经存在，则返回 http 状态码为 409 的错误</p>
<div><pre><code><span># 使用 PUT 的方式创建文档</span>
PUT books/_create/2
<span>{</span>
  <span>"book_id"</span><span>:</span> <span>"4ee82463"</span>,
  <span>"name"</span><span>:</span> <span>"时间简史"</span>,
  <span>"author"</span><span>:</span> <span>"史蒂芬霍金"</span>,
  <span>"intro"</span><span>:</span> <span>"探索时间和空间核心秘密的引人入胜的故事"</span>
<span>}</span>

<span># PUT 方式返回的结果</span>
<span>{</span>
  <span>"_index"</span> <span>:</span> <span>"books"</span>,
  <span>"_type"</span> <span>:</span> <span>"_doc"</span>,
  <span>"_id"</span> <span>:</span> <span>"2"</span>,
  <span>"_version"</span> <span>:</span> <span>1</span>
  <span>..</span><span>..</span><span>..</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>使用 POST 的方式创建文档时候，则不需要指定文档 ID，系统会自动创建</p>
<div><pre><code><span># 使用 POST 的方式，不需要指定文档 ID，系统自动生成</span>
POST books/_doc
<span>{</span>
  <span>"book_id"</span><span>:</span> <span>"4ee82464"</span>,
  <span>"name"</span><span>:</span> <span>"时间简史（插画版）"</span>,
  <span>"author"</span><span>:</span> <span>"史蒂芬霍金"</span>,
  <span>"intro"</span><span>:</span> <span>"用精美的插画带你探索时间和空间的核心秘密"</span>
<span>}</span>

<span># POST 方式返回的结果</span>
<span>{</span>
  <span>"_index"</span> <span>:</span> <span>"books"</span>,
  <span>"_type"</span> <span>:</span> <span>"_doc"</span>,
  <span>"_id"</span> <span>:</span> <span>"LfwVtH0BxOuNtEd4yM4F"</span>,
  <span>"_version"</span> <span>:</span> <span>1</span>
  <span>..</span><span>..</span><span>..</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id="总结三种创建文档方式"> 总结三种创建文档方式</h3>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">语句</th>
<th style="text-align:left">特性描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><code>PUT books/_doc/1</code></td>
<td style="text-align:left">使用 Index API 索引文档，如果文档存在，会先删除然后再写入，即有覆盖原内容的功能</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><code>PUT books/_create/2</code></td>
<td style="text-align:left">Create API 中使用 PUT 的方式创建文档，需要指定文档 ID如果文档已经存在，<br>则返回 http 409 错误</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><code>POST books/_doc</code></td>
<td style="text-align:left">Create API 中使用 POST 的方式，不需要指定文档 ID，系统自动生成</td>
</tr>
</tbody>
</table>
<ul>
<li>如果有更新文档内容的需求，应该使用第一种方式</li>
<li>如果写入文档时有唯一性校验需求的话，应该使用第二种方式</li>
<li>如果需要系统为你创建文档 ID，应该使用第三种方式</li>
</ul>
<p>相对于第一种方式来说，第三种方式写入的效率会更高，因为不需要在库里查询文档是否已经存在，并且进行后续的删除工作</p>
<h2 id="获取文档"> 获取文档</h2>
<p>可以使用 ES 提供的 GET API 来获取文档内容，获取文档有 2 种情况，一种是只获取一个文档内容，另一种是同时获取多个文档的内容</p>
<h3 id="使用-get-api-获取单个文档"> 使用 GET API 获取单个文档</h3>
<p>通过文档的 ID 获取文档的信息时可以使用 GET API 来实现，其示例如下：</p>
<div><pre><code><span># 使用 GET API 获取单个文档的内容</span>
GET books/_doc/1

<span># 结果</span>
<span>{</span>
  <span>"_index"</span> <span>:</span> <span>"books"</span>,
  <span>"_type"</span> <span>:</span> <span>"_doc"</span>,
  <span>"_id"</span> <span>:</span> <span>"1"</span>,
  <span>"_version"</span> <span>:</span> <span>1</span>,
  <span>"_seq_no"</span> <span>:</span> <span>0</span>,
  <span>"_primary_term"</span> <span>:</span> <span>1</span>,
  <span>"found"</span> <span>:</span> true,
  <span>"_source"</span> <span>:</span> <span>{</span>
    <span>"book_id"</span> <span>:</span> <span>"4ee82462"</span>,
    <span>"name"</span> <span>:</span> <span>"深入Linux内核架构"</span>,
    <span>"author"</span> <span>:</span> <span>"Wolfgang Mauerer"</span>,
    <span>"intro"</span> <span>:</span> <span>"内容全面深入，领略linux内核的无限风光"</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>如果获取如果成功，文档的原生内容保存在 <code>_source</code> 字段中，其他字段是这个文档的元数据</p>
<p>GET API 提供了多个参数，更多的信息可以参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/docs-get.html" target="_blank" rel="noopener noreferrer">官方文档</a>，下面是几个比较常用的：</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">简介</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>preference</code></td>
<td style="text-align:left">默认的情况下，GET API 会从多个副本中随机挑选一个，设置 <code>preference</code> 参数可以控制 GET 请求被路由到哪个分片上执行</td>
</tr>
<tr>
<td style="text-align:left"><code>realtime</code></td>
<td style="text-align:left">控制 GET 请求是实时的还是准实时的，默认为 <code>true</code></td>
</tr>
<tr>
<td style="text-align:left"><code>refresh</code></td>
<td style="text-align:left">是否在执行 GET 操作前执行 <code>refresh</code>（默认的情况下新写入的数据需要一秒后才能被搜索到），默认为 <code>false</code></td>
</tr>
<tr>
<td style="text-align:left"><code>routing</code></td>
<td style="text-align:left">自定义 routing key</td>
</tr>
<tr>
<td style="text-align:left"><code>stored_fields</code></td>
<td style="text-align:left">返回在 Mapping 中 <code>store</code> 设置为 <code>true</code> 的字段，而不是 <code>_source</code>默认为 <code>false</code></td>
</tr>
<tr>
<td style="text-align:left"><code>_source</code></td>
<td style="text-align:left">指定是否返回 <code>_source</code> 的字段，或者设置某些需要返回的字段</td>
</tr>
<tr>
<td style="text-align:left"><code>_source_excludes</code></td>
<td style="text-align:left">不返回哪些字段，逗号分割的字符串列表如果 <code>_source</code> 设置为 <code>false</code>，此参数会被忽略</td>
</tr>
<tr>
<td style="text-align:left"><code>_source_includes</code></td>
<td style="text-align:left">返回哪些字段，逗号分割的字符串列表如果 <code>_source</code> 设置为 <code>false</code>，此参数会被忽略</td>
</tr>
<tr>
<td style="text-align:left"><code>version</code></td>
<td style="text-align:left">指定版本号，如果获取的文档的版本号与指定的不一样，返回 http 409</td>
</tr>
</tbody>
</table>
<h3 id="使用-mget-api-获取多个文档"> 使用 MGET API 获取多个文档</h3>
<p>当需要通过多个文档 ID 同时获取它们的信息时，可以使用 GET API 发起多个请求，但效率比较低下这时可以使用 ES 提供的 MGET API 来解决这个需求</p>
<p>MGET API 的请求格式有 3 种，其示例如下：</p>
<div><pre><code><span># 1：在 body 中指定 index</span>
GET /_mget
<span>{</span>
  <span>"docs"</span><span>:</span> <span>[</span>
    <span>{</span> <span>"_index"</span><span>:</span> <span>"books"</span>, <span>"_id"</span><span>:</span> <span>"1"</span> <span>}</span>,
    <span>{</span> <span>"_index"</span><span>:</span> <span>"books"</span>, <span>"_id"</span><span>:</span> <span>"2"</span> <span>}</span>
  <span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span># 2：直接指定 index</span>
GET /books/_doc/_mget
<span>{</span>
  <span>"docs"</span><span>:</span> <span>[</span>
    <span>{</span> <span>"_id"</span><span>:</span> <span>"1"</span> <span>}</span>,
    <span>{</span> <span>"_id"</span><span>:</span> <span>"2"</span> <span>}</span>
  <span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span># 3：也可以简写为一下例子</span>
GET /books/_mget
<span>{</span>
  <span>"ids"</span> <span>:</span> <span>[</span><span>"1"</span>, <span>"2"</span><span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span># 结果</span>
<span>{</span>
  <span>"docs"</span> <span>:</span> <span>[</span>
    <span>{</span>
      <span>"found"</span> <span>:</span> true,
      <span>"_source"</span> <span>:</span> <span>{</span>
        <span>"book_id"</span> <span>:</span> <span>"4ee82462"</span>,
        <span>"name"</span> <span>:</span> <span>"深入Linux内核架构"</span>
        <span>..</span><span>..</span><span>..</span>
      <span>}</span>
    <span>}</span>,
    <span>{</span>
      <span>"found"</span> <span>:</span> true,
      <span>"_source"</span> <span>:</span> <span>{</span>
        <span>"book_id"</span> <span>:</span> <span>"4ee82463"</span>,
        <span>"name"</span> <span>:</span> <span>"时间简史"</span>,
        <span>..</span><span>..</span><span>..</span>
      <span>}</span>
    <span>}</span>
  <span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>如上示例，如果在 body 中指定 index，可以获取多个索引中的文档数据，比较灵活而使用直接指定 index 的方式只能获取指定索引中的文档更多的 MGET API 使用例子可以参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/docs-multi-get.html" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<p>如果对应的文档找不到，<code>found</code> 字段为 <code>false</code></p>
<h2 id="更新文档"> 更新文档</h2>
<p>ES 提供了 Update API 来更新文档信息，更新一个文档，需要指定文档的 ID 和需要更新的字段与其对应的值Update API 使用如下：</p>
<div><pre><code><span># 更新文档</span>
POST books/_update/2
<span>{</span>
  <span>"doc"</span><span>:</span> <span>{</span>
    <span>"name"</span><span>:</span><span>"时间简史（视频版）"</span>,
    <span>"intro"</span><span>:</span> <span>"探索时间和空间核心秘密的引人入胜的视频故事"</span>
  <span>}</span>
<span>}</span>

<span># 结果</span>
<span>{</span>
  <span>"_index"</span> <span>:</span> <span>"books"</span>,
  <span>"_type"</span> <span>:</span> <span>"_doc"</span>,
  <span>"_id"</span> <span>:</span> <span>"2"</span>,
  <span>"_version"</span> <span>:</span> <span>3</span>,
  <span>"result"</span> <span>:</span> <span>"updated"</span>,
  <span>..</span><span>..</span><span>..</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>更新文档后，版本号会增加，<code>result</code> 字段为 <code>updated</code></p>
<p>前面提到的，索引文档的方式也有更新数据的效果，那它跟文档更新接口有啥区别呢？</p>
<ul>
<li>索引文档的更新效果是先删除数据，然后再写入新数据所以<strong>索引文档的方式会覆盖旧的数据，使其无法实现只更新某些字段的需求</strong></li>
</ul>
<h2 id="删除文档"> 删除文档</h2>
<p>ES 提供了 Delete API 来删除一个文档，删除一个文档是非常简单的，只需要指定索引和文档 ID 即可Delete API 使用如下：</p>
<div><pre><code><span># 删除 id 为 2 的文档</span>
DELETE books/_doc/2

<span># 结果</span>
<span>{</span>
  <span>"_index"</span> <span>:</span> <span>"books"</span>,
  <span>"_type"</span> <span>:</span> <span>"_doc"</span>,
  <span>"_id"</span> <span>:</span> <span>"2"</span>,
  <span>"_version"</span> <span>:</span> <span>4</span>,
  <span>"result"</span> <span>:</span> <span>"deleted"</span>,
  <span>..</span><span>..</span><span>..</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>除了指定文档 ID 进行文档删除外，我们还可以使用 Delete By Query API 进行查询删除</p>
<div><pre><code><span># 使用 Delete By Query API 删除文档</span>
POST /books/_delete_by_query
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"term"</span><span>:</span> <span>{</span>
      <span>"book_id"</span><span>:</span> <span>"4ee82462"</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

<span># 结果</span>
<span>{</span>
  
  <span>"total"</span> <span>:</span> <span>1</span>,
  <span>"deleted"</span> <span>:</span> <span>1</span>,
  <span>..</span><span>..</span><span>..</span>
  <span>"failures"</span> <span>:</span> <span>[</span> <span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>如上示例，将删除掉所有满足查询条件的内容在返回结果中，<code>deleted</code> 字段为 <code>1</code>，即删除了 <code>1</code> 个文档</p>
<h2 id="批量操作文档"> 批量操作文档</h2>
<p>当我们需要写入多个文档的时候，如果每写一个文档就发起一个请求的话，多少有点浪费这个时候我们可以使用 Bulk API 来批量处理文档</p>
<p>Bulk API 支持在一次调用中操作不同的索引，使用时可以在 Body 中指定索引也可以在 URI 中指定索引而且还可以同时支持 4 种类型的操作：</p>
<ul>
<li>Index</li>
<li>Create</li>
<li>Update</li>
<li>Delete</li>
</ul>
<p>Bulk API 的格式是用换行符分隔 JSON 的结构，第一行指定操作类型和元数据（索引、文档 id 等），紧接着的一行是这个操作的内容（文档数据，如果有的话像简单的删除就没有），其格式如下：</p>
<div><pre><code>POST _bulk
<span># 第一行指定操作类型和元数据（索引、文档id等）</span>
<span>{</span> <span>"index"</span> <span>:</span> <span>{</span> <span>"_index"</span> <span>:</span> <span>"books"</span>, <span>"_id"</span> <span>:</span> <span>"1"</span> <span>}</span> <span>}</span> 
<span># 紧接着的一行是这个操作的内容（文档数据，如果有的话像简单的删除就没有）</span>
<span>{</span> <span>"book_id"</span><span>:</span> <span>"4ee82462"</span>,<span>"name"</span><span>:</span> <span>"深入Linux内核架构"</span>, <span>..</span><span>..</span><span>..</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>下面示例是在 Bulk API 中同时使用多种操作类型的例子：</p>
<div><pre><code><span># 在 Bulk API 中同时使用多种操作类型的实例</span>
POST _bulk
<span>{</span> <span>"index"</span> <span>:</span> <span>{</span> <span>"_index"</span> <span>:</span> <span>"books"</span>, <span>"_id"</span> <span>:</span> <span>"1"</span> <span>}</span> <span>}</span>
<span>{</span> <span>"book_id"</span><span>:</span> <span>"4ee82462"</span>,<span>"name"</span><span>:</span> <span>"深入Linux内核架构"</span>,<span>"author"</span><span>:</span> <span>"Wolfgang Mauerer"</span>,<span>"intro"</span><span>:</span> <span>"内容全面深入，领略linux内核的无限风光"</span> <span>}</span>
<span>{</span> <span>"delete"</span> <span>:</span> <span>{</span> <span>"_index"</span> <span>:</span> <span>"books"</span>, <span>"_id"</span> <span>:</span> <span>"2"</span> <span>}</span> <span>}</span>
<span>{</span> <span>"create"</span> <span>:</span> <span>{</span> <span>"_index"</span> <span>:</span> <span>"books"</span>, <span>"_id"</span> <span>:</span> <span>"3"</span> <span>}</span> <span>}</span>
<span>{</span> <span>"book_id"</span><span>:</span> <span>"4ee82464"</span>,<span>"name"</span><span>:</span> <span>"深入Linux内核架构第三版"</span>,<span>"author"</span><span>:</span> <span>"Wolfgang Mauerer"</span>,<span>"intro"</span><span>:</span> <span>"内容全面深入，再次领略linux内核的无限风光"</span> <span>}</span>
<span>{</span> <span>"update"</span> <span>:</span> <span>{</span><span>"_index"</span> <span>:</span> <span>"books"</span>, <span>"_id"</span> <span>:</span> <span>"4"</span><span>}</span> <span>}</span> <span># 指定操作类型、索引、文档 id</span>
<span>{</span> <span>"doc"</span> <span>:</span> <span>{</span><span>"intro"</span> <span>:</span> <span>"书本的内容非常好，值得一看"</span><span>}</span> <span>}</span> <span># 指定文档内容</span>

<span># 结果</span>
<span>{</span>
  <span>"items"</span> <span>:</span> <span>[</span>
    <span>{</span>
      <span>"index"</span> <span>:</span> <span>{</span>
        <span>"_id"</span> <span>:</span> <span>"1"</span>,
        <span>"result"</span> <span>:</span> <span>"created"</span>,
        <span>..</span><span>..</span><span>..</span>
      <span>}</span>
    <span>}</span>,
    <span>{</span>
      <span>"delete"</span> <span>:</span> <span>{</span>
        <span>"_id"</span> <span>:</span> <span>"2"</span>,
        <span>"result"</span> <span>:</span> <span>"deleted"</span>,
        <span>..</span><span>..</span><span>..</span>
      <span>}</span>
    <span>}</span>,
    <span>{</span>
      <span>"create"</span> <span>:</span> <span>{</span>
        <span>"_id"</span> <span>:</span> <span>"3"</span>,
        <span>"result"</span> <span>:</span> <span>"created"</span>,
        <span>..</span><span>..</span><span>..</span>
      <span>}</span>
    <span>}</span>,
    <span>{</span>
      <span>"update"</span> <span>:</span> <span>{</span>
        <span>"_id"</span> <span>:</span> <span>"4"</span>,
        <span>"status"</span> <span>:</span> <span>404</span>,
        <span>..</span><span>..</span><span>..</span>
      <span>}</span>
    <span>}</span>
  <span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><p>因为一个请求中有多个操作，所以返回结果中会对每个操作有相应的执行结果如果其中一条操作失败，是不会影响其他操作的执行</p>
<p>更详细 Bulk API 使用方式，可以参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/docs-bulk.html" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<h2 id="参考资料"> 参考资料</h2>
<ul>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/index.html" target="_blank" rel="noopener noreferrer">官方文档</a></li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">索引管理 API</title>
    <id>https://www.snowji.cn/databases/es/index-manage-apis/</id>
    <link href="https://www.snowji.cn/databases/es/index-manage-apis/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="索引管理-api"> 索引管理 API</h1>
<h2 id="简介"> 简介</h2>
<p>索引管理的 API 提供了单个索引的管理（创建和删除）、别名管理、索引设置、定义 Mapping、Reindex、索引模板、索引收缩等功能</p>
<h2 id="单个索引的管理"> 单个索引的管理</h2>
<h3 id="创建索引"> 创建索引</h3>
<div><pre><code><span># 创建索引的最基本形式，没有指定 Mapping</span>
PUT test_index

<span># 创建带 setting 和 Mapping 的 books 索引</span>
PUT books
<span>{</span>
  <span>"mappings"</span><span>:</span> <span>{</span>
    <span>"properties"</span><span>:</span> <span>{</span>
      <span>"book_id"</span><span>:</span> <span>{</span>
        <span>"type"</span><span>:</span> <span>"keyword"</span>
      <span>}</span>,
      <span>"name"</span><span>:</span> <span>{</span>
        <span>"type"</span><span>:</span> <span>"text"</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>,
  <span>"settings"</span><span>:</span> <span>{</span>
    <span>"number_of_shards"</span><span>:</span> <span>3</span>,  <span># 指定了 3 个主分片</span>
    <span>"number_of_replicas"</span><span>:</span> <span>1</span> <span># 指定了一个副本分片</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>创建索引的限制有以下几个：</p>
<ul>
<li>只能是小写字母</li>
<li>不能包含 <code>\</code>，<code>/</code>，<code>*</code>，<code>?</code>，<code>&quot;</code>，<code>&lt;</code>，<code>&gt;</code>，<code>|</code>，(空格)，<code>,</code>，<code>#</code> 等字符</li>
<li>7.0 之后的版本不能再包含 <code>:</code>（冒号）字符了</li>
<li>不能以 <code>-</code>，<code>_</code>，<code>+</code> 开头名字不能是 <code>.</code> 或者 <code>..</code></li>
<li>不能长于 255 字节需要注意的是某些字符是需要多个字节来表示的</li>
</ul>
<h3 id="删除索引"> 删除索引</h3>
<div><pre><code><span># 删除一个索引</span>
DELETE test_index
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="索引别名管理"> 索引别名管理</h2>
<p>当业务需求发生改变，而不得不创建一个新索引来代替旧索引的时候，我们必须更新应用服务（后端代码）的索引名称，使用索引别名可以解决这个问题假设应用中用 <code>test</code> 别名指向旧索引 <code>test_old</code>，在创建新索引 <code>test_new</code> 并将 <code>test_old</code> 的数据迁移到 <code>test_new</code> 后，我们可以将 <code>test</code> 索引别名指向 <code>test_new</code>，这样可以做到在新旧索引间的无缝切换</p>
<div style="text-align: center;">
  <img src="./images/index-alias.png" height="300" alt="索引别名 - 以 test 为例">
</div>
<p><strong>别名就是一个索引另外的名字，其就像一个软连接或者快捷方式每个索引可以有多个别名，而不同的索引也可以使用相同的别名，这样使得不同的别名可以适用于不同的情景</strong></p>
<h3 id="别名创建"> 别名创建</h3>
<div><pre><code><span># 为 test1 索引创建了 "alias1" 别名</span>
POST /_aliases
<span>{</span>
  <span>"actions"</span> <span>:</span> <span>[</span>
    <span>{</span> <span>"add"</span> <span>:</span> <span>{</span> <span>"index"</span> <span>:</span> <span>"test1"</span>, <span>"alias"</span> <span>:</span> <span>"alias1"</span> <span>}</span> <span>}</span>
  <span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="别名删除"> 别名删除</h3>
<div><pre><code><span># 删除了索引 test1 的别名 "alias1"</span>
POST /_aliases
<span>{</span>
  <span>"actions"</span> <span>:</span> <span>[</span>
    <span>{</span> <span>"remove"</span> <span>:</span> <span>{</span> <span>"index"</span> <span>:</span> <span>"test1"</span>, <span>"alias"</span> <span>:</span> <span>"alias1"</span> <span>}</span> <span>}</span>
  <span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="别名重命名"> 别名重命名</h3>
<p>别名重命名的操作是先将原先的别名删除了，然后再创建新的别名这操作是原子的，不需担心别名不指向索引的短暂时间</p>
<div><pre><code>POST /_aliases
<span>{</span>
  <span>"actions"</span> <span>:</span> <span>[</span>
    <span>{</span> <span>"remove"</span> <span>:</span> <span>{</span> <span>"index"</span> <span>:</span> <span>"test1"</span>, <span>"alias"</span> <span>:</span> <span>"alias1"</span> <span>}</span> <span>}</span>,
    <span>{</span> <span>"add"</span> <span>:</span> <span>{</span> <span>"index"</span> <span>:</span> <span>"test1"</span>, <span>"alias"</span> <span>:</span> <span>"alias2"</span> <span>}</span> <span>}</span>
  <span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="关联多个索引"> 关联多个索引</h3>
<div><pre><code><span># 将别名 alias1 指向了索引 test1、test2 </span>
POST /_aliases
<span>{</span>
  <span>"actions"</span> <span>:</span> <span>[</span>
    <span>{</span> <span>"add"</span> <span>:</span> <span>{</span> <span>"indices"</span> <span>:</span> <span>[</span><span>"test1"</span>, <span>"test2"</span><span>]</span>, <span>"alias"</span> <span>:</span> <span>"alias1"</span> <span>}</span> <span>}</span>
  <span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>更多的别名使用示例可以参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/indices-aliases.html" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<h2 id="索引设置"> 索引设置</h2>
<p>在创建索引的时候，可以在 <code>&quot;settings&quot;</code> 字段中指定索引的设置<code>number_of_shards</code> 和 <code>number_of_replicas</code> 是索引非常重要的两个配置，设置它们值的示例如下：</p>
<div><pre><code>PUT test_index
<span>{</span>
  <span>"settings"</span><span>:</span> <span>{</span>
    <span>"number_of_shards"</span><span>:</span> <span>3</span>,  <span># 指定了 3 个主分片</span>
    <span>"number_of_replicas"</span><span>:</span> <span>1</span> <span># 指定了一个副本分片</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>也可以动态修改索引的配置，其示例如下：</p>
<div><pre><code>PUT /test_index/_settings
<span>{</span>
  <span>"number_of_replicas"</span><span>:</span> <span>2</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>但要注意的是，<strong><code>number_of_shards</code> 设定后是无法改变的，要修改索引的分片数量可以通过 Reindex API 或者收缩索引的 API 做处理</strong></p>
<h2 id="定义索引的-mapping"> 定义索引的 Mapping</h2>
<p>在创建索引的时候可以设置索引的 Mapping（使用 <code>&quot;mappings&quot;</code> 字段）其示例如下：</p>
<div><pre><code>PUT test_index
<span>{</span>
  <span>"mappings"</span><span>:</span> <span>{</span>
    <span>"properties"</span><span>:</span> <span>{</span>
        <span>"test_id"</span><span>:</span> <span>{</span>
          <span>"type"</span><span>:</span> <span>"keyword"</span>
        <span>}</span>
      <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>如果增加了某些需求，想要增加索引 Mapping 的设置，其示例如下：</p>
<div><pre><code>PUT test_index/_mapping
<span>{</span>
  <span>"properties"</span><span>:</span> <span>{</span>
    <span>"test_name"</span><span>:</span> <span>{</span>
      <span>"type"</span><span>:</span> <span>"keyword"</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>需要注意的是，<strong>在 Mapping 中已经定义好的字段是不能修改的</strong>，如果尝试修改将会返回错误提示</p>
<h2 id="reindex-api"> Reindex API</h2>
<p>对于已经创建过的 Mapping ，既不能修改已经定义过的字段类型，同时也不能改变分片的数量而如果需求上必须要我们修改，就可以使用 Reindex API 来解决这个问题</p>
<p>首先创建一个新的索引，使其 Mapping 等设置满足新的需求，然后将数据从旧的索引中迁移到新的索引具体步骤如下：</p>
<div><pre><code><span># 创建新的索引，并且满足需求</span>
PUT test_index_reindex
<span>{</span>
  <span>"mappings"</span><span>:</span> <span>{</span>
    <span>"properties"</span><span>:</span> <span>{</span>
      <span>"test_id"</span><span>:</span> <span>{</span> <span>"type"</span><span>:</span> <span>"keyword"</span> <span>}</span>,
      <span>"test_name"</span><span>:</span> <span>{</span> <span>"type"</span><span>:</span> <span>"text"</span> <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

<span># 执行 reindex 操作</span>
POST _reindex
<span>{</span>
  <span>"source"</span><span>:</span> <span>{</span> <span>"index"</span><span>:</span> <span>"test_index"</span> <span>}</span>,
  <span>"dest"</span><span>:</span> <span>{</span> <span>"index"</span><span>:</span> <span>"test_index_reindex"</span> <span>}</span>
<span>}</span>

<span># 在迁移数据后的 test_index_reindex 索引中获取数据</span>
GET test_index_reindex/_doc/1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>需要注意的是，如果索引中的数据很多，并且是需要同步返回的情况下，在 Kibana 中执行这个操作可能会发生超时的现象可以使用 <code>wait_for_completion=false</code> 参数来进行异步操作，其示例如下：</p>
<div><pre><code><span># 异步地执行 _reindex</span>
POST _reindex?wait_for_completion<span>=</span>false
<span>{</span>
  <span>"source"</span><span>:</span> <span>{</span> <span>"index"</span><span>:</span> <span>"test_index"</span> <span>}</span>,
  <span>"dest"</span><span>:</span> <span>{</span> <span>"index"</span><span>:</span> <span>"test_index_reindex"</span> <span>}</span>
<span>}</span>

<span># 结果</span>
<span>{</span>
  <span>"task"</span> <span>:</span> <span>"26d0dAjcRYygigd0shfz5w:35995695"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>异步的 reindex 操作返回的结果将会是个 task id，可以使用 Task API 查看这个任务的情况：</p>
<div><pre><code>GET /_tasks/26d0dAjcRYygigd0shfz5w:35995695
</code></pre>
<div><span>1</span><br></div></div><p>Reindex API 还提供很多丰富的参数和操作示例，可以参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/docs-reindex.html" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<h2 id="索引模板"> 索引模板</h2>
<p>可以使用 Index templates 按照一定的规则对新创建的索引进行 Mapping 设定和 Settings 设定需要注意的是，索引模板只在索引被新创建时起作用</p>
<p>创建一个模板：</p>
<div><pre><code>PUT /_index_template/my_tmp1
<span>{</span>
  <span>"index_patterns"</span> <span>:</span> <span>[</span><span>"tmp_*"</span><span>]</span>, <span># 以tmp_ 开头的索引都引用这个模板</span>
  <span>"priority"</span> <span>:</span> <span>1</span>,               <span># 指定优先级, 数值越大优先级越高, 这个模板就越先被应用</span>
  <span>"template"</span><span>:</span> <span>{</span>
    <span>"settings"</span> <span>:</span> <span>{</span>
      <span>"number_of_shards"</span> <span>:</span> <span>3</span>
    <span>}</span>,
    <span>"mappings"</span><span>:</span> <span>{</span>
      <span>"date_detection"</span><span>:</span> <span>false</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="打开和关闭索引"> 打开和关闭索引</h2>
<p>当我们需要执行某些操作的时候，需要关闭索引或者打开索引，可以使用 <code>_close</code> API 和 <code>_open</code> API 来关闭或者打开索引</p>
<p><strong>关闭索引的操作开销很小，并且会阻塞读写操作，关闭后的索引不再允许执行打开状态时的所有操作</strong>关闭和打开一个索引的示例如下：</p>
<div><pre><code><span># 关闭索引</span>
POST /test_index/_close

<span># 打开索引</span>
POST /test_index/_open
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="判断索引是否存在"> 判断索引是否存在</h2>
<p>可以使用 Exists API 来判断一个索引是否存在，其示例如下：</p>
<div><pre><code>HEAD test_index
</code></pre>
<div><span>1</span><br></div></div><p>如果索引存在，那么返回的 HTTP 状态码为 200，不存在的话为 404更多关于 Exists API 的使用示例，可以参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/indices-exists.html" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<h2 id="收缩索引"> 收缩索引</h2>
<p>如果一开始创建的索引其分片太多，可以使用收缩索引的 API 将索引<strong>收缩为具有较少主分片的新索引</strong></p>
<p><strong>收缩后的新索引的主分片数量必须为源索引主分片数量的一个因子</strong>例如，源索引的主分片分配了 12 个，那么收缩后的新索引的主分片数只能为 1、2、3、4、6</p>
<p>在进行索引收缩前需要进行以下操作：</p>
<ul>
<li>源索引必须只读</li>
<li>源索引所有的副本（主分片也行，副分片也行）必须在同一个节点上，也就是在这个节点上必须有这个索引的所有数据，不管分片数据是主分片的还是副分片的</li>
<li>源索引的状态必须为健康状态（green）</li>
</ul>
<p>下面示例：将拥有 12 个主分片、2 个副本分片的索引（<code>test_index</code>）收缩为拥有 3 个主分片和 1 个副分片的索引（<code>test_index_new</code>）</p>
<h3 id="第一步-创建原索引"> 第一步：创建原索引</h3>
<p>先创建索引 <code>test_index</code>，设置 <code>number_of_shards = 12</code>，<code>number_of_replicas = 2</code>：</p>
<div><pre><code><span># 创建原索引（测试用）</span>
PUT test_index
<span>{</span>
  <span>"mappings"</span><span>:</span> <span>{</span>
    <span>"properties"</span><span>:</span> <span>{</span> <span>"test_name"</span><span>:</span> <span>{</span> <span>"type"</span><span>:</span> <span>"keyword"</span><span>}</span> <span>}</span>
  <span>}</span>,
  <span>"settings"</span><span>:</span> <span>{</span>
    <span>"number_of_shards"</span><span>:</span> <span>12</span>, 
    <span>"number_of_replicas"</span><span>:</span> <span>2</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="第二步-收缩前准备"> 第二步：收缩前准备</h3>
<p>下面将索引 <code>test_index</code> 所有的主分片转移到节点 <code>my_ndoe_1</code> 上，并且设置索引的副本分片数量为 0、设置这个索引为只读状态：</p>
<div><pre><code>PUT /test_index/_settings
<span>{</span>
  <span># 分片分配到 my_node_1 节点</span>
  <span>"index.routing.allocation.require._name"</span><span>:</span> <span>"my_node_1"</span>,
  <span>"index.number_of_replicas"</span><span>:</span> <span>0</span>,
  <span>"index.blocks.write"</span><span>:</span> <span>true</span>  
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="第三步-开始进行收缩"> 第三步：开始进行收缩</h3>
<p>OK，这个时候 <code>test_index</code> 满足了收缩索引的 3 个条件了，下面开始进行收缩：</p>
<div><pre><code>POST /test_index/_shrink/test_index_new
<span>{</span>
  <span>"settings"</span><span>:</span> <span>{</span>
    <span>"index.number_of_replicas"</span><span>:</span> <span>1</span>,
    <span>"index.number_of_shards"</span><span>:</span> <span>3</span>,
    <span>"index.routing.allocation.require._name"</span><span>:</span> null, <span># 系统随机分配分片</span>
    <span>"index.blocks.write"</span><span>:</span> null <span># 不阻塞写操作</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>如上示例，我们设置了新索引的主分片数量为 3，每个主分片的副本数量为 1，并且这些分片是系统自动、随机分配的，不阻塞新索引的写操作</p>
<p>更多关于收缩索引 API 的使用参数和示例，可以参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/indices-shrink-index.html" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<h2 id="参考资料"> 参考资料</h2>
<ul>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/indices.html" target="_blank" rel="noopener noreferrer">Index APIs</a></li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">定义字段类型：Mapping</title>
    <id>https://www.snowji.cn/databases/es/mapping/</id>
    <link href="https://www.snowji.cn/databases/es/mapping/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="定义字段类型-mapping"> 定义字段类型：Mapping</h1>
<h2 id="前言"> 前言</h2>
<p>每个文档都是一个字段的集合，每个字段都有自己的数据类型。<strong>Mapping 定义了索引中的文档有哪些字段及其类型、这些字段是如何存储和索引的</strong></p>
<p>所以 Mapping 的作用主要有：</p>
<ul>
<li>定义了索引中各个字段的名称和对应的类型</li>
<li>定义各个字段、倒排索引的相关设置。如使用某字段使用什么分词器等</li>
</ul>
<p>一个基本的定义 Mapping 的语法如下：</p>
<div><pre><code>PUT books
<span>{</span>
  <span>"mappings"</span><span>:</span> <span>{</span>
    <span>"properties"</span><span>:</span> <span>{</span>
      <span>"book_id"</span><span>:</span> <span>{</span>
        <span>"type"</span><span>:</span> <span>"keyword"</span>
      <span>}</span>,
      <span>"name"</span><span>:</span> <span>{</span>
        <span>"type"</span><span>:</span> <span>"text"</span>,
        <span>"analyzer"</span><span>:</span> <span>"standard"</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id="dynamic-mapping"> Dynamic Mapping</h2>
<p>除了预先定义好 Mapping 外，如果写入文档时索引不存在的话会自动创建索引，或者写入的字段不存在也会自动创建这个字段，这个时候 ES 会自行推断字段类型，官方把这种功能称为 Dynamic Mapping</p>
<p>动态索引的好处是使得我们无需手动定义 Mapping，ES 帮我们根据文档的信息自动推算出了各个字段的信息</p>
<p>但是，推算的东西它不一定是准确的，很多时候并不是我们想要的东西，所以还是建议尽量自定义 Mapping</p>
<p>当然也可以对 Mapping 的 Dynamic 属性进行设置：</p>
<div><pre><code>PUT books/_mapping
<span>{</span>
    <span>"dynamic"</span><span>:</span> <span>"false"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><code>dynamic</code> 属性的取值范围和作用如下：</p>
<ul>
<li><strong>true</strong>：一旦有新的字段写入，Mapping 也同时被更新（自动创建了这个字段）</li>
<li><strong>false</strong>：Mapping 不会被更新，新的字段不会被索引，但是新增的字段数据会出现在 <code>_source</code> 里</li>
<li><strong>runtime</strong>：新的字段不会被索引，也是就是不能被检索，但是会以 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/runtime.html" target="_blank" rel="noopener noreferrer">runtime fields</a> 的形式出现在 Mapping 中，并且新字段会存在于搜索结果的 <code>_source</code> 中</li>
<li><strong>strict</strong>：如果写入不存在的字段，文档数据写入会失败</li>
</ul>
<h2 id="mapping-支持的数据类型"> Mapping 支持的数据类型</h2>
<p>Dynamic Mapping 的功能可以自动推断字段的类型，这些类型都是 ES 支持的基本数据类型，这些类型主要有：</p>
<div style="text-align: center;">
  <img src="./images/data-types.svg" alt="ES 支持的基本数据类型">
</div>
<p>如上图，ES 提供的数据类型主要分为字符串、日期、数字、二进制、布尔、范围、地理、对象、嵌套类型等，比较常用的数据类型在图上已经用底纹进行标记了</p>
<p>下面对常用的数据类型进行介绍，更多关于 Mapping 基本数据类型的内容可以参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/mapping-types.html" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<h3 id="字符串"> 字符串</h3>
<p>在 7.x 之后的版本中，字符串类型只有 <code>keyword</code> 和 <code>text</code> 两种，旧版本的 <code>string</code> 类型已不再支持</p>
<ul>
<li><code>keyword</code> 类型适合存储简短、结构化的字符串，例如产品 ID、产品名字等。其适合用于聚合、过滤、精确查询</li>
<li><code>text</code> 类型的字段适合存储全文本数据，如短信内容、邮件内容等。text 的类型数据将会被分词器进行分词，最终成为一个个词项存储在倒排索引中</li>
</ul>
<h3 id="日期类型"> 日期类型</h3>
<p>JSON 中是没有日期类型的，所以其形式可以如下表示：</p>
<ul>
<li>字符串包含日期格式，例如：&quot;2015-01-01&quot; 或者 &quot;2015/01/01 12:10:30&quot;</li>
<li>时间戳，以毫秒或者秒为单位</li>
</ul>
<p>实际上，在底层 ES 都会把日期类型转换为 UTC（如果有指定时区的话），并且作为毫秒形式的时间戳用一个 <code>long</code> 来存储</p>
<h3 id="数字类型"> 数字类型</h3>
<p>数字类型分为 <code>byte</code>、<code>short</code>、<code>integer</code>、<code>long</code>、<code>float</code>、<code>double</code>、<code>half_float</code>、<code>scaled_float</code>、<code>unsigned_long</code></p>
<p>有两个不太熟悉的：</p>
<ul>
<li><code>half_float</code> 是一种 16 位的半精度浮点数，限制为有限值</li>
<li><code>scaled_float</code> 是缩放类型的的浮点数</li>
</ul>
<p>在满足需求的前提下，应当选择尽可能小的数据类型，除了可能会减少存储空间外，也会提高索引数据和检索数据的效率</p>
<h3 id="对象与嵌套类型"> 对象与嵌套类型</h3>
<p>实际业务中的数据，很多时候都需要用对象和数组、嵌套类型等复杂数据类型来表示的，例如书本作者可能有多个，这个时候作者字段就需要保存为一个数组</p>
<p>这里只介绍对象和数组，嵌套类型（nested）是一个很复杂的类型，其查询语法也会有所讲究，所以在 <a href="/databases/es/nested-and-join">嵌套类型和父子文档</a> 一文中单独拎出来整理了</p>
<p>JSON 中是可以嵌套对象的，保存对象类型可以用 <code>object</code> 类型，但实际上在 ES 中会将原 JSON 文档扁平化存储的。假如作者字段是一个对象，那么可以表示为：</p>
<div><pre><code><span>{</span>
  <span>"author"</span><span>:</span> <span>{</span>
    <span>"first"</span><span>:</span><span>"zhang"</span>,
    <span>"last"</span><span>:</span><span>"san"</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>但实际上，ES 在存储的时候会转化为以下格式存储：</p>
<div><pre><code><span>{</span>
  <span>"author.first"</span><span>:</span> <span>"zhang"</span>,
  <span>"author.last"</span><span>:</span> <span>"san"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>对于数组来说，ES 并没有定义关键字来表示一个字段为数组类型。默认的情况下，<strong>任何一个字段都可以包含 0 个或者多个值，只要这些值是相同的数据类型</strong>。所以我们在创建数据的时候可以直接写入数组类型：</p>
<div><pre><code>PUT books/_doc/3
<span>{</span>
  <span>"author"</span><span>:</span> <span>[</span><span>"Neil Matthew"</span>,<span>"Richard Stones"</span><span>]</span>,
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="快速自定义-mapping"> 快速自定义 Mapping</h2>
<p><strong>在一个索引中定义太多的字段可能会造成 OOM 错误并且在错误恢复时会更加困难</strong>。但前面又说建议自定义 Mapping 而不要使用 Dynamic Mapping</p>
<p>那么当 Mapping 拥有的字段非常多的时候，该怎么处理呢？</p>
<p>答案是：<strong>可以把 JSON 对象直接写入，利用 Dynamic Mapping 的特性帮我们生成出一个初步可用的 Mapping，然后我们修改这个 Mapping 来直到满足需求即可</strong></p>
<p>大概的步骤如下：</p>
<ol>
<li>创建临时索引，并且写入业务数据</li>
<li>获取这个临时索引的 Mapping</li>
<li>根据业务场景，完善这个 Mapping。如对某些字段定义对应的分词器等</li>
<li>完成后删除临时的索引，并创建符合需求的索引</li>
</ol>
<p>在使用 Dynamic Mapping 的时候，JSON 文档的字段类型会自动转换为ES的类型，下面是对照表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">JSON 类型</th>
<th style="text-align:left">ES类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">boolean</td>
</tr>
<tr>
<td style="text-align:left">整数</td>
<td style="text-align:left">long</td>
</tr>
<tr>
<td style="text-align:left">浮点数</td>
<td style="text-align:left">float</td>
</tr>
<tr>
<td style="text-align:left">字符串</td>
<td style="text-align:left">1、匹配为 text，并且增加 keyword 子字段。<br>2、匹配为日期，设置为 date。<br>3、匹配为数字，设置为 long 或者 float，这个功能默认关闭。</td>
</tr>
<tr>
<td style="text-align:left">对象</td>
<td style="text-align:left">object</td>
</tr>
<tr>
<td style="text-align:left">数组</td>
<td style="text-align:left">由第一个非空数值的类型决定</td>
</tr>
<tr>
<td style="text-align:left">空值</td>
<td style="text-align:left">忽略，不做转换</td>
</tr>
</tbody>
</table>
<h2 id="mapping-的常用参数"> Mapping 的常用参数</h2>
<p>Mapping 参数可以用来控制某个字段的特性，例如这个字段是否被索引、用什么分词器、空值是否可以被搜索到等</p>
<p>Mapping 提供的参数有很多，可以参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/mapping-params.html" target="_blank" rel="noopener noreferrer">官方文档</a>，下面挑几个来介绍</p>
<h3 id="index"> index</h3>
<p>当某个字段不需要被索引和查询的时候，可以使用 <code>index</code> 参数进行控制，其接受的值为 <code>true</code> 或者 <code>false</code>。使用示例如下：</p>
<div><pre><code>PUT index_param_index
<span>{</span>
  <span>"mappings"</span><span>:</span> <span>{</span>
    <span>"properties"</span><span>:</span> <span>{</span>
      <span>"name"</span><span>:</span> <span>{</span>
        <span>"type"</span><span>:</span> <span>"text"</span>,
        <span>"index"</span><span>:</span> <span>false</span> <span># name 字段不进行索引操作，所以不能查询到</span>
      <span>}</span>,
      <span>"address"</span><span>:</span> <span>{</span> <span>"type"</span><span>:</span> <span>"text"</span> <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="analyzer"> analyzer</h3>
<p>这个参数用来指定使用哪个分词器</p>
<p>当我们进行全文本搜索的时候，会将检索的内容先进行分词，然后再进行匹配。默认情况下，检索内容使用的分词器会与字段指定的分词器一致，但如果设置了 <code>search_analyzer</code>，检索内容使用的分词器将会与 <code>search_analyzer</code> 设定的一致。其使用实例如下：</p>
<div><pre><code>PUT analyzer_index
<span>{</span>
  <span>"mappings"</span><span>:</span> <span>{</span>
    <span>"properties"</span><span>:</span> <span>{</span>
      <span>"name"</span><span>:</span> <span>{</span>
        <span>"type"</span><span>:</span> <span>"text"</span>,
        <span>"analyzer"</span><span>:</span> <span>"simple"</span>, 
        <span>"search_analyzer"</span><span>:</span> <span>"standard"</span> 
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="dynamic"> dynamic</h3>
<p>可以在文档和对象级别对 Dynamic Mapping 进行控制，来一个示例：</p>
<div><pre><code>PUT dynamic_index
<span>{</span>
  <span>"mappings"</span><span>:</span> <span>{</span>
    <span>"dynamic"</span><span>:</span> <span>"strict"</span>, <span># 1，文档级别，表示文档不能动态添加 top 级别的字段</span>
    <span>"properties"</span><span>:</span> <span>{</span> 
      <span>"author"</span><span>:</span> <span>{</span>        <span># 2，author 对象继承了文档级别的设置。    </span>
        <span>"properties"</span><span>:</span> <span>{</span>
          <span>"address"</span><span>:</span> <span>{</span> 
            <span>"dynamic"</span><span>:</span> <span>"true"</span>, <span># 3，表示 address 对象可以动态添加字段</span>
            <span>"properties"</span>:<span>{</span><span>}</span>
          <span>}</span>,
          <span>"country"</span><span>:</span> <span>{</span> <span>"properties"</span>:<span>{</span><span>}</span> <span>}</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>如上示例，在 <code>1</code> 处，我们控制了整个文档的 <code>dynamic</code> 为 <code>strict</code>，即如果写入不存在的字段，文档数据写入会失败。其中 <code>author</code> 对象没有设置 <code>dynamic</code> 属性，其将会继承 <code>top</code> 级别的 <code>dynamic</code> 设置 我们在 <code>&quot;author.address&quot;</code> 对象级别中也设置了 <code>dynamic</code> 属性为 <code>true</code>，其效果是 <code>address</code> 对象可以动态添加字段</p>
<h3 id="null-value"> <code>null_value</code></h3>
<p>如果需要对 <code>null</code> 值实现搜索的时候，需要设置字段的 <code>null_value</code> 参数。<code>null_value</code> 参数默认值为 <code>null</code>，其允许用户使用指定值替换空值，以便它可以索引和搜索</p>
<p>需要注意的是，<code>null_value</code> 只决定数据是如何索引的，不影响 <code>_source</code> 的内容, 并且 <code>null_value</code> 的值的类型需要与字段的类型一致，例如一个 <code>long</code> 类型的字段，其 <code>null_value</code> 的值不能为字符串。使用 <code>&quot;NULL&quot;</code> 显式值来代替 <code>null</code>，使用示例如下：</p>
<div><pre><code><span># 创建索引</span>
PUT null_value_index
<span>{</span>
  <span>"mappings"</span><span>:</span> <span>{</span>
    <span>"properties"</span><span>:</span> <span>{</span>
      <span>"id"</span><span>:</span> <span>{</span> <span>"type"</span><span>:</span> <span>"keyword"</span> <span>}</span>,
      <span>"email"</span><span>:</span> <span>{</span>
        <span>"type"</span><span>:</span> <span>"keyword"</span>,
        <span>"null_value"</span><span>:</span> <span>"NULL"</span> <span># 使用 "NULL" 显式值</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

<span># 插入数据</span>
PUT null_value_index/_doc/1
<span>{</span>
  <span>"id"</span><span>:</span> <span>"1"</span>,
  <span>"email"</span><span>:</span> null
<span>}</span>

<span># 查询空值数据</span>
GET null_value_index/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"term"</span><span>:</span> <span>{</span> <span>"email"</span><span>:</span> <span>"NULL"</span> <span>}</span> <span># 使用显式值来查询空值的文档</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h3 id="copy-to"> <code>copy_to</code></h3>
<p><code>copy_to</code> 参数允许用户复制多个字段的值到目标字段，<strong>这个字段可以像单个字段那样被查询</strong>。其使用示例如下：</p>
<div><pre><code><span># 创建索引</span>
PUT <span>users</span>
<span>{</span>
  <span>"mappings"</span><span>:</span> <span>{</span>
    <span>"properties"</span><span>:</span> <span>{</span>
      <span>"first_name"</span><span>:</span> <span>{</span>
        <span>"type"</span><span>:</span> <span>"text"</span>,
        <span>"copy_to"</span><span>:</span> <span>"full_name"</span> 
      <span>}</span>,
      <span>"last_name"</span><span>:</span> <span>{</span>
        <span>"type"</span><span>:</span> <span>"text"</span>,
        <span>"copy_to"</span><span>:</span> <span>"full_name"</span> 
      <span>}</span>,
      <span>"full_name"</span><span>:</span> <span>{</span> <span>"type"</span><span>:</span> <span>"text"</span> <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

<span># 插入数据</span>
PUT users/_doc/1
<span>{</span>
  <span>"first_name"</span><span>:</span> <span>"zhang"</span>,
  <span>"last_name"</span><span>:</span> <span>"san"</span>
<span>}</span>

<span># 查询</span>
GET users/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"match"</span><span>:</span> <span>{</span>
      <span>"full_name"</span><span>:</span> <span>{</span>
        <span>"query"</span><span>:</span> <span>"zhang san"</span>,
        <span>"operator"</span><span>:</span> <span>"and"</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

<span># 结果</span>
<span>{</span>
  <span>"hits"</span> <span>:</span> <span>{</span>
    <span>"hits"</span> <span>:</span> <span>[</span>
      <span>{</span>
        <span>"_source"</span> <span>:</span> <span>{</span>
          <span>"first_name"</span> <span>:</span> <span>"zhang"</span>,
          <span>"last_name"</span> <span>:</span> <span>"san"</span>
        <span>}</span>
      <span>}</span>
    <span>]</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br></div></div><p>如上示例可以看到，返回的结果中，<code>_source</code> 里是不包含 <code>full_name</code> 字段的</p>
<h3 id="doc-values"> <code>doc_values</code></h3>
<p>对数据进行检索的时候，倒排索引可以提高检索的效率，但是在对字段进行聚合、排序、使用脚本访问字段值等操作的时候，需要一种不同的数据结构来支持</p>
<p>Doc values 是基于列式存储的结构，在索引数据的时候创建。它存储的值与 <code>_source</code> 中的值相同，<strong>使用列式存储结构使得 Doc values 在处理聚合、排序操作上更高效</strong>。Doc values 支持几乎所有的类型字段，但是 <code>text</code> 和 <code>annotated_text</code> 除外</p>
<p><strong>Doc values 默认是开启的，保存 Doc values 结构需要很大的空间开销，如果某个字段不需要排序、聚合、使用脚本访问，那么应该禁用此字段的 Doc values 来节省磁盘空间</strong>。其使用示例如下：</p>
<div><pre><code>PUT my-index
<span>{</span>
  <span>"mappings"</span><span>:</span> <span>{</span>
    <span>"properties"</span><span>:</span> <span>{</span>
      <span>"status_code"</span><span>:</span> <span>{</span> 
        <span>"type"</span><span>:</span>       <span>"keyword"</span>
      <span>}</span>,
      <span>"session_id"</span><span>:</span> <span>{</span> 
        <span>"type"</span><span>:</span>       <span>"keyword"</span>,
        <span>"doc_values"</span><span>:</span> <span>false</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id="参考资料"> 参考资料</h2>
<ul>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/mapping.html" target="_blank" rel="noopener noreferrer">Mapping</a></li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">正排索引与倒排索引</title>
    <id>https://www.snowji.cn/databases/es/forward-and-inverted-index/</id>
    <link href="https://www.snowji.cn/databases/es/forward-and-inverted-index/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="正排索引与倒排索引"> 正排索引与倒排索引</h1>
<h2 id="索引"> 索引</h2>
<p><strong>索引从本质来讲就是一种为了加快检索数据的存储结构</strong>，就像书的目录一样，可以很快地帮助我们查找到某个章节所在的位置。而 ES 正是通过<strong>正排索引</strong>和<strong>倒排索引</strong>来提供高效的数据获取和检索能力的</p>
<p>比如在背诵古诗词的比赛中，有两个比赛项目：</p>
<ul>
<li>一个是给定诗词的名称，请你背诵诗词的内容</li>
<li>一个是给定多个词语，请你说出同时带有这些词语的古诗词的名称，并且背诵诗词内容</li>
</ul>
<p>第二种我们在参赛的时候，一般人的方式都是先在心里一首首默念一下，判断内容中是否同时包含给定的词语。很明显，这种逆向操作的难度是要比第一种大的</p>
<p>如果我们要做一个机器人去参加这个古诗词背诵比赛，面对这两个项目，有两个非常重要的技术可以解决这两个需求，那就是前面提到的正排索引和倒排索引</p>
<h2 id="正排索引"> 正排索引</h2>
<p>如果要赢得诗词比赛的第一个项目，那么设计的思路也比较简单：我们可以把诗词的名字作为唯一 ID，诗词的内容作为值，然后用哈希表存储起来，这样查询的时候就可以实现在 O(1) 复杂度下完成对信息的检索，非常高效</p>
<p><strong>像这种实体 ID 到数据实体内容的关联关系的索引我们称为正排索引</strong>，它非常适合处理键值查询的场景。例如这样的查询语句：</p>
<div><pre><code><span># poetry_title 是主键</span>
<span>select</span> author<span>,</span> content <span>from</span> poetry <span>where</span> poetry_title <span>=</span> <span>'静夜思'</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>那么要实现这个正排索引，主要有<strong>三种数据结构</strong>：哈希表、有序数组和 B+ 树。</p>
<h3 id="哈希表"> 哈希表</h3>
<p>哈希表是一种以键值对（Key-Value）存储的数据结构，我们可以非常高效地使用 Key 来获取对应的 Value 值，其复杂度为 O(1)</p>
<p>哈希表的实现思路非常简单，<strong>只需要利用哈希函数将 Key 转换为一个确定的数值，并且将对应的 Value 放到数组对应的位置即可</strong>。如果发生哈希冲突，就将对应的数组位置保存为一个列表的地址，相应的 Value 可以插入这个列表的头或者列表的尾巴</p>
<div style="text-align: center;">
  <svg id="SvgjsSvg1006" width="807.1000061035156" height="388.99998474121094" xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.com/svgjs"><defs id="SvgjsDefs1007"><marker id="SvgjsMarker1134" markerWidth="12" markerHeight="8" refX="9" refY="4" viewBox="0 0 12 8" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1135" d="M0,0 L12,4 L0,8 L0,0" fill="#9e9e9e" stroke="#9e9e9e" stroke-width="1"></path></marker><marker id="SvgjsMarker1138" markerWidth="12" markerHeight="8" refX="9" refY="4" viewBox="0 0 12 8" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1139" d="M0,0 L12,4 L0,8 L0,0" fill="#9e9e9e" stroke="#9e9e9e" stroke-width="1"></path></marker><marker id="SvgjsMarker1142" markerWidth="12" markerHeight="8" refX="9" refY="4" viewBox="0 0 12 8" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1143" d="M0,0 L12,4 L0,8 L0,0" fill="#9e9e9e" stroke="#9e9e9e" stroke-width="1"></path></marker><marker id="SvgjsMarker1146" markerWidth="12" markerHeight="8" refX="9" refY="4" viewBox="0 0 12 8" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1147" d="M0,0 L12,4 L0,8 L0,0" fill="#9e9e9e" stroke="#9e9e9e" stroke-width="1"></path></marker><marker id="SvgjsMarker1150" markerWidth="12" markerHeight="8" refX="9" refY="4" viewBox="0 0 12 8" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1151" d="M0,0 L12,4 L0,8 L0,0" fill="#9e9e9e" stroke="#9e9e9e" stroke-width="1"></path></marker><marker id="SvgjsMarker1154" markerWidth="12" markerHeight="8" refX="9" refY="4" viewBox="0 0 12 8" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1155" d="M0,0 L12,4 L0,8 L0,0" fill="#9e9e9e" stroke="#9e9e9e" stroke-width="1"></path></marker><marker id="SvgjsMarker1158" markerWidth="12" markerHeight="8" refX="9" refY="4" viewBox="0 0 12 8" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1159" d="M0,0 L12,4 L0,8 L0,0" fill="#9e9e9e" stroke="#9e9e9e" stroke-width="1"></path></marker><marker id="SvgjsMarker1162" markerWidth="12" markerHeight="8" refX="9" refY="4" viewBox="0 0 12 8" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1163" d="M0,0 L12,4 L0,8 L0,0" fill="#9e9e9e" stroke="#9e9e9e" stroke-width="1"></path></marker></defs><g id="SvgjsG1008" transform="translate(25.000015258789062,102.99999237060547)"><path id="SvgjsPath1009" d="M 0 4Q 0 0 4 0L 97 0Q 101 0 101 4L 101 42Q 101 46 97 46L 4 46Q 0 46 0 42Z" stroke="rgba(76,175,80,1)" stroke-width="1" fill-opacity="1" fill="#c8e6c9"></path><g id="SvgjsG1010"><text id="SvgjsText1011" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="81px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="12.375" transform="rotate(0)"><tspan id="SvgjsTspan1012" dy="16" x="50.5"><tspan id="SvgjsTspan1013" style="text-decoration:;">静夜思</tspan></tspan></text></g></g><g id="SvgjsG1014" transform="translate(25.000015258789062,146.99999237060547)"><path id="SvgjsPath1015" d="M 0 4Q 0 0 4 0L 97 0Q 101 0 101 4L 101 42Q 101 46 97 46L 4 46Q 0 46 0 42Z" stroke="rgba(156,39,176,1)" stroke-width="1" fill-opacity="1" fill="#e1bee7"></path><g id="SvgjsG1016"><text id="SvgjsText1017" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="81px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="12.375" transform="rotate(0)"><tspan id="SvgjsTspan1018" dy="16" x="50.5"><tspan id="SvgjsTspan1019" style="text-decoration:;">咏鹅</tspan></tspan></text></g></g><g id="SvgjsG1020" transform="translate(25.000015258789062,192.99999237060547)"><path id="SvgjsPath1021" d="M 0 4Q 0 0 4 0L 97 0Q 101 0 101 4L 101 42Q 101 46 97 46L 4 46Q 0 46 0 42Z" stroke="rgba(255,152,0,1)" stroke-width="1" fill-opacity="1" fill="#ffe0b2"></path><g id="SvgjsG1022"><text id="SvgjsText1023" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="81px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="12.375" transform="rotate(0)"><tspan id="SvgjsTspan1024" dy="16" x="50.5"><tspan id="SvgjsTspan1025" style="text-decoration:;">陋室铭</tspan></tspan></text></g></g><g id="SvgjsG1026" transform="translate(25.000015258789062,238.99999237060547)"><path id="SvgjsPath1027" d="M 0 4Q 0 0 4 0L 97 0Q 101 0 101 4L 101 42Q 101 46 97 46L 4 46Q 0 46 0 42Z" stroke="rgba(255,152,0,1)" stroke-width="1" fill-opacity="1" fill="#ffe0b2"></path><g id="SvgjsG1028"><text id="SvgjsText1029" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="81px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="12.375" transform="rotate(0)"><tspan id="SvgjsTspan1030" dy="16" x="50.5"><tspan id="SvgjsTspan1031" style="text-decoration:;">登鹤雀楼</tspan></tspan></text></g></g><g id="SvgjsG1032" transform="translate(205.10000610351562,76.59999084472656)"><path id="SvgjsPath1033" d="M 0 4Q 0 0 4 0L 55 0Q 59 0 59 4L 59 35Q 59 39 55 39L 4 39Q 0 39 0 35Z" stroke="rgba(76,175,80,1)" stroke-width="1" fill-opacity="1" fill="#c8e6c9"></path><g id="SvgjsG1034"><text id="SvgjsText1035" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="39px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.875" transform="rotate(0)"><tspan id="SvgjsTspan1036" dy="16" x="29.5"><tspan id="SvgjsTspan1037" style="text-decoration:;">1</tspan></tspan></text></g></g><g id="SvgjsG1038" transform="translate(205.10000610351562,114.99999237060547)"><path id="SvgjsPath1039" d="M 0 4Q 0 0 4 0L 55 0Q 59 0 59 4L 59 35Q 59 39 55 39L 4 39Q 0 39 0 35Z" stroke="rgba(156,39,176,1)" stroke-width="1" fill-opacity="1" fill="#e1bee7"></path><g id="SvgjsG1040"><text id="SvgjsText1041" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="39px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.875" transform="rotate(0)"><tspan id="SvgjsTspan1042" dy="16" x="29.5"><tspan id="SvgjsTspan1043" style="text-decoration:;">2</tspan></tspan></text></g></g><g id="SvgjsG1044" transform="translate(205.10000610351562,152.49999237060547)"><path id="SvgjsPath1045" d="M 0 4Q 0 0 4 0L 55 0Q 59 0 59 4L 59 35Q 59 39 55 39L 4 39Q 0 39 0 35Z" stroke="rgba(0,188,212,1)" stroke-width="1" fill-opacity="1" fill="#b2ebf2"></path><g id="SvgjsG1046"><text id="SvgjsText1047" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="39px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.875" transform="rotate(0)"><tspan id="SvgjsTspan1048" dy="16" x="29.5"><tspan id="SvgjsTspan1049" style="text-decoration:;">…</tspan></tspan></text></g></g><g id="SvgjsG1050" transform="translate(205.10000610351562,190.99999237060547)"><path id="SvgjsPath1051" d="M 0 4Q 0 0 4 0L 55 0Q 59 0 59 4L 59 35Q 59 39 55 39L 4 39Q 0 39 0 35Z" stroke="rgba(0,188,212,1)" stroke-width="1" fill-opacity="1" fill="#b2ebf2"></path><g id="SvgjsG1052"><text id="SvgjsText1053" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="39px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.875" transform="rotate(0)"><tspan id="SvgjsTspan1054" dy="16" x="29.5"><tspan id="SvgjsTspan1055" style="text-decoration:;">…</tspan></tspan></text></g></g><g id="SvgjsG1056" transform="translate(205.10000610351562,228.39999389648438)"><path id="SvgjsPath1057" d="M 0 4Q 0 0 4 0L 55 0Q 59 0 59 4L 59 35Q 59 39 55 39L 4 39Q 0 39 0 35Z" stroke="rgba(255,152,0,1)" stroke-width="1" fill-opacity="1" fill="#ffe0b2"></path><g id="SvgjsG1058"><text id="SvgjsText1059" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="39px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.875" transform="rotate(0)"><tspan id="SvgjsTspan1060" dy="16" x="29.5"><tspan id="SvgjsTspan1061" style="text-decoration:;">M</tspan></tspan></text></g></g><g id="SvgjsG1062" transform="translate(205.10000610351562,266.99999237060547)"><path id="SvgjsPath1063" d="M 0 4Q 0 0 4 0L 55 0Q 59 0 59 4L 59 35Q 59 39 55 39L 4 39Q 0 39 0 35Z" stroke="rgba(0,188,212,1)" stroke-width="1" fill-opacity="1" fill="#b2ebf2"></path><g id="SvgjsG1064"><text id="SvgjsText1065" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="39px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.875" transform="rotate(0)"><tspan id="SvgjsTspan1066" dy="16" x="29.5"><tspan id="SvgjsTspan1067" style="text-decoration:;">N</tspan></tspan></text></g></g><g id="SvgjsG1068" transform="translate(339.1000061035156,24.99999237060547)"><path id="SvgjsPath1069" d="M 0 0L 188 0L 188 103L 0 103Z" stroke="rgba(158,158,158,1)" stroke-width="1" fill-opacity="1" fill="#f5f5f5"></path><g id="SvgjsG1070"><text id="SvgjsText1071" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="168px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="40.875" transform="rotate(0)"></text></g></g><g id="SvgjsG1072" transform="translate(366.1000061035156,31.99999237060547)"><path id="SvgjsPath1073" d="M 0 4Q 0 0 4 0L 136 0Q 140 0 140 4L 140 35Q 140 39 136 39L 4 39Q 0 39 0 35Z" stroke="rgba(76,175,80,1)" stroke-width="1" fill-opacity="1" fill="#c8e6c9"></path><g id="SvgjsG1074"><text id="SvgjsText1075" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="120px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.875" transform="rotate(0)"><tspan id="SvgjsTspan1076" dy="16" x="70"><tspan id="SvgjsTspan1077" style="text-decoration:;">静夜思</tspan></tspan></text></g></g><g id="SvgjsG1078" transform="translate(366.1000061035156,81.09999084472656)"><path id="SvgjsPath1079" d="M 0 4Q 0 0 4 0L 136 0Q 140 0 140 4L 140 36Q 140 40 136 40L 4 40Q 0 40 0 36Z" stroke="rgba(76,175,80,1)" stroke-width="1" fill-opacity="1" fill="#c8e6c9"></path><g id="SvgjsG1080"><text id="SvgjsText1081" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="120px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="9.375" transform="rotate(0)"><tspan id="SvgjsTspan1082" dy="16" x="70"><tspan id="SvgjsTspan1083" style="text-decoration:;">床前明月光……</tspan></tspan></text></g></g><g id="SvgjsG1084" transform="translate(339.1000061035156,142.99999237060547)"><path id="SvgjsPath1085" d="M 0 0L 188 0L 188 103L 0 103Z" stroke="rgba(158,158,158,1)" stroke-width="1" fill-opacity="1" fill="#f5f5f5"></path><g id="SvgjsG1086"><text id="SvgjsText1087" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="168px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="40.875" transform="rotate(0)"></text></g></g><g id="SvgjsG1088" transform="translate(366.1000061035156,149.99999237060547)"><path id="SvgjsPath1089" d="M 0 4Q 0 0 4 0L 136 0Q 140 0 140 4L 140 35Q 140 39 136 39L 4 39Q 0 39 0 35Z" stroke="rgba(156,39,176,1)" stroke-width="1" fill-opacity="1" fill="#e1bee7"></path><g id="SvgjsG1090"><text id="SvgjsText1091" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="120px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.875" transform="rotate(0)"><tspan id="SvgjsTspan1092" dy="16" x="70"><tspan id="SvgjsTspan1093" style="text-decoration:;">咏鹅</tspan></tspan></text></g></g><g id="SvgjsG1094" transform="translate(366.1000061035156,199.09999084472656)"><path id="SvgjsPath1095" d="M 0 4Q 0 0 4 0L 136 0Q 140 0 140 4L 140 36Q 140 40 136 40L 4 40Q 0 40 0 36Z" stroke="rgba(156,39,176,1)" stroke-width="1" fill-opacity="1" fill="#e1bee7"></path><g id="SvgjsG1096"><text id="SvgjsText1097" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="120px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="9.375" transform="rotate(0)"><tspan id="SvgjsTspan1098" dy="16" x="70"><tspan id="SvgjsTspan1099" style="text-decoration:;">鹅，鹅，鹅……</tspan></tspan></text></g></g><g id="SvgjsG1100" transform="translate(339.1000061035156,260.99999237060547)"><path id="SvgjsPath1101" d="M 0 0L 188 0L 188 103L 0 103Z" stroke="rgba(158,158,158,1)" stroke-width="1" fill-opacity="1" fill="#f5f5f5"></path><g id="SvgjsG1102"><text id="SvgjsText1103" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="168px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="40.875" transform="rotate(0)"></text></g></g><g id="SvgjsG1104" transform="translate(366.1000061035156,267.99999237060547)"><path id="SvgjsPath1105" d="M 0 4Q 0 0 4 0L 136 0Q 140 0 140 4L 140 35Q 140 39 136 39L 4 39Q 0 39 0 35Z" stroke="rgba(255,152,0,1)" stroke-width="1" fill-opacity="1" fill="#ffe0b2"></path><g id="SvgjsG1106"><text id="SvgjsText1107" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="120px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.875" transform="rotate(0)"><tspan id="SvgjsTspan1108" dy="16" x="70"><tspan id="SvgjsTspan1109" style="text-decoration:;">陋室铭</tspan></tspan></text></g></g><g id="SvgjsG1110" transform="translate(366.1000061035156,317.09999084472656)"><path id="SvgjsPath1111" d="M 0 4Q 0 0 4 0L 136 0Q 140 0 140 4L 140 36Q 140 40 136 40L 4 40Q 0 40 0 36Z" stroke="rgba(255,152,0,1)" stroke-width="1" fill-opacity="1" fill="#ffe0b2"></path><g id="SvgjsG1112"><text id="SvgjsText1113" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="120px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="9.375" transform="rotate(0)"><tspan id="SvgjsTspan1114" dy="16" x="70"><tspan id="SvgjsTspan1115" style="text-decoration:;">山不在高……</tspan></tspan></text></g></g><g id="SvgjsG1116" transform="translate(594.1000061035156,260.99999237060547)"><path id="SvgjsPath1117" d="M 0 0L 188 0L 188 103L 0 103Z" stroke="rgba(158,158,158,1)" stroke-width="1" fill-opacity="1" fill="#f5f5f5"></path><g id="SvgjsG1118"><text id="SvgjsText1119" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="168px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="40.875" transform="rotate(0)"></text></g></g><g id="SvgjsG1120" transform="translate(621.1000061035156,267.99999237060547)"><path id="SvgjsPath1121" d="M 0 4Q 0 0 4 0L 136 0Q 140 0 140 4L 140 35Q 140 39 136 39L 4 39Q 0 39 0 35Z" stroke="rgba(255,152,0,1)" stroke-width="1" fill-opacity="1" fill="#ffe0b2"></path><g id="SvgjsG1122"><text id="SvgjsText1123" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="120px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.875" transform="rotate(0)"><tspan id="SvgjsTspan1124" dy="16" x="70"><tspan id="SvgjsTspan1125" style="text-decoration:;">登鹳雀楼</tspan></tspan></text></g></g><g id="SvgjsG1126" transform="translate(621.1000061035156,317.09999084472656)"><path id="SvgjsPath1127" d="M 0 4Q 0 0 4 0L 136 0Q 140 0 140 4L 140 36Q 140 40 136 40L 4 40Q 0 40 0 36Z" stroke="rgba(255,152,0,1)" stroke-width="1" fill-opacity="1" fill="#ffe0b2"></path><g id="SvgjsG1128"><text id="SvgjsText1129" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="120px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="9.375" transform="rotate(0)"><tspan id="SvgjsTspan1130" dy="16" x="70"><tspan id="SvgjsTspan1131" style="text-decoration:;">白日依山尽……</tspan></tspan></text></g></g><g id="SvgjsG1132"><path id="SvgjsPath1133" d="M126.46771653579884 125.82320007585415L203.41628150628048 96.73644310583131" stroke-dasharray="8,5" stroke="#9e9e9e" stroke-width="1" fill="none" marker-end="url(#SvgjsMarker1134)"></path></g><g id="SvgjsG1136"><path id="SvgjsPath1137" d="M126.45618079528231 169.7952657154874L203.45781017213994 135.2370083290305" stroke-dasharray="8,5" stroke="#9e9e9e" stroke-width="1" fill="none" marker-end="url(#SvgjsMarker1138)"></path></g><g id="SvgjsG1140"><path id="SvgjsPath1141" d="M126.46372614521476 216.18700096348363L203.430646912383 247.22676296212302" stroke-dasharray="8,5" stroke="#9e9e9e" stroke-width="1" fill="none" marker-end="url(#SvgjsMarker1142)"></path></g><g id="SvgjsG1144"><path id="SvgjsPath1145" d="M126.49225594615876 261.91224782263913L203.32793962898478 248.21587426916324" stroke-dasharray="8,5" stroke="#9e9e9e" stroke-width="1" fill="none" marker-end="url(#SvgjsMarker1146)"></path></g><g id="SvgjsG1148"><path id="SvgjsPath1149" d="M264.5837598996321 95.97356986251678L337.35849243749624 76.95510790656068" stroke="#9e9e9e" stroke-width="1" fill="none" marker-end="url(#SvgjsMarker1150)"></path></g><g id="SvgjsG1152"><path id="SvgjsPath1153" d="M264.49044050823716 134.8123398943827L337.6944422465182 193.3755412850075" stroke="#9e9e9e" stroke-width="1" fill="none" marker-end="url(#SvgjsMarker1154)"></path></g><g id="SvgjsG1156"><path id="SvgjsPath1157" d="M264.478848878035 248.2263037985628L337.73617211524584 311.325276723123" stroke="#9e9e9e" stroke-width="1" fill="none" marker-end="url(#SvgjsMarker1158)"></path></g><g id="SvgjsG1160"><path id="SvgjsPath1161" d="M527.6000061035156 312.49999237060547L592.3000061035157 312.49999237060547" stroke="#9e9e9e" stroke-width="1" fill="none" marker-end="url(#SvgjsMarker1162)"></path></g></svg>
</div>
<p>如上图，经过哈希算法，《静夜思》这首诗的内容被存储在了数组的第一个位置，《陋室铭》和《登鹳雀楼》被存储在了 M 这个位置，并且它们发生了哈希冲突，所以用链表把它们链接起来了。从这里可以看出数据插入只需要计算位置，而且即使发生哈希冲突，也只是将数据放到链表的头部或者尾部，不需要移动数据，所以哈希表的数据插入是非常高效的</p>
<p>虽然使用哈希表存储数据，可以通过哈希算法快速定位到 Key 对应的 Value 的存储位置从而获取对应的值，但是由于经过哈希算法计算后各个 Key 是无法排序的，所以单是哈希表的结构<strong>无法实现范围查询</strong>。因此说<strong>哈希表非常适合等值查询的应用场景</strong></p>
<h3 id="有序数组"> 有序数组</h3>
<p>有序数组的优缺点就更明显了，因为数据有序，可以使用二分法进行查询，其复杂度为 O(log(N))，所以非常适合等值查询和范围查询。但是在每次数据插入时都要移动插入位置之后的所有数据，这个操作的成本就非常高了</p>
<p>如下图，在 EntityX 要插入到 Entity2 后面时，Entity3 和其后面的所有数据都需要往后移动。因此说<strong>有序数组适合在存储静态数据的场景下使用</strong></p>
<div style="text-align: center;">
  <svg id="SvgjsSvg1006" width="582.0000305175781" height="197.39999389648438" xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.com/svgjs"><defs id="SvgjsDefs1007"><marker id="SvgjsMarker1058" markerWidth="14" markerHeight="10" refX="10" refY="5" viewBox="0 0 14 10" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1059" d="M0,0 L14,5 L0,10 L0,0" fill="#f44336" stroke="#f44336" stroke-width="1"></path></marker></defs><g id="SvgjsG1008" transform="translate(25.000015258789062,124.4000015258789)"><path id="SvgjsPath1009" d="M 0 4Q 0 0 4 0L 72.09999084472656 0Q 76.09999084472656 0 76.09999084472656 4L 76.09999084472656 43.599998474121094Q 76.09999084472656 47.599998474121094 72.09999084472656 47.599998474121094L 4 47.599998474121094Q 0 47.599998474121094 0 43.599998474121094Z" stroke="rgba(76,175,80,1)" stroke-width="1" fill-opacity="1" fill="#c8e6c9"></path><g id="SvgjsG1010"><text id="SvgjsText1011" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="57px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="13.174999237060547" transform="rotate(0)"><tspan id="SvgjsTspan1012" dy="16" x="38.5"><tspan id="SvgjsTspan1013" style="text-decoration:;">Entity1</tspan></tspan></text></g></g><g id="SvgjsG1014" transform="translate(101.00001525878906,124.4000015258789)"><path id="SvgjsPath1015" d="M 0 4Q 0 0 4 0L 72.09999084472656 0Q 76.09999084472656 0 76.09999084472656 4L 76.09999084472656 43.599998474121094Q 76.09999084472656 47.599998474121094 72.09999084472656 47.599998474121094L 4 47.599998474121094Q 0 47.599998474121094 0 43.599998474121094Z" stroke="rgba(76,175,80,1)" stroke-width="1" fill-opacity="1" fill="#c8e6c9"></path><g id="SvgjsG1016"><text id="SvgjsText1017" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="57px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="13.174999237060547" transform="rotate(0)"><tspan id="SvgjsTspan1018" dy="16" x="38.5"><tspan id="SvgjsTspan1019" style="text-decoration:;">Entity2</tspan></tspan></text></g></g><g id="SvgjsG1020" transform="translate(177.00001525878906,124.4000015258789)"><path id="SvgjsPath1021" d="M 0 4Q 0 0 4 0L 72.09999084472656 0Q 76.09999084472656 0 76.09999084472656 4L 76.09999084472656 43.599998474121094Q 76.09999084472656 47.599998474121094 72.09999084472656 47.599998474121094L 4 47.599998474121094Q 0 47.599998474121094 0 43.599998474121094Z" stroke="rgba(76,175,80,1)" stroke-width="1" fill-opacity="1" fill="#c8e6c9"></path><g id="SvgjsG1022"><text id="SvgjsText1023" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="57px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="13.174999237060547" transform="rotate(0)"><tspan id="SvgjsTspan1024" dy="16" x="38.5"><tspan id="SvgjsTspan1025" style="text-decoration:;">Entity3</tspan></tspan></text></g></g><g id="SvgjsG1026" transform="translate(252.50001525878906,124.4000015258789)"><path id="SvgjsPath1027" d="M 0 4Q 0 0 4 0L 72.09999084472656 0Q 76.09999084472656 0 76.09999084472656 4L 76.09999084472656 43.599998474121094Q 76.09999084472656 47.599998474121094 72.09999084472656 47.599998474121094L 4 47.599998474121094Q 0 47.599998474121094 0 43.599998474121094Z" stroke="rgba(33,150,243,1)" stroke-width="1" fill-opacity="1" fill="#bbdefb"></path><g id="SvgjsG1028"><text id="SvgjsText1029" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="57px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="13.174999237060547" transform="rotate(0)"><tspan id="SvgjsTspan1030" dy="16" x="38.5"><tspan id="SvgjsTspan1031" style="text-decoration:;">…</tspan></tspan></text></g></g><g id="SvgjsG1032" transform="translate(329.50001525878906,124.4000015258789)"><path id="SvgjsPath1033" d="M 0 4Q 0 0 4 0L 72.09999084472656 0Q 76.09999084472656 0 76.09999084472656 4L 76.09999084472656 43.599998474121094Q 76.09999084472656 47.599998474121094 72.09999084472656 47.599998474121094L 4 47.599998474121094Q 0 47.599998474121094 0 43.599998474121094Z" stroke="rgba(33,150,243,1)" stroke-width="1" fill-opacity="1" fill="#bbdefb"></path><g id="SvgjsG1034"><text id="SvgjsText1035" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="57px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="13.174999237060547" transform="rotate(0)"><tspan id="SvgjsTspan1036" dy="16" x="38.5"><tspan id="SvgjsTspan1037" style="text-decoration:;">…</tspan></tspan></text></g></g><g id="SvgjsG1038" transform="translate(405.00001525878906,124.4000015258789)"><path id="SvgjsPath1039" d="M 0 4Q 0 0 4 0L 72.09999084472656 0Q 76.09999084472656 0 76.09999084472656 4L 76.09999084472656 43.599998474121094Q 76.09999084472656 47.599998474121094 72.09999084472656 47.599998474121094L 4 47.599998474121094Q 0 47.599998474121094 0 43.599998474121094Z" stroke="rgba(76,175,80,1)" stroke-width="1" fill-opacity="1" fill="#c8e6c9"></path><g id="SvgjsG1040"><text id="SvgjsText1041" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="57px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="13.174999237060547" transform="rotate(0)"><tspan id="SvgjsTspan1042" dy="16" x="38.5"><tspan id="SvgjsTspan1043" style="text-decoration:;">EntityM</tspan></tspan></text></g></g><g id="SvgjsG1044" transform="translate(481.00001525878906,124.4000015258789)"><path id="SvgjsPath1045" d="M 0 4Q 0 0 4 0L 72.09999084472656 0Q 76.09999084472656 0 76.09999084472656 4L 76.09999084472656 43.599998474121094Q 76.09999084472656 47.599998474121094 72.09999084472656 47.599998474121094L 4 47.599998474121094Q 0 47.599998474121094 0 43.599998474121094Z" stroke="rgba(76,175,80,1)" stroke-width="1" fill-opacity="1" fill="#c8e6c9"></path><g id="SvgjsG1046"><text id="SvgjsText1047" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="57px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="13.174999237060547" transform="rotate(0)"><tspan id="SvgjsTspan1048" dy="16" x="38.5"><tspan id="SvgjsTspan1049" style="text-decoration:;">EntityN</tspan></tspan></text></g></g><g id="SvgjsG1050" transform="translate(183.00001525878906,41.400001525878906)"><path id="SvgjsPath1051" d="M 0 4Q 0 0 4 0L 73 0Q 77 0 77 4L 77 44Q 77 48 73 48L 4 48Q 0 48 0 44Z" stroke="rgba(27,94,32,1)" stroke-width="1" fill-opacity="1" fill="#99db9b"></path><g id="SvgjsG1052"><text id="SvgjsText1053" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="57px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="13.375" transform="rotate(0)"><tspan id="SvgjsTspan1054" dy="16" x="38.5"><tspan id="SvgjsTspan1055" style="text-decoration:;">EntityX</tspan></tspan></text></g></g><g id="SvgjsG1056"><path id="SvgjsPath1057" d="M176.10000610351562 25L176.10000610351562 71L176.10000610351562 71L176.10000610351562 117" stroke="#f44336" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1058)"></path></g></svg>
</div>
<h3 id="b-树"> B+ 树</h3>
<p>B+ 树是现在 MySQL InnoDB 索引底层实现的数据结构，它一定程度上解决了有序数组插入数据时的低效，也解决了哈希表无法进行范围搜索的问题，并且 B+ 树非常适合在内存、磁盘上存储和访问，相对于哈希表和有序数组而言，它的优势非常明显，毕竟现在很多应用数据量都是海量的</p>
<div style="text-align: center;">
  <svg id="SvgjsSvg1138" width="807" height="248.75001525878906" xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.com/svgjs"><defs id="SvgjsDefs1139"><marker id="SvgjsMarker1194" markerWidth="12" markerHeight="8" refX="9" refY="4" viewBox="0 0 12 8" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1195" d="M0,0 L12,4 L0,8 L0,0" fill="#323232" stroke="#323232" stroke-width="1"></path></marker><marker id="SvgjsMarker1198" markerWidth="12" markerHeight="8" refX="9" refY="4" viewBox="0 0 12 8" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1199" d="M0,0 L12,4 L0,8 L0,0" fill="#323232" stroke="#323232" stroke-width="1"></path></marker><marker id="SvgjsMarker1202" markerWidth="12" markerHeight="8" refX="9" refY="4" viewBox="0 0 12 8" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1203" d="M0,0 L12,4 L0,8 L0,0" fill="#323232" stroke="#323232" stroke-width="1"></path></marker><marker id="SvgjsMarker1206" markerWidth="12" markerHeight="8" refX="9" refY="4" viewBox="0 0 12 8" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1207" d="M0,0 L12,4 L0,8 L0,0" fill="#323232" stroke="#323232" stroke-width="1"></path></marker><marker id="SvgjsMarker1210" markerWidth="12" markerHeight="8" refX="9" refY="4" viewBox="0 0 12 8" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1211" d="M0,0 L12,4 L0,8 L0,0" fill="#323232" stroke="#323232" stroke-width="1"></path></marker><marker id="SvgjsMarker1214" markerWidth="12" markerHeight="8" refX="9" refY="4" viewBox="0 0 12 8" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1215" d="M0,0 L12,4 L0,8 L0,0" fill="#323232" stroke="#323232" stroke-width="1"></path></marker><marker id="SvgjsMarker1218" markerWidth="12" markerHeight="8" refX="9" refY="4" viewBox="0 0 12 8" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1219" d="M0,0 L12,4 L0,8 L0,0" fill="#323232" stroke="#323232" stroke-width="1"></path></marker><marker id="SvgjsMarker1222" markerWidth="12" markerHeight="8" refX="9" refY="4" viewBox="0 0 12 8" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1223" d="M0,0 L12,4 L0,8 L0,0" fill="#323232" stroke="#323232" stroke-width="1"></path></marker><marker id="SvgjsMarker1226" markerWidth="12" markerHeight="8" refX="9" refY="4" viewBox="0 0 12 8" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1227" d="M0,0 L12,4 L0,8 L0,0" fill="#323232" stroke="#323232" stroke-width="1"></path></marker><marker id="SvgjsMarker1230" markerWidth="12" markerHeight="8" refX="9" refY="4" viewBox="0 0 12 8" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1231" d="M0,0 L12,4 L0,8 L0,0" fill="#323232" stroke="#323232" stroke-width="1"></path></marker><marker id="SvgjsMarker1234" markerWidth="12" markerHeight="8" refX="9" refY="4" viewBox="0 0 12 8" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1235" d="M0,0 L12,4 L0,8 L0,0" fill="#323232" stroke="#323232" stroke-width="1"></path></marker><marker id="SvgjsMarker1238" markerWidth="12" markerHeight="8" refX="9" refY="4" viewBox="0 0 12 8" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1239" d="M0,0 L12,4 L0,8 L0,0" fill="#323232" stroke="#323232" stroke-width="1"></path></marker></defs><g id="SvgjsG1140" transform="translate(386.24998474121094,25.00000762939453)"><path id="SvgjsPath1141" d="M 0 4Q 0 0 4 0L 51 0Q 55 0 55 4L 55 29Q 55 33 51 33L 4 33Q 0 33 0 29Z" stroke="rgba(76,175,80,1)" stroke-width="1" fill-opacity="1" fill="#c8e6c9"></path><g id="SvgjsG1142"><text id="SvgjsText1143" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="35px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="5.875" transform="rotate(0)"></text></g></g><g id="SvgjsG1144" transform="translate(118.99998474121094,113.50000762939453)"><path id="SvgjsPath1145" d="M 0 4Q 0 0 4 0L 51 0Q 55 0 55 4L 55 29Q 55 33 51 33L 4 33Q 0 33 0 29Z" stroke="rgba(76,175,80,1)" stroke-width="1" fill-opacity="1" fill="#c8e6c9"></path><g id="SvgjsG1146"><text id="SvgjsText1147" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="35px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="5.875" transform="rotate(0)"></text></g></g><g id="SvgjsG1148" transform="translate(277.24998474121094,113.50000762939453)"><path id="SvgjsPath1149" d="M 0 4Q 0 0 4 0L 51 0Q 55 0 55 4L 55 29Q 55 33 51 33L 4 33Q 0 33 0 29Z" stroke="rgba(76,175,80,1)" stroke-width="1" fill-opacity="1" fill="#c8e6c9"></path><g id="SvgjsG1150"><text id="SvgjsText1151" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="35px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="5.875" transform="rotate(0)"></text></g></g><g id="SvgjsG1152" transform="translate(470.99998474121094,113.50000762939453)"><path id="SvgjsPath1153" d="M 0 4Q 0 0 4 0L 51 0Q 55 0 55 4L 55 29Q 55 33 51 33L 4 33Q 0 33 0 29Z" stroke="rgba(76,175,80,1)" stroke-width="1" fill-opacity="1" fill="#c8e6c9"></path><g id="SvgjsG1154"><text id="SvgjsText1155" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="35px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="5.875" transform="rotate(0)"></text></g></g><g id="SvgjsG1156" transform="translate(626.9999847412109,113.50000762939453)"><path id="SvgjsPath1157" d="M 0 4Q 0 0 4 0L 51 0Q 55 0 55 4L 55 29Q 55 33 51 33L 4 33Q 0 33 0 29Z" stroke="rgba(76,175,80,1)" stroke-width="1" fill-opacity="1" fill="#c8e6c9"></path><g id="SvgjsG1158"><text id="SvgjsText1159" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="35px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="5.875" transform="rotate(0)"></text></g></g><g id="SvgjsG1160" transform="translate(125.99998474121094,185.50000762939453)"><path id="SvgjsPath1161" d="M 0 4Q 0 0 4 0L 51 0Q 55 0 55 4L 55 29Q 55 33 51 33L 4 33Q 0 33 0 29Z" stroke="rgba(76,175,80,1)" stroke-width="1" fill-opacity="1" fill="#c8e6c9"></path><g id="SvgjsG1162"><text id="SvgjsText1163" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="35px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="5.875" transform="rotate(0)"></text></g></g><g id="SvgjsG1164" transform="translate(24.999984741210938,185.50000762939453)"><path id="SvgjsPath1165" d="M 0 4Q 0 0 4 0L 51 0Q 55 0 55 4L 55 29Q 55 33 51 33L 4 33Q 0 33 0 29Z" stroke="rgba(76,175,80,1)" stroke-width="1" fill-opacity="1" fill="#c8e6c9"></path><g id="SvgjsG1166"><text id="SvgjsText1167" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="35px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="5.875" transform="rotate(0)"></text></g></g><g id="SvgjsG1168" transform="translate(212.99998474121094,185.50000762939453)"><path id="SvgjsPath1169" d="M 0 4Q 0 0 4 0L 51 0Q 55 0 55 4L 55 29Q 55 33 51 33L 4 33Q 0 33 0 29Z" stroke="rgba(76,175,80,1)" stroke-width="1" fill-opacity="1" fill="#c8e6c9"></path><g id="SvgjsG1170"><text id="SvgjsText1171" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="35px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="5.875" transform="rotate(0)"></text></g></g><g id="SvgjsG1172" transform="translate(323.99998474121094,185.50000762939453)"><path id="SvgjsPath1173" d="M 0 4Q 0 0 4 0L 51 0Q 55 0 55 4L 55 29Q 55 33 51 33L 4 33Q 0 33 0 29Z" stroke="rgba(76,175,80,1)" stroke-width="1" fill-opacity="1" fill="#c8e6c9"></path><g id="SvgjsG1174"><text id="SvgjsText1175" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="35px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="5.875" transform="rotate(0)"></text></g></g><g id="SvgjsG1176" transform="translate(422.99998474121094,185.50000762939453)"><path id="SvgjsPath1177" d="M 0 4Q 0 0 4 0L 51 0Q 55 0 55 4L 55 29Q 55 33 51 33L 4 33Q 0 33 0 29Z" stroke="rgba(76,175,80,1)" stroke-width="1" fill-opacity="1" fill="#c8e6c9"></path><g id="SvgjsG1178"><text id="SvgjsText1179" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="35px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="5.875" transform="rotate(0)"></text></g></g><g id="SvgjsG1180" transform="translate(521.9999847412109,185.50000762939453)"><path id="SvgjsPath1181" d="M 0 4Q 0 0 4 0L 51 0Q 55 0 55 4L 55 29Q 55 33 51 33L 4 33Q 0 33 0 29Z" stroke="rgba(76,175,80,1)" stroke-width="1" fill-opacity="1" fill="#c8e6c9"></path><g id="SvgjsG1182"><text id="SvgjsText1183" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="35px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="5.875" transform="rotate(0)"></text></g></g><g id="SvgjsG1184" transform="translate(613.9999847412109,185.50000762939453)"><path id="SvgjsPath1185" d="M 0 4Q 0 0 4 0L 51 0Q 55 0 55 4L 55 29Q 55 33 51 33L 4 33Q 0 33 0 29Z" stroke="rgba(76,175,80,1)" stroke-width="1" fill-opacity="1" fill="#c8e6c9"></path><g id="SvgjsG1186"><text id="SvgjsText1187" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="35px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="5.875" transform="rotate(0)"></text></g></g><g id="SvgjsG1188" transform="translate(726.9999847412109,185.50000762939453)"><path id="SvgjsPath1189" d="M 0 4Q 0 0 4 0L 51 0Q 55 0 55 4L 55 29Q 55 33 51 33L 4 33Q 0 33 0 29Z" stroke="rgba(76,175,80,1)" stroke-width="1" fill-opacity="1" fill="#c8e6c9"></path><g id="SvgjsG1190"><text id="SvgjsText1191" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="35px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="5.875" transform="rotate(0)"></text></g></g><g id="SvgjsG1192"><path id="SvgjsPath1193" d="M146.5883167726078 146.99214323289146L153.18198942818213 183.72831945680554" stroke="#323232" stroke-width="1" fill="none" marker-end="url(#SvgjsMarker1194)"></path></g><g id="SvgjsG1196"><path id="SvgjsPath1197" d="M146.0381560928007 146.6916173877775L54.16256787548778 184.81021249921582" stroke="#323232" stroke-width="1" fill="none" marker-end="url(#SvgjsMarker1198)"></path></g><g id="SvgjsG1200"><path id="SvgjsPath1201" d="M304.3225646363858 146.75945329613666L242.03869711858147 184.56600322912294" stroke="#323232" stroke-width="1" fill="none" marker-end="url(#SvgjsMarker1202)"></path></g><g id="SvgjsG1204"><path id="SvgjsPath1205" d="M305.1339270355149 146.82030173587268L350.1177924817168 184.3469488460732" stroke="#323232" stroke-width="1" fill="none" marker-end="url(#SvgjsMarker1206)"></path></g><g id="SvgjsG1208"><path id="SvgjsPath1209" d="M498.11192774115284 146.81530394194175L451.8969899414202 184.3649409042245" stroke="#323232" stroke-width="1" fill="none" marker-end="url(#SvgjsMarker1210)"></path></g><g id="SvgjsG1212"><path id="SvgjsPath1213" d="M498.8971636576995 146.80373268317993L548.0701406418519 184.40659743576708" stroke="#323232" stroke-width="1" fill="none" marker-end="url(#SvgjsMarker1214)"></path></g><g id="SvgjsG1216"><path id="SvgjsPath1217" d="M654.3418708582025 146.9743492784198L642.0691947200412 183.79237769290359" stroke="#323232" stroke-width="1" fill="none" marker-end="url(#SvgjsMarker1218)"></path></g><g id="SvgjsG1220"><path id="SvgjsPath1221" d="M654.9658120187644 146.68168026764036L752.8230065420188 184.8459861317096" stroke="#323232" stroke-width="1" fill="none" marker-end="url(#SvgjsMarker1222)"></path></g><g id="SvgjsG1224"><path id="SvgjsPath1225" d="M413.25985258672705 58.098853322982876L140.31446354911083 113.1441631324765" stroke="#323232" stroke-width="1" fill="none" marker-end="url(#SvgjsMarker1226)"></path></g><g id="SvgjsG1228"><path id="SvgjsPath1229" d="M413.3044182089948 58.22687866185322L306.3540242571891 112.68327191254326" stroke="#323232" stroke-width="1" fill="none" marker-end="url(#SvgjsMarker1230)"></path></g><g id="SvgjsG1232"><path id="SvgjsPath1233" d="M414.16827380877004 58.27393144354829L496.9941440979982 112.51388189844104" stroke="#323232" stroke-width="1" fill="none" marker-end="url(#SvgjsMarker1234)"></path></g><g id="SvgjsG1236"><path id="SvgjsPath1237" d="M414.23720590773274 58.112326527595826L652.7459885417325 113.0956595958699" stroke="#323232" stroke-width="1" fill="none" marker-end="url(#SvgjsMarker1238)"></path></g><g id="SvgjsG1240" transform="translate(339.62498474121094,110.00000762939453)"><path id="SvgjsPath1241" d="M 0 0L 120 0L 120 40L 0 40Z" stroke="none" fill="none"></path><g id="SvgjsG1242"><text id="SvgjsText1243" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="120px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="9.375" transform="rotate(0)"><tspan id="SvgjsTspan1244" dy="16" x="60"><tspan id="SvgjsTspan1245" style="text-decoration:;">…</tspan></tspan></text></g></g><g id="SvgjsG1246" transform="translate(41.99998474121094,183.75000762939453)"><path id="SvgjsPath1247" d="M 0 0L 120 0L 120 40L 0 40Z" stroke="none" fill="none"></path><g id="SvgjsG1248"><text id="SvgjsText1249" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="120px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="9.375" transform="rotate(0)"><tspan id="SvgjsTspan1250" dy="16" x="60"><tspan id="SvgjsTspan1251" style="text-decoration:;">…</tspan></tspan></text></g></g><g id="SvgjsG1252" transform="translate(235.99998474121094,183.75000762939453)"><path id="SvgjsPath1253" d="M 0 0L 120 0L 120 40L 0 40Z" stroke="none" fill="none"></path><g id="SvgjsG1254"><text id="SvgjsText1255" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="120px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="9.375" transform="rotate(0)"><tspan id="SvgjsTspan1256" dy="16" x="60"><tspan id="SvgjsTspan1257" style="text-decoration:;">…</tspan></tspan></text></g></g><g id="SvgjsG1258" transform="translate(438.49998474121094,183.75000762939453)"><path id="SvgjsPath1259" d="M 0 0L 120 0L 120 40L 0 40Z" stroke="none" fill="none"></path><g id="SvgjsG1260"><text id="SvgjsText1261" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="120px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="9.375" transform="rotate(0)"><tspan id="SvgjsTspan1262" dy="16" x="60"><tspan id="SvgjsTspan1263" style="text-decoration:;">…</tspan></tspan></text></g></g><g id="SvgjsG1264" transform="translate(640.9999847412109,183.75000762939453)"><path id="SvgjsPath1265" d="M 0 0L 120 0L 120 40L 0 40Z" stroke="none" fill="none"></path><g id="SvgjsG1266"><text id="SvgjsText1267" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="120px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="9.375" transform="rotate(0)"><tspan id="SvgjsTspan1268" dy="16" x="60"><tspan id="SvgjsTspan1269" style="text-decoration:;">…</tspan></tspan></text></g></g></svg>
</div>
<p>如上图，这是一个 B+ 树的模型，其在 MySQL InnoDB 的实现中每个节点都是一页，每页的默认大小为 16K，所以每页（每个节点）都可以放下多条数据。以 InnoDB 的一个 Int 类型字段索引为例子，每个页可以存储 1000 多条数据，那么上图 3 层的树就可以保存 100 万+的数据了。如果树高 4 层，则可以保存 10 亿+的数据</p>
<p>另外，在优化后，树的第一层一定在内存中，而第二层也大概率在内存中，所以查找数据时磁盘平均的访问次数并不高（InnoDB 还有页缓存）。 一旦数据被定位到某个页后，将其加载到内存中，由于页内的数据是有序的，所以可以使用类似于二分法的方式访问整个页的数据，从而达到快速查询到所需数据的目的。由于 B+ 树在读写上的性能优势，以及适配磁盘的访问方式，其<strong>在数据库引擎领域已被广泛应用</strong></p>
<p>此外还有非常多的数据结构应用在搜索引擎的设计中，例如 LSM 树、跳表等，这里不展开叙述</p>
<p>回到古诗词背诵的需求，目前来看哈希表和有序数组都合适用来实现正排索引的数据结构。一来是因为古诗词的数据量不会太大，内存可以放得下所有数据，二来是这个项目没有范围查询也没有新增数据的需求，三来哈希表和有序数组的实现比 B+树简单</p>
<h2 id="倒排索引"> 倒排索引</h2>
<p>正排索引是实体 ID 到实体内容的关系，利用它可以很好地解决第一个比赛项目的需求。但是第二个需求是给定多个词语，找出内容中包含给定词语的诗词，这个我们就没有办法使用正排索引来处理了</p>
<p>但是如果我们把题库中所有诗词的内容进行分词，然后建立各个词语到诗词名称（或者诗词的 ID）的索引会如何？</p>
<p><svg id="SvgjsSvg1006" width="830" height="293.00001525878906" xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.com/svgjs"><defs id="SvgjsDefs1007"></defs><g id="SvgjsG1008" transform="translate(128,25.00000762939453)"><path id="SvgjsPath1009" d="M 0 0L 120 0L 120 40L 0 40Z" stroke="none" fill="none"></path><g id="SvgjsG1010"><text id="SvgjsText1011" font-family="微软雅黑" text-anchor="middle" font-size="24px" width="120px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="24px" weight="400" font-style="" opacity="1" y="-1" transform="rotate(0)"><tspan id="SvgjsTspan1012" dy="30" x="60"><tspan id="SvgjsTspan1013" style="text-decoration:;">正排索引</tspan></tspan></text></g></g><g id="SvgjsG1014" transform="translate(557,25.00000762939453)"><path id="SvgjsPath1015" d="M 0 0L 120 0L 120 40L 0 40Z" stroke="none" fill="none"></path><g id="SvgjsG1016"><text id="SvgjsText1017" font-family="微软雅黑" text-anchor="middle" font-size="24px" width="120px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="24px" weight="400" font-style="" opacity="1" y="-1" transform="rotate(0)"><tspan id="SvgjsTspan1018" dy="30" x="60"><tspan id="SvgjsTspan1019" style="text-decoration:;">倒排索引</tspan></tspan></text></g></g><g id="SvgjsG1020" transform="translate(25,77.00000762939453)"><path id="SvgjsPath1021" d="M 0 0L 82 0L 82 39L 0 39Z" stroke="rgba(50,50,50,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1022"><text id="SvgjsText1023" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="62px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.875" transform="rotate(0)"><tspan id="SvgjsTspan1024" dy="16" x="41"><tspan id="SvgjsTspan1025" style="text-decoration:;">诗词ID</tspan></tspan></text></g></g><g id="SvgjsG1026" transform="translate(25,115.00000762939453)"><path id="SvgjsPath1027" d="M 0 0L 82 0L 82 39L 0 39Z" stroke="rgba(50,50,50,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1028"><text id="SvgjsText1029" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="62px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.875" transform="rotate(0)"><tspan id="SvgjsTspan1030" dy="16" x="41"><tspan id="SvgjsTspan1031" style="text-decoration:;">1</tspan></tspan></text></g></g><g id="SvgjsG1032" transform="translate(25,153.00000762939453)"><path id="SvgjsPath1033" d="M 0 0L 82 0L 82 39L 0 39Z" stroke="rgba(50,50,50,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1034"><text id="SvgjsText1035" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="62px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.875" transform="rotate(0)"><tspan id="SvgjsTspan1036" dy="16" x="41"><tspan id="SvgjsTspan1037" style="text-decoration:;">2</tspan></tspan></text></g></g><g id="SvgjsG1038" transform="translate(25,191.00000762939453)"><path id="SvgjsPath1039" d="M 0 0L 82 0L 82 39L 0 39Z" stroke="rgba(50,50,50,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1040"><text id="SvgjsText1041" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="62px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.875" transform="rotate(0)"><tspan id="SvgjsTspan1042" dy="16" x="41"><tspan id="SvgjsTspan1043" style="text-decoration:;">3</tspan></tspan></text></g></g><g id="SvgjsG1044" transform="translate(25,229.00000762939453)"><path id="SvgjsPath1045" d="M 0 0L 82 0L 82 39L 0 39Z" stroke="rgba(50,50,50,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1046"><text id="SvgjsText1047" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="62px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.875" transform="rotate(0)"><tspan id="SvgjsTspan1048" dy="16" x="41"><tspan id="SvgjsTspan1049" style="text-decoration:;">4</tspan></tspan></text></g></g><g id="SvgjsG1050" transform="translate(107,77.00000762939453)"><path id="SvgjsPath1051" d="M 0 0L 118 0L 118 39L 0 39Z" stroke="rgba(50,50,50,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1052"><text id="SvgjsText1053" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="98px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.875" transform="rotate(0)"><tspan id="SvgjsTspan1054" dy="16" x="59"><tspan id="SvgjsTspan1055" style="text-decoration:;">诗词名称</tspan></tspan></text></g></g><g id="SvgjsG1056" transform="translate(107,115.00000762939453)"><path id="SvgjsPath1057" d="M 0 0L 118 0L 118 38L 0 38Z" stroke="rgba(50,50,50,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1058"><text id="SvgjsText1059" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="98px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.375" transform="rotate(0)"><tspan id="SvgjsTspan1060" dy="16" x="59"><tspan id="SvgjsTspan1061" style="text-decoration:;">静夜思</tspan></tspan></text></g></g><g id="SvgjsG1062" transform="translate(107,153.00000762939453)"><path id="SvgjsPath1063" d="M 0 0L 118 0L 118 38L 0 38Z" stroke="rgba(50,50,50,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1064"><text id="SvgjsText1065" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="98px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.375" transform="rotate(0)"><tspan id="SvgjsTspan1066" dy="16" x="59"><tspan id="SvgjsTspan1067" style="text-decoration:;">陋室铭</tspan></tspan></text></g></g><g id="SvgjsG1068" transform="translate(107,191.00000762939453)"><path id="SvgjsPath1069" d="M 0 0L 118 0L 118 38L 0 38Z" stroke="rgba(50,50,50,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1070"><text id="SvgjsText1071" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="98px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.375" transform="rotate(0)"><tspan id="SvgjsTspan1072" dy="16" x="59"><tspan id="SvgjsTspan1073" style="text-decoration:;">咏鹅</tspan></tspan></text></g></g><g id="SvgjsG1074" transform="translate(107,229.00000762939453)"><path id="SvgjsPath1075" d="M 0 0L 118 0L 118 39L 0 39Z" stroke="rgba(50,50,50,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1076"><text id="SvgjsText1077" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="98px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.875" transform="rotate(0)"><tspan id="SvgjsTspan1078" dy="16" x="59"><tspan id="SvgjsTspan1079" style="text-decoration:;">登鹳雀楼</tspan></tspan></text></g></g><g id="SvgjsG1080" transform="translate(225,77.00000762939453)"><path id="SvgjsPath1081" d="M 0 0L 153 0L 153 39L 0 39Z" stroke="rgba(50,50,50,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1082"><text id="SvgjsText1083" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="133px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.875" transform="rotate(0)"><tspan id="SvgjsTspan1084" dy="16" x="76.5"><tspan id="SvgjsTspan1085" style="text-decoration:;">诗词内容</tspan></tspan></text></g></g><g id="SvgjsG1086" transform="translate(225,115.00000762939453)"><path id="SvgjsPath1087" d="M 0 0L 153 0L 153 38L 0 38Z" stroke="rgba(50,50,50,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1088"><text id="SvgjsText1089" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="133px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.375" transform="rotate(0)"><tspan id="SvgjsTspan1090" dy="16" x="76.5"><tspan id="SvgjsTspan1091" style="text-decoration:;">床前明月光……</tspan></tspan></text></g></g><g id="SvgjsG1092" transform="translate(225,153.00000762939453)"><path id="SvgjsPath1093" d="M 0 0L 153 0L 153 38L 0 38Z" stroke="rgba(50,50,50,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1094"><text id="SvgjsText1095" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="133px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.375" transform="rotate(0)"><tspan id="SvgjsTspan1096" dy="16" x="76.5"><tspan id="SvgjsTspan1097" style="text-decoration:;">山不在高……</tspan></tspan></text></g></g><g id="SvgjsG1098" transform="translate(225,191.00000762939453)"><path id="SvgjsPath1099" d="M 0 0L 153 0L 153 38L 0 38Z" stroke="rgba(50,50,50,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1100"><text id="SvgjsText1101" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="133px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.375" transform="rotate(0)"><tspan id="SvgjsTspan1102" dy="16" x="76.5"><tspan id="SvgjsTspan1103" style="text-decoration:;">鹅，鹅，鹅……</tspan></tspan></text></g></g><g id="SvgjsG1104" transform="translate(225,229.00000762939453)"><path id="SvgjsPath1105" d="M 0 0L 153 0L 153 39L 0 39Z" stroke="rgba(50,50,50,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1106"><text id="SvgjsText1107" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="133px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.875" transform="rotate(0)"><tspan id="SvgjsTspan1108" dy="16" x="76.5"><tspan id="SvgjsTspan1109" style="text-decoration:;">白日依山尽……</tspan></tspan></text></g></g><g id="SvgjsG1110" transform="translate(452,77.00000762939453)"><path id="SvgjsPath1111" d="M 0 0L 82 0L 82 39L 0 39Z" stroke="rgba(50,50,50,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1112"><text id="SvgjsText1113" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="62px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.875" transform="rotate(0)"><tspan id="SvgjsTspan1114" dy="16" x="41"><tspan id="SvgjsTspan1115" style="text-decoration:;">词项</tspan></tspan></text></g></g><g id="SvgjsG1116" transform="translate(452,115.00000762939453)"><path id="SvgjsPath1117" d="M 0 0L 82 0L 82 39L 0 39Z" stroke="rgba(50,50,50,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1118"><text id="SvgjsText1119" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="62px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.875" transform="rotate(0)"><tspan id="SvgjsTspan1120" dy="16" x="41"><tspan id="SvgjsTspan1121" style="text-decoration:;">明月</tspan></tspan></text></g></g><g id="SvgjsG1122" transform="translate(452,153.00000762939453)"><path id="SvgjsPath1123" d="M 0 0L 82 0L 82 39L 0 39Z" stroke="rgba(50,50,50,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1124"><text id="SvgjsText1125" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="62px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.875" transform="rotate(0)"><tspan id="SvgjsTspan1126" dy="16" x="41"><tspan id="SvgjsTspan1127" style="text-decoration:;">光</tspan></tspan></text></g></g><g id="SvgjsG1128" transform="translate(452,191.00000762939453)"><path id="SvgjsPath1129" d="M 0 0L 82 0L 82 39L 0 39Z" stroke="rgba(50,50,50,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1130"><text id="SvgjsText1131" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="62px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.875" transform="rotate(0)"><tspan id="SvgjsTspan1132" dy="16" x="41"><tspan id="SvgjsTspan1133" style="text-decoration:;">山</tspan></tspan></text></g></g><g id="SvgjsG1134" transform="translate(452,229.00000762939453)"><path id="SvgjsPath1135" d="M 0 0L 82 0L 82 39L 0 39Z" stroke="rgba(50,50,50,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1136"><text id="SvgjsText1137" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="62px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.875" transform="rotate(0)"><tspan id="SvgjsTspan1138" dy="16" x="41"><tspan id="SvgjsTspan1139" style="text-decoration:;">白日</tspan></tspan></text></g></g><g id="SvgjsG1140" transform="translate(534,77.00000762939453)"><path id="SvgjsPath1141" d="M 0 0L 118 0L 118 39L 0 39Z" stroke="rgba(50,50,50,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1142"><text id="SvgjsText1143" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="98px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.875" transform="rotate(0)"><tspan id="SvgjsTspan1144" dy="16" x="59"><tspan id="SvgjsTspan1145" style="text-decoration:;">文档数量</tspan></tspan></text></g></g><g id="SvgjsG1146" transform="translate(534,115.00000762939453)"><path id="SvgjsPath1147" d="M 0 0L 118 0L 118 38L 0 38Z" stroke="rgba(50,50,50,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1148"><text id="SvgjsText1149" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="98px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.375" transform="rotate(0)"><tspan id="SvgjsTspan1150" dy="16" x="59"><tspan id="SvgjsTspan1151" style="text-decoration:;">1</tspan></tspan></text></g></g><g id="SvgjsG1152" transform="translate(534,153.00000762939453)"><path id="SvgjsPath1153" d="M 0 0L 118 0L 118 38L 0 38Z" stroke="rgba(50,50,50,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1154"><text id="SvgjsText1155" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="98px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.375" transform="rotate(0)"><tspan id="SvgjsTspan1156" dy="16" x="59"><tspan id="SvgjsTspan1157" style="text-decoration:;">1</tspan></tspan></text></g></g><g id="SvgjsG1158" transform="translate(534,191.00000762939453)"><path id="SvgjsPath1159" d="M 0 0L 118 0L 118 38L 0 38Z" stroke="rgba(50,50,50,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1160"><text id="SvgjsText1161" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="98px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.375" transform="rotate(0)"><tspan id="SvgjsTspan1162" dy="16" x="59"><tspan id="SvgjsTspan1163" style="text-decoration:;">2</tspan></tspan></text></g></g><g id="SvgjsG1164" transform="translate(534,229.00000762939453)"><path id="SvgjsPath1165" d="M 0 0L 118 0L 118 39L 0 39Z" stroke="rgba(50,50,50,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1166"><text id="SvgjsText1167" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="98px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.875" transform="rotate(0)"><tspan id="SvgjsTspan1168" dy="16" x="59"><tspan id="SvgjsTspan1169" style="text-decoration:;">1</tspan></tspan></text></g></g><g id="SvgjsG1170" transform="translate(652,77.00000762939453)"><path id="SvgjsPath1171" d="M 0 0L 153 0L 153 39L 0 39Z" stroke="rgba(50,50,50,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1172"><text id="SvgjsText1173" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="133px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.875" transform="rotate(0)"><tspan id="SvgjsTspan1174" dy="16" x="76.5"><tspan id="SvgjsTspan1175" style="text-decoration:;">诗词ID</tspan></tspan></text></g></g><g id="SvgjsG1176" transform="translate(652,115.00000762939453)"><path id="SvgjsPath1177" d="M 0 0L 153 0L 153 38L 0 38Z" stroke="rgba(50,50,50,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1178"><text id="SvgjsText1179" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="133px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.375" transform="rotate(0)"><tspan id="SvgjsTspan1180" dy="16" x="76.5"><tspan id="SvgjsTspan1181" style="text-decoration:;">1</tspan></tspan></text></g></g><g id="SvgjsG1182" transform="translate(652,153.00000762939453)"><path id="SvgjsPath1183" d="M 0 0L 153 0L 153 38L 0 38Z" stroke="rgba(50,50,50,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1184"><text id="SvgjsText1185" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="133px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.375" transform="rotate(0)"><tspan id="SvgjsTspan1186" dy="16" x="76.5"><tspan id="SvgjsTspan1187" style="text-decoration:;">1</tspan></tspan></text></g></g><g id="SvgjsG1188" transform="translate(652,191.00000762939453)"><path id="SvgjsPath1189" d="M 0 0L 153 0L 153 38L 0 38Z" stroke="rgba(50,50,50,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1190"><text id="SvgjsText1191" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="133px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.375" transform="rotate(0)"><tspan id="SvgjsTspan1192" dy="16" x="76.5"><tspan id="SvgjsTspan1193" style="text-decoration:;">2，4</tspan></tspan></text></g></g><g id="SvgjsG1194" transform="translate(652,229.00000762939453)"><path id="SvgjsPath1195" d="M 0 0L 153 0L 153 39L 0 39Z" stroke="rgba(50,50,50,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1196"><text id="SvgjsText1197" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="133px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="8.875" transform="rotate(0)"><tspan id="SvgjsTspan1198" dy="16" x="76.5"><tspan id="SvgjsTspan1199" style="text-decoration:;">4</tspan></tspan></text></g></g></svg></p>
<p>如上表，我们把<strong>分词后保存词项到实体 ID 关系的索引称为倒排索引</strong>。根据倒排索引，我们可以获取词项对应的诗词 ID，如果有多个词项，我们会有多个列表，然后做交集即可。根据交集出来的 ID 列表再去正排索引中查找对应的诗词内容即可。这样，第二个比赛项目的需求也满足了</p>
<p>在上面的倒排索引表中，我们除了要保存词项与诗词 ID 的关系外，还需要保存这个词项在对应文档出现的位置，这是因为很多检索的场景中还需要判断关键词前后的内容是否符合搜索要求</p>
<div style="text-align: center;">
  <svg id="SvgjsSvg1298" width="599.8875122070312" height="300.5" xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.com/svgjs"><defs id="SvgjsDefs1299"><marker id="SvgjsMarker1399" markerWidth="12" markerHeight="8" refX="9" refY="4" viewBox="0 0 12 8" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1400" d="M0,0 L12,4 L0,8 L0,0" fill="#323232" stroke="#323232" stroke-width="1"></path></marker><marker id="SvgjsMarker1403" markerWidth="12" markerHeight="8" refX="9" refY="4" viewBox="0 0 12 8" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1404" d="M0,0 L12,4 L0,8 L0,0" fill="#323232" stroke="#323232" stroke-width="1"></path></marker><marker id="SvgjsMarker1407" markerWidth="12" markerHeight="8" refX="9" refY="4" viewBox="0 0 12 8" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1408" d="M0,0 L12,4 L0,8 L0,0" fill="#323232" stroke="#323232" stroke-width="1"></path></marker><marker id="SvgjsMarker1411" markerWidth="12" markerHeight="8" refX="9" refY="4" viewBox="0 0 12 8" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1412" d="M0,0 L12,4 L0,8 L0,0" fill="#323232" stroke="#323232" stroke-width="1"></path></marker><marker id="SvgjsMarker1415" markerWidth="12" markerHeight="8" refX="9" refY="4" viewBox="0 0 12 8" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1416" d="M0,0 L12,4 L0,8 L0,0" fill="#323232" stroke="#323232" stroke-width="1"></path></marker><marker id="SvgjsMarker1419" markerWidth="12" markerHeight="8" refX="9" refY="4" viewBox="0 0 12 8" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1420" d="M0,0 L12,4 L0,8 L0,0" fill="#323232" stroke="#323232" stroke-width="1"></path></marker><marker id="SvgjsMarker1423" markerWidth="12" markerHeight="8" refX="9" refY="4" viewBox="0 0 12 8" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1424" d="M0,0 L12,4 L0,8 L0,0" fill="#323232" stroke="#323232" stroke-width="1"></path></marker><marker id="SvgjsMarker1427" markerWidth="12" markerHeight="8" refX="9" refY="4" viewBox="0 0 12 8" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1428" d="M0,0 L12,4 L0,8 L0,0" fill="#323232" stroke="#323232" stroke-width="1"></path></marker><marker id="SvgjsMarker1431" markerWidth="12" markerHeight="8" refX="9" refY="4" viewBox="0 0 12 8" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1432" d="M0,0 L12,4 L0,8 L0,0" fill="#323232" stroke="#323232" stroke-width="1"></path></marker></defs><g id="SvgjsG1300" transform="translate(37,170)"><path id="SvgjsPath1301" d="M 0 0L 61 0L 61 40L 0 40Z" stroke="none" fill="none"></path><g id="SvgjsG1302"><text id="SvgjsText1303" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="61px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="-4" transform="rotate(0)"><tspan id="SvgjsTspan1304" dy="20" x="30.5"><tspan id="SvgjsTspan1305" style="text-decoration:;">词项</tspan></tspan><tspan id="SvgjsTspan1306" dy="20" x="30.5"><tspan id="SvgjsTspan1307" style="text-decoration:;">（Key）</tspan></tspan></text></g></g><g id="SvgjsG1308" transform="translate(25,124.25)"><path id="SvgjsPath1309" d="M 100 0Q 91 0 91 9L 91 61Q 91 70 78 70Q 91 70 91 79L 91 131Q 91 140 100 140" stroke="rgba(50,50,50,1)" stroke-width="2" fill="none"></path><path id="SvgjsPath1310" d="M 0 0L 100 0L 100 140L 0 140Z" stroke="none" fill="none"></path><g id="SvgjsG1311"><text id="SvgjsText1312" font-family="微软雅黑" text-anchor="end" font-size="13px" width="73px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="end" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="59.375" transform="rotate(0)"></text></g></g><g id="SvgjsG1313" transform="translate(147,179)"><path id="SvgjsPath1314" d="M 0 4Q 0 0 4 0L 59 0Q 63 0 63 4L 63 26.5Q 63 30.5 59 30.5L 4 30.5Q 0 30.5 0 26.5Z" stroke="rgba(76,175,80,1)" stroke-width="1" fill-opacity="1" fill="#c8e6c9"></path><g id="SvgjsG1315"><text id="SvgjsText1316" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="43px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="4.625" transform="rotate(0)"><tspan id="SvgjsTspan1317" dy="16" x="31.5"><tspan id="SvgjsTspan1318" style="text-decoration:;">…</tspan></tspan></text></g></g><g id="SvgjsG1319" transform="translate(147,209.5)"><path id="SvgjsPath1320" d="M 0 4Q 0 0 4 0L 59 0Q 63 0 63 4L 63 27Q 63 31 59 31L 4 31Q 0 31 0 27Z" stroke="rgba(76,175,80,1)" stroke-width="1" fill-opacity="1" fill="#c8e6c9"></path><g id="SvgjsG1321"><text id="SvgjsText1322" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="43px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="4.875" transform="rotate(0)"><tspan id="SvgjsTspan1323" dy="16" x="31.5"><tspan id="SvgjsTspan1324" style="text-decoration:;">…</tspan></tspan></text></g></g><g id="SvgjsG1325" transform="translate(147,242.5)"><path id="SvgjsPath1326" d="M 0 4Q 0 0 4 0L 59 0Q 63 0 63 4L 63 28.5Q 63 32.5 59 32.5L 4 32.5Q 0 32.5 0 28.5Z" stroke="rgba(255,152,0,1)" stroke-width="1" fill-opacity="1" fill="#ffe0b2"></path><g id="SvgjsG1327"><text id="SvgjsText1328" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="43px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="5.625" transform="rotate(0)"><tspan id="SvgjsTspan1329" dy="16" x="31.5"><tspan id="SvgjsTspan1330" style="text-decoration:;">termM</tspan></tspan></text></g></g><g id="SvgjsG1331" transform="translate(147,143.5)"><path id="SvgjsPath1332" d="M 0 4Q 0 0 4 0L 59 0Q 63 0 63 4L 63 28.5Q 63 32.5 59 32.5L 4 32.5Q 0 32.5 0 28.5Z" stroke="rgba(255,152,0,1)" stroke-width="1" fill-opacity="1" fill="#ffe0b2"></path><g id="SvgjsG1333"><text id="SvgjsText1334" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="43px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="5.625" transform="rotate(0)"><tspan id="SvgjsTspan1335" dy="16" x="31.5"><tspan id="SvgjsTspan1336" style="text-decoration:;">term2</tspan></tspan></text></g></g><g id="SvgjsG1337" transform="translate(147,109)"><path id="SvgjsPath1338" d="M 0 4Q 0 0 4 0L 59 0Q 63 0 63 4L 63 28.5Q 63 32.5 59 32.5L 4 32.5Q 0 32.5 0 28.5Z" stroke="rgba(255,152,0,1)" stroke-width="1" fill-opacity="1" fill="#ffe0b2"></path><g id="SvgjsG1339"><text id="SvgjsText1340" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="43px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="5.625" transform="rotate(0)"><tspan id="SvgjsTspan1341" dy="16" x="31.5"><tspan id="SvgjsTspan1342" style="text-decoration:;">term1</tspan></tspan></text></g></g><g id="SvgjsG1343" transform="translate(296,110)"><path id="SvgjsPath1344" d="M 0 4Q 0 0 4 0L 58.109540636042404 0Q 62.109540636042404 0 62.109540636042404 4L 62.109540636042404 25.5Q 62.109540636042404 29.5 58.109540636042404 29.5L 4 29.5Q 0 29.5 0 25.5Z" stroke="rgba(255,235,59,1)" stroke-width="1" fill-opacity="1" fill="#fff9c4"></path><g id="SvgjsG1345"><text id="SvgjsText1346" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="43px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="4.125" transform="rotate(0)"><tspan id="SvgjsTspan1347" dy="16" x="31.5"><tspan id="SvgjsTspan1348" style="text-decoration:;">doc1</tspan></tspan></text></g></g><g id="SvgjsG1349" transform="translate(404.44522968197884,110)"><path id="SvgjsPath1350" d="M 0 4Q 0 0 4 0L 58.109540636042404 0Q 62.109540636042404 0 62.109540636042404 4L 62.109540636042404 25.5Q 62.109540636042404 29.5 58.109540636042404 29.5L 4 29.5Q 0 29.5 0 25.5Z" stroke="rgba(255,235,59,1)" stroke-width="1" fill-opacity="1" fill="#fff9c4"></path><g id="SvgjsG1351"><text id="SvgjsText1352" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="43px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="4.125" transform="rotate(0)"><tspan id="SvgjsTspan1353" dy="16" x="31.5"><tspan id="SvgjsTspan1354" style="text-decoration:;">doc12</tspan></tspan></text></g></g><g id="SvgjsG1355" transform="translate(512.8904593639576,110)"><path id="SvgjsPath1356" d="M 0 4Q 0 0 4 0L 58.109540636042404 0Q 62.109540636042404 0 62.109540636042404 4L 62.109540636042404 25.5Q 62.109540636042404 29.5 58.109540636042404 29.5L 4 29.5Q 0 29.5 0 25.5Z" stroke="rgba(255,235,59,1)" stroke-width="1" fill-opacity="1" fill="#fff9c4"></path><g id="SvgjsG1357"><text id="SvgjsText1358" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="43px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="4.125" transform="rotate(0)"><tspan id="SvgjsTspan1359" dy="16" x="31.5"><tspan id="SvgjsTspan1360" style="text-decoration:;">doc23</tspan></tspan></text></g></g><g id="SvgjsG1361" transform="translate(296,145)"><path id="SvgjsPath1362" d="M 0 4Q 0 0 4 0L 58.109540636042404 0Q 62.109540636042404 0 62.109540636042404 4L 62.109540636042404 25.5Q 62.109540636042404 29.5 58.109540636042404 29.5L 4 29.5Q 0 29.5 0 25.5Z" stroke="rgba(255,235,59,1)" stroke-width="1" fill-opacity="1" fill="#fff9c4"></path><g id="SvgjsG1363"><text id="SvgjsText1364" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="43px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="4.125" transform="rotate(0)"><tspan id="SvgjsTspan1365" dy="16" x="31.5"><tspan id="SvgjsTspan1366" style="text-decoration:;">doc10</tspan></tspan></text></g></g><g id="SvgjsG1367" transform="translate(404.44522968197884,145)"><path id="SvgjsPath1368" d="M 0 4Q 0 0 4 0L 58.109540636042404 0Q 62.109540636042404 0 62.109540636042404 4L 62.109540636042404 25.5Q 62.109540636042404 29.5 58.109540636042404 29.5L 4 29.5Q 0 29.5 0 25.5Z" stroke="rgba(255,235,59,1)" stroke-width="1" fill-opacity="1" fill="#fff9c4"></path><g id="SvgjsG1369"><text id="SvgjsText1370" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="43px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="4.125" transform="rotate(0)"><tspan id="SvgjsTspan1371" dy="16" x="31.5"><tspan id="SvgjsTspan1372" style="text-decoration:;">doc12</tspan></tspan></text></g></g><g id="SvgjsG1373" transform="translate(512.8904593639576,145)"><path id="SvgjsPath1374" d="M 0 4Q 0 0 4 0L 58.109540636042404 0Q 62.109540636042404 0 62.109540636042404 4L 62.109540636042404 25.5Q 62.109540636042404 29.5 58.109540636042404 29.5L 4 29.5Q 0 29.5 0 25.5Z" stroke="rgba(255,235,59,1)" stroke-width="1" fill-opacity="1" fill="#fff9c4"></path><g id="SvgjsG1375"><text id="SvgjsText1376" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="43px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="4.125" transform="rotate(0)"><tspan id="SvgjsTspan1377" dy="16" x="31.5"><tspan id="SvgjsTspan1378" style="text-decoration:;">doc43</tspan></tspan></text></g></g><g id="SvgjsG1379" transform="translate(296,244)"><path id="SvgjsPath1380" d="M 0 4Q 0 0 4 0L 58.109540636042404 0Q 62.109540636042404 0 62.109540636042404 4L 62.109540636042404 25.5Q 62.109540636042404 29.5 58.109540636042404 29.5L 4 29.5Q 0 29.5 0 25.5Z" stroke="rgba(255,235,59,1)" stroke-width="1" fill-opacity="1" fill="#fff9c4"></path><g id="SvgjsG1381"><text id="SvgjsText1382" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="43px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="4.125" transform="rotate(0)"><tspan id="SvgjsTspan1383" dy="16" x="31.5"><tspan id="SvgjsTspan1384" style="text-decoration:;">doc9</tspan></tspan></text></g></g><g id="SvgjsG1385" transform="translate(404.44522968197884,244)"><path id="SvgjsPath1386" d="M 0 4Q 0 0 4 0L 58.109540636042404 0Q 62.109540636042404 0 62.109540636042404 4L 62.109540636042404 25.5Q 62.109540636042404 29.5 58.109540636042404 29.5L 4 29.5Q 0 29.5 0 25.5Z" stroke="rgba(255,235,59,1)" stroke-width="1" fill-opacity="1" fill="#fff9c4"></path><g id="SvgjsG1387"><text id="SvgjsText1388" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="43px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="4.125" transform="rotate(0)"><tspan id="SvgjsTspan1389" dy="16" x="31.5"><tspan id="SvgjsTspan1390" style="text-decoration:;">doc22</tspan></tspan></text></g></g><g id="SvgjsG1391" transform="translate(512.8904593639576,244)"><path id="SvgjsPath1392" d="M 0 4Q 0 0 4 0L 58.109540636042404 0Q 62.109540636042404 0 62.109540636042404 4L 62.109540636042404 25.5Q 62.109540636042404 29.5 58.109540636042404 29.5L 4 29.5Q 0 29.5 0 25.5Z" stroke="rgba(255,235,59,1)" stroke-width="1" fill-opacity="1" fill="#fff9c4"></path><g id="SvgjsG1393"><text id="SvgjsText1394" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="43px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="4.125" transform="rotate(0)"><tspan id="SvgjsTspan1395" dy="16" x="31.5"><tspan id="SvgjsTspan1396" style="text-decoration:;">doc23</tspan></tspan></text></g></g><g id="SvgjsG1397"><path id="SvgjsPath1398" d="M210.5 125.25L253 125.25L253 125.25L294.2 125.25" stroke="#323232" stroke-width="1" fill="none" marker-end="url(#SvgjsMarker1399)"></path></g><g id="SvgjsG1401"><path id="SvgjsPath1402" d="M210.5 159.75L253 159.75L253 159.75L294.2 159.75" stroke="#323232" stroke-width="1" fill="none" marker-end="url(#SvgjsMarker1403)"></path></g><g id="SvgjsG1405"><path id="SvgjsPath1406" d="M210.5 258.75L253 258.75L253 258.75L294.2 258.75" stroke="#323232" stroke-width="1" fill="none" marker-end="url(#SvgjsMarker1407)"></path></g><g id="SvgjsG1409"><path id="SvgjsPath1410" d="M358.6095406360424 124.75L381.2773851590107 124.75L381.2773851590107 124.75L402.64522968197883 124.75" stroke="#323232" stroke-width="1" fill="none" marker-end="url(#SvgjsMarker1411)"></path></g><g id="SvgjsG1413"><path id="SvgjsPath1414" d="M467.05477031802127 124.75L489.7226148409894 124.75L489.7226148409894 124.75L511.0904593639575 124.75" stroke="#323232" stroke-width="1" fill="none" marker-end="url(#SvgjsMarker1415)"></path></g><g id="SvgjsG1417"><path id="SvgjsPath1418" d="M358.6095406360424 159.75L381.2773851590107 159.75L381.2773851590107 159.75L402.64522968197883 159.75" stroke="#323232" stroke-width="1" fill="none" marker-end="url(#SvgjsMarker1419)"></path></g><g id="SvgjsG1421"><path id="SvgjsPath1422" d="M467.05477031802127 159.75L489.7226148409894 159.75L489.7226148409894 159.75L511.0904593639575 159.75" stroke="#323232" stroke-width="1" fill="none" marker-end="url(#SvgjsMarker1423)"></path></g><g id="SvgjsG1425"><path id="SvgjsPath1426" d="M358.6095406360424 258.75L381.2773851590107 258.75L381.2773851590107 258.75L402.64522968197883 258.75" stroke="#323232" stroke-width="1" fill="none" marker-end="url(#SvgjsMarker1427)"></path></g><g id="SvgjsG1429"><path id="SvgjsPath1430" d="M467.05477031802127 258.75L489.7226148409894 258.75L489.7226148409894 258.75L511.0904593639575 258.75" stroke="#323232" stroke-width="1" fill="none" marker-end="url(#SvgjsMarker1431)"></path></g><g id="SvgjsG1433" transform="matrix(-1.8369701987210297e-16,-1,1,-1.8369701987210297e-16,302,93.00000000000003)"><path id="SvgjsPath1434" d="M 0 270Q 6.800000000000001 270 6.800000000000001 261L 6.800000000000001 144Q 6.800000000000001 135 22 135Q 6.800000000000001 135 6.800000000000001 126L 6.800000000000001 9Q 6.800000000000001 0 0 0" stroke="rgba(50,50,50,1)" stroke-width="2" fill="none"></path><path id="SvgjsPath1435" d="M 0 0L 68 0L 68 270L 0 270Z" stroke="none" fill="none"></path><g id="SvgjsG1436"><text id="SvgjsText1437" font-family="微软雅黑" text-anchor="start" font-size="13px" width="41px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="start" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="124.375" transform="rotate(0)"></text></g></g><g id="SvgjsG1438" transform="translate(375.5,36)"><path id="SvgjsPath1439" d="M 0 0L 120 0L 120 29L 0 29Z" stroke="none" fill="none"></path><g id="SvgjsG1440"><text id="SvgjsText1441" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="120px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="0.5" transform="rotate(0)"><tspan id="SvgjsTspan1442" dy="20" x="60"><tspan id="SvgjsTspan1443" style="text-decoration:;">文档列表</tspan></tspan></text></g></g></svg>
</div>
<p>如上图，这个倒排索引使用哈希表来实现也是可以的，其有着 O(1) 查询复杂度，能完美地满足我们的需求。但是呢，现实中数据往往是海量的，如果简单地使用哈希表来实现倒排索引是不可行的，因为存储海量的数据时，系统将会面临下面几个问题：</p>
<ul>
<li>分词形成的词项（term）可能是海量的，需要可以在内存和磁盘上高效存储</li>
<li>既然词项是海量的，那么如何快速找到对应的词项也是个问题</li>
<li>每个词项对应的文档数可能非常多，也就是上图中文档列表的链表很长</li>
<li>在词项对应的文档多的情况下，多个文档列表间做交集的效率将是个挑战</li>
</ul>
<p>其实这四个问题可以分为两个方面：<strong>词项</strong>方面的问题和<strong>文档列表</strong>方面的问题</p>
<p>在 Lucene 的倒排索引的实现中，其使用词项索引（Term Index）来解决上述 1 和 2 的问题，而对于 3 和 4，Lucene 对数据进行了压缩处理，使用 Roaring Bitmaps、跳表等技术来进行快速求交集</p>
<p>具体的实现方式就不展开描述了，后面有需要的时候再进行深入的研究</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">搜索词自动补全语法</title>
    <id>https://www.snowji.cn/databases/es/suggester-query/</id>
    <link href="https://www.snowji.cn/databases/es/suggester-query/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="搜索词自动补全语法"> 搜索词自动补全语法</h1>
<h2 id="前言"> 前言</h2>
<p>搜索词自动补全的功能可以改善用户的搜索体验具体的表现形式就是当用户在搜索框输入部分内容后，出现对应的推荐选项，让用户可以快速选择这种自动补全或纠错的功能在现代搜索引擎中都很常见</p>
<p>想要实现这样的需求，可以使用 ES 提供的 Suggesters API它的原理简单来说，就是 Suggesters 会将输入的文本分解为 token（token 就是根据规则切分文本后一个个的词），然后在索引里查找相似的 Term</p>
<p>根据使用场景的不同，ES 提供了以下 4 种 Suggester：</p>
<ul>
<li><strong>Term Suggester</strong>：基于单词的纠错补全</li>
<li><strong>Phrase Suggester</strong>：基于短语的纠错补全</li>
<li><strong>Completion Suggester</strong>：自动补全单词，输入词语的前半部分，自动补全单词</li>
<li><strong>Context Suggester</strong>：基于上下文的补全提示，可以实现上下文感知推荐</li>
</ul>
<h2 id="term-suggester"> Term Suggester</h2>
<p>Term Suggester 提供了基于单词的纠错、补全功能，其工作原理是基于编辑距离（edit distance）来运作的，编辑距离的<strong>核心思想是一个词需要改变多少个字符就可以和另一个词一致</strong></p>
<p>所以如果一个词转化为原词所需要改动的字符数越少，它越有可能是最佳匹配（例如 <code>linvx</code> 通过改变一个字符 <code>v</code> 可以转化成 <code>linux</code>）</p>
<p>Term Suggester 工作的时候，会先将输入的文本切分为一个个单词（称为 token），然后根据每个单词提供建议，所以其不会考虑输入文本间各个单词的关系</p>
<p>示例如下：</p>
<div><pre><code><span># Term Suggester，"architture" 是错误的拼写，正确的是 "architecture"</span>
POST books/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"match"</span><span>:</span> <span>{</span>
      <span>"name"</span><span>:</span> <span>"kernel architture"</span>
    <span>}</span>
  <span>}</span>,
  
  <span>"suggest"</span><span>:</span> <span>{</span>
    <span>"my_suggest"</span><span>:</span> <span>{</span>
      <span>"text"</span><span>:</span> <span>"kernel architture"</span>,
      <span>"term"</span><span>:</span> <span>{</span>
        <span>"suggest_mode"</span><span>:</span> <span>"missing"</span>,
        <span>"field"</span><span>:</span> <span>"name"</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>上述示例里，用户搜索词中的 <code>architture</code> 是错误的拼写Suggester API 需要在 <code>suggest</code> 块中指定使用的参数<code>my_suggest</code> 是这次建议的名字，是我们自定义的<code>term</code> 指的是使用 Term Suggester，如果是 Phrase Suggester 则用的是 <code>phrase</code></p>
<p>Term Suggester 比较常用的参数：</p>
<ul>
<li><strong><code>text</code></strong>：指定需要产生建议的文本，一般是照搬用户的输入内容</li>
<li><strong><code>field</code></strong>：指定从文档的哪个字段中获取建议</li>
<li><strong><code>suggest_mode</code></strong>：设置建议的模式其值有以下几个选项：
<ul>
<li><code>missing</code>：如果索引中存在就不进行建议，默认的选项上例中的 <code>kernel</code> 是存在索引中的，所以返回结果里这个词是没有建议的</li>
<li><code>popular</code>：推荐出现频率更高的词</li>
<li><code>always</code>：不管是否存在，都进行建议</li>
</ul>
</li>
<li><strong><code>analyzer</code></strong>：指定分词器来对输入文本进行分词，默认与 <code>field</code> 指定的字段设置的分词器一致</li>
<li><strong><code>size</code></strong>：为每个单词提供的最大建议数量</li>
<li><strong><code>sort</code></strong>：建议结果排序的方式，有以下两个选项：
<ul>
<li><code>score</code>：先按相似性得分排序，然后按文档频率排序，最后按词项本身（字母顺序的等）排序</li>
<li><code>frequency</code>：先按文档频率排序，然后按相似性得分排序，最后按词项本身排序</li>
</ul>
</li>
</ul>
<p>下面是上述示例的返回结果：</p>
<div><pre><code><span># 返回的结果</span>
<span>{</span>
  <span>"hits"</span> <span>:</span> <span>{</span>
    <span>"hits"</span> <span>:</span> <span>[</span>
      <span>{</span>
        <span>"_id"</span> <span>:</span> <span>"1"</span>,
        <span>"_source"</span> <span>:</span> <span>{</span>
          <span>"book_id"</span> <span>:</span> <span>"4ee82462"</span>,
          <span>"name"</span> <span>:</span> <span>"Dive into the Linux kernel architecture"</span>
        <span>}</span>
      <span>}</span>
    <span>]</span>
  <span>}</span>,
  <span>"suggest"</span> <span>:</span> <span>{</span>
    <span>"my_suggest"</span> <span>:</span> <span>[</span>
      <span>{</span>
        <span>"text"</span> <span>:</span> <span>"kernel"</span>,
        <span>"offset"</span> <span>:</span> <span>0</span>,
        <span>"length"</span> <span>:</span> <span>6</span>,
        <span>"options"</span> <span>:</span> <span>[</span> <span>]</span>
      <span>}</span>,
      <span>{</span>
        <span>"text"</span> <span>:</span> <span>"architture"</span>,
        <span>"offset"</span> <span>:</span> <span>7</span>,
        <span>"length"</span> <span>:</span> <span>10</span>,
        <span>"options"</span> <span>:</span> <span>[</span>
          <span>{</span>
            <span>"text"</span> <span>:</span> <span>"architecture"</span>,
            <span>"score"</span> <span>:</span> <span>0.8</span>,
            <span>"freq"</span> <span>:</span> <span>1</span>
          <span>}</span>
        <span>]</span>
      <span>}</span>
    <span>]</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><p>从返回结果中可以看出，对于每个词语的建议结果，放在了 <code>options</code> 数组中如果一个词语有多个建议，那么将按照 <code>sort</code> 参数指定的方式进行排序示例中，由于 <code>kernel</code> 这个词是有存在的，并且设置了 <code>&quot;suggest_mode&quot;: &quot;missing&quot;</code>，所以不进行建议，其 <code>option</code> 是空的</p>
<h2 id="phrase-suggester"> Phrase Suggester</h2>
<p>Term Suggester 产生的建议是基于每个单词的，如果想要针对整个短语或者一句话做建议，就有点无能为力了</p>
<p>而 Phrase Suggester 可以获取与用户输入文本相似的内容它在前者的基础上增加了一些额外的逻辑，因为是短语形式的建议，所以会考量多个 term 间的关系，比如相邻的程度、词频等</p>
<div><pre><code><span># Phrase Suggester 使用示例</span>
POST books/_search
<span>{</span>
  
  <span>"suggest"</span><span>:</span> <span>{</span>
    <span>"my_suggest"</span><span>:</span> <span>{</span>
      <span>"text"</span><span>:</span> <span>"Brief Hestory Of Tome"</span>,
      <span>"phrase"</span><span>:</span> <span>{</span>
        <span>"field"</span><span>:</span> <span>"name"</span>,
        <span>"highlight"</span><span>:</span> <span>{</span>
          <span>"pre_tag"</span><span>:</span> <span>"&lt;em>"</span>,
          <span>"post_tag"</span><span>:</span> <span>"&lt;/em>"</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

<span># 结果</span>
<span>{</span>
  <span>..</span><span>..</span><span>..</span>
  <span>"suggest"</span> <span>:</span> <span>{</span>
    <span>"my_suggest"</span> <span>:</span> <span>[</span>
      <span>{</span>
        <span>..</span><span>..</span><span>..</span>
        <span>"options"</span> <span>:</span> <span>[</span>
          <span>{</span>
            <span>"text"</span> <span>:</span> <span>"brief history of time"</span>,
            <span>"highlighted"</span> <span>:</span> <span>"brief &lt;em>history&lt;/em> of &lt;em>time&lt;/em>"</span>,
            <span>"score"</span> <span>:</span> <span>0.030559132</span>
          <span>}</span>,
          <span>{</span>
            <span>"text"</span> <span>:</span> <span>"brief history of tome"</span>,
            <span>"highlighted"</span> <span>:</span> <span>"brief &lt;em>history&lt;/em> of tome"</span>,
            <span>"score"</span> <span>:</span> <span>0.025060574</span>
          <span>}</span>,
          <span>{</span>
            <span>"text"</span> <span>:</span> <span>"brief hestory of time"</span>,
            <span>"highlighted"</span> <span>:</span> <span>"brief hestory of &lt;em>time&lt;/em>"</span>,
            <span>"score"</span> <span>:</span> <span>0.0236486</span>
          <span>}</span>
        <span>]</span>
      <span>}</span>
    <span>]</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><p>如上示例，<code>phrase</code> 指定使用 Phrase Suggester从返回结果可以看出，&quot;options&quot; 返回了一个短语列表，并且因为 &quot;history&quot; 和 &quot;time&quot; 在一个文档里出现过，其可信度相对于其他来说更高，所以得分更高</p>
<p>因为使用了 <code>highlight</code> 选项，所以返回结果中被替换的词语会高亮显示</p>
<p>Phrase Suggester 比较常用的参数：</p>
<ul>
<li><strong><code>max_error</code></strong>：指定最多可以拼写错误的词语的个数</li>
<li><strong><code>confidence</code></strong>：其作用是用来控制返回结果条数的如果用户输入的数据（短语）得分为 <code>N</code>，那么返回结果的得分需要大于 <code>N * confidence</code>confidence 默认值为 1.0</li>
<li><strong><code>highlight</code></strong>：高亮被修改后的词语</li>
</ul>
<h2 id="completion-suggester"> Completion Suggester</h2>
<p><strong>Completion Suggester 提供了自动补全的功能，其应用场景是用户每输入一个字符就需要返回匹配的结果给用户</strong></p>
<p>在并发量大、用户输入速度快的时候，对服务的吞吐量来说是个不小的挑战所以 Completion Suggester 不能像上面的几个 Suggester 那样简单通过倒排索引来实现，必须通过某些更高效的数据结构和算法才能满足需求</p>
<p><strong>Completion Suggester 在实现的时候会将 analyze（将文本分词，并且去除没用的词语，例如 is、at这样的词语） 后的数据进行编码，构建为 FST 并且和索引存放在一起</strong>FST（<a href="https://en.wikipedia.org/wiki/Finite-state_transducer" target="_blank" rel="noopener noreferrer">finite-state transducer</a>）是一种高效的前缀查询索引由于 FST 天生为前缀查询而生，所以其非常适合实现自动补全的功能ES 会将整个 FST 加载到内存中，所以在使用 FST 进行前缀查询的时候效率是非常高效的</p>
<p>在使用 Completion Suggester 前需要定义 Mapping，对应的字段需要使用 <code>completion</code> type</p>
<p>比如构建一个新的 <code>books_completion</code> 索引，其 Mapping 和测试数据如下：</p>
<div><pre><code><span># 先删除原来的索引和数据</span>
DELETE books_completion

<span># 新增 "name_completion" 字段做 Completion Suggester 测试, 其类型为 "completion"</span>
PUT books_completion
<span>{</span>
  <span>"mappings"</span><span>:</span> <span>{</span>
    <span>"properties"</span><span>:</span> <span>{</span>
        <span>"book_id"</span><span>:</span> <span>{</span>
          <span>"type"</span><span>:</span> <span>"keyword"</span>
        <span>}</span>,
        <span>"name"</span><span>:</span> <span>{</span>
          <span>"type"</span><span>:</span> <span>"text"</span>,
          <span>"analyzer"</span><span>:</span> <span>"standard"</span>
        <span>}</span>,
        <span>"name_completion"</span><span>:</span> <span>{</span>
          <span>"type"</span><span>:</span> <span>"completion"</span>
        <span>}</span>,
        <span>"author"</span><span>:</span> <span>{</span>
          <span>"type"</span><span>:</span> <span>"keyword"</span>
        <span>}</span>,
        <span>"intro"</span><span>:</span> <span>{</span>
          <span>"type"</span><span>:</span> <span>"text"</span>
        <span>}</span>,
        <span>"price"</span><span>:</span> <span>{</span>
          <span>"type"</span><span>:</span> <span>"double"</span>
        <span>}</span>,
        <span>"date"</span><span>:</span> <span>{</span>
          <span>"type"</span><span>:</span> <span>"date"</span>
        <span>}</span>
      <span>}</span>
  <span>}</span>,
  <span>"settings"</span><span>:</span> <span>{</span>
    <span>"number_of_shards"</span><span>:</span> <span>3</span>,
    <span>"number_of_replicas"</span><span>:</span> <span>1</span>
  <span>}</span>
<span>}</span>

<span># 插入三条测试数据</span>
PUT books_completion/_doc/1
<span>{</span>
  <span>"book_id"</span><span>:</span> <span>"4ee82462"</span>,
  <span>"name"</span><span>:</span> <span>"Dive into the Linux kernel architecture"</span>,
  <span>"name_completion"</span><span>:</span> <span>"Dive into the Linux kernel architecture"</span>,
  <span>"author"</span><span>:</span> <span>"Wolfgang Mauerer"</span>,
  <span>"intro"</span><span>:</span> <span>"The content is comprehensive and in-depth, appreciate the infinite scenery of the Linux kernel."</span>,
  <span>"price"</span><span>:</span> <span>19.9</span>,
  <span>"date"</span><span>:</span> <span>"2010-06-01"</span>
<span>}</span>

PUT books_completion/_doc/2
<span>{</span>
  <span>"book_id"</span><span>:</span> <span>"4ee82463"</span>,
  <span>"name"</span><span>:</span> <span>"A Brief History Of Time"</span>,
  <span>"name_completion"</span><span>:</span> <span>"A Brief History Of Time"</span>,
  <span>"author"</span><span>:</span> <span>"Stephen Hawking"</span>,
  <span>"intro"</span><span>:</span> <span>"A fascinating story that explores the secrets at the heart of time and space."</span>,
  <span>"price"</span><span>:</span> <span>9.9</span>,
  <span>"date"</span><span>:</span> <span>"1988-01-01"</span>
<span>}</span>

PUT books_completion/_doc/3
<span>{</span>
  <span>"book_id"</span><span>:</span> <span>"4ee82464"</span>,
  <span>"name"</span><span>:</span> <span>"Beginning Linux Programming 4th Edition"</span>,
  <span>"name_completion"</span><span>:</span> <span>"Beginning Linux Programming 4th Edition"</span>,
  <span>"author"</span><span>:</span> <span>"Neil Matthew、Richard Stones"</span>,
  <span>"intro"</span><span>:</span> <span>"Describes the Linux system and other UNIX-style operating system on the program development"</span>,
  <span>"price"</span><span>:</span> <span>12.9</span>,
  <span>"date"</span><span>:</span> <span>"2010-06-01"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br></div></div><p>在测试数据准备好后，可以执行下面 Completion Suggester 的使用示例：</p>
<div><pre><code><span># Completion Suggester </span>
POST books_completion/_search
<span>{</span>
  
  <span>"suggest"</span><span>:</span> <span>{</span>
    <span>"my_suggest"</span><span>:</span> <span>{</span>
      <span>"prefix"</span><span>:</span> <span>"a brief hist"</span>,
      <span>"completion"</span><span>:</span> <span>{</span>
        <span>"field"</span><span>:</span> <span>"name_completion"</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

<span># 结果</span>
<span>{</span>
  <span>..</span><span>..</span><span>..</span>
  <span>"suggest"</span> <span>:</span> <span>{</span>
    <span>"my_suggest"</span> <span>:</span> <span>[</span>
      <span>{</span>
        <span>"text"</span> <span>:</span> <span>"a brief hist"</span>,
        <span>"offset"</span> <span>:</span> <span>0</span>,
        <span>"length"</span> <span>:</span> <span>12</span>,
        <span>"options"</span> <span>:</span> <span>[</span>
          <span>{</span>
            <span>"text"</span> <span>:</span> <span>"A Brief History Of Time"</span>,
            <span>"_id"</span> <span>:</span> <span>"2"</span>,
            <span>"_source"</span> <span>:</span> <span>{</span>
              <span>"book_id"</span> <span>:</span> <span>"4ee82463"</span>,
              <span>"name_completion"</span> <span>:</span> <span>"A Brief History Of Time"</span>,
              <span>..</span><span>..</span><span>..</span>
            <span>}</span>
          <span>}</span>
        <span>]</span>
      <span>}</span>
    <span>]</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><p>如上示例，在 <code>my_suggest</code> 中，<code>prefix</code> 指定了需要匹配的前缀数据，<code>completion</code> 中的 <code>field</code> 指定了需要匹配文档的哪个字段返回结果中 <code>options</code> 包含了整个文档的数据</p>
<p>需要注意的是，Completion Suggester 在索引数据的时候经过了 analyze 阶段，所以使用不同的 analyzer（分词器） 会造成构建 FST 的数据不同，例如某些词（is、at 等停用词）被去除、某些词被转换（大小写等）由于构建的数据不同，可能会影响查询匹配的结果</p>
<h2 id="context-suggester"> Context Suggester</h2>
<p><strong>Context Suggester 是 Completion Suggester 的扩展，可以实现上下文感知推荐</strong>例如当我们在编程类型的书籍中查询 <code>linu</code> 的时候，可以返回 linux 编程相关的书籍，但在人物自传类型的书籍中，将会返回 linus 的自传要实现这个功能，可以在文档中加入分类信息，帮助我们做精准推荐</p>
<p>ES 支持两种类型的上下文：</p>
<ul>
<li><strong>Category</strong>：任意字符串的分类</li>
<li><strong>Geo</strong>：地理位置信息</li>
</ul>
<p>下面演示如何基于任意字符串的分类来做上下文推荐同样，在使用 Context Suggester 前，首先要创建 Mapping，然后在数据中加入相关的 Context 信息下面是使用 Context Suggester 时的 Mapping：</p>
<div><pre><code><span>#删除原来的索引</span>
DELETE books_context

<span># 创建用于测试 Context Suggester 的索引</span>
PUT books_context
<span>{</span>
  <span>"mappings"</span><span>:</span> <span>{</span>
    <span>"properties"</span><span>:</span> <span>{</span>
        <span>"book_id"</span><span>:</span> <span>{</span>
          <span>"type"</span><span>:</span> <span>"keyword"</span>
        <span>}</span>,
        <span>"name"</span><span>:</span> <span>{</span>
          <span>"type"</span><span>:</span> <span>"text"</span>,
          <span>"analyzer"</span><span>:</span> <span>"standard"</span>
        <span>}</span>,
        <span>"name_completion"</span><span>:</span> <span>{</span>
          <span>"type"</span><span>:</span> <span>"completion"</span>,
          <span>"contexts"</span><span>:</span> <span>[</span>
            <span>{</span>
              <span>"name"</span><span>:</span> <span>"book_type"</span>,
              <span>"type"</span><span>:</span> <span>"category"</span>
            <span>}</span>  
          <span>]</span>
        <span>}</span>,
        <span>"author"</span><span>:</span> <span>{</span>
          <span>"type"</span><span>:</span> <span>"keyword"</span>
        <span>}</span>,
        <span>"intro"</span><span>:</span> <span>{</span>
          <span>"type"</span><span>:</span> <span>"text"</span>
        <span>}</span>,
        <span>"price"</span><span>:</span> <span>{</span>
          <span>"type"</span><span>:</span> <span>"double"</span>
        <span>}</span>,
        <span>"date"</span><span>:</span> <span>{</span>
          <span>"type"</span><span>:</span> <span>"date"</span>
        <span>}</span>
      <span>}</span>
  <span>}</span>,
  <span>"settings"</span><span>:</span> <span>{</span>
    <span>"number_of_shards"</span><span>:</span> <span>3</span>,
    <span>"number_of_replicas"</span><span>:</span> <span>1</span>
  <span>}</span>
<span>}</span>

<span># 插入三条测试数据</span>
PUT books_context/_doc/4
<span>{</span>
  <span>"book_id"</span><span>:</span> <span>"4ee82465"</span>,
  <span>"name"</span><span>:</span> <span>"Linux Programming"</span>,
  <span>"name_completion"</span><span>:</span> <span>{</span>
    <span>"input"</span><span>:</span> <span>[</span><span>"Linux Programming"</span><span>]</span>,
    <span>"contexts"</span><span>:</span> <span>{</span>
      <span>"book_type"</span><span>:</span> <span>"program"</span>
    <span>}</span>
  <span>}</span>,
  <span>"author"</span><span>:</span> <span>"Richard Stones"</span>,
  <span>"intro"</span><span>:</span> <span>"Happy to Linux Programming"</span>,
  <span>"price"</span><span>:</span> <span>10.9</span>,
  <span>"date"</span><span>:</span> <span>"2022-06-01"</span>
<span>}</span>

PUT books_context/_doc/5
<span>{</span>
  <span>"book_id"</span><span>:</span> <span>"4ee82466"</span>,
  <span>"name"</span><span>:</span> <span>"Linus Autobiography"</span>,
  <span>"name_completion"</span><span>:</span> <span>{</span>
    <span>"input"</span><span>:</span> <span>[</span><span>"Linus Autobiography"</span><span>]</span>,
    <span>"contexts"</span><span>:</span> <span>{</span>
      <span>"book_type"</span><span>:</span> <span>"autobiography"</span>
    <span>}</span>
  <span>}</span>,
  <span>"author"</span><span>:</span> <span>"Linus"</span>,
  <span>"intro"</span><span>:</span> <span>"Linus Autobiography"</span>,
  <span>"price"</span><span>:</span> <span>14.9</span>,
  <span>"date"</span><span>:</span> <span>"2012-06-01"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br></div></div><p>如上所示的 Mapping，其中 <code>name_completion</code> 的类型还是为 <code>completion</code>，在 <code>contexts</code> 中有两个字段，其中 <code>type</code> 为上下文的类型，就是上面提到的 Category 和 Geo，本例子使用了 Category而 <code>name</code> 则为上下文的名称（即哪个分类），本例子为 <code>book_type</code></p>
<p>导入的数据中，<code>name_completion</code> 中的 <code>input</code> 字段用于内容匹配<code>book_type</code> 的值有多个，<code>program</code> 是编程类的，<code>autobiography</code> 是自传类的</p>
<p>导入数据成功后，下面来看看 Context Suggester 的使用例子：</p>
<div><pre><code>POST books_context/_search
<span>{</span>
  
  <span>"suggest"</span><span>:</span> <span>{</span>
    <span>"my_suggest"</span><span>:</span> <span>{</span>
      <span>"prefix"</span><span>:</span> <span>"linu"</span>,
      <span>"completion"</span><span>:</span> <span>{</span>
        <span>"field"</span><span>:</span> <span>"name_completion"</span>,
        <span>"contexts"</span><span>:</span> <span>{</span>
          <span>"book_type"</span><span>:</span> <span>"program"</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>如上示例，还是使用 <code>prefix</code> 字段来指定需要匹配的前缀数据，其将与 <code>input</code> 字段的数据进行匹配而 <code>contexts</code> 中指定了 <code>book_type</code> 为 <code>program</code>所以查询的意思是：在书本类别为 <code>program</code> 的数据里，推荐以 <code>linu</code> 开头的书本</p>
<h2 id="总结"> 总结</h2>
<ul>
<li><strong>Term Suggester 提供基于单词的纠错、补全功能</strong>其工作原理是基于编辑距离（edit distance）来运作的，编辑距离的核心思想是一个词需要改变多少个字符就可以和另一个词一致Term Suggester 是根据每个单词提供建议，所以其不会考虑输入文本间各个单词的关系</li>
<li><strong>Phrase Suggester 是基于短语的纠错补全的</strong>，不像 Term Suggester 只能提供基于单词的纠错所以其会考量多个 term 间的关系，比如相邻的程度、词频等</li>
<li><strong>Completion Suggester 提供自动补全单词的功能，输入词语的前半部分，自动补全整个单词</strong>由于 Completion Suggester 需要比较高的性能，所以底层使用了 FST 来实现需要注意的是，Completion Suggester 在写入数据时会将数据进行分词等操作，而不同的分词器分词后的结果不尽相同，这会导致构建的 FST 也是不同的，这样将会造成某些查询无法匹配到结果的现象</li>
<li><strong>Context Suggester 提供基于上下文的补全功能</strong>当我们需要根据不同类别进行相关上下文补全的时候，Context Suggester 就派上用场了Context Suggester 可以定义两种上下文类型：Category 和 Geo，其中我们今天详细讲解了 Category 类型的实例</li>
</ul>
<h2 id="参考文档"> 参考文档</h2>
<ul>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/search-suggesters.html#global-suggest" target="_blank" rel="noopener noreferrer">Suggesters</a></li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">嵌套类型和父子文档</title>
    <id>https://www.snowji.cn/databases/es/nested-and-join/</id>
    <link href="https://www.snowji.cn/databases/es/nested-and-join/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="嵌套类型和父子文档"> 嵌套类型和父子文档</h1>
<h2 id="前言"> 前言</h2>
<p>在传统的关系型数据库领域，想要表达关系型模型是非常自然的（通过外键关联），但在 ES 里要处理这个事情就并不那么简单了</p>
<p>在 ES 中可以保存关系型模型数据的方式主要有以下两种：</p>
<ul>
<li><strong>nested</strong>：在这种方式中，会将一对多的关系保存在同一个文档中</li>
<li><strong>join（Parent / Child）</strong>：通过维护文档的父子关系，将两个对象分离</li>
</ul>
<p><strong>上述的这两种方式都可以描述一对多的关系</strong>，下面分别介绍这两种实现关系型模型的方式和它们各种的优缺点以及适用场景</p>
<h2 id="nested-嵌套类型"> nested（嵌套类型）</h2>
<p>nested 类型是<strong>一种特殊的 object 数据类型，其允许数组中的对象可以被单独索引，使它们可以被独立地检索</strong></p>
<h3 id="不指定-nested-的情况"> 不指定 nested 的情况</h3>
<p>如果使用普通的 object 数组来保存书本与作者的一对多关系：</p>
<div><pre><code><span># 创建 Mapping</span>
PUT books_index
<span>{</span>
  <span>"mappings"</span><span>:</span> <span>{</span>
    <span>"properties"</span><span>:</span> <span>{</span> 
      <span>"book_id"</span><span>:</span> <span>{</span> <span>"type"</span><span>:</span> <span>"keyword"</span> <span>}</span>,
      <span>"author"</span><span>:</span> <span>{</span> 
        <span>"properties"</span><span>:</span> <span>{</span>
          <span>"first_name"</span><span>:</span> <span>{</span> <span>"type"</span><span>:</span> <span>"keyword"</span> <span>}</span>,
          <span>"last_name"</span><span>:</span> <span>{</span> <span>"type"</span><span>:</span> <span>"keyword"</span> <span>}</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

<span># 写入书本数据</span>
PUT books_index/_doc/1
<span>{</span>
  <span>"book_id"</span><span>:</span> <span>"1234"</span>,
  <span>"author"</span><span>:</span> <span>[</span>
    <span>{</span> <span>"first_name"</span><span>:</span> <span>"zhang"</span>, <span>"last_name"</span><span>:</span> <span>"san"</span> <span>}</span>,
    <span>{</span> <span>"first_name"</span><span>:</span> <span>"wang"</span>, <span>"last_name"</span><span>:</span> <span>"wu"</span> <span>}</span>
  <span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>写入数据的时候，书本的作者有两个（描述了一对多的关系）：<code>&quot;zhangsan&quot;</code> 和 <code>&quot;wangwu&quot;</code></p>
<p>执行查询语句：</p>
<div><pre><code>GET books_index/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"bool"</span><span>:</span> <span>{</span>
      <span>"must"</span><span>:</span> <span>[</span>
        <span>{</span> <span>"term"</span><span>:</span> <span>{</span> <span>"author.first_name"</span><span>:</span> <span>"zhang"</span> <span>}</span> <span>}</span>,
        <span>{</span> <span>"term"</span><span>:</span> <span>{</span> <span>"author.last_name"</span><span>:</span> <span>"wu"</span> <span>}</span> <span>}</span>
      <span>]</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>用上面的查询语法，本意是查 <code>&quot;zhangwu&quot;</code> 这个姓名，数据中不存在这个作者。但是这个查询却可以命中文档 1，跟我们预期的不一样</p>
<p>这是因为 object 被扁平化处理后，其丢失了 <code>first_name</code> 和 <code>last_name</code> 之间的关系，变成了下面这样的关系：</p>
<div><pre><code><span>{</span>
    <span>"book_id"</span><span>:</span> <span>"1234"</span>,
    <span>"author.first_name"</span><span>:</span> <span>[</span><span>"zhang"</span>, <span>"wang"</span><span>]</span>,
    <span>"author.last_name"</span><span>:</span> <span>[</span><span>"san"</span>, <span>"wu"</span><span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>对于这个扁平化数组，原先 <code>first_name</code> 和 <code>last_name</code> 间的对应关系已经不复存在了。所以查询语句在 <code>author.first_name</code> 中匹配了 <code>&quot;zhang&quot;</code>，在 <code>author.last_name</code> 匹配了 <code>&quot;wu&quot;</code>，自然而然就命中了文档 1</p>
<h3 id="指定-nested-的情况"> 指定 nested 的情况</h3>
<p>使用 nested 数据类型可以使对象数组中的对象被独立索引，这样 <code>first_name</code> 和 <code>last_name</code> 间的对应关系就不会丢失了</p>
<p>下面示例修改一下 Mapping，把 <code>author</code> 的类型定义为 nested：</p>
<div><div><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br></div><pre><code><span># 删除索引</span>
DELETE books_index

<span># 创建索引，author 类型为 nested</span>
PUT books_index
<span>{</span>
  <span>"mappings"</span><span>:</span> <span>{</span>
    <span>"properties"</span><span>:</span> <span>{</span> 
      <span>"book_id"</span><span>:</span> <span>{</span> <span>"type"</span><span>:</span> <span>"keyword"</span> <span>}</span>,
      <span>"author"</span><span>:</span> <span>{</span> 
        <span>"type"</span><span>:</span> <span>"nested"</span>, <span># author 定义为 nested 类型的对象</span>
        <span>"properties"</span><span>:</span> <span>{</span>
          <span>"first_name"</span><span>:</span> <span>{</span> <span>"type"</span><span>:</span> <span>"keyword"</span> <span>}</span>,
          <span>"last_name"</span><span>:</span> <span>{</span> <span>"type"</span><span>:</span> <span>"keyword"</span> <span>}</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>指定 <code>author</code> 这个对象的类型为 nested 后，在内部 nested 类型将数组中的每个对象索引为单独的隐藏文档，这样数组中的每个对象就可以被单独检索了</p>
<p>nested 数据类型的检索示例如下：</p>
<div><pre><code><span># nested 数据类型的查询</span>
GET books_index/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"nested"</span><span>:</span> <span>{</span>         <span># 使用 nested 关键字</span>
      <span>"path"</span><span>:</span> <span>"author"</span>, <span># path 关键字指定对象名字</span>
      <span>"query"</span><span>:</span> <span>{</span>
        <span>"bool"</span><span>:</span> <span>{</span>
          <span>"must"</span><span>:</span> <span>[</span>
            <span>{</span> <span>"term"</span><span>:</span> <span>{</span> <span>"author.first_name"</span><span>:</span> <span>"zhang"</span> <span>}</span> <span>}</span>,
            <span>{</span> <span>"term"</span><span>:</span> <span>{</span> <span>"author.last_name"</span><span>:</span> <span>"san"</span> <span>}</span> <span>}</span>
          <span>]</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>如上示例，使用 <code>nested</code> 关键字指定一个 nested 对象的查询，使用 <code>path</code> 指定 nested 对象的名字</p>
<p>从上面的示例来看，nested 通过冗余的方式将对象和文档存储在一起，所以查询时的性能是很高的。但在需要更新对象信息的时候需要更新所有包含此对象的文档，例如某个作者的信息更改了，那么所有这个作者的书本文档都要更新。<strong>所以 nested 适合查询频繁但更新频率低的场景</strong></p>
<h2 id="parent-child-文档的父子关系"> Parent / Child（文档的父子关系）</h2>
<p>除了提供 nested 来描述一对多关系外，ES 还提供了 join 数据类型来表达关系型数据模型</p>
<p><strong>join 数据类型允许在一个索引中的文档创建父子关系，通过维护父子文档的关系独立出来两个对象</strong>。父文档和子文档是相互独立的，通过类似引用的关系进行绑定，所以当父文档更新时，不需要更新子文档，而子文档可以被任意添加、修改、删除而不会影响到父文档和其他子文档</p>
<p>需要注意的是，<strong>为了维护父子文档的关系需要占用额外的内存资源，并且读取性能相对较差</strong>。但由于父子文档是互相独立的，所以<strong>适合子文档更新频率高的场景</strong></p>
<p>下面是 join 数据类型的使用示例</p>
<h3 id="在-mapping-中定义-join-数据类型"> 在 Mapping 中定义 join 数据类型</h3>
<p>在使用 join 前，先进行字段的定义，Mapping 的定义如下：</p>
<div><pre><code>PUT join_books_index
<span>{</span>
  <span>"mappings"</span><span>:</span> <span>{</span>
    <span>"properties"</span><span>:</span> <span>{</span> 
      <span>"book_id"</span><span>:</span> <span>{</span> <span>"type"</span><span>:</span> <span>"keyword"</span> <span>}</span>,
      <span>"name"</span><span>:</span> <span>{</span> <span>"type"</span><span>:</span> <span>"text"</span> <span>}</span>,
      <span>"book_comments_relation"</span><span>:</span> <span>{</span>  <span># 定义字段名字</span>
        <span>"type"</span><span>:</span> <span>"join"</span>,            <span># 此字段为 join 类型</span>
        <span>"relations"</span><span>:</span> <span>{</span>             <span># 声明 Parent / Child 的关系</span>
          <span>"book"</span><span>:</span> <span>"comment"</span>        <span># book 是 Parent 的名称，comment 是 Child 的名称</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>,
  <span>"settings"</span><span>:</span> <span>{</span>
    <span>"number_of_shards"</span><span>:</span> <span>3</span>,  <span># 定义 3 个主分片</span>
    <span>"number_of_replicas"</span><span>:</span> <span>1</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>如上示例，<code>book_comments_relation</code> 是字段的名字，使用 <code>join</code> 关键字定义此字段的类型为 join 类型。<code>relations</code> 处声明了 Parent / Child 的关系</p>
<h3 id="索引父文档"> 索引父文档</h3>
<p>在定义了 Mapping 后，写入父文档的数据</p>
<div><pre><code>PUT join_books_index/_doc/11
<span>{</span>
  <span>"book_id"</span><span>:</span> <span>"1234"</span>,
  <span>"name"</span><span>:</span> <span>"java book"</span>,
  <span>"book_comments_relation"</span><span>:</span> <span>{</span>
    <span>"name"</span><span>:</span> <span>"book"</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>这里父文档的 ID 为 11，其中 <code>book_comments_relation</code> 声明了文档类型为 <code>book</code>（即我们概念里的父文档）</p>
<h3 id="索引子文档"> 索引子文档</h3>
<p>索引子文档的示例如下：</p>
<div><pre><code>PUT join_books_index/_doc/21?routing<span>=</span><span>11</span>
<span>{</span>
  <span>"comment"</span><span>:</span> <span>"a good book!!"</span>,
  <span>"user_name"</span><span>:</span> <span>"tom"</span>,
  <span>"book_comments_relation"</span><span>:</span> <span>{</span>
    <span>"name"</span><span>:</span> <span>"comment"</span>,
    <span>"parent"</span><span>:</span> <span>"11"</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>如上示例，<code>book_comments_relation</code> 中声明了文档的类型为 <code>comment</code>（即我们概念里的子文档），并且使用 <code>parent</code> 字段指定父文档的 ID</p>
<p>为了确保查询时的性能，父文档和子文档必须在同一个分片，所以需要强制使用 <code>routing</code> 参数，并且其值为父文档的 ID（如果写入父文档的时候也用 <code>routing</code> 参数，那么需要保证它们的值是一样的）</p>
<h3 id="数据检索"> 数据检索</h3>
<p>在索引了父子文档的数据后，下面来做几个搜索</p>
<h4 id="_1-获取父文档的信息"> 1）获取父文档的信息</h4>
<div><pre><code><span># 获取父文档</span>
GET join_books_index/_doc/11

<span># 结果</span>
<span>{</span>
  <span>"_id"</span> <span>:</span> <span>"11"</span>,
  <span>"_source"</span> <span>:</span> <span>{</span>
    <span>"book_id"</span> <span>:</span> <span>"1234"</span>,
    <span>"name"</span> <span>:</span> <span>"java book"</span>,
    <span>"book_comments_relation"</span> <span>:</span> <span>{</span>
      <span>"name"</span> <span>:</span> <span>"book"</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>如上示例，可以看到获取的父文档的数据是不包含子文档的信息的，因为父子文档是相互独立的</p>
<h4 id="_2-获取子文档的信息"> 2）获取子文档的信息</h4>
<div><pre><code><span># 获取子文档信息</span>
GET join_books_index/_doc/21

<span># 结果，失败的</span>
<span>{</span>
  <span>"_index"</span> <span>:</span> <span>"join_books_index"</span>,
  <span>"_type"</span> <span>:</span> <span>"_doc"</span>,
  <span>"_id"</span> <span>:</span> <span>"21"</span>,
  <span>"found"</span> <span>:</span> <span>false</span>
<span>}</span>

<span># 获取子文档信息，需要加入 routing 参数</span>
GET join_books_index/_doc/21?routing<span>=</span><span>11</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>如上示例，在获取子文档时，如果不加 <code>routing</code> 参数是无法找到对应的子文档的。<code>routing</code> 参数的值为父文档的 ID</p>
<h4 id="_3-parent-id-查询"> 3）Parent Id 查询</h4>
<p>如果我们要查询一本书的评价列表，可以用 Parent Id 进行查询</p>
<div><pre><code>POST join_books_index/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"parent_id"</span><span>:</span> <span>{</span>
      <span>"type"</span><span>:</span> <span>"comment"</span>,
      <span>"id"</span><span>:</span> <span>"11"</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>如上示例，<code>parent_id</code> 字段里，我们查询了父文档 ID 为 <code>11</code> 并且 <code>comment</code> 类型的文档</p>
<h4 id="_4-has-child-查询"> 4）Has Child 查询</h4>
<p>如果我们想查询用户 &quot;tom&quot; 评论了哪些书本，可以使用 <strong>Has Child 查询</strong>。Has Child 查询将在子文档中进行条件匹配，然后返回匹配文档对应的父文档的信息</p>
<div><pre><code><span># Has Child 查询</span>
POST join_books_index/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"has_child"</span><span>:</span> <span>{</span>
      <span>"type"</span><span>:</span> <span>"comment"</span>, <span># 在评论中查询</span>
      <span>"query"</span><span>:</span> <span>{</span>
        <span>"term"</span><span>:</span> <span>{</span>
          <span>"user_name"</span><span>:</span> <span>"tom"</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

<span># 结果</span>
<span>{</span>
  <span>"_id"</span> <span>:</span> <span>"11"</span>,
  <span>"_source"</span> <span>:</span> <span>{</span>
    <span>"book_id"</span> <span>:</span> <span>"1234"</span>,
    <span>"name"</span> <span>:</span> <span>"java book"</span>,
    <span>"book_comments_relation"</span> <span>:</span> <span>{</span>
      <span>"name"</span> <span>:</span> <span>"book"</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>如上示例，使用 <code>has_child</code> 字段来声明一次 Has Child 查询，其中我们查询文档类型（<code>type</code> 字段的值）为 <code>comment</code>（子文档） 的文档，条件为用户名字为 <code>&quot;tom&quot;</code>，而返回结果则为父文档的列表</p>
<h4 id="_5-has-parent-查询"> 5）Has Parent 查询</h4>
<p>那如果我们想查询 java 相关书籍的评论时，可以使用 <strong>Has Parent</strong> 查询。Has Parent 查询会在父文档中进行匹配，然后返回匹配文档对应的子文档的信息</p>
<div><pre><code><span># Has Parent 查询</span>
POST join_books_index/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"has_parent"</span><span>:</span> <span>{</span>
      <span>"parent_type"</span><span>:</span> <span>"book"</span>,
      <span>"query"</span><span>:</span> <span>{</span>
        <span>"term"</span><span>:</span> <span>{</span>
          <span>"name"</span><span>:</span> <span>"java"</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

<span># 结果</span>
<span>{</span>
  <span>"hits"</span> <span>:</span> <span>{</span>
    <span>"hits"</span> <span>:</span> <span>[</span>
      <span>{</span>
        <span>"_id"</span> <span>:</span> <span>"21"</span>,
        <span>"_source"</span> <span>:</span> <span>{</span>
          <span>"comment"</span> <span>:</span> <span>"a good book!!"</span>,
          <span>"user_name"</span> <span>:</span> <span>"tom"</span>,
          <span>"book_comments_relation"</span> <span>:</span> <span>{</span>
            <span>"name"</span> <span>:</span> <span>"comment"</span>,
            <span>"parent"</span> <span>:</span> <span>"11"</span>
          <span>}</span>
        <span>}</span>
      <span>}</span>
    <span>]</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>如上示例，使用 <code>has_parent</code> 字段开启一次 Has Parent 查询，<code>parent_type</code> 的值设置为 <code>book</code>（父文档），查询条件为书名中带有 <code>&quot;java&quot;</code> 的文档，最终返回结果则为子文档列表</p>
<h2 id="总结"> 总结</h2>
<p>因为对象数组在存储的时候被扁平化了，会导致对象字段间的关系丢失，从而影响搜索的精准度。所以普通的 object 类型数组不能满足关系型数据这种需求</p>
<p>nested 数据类型和 join 数据类型可以解决这个问题</p>
<p>下面是 nested 和 join 数据类型的优缺点：</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">Nested 类型</th>
<th style="text-align:left">Join 类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">缺点</td>
<td style="text-align:left">文档变更时，需要更新所有引用这个文档信<br>息的文档</td>
<td style="text-align:left">占用额外的内存资源来维护父子关系，并且读取性<br>能相对较差</td>
</tr>
<tr>
<td style="text-align:left">优点</td>
<td style="text-align:left">对象与文档存储在一起，读取性能高</td>
<td style="text-align:left">父子文档互相独立</td>
</tr>
<tr>
<td style="text-align:left">使用场景</td>
<td style="text-align:left">适合查询频繁但更新频率低的场景</td>
<td style="text-align:left">适合子文档更新频率高的场景</td>
</tr>
</tbody>
</table>
<h2 id="参考文档"> 参考文档</h2>
<ul>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/nested.html#nested" target="_blank" rel="noopener noreferrer">nested</a></li>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/parent-join.html" target="_blank" rel="noopener noreferrer">join</a></li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Term 查询语法</title>
    <id>https://www.snowji.cn/databases/es/term-query/</id>
    <link href="https://www.snowji.cn/databases/es/term-query/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="term-查询语法"> Term 查询语法</h1>
<h2 id="前言"> 前言</h2>
<p>Match 是基于全文的搜索，Term 是基于词项的搜索</p>
<p>Term 查询不会对输入内容进行分词，它会将输入的内容会作为一个整体来进行检索，并且使用相关性算分公式对包含整个检索内容的文档进行相关性算分</p>
<p>Term 是文本经过分词处理后得出来的词项，是 ES 中表达语义的最小单位ES 中提供很多基于 Term 的查询功能，例如：</p>
<ul>
<li><strong>Term Query</strong>：返回在指定字段中准确包含了检索内容的文档</li>
<li><strong>Terms Query</strong>：跟 Term Query 类似，不过可以同时检索多个词项的功能</li>
<li><strong>Range Query</strong>：范围查询</li>
<li><strong>Exist Query</strong>：返回在指定字段上有值的文档，一般用于过滤没有值的文档</li>
<li><strong>Prefix Query</strong>：返回在指定字段中包含指定前缀的文档</li>
<li><strong>Wildcard Query</strong>：通配符查询</li>
</ul>
<h2 id="term-query"> Term Query</h2>
<p>Term Query 返回在指定字段中准确包含了检索内容的文档，可以使用此 API 去查询精确值的字段，如书本 ID、价格等</p>
<div><pre><code><span># 使用 Term Query API 查询书本 id 为 "4ee82463" 的文档 </span>
POST books/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"term"</span><span>:</span> <span>{</span>
      <span>"book_id"</span><span>:</span> <span>{</span>
        <span>"value"</span><span>:</span> <span>"4ee82463"</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>要避免将 Term Query 用在 <code>text</code> 类型的字段上，因为基于 Term 的查询是不会对输入的内容进行分词的，输入的文本会作为一个整体进行查询但是索引里的数据是进行过分词并且转化为小写的（如果使用的是 standard 分词器，会进行小写转换）</p>
<p>如果要对 <code>text</code> 类型的字段进行搜索，应该使用 match 而不是 Term Query</p>
<h2 id="terms-query"> Terms Query</h2>
<p>Terms Query 的功能跟 Term Query 类似，不过可以同时检索多个词项的功能</p>
<div><pre><code><span># 使用 Terms Query 进行查询</span>
POST books/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"terms"</span><span>:</span> <span>{</span>
      <span>"author"</span><span>:</span> <span>[</span>  <span># 数组，可以指定多个作者的名字</span>
        <span>"Stephen Hawking"</span>,
        <span>"Wolfgang Mauerer"</span>
      <span>]</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="range-query"> Range Query</h2>
<p>Range Query 可以查询字段值符合某个范围的文档数据</p>
<div><pre><code><span># 使用 Range Query 查询书本价格大于等于 10.0 小于 20.0 的书本</span>
POST books/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"range"</span><span>:</span> <span>{</span>
      <span>"price"</span><span>:</span> <span>{</span>
        <span>"gte"</span><span>:</span> <span>10.0</span>,
        <span>"lt"</span><span>:</span> <span>20.0</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>大小的比较：</p>
<ul>
<li><code>gt</code>：表示大于</li>
<li><code>gte</code>：表示大于或者等于</li>
<li><code>lt</code>：表示小于</li>
<li><code>lte</code>：表示小于或者等于</li>
</ul>
<h2 id="exist-query"> Exist Query</h2>
<p>使用 Exist Query 可以查询那些在指定字段上有值的文档，一般情况下会使用这个 API 来做文档过滤</p>
<div><pre><code><span># 查询出所有存在 "price" 字段的文档</span>
POST books/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"exists"</span><span>:</span> <span>{</span>
      <span>"field"</span><span>:</span> <span>"price"</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>ES 中空值的标准：</p>
<ul>
<li>字段的 JSON 值为 <code>null</code> 或者 <code>[]</code>，如果一个字段压根不存在于文档的 <code>_source</code> 里，也被认为是空的</li>
<li>一个字段在 Mapping 定义的时候设置了 <code>&quot;index&quot; : false</code></li>
<li>一个字段的值的长度超出了 Mapping 里这个字段设置的 <code>ignore_above</code> 时</li>
<li>当字段的值不合规，并且 Mapping 中这个字段设置了 <code>ignore_malformed</code> 时</li>
</ul>
<h2 id="prefix-query"> Prefix Query</h2>
<p>使用 Prefix Query 可以查询在指定字段中包含特定前缀的文档</p>
<div><pre><code><span># 使用 Prefix Query 查询含有 "linu" 前缀的文档</span>
POST books/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"prefix"</span><span>:</span> <span>{</span>
      <span>"name"</span><span>:</span> <span>{</span>
        <span>"value"</span><span>:</span> <span>"linu"</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>需要注意的是，<code>text</code> 类型的字段会被分词，成为一个个的 term（词项），所以这里的前缀匹配是匹配这些分词后 term</p>
<h2 id="wildcard-query"> Wildcard Query</h2>
<p>Wildcard Query 允许使用通配符表达式进行匹配它支持两个通配符：</p>
<ul>
<li>使用 <code>?</code> 来匹配任意字符</li>
<li>使用 <code>*</code> 来匹配 0 或多个字符</li>
</ul>
<div><pre><code><span># 使用 Wildcard Query 查询书名中含有 "linu" 开头的文档</span>
POST books/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"wildcard"</span><span>:</span> <span>{</span>
      <span>"name"</span><span>:</span> <span>"linu*"</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>需要注意的是，Prefix Query 和 Wildcard Query 在进行查询的时候需要扫描倒排索引中的词项列表才能找到全部匹配的词项，然后再获取匹配词项对应的文档 ID</p>
<p>所以使用 Wildcard Query 的时候需要注意性能问题，要尽量避免使用左通配匹配模式，如 <code>*linux</code>、<code>.*linux</code></p>
<h2 id="结构化搜索"> 结构化搜索</h2>
<p>结构化搜索指的是对结构化的数据进行搜索所谓结构化数据，就是像日期、价格等这些有精确格式的数据</p>
<p>我们可以对这些数据进行逻辑操作，例如判断价格的范围等一般我们会对结构化数据进行精确匹配，而精确匹配的结果为布尔值，这个时候可以考虑跳过相关性算分的步骤，从而提高搜索的性能</p>
<p>使用 Constant Score 可以将 <code>query</code> 转化为 <code>filter</code>，可以忽略相关性算分的环节，并且 <code>filter</code> 可以有效利用缓存，从而提高查询的性能示例如下：</p>
<div><pre><code><span># 使用 Range 查询，并且不进行相关性算分</span>
POST /books/_search
<span>{</span>
  <span>"query"</span><span>:</span> <span>{</span>
    <span>"constant_score"</span><span>:</span> <span>{</span>
      <span>"filter"</span><span>:</span> <span>{</span>
        <span>"range"</span><span>:</span> <span>{</span>
          <span>"price"</span><span>:</span> <span>{</span>
            <span>"gte"</span><span>:</span> <span>10</span>,
            <span>"lte"</span><span>:</span> <span>20</span>
          <span>}</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="参考文档"> 参考文档</h2>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.13/term-level-queries.html" target="_blank" rel="noopener noreferrer">Term-level queries</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Windows 下安装</title>
    <id>https://www.snowji.cn/databases/es/windows/</id>
    <link href="https://www.snowji.cn/databases/es/windows/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="windows-下安装"> Windows 下安装</h1>
<p><strong>必须先安装 Java 环境</strong></p>
<p>本文中所述版本是 8.2.2</p>
<h2 id="安装步骤"> 安装步骤</h2>
<h3 id="下载压缩包"> 下载压缩包</h3>
<p>官网地址：https://www.elastic.co/cn/downloads/elasticsearch</p>
<p>下载 Windows 环境的压缩包 8.2.2 版本</p>
<h3 id="解压启动"> 解压启动</h3>
<p>将上面下载的压缩包进行解压</p>
<p><img src="./images/windows1.png" alt="es" /></p>
<div><pre><code>相关目录介绍：

bin：启动文件

config：配置文件

log4j2：日志配置文件

jvm.options：java 虚拟机相关的配置

elasticsearch.yml：elasticsearch 的配置文件！ 默认 9200 端口！ 跨域！

lib：相关jar包

logs：日志

modules：功能模块

plugins；插件
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>启动：</p>
<p><img src="./images/windows3.png" alt="es" /></p>
<p><img src="./images/windows2.png" alt="es" /></p>
<p>访问 9200 端口时：</p>
<p>有报错信息：</p>
<div><pre><code><span>[</span><span>2022</span>-05-18T15:59:34,697<span>]</span><span>[</span>WARN <span>]</span><span>[</span>o.e.x.s.t.n.SecurityNetty4HttpServerTransport<span>]</span> <span>[</span>DESKTOP-0QU7RUU<span>]</span> received plaintext http traffic on an https channel, closing connection Netty4HttpChannel<span>{</span>localAddress<span>=</span>/127.0.0.1:9200, <span>remoteAddress</span><span>=</span>/127.0.0.1:52407<span>}</span>
</code></pre>
<div><span>1</span><br></div></div><p>访问页面：</p>
<p><img src="./images/windows4.png" alt="es" /></p>
<p><strong>解决方案</strong>：</p>
<p>修改 Elasticsearch-8.2.2 安装目录下，/config/elasticsearch.yml 文件</p>
<p>将 <code>xpack.security.enabled: true</code> 修改为 <code>xpack.security.enabled: false</code></p>
<p>修改完成后重新启动：</p>
<p><img src="./images/windows5.png" alt="es" /></p>
<h2 id="安装可视化界面-es-head-的插件"> 安装可视化界面 es head 的插件</h2>
<p><strong>必须安装 node 环境</strong></p>
<p>下载地址：https://github.com/mobz/elasticsearch-head/</p>
<p>下载完成后进入目录执行：</p>
<div><pre><code>npm install
npm run start
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>启动后可以看到：</p>
<div><pre><code><span>></span> elasticsearch<span>-</span>head@<span>0.0</span><span>.0</span> start <span>G</span><span>:</span>\elasticsearch<span>-</span>head
<span>></span> grunt server

Running <span>"connect:server"</span> <span>(</span>connect<span>)</span> task
Waiting forever<span>...</span>
Started connect web server on http<span>:</span><span>/</span><span>/</span>localhost<span>:</span><span>9100</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>打开 9100 端口：</p>
<p><img src="./images/windows6.png" alt="es" /></p>
<p>出现上述情况的原因是<strong>跨域</strong></p>
<p><strong>解决方案</strong>：</p>
<p>修改 es 的配置文件如下：</p>
<p><img src="./images/windows7.png" alt="es" /></p>
<p>重启 es 后重新连接</p>
<p><img src="./images/windows8.png" alt="es" /></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">MySQL</title>
    <id>https://www.snowji.cn/databases/mysql/</id>
    <link href="https://www.snowji.cn/databases/mysql/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="mysql"> MySQL</h1>
<blockquote>
<p>本系列以 MySQL 8.0 作为安装版本进行知识点梳理，但考虑到目前在生产环境中用的比较多的是 5.7，故优先使用向前兼容的 5.7 版本功能，对于 8.0 特有的新功能和特性，仅是学习一下</p>
</blockquote>
<p>在日常工作与学习中，无论是开发、运维、还是测试，对于数据库的学习是不可避免的，同时也是日常工作的必备技术之一。而目前业内所用的关系型数据库中，占比较多的还是 MySQL</p>
<hr>
<p><strong>哪个版本的 MySQL 可以用于生产环境</strong>：</p>
<p>MySQL 有很多版本，支持在生产环境中使用的有 8.0、5.7 和 5.6：</p>
<ul>
<li>MySQL 8.0(GA)，MySQL 8.0.11 于2018年4月19日发布</li>
<li>MySQL 5.7(GA)，MySQL 5.7.9 于2015年10月21日发布</li>
<li>MySQL 5.6(GA)，MySQL 5.6.10 于2013年2月5日发布</li>
<li>MySQL 5.5(GA)，MySQL 5.5.8 于2010年12月3日发布</li>
</ul>
<hr>
<p><strong>为什么这三个版本可以用于生产环境</strong>：</p>
<p>MySQL 的产品生命周期分为三个阶段，首要阶段、延伸阶段和维持阶段（MySQL 版本号的前两位为主版本号，例如 8.0、5.7、5.6，后面的为维护版本号码。MySQL 的生命周期计算依据主版本号）</p>
<ul>
<li>首要阶段的时间为产品 GA 开始 5 年。处于首要阶段的产品会定期发布维护版本、更新、修正错误及修补安全漏洞</li>
<li>延伸阶段为产品 GA 后 6-8 年。延伸阶段的产品会对特定的错误及安全漏洞发布维护版本和更新</li>
<li>产品从 GA 的第 9 年起进入维持阶段。进入维持阶段后，MySQL 将不会对其进行维护版本的发布、更新和修正错误</li>
</ul>
<p>因此对应 MySQL 各个版本的 GA 日期，目前生产系统上支持 8.0、5.7 及 5.6 版本的 MySQL</p>
<hr>
<p><strong>为什么 MySQL 的版本号没有 6.x 和 7.x</strong>：</p>
<p>早在 2008 年，Sun 收购 MySQL AB 以前，公司内部已经在进行着版本号 6 的开发工作了（5.0 在 2005 年发布）。然而，版本 6 的 MySQL 制定的目标和计划过于激进，步子迈得有点儿大，随着收购的顺利完成，项目也被砍掉了</p>
<p>至于版本号 7，则是用在了 MySQL Cluster 上。由于新版的 MySQL 带来了许多的重大更新，开发者们决定是时候把版本号往前滚动一下了，于是便有了 8</p>
<p>参考：<a href="https://opensource.com/article/17/2/mysql-8-coming" target="_blank" rel="noopener noreferrer">MySQL 8 is coming</a></p>
<hr>
<p><strong>为什么选择 MySQL 8.0 做安装版本</strong>：</p>
<p>5.7 版本虽然还在其生命周期，但已经进入了维持阶段，不出意外，将于2023年的10月份结束对它的维护，进入到与 5.6 同样的状态</p>
<p>8.0 版本发布于2018年的4月份，除了在功能和性能上进行了大幅的增强和改进，它的发布方式（持续发布）使得用户可以在第一时间获得最新的功能和改进，而不像以往一定要等到大版本升级才能获得新的功能</p>
<p>但现实中，数据库系统升级影响很大，以前的 5.6 和 5.7 版本目前也足够稳定，如果不是新开的项目，需要慎重考虑是否升级（毕竟像 Facebook 这样的公司，将 MySQL 从 5.6 升级至 8.0 也花了几年时间，覆盖率还没达到 100%）</p>
<p>因此，考虑到实际情况，本系列采用 MySQL 8.0 做安装版本，但会优先使用向前兼容的 5.7 版本功能，对于 8.0 特有的新功能和特性，仅是学习一下</p>
<hr>
<p><strong>MySQL 5.7 和 8.0 性能对比</strong>：</p>
<ul>
<li><a href="https://www.cnblogs.com/YangJiaXin/p/11234591.html" target="_blank" rel="noopener noreferrer">MySQL 5.7和8.0性能测试</a></li>
</ul>
<p>该性能测试结果未经考验，仅供参考</p>
<div style="text-align: right">
  <svg t="1646148855959" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5290" width="64" height="64"><path d="M715.8 312.4l-5.6-11.7c-2.4-3.4-5.9-6-7.9-10h-0.6v-0.6c3.3-0.8 6.7-1.2 10.1-1.1 2 1.9 5.1 3.3 6.7 5.6 1.2 1.7 1.4 3.6 2.8 5 0 5.9-1.6 9.8-5.1 12.3 0.2-0.1-0.4 0.5-0.4 0.5z m251.9 251.1c-9.3-5.9-20.1-9.2-29.8-15.1-5.4-3.3-10.7-7.4-15.7-11.2-4.7-3.5-9.9-10.1-12.9-15.1-1.6-2.6-1.9-5.7-3.9-7.8 0.6-4.6 6.4-4.6 10.1-6.1 12.9-5.4 28-7.2 47.8-6.7-0.6-5-12.9-11.2-16.9-13.9-8-5.6-16.2-11.6-24.7-16.8-4.5-2.7-12.2-4.7-16.9-6.7-6.7-2.8-21.5-5.5-25.3-10.6-7.3-9.6-12.3-21.3-17.4-32.9-5.2-11.6-11.7-23.8-16.9-35.7-2.6-5.9-3.8-11.2-6.7-16.7-18.1-34.5-44.6-63.4-77-83.7-10.6-6.7-22.4-12.8-35.4-16.7-7.4-2.2-16.3-1-24.2-2.8h-5.1c-4.4-1.3-8.1-6-11.8-8.4-7.6-5-15.2-8.6-24.2-12.3-3.4-1.4-12.5-4.7-15.7-2.2-1.9 0.6-2.8 1.4-3.4 3.3-1.9 2.9-0.2 7.3 1.1 10 3.6 7.8 8.8 12.5 13.5 19 4.2 5.8 9.3 12.4 12.4 19 6.3 13.7 9.2 28.9 15.2 42.4 2.3 5.2 5.7 11.1 9 15.6 2.7 3.6 7.5 6.4 9 11.2 3.1 4.8-4.5 21.1-6.2 26.2-6.5 20-5.1 47.9 2.2 65.3 2.9 6.9 5.7 14.9 13.5 16.7 0.6-0.4 0.1-0.2 1.1-0.5 1.7-13.4 2.2-26.3 6.7-36.8 2.8-6.6 8.2-11.1 11.8-16.7 2.7 1.5 2.6 6 3.9 8.9 3.3 7.6 6.8 15.9 10.7 23.4 8.3 15.7 17.3 30.8 27.6 44.6 3.6 4.9 8.5 10.2 12.9 14.5 1.9 1.8 4.2 2.8 5.6 5h0.6v0.6c-7.6-2.6-12.1-10.1-18-14.5-11.3-8.4-24.6-21-32-32.9l-10.1-20.1v-0.6c-1.4 1.9-1 3.9-1.7 6.7-3.2 12.3-0.7 26.2-11.8 30.7-12.7 5.1-21.9-8.3-25.9-14.5-12.8-20.3-16.1-54.5-7.3-82 1.9-6.1 2.1-13.6 5.6-18.4-0.6-4.3-4.1-5.6-6.2-8.4-3.4-4.6-6.3-10-9-15.1-5.3-10.1-8.8-22-12.9-32.9-1.7-4.4-2-8.6-3.9-12.8-2.9-6.4-8.2-12.7-12.4-18.4-5.9-8.1-22.3-23.7-15.7-39.6 10.4-25.3 46.6-6.1 60.7 2.8 3.5 2.2 7.5 6.8 11.2 8.4l18.6 1.1c11.5 2.7 22.4 4.8 31.5 10 42.6 24.7 70 49.9 95.6 91.5 5.3 8.7 8.1 18.2 12.4 27.9 6.3 14.4 13 28.5 20.3 42.4 3.4 6.4 5.8 13.5 10.1 19 1.8 2.3 6.8 3.1 9.6 4.5 8.3 4.2 18 7.3 25.9 12.3 14.2 8.9 27.9 19.5 40.5 30.1 4.8 4.1 8 10 12.4 14.5v2.2c-3.9 1.1-7.9 2.2-11.8 3.3-8.7 2.2-16.3 1.7-24.7 3.9-5 1.3-11.4 3.3-16.9 3.9l0.6 0.5c3.2 8.9 20.4 16.3 28.1 21.8 9.6 6.9 18.7 15.1 25.9 24.5l7.3 7.3c1.7 2.4 2.1 5.5 3.9 7.8v0.5c-3.4-1.2-5.2-4.2-7.9-6.1-5.7-3.8-11.1-8.1-16.6-11.6zM373 728.9H271.4v-21.5h101.7c20.7-2.2 18.3-12.4 18.3-15.8v-8.4h-68.3c-31.8-0.3-52.1-14.1-52.3-29.9 0-1.5 0.7-71 0-71.6H303v69.5c-0.3 3.8 1.2 12.6 18.8 12.9 9 0.1 69.4 0 69.9 0v-82.7h32.2c0.2 0 0 112.8 0 113.3 0.2 27.7-34.8 33.7-50.9 34.2zM211.8 558.2L162 668.1c-5.9 13.3-13.6 18-29.4 18-15.8 0-23.8-4.7-29.7-18L53.2 558.2v126.1H21V558.4c0-12.3 4.9-18.2 15.2-21.3 24.4-7.6 41.1-1 48.2 15.3l47.3 108.5 48.9-108.5c7.4-16.4 23.8-22.9 48.3-15.3 10.2 3.1 15.2 9 15.2 21.3v125.9h-32.2l-0.1-126.1z" fill="#00758F" p-id="5291"></path><path d="M659.8 536.6h61.1c3.1 0 5.9 0.2 9 0.6 27 3.7 40.6 15.4 40.6 34.7v75.9c0 15.6-5.8 24-19.1 29.5l31.7 28.4h-37.3l-25.6-23-25.8 1.6H660c-6.4 0-12.8-0.9-18.9-2.7-20.5-5.5-30.4-16.2-30.4-33.8v-75.9c0-19.3 13.6-31 40.6-34.7 2.6-0.4 5.7-0.6 8.5-0.6z m-14.6 109.3c0 1 0.3 2.1 0.6 3.3 1.9 8.8 10.2 13.7 22.9 13.7H698l-26.8-24.1h37.3l23.4 21c4.3-2.3 7.2-5.8 8.2-10.3 0.3-1 0.3-2.1 0.3-3.1v-72.8c0-0.8 0-1.9-0.3-2.9-1.9-8.2-10.2-12.9-22.6-12.9h-48.7c-14.3 0-23.6 6.2-23.6 15.8v72.3z m-148.9-88.1c-11.5 1-14.9 2.9-16.4 9.4-0.3 1-0.3 1.9-0.3 2.7v14.5c0 1 0 1.8 0.3 2.9 1.5 8.6 7.7 12.5 20.7 12.5h39c9.6 0 19.5 1.6 27.5 4.7 15.2 5.7 22.9 14.3 22.9 23.5v23.3c0 11.3-6.8 19.9-20.7 26.2-8.3 3.9-18.9 6.1-29.7 6.1h-92.5v-21.3h88.8c1.2 0 2.2-0.2 3.4-0.2 6.2-0.4 10.8-2.1 13.6-4.5 3.1-2.5 4.6-5.3 4.6-7.6v-18.6c0-2.2-0.9-4.3-2.5-5.7-3.1-3.7-7.4-5.5-17.6-6.3-0.9-0.2-2.2-0.2-3.4-0.2h-33.4c-3.1 0-6.2-0.2-9.3-0.4-27.5-2.9-43.9-15.1-43.9-29.5v-18.6c0-16.4 8.4-25.8 27.5-31.7 6.2-1.8 13-2.7 26-2.7h90.3v21.3h-91.9c-0.9 0-2.1 0.2-3 0.2z m326.5 88.6c0 11.3 7.1 16 26 16h84.4v21.3h-83.8c-3.1 0-6.2-0.2-9.3-0.4-33.1-2.4-49.5-14.7-49.5-36.6V536.3h32.2v110.1z m149.2-8.2c12.5 0 23.7 9.5 23.7 23.5 0 14.1-11.2 23.5-23.7 23.5s-23.7-9.5-23.7-23.5 11.2-23.5 23.7-23.5z m0 42.2c10.2 0 18.4-8 18.4-18.6 0-10.7-8.2-18.6-18.4-18.6-10.3 0-18.4 8-18.4 18.6 0.1 10.6 8.1 18.6 18.4 18.6z m11.3-24.3c0 4.9-3.2 6.9-7.3 7.3l7.8 11.8h-5.3l-7.1-11.6h-4.2v11.6h-4.5v-26.9h10.6c6.5 0 10 2.3 10 7.8z m-16.2-4v7.7h4.9c3.4 0 6.4-0.3 6.4-4.1 0-3.1-3.3-3.6-6-3.6h-5.3z" fill="#F2A72F" p-id="5292"></path></svg>
</div>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">MySql 事务</title>
    <id>https://www.snowji.cn/databases/mysql/affairs/</id>
    <link href="https://www.snowji.cn/databases/mysql/affairs/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="mysql-事务"> MySql 事务</h1>
<h2 id="什么是事务"> 什么是事务</h2>
<ul>
<li>是数据库管理系统(DBMS)执行过程中的一个逻辑单位</li>
<li>由一个有限的数据库操作序列构成</li>
</ul>
<p><strong>常见的业务场景</strong>：</p>
<ul>
<li>转账</li>
<li>订单</li>
<li>修改数据库的数据内容</li>
</ul>
<p><strong>支持事务的存储引擎</strong>：</p>
<ul>
<li>InnoDB</li>
<li>NDB</li>
</ul>
<h2 id="数据库的事务"> 数据库的事务</h2>
<h3 id="默认事务"> 默认事务</h3>
<p>查看是否自动开启，默认是 ON</p>
<div><pre><code>show VARIABLES like <span>'autocommit'</span>
</code></pre>
<div><span>1</span><br></div></div><p>数据库默认是开启事务的，这会使得使用关键字时会提交事务，例如</p>
<div><pre><code>update student <span>set</span> sname <span>=</span> <span>'1111'</span> where <span>id</span> <span>=</span><span>1</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="自定义事务"> 自定义事务</h3>
<p>语法：</p>
<div><pre><code>begin或 start TRANSACTION<span>;</span>
update student <span>set</span> sname <span>=</span> <span>'1111'</span> where <span>id</span> <span>=</span><span>1</span><span>;</span>
commit <span># 提交事务</span>
rollback <span># 回滚事务</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="事务的结束"> 事务的结束</h3>
<p>两种方式：</p>
<ul>
<li>commit</li>
<li>rollback</li>
</ul>
<h2 id="事务的四大特性"> 事务的四大特性</h2>
<ul>
<li>原子性(Atomicity)
<ul>
<li>数据库事务的最小的逻辑单位</li>
<li>事务要么全部成功，要么全部失败</li>
</ul>
</li>
<li>一致性(Consistency)
<ul>
<li>数据库自身的完整性约束</li>
<li>用户自定义的完整性</li>
</ul>
</li>
<li>隔离性(Isolation)</li>
<li>持久性(Durablity)</li>
</ul>
<p>A、I、D 都是为了保证 C</p>
<h2 id="事务并发存在的问题"> 事务并发存在的问题</h2>
<p>对数据的增删改都会存在提交事务，如果操作的是同一个数据库的同一张表，会出现哪些问题？</p>
<h3 id="脏读"> 脏读</h3>
<p><img src="./images/transation1.png" alt="transation" /></p>
<ul>
<li>第一次查询时后，执行了其他未提交的事务</li>
<li>第二次查询时，查询的结果是未提交事务的数据</li>
<li>两次查询的结果不一致</li>
</ul>
<h3 id="不可重复读"> 不可重复读</h3>
<p><img src="./images/transation2.png" alt="transation" /></p>
<ul>
<li>第一次查询时后，执行了其他未提交的事务</li>
<li>第二次查询时，查询的结果是已提交事务的数据</li>
<li>两次查询的结果不一致</li>
</ul>
<h3 id="幻读"> 幻读</h3>
<p><img src="./images/transation3.png" alt="transation" /></p>
<ul>
<li>第一次查询时后，执行了其他未提交的事务</li>
<li>第二次查询时，查询的结果中包含了已提交事务的数据</li>
<li>两次查询的结果不一致</li>
</ul>
<div><p>总结</p>
<ul>
<li>事务并发的三大问题都是数据库<strong>读一致性</strong>问题</li>
<li>读一致性的问题必须由数据库提供一定的事务隔离机制来解决(SQL92 ANSI/ISO 标准)
<ul>
<li>Read Uncommitted(未提交读)</li>
<li>Read Committed(已提交读)：解决脏读</li>
<li>Repeatable Read(可重复读)：解决脏读、不可重复读</li>
<li>Serializable(串行化)：解决事务并发的所有问题，但效率低</li>
</ul>
</li>
<li>update/delete 属于不可重复读，insert 属于幻读</li>
</ul>
</div>
<h3 id="如何实现事务隔离"> 如何实现事务隔离</h3>
<p>事务隔离级别：</p>
<p><img src="./images/lock4.png" alt="lock" /></p>
<h4 id="lbcc-lock-based-concurrency-control"> LBCC(Lock Based Concurrency Control)</h4>
<p>读数据前，对其加锁，阻止其他事务对数据进行修改</p>
<h4 id="mvcc-mutil-version-concurrency-control"> MVCC(Mutil Version Concurrency Control)</h4>
<ul>
<li>生成一个数据请求时间的一致性数据快照</li>
<li>并用这个快照来提供一定级别(语句级或事务级)的一致性读取</li>
</ul>
<h2 id="参考文档"> 参考文档</h2>
<p><a href="https://www.bilibili.com/video/BV1x54y1979n?spm_id_from=333.337.search-card.all.click" target="_blank" rel="noopener noreferrer">MySql 事务</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">聚簇索引与非聚簇索引</title>
    <id>https://www.snowji.cn/databases/mysql/clustered-non-clustered/</id>
    <link href="https://www.snowji.cn/databases/mysql/clustered-non-clustered/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="聚簇索引与非聚簇索引"> 聚簇索引与非聚簇索引</h1>
<h2 id="什么是聚簇索引"> 什么是聚簇索引</h2>
<ul>
<li>将数据存储与索引结构放到了一块</li>
<li>索引结构的叶子节点保存了行数据</li>
</ul>
<div><p>注意</p>
<ul>
<li>主键索引一定是聚簇索引</li>
<li>聚簇索引不一定就是主键索引</li>
</ul>
</div>
<h2 id="什么是非聚簇索引"> 什么是非聚簇索引</h2>
<ul>
<li>将数据与索引结构分开存储</li>
<li>索引结构的叶子节点指向了数据对应的位置</li>
<li>InnoDB 中建立在主键索引之上的辅助索引都是非聚簇索引</li>
<li>非聚簇索引中的叶子节点存储的不是行的物理位置，而是主键值</li>
<li>辅助索引查找数据时总是需要二次查找</li>
</ul>
<div><p>重点</p>
<p>为什么非聚簇索引中的叶子节点存的是主键 id 而不是数据的地址？</p>
<p>因为数据库的增删改，会使得地址改变</p>
</div>
<h2 id="innodb-与-myisam-中索引对比"> InnoDB 与 MyISAM 中索引对比</h2>
<h3 id="innodb-中"> InnoDB 中</h3>
<ul>
<li>使用的是聚簇索引，将主键组织到一颗 B+树 中，行数据存储在叶子节点上</li>
<li>使用 <code>where id=14</code> 查找主键，则按照 B+树 的检索算法即可找到对应的叶节点获取数据</li>
<li>若对 Name 列进行条件搜索需要两个步骤(在建立非聚簇索引的情况下)：
<ul>
<li>在辅助索引 B+树 中检索 Name，在对应的叶子节点上获取对应的主键</li>
<li>使用主键在主键索引 B+树 中再执行 B+树 检索操作，最终到达叶子节点获取整行数据</li>
</ul>
</li>
<li>聚簇索引默认是主键：
<ul>
<li>如果没有定义主键，InnoDB 会选择一个**唯一且非空的索引(unique 索引)**代替</li>
<li>如果没有这样的索引，InnoDB 会**隐式定义一个主键(类似于 oracle 中的 RowId)**作为聚簇索引</li>
<li>如果已经设置了主键为聚簇索引，又希望单独设置其他的聚簇索引，必须先删除主键添加想要的聚簇索引，然后恢复主键</li>
</ul>
</li>
</ul>
<p><img src="./images/index4.png" alt="index" /></p>
<h3 id="myisam-中"> MyISAM 中</h3>
<ul>
<li>使用的是非聚簇索引</li>
<li>非聚簇索引的两颗 B+树 结构一致，只有存储的内容不一致</li>
<li>主键索引 B+树 的节点存储了主键，辅助索引 B+树 存储了辅助键</li>
<li>表数据存储在独立的地方</li>
<li>两颗 B+树 的叶子节点都使用一个地址指向真正的表数据</li>
<li>由于索引树是独立的，通过辅助键检索无需访问主键的索引树</li>
</ul>
<p><img src="./images/index3.png" alt="index" /></p>
<h3 id="聚簇索引的优势"> 聚簇索引的优势</h3>
<p>每次使用辅助索引检索都要经过两次 B+树 查找，看上去聚簇索引的效率明显要低于非聚簇索引，那聚簇索引的优势在哪？</p>
<ul>
<li>由于数据和聚簇索引的叶子节点存储在一起，同一页会有多条行数据，访问同一数据页不同行记录时，已经把页加载到 Buffer(缓存器)，再次访问时，会在内存在访问，不用进行 I/O 操作这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键 Id 来组织数据，获得数据更快</li>
<li>辅助索引的叶子节点，存储主键值，不是数据的存放地址</li>
<li>当行数据发生变化时，索引树的节点也需要分裂变化</li>
<li>需要查找数据时，在上一次 IO 读写的缓存中没有，需要发生一次新的 IO 操作时，可以避免对辅助索引的维护工作，只要维护聚簇索引树就好了</li>
<li>辅助索引存放的是主键值，减少了辅助索引占用的存储空间大小</li>
</ul>
<h2 id="使用聚簇索引的注意点"> 使用聚簇索引的注意点</h2>
<ul>
<li>使用主键为聚簇索引时，主键最好不要使用 uuid，uuid 的值太过离散，不适合排序且可能出现新增记录的 uuid 会插入在索引树中间位置，导致索引树调整复杂度变大，消耗更多的时间和资源</li>
<li>建议使用 int  类型的自增，方便排序且默认会在索引树的末尾增加主键值，对索引树的结构影响最小而且，主键值占用的存储空间越大，辅助索引中保存的主键值也会跟着变大，占用存储空间，也会影响到 IO 操作读取到的数据量</li>
</ul>
<h2 id="为什么主键通常建议使用自增-id"> 为什么主键通常建议使用自增 id</h2>
<ul>
<li>聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻存放在磁盘上</li>
<li>如果主键不是自增 id ，会不断调整数据的物理地址、分页</li>
<li>如果是自增的，只需要一页一页的写，索引结构相对紧凑，磁盘碎片少，效率也高</li>
</ul>
<h2 id="什么情况下无法利用索引"> 什么情况下无法利用索引</h2>
<ul>
<li>
<p>查询语句中使用 like 关键字</p>
<ul>
<li>如果匹配字符串的第一个字符为 % ，索引不会被使用</li>
<li>如果 % 不是在第一个位置，索引会被使用</li>
</ul>
</li>
<li>
<p>查询语句中使用多列索引</p>
<ul>
<li>只有查询条件中使用了这些字段中的第一个字段，索引才会被使用</li>
</ul>
</li>
<li>
<p>查询语句中使用 or 关键字</p>
<ul>
<li>如果 or 前后的两个条件的列都是索引，那么会使用索引</li>
<li>如果 or 前后有一个列不是索引，那么不会使用索引</li>
</ul>
</li>
</ul>
<h2 id="参考文档"> 参考文档</h2>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html" target="_blank" rel="noopener noreferrer">Clustered and Secondary Indexes</a></p>
<p><a href="https://www.bilibili.com/video/BV19y4y127h4?p=3" target="_blank" rel="noopener noreferrer">聚簇索引与非聚簇索引</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">表中列的基本属性</title>
    <id>https://www.snowji.cn/databases/mysql/column-properties/</id>
    <link href="https://www.snowji.cn/databases/mysql/column-properties/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="表中列的基本属性"> 表中列的基本属性</h1>
<h2 id="默认值"> 默认值</h2>
<p>在插入数据的时候，可以只指定插入部分的列。那些没有被显式指定的列的值将被设置默认值。在 MySQL 中，如果没有手动指定，那么列的默认值是 <code>NULL</code>，表示这个列的值还没有被设置</p>
<p>如果我们不想让默认值为 <code>NULL</code>，而是设置成某个有意义的值，可以在定义列的时候给该列增加一个 <code>DEFAULT</code> 属性，就像这样：</p>
<div><pre><code>列名 列的类型 <span>DEFAULT</span> 默认值
</code></pre>
<div><span>1</span><br></div></div><p>在建表语句中就是这样：</p>
<div><pre><code><span>CREATE</span> <span>TABLE</span> first_table <span>(</span>
    first_column <span>INT</span> <span>DEFAULT</span> <span>NULL</span><span>,</span>
    second_column <span>VARCHAR</span><span>(</span><span>100</span><span>)</span> <span>DEFAULT</span> <span>'abc'</span>
<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="not-null-属性"> NOT NULL 属性</h2>
<p>如果要求表中的某些列中必须有值，不能存放 <code>NULL</code>，那么可以用这样的语法来定义这个列：</p>
<div><pre><code>列名 列的类型 <span>NOT</span> <span>NULL</span>
</code></pre>
<div><span>1</span><br></div></div><p>例如：</p>
<div><pre><code><span>CREATE</span> <span>TABLE</span> first_table <span>(</span>
    first_column <span>INT</span> <span>NOT</span> <span>NULL</span><span>,</span>
    second_column <span>VARCHAR</span><span>(</span><span>100</span><span>)</span> <span>DEFAULT</span> <span>'abc'</span>
<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这样一来，如果还往这个字段里插入 <code>NULL</code> 值，就会报错 <code>ERROR 1048 (23000): Column 'first_column' cannot be null</code></p>
<p>另外，一旦对某个列定义了 <code>NOT NULL</code> 属性，那这个列的默认值就不为 <code>NULL</code> 了。如果在定义列属性时没有指定默认值，在使用 <code>INSERT</code> 插入行时必须显式的指定这个列的值，而不能省略它，否则也会报错 <code>ERROR 1364 (HY000): Field 'first_column' doesn't have a default value</code></p>
<h2 id="主键"> 主键</h2>
<p>一个表最多只能有一个主键，主键的值不能重复，通过主键可以找到唯一的一条记录</p>
<p>可以选用下面这两种方式之一来指定主键：</p>
<ul>
<li>
<p>如果主键只是单个列的话，可以直接在该列后声明 <code>PRIMARY KEY</code>，例如：</p>
<div><div><br><div>&nbsp;</div><br><br><br><br><br><br><br><br></div><pre><code><span>CREATE</span> <span>TABLE</span> student_info <span>(</span>
    number <span>INT</span> <span>PRIMARY</span> <span>KEY</span><span>,</span>
    name <span>VARCHAR</span><span>(</span><span>5</span><span>)</span><span>,</span>
    sex <span>ENUM</span><span>(</span><span>'男'</span><span>,</span> <span>'女'</span><span>)</span><span>,</span>
    id_number <span>CHAR</span><span>(</span><span>18</span><span>)</span><span>,</span>
    department <span>VARCHAR</span><span>(</span><span>30</span><span>)</span><span>,</span>
    major <span>VARCHAR</span><span>(</span><span>30</span><span>)</span><span>,</span>
    enrollment_time <span>DATE</span>
<span>)</span><span>;</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></li>
<li>
<p>也可以把主键的声明单独提取出来，用这样的形式声明：</p>
<div><pre><code><span>PRIMARY</span> <span>KEY</span> <span>(</span>列名<span>1</span><span>,</span> 列名<span>2</span><span>,</span> <span>.</span><span>.</span><span>.</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>然后把这个主键声明放到列定义的后面，就像这样：</p>
<div><div><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br></div><pre><code><span>CREATE</span> <span>TABLE</span> student_info <span>(</span>
    number <span>INT</span><span>,</span>
    name <span>VARCHAR</span><span>(</span><span>5</span><span>)</span><span>,</span>
    sex <span>ENUM</span><span>(</span><span>'男'</span><span>,</span> <span>'女'</span><span>)</span><span>,</span>
    id_number <span>CHAR</span><span>(</span><span>18</span><span>)</span><span>,</span>
    department <span>VARCHAR</span><span>(</span><span>30</span><span>)</span><span>,</span>
    major <span>VARCHAR</span><span>(</span><span>30</span><span>)</span><span>,</span>
    enrollment_time <span>DATE</span><span>,</span>
    <span>PRIMARY</span> <span>KEY</span> <span>(</span>number<span>)</span>
<span>)</span><span>;</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>对于多个列的组合作为主键的情况，必须使用这种单独声明的形式。例如：</p>
<div><div><br><br><br><br><div>&nbsp;</div><br><br></div><pre><code><span>CREATE</span> <span>TABLE</span> student_score <span>(</span>
    number <span>INT</span><span>,</span>
    subject <span>VARCHAR</span><span>(</span><span>30</span><span>)</span><span>,</span>
    score <span>TINYINT</span><span>,</span>
    <span>PRIMARY</span> <span>KEY</span> <span>(</span>number<span>,</span> subject<span>)</span>
<span>)</span><span>;</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
</ul>
<p>另外，主键列默认是有 <code>NOT NULL</code> 属性，也就是必填的，如果填入 <code>NULL</code> 值会报错</p>
<h2 id="unique-属性"> UNIQUE 属性</h2>
<p>表明该列或者列组合的值是不允许重复的</p>
<p>声明方式有两种：</p>
<ul>
<li>
<p>为单个列声明 <code>UNIQUE</code> 属性，可以直接在该列后填写 <code>UNIQUE</code> 或者 <code>UNIQUE KEY</code>，例如：</p>
<div><div><br><br><br><br><div>&nbsp;</div><br><br><br><br><br></div><pre><code><span>CREATE</span> <span>TABLE</span> student_info <span>(</span>
    number <span>INT</span> <span>PRIMARY</span> <span>KEY</span><span>,</span>
    name <span>VARCHAR</span><span>(</span><span>5</span><span>)</span><span>,</span>
    sex <span>ENUM</span><span>(</span><span>'男'</span><span>,</span> <span>'女'</span><span>)</span><span>,</span>
    id_number <span>CHAR</span><span>(</span><span>18</span><span>)</span> <span>UNIQUE</span><span>,</span>
    department <span>VARCHAR</span><span>(</span><span>30</span><span>)</span><span>,</span>
    major <span>VARCHAR</span><span>(</span><span>30</span><span>)</span><span>,</span>
    enrollment_time <span>DATE</span>
<span>)</span><span>;</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></li>
<li>
<p>也可以把 <code>UNIQUE</code> 属性的声明单独提取出来，用这样的形式声明（中括号 <code>[]</code> 里的约束名称可以不写，它类似给这个 <code>UNIQUE</code> 属性起个别名，如果不写的话系统也会自动起一个）：</p>
<div><pre><code><span>UNIQUE</span> <span>[</span>约束名称<span>]</span> <span>(</span>列名<span>1</span><span>,</span> 列名<span>2</span><span>,</span> <span>.</span><span>.</span><span>.</span><span>)</span>
<span># 或者</span>
<span>UNIQUE</span> <span>KEY</span> <span>[</span>约束名称<span>]</span> <span>(</span>列名<span>1</span><span>,</span> 列名<span>2</span><span>,</span> <span>.</span><span>.</span><span>.</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>然后把这个 <code>UNIQUE</code> 属性的声明放到列定义的后面，就像这样：</p>
<div><div><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br></div><pre><code><span>CREATE</span> <span>TABLE</span> student_info <span>(</span>
    number <span>INT</span> <span>PRIMARY</span> <span>KEY</span><span>,</span>
    name <span>VARCHAR</span><span>(</span><span>5</span><span>)</span><span>,</span>
    sex <span>ENUM</span><span>(</span><span>'男'</span><span>,</span> <span>'女'</span><span>)</span><span>,</span>
    id_number <span>CHAR</span><span>(</span><span>18</span><span>)</span><span>,</span>
    department <span>VARCHAR</span><span>(</span><span>30</span><span>)</span><span>,</span>
    major <span>VARCHAR</span><span>(</span><span>30</span><span>)</span><span>,</span>
    enrollment_time <span>DATE</span><span>,</span>
    <span>UNIQUE</span> <span>KEY</span> uk_id_number <span>(</span>id_number<span>)</span>
<span>)</span><span>;</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>对于多个列的组合具有 <code>UNIQUE</code> 属性的情况，必须使用这种单独声明的形式</p>
</li>
</ul>
<p>如果表中为某个列或者列组合定义了 <code>UNIQUE</code> 属性的话，MySQL 就会对插入的记录做校验，如果新插入记录在该列或者列组合的值已经在表中存在了，那就会报错</p>
<h2 id="主键和-unique-约束的区别"> 主键和 UNIQUE 约束的区别</h2>
<ul>
<li>一张表中只能定义一个主键，却可以定义多个 <code>UNIQUE</code> 约束</li>
<li>规定：主键列不允许存放 <code>NULL</code>，而声明了 <code>UNIQUE</code> 属性的列可以存放 <code>NULL</code>，而且 <code>NULL</code> 可以重复地出现在多条记录中</li>
</ul>
<div><p>小贴士</p>
<p><code>NULL</code> 其实并不是一个值，它代表不确定，我们平常说某个列的值为 <code>NULL</code>，意味着这一列的值尚未被填入</p>
</div>
<h2 id="外键"> 外键</h2>
<p>定义外键的语法：</p>
<div><pre><code><span>CONSTRAINT</span> <span>[</span>外键名称<span>]</span> <span>FOREIGN</span> <span>KEY</span><span>(</span>列<span>1</span><span>,</span> 列<span>2</span><span>,</span> <span>.</span><span>.</span><span>.</span><span>)</span> <span>REFERENCES</span> 父表名<span>(</span>父列<span>1</span><span>,</span> 父列<span>2</span><span>,</span> <span>.</span><span>.</span><span>.</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>其中的外键名称是可选的，如果不自己命名的话，MySQL 会自动帮助我们命名</p>
<p>如果 A 表中的某个列或者某些列依赖于 B 表中的某个列或者某些列，那么就称 A 表为子表，B 表为父表。子表和父表可以使用外键来关联起来</p>
<p>比如学生成绩表中的学号（<code>number</code>）列，依赖于学生信息表中的学号（<code>number</code>）列，那么学生成绩表就是一个子表，可以在它的建表语句中定义一个外键：</p>
<div><div><br><br><br><br><br><div>&nbsp;</div><br><br></div><pre><code><span>CREATE</span> <span>TABLE</span> student_score <span>(</span>
    number <span>INT</span><span>,</span>
    subject <span>VARCHAR</span><span>(</span><span>30</span><span>)</span><span>,</span>
    score <span>TINYINT</span><span>,</span>
    <span>PRIMARY</span> <span>KEY</span> <span>(</span>number<span>,</span> subject<span>)</span><span>,</span>
    <span>CONSTRAINT</span> <span>FOREIGN</span> <span>KEY</span><span>(</span>number<span>)</span> <span>REFERENCES</span> student_info<span>(</span>number<span>)</span>
<span>)</span><span>;</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>这样，在对 <code>student_score</code> 表插入数据的时候，MySQL 都会检查一下插入的学号是否能在 <code>student_info</code> 表中找到，如果找不到则会报错</p>
<div><p>小贴士</p>
<p>父表中被子表依赖的列或者列组合必须建立索引，如果该列或者列组合已经是主键或者有 <code>UNIQUE</code> 属性，那么它们也就被默认建立了索引</p>
<p>至于什么是索引，这里先不展开讨论，总之用来建立外键的列一般都是主键或者有 <code>UNIQUE</code> 属性的就对了，这样就不容易遇到问题</p>
</div>
<h2 id="auto-increment-属性"> AUTO_INCREMENT 属性</h2>
<p><code>AUTO_INCREMENT</code> 就是自增的意思，用于设置给整数类型或者浮点数类型的列</p>
<p>如果在插入新记录的时候不指定该列的值，或者将该列的值显式地指定为 <code>NULL</code> 或者 <code>0</code>，那么新插入的记录在该列上的值就是当前该列的最大值加 1 后的值</p>
<p>定义这个属性的语法如下：</p>
<div><pre><code>列名 列的类型 <span>AUTO_INCREMENT</span>
</code></pre>
<div><span>1</span><br></div></div><p>比如建表时有一个非负 <code>INT</code> 类型的 <code>id</code> 列，把它设置为主键而且具有 <code>AUTO_INCREMENT</code> 属性：</p>
<div><div><br><div>&nbsp;</div><br><br><br><br></div><pre><code><span>CREATE</span> <span>TABLE</span> first_table <span>(</span>
    id <span>INT</span> <span>UNSIGNED</span> <span>AUTO_INCREMENT</span> <span>PRIMARY</span> <span>KEY</span><span>,</span>
    first_column <span>INT</span><span>,</span>
    second_column <span>VARCHAR</span><span>(</span><span>100</span><span>)</span> <span>DEFAULT</span> <span>'abc'</span>
<span>)</span><span>;</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>接下来我们在插入新记录时可以忽略掉这个列，或者将列值显式地指定为 <code>NULL</code> 或 <code>0</code>，但是它的值是从 <code>1</code> 开始递增的</p>
<p>注意事项：</p>
<ul>
<li>一个表中最多有一个具有 <code>AUTO_INCREMENT</code> 属性的列</li>
<li>具有 <code>AUTO_INCREMENT</code> 属性的列必须建立索引。主键和具有 <code>UNIQUE</code> 属性的列会自动建立索引</li>
<li>拥有 <code>AUTO_INCREMENT</code> 属性的列就不能再通过指定DEFAULT属性来指定默认值</li>
<li>一般拥有 <code>AUTO_INCREMENT</code> 属性的列都是作为主键的属性，来自动生成唯一标识一条记录的主键值</li>
</ul>
<h2 id="列的注释"> 列的注释</h2>
<p>除了可以在建表语句的末尾添加 <code>COMMENT</code> 语句来给表添加注释，也可以在每一个列末尾添加 <code>COMMENT</code> 语句来为列来添加注释。</p>
<p>比如：</p>
<div><pre><code><span>CREATE</span> <span>TABLE</span> first_table <span>(</span>
    id <span>int</span> <span>UNSIGNED</span> <span>AUTO_INCREMENT</span> <span>PRIMARY</span> <span>KEY</span> <span>COMMENT</span> <span>'自增主键'</span><span>,</span>
    first_column <span>INT</span> <span>COMMENT</span> <span>'第一列'</span><span>,</span>
    second_column <span>VARCHAR</span><span>(</span><span>100</span><span>)</span> <span>DEFAULT</span> <span>'abc'</span> <span>COMMENT</span> <span>'第二列'</span>
<span>)</span> <span>COMMENT</span> <span>'第一个表'</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="影响展示外观的-zerofill-属性"> 影响展示外观的 ZEROFILL 属性</h2>
<p>举个例子，正整数 <code>3</code> 可以有三种写法：</p>
<ul>
<li>写法一：<code>3</code></li>
<li>写法二：<code>003</code></li>
<li>写法三：<code>000003</code></li>
</ul>
<p><code>ZEROFILL</code> 属性就是做这样的事的：对于无符号整数类型的列，可以在查询数据的时候让数字左边补 0</p>
<p>用法示例：</p>
<div><pre><code><span>CREATE</span> <span>TABLE</span> zerofill_table <span>(</span>
    i1 <span>INT</span><span>(</span><span>5</span><span>)</span> <span>UNSIGNED</span> ZEROFILL<span>,</span>
    i2 <span>INT</span> <span>UNSIGNED</span>
<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面定义的两个列都是无符号整数类型，而 <code>i1</code> 后面的 <code>(5)</code> 表示<strong>显示宽度</strong>。也就是如果声明了 <code>ZEROFILL</code> 属性的整数列的实际值的位数小于显示宽度时，会在实际值的左侧补 0，使补0的位数和实际值的位数相加正好等于显示宽度</p>
<p>注意事项：</p>
<ul>
<li>在展示查询结果时，某列数据自动补 0 的条件有这几个：
<ul>
<li>该列必须是整数类型的</li>
<li>该列必须有 <code>UNSIGNED ZEROFILL</code> 的属性</li>
<li>该列的实际值的位数必须小于显示宽度时才会补 0</li>
<li>实际值的位数大于显示宽度时照原样输出</li>
</ul>
</li>
<li>在创建表的时候，如果声明了 <code>ZEROFILL</code> 属性的列没有声明 <code>UNSIGNED</code> 属性，那 MySQL 会为该列自动生成 <code>UNSIGNED</code> 属性
<ul>
<li>也就是说 MySQL 现在只支持对无符号整数进行自动补 0 的操作</li>
</ul>
</li>
<li>每个整数类型都会有默认的显示宽度
<ul>
<li><code>TINYINT</code> 的默认显示宽度是 <code>(4)</code></li>
<li><code>INT</code> 的默认显示宽度是 <code>(11)</code></li>
<li>如果加了 <code>UNSIGNED</code> 属性，则该类型的显示宽度减 1</li>
<li>可以使用 <code>SHOW CREATE TABLE 表名\G</code> 查看已经生成的表，其列的显示宽度</li>
</ul>
</li>
<li>显示宽度并不会影响该数据类型要求的存储空间以及该类型能存储的数据范围，仅在展示时有区别</li>
<li>对于没有声明 <code>ZEROFILL</code> 属性的列，显示宽度没有任何用处</li>
</ul>
<h2 id="一个列同时具有多个属性"> 一个列同时具有多个属性</h2>
<p>每个列可以同时具有多个属性，属性声明的顺序无所谓，各个属性之间用空白隔开就好了</p>
<div><p>小贴士</p>
<p>有的属性是冲突的，一个列不能具有两个冲突的属性</p>
<p>如一个列不能既声明为 <code>PRIMARY KEY</code>，又声明为 <code>UNIQUE KEY</code>；不能既声明为 <code>DEFAULT NULL</code>，又声明为 <code>NOT NULL</code>。需要注意这一点</p>
</div>
<h2 id="查看表结构时的列属性"> 查看表结构时的列属性</h2>
<p>建表：</p>
<div><div><div>&nbsp;</div><br><br><br><br><div>&nbsp;</div><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br></div><pre><code>mysql<span>></span> <span>use</span> school<span>;</span>
Reading <span>table</span> information <span>for</span> completion <span>of</span> <span>table</span> <span>and</span> <span>column</span> names
You can turn <span>off</span> this feature <span>to</span> get a quicker startup <span>with</span> <span>-</span>A

<span>Database</span> changed
mysql<span>></span> <span>DROP</span> <span>TABLE</span> student_info<span>;</span>
Query OK<span>,</span> <span>0</span> <span>rows</span> affected <span>(</span><span>0.04</span> sec<span>)</span>

mysql<span>></span> <span>CREATE</span> <span>TABLE</span> student_info <span>(</span>
    <span>-</span><span>></span>     number <span>INT</span> <span>PRIMARY</span> <span>KEY</span><span>,</span>
    <span>-</span><span>></span>     name <span>VARCHAR</span><span>(</span><span>5</span><span>)</span><span>,</span>
    <span>-</span><span>></span>     sex <span>ENUM</span><span>(</span><span>'男'</span><span>,</span> <span>'女'</span><span>)</span><span>,</span>
    <span>-</span><span>></span>     id_number <span>CHAR</span><span>(</span><span>18</span><span>)</span><span>,</span>
    <span>-</span><span>></span>     department <span>VARCHAR</span><span>(</span><span>30</span><span>)</span><span>,</span>
    <span>-</span><span>></span>     major <span>VARCHAR</span><span>(</span><span>30</span><span>)</span><span>,</span>
    <span>-</span><span>></span>     enrollment_time <span>DATE</span><span>,</span>
    <span>-</span><span>></span>     <span>UNIQUE</span> <span>KEY</span> uk_id_number <span>(</span>id_number<span>)</span>
    <span>-</span><span>></span> <span>)</span><span>;</span>
Query OK<span>,</span> <span>0</span> <span>rows</span> affected <span>(</span><span>0.07</span> sec<span>)</span>

mysql<span>></span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>查询：</p>
<div><pre><code>mysql<span>></span> <span>DESC</span> student_info<span>;</span>
<span>+</span><span>-----------------+-------------------+------+-----+---------+-------+</span>
<span>|</span> Field           <span>|</span> <span>Type</span>              <span>|</span> <span>Null</span> <span>|</span> <span>Key</span> <span>|</span> <span>Default</span> <span>|</span> Extra <span>|</span>
<span>+</span><span>-----------------+-------------------+------+-----+---------+-------+</span>
<span>|</span> number          <span>|</span> <span>int</span>               <span>|</span> <span>NO</span>   <span>|</span> PRI <span>|</span> <span>NULL</span>    <span>|</span>       <span>|</span>
<span>|</span> name            <span>|</span> <span>varchar</span><span>(</span><span>5</span><span>)</span>        <span>|</span> YES  <span>|</span>     <span>|</span> <span>NULL</span>    <span>|</span>       <span>|</span>
<span>|</span> sex             <span>|</span> <span>enum</span><span>(</span><span>'男'</span><span>,</span><span>'女'</span><span>)</span>   <span>|</span> YES  <span>|</span>     <span>|</span> <span>NULL</span>    <span>|</span>       <span>|</span>
<span>|</span> id_number       <span>|</span> <span>char</span><span>(</span><span>18</span><span>)</span>          <span>|</span> YES  <span>|</span> UNI <span>|</span> <span>NULL</span>    <span>|</span>       <span>|</span>
<span>|</span> department      <span>|</span> <span>varchar</span><span>(</span><span>30</span><span>)</span>       <span>|</span> YES  <span>|</span>     <span>|</span> <span>NULL</span>    <span>|</span>       <span>|</span>
<span>|</span> major           <span>|</span> <span>varchar</span><span>(</span><span>30</span><span>)</span>       <span>|</span> YES  <span>|</span>     <span>|</span> <span>NULL</span>    <span>|</span>       <span>|</span>
<span>|</span> enrollment_time <span>|</span> <span>date</span>              <span>|</span> YES  <span>|</span>     <span>|</span> <span>NULL</span>    <span>|</span>       <span>|</span>
<span>+</span><span>-----------------+-------------------+------+-----+---------+-------+</span>
<span>7</span> <span>rows</span> <span>in</span> <span>set</span> <span>(</span><span>0.00</span> sec<span>)</span>

mysql<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><ul>
<li><code>NULL</code> 列代表该列是否可以存储 <code>NULL</code>，值为 <code>NO</code> 表示不允许存储 <code>NULL</code>，值为 <code>YES</code> 表示可以存储 <code>NULL</code></li>
<li><code>Key</code> 列存储关于键的信息，值为 <code>PRI</code> 是 <code>PRIMARY KEY</code> 的缩写，代表主键；<code>UNI</code> 是 <code>UNIQUE KEY</code> 的缩写，代表 <code>UNIQUE</code> 属性</li>
<li><code>Default</code> 列代表该列的默认值</li>
<li><code>Extra</code> 列展示一些额外的信息。例如，如果某个列具有 <code>AUTO_INCREMENT</code> 属性就会被展示在这个列里</li>
</ul>
<h2 id="标识符的命名"> 标识符的命名</h2>
<p>像数据库名、表名、列名、约束名称或者我们之后会遇到的别的名称，这些名称统统被称为<strong>标识符</strong></p>
<p>虽然 MySQL 中对标识符的命名没多少限制，但是<strong>最好杜绝</strong>下面的这几种命名：</p>
<ul>
<li>
<p>名称中全都是数字</p>
<p>因为在一些MySQL语句中也会使用到数字，如果你起的名称中全部都是数字，会让 MySQL 服务器分别不清哪个是名称，哪个是数字了。比如名称 <code>1234567</code> 就是非法的</p>
</li>
<li>
<p>名称中有空白字符</p>
<p>MySQL 命令是靠空白字符来分隔各个单词的，比如下边这两行命令是等价的：</p>
<div><pre><code><span>CREATE</span> <span>DATABASE</span> school<span>;</span>
<span>CREATE</span>   <span>DATABASE</span>   school<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>但是如果你定义的名称中有空白字符，这样会被当作两个词去处理，就会造成歧义。比如名称 <code>word1 word2 word3</code> 就是非法的</p>
</li>
<li>
<p>名称使用了 MySQL 中的保留字</p>
<p>比如 <code>CREATE</code>、<code>DATABASE</code>、<code>INT</code>、<code>DOUBLE</code>、<code>DROP</code>、<code>TABLE</code> 等等这些单词，这些单词都是供 MySQL 内部使用的，称之为保留字。如果你自己定义的名称用到了这些词也会导致歧义。比如名称 <code>create</code> 就是非法的</p>
</li>
</ul>
<p>如果你一根筋就是坚持要使用的话，也不是不行，你可以使用反引号将自定义的名称扩起来，这样 MySQL 的服务器就能检测到你提供的是一个名称而不是别的东西，比如说把上面几个非法的名称加上反引号就变成合法的名称了：</p>
<div><pre><code><span><span>`</span><span>1234567</span><span>`</span></span>
<span><span>`</span>word1 word2    word3<span>`</span></span>
<span><span>`</span>create<span>`</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>虽然反引号比较强大，但还是建议不要起各种非主流的名称，也不要使用全数字、带有空白字符或者 MySQL 保留字的名称</p>
<p>反引号更好的用途是可以把建表语句中的标识符给引起来，这样语义更清晰一点，看一下是不是表清晰了：</p>
<div><pre><code><span>CREATE</span> <span>TABLE</span> <span><span>`</span>first_table<span>`</span></span> <span>(</span>
    <span><span>`</span>id<span>`</span></span> <span>int</span> <span>UNSIGNED</span> <span>AUTO_INCREMENT</span> <span>PRIMARY</span> <span>KEY</span><span>,</span>
    <span><span>`</span>first_column<span>`</span></span> <span>INT</span><span>,</span>
    <span><span>`</span>second_column<span>`</span></span> <span>VARCHAR</span><span>(</span><span>100</span><span>)</span> <span>DEFAULT</span> <span>'abc'</span>
<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>最后，由于 MySQL 是 C 语言实现的，所以在名称定义上还是尽量遵从 C 语言的规范吧：即<strong>用小写字母、数字、下划线、美元符号等作为名称，如果有多个单词的话，各个单词之间用下划线连接起来</strong></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">MySQL 常用命令</title>
    <id>https://www.snowji.cn/databases/mysql/common-commands/</id>
    <link href="https://www.snowji.cn/databases/mysql/common-commands/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="mysql-常用命令"> MySQL 常用命令</h1>
<p>有时候不能使用可视化工具，就需要通过一些命令快速查看和操作数据库数据</p>
<div><pre><code><span># 连接 mysql（注：-h、-P、-u、-p 后面可以不用加空格）</span>
mysql <span>-</span>h主机地址 <span>-</span>P端口 <span>-</span>u用户名 <span>-</span>p用户密码

<span># 显示数据库</span>
mysql<span>></span> <span>show</span> <span>databases</span><span>;</span>

<span># 使用某个数据库</span>
mysql<span>></span> <span>use</span> xxx<span>;</span>

<span># 查看该数据库中的表</span>
mysql<span>></span> <span>show</span> <span>tables</span><span>;</span>

<span># 显示数据表的结构</span>
mysql<span>></span> <span>describe</span> 表名<span>;</span>

<span># 显示表中的记录（注意表名大小写）</span>
mysql<span>></span> <span>select</span> <span>*</span> <span>from</span> 表名<span>;</span>

<span># 创建数据库</span>
mysql<span>></span> <span>create</span> <span>database</span> 数据库名<span>;</span>

<span># 建表  </span>
<span>use</span> 库名<span>;</span>
<span>create</span> <span>table</span> 表名 跟上字段列表<span>;</span>
<span># 例如：创建表 user，表中有 id（序号，自增），name（姓名），gender（性别），birthday（出身年月）四个字段  </span>
mysql<span>></span> <span>use</span> blog<span>;</span>  
mysql<span>></span> <span>create</span> <span>table</span> <span>user</span> <span>(</span>id <span>int</span><span>(</span><span>3</span><span>)</span> <span>auto_increment</span> <span>not</span> <span>null</span> <span>primary</span> <span>key</span><span>,</span> name <span>char</span><span>(</span><span>8</span><span>)</span><span>,</span>gender <span>char</span><span>(</span><span>2</span><span>)</span><span>,</span>birthday <span>date</span><span>)</span><span>;</span>
mysql<span>></span> <span>describe</span> name<span>;</span>

<span># 往表中增加数据</span>
<span># 例如：增加几条相关纪录。  </span>
mysql<span>></span> <span>insert</span> <span>into</span> <span>user</span> <span>values</span><span>(</span><span>''</span><span>,</span><span>'张三'</span><span>,</span><span>'男'</span><span>,</span><span>'2019-01-01'</span><span>)</span><span>;</span>  
mysql<span>></span> <span>insert</span> <span>into</span> <span>user</span> <span>values</span><span>(</span><span>''</span><span>,</span><span>'李四'</span><span>,</span><span>'女'</span><span>,</span><span>'2020-06-01'</span><span>)</span><span>;</span>
mysql<span>></span> <span>select</span> <span>*</span> <span>from</span> name<span>;</span>

<span># 修改表中数据</span>
<span># 例如：将张三的出生年月改为 2019-06-01</span>
mysql<span>></span> <span>update</span> <span>user</span> <span>set</span> birthday<span>=</span><span>'2019-01-01'</span> <span>where</span> name<span>=</span><span>'张三'</span><span>;</span>  

<span># 删除某表中的数据  </span>
<span># 例如：删除名字是张三的数据。  </span>
mysql<span>></span> <span>delete</span> <span>from</span> <span>user</span> <span>where</span> name<span>=</span><span>'张三'</span><span>;</span>  

<span># 删库和删表  </span>
mysql<span>></span> <span>drop</span> <span>database</span> 库名<span>;</span>
mysql<span>></span> <span>drop</span> <span>table</span> 表名<span>;</span>

<span># 退出mysql</span>
mysql<span>></span> <span>exit</span> <span>(</span>回车<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">数据的增删改</title>
    <id>https://www.snowji.cn/databases/mysql/data-insert-delete-update/</id>
    <link href="https://www.snowji.cn/databases/mysql/data-insert-delete-update/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="数据的增删改"> 数据的增删改</h1>
<blockquote>
<p>这一篇里创建的两张表：学生信息表和学生成绩表，以及里面插入的一些模拟数据，在后面的查询相关文章里也会用到</p>
</blockquote>
<p>数据库的表里得先有数据之后查询才有意义，所以这里先整理各种对表中数据的操作，包括插入数据、删除数据和更新数据</p>
<h2 id="创建表"> 创建表</h2>
<p>插入数据之前需要先创建表，假设要创建两个表</p>
<p>创建学生信息表 <code>student_info</code>：</p>
<div><pre><code><span>CREATE</span> <span>TABLE</span> student_info <span>(</span>
    number <span>INT</span> <span>PRIMARY</span> <span>KEY</span><span>,</span>
    name <span>VARCHAR</span><span>(</span><span>5</span><span>)</span><span>,</span>
    sex <span>ENUM</span><span>(</span><span>'男'</span><span>,</span> <span>'女'</span><span>)</span><span>,</span>
    id_number <span>CHAR</span><span>(</span><span>18</span><span>)</span><span>,</span>
    department <span>VARCHAR</span><span>(</span><span>30</span><span>)</span><span>,</span>
    major <span>VARCHAR</span><span>(</span><span>30</span><span>)</span><span>,</span>
    enrollment_time <span>DATE</span><span>,</span>
    <span>UNIQUE</span> <span>KEY</span> <span>(</span>id_number<span>)</span>
<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>创建学生成绩表 <code>student_score</code>：</p>
<div><pre><code><span>CREATE</span> <span>TABLE</span> student_score <span>(</span>
    number <span>INT</span><span>,</span>
    subject <span>VARCHAR</span><span>(</span><span>30</span><span>)</span><span>,</span>
    score <span>TINYINT</span><span>,</span>
    <span>PRIMARY</span> <span>KEY</span> <span>(</span>number<span>,</span> subject<span>)</span><span>,</span>
    <span>CONSTRAINT</span> <span>FOREIGN</span> <span>KEY</span><span>(</span>number<span>)</span> <span>REFERENCES</span> student_info<span>(</span>number<span>)</span>
<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="插入数据"> 插入数据</h2>
<p>在关系型数据库中，数据一般都是以记录（或者说行）为单位被插入到表中的，有几种插入形式</p>
<h3 id="插入完整的记录"> 插入完整的记录</h3>
<p>语法格式：</p>
<div><pre><code><span>INSERT</span> <span>INTO</span> 表名<span>(</span>列<span>1</span><span>,</span> 列<span>2</span><span>,</span> <span>.</span><span>.</span><span>.</span><span>)</span> <span>VALUES</span> <span>(</span>列<span>1</span>的值，列<span>2</span>的值<span>,</span> <span>.</span><span>.</span><span>.</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>有时候为了方便，可以批量插入数据。只需要在原来的单条插入语句后边多写几条记录的内容，用逗号分隔开就好了。语法格式如下：</p>
<div><pre><code><span>INSERT</span> <span>INTO</span> 表名<span>(</span>列<span>1</span><span>,</span>列<span>2</span><span>,</span> <span>.</span><span>.</span><span>.</span><span>)</span> VAULES 
<span>(</span>列<span>1</span>的值，列<span>2</span>的值<span>,</span> <span>.</span><span>.</span><span>.</span><span>)</span><span>,</span> 
<span>(</span>列<span>1</span>的值，列<span>2</span>的值<span>,</span> <span>.</span><span>.</span><span>.</span><span>)</span><span>,</span> 
<span>(</span>列<span>1</span>的值，列<span>2</span>的值<span>,</span> <span>.</span><span>.</span><span>.</span><span>)</span><span>,</span> 
<span>.</span><span>.</span><span>.</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>示例如下：</p>
<ul>
<li>
<p>给学生信息表插入一些数据：</p>
<div><pre><code><span>INSERT</span> <span>INTO</span> student_info<span>(</span>number<span>,</span> name<span>,</span> sex<span>,</span> id_number<span>,</span> department<span>,</span> major<span>,</span> enrollment_time<span>)</span> <span>VALUES</span> 
<span>(</span><span>20220101</span><span>,</span> <span>'张星星'</span><span>,</span> <span>'男'</span><span>,</span> <span>'158177199901044792'</span><span>,</span> <span>'计算机学院'</span><span>,</span> <span>'计算机科学与工程'</span><span>,</span> <span>'2022-09-01'</span><span>)</span><span>,</span>
<span>(</span><span>20220102</span><span>,</span> <span>'王二狗'</span><span>,</span> <span>'女'</span><span>,</span> <span>'151008199801178529'</span><span>,</span> <span>'计算机学院'</span><span>,</span> <span>'计算机科学与工程'</span><span>,</span> <span>'2022-09-01'</span><span>)</span><span>,</span>
<span>(</span><span>20220103</span><span>,</span> <span>'陈珊珊'</span><span>,</span> <span>'男'</span><span>,</span> <span>'17156319980116959X'</span><span>,</span> <span>'计算机学院'</span><span>,</span> <span>'软件工程'</span><span>,</span> <span>'2022-09-01'</span><span>)</span><span>,</span>
<span>(</span><span>20220104</span><span>,</span> <span>'李思思'</span><span>,</span> <span>'女'</span><span>,</span> <span>'141992199701078600'</span><span>,</span> <span>'计算机学院'</span><span>,</span> <span>'软件工程'</span><span>,</span> <span>'2022-09-01'</span><span>)</span><span>,</span>
<span>(</span><span>20220105</span><span>,</span> <span>'孙小武'</span><span>,</span> <span>'男'</span><span>,</span> <span>'181048199308156368'</span><span>,</span> <span>'航天学院'</span><span>,</span> <span>'飞行器设计'</span><span>,</span> <span>'2022-09-01'</span><span>)</span><span>,</span>
<span>(</span><span>20220106</span><span>,</span> <span>'刘大彪'</span><span>,</span> <span>'男'</span><span>,</span> <span>'197995199501078445'</span><span>,</span> <span>'航天学院'</span><span>,</span> <span>'电子信息'</span><span>,</span> <span>'2022-09-01'</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
<li>
<p>给学生成绩表插入一些数据：</p>
<div><pre><code><span>INSERT</span> <span>INTO</span> student_score <span>(</span>number<span>,</span> subject<span>,</span> score<span>)</span> <span>VALUES</span> 
<span>(</span><span>20220101</span><span>,</span> <span>'高等数学'</span><span>,</span> <span>78</span><span>)</span><span>,</span>
<span>(</span><span>20220101</span><span>,</span> <span>'大学英语'</span><span>,</span> <span>88</span><span>)</span><span>,</span>
<span>(</span><span>20220102</span><span>,</span> <span>'高等数学'</span><span>,</span> <span>100</span><span>)</span><span>,</span>
<span>(</span><span>20220102</span><span>,</span> <span>'大学英语'</span><span>,</span> <span>98</span><span>)</span><span>,</span>
<span>(</span><span>20220103</span><span>,</span> <span>'高等数学'</span><span>,</span> <span>59</span><span>)</span><span>,</span>
<span>(</span><span>20220103</span><span>,</span> <span>'大学英语'</span><span>,</span> <span>61</span><span>)</span><span>,</span>
<span>(</span><span>20220104</span><span>,</span> <span>'高等数学'</span><span>,</span> <span>55</span><span>)</span><span>,</span>
<span>(</span><span>20220104</span><span>,</span> <span>'大学英语'</span><span>,</span> <span>46</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></li>
</ul>
<div><p>小贴士</p>
<p><code>INSERT</code> 语句中指定的列顺序可以改变，但是一定要和 <code>VALUES</code> 列表中的值一一对应起来</p>
</div>
<h3 id="插入记录的一部分"> 插入记录的一部分</h3>
<p>在插入数据的时候，也可以只指定部分的列以及对应的值，没有显式指定的列的值将被设置为 <code>NULL</code></p>
<p>但前提是省略的列必须满足下面两个条件之一：</p>
<ul>
<li>该列允许存储 <code>NULL</code> 值</li>
<li>该列有 <code>DEFAULT</code> 属性，给出了默认值</li>
</ul>
<h3 id="将某个查询的结果集插入表中"> 将某个查询的结果集插入表中</h3>
<p>除了手动显式地将记录的值放在 <code>VALUES</code> 后面，也可以将某个查询的结果集作为数据源插入到表中</p>
<p>比如把 <code>first_table</code> 表中的一些数据插入到 <code>second_table</code> 表里面，可以这么写：</p>
<div><pre><code><span>INSERT</span> <span>INTO</span> second_table<span>(</span>column_a<span>,</span> column_b<span>)</span> <span>SELECT</span> first_column<span>,</span> second_column <span>FROM</span> first_table <span>WHERE</span> first_column <span>&lt;</span> <span>5</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>把这条 <code>INSERT</code> 语句分成两部分来理解就是：先执行查询语句，然后把查询语句得到的结果集插入到指定的表中</p>
<p>有一个注意点：<code>INSERT</code> 语句指定的列要和查询语句中指定的列一一对应</p>
<h3 id="insert-ignore"> INSERT IGNORE</h3>
<p>对于一些是主键或者具有 <code>UNIQUE</code> 约束的列或者列组合来说，它们不允许重复值的出现。所以如果待插入记录的列值与已有的值重复的话就会报错</p>
<p>如果不知道待插入数据中的列有没有和已存在记录中某些唯一值重复，但仍然想正常执行插入语句，只不过加一点保护：</p>
<ul>
<li>如果不存在重复的值，就把待插入记录插到表中</li>
<li>否则忽略此次插入操作</li>
</ul>
<p>就可以用到 <code>INSERT IGNORE</code> 语法：</p>
<div><pre><code><span>INSERT</span> <span>IGNORE</span> <span>INTO</span> first_table<span>(</span>first_column<span>,</span> second_column<span>)</span> <span>VALUES</span> <span>(</span><span>10001</span><span>,</span> <span>'榴莲味的冰淇淋'</span><span>)</span> <span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>对于批量插入的情况，<code>INSERT IGNORE</code> 同样适用，会将符合唯一性条件的数据全部插入，忽略不符合要求的数据</p>
<h3 id="insert-on-duplicate-key-update"> INSERT ON DUPLICATE KEY UPDATE</h3>
<p>对于主键或者有唯一性约束的列或列组合来说，新插入的记录如果和表中已存在的记录重复的话，我们可以选择的策略不仅仅是忽略该条记录的插入，也可以选择更新这条重复的旧记录</p>
<p>这时就要用到 <code>INSERT ... ON DUPLICATE KEY UPDATE ...</code> 的语法：</p>
<div><pre><code><span>INSERT</span> <span>INTO</span> first_table <span>(</span>first_column<span>,</span> second_column<span>)</span> <span>VALUES</span> <span>(</span><span>10001</span><span>,</span> <span>'榴莲味的冰淇淋'</span><span>)</span> <span>ON</span> <span>DUPLICATE</span> <span>KEY</span> <span>UPDATE</span> second_column <span>=</span> <span>'榴莲味的冰淇淋'</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>这个语句的意思就是，对于要插入的数据 <code>(10001, '榴莲味的冰淇淋')</code> 来说，如果表中已经存在 <code>first_column</code> 的列值为 <code>10001</code> 的记录（因为 <code>first_column</code> 列具有 <code>UNIQUE</code> 约束），那么就把该记录的 <code>second_column</code> 列更新为 <code>'榴莲味的冰淇淋'</code></p>
<p>在批量插入大量记录的时候这条语句怎么写呢？我们可以使用 <code>VALUES(列名)</code> 的形式来引用待插入记录中对应列的值，如下所示：</p>
<div><pre><code><span>INSERT</span> <span>INTO</span> first_table <span>(</span>first_column<span>,</span> second_column<span>)</span> <span>VALUES</span> 
<span>(</span><span>10002</span><span>,</span> <span>'菠萝味的冰淇淋'</span><span>)</span><span>,</span> 
<span>(</span><span>10003</span><span>,</span> <span>'草莓味的冰淇淋'</span><span>)</span> <span>ON</span> <span>DUPLICATE</span> <span>KEY</span> <span>UPDATE</span> second_column <span>=</span> <span>VALUES</span><span>(</span>second_column<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>其中的 <code>VALUES(second_column)</code> 对应上了两条待插入数据的 <code>second_column</code>。实现的效果就是批量插入两条数据，如果遇到重复记录时把该重复记录的 <code>second_column</code> 列更新成待插入记录中 <code>second_column</code> 列的值。</p>
<h2 id="删除数据"> 删除数据</h2>
<p>如果某些记录不想要了，可以使用下面的语句进行删除：</p>
<div><pre><code><span>DELETE</span> <span>FROM</span> 表名 <span>[</span><span>WHERE</span> 表达式<span>]</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>删除语句的 <code>WHERE</code> 子句是可选的，如果不加 <code>WHERE</code> 子句的话，意味着删除表中所有数据（非常危险！慎重使用！），如下：</p>
<div><pre><code><span>DELETE</span> <span>FROM</span> 表名<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>另外，也可以使用 <code>LIMIT</code> 子句来限制想要删除掉的记录数量，使用 <code>ORDER BY</code> 子句来指定符合条件的记录的删除顺序，如下：</p>
<div><pre><code><span>DELETE</span> <span>FROM</span> first_table <span>ORDER</span> <span>BY</span> first_column <span>DESC</span> <span>LIMIT</span> <span>1</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>上述语句就是想删除掉 <code>first_table</code> 表中 <code>first_column</code> 列值最大的那条记录</p>
<h2 id="更新数据"> 更新数据</h2>
<p>修改记录的语法如下：</p>
<div><pre><code><span>UPDATE</span> 表名 <span>SET</span> 列<span>1</span><span>=</span>值<span>1</span><span>,</span> 列<span>2</span><span>=</span>值<span>2</span><span>,</span> <span>.</span><span>.</span><span>.</span><span>,</span>  列n<span>=</span>值n <span>[</span><span>WHERE</span> 布尔表达式<span>]</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>把想更新的列的名称和该列更新后的值写到 <code>SET</code> 单词后边，如果想更新多个列的话，它们之间用逗号 <code>,</code> 分隔开</li>
<li>如果不指定 <code>WHERE</code> 子句，那么表中所有的记录都会被更新，否则的话只有符合 <code>WHERE</code> 子句中的条件的记录才可以被更新</li>
</ul>
<p>注意：虽然更新语句的 <code>WHERE</code> 子句是可选的，但是如果不加 <code>WHERE</code> 子句的话将更新表中所有的记录，这是非常危险的！请慎重使用</p>
<p>另外，也可以使用 <code>LIMIT</code> 子句来限制想要更新的记录数量，使用 <code>ORDER BY</code> 子句来指定符合条件的记录的更新顺序，如下：</p>
<div><pre><code><span>UPDATE</span> first_table <span>SET</span> second_column<span>=</span><span>'榴莲味的冰淇淋'</span> <span>ORDER</span> <span>BY</span> first_column <span>DESC</span> <span>LIMIT</span> <span>1</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>上述语句就是想更新 <code>first_column</code> 列值最大的那条记录</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">MySQL 数据类型</title>
    <id>https://www.snowji.cn/databases/mysql/data-types/</id>
    <link href="https://www.snowji.cn/databases/mysql/data-types/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="mysql-数据类型"> MySQL 数据类型</h1>
<p>MySQL 中的数据类型在使用时可以划分为：数值类型、时间类型、字符串类型、枚举与集合类型</p>
<h2 id="数值类型"> 数值类型</h2>
<p>有整数和浮点数两种，再根据字节来区分：字节一般是 8 位的二进制，如果需要带符号，就会占用第一位来表示符号，用 <code>0</code> 表示整数，<code>1</code> 表示负数</p>
<p>很显然，使用的字节数越多，意味着能表示的数值范围就越大，但是也就越耗费存储空间</p>
<h3 id="整数类型"> 整数类型</h3>
<p>整数有 5 种：</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">占用存储空间</th>
<th style="text-align:left">无符号数取值范围</th>
<th style="text-align:left">有符号数取值范围</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>TINYINT</code></td>
<td style="text-align:left">1 字节</td>
<td style="text-align:left">0 ~ 2⁸-1</td>
<td style="text-align:left">-2⁷ ~ 2⁷-1</td>
<td style="text-align:left">非常小的整数</td>
</tr>
<tr>
<td style="text-align:left"><code>SMALLINT</code></td>
<td style="text-align:left">2 字节</td>
<td style="text-align:left">0 ~ 2¹⁶-1</td>
<td style="text-align:left">-2¹⁵ ~ 2¹⁵-1</td>
<td style="text-align:left">小的整数</td>
</tr>
<tr>
<td style="text-align:left"><code>MEDIUMINT</code></td>
<td style="text-align:left">3 字节</td>
<td style="text-align:left">0 ~ 2²⁴-1</td>
<td style="text-align:left">-2²³ ~ 2²³-1</td>
<td style="text-align:left">中等大小的整数</td>
</tr>
<tr>
<td style="text-align:left"><code>INT</code> 或 <code>INTEGER</code></td>
<td style="text-align:left">4 字节</td>
<td style="text-align:left">0 ~ 2³²-1</td>
<td style="text-align:left">-2³¹ ~ 2³¹-1</td>
<td style="text-align:left">标准的整数</td>
</tr>
<tr>
<td style="text-align:left"><code>BIGINT</code></td>
<td style="text-align:left">8 字节</td>
<td style="text-align:left">0 ~ 2⁶⁴-1</td>
<td style="text-align:left">-2⁶³ ~ 2⁶³-1</td>
<td style="text-align:left">大整数</td>
</tr>
</tbody>
</table>
<p>在 MySQL 中定义的 BOOL 或 BOOLEAN 类型，最终会转换成 TINYINT(1) 类型，用 <code>1</code> 代表 <code>TRUE</code>，<code>0</code> 代表 <code>FALSE</code></p>
<h3 id="浮点数类型"> 浮点数类型</h3>
<p>浮点数有 2 种：</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">占用存储空间</th>
<th style="text-align:left">无符号数取值范围</th>
<th style="text-align:left">有符号数取值范围</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>FLOAT</code></td>
<td style="text-align:left">4 字节</td>
<td style="text-align:left">0 <hr> (1.175494351E-38,<br> 3.402823466E+38)</td>
<td style="text-align:left">(-3.402823466E+38,<br> -1.175494351E-38) <hr> 0 <hr> (1.175494351E-38,<br> 3.402823466E+38)</td>
<td style="text-align:left">单精度浮点数</td>
</tr>
<tr>
<td style="text-align:left"><code>DOUBLE</code></td>
<td style="text-align:left">8 字节</td>
<td style="text-align:left">0 <hr> (2.2250738585072014E-308,<br> 1.7976931348623157E+308)</td>
<td style="text-align:left">(-1.7976931348623157E+308,<br> -2.2250738585072014E-308) <hr> 0 <hr> (2.2250738585072014E-308,<br> 1.7976931348623157E+308)</td>
<td style="text-align:left">双精度浮点数</td>
</tr>
</tbody>
</table>
<h4 id="浮点数的不精确性"> 浮点数的不精确性</h4>
<p>在计算机中十进制最终是被转成二进制来存储的，比如十进制小数 <code>9.875</code> 转换成二进制小数的话就是：<code>1001.111</code></p>
<p>但虽然有的十进制小数，比如 <code>1.875</code> 可以被很容易的转换成二进制数 <code>1.111</code>，但是更多的小数是无法直接转换成二进制的，比如说 <code>0.3</code>，它转换成的二进制小数就是一个无限小数，但是我们现在只能用 4 个字节或者 8 个字节来表示这个小数，所以只能进行一些舍入来近似的表示，所以我们说计算机的浮点数表示有时是不精确的。</p>
<h4 id="设置最大位数和小数位数"> 设置最大位数和小数位数</h4>
<p>在定义浮点数类型时，还可以在 <code>FLOAT</code> 或者 <code>DOUBLE</code> 后边跟上两个参数，就像这样：</p>
<div><pre><code>FLOAT<span>(</span>M, D<span>)</span>
DOUBLE<span>(</span>M, D<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>对于我们用户而言，使用的都是十进制小数。如果我们事先知道表中的某个列要存储的小数在一定范围内，我们可以使用 <code>FLOAT(M, D)</code> 或者 <code>DOUBLE(M, D)</code> 来限制可以存储到本列中的小数范围。其中：</p>
<ul>
<li><code>M</code> 表示该小数最多需要的十进制有效数字个数。
<ul>
<li>注意是<strong>有效数字</strong>个数，对于小数 <code>-2.3</code> 来说有效数字个数就是 2，对于小数 <code>0.9</code> 来说有效数字个数就是 1。</li>
</ul>
</li>
<li><code>D</code> 表示该小数的小数点后的十进制数字个数。
<ul>
<li>小数点后有几个十进制数字，<code>D</code> 的值就是什么。</li>
</ul>
</li>
</ul>
<p>例如下面这样设置了 <code>M</code> 和 <code>D</code> 的单精度浮点数的取值范围：</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>FLOAT(4, 1)</code></td>
<td style="text-align:left">-999.9 ~ 999.9</td>
</tr>
<tr>
<td style="text-align:left"><code>FLOAT(5, 1)</code></td>
<td style="text-align:left">-9999.9 ~ 9999.9</td>
</tr>
<tr>
<td style="text-align:left"><code>FLOAT(6, 1)</code></td>
<td style="text-align:left">-99999.9 ~ 99999.9</td>
</tr>
<tr>
<td style="text-align:left"><code>FLOAT(4, 0)</code></td>
<td style="text-align:left">-9999 ~ 9999</td>
</tr>
<tr>
<td style="text-align:left"><code>FLOAT(4, 1)</code></td>
<td style="text-align:left">-999.9 ~ 999.9</td>
</tr>
<tr>
<td style="text-align:left"><code>FLOAT(4, 2)</code></td>
<td style="text-align:left">-99.99 ~ 99.99</td>
</tr>
</tbody>
</table>
<p>当然，<code>M</code> 和 <code>D</code> 的取值也不是无限大的：</p>
<ul>
<li>M 的取值范围是 <code>1 ~ 255</code></li>
<li>D 的取值范围是 <code>0 ~ 30</code></li>
<li>MySQL 要求 <code>D &lt;= M</code>。</li>
</ul>
<p>M 和 D 都是可选的，如果我们省略了它们，那它们的值按照机器支持的最大值来存储</p>
<h3 id="定点数类型"> 定点数类型</h3>
<p>因为用浮点数表示小数可能会有不精确的情况，在一些情况下我们必须保证小数是精确的，所以有了定点数类型，它也是存储小数的一种方式：</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">占用存储空间</th>
<th style="text-align:left">取值范围</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>DECIMAL(M, D)</code></td>
<td style="text-align:left">取决于 M 和 D</td>
<td style="text-align:left">取决于 M 和 D</td>
<td style="text-align:left">一些需要保存定长小数的项，比如存储的值要求保存数位小数</td>
</tr>
</tbody>
</table>
<p>其中 <code>M</code> 和 <code>D</code> 的含义与浮点数中的含义一样，但取值范围略有不一样：</p>
<ul>
<li><code>M</code> 是表示有效数字数的精度，范围为 <code>1 ~ 65</code></li>
<li><code>D</code> 是表示小数点后的位数，范围为 <code>0 ~ 30</code></li>
<li>MySQL 要求 <code>D &lt;= M</code></li>
</ul>
<h4 id="为什么能保证小数精确"> 为什么能保证小数精确</h4>
<p>定点数类型的 <code>M</code> 和 <code>D</code> 的含义与浮点数中的含义一样，但是占用存储空间不一样：</p>
<ul>
<li>单精度浮点数类型 <code>FLOAT(M, D)</code> 占用的字节数一直都是 4 字节</li>
<li>双精度浮点数类型 <code>DOUBLE(M, D)</code> 占用的字节数一直都是 8 字节</li>
<li>定点数类型 <code>DECIMAL(M, D)</code> 占用的字节数随着 M 和 D 的值的变动而变动</li>
</ul>
<p>这是因为定点数作为一种精确的小数，为了达到精确的目的就不能把它转换成二进制小数之后再存储（因为有很多十进制小数转为二进制小数后需要进行舍入操作，导致二进制小数表示的数值是不精确的）</p>
<p>那么它是怎么存储的呢？大致的思路就是把小数点左右的两个十进制整数给存储起来，比如对于十进制小数 <code>2.38</code> 来说，可以把这个小数的小数点左右的两个整数，也就是 <code>2</code> 和 <code>38</code> 分别保存起来。当然事情并没有这么简单，具体的实现原理这里就不展开研究了</p>
<h3 id="无符号数值类型的表示"> 无符号数值类型的表示</h3>
<p>对于数值类型，有些情况下我们只需要用到无符号数（就是非负数），定义时就是在原数值类型后加一个单词 <code>UNSIGNED</code>：</p>
<div><pre><code>数值类型 UNSIGNED
</code></pre>
<div><span>1</span><br></div></div><p>例如：</p>
<div><pre><code>INT UNSIGNED      <span># 表示无符号整数</span>
FLOAT UNSIGNED    <span># 表示无符号浮点数</span>
DECIMAL UNSIGNED  <span># 表示无符号定点数</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><p>小贴士</p>
<p>在使用的存储空间大小相同的情况下，无符号整数可以表示的正整数范围比有符号整数能表示的正整数范围大一倍。不过受浮点数和定点数具体的存储格式影响，无符号浮点数和定点数并不能提升正数的表示范围</p>
</div>
<h2 id="日期和时间类型"> 日期和时间类型</h2>
<p>MySQL 提供了多种关于时间和日期的类型，各种类型能表示的范围如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">占用存储空间</th>
<th style="text-align:left">范围</th>
<th style="text-align:left">格式</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>YEAR</code></td>
<td style="text-align:left">1 字节</td>
<td style="text-align:left">1901 ~ 2155</td>
<td style="text-align:left">YYYY</td>
<td style="text-align:left">年份值</td>
</tr>
<tr>
<td style="text-align:left"><code>DATE</code></td>
<td style="text-align:left">3 字节</td>
<td style="text-align:left">1000-01-01 <br>~<br> 9999-12-31</td>
<td style="text-align:left">YYYY-MM-DD</td>
<td style="text-align:left">日期值</td>
</tr>
<tr>
<td style="text-align:left"><code>TIME</code></td>
<td style="text-align:left">3 字节</td>
<td style="text-align:left">-838:59:59 <br>~<br> 838:59:59</td>
<td style="text-align:left">HH:MM:SS</td>
<td style="text-align:left">时间值</td>
</tr>
<tr>
<td style="text-align:left"><code>DATETIME</code></td>
<td style="text-align:left">8 字节</td>
<td style="text-align:left">1000-01-01 00:00:00 <br>~<br> 9999-12-31 23:59:59</td>
<td style="text-align:left">YYYY-MM-DD HH:MM:SS</td>
<td style="text-align:left">日期加时间值</td>
</tr>
<tr>
<td style="text-align:left"><code>TIMESTAMP</code></td>
<td style="text-align:left">4 字节</td>
<td style="text-align:left">1970-01-01 00:00:00 <br>~<br> 2038-1-19 11:14:07</td>
<td style="text-align:left">YYYY-MM-DD HH:MM:SS</td>
<td style="text-align:left">时间戳</td>
</tr>
</tbody>
</table>
<p>若定义一个字段为 <code>TIMESTAMP</code>，这个字段里的时间数据会随其他字段修改的时候自动刷新，所以这个数据类型的字段可以存放这条记录最后被修改的时间</p>
<h2 id="字符串类型"> 字符串类型</h2>
<h3 id="字符编码"> 字符编码</h3>
<p>在具体分析 MySQL 中各个字符串类型之前，一定要先搞明白字符和字节的区别。字符是面向人的概念，字节是面向计算机的概念。如果你想在计算机中表示字符，那就需要将该字符与一个特定的字节序列对应起来，这个映射过程称之为编码。不幸的是，这种映射关系并不是唯一的，不同的人制作了不同的编码方案，根据表示一个字符使用的字节数量是不是固定的，编码方案可以分为下边两种：</p>
<ul>
<li><strong>固定长度的编码方案</strong><br>
表示不同的字符所需要的字节数量是相同的。比如 <code>ASCII</code> 编码方案采用 1 个字节来编码一个字符，<code>ucs2</code> 采用 2 个字节来编码一个字符</li>
<li><strong>变长的编码方案</strong><br>
表示不同的字符所需要的字节数量是不同的。比比如 <code>utf8</code> 编码方案采用 1~3 个字节来编码一个字符，<code>gb2312</code> 采用 1~2 个字节来编码一个字符</li>
</ul>
<p>对于不同的字符编码方案来说，同一个字符可能被编码成不同的字节序列。比如同样一个字符：<code>我</code>，在 <code>utf8</code> 和 <code>gb2312</code> 这两种编码方案下被映射成如下的字节序列：</p>
<div><pre><code><span># utf8 编码方案，将字符 '我' 编码成：</span>
<span>111001101000100010010001</span>
<span># 共占用 3 个字节，用十六进制表示就是：0xE68891</span>

<span># gb2312 编码方案，将字符 '我' 编码成：</span>
<span>1100111011010010</span>
<span># 共占用 2 个字节，用十六进制表示就是：0xCED2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>另外，设计 MySQL 的人最初对<strong>编码方案</strong>和<strong>字符集</strong>这两个概念并没做明确区分，也就是说我们之后所讲的 <code>utf8</code> 字符集指的就是 <code>utf8</code> 编码方案，<code>gb2312</code> 字符集指的也就是 <code>gb2312</code> 编码方案</p>
<div><p>小贴士</p>
<p>正宗的 utf8 字符集是使用 1~4 个字节来编码一个字符的，不过 MySQL 中对 utf8 字符集做了阉割，编码一个字符最多使用 3 个字节</p>
<p>如果我们之后有存储使用 4 个字节来编码的字符的情景，可以使用一种称之为 utf8mb4 的字符集，它才是正宗的 utf8 字符集（现在一般都是用这种）</p>
</div>
<h3 id="常用类型"> 常用类型</h3>
<p>以下是 MySQL 中提供的各种字符串类型：</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">最大长度</th>
<th style="text-align:left">占用存储空间</th>
<th style="text-align:left">特性</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>CHAR(M)</code></td>
<td style="text-align:left">M 个字符</td>
<td style="text-align:left">M×W 个字节</td>
<td style="text-align:left">固定长度</td>
<td style="text-align:left">固定长度的字符串</td>
</tr>
<tr>
<td style="text-align:left"><code>VARCHAR(M)</code></td>
<td style="text-align:left">M 个字符</td>
<td style="text-align:left">L+1 或 L+2 个字节</td>
<td style="text-align:left">固定长度</td>
<td style="text-align:left">可变长度的字符串</td>
</tr>
<tr>
<td style="text-align:left"><code>TINYTEXT</code></td>
<td style="text-align:left">2⁸-1 个字节</td>
<td style="text-align:left">L+1 个字节</td>
<td style="text-align:left">可变长度，大小写不敏感</td>
<td style="text-align:left">非常小型的字符串</td>
</tr>
<tr>
<td style="text-align:left"><code>TEXT</code></td>
<td style="text-align:left">2¹⁶-1 个字节</td>
<td style="text-align:left">L+2 个字节</td>
<td style="text-align:left">可变长度，大小写不敏感</td>
<td style="text-align:left">小型的字符串</td>
</tr>
<tr>
<td style="text-align:left"><code>MEDIUMTEXT</code></td>
<td style="text-align:left">2²⁴-1 个字节</td>
<td style="text-align:left">L+3 个字节</td>
<td style="text-align:left">可变长度，大小写不敏感</td>
<td style="text-align:left">中等大小的字符串</td>
</tr>
<tr>
<td style="text-align:left"><code>LONGTEXT</code></td>
<td style="text-align:left">2³²-1 个字节</td>
<td style="text-align:left">L+4 个字节</td>
<td style="text-align:left">可变长度，大小写不敏感</td>
<td style="text-align:left">大型的字符串</td>
</tr>
</tbody>
</table>
<p>（注：其中 <code>M</code> 代表该数据类型最多能存储的<strong>字符数量</strong>，<code>L</code> 代表实际存储的字符串在特定字符集下所占的<strong>字节数</strong>，<code>W</code> 代表在该特定字符集下，编码一个字符最多需要的字节数）</p>
<div><p>小贴士</p>
<p>在 MySQL 中，一个英文字母占 1 字节，一个中文汉字所占的字节数与编码格式有关：</p>
<ul>
<li>如果是 gbk 编码，则一个中文汉字占 2 个字节</li>
<li>如果是 utf8 编码，则一个中文汉字占 3 个字节</li>
</ul>
</div>
<h4 id="char-m"> CHAR(M)</h4>
<p><code>CHAR(M)</code> 中的 <code>M</code> 代表该类型最多可以存储的<strong>字符数量</strong>，它的取值范围是 <code>0~255</code></p>
<ul>
<li>如果省略 M，它的默认值就是 <code>1</code></li>
<li><code>CHAR(0)</code> 是一种特别的类型，它只能存储空字符串 <code>''</code> 或者 <code>NULL</code> 值</li>
</ul>
<p>因为 <code>CHAR</code> 是固定长度的，所以如果实际存储的字符串在特定字符集编码下占用的字节数不足 M×W，那么剩余的那些存储空间用空格字符（<code>' '</code>）补齐</p>
<p>这也就是说：一旦确定了 CHAR(M) 类型的 M 的值，如果 M 的值很大，而实际存储的字符串占用字节数又很少，会造成存储空间的浪费</p>
<h4 id="varchar-m"> VARCHAR(M)</h4>
<p>如果表中某个列需要存储字符串类型的数据，而且这些字符串长短不一，使用 <code>CHAR(M)</code> 可能会浪费很多存储空间，<code>VARCHAR(M)</code> 会是一个更好的选择</p>
<p><code>VARCHAR(M)</code> 中的 <code>M</code> 也是代表该类型最多可以存储的字符数量，理论上的取值范围是 <code>1~65535</code>。但是 MySQL 中还有一个规定，表中某一行包含的所有列中存储的数据大小总共不得超过 65535 个字节（注意是字节），也就是说 <code>VARCHAR(M)</code> 类型实际能够容纳的字符数量是小于 65535 的</p>
<h4 id="各种-text-类型"> 各种 TEXT 类型</h4>
<p>如果 <code>VARCHAR(M)</code> 的长度开始不够用，那么可以考虑另外几种 TEXT 类型，它们也都是变长类型：</p>
<ul>
<li><code>TINYTEXT</code> 最多可以存储 2⁸-1 个字节</li>
<li><code>TEXT</code> 最多可以存储 2¹⁶-1 个字节</li>
<li><code>MEDIUMTEXT</code> 最多可以存储 2²⁴-1 个字节</li>
<li><code>LONGTEXT</code> 最多可以存储 2³²-1 个字节</li>
</ul>
<p>前面提到某一行包含的所有列中存储的数据大小总和不得超过 65535 个字节么，这个规定对这些 TEXT 类型是不起作用的，它们并不在这个规定的限制范围之内。一个表中如果有的属性需要存储特别长的文本的话，就可以考虑使用这几个类型了</p>
<h2 id="enum-类型和-set-类型"> ENUM 类型和 SET 类型</h2>
<p>ENUM 和 SET 类型都是一种特殊的字符串类型，在从字符串列表中单选或多选元素的时候会用得到它们</p>
<h3 id="枚举"> 枚举</h3>
<p>枚举（ENUM）是单选字符串数据类型，适合存储表单界面中的「单选值」，比如性别</p>
<p>设定 ENUM 的时候，需要给定「固定的几个选项」，存储的时候就只存储其中的一个值</p>
<p>设定 ENUM 的格式：</p>
<div><pre><code><span>enum</span><span>(</span><span>"选项1"</span><span>,</span><span>"选项2"</span><span>,</span><span>"选项3"</span><span>,</span><span>.</span><span>.</span><span>.</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>实际上，ENUM 的选项都会对应一个数字，依次是 1，2，3，4，5...，最多有 65535 个选项。</p>
<p>使用的时候，可以使用选项的字符串格式，也可以使用对应的数字</p>
<h3 id="集合"> 集合</h3>
<p>集合（SET）是多选字符串数据类型，适合存储表单界面的「多选值」</p>
<p>设定 SET 的时候，同样需要给定「固定的几个选项」，存储的时候，可以存储其中的若干个值</p>
<p>设定 SET 的格式：</p>
<div><pre><code><span>set</span><span>(</span><span>"选项1"</span><span>,</span><span>"选项2"</span><span>,</span><span>"选项3"</span><span>,</span><span>.</span><span>.</span><span>.</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>同样的，SET 的每个选项值也对应一个数字，依次是 1，2，4，8，16...，最多有 64 个选项</p>
<p>使用的时候，可以使用 SET 选项的字符串本身（多个选项用逗号分隔），也可以使用多个选项的数字之和（比如：1+2+4=7）</p>
<h2 id="二进制类型"> 二进制类型</h2>
<h3 id="bit-类型"> BIT 类型</h3>
<p>有时候我们有存储单个或者多个比特位的需求，此时就可以用到这种类型：</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">字节数</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>BIT(M)</code></td>
<td style="text-align:left">近似为(M+7)/8</td>
<td style="text-align:left">存储 M 个比特位的值</td>
</tr>
</tbody>
</table>
<p>其中 <code>M</code> 的取值范围为 <code>1~64</code>，而且 M 可以省略，它的默认值为 1，也就是说 <code>BIT(1)</code> 和 <code>BIT</code> 的意思是一样的</p>
<p>MySQL 是以字节为单位存储数据的，一个字节拥有 8 个比特位。如果我们想存储的比特位个数不足整数个字节，那么 MySQL 会偷偷的填充满，比如：</p>
<ul>
<li><code>BIT(1)</code> 类型仅仅需要存储 1 个比特位的数据，但是 MySQL 会为其申请 <code>(1+7)/8 = 1</code> 个字节</li>
<li><code>BIT(5)</code> 类型仅仅需要存储 5 个比特位的数据，但是 MySQL 会为其申请 <code>(5+7)/8 = 1</code> 个字节</li>
<li><code>BIT(9)</code> 类型仅仅需要存储 9 个比特位的数据，但是 MySQL 会为其申请 <code>(9+7)/8 = 2</code> 个字节</li>
</ul>
<h3 id="binary-m-与-varbinary-m"> BINARY(M) 与 VARBINARY(M)</h3>
<p><code>BINARY(M)</code> 和 <code>VARBINARY(M)</code> 对应于前面提到的 <code>CHAR(M)</code> 和 <code>VARCHAR(M)</code>，都是前者是固定长度的类型，后者是可变长度的类型，只不过：</p>
<ul>
<li><code>BINARY(M)</code> 和<code>VARBINARY(M)</code> 是用来存放字节的，其中的 <code>M</code> 代表该类型最多能存放的<strong>字节数量</strong></li>
<li><code>CHAR(M)</code> 和 <code>VARCHAR(M)</code> 是用来存储字符的，其中的 <code>M</code> 代表该类型最多能存放的<strong>字符数量</strong></li>
</ul>
<h3 id="其他的二进制类型"> 其他的二进制类型</h3>
<p><code>TINYBLOB</code>、<code>BLOB</code>、<code>MEDIUMBLOB</code>、<code>LONGBLOB</code> 是针对数据量很大的二进制数据提出的，比如图片、音频、压缩文件啥的。它们很像 <code>TINYTEXT</code>、<code>TEXT</code>、<code>MEDIUMTEXT</code>、<code>LONGTEXT</code>，不过各种 <code>BLOB</code> 类型是用来存储<strong>字节</strong>的，而各种 <code>TEXT</code> 类型是用来存储<strong>字符</strong>的而已</p>
<div><p>小贴士</p>
<p>对于比较大的二进制数据，比如图片、音频、压缩文件等，通常情况下都不直接存储到数据库管理系统中，而是将它们保存到文件系统中，然后在数据库中之存放一个文件路径即可</p>
</div>
<h2 id="数据类型的属性"> 数据类型的属性</h2>
<table>
<thead>
<tr>
<th style="text-align:left">MySQL 关键字</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>NULL</code></td>
<td style="text-align:left">数据列可包含 <code>NULL</code> 值</td>
</tr>
<tr>
<td style="text-align:left"><code>NOT NULL</code></td>
<td style="text-align:left">数据列不允许包含 <code>NULL</code> 值</td>
</tr>
<tr>
<td style="text-align:left"><code>DEFAULT</code></td>
<td style="text-align:left">默认值</td>
</tr>
<tr>
<td style="text-align:left"><code>PRIMARY KEY</code></td>
<td style="text-align:left">主键</td>
</tr>
<tr>
<td style="text-align:left"><code>AUTO_INCREMENT</code></td>
<td style="text-align:left">自动递增，适用于整数类型</td>
</tr>
<tr>
<td style="text-align:left"><code>UNSIGNED</code></td>
<td style="text-align:left">无符号</td>
</tr>
<tr>
<td style="text-align:left"><code>CHARACTER SET name</code></td>
<td style="text-align:left">指定一个字符集</td>
</tr>
</tbody>
</table>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">库和表的基本操作</title>
    <id>https://www.snowji.cn/databases/mysql/database-and-table-operations/</id>
    <link href="https://www.snowji.cn/databases/mysql/database-and-table-operations/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="库和表的基本操作"> 库和表的基本操作</h1>
<blockquote>
<p>以下用到的 SQL 语句中，大小写其实不作强制规定。但为了方便区分，关键词会用大写字母，自定义的表名、字段名、函数名等等会用小写字母</p>
</blockquote>
<h2 id="数据库操作"> 数据库操作</h2>
<h3 id="展示数据库"> 展示数据库</h3>
<div><pre><code>mysql<span>></span> <span>SHOW</span> <span>DATABASES</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="创建数据库"> 创建数据库</h3>
<p>语法：</p>
<div><pre><code><span>CREATE</span> <span>DATABASE</span> 数据库名<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>例如：</p>
<div><pre><code>mysql<span>></span> <span>CREATE</span> <span>DATABASE</span> school<span>;</span>
Query OK<span>,</span> <span>1</span> <span>row</span> affected <span>(</span><span>0.02</span> sec<span>)</span>

mysql<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果创建一个已经存在的数据库会报错 <code>ERROR</code>。这个时候可以使用 <code>IF NOT EXISTS</code> 语句，这样不影响语句的执行，只是结果中有 1 个 <code>warning</code>：</p>
<div><pre><code>mysql<span>></span> <span>CREATE</span> <span>DATABASE</span> <span>IF</span> <span>NOT</span> <span>EXISTS</span> school<span>;</span>
Query OK<span>,</span> <span>1</span> <span>row</span> affected<span>,</span> <span>1</span> warning <span>(</span><span>0.00</span> sec<span>)</span>

mysql<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="切换数据库"> 切换数据库</h3>
<p>语法：</p>
<div><pre><code><span>USE</span> 数据库名称<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>例如：</p>
<div><pre><code>mysql<span>></span> <span>USE</span> school<span>;</span>
<span>Database</span> changed
mysql<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="删除数据库"> 删除数据库</h3>
<p>如果觉得某个数据库没用了，可以把它删掉</p>
<p>语法：</p>
<div><pre><code><span>DROP</span> <span>DATABASE</span> 数据库名<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>在真实的工作环境里，在删除数据库之前一定要反复找上级核实，就算要删最好不要自己删，「删库」这个责任很大</p>
<p>不过这里演示的是学习环境，就无所谓了。删除刚才创建的 <code>school</code> 库：</p>
<div><pre><code>mysql<span>></span> <span>DROP</span> <span>DATABASE</span> school<span>;</span>
Query OK<span>,</span> <span>0</span> <span>rows</span> affected <span>(</span><span>0.02</span> sec<span>)</span>

mysql<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果某个数据库并不存在，我们仍旧调用 <code>DROP DATABASE</code> 语句去删除它，不过会报错的。如果想避免这种报错，可以使用 <code>IF EXISTS</code> 语句来删除数据库：</p>
<div><pre><code>mysql<span>></span> <span>DROP</span> <span>DATABASE</span> <span>IF</span> <span>EXISTS</span> school<span>;</span>
Query OK<span>,</span> <span>0</span> <span>rows</span> affected<span>,</span> <span>1</span> warning <span>(</span><span>0.00</span> sec<span>)</span>

mysql<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="表的操作"> 表的操作</h2>
<blockquote>
<p>以下用到的 SQL 语句，需要先进入到一个新的数据库，就拿前面举例的 <code>school</code> 库好了</p>
</blockquote>
<h3 id="展示当前数据库中的表"> 展示当前数据库中的表</h3>
<p>这条语句用于展示当前数据库中有哪些表：</p>
<div><pre><code>mysql<span>></span> <span>SHOW</span> <span>TABLES</span><span>;</span>
Empty <span>set</span> <span>(</span><span>0.00</span> sec<span>)</span>

mysql<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>因为是新创建的数据库，所以里面是空的，得到的结果就是 <code>Empty set</code></p>
<h3 id="创建表"> 创建表</h3>
<h4 id="基本语法"> 基本语法</h4>
<p>MySQL 中创建表的基本语法就是这样的：</p>
<div><pre><code><span>CREATE</span> <span>TABLE</span> 表名 <span>(</span>
    列名<span>1</span>    数据类型    <span>[</span>列的属性<span>]</span><span>,</span>
    列名<span>2</span>    数据类型    <span>[</span>列的属性<span>]</span><span>,</span>
    <span>.</span><span>.</span><span>.</span>
    列名n    数据类型    <span>[</span>列的属性<span>]</span>
<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>也就是说创建一个表时至少需要完成下列事情：</p>
<ul>
<li>给表起个名</li>
<li>然后在小括号 <code>()</code> 中定义上这个表的各个列的信息，包括列的名称、列的数据类型、列的属性（列的属性非必须，用中括号 <code>[]</code> 引起来）</li>
<li>列名、数据类型、列的属性之间用空白字符分开就好，然后各个列的信息之间用逗号 <code>,</code> 分隔开</li>
</ul>
<p>最后，将建表语句放到客户端执行，输出 <code>Query OK, 0 rows affected (0.07 sec)</code> 意味着创建成功了，这里的 0.07 表示耗时，实际耗时不一定就是这个数字</p>
<div><p>小贴士</p>
<p>这个创建表的语句可以放在单行中完成，我把它分成多行并且加上缩进仅仅是为了美观而已</p>
</div>
<h4 id="为建表语句添加注释"> 为建表语句添加注释</h4>
<p>可以在创建表时将该表的用处以注释的形式添加到语句中，只要在建表语句最后加上 <code>COMMENT</code> 语句就好，如下：</p>
<div><pre><code><span>CREATE</span> <span>TABLE</span> 表名 <span>(</span>
    各个列的信息 <span>.</span><span>.</span><span>.</span>
<span>)</span> <span>COMMENT</span> <span>'表的注释信息'</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>为了我们和他人的方便，最好写个注释。不过注释没必要太长，言简意赅即可，毕竟是给人看的，让人看明白是什么意思就好了</p>
<h4 id="创建两个实际的表"> 创建两个实际的表</h4>
<p>先创建一个学生信息表（<code>student_info</code>）：</p>
<div><pre><code><span>CREATE</span> <span>TABLE</span> student_info <span>(</span>
    number <span>INT</span><span>,</span>
    name <span>VARCHAR</span><span>(</span><span>5</span><span>)</span><span>,</span>
    sex <span>ENUM</span><span>(</span><span>'男'</span><span>,</span> <span>'女'</span><span>)</span><span>,</span>
    id_number <span>CHAR</span><span>(</span><span>18</span><span>)</span><span>,</span>
    department <span>VARCHAR</span><span>(</span><span>30</span><span>)</span><span>,</span>
    major <span>VARCHAR</span><span>(</span><span>30</span><span>)</span><span>,</span>
    enrollment_time <span>DATE</span>
<span>)</span> <span>COMMENT</span> <span>'学生信息表'</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>这张表有如下字段：</p>
<ul>
<li>学号（<code>number</code>）：整数类型</li>
<li>姓名（<code>name</code>）：变长字符串类型，最多 5 个字符</li>
<li>性别（<code>sex</code>）：枚举类型，只能填 <code>男</code> 或 <code>女</code></li>
<li>身份证号（<code>id_number</code>）：固定长度字符串类型，因为身份证是固定的 18 位</li>
<li>学院（<code>department</code>）：变长字符串类型，最多 30 个字符</li>
<li>专业（<code>major</code>）：变长字符串类型，最多 30 个字符</li>
<li>入学时间（<code>enrollment_time</code>）：日期类型</li>
</ul>
<p>再创建一个学生成绩表（<code>student_score</code>）：</p>
<div><pre><code><span>CREATE</span> <span>TABLE</span> student_score <span>(</span>
    number <span>INT</span><span>,</span>
    subject <span>VARCHAR</span><span>(</span><span>30</span><span>)</span><span>,</span>
    score <span>TINYINT</span>
<span>)</span> <span>COMMENT</span> <span>'学生成绩表'</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这张表有如下字段：</p>
<ul>
<li>学号（<code>number</code>）：整数类型</li>
<li>科目（<code>subject</code>）：变长字符串类型，最多 30 个字符</li>
<li>成绩（<code>score</code>）：小整数类型，成绩够用了</li>
</ul>
<p>和重复创建数据库一样，如果创建一个已经存在的表的话是会报错的，这个时候也可以使用 <code>IF NOT EXISTS</code> 来避免这种错误发生：</p>
<div><pre><code><span>CREATE</span> <span>TABLE</span> <span>IF</span> <span>NOT</span> <span>EXISTS</span> 表名<span>(</span>
    各个列的信息 <span>.</span><span>.</span><span>.</span>
<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="删除表"> 删除表</h3>
<p>删除表的语法：</p>
<div><pre><code><span>DROP</span> <span>TABLE</span> 表<span>1</span><span>,</span> 表<span>2</span><span>,</span> <span>.</span><span>.</span><span>.</span><span>,</span> 表n<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>在真实工作环境中删除表一定要慎重、谨慎</p>
<p>同样，如果尝试删除某个不存在的表的话会报错，可以使用 <code>IF EXISTS</code> 来避免报错：</p>
<div><pre><code><span>DROP</span> <span>TABLE</span> <span>IF</span> <span>EXISTS</span> 表名<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="查看表结构"> 查看表结构</h3>
<p>下边这些语句都可以用来查看表的结构，它们的效果是一样的：</p>
<div><pre><code><span>DESCRIBE</span> 表名<span>;</span>
<span>DESC</span> 表名<span>;</span>
<span>EXPLAIN</span> 表名<span>;</span>
<span>SHOW</span> <span>COLUMNS</span> <span>FROM</span> 表名<span>;</span>
<span>SHOW</span> <span>FIELDS</span> <span>FROM</span> 表名<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>还可以使用下边这个语句来查看表结构，而它显示其实跟平时创建表的语句是一样的，所以可以用来反查建表语句：</p>
<div><pre><code><span>SHOW</span> <span>CREATE</span> <span>TABLE</span> 表名\G
</code></pre>
<div><span>1</span><br></div></div><p>用 <code>\G</code> 来代替原来用于标记语句结束的分号 <code>;</code>，是为了让输出的结果显示效果更好一点</p>
<h3 id="显式指定表的数据库"> 显式指定表的数据库</h3>
<p>有时候我们并没有使用 <code>USE</code> 语句来选择当前数据库，或者在一条语句中遇到的表分散在不同的数据库中，如果我们想在语句中使用这些表，那么就必须显式的指定这些表所属的数据库了</p>
<p>比如不管当前数据库是不是 <code>school</code>，都可以调用这个语句来展示数据库 <code>school</code> 里边的表：</p>
<div><pre><code>mysql<span>></span> <span>SHOW</span> <span>TABLES</span> <span>FROM</span> school<span>;</span>
<span>+</span><span>------------------+</span>
<span>|</span> Tables_in_school <span>|</span>
<span>+</span><span>------------------+</span>
<span>|</span> student_info     <span>|</span>
<span>|</span> student_score    <span>|</span>
<span>+</span><span>------------------+</span>
<span>2</span> <span>rows</span> <span>in</span> <span>set</span> <span>(</span><span>0.01</span> sec<span>)</span>

mysql<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>其他地方如果使用到表名的话，需要显式指定这个表所属的数据库，指明方式是 <code>数据库名.表名</code>。例如：</p>
<div><pre><code>mysql<span>></span> <span>SHOW</span> <span>CREATE</span> <span>TABLE</span> school<span>.</span>student_score\G
<span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span> <span>1.</span> <span>row</span> <span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span>
       <span>Table</span>: student_score
<span>Create</span> <span>Table</span>: <span>CREATE</span> <span>TABLE</span> <span><span>`</span>student_score<span>`</span></span> <span>(</span>
  <span><span>`</span>number<span>`</span></span> <span>int</span> <span>DEFAULT</span> <span>NULL</span><span>,</span>
  <span><span>`</span>subject<span>`</span></span> <span>varchar</span><span>(</span><span>30</span><span>)</span> <span>COLLATE</span> utf8mb4_general_ci <span>DEFAULT</span> <span>NULL</span><span>,</span>
  <span><span>`</span>score<span>`</span></span> <span>tinyint</span> <span>DEFAULT</span> <span>NULL</span>
<span>)</span> <span>ENGINE</span><span>=</span><span>InnoDB</span> <span>DEFAULT</span> <span>CHARSET</span><span>=</span>utf8mb4 <span>COLLATE</span><span>=</span>utf8mb4_general_ci <span>COMMENT</span><span>=</span><span>'学生成绩表'</span>
<span>1</span> <span>row</span> <span>in</span> <span>set</span> <span>(</span><span>0.00</span> sec<span>)</span>

mysql<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="修改表"> 修改表</h3>
<h4 id="修改表名"> 修改表名</h4>
<ul>
<li>方式一：</li>
</ul>
<div><pre><code><span>ALTER</span> <span>TABLE</span> 旧表名 <span>RENAME</span> <span>TO</span> 新表名<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>方式二（可以用一条语句修改多个表的名称）：</li>
</ul>
<div><pre><code><span>RENAME</span> <span>TABLE</span> 旧表名<span>1</span> <span>TO</span> 新表名<span>1</span><span>,</span> 旧表名<span>2</span> <span>TO</span> 新表名<span>2</span><span>,</span> <span>.</span><span>.</span><span>.</span> 旧表名n <span>TO</span> 新表名n<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>如果在修改表名的时候指定了数据库名，还可以将该表转移到对应的数据库下，例如：</p>
<div><pre><code><span>ALTER</span> <span>TABLE</span> student_info <span>RENAME</span> <span>TO</span> company<span>.</span>student_info<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="增加列"> 增加列</h4>
<p>可以使用下边的语句来增加表中的列：</p>
<div><pre><code><span>ALTER</span> <span>TABLE</span> 表名 <span>ADD</span> <span>COLUMN</span> 列名 数据类型 <span>[</span>列的属性<span>]</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="增加列到特定位置"> 增加列到特定位置</h4>
<p>默认的情况下列都是加到现有列的最后一列后面，我们也可以在添加列的时候指定它的位置，常用的方式如下：</p>
<ul>
<li>添加到第一列：</li>
</ul>
<div><pre><code><span>ALTER</span> <span>TABLE</span> 表名 <span>ADD</span> <span>COLUMN</span> 列名 列的类型 <span>[</span>列的属性<span>]</span> <span>FIRST</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>添加到指定列的后边：</li>
</ul>
<div><pre><code><span>ALTER</span> <span>TABLE</span> 表名 <span>ADD</span> <span>COLUMN</span> 列名 列的类型 <span>[</span>列的属性<span>]</span> <span>AFTER</span> 指定列名<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="删除列"> 删除列</h4>
<p>可以使用下边的语句来删除表中的列：</p>
<div><pre><code><span>ALTER</span> <span>TABLE</span> 表名 <span>DROP</span> <span>COLUMN</span> 列名<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="修改列信息"> 修改列信息</h4>
<p>修改列的信息有下边这两种方式：</p>
<ul>
<li>方式一：</li>
</ul>
<div><pre><code><span>ALTER</span> <span>TABLE</span> 表名 <span>MODIFY</span> 列名 新数据类型 <span>[</span>新属性<span>]</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>不过在修改列信息的时候需要注意：修改后的数据类型和属性一定要兼容表中现有的数据，否则就会报错</p>
<ul>
<li>方式二：</li>
</ul>
<div><pre><code><span>ALTER</span> <span>TABLE</span> 表名 CHANGE 旧列名 新列名 新数据类型 <span>[</span>新属性<span>]</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>这种修改方式需要我们填两个列名，也就是说在修改数据类型和属性的同时也可以修改列名。因此也可以用在不改变数据类型和属性，仅重命名列明的需求场景上</p>
<h4 id="修改列排列位置"> 修改列排列位置</h4>
<p>可以使用下面这几条语句修改列的顺序：</p>
<ul>
<li>将列设为表的第一列：</li>
</ul>
<div><pre><code><span>ALTER</span> <span>TABLE</span> 表名 <span>MODIFY</span> 列名 列的类型 列的属性 <span>FIRST</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>将列放到指定列的后边：</li>
</ul>
<div><pre><code><span>ALTER</span> <span>TABLE</span> 表名 <span>MODIFY</span> 列名 列的类型 列的属性 <span>AFTER</span> 指定列名<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="一条语句中包含多个修改操作"> 一条语句中包含多个修改操作</h4>
<p>如果对同一个表有多个修改操作的话，我们可以把它们放到一条语句中执行，就像这样：</p>
<div><pre><code><span>ALTER</span> <span>TABLE</span> 表名 操作<span>1</span><span>,</span> 操作<span>2</span><span>,</span> <span>.</span><span>.</span><span>.</span><span>,</span> 操作n<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>比如连续删除三个列的语句，可以合并为一条：</p>
<div><pre><code><span># 合并前</span>
<span>ALTER</span> <span>TABLE</span> test_table <span>DROP</span> <span>COLUMN</span> column_a<span>;</span>
<span>ALTER</span> <span>TABLE</span> test_table <span>DROP</span> <span>COLUMN</span> column_b<span>;</span>
<span>ALTER</span> <span>TABLE</span> test_table <span>DROP</span> <span>COLUMN</span> column_c<span>;</span>

<span># 合并后</span>
<span>ALTER</span> <span>TABLE</span> test_table <span>DROP</span> <span>COLUMN</span> column_a<span>,</span> <span>DROP</span> <span>COLUMN</span> column_b<span>,</span> <span>DROP</span> <span>COLUMN</span> column_c<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>这样敲的语句也少了，服务器也不用分多次执行从而效率也高了</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">表达式和函数</title>
    <id>https://www.snowji.cn/databases/mysql/expressions-and-functions/</id>
    <link href="https://www.snowji.cn/databases/mysql/expressions-and-functions/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="表达式和函数"> 表达式和函数</h1>
<h2 id="表达式"> 表达式</h2>
<p>表达式由操作数和操作符组成，比如 <code>1 + 1</code> 就是一个 <code>表达式</code>，其中数字称为 <code>操作数</code>，运算符称为 <code>操作符</code></p>
<h3 id="操作数"> 操作数</h3>
<p>MySQL 中操作数可以是以下这几种类型：</p>
<ul>
<li><strong>常数</strong><br>
常数很好理解，我们平时用到的数字、字符串、时间值等都可以被称为常数，它是一个确定的值</li>
<li><strong>列名</strong><br>
针对某个具体的表，它的列名可以被当作表达式的一部分</li>
<li><strong>函数调用</strong><br>
MySQL 中有函数的概念，比如获取当前时间的函数 <code>NOW</code>，而在函数后边加个小括号就算是一个函数调用，比如 <code>NOW()</code></li>
<li><strong>标量子查询或者行子查询</strong><br>
关于子查询的知识点后面会单独整理</li>
<li><strong>其他表达式</strong><br>
一个表达式本身也可以作为一个操作数，然后与另一个操作数结合形成一个更复杂的表达式，比方说（假设 <code>col</code> 是一个列名）：
<ul>
<li><code>(col - 5) / 3</code></li>
<li><code>(1 + 1) * 2 + col * 3</code></li>
</ul>
</li>
</ul>
<div><p>小贴士</p>
<p>以上只是常用操作数，实际上 MySQL 中可以作为操作数的还有很多，如有更高级的需求可以到官方文档中查看更多的操作数类型</p>
</div>
<h3 id="操作符"> 操作符</h3>
<p>比较常用的有三种操作符（高级的以后再说）：</p>
<h4 id="_1-算术操作符"> 1）算术操作符</h4>
<p>就是加减乘除法那一套</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">示例</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>+</code></td>
<td style="text-align:left"><code>a + b</code></td>
<td style="text-align:left">加法</td>
</tr>
<tr>
<td style="text-align:left"><code>-</code></td>
<td style="text-align:left"><code>a - b</code></td>
<td style="text-align:left">减法</td>
</tr>
<tr>
<td style="text-align:left"><code>*</code></td>
<td style="text-align:left"><code>a * b</code></td>
<td style="text-align:left">乘法</td>
</tr>
<tr>
<td style="text-align:left"><code>/</code></td>
<td style="text-align:left"><code>a / b</code></td>
<td style="text-align:left">除法</td>
</tr>
<tr>
<td style="text-align:left"><code>DIV</code></td>
<td style="text-align:left"><code>a DIV b</code></td>
<td style="text-align:left">除法，取商的整数部分</td>
</tr>
<tr>
<td style="text-align:left"><code>%</code></td>
<td style="text-align:left"><code>a % b</code></td>
<td style="text-align:left">取余</td>
</tr>
<tr>
<td style="text-align:left"><code>-</code></td>
<td style="text-align:left"><code>-a</code></td>
<td style="text-align:left">负号</td>
</tr>
</tbody>
</table>
<h4 id="_2-比较操作符"> 2）比较操作符</h4>
<p>就是在 <code>搜索条件</code> 中使用的比较操作符，下面整理一些常用的：</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">示例</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>=</code></td>
<td style="text-align:left"><code>a = b</code></td>
<td style="text-align:left">a 等于 b</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;&gt;</code> 或者 <code>!=</code></td>
<td style="text-align:left"><code>a &lt;&gt; b</code></td>
<td style="text-align:left">a 不等于 b</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;</code></td>
<td style="text-align:left"><code>a &lt; b</code></td>
<td style="text-align:left">a 小于 b</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;=</code></td>
<td style="text-align:left"><code>a &lt;= b</code></td>
<td style="text-align:left">a 小于或等于 b</td>
</tr>
<tr>
<td style="text-align:left"><code>&gt;</code></td>
<td style="text-align:left"><code>a &gt; b</code></td>
<td style="text-align:left">a 大于 b</td>
</tr>
<tr>
<td style="text-align:left"><code>&gt;=</code></td>
<td style="text-align:left"><code>a &gt;= b</code></td>
<td style="text-align:left">a 大于或等于 b</td>
</tr>
<tr>
<td style="text-align:left"><code>BETWEEN</code></td>
<td style="text-align:left"><code>a BETWEEN b AND c</code></td>
<td style="text-align:left">满足 b &lt;= a &lt;= c</td>
</tr>
<tr>
<td style="text-align:left"><code>NOT BETWEEN</code></td>
<td style="text-align:left"><code>a NOT BETWEEN b AND c</code></td>
<td style="text-align:left">不满足 b &lt;= a &lt;= c</td>
</tr>
<tr>
<td style="text-align:left"><code>IN</code></td>
<td style="text-align:left"><code>a IN (b1, b2, ...)</code></td>
<td style="text-align:left">a 是 b1, b2, ... 中的某一个</td>
</tr>
<tr>
<td style="text-align:left"><code>NOT IN</code></td>
<td style="text-align:left"><code>a NOT IN (b1, b2, ...)</code></td>
<td style="text-align:left">a 不是 b1, b2, ... 中的任意一个</td>
</tr>
<tr>
<td style="text-align:left"><code>IS NULL</code></td>
<td style="text-align:left"><code>a IS NULL</code></td>
<td style="text-align:left">a 的值是 <code>NULL</code></td>
</tr>
<tr>
<td style="text-align:left"><code>IS NOT NULL</code></td>
<td style="text-align:left"><code>a IS NOT NULL</code></td>
<td style="text-align:left">a 的值不是 <code>NULL</code></td>
</tr>
<tr>
<td style="text-align:left"><code>LIKE</code></td>
<td style="text-align:left"><code>a LIKE b</code></td>
<td style="text-align:left">a 匹配 b</td>
</tr>
<tr>
<td style="text-align:left"><code>NOT LIKE</code></td>
<td style="text-align:left"><code>a NOT LIKE b</code></td>
<td style="text-align:left">a 不匹配 b</td>
</tr>
</tbody>
</table>
<p>由比较操作符连接而成的表达式也称为布尔表达式，表示 <code>TRUE</code> 或者 <code>FALSE</code></p>
<h4 id="_3-逻辑操作符"> 3）逻辑操作符</h4>
<p>逻辑操作符用来将多个布尔表达式连接起来，主要有这几个逻辑操作符：</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">示例</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>AND</code></td>
<td style="text-align:left"><code>a AND b</code></td>
<td style="text-align:left">只有 a 和 b 同时为真，表达式才为真</td>
</tr>
<tr>
<td style="text-align:left"><code>OR</code></td>
<td style="text-align:left"><code>a OR b</code></td>
<td style="text-align:left">只要 a 或 b 有任意一个为真，表达式就为真</td>
</tr>
<tr>
<td style="text-align:left"><code>XOR</code></td>
<td style="text-align:left"><code>a XOR b</code></td>
<td style="text-align:left">a 和 b 有且只有一个为真，表达式为真</td>
</tr>
</tbody>
</table>
<h3 id="表达式的使用"> 表达式的使用</h3>
<p>把操作数和操作符相互组合起来就可以组成一个表达式，表达式主要有下面这两种使用方式：</p>
<h4 id="_1-放在查询列表中"> 1）放在查询列表中</h4>
<p>查询列表中既可以直接放列名，也可以放任意一个表达式。比如下面的查询语句，就是在查询 <code>student_score</code> 表时把 <code>score</code> 字段的数据都加 <code>100</code>：</p>
<div><pre><code><span>SELECT</span> number<span>,</span> subject<span>,</span> score <span>+</span> <span>100</span> <span>FROM</span> student_score<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>其中的 <code>number</code>、<code>subject</code>、<code>score + 100</code> 都是表达式，结果集中的列的名称也将默认使用这些表达式的名称，所以如果你觉得原名称不好，可以使用别名</p>
<div><p>小贴士</p>
<p>放在查询列表的表达式也可以不涉及列名，这种查询列表中不涉及列名的情况下，甚至可以省略掉 <code>FROM</code> 子句后边的表名</p>
<p>比如写个常数相加：</p>
<div><pre><code>mysql<span>></span> <span>SELECT</span> <span>1</span><span>+</span><span>1</span><span>;</span>
<span>+</span><span>-----+</span>
<span>|</span> <span>1</span><span>+</span><span>1</span> <span>|</span>
<span>+</span><span>-----+</span>
<span>|</span>   <span>2</span> <span>|</span>
<span>+</span><span>-----+</span>
<span>1</span> <span>row</span> <span>in</span> <span>set</span> <span>(</span><span>0.00</span> sec<span>)</span>

mysql<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>这么写似乎没有什么实际用处。emm…或许可以当作计算器使用~</p>
</div>
<h4 id="_2-作为搜索条件"> 2）作为搜索条件</h4>
<p>前面介绍<strong>条件查询语法</strong>时，介绍的都是带有列名的表达式，搜索条件也可以不带列名，比如这样：</p>
<div><pre><code><span>SELECT</span> number<span>,</span> name<span>,</span> id_number<span>,</span> major <span>FROM</span> student_info <span>WHERE</span> <span>2</span> <span>></span> <span>1</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>不过这么写没什么实际意义，所以通常情况下搜索条件中都会包含列名的</p>
<h2 id="函数"> 函数</h2>
<p>MySQL 提供了一些函数可以帮助我们很方便的应对一些需求，比如：</p>
<ul>
<li><code>UPPER</code> 函数是用来把给定的文本中的小写字母转换成大写字母</li>
<li><code>MONTH</code> 函数是用来把某个日期数据中的月份值提取出来</li>
<li><code>NOW</code> 函数用来获取当前的日期和时间</li>
</ul>
<p>如果想使用这些函数，可以在函数名后加一个小括号 <code>()</code>，表示调用一下这个函数</p>
<p>下面是一些常用的 MySQL 内置函数：</p>
<h3 id="文本处理函数"> 文本处理函数</h3>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">调用示例</th>
<th style="text-align:left">示例结果</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>LEFT</code></td>
<td style="text-align:left"><code>LEFT('abc123', 3)</code></td>
<td style="text-align:left"><code>abc</code></td>
<td style="text-align:left">给定字符串从左边取指定长度的子串</td>
</tr>
<tr>
<td style="text-align:left"><code>RIGHT</code></td>
<td style="text-align:left"><code>RIGHT('abc123', 3)</code></td>
<td style="text-align:left"><code>123</code></td>
<td style="text-align:left">给定字符串从右边取指定长度的子串</td>
</tr>
<tr>
<td style="text-align:left"><code>LENGTH</code></td>
<td style="text-align:left"><code>LENGTH('abc')</code></td>
<td style="text-align:left"><code>3</code></td>
<td style="text-align:left">给定字符串的长度</td>
</tr>
<tr>
<td style="text-align:left"><code>LOWER</code></td>
<td style="text-align:left"><code>LOWER('ABC')</code></td>
<td style="text-align:left"><code>abc</code></td>
<td style="text-align:left">给定字符串的小写格式</td>
</tr>
<tr>
<td style="text-align:left"><code>UPPER</code></td>
<td style="text-align:left"><code>UPPER('abc')</code></td>
<td style="text-align:left"><code>ABC</code></td>
<td style="text-align:left">给定字符串的大写格式</td>
</tr>
<tr>
<td style="text-align:left"><code>LTRIM</code></td>
<td style="text-align:left"><code>LTRIM(' abc')</code></td>
<td style="text-align:left"><code>abc</code></td>
<td style="text-align:left">给定字符串左边空格去除后的格式</td>
</tr>
<tr>
<td style="text-align:left"><code>RTRIM</code></td>
<td style="text-align:left"><code>RTRIM('abc ')</code></td>
<td style="text-align:left"><code>abc</code></td>
<td style="text-align:left">给定字符串右边空格去除后的格式</td>
</tr>
<tr>
<td style="text-align:left"><code>SUBSTRING</code></td>
<td style="text-align:left"><code>SUBSTRING('abc123', 2, 3)</code></td>
<td style="text-align:left"><code>bc1</code></td>
<td style="text-align:left">给定字符串从指定位置截取指定长度的子串</td>
</tr>
<tr>
<td style="text-align:left"><code>CONCAT</code></td>
<td style="text-align:left"><code>CONCAT('abc', '123', 'xyz')</code></td>
<td style="text-align:left"><code>abc123xyz</code></td>
<td style="text-align:left">将给定的各个字符串拼接成一个新字符串</td>
</tr>
</tbody>
</table>
<p>用法示例：</p>
<div><pre><code>mysql<span>></span> <span>SELECT</span> CONCAT<span>(</span><span>'学号为'</span><span>,</span> number<span>,</span> <span>'的学生在《'</span><span>,</span> subject<span>,</span> <span>'》课程的成绩是：'</span><span>,</span> score<span>)</span> <span>AS</span> 成绩描述 <span>FROM</span> student_score<span>;</span>
<span>+</span><span>-------------------------------------------------------------------------+</span>
<span>|</span> 成绩描述                                                                <span>|</span>
<span>+</span><span>-------------------------------------------------------------------------+</span>
<span>|</span> 学号为<span>20220101</span>的学生在《大学英语》课程的成绩是：<span>88</span>                      <span>|</span>
<span>|</span> 学号为<span>20220101</span>的学生在《高等数学》课程的成绩是：<span>78</span>                      <span>|</span>
<span>|</span> 学号为<span>20220102</span>的学生在《大学英语》课程的成绩是：<span>98</span>                      <span>|</span>
<span>|</span> 学号为<span>20220102</span>的学生在《高等数学》课程的成绩是：<span>100</span>                     <span>|</span>
<span>|</span> 学号为<span>20220103</span>的学生在《大学英语》课程的成绩是：<span>61</span>                      <span>|</span>
<span>|</span> 学号为<span>20220103</span>的学生在《高等数学》课程的成绩是：<span>59</span>                      <span>|</span>
<span>|</span> 学号为<span>20220104</span>的学生在《大学英语》课程的成绩是：<span>46</span>                      <span>|</span>
<span>|</span> 学号为<span>20220104</span>的学生在《高等数学》课程的成绩是：<span>55</span>                      <span>|</span>
<span>+</span><span>-------------------------------------------------------------------------+</span>
<span>8</span> <span>rows</span> <span>in</span> <span>set</span> <span>(</span><span>0.00</span> sec<span>)</span>

mysql<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p><strong>有一个注意点</strong>：</p>
<p>文本处理函数 <code>SUBSTRING</code> 里的第 2 个参数是索引，是从 <code>1</code> 开始的，不是从 <code>0</code> 开始的。这与数据表里的记录索引不同，索引是从 <code>0</code> 开始的，具体体现在 <code>limit</code> 的使用中。如下实例：</p>
<div><pre><code>mysql<span>></span> <span>SELECT</span> SUBSTRING<span>(</span><span>'abcdef'</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>;</span>
<span>+</span><span>---------------------------+</span>
<span>|</span> SUBSTRING<span>(</span><span>'abcdef'</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span> <span>|</span>
<span>+</span><span>---------------------------+</span>
<span>|</span> bcd                       <span>|</span>
<span>+</span><span>---------------------------+</span>
<span>1</span> <span>row</span> <span>in</span> <span>set</span> <span>(</span><span>0.00</span> sec<span>)</span>

mysql<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="日期和时间处理函数"> 日期和时间处理函数</h3>
<p>下边有些函数会用到当前日期，在实际调用这些函数时以你的当前时间为准</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">调用示例</th>
<th style="text-align:left">示例结果</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>NOW</code></td>
<td style="text-align:left"><code>NOW()</code></td>
<td style="text-align:left"><code>2022-07-30 16:13:30</code></td>
<td style="text-align:left">返回当前日期和时间</td>
</tr>
<tr>
<td style="text-align:left"><code>CURDATE</code></td>
<td style="text-align:left"><code>CURDATE()</code></td>
<td style="text-align:left"><code>2022-07-30</code></td>
<td style="text-align:left">返回当前日期</td>
</tr>
<tr>
<td style="text-align:left"><code>CURTIME</code></td>
<td style="text-align:left"><code>CURTIME()</code></td>
<td style="text-align:left"><code>16:13:30</code></td>
<td style="text-align:left">返回当前时间</td>
</tr>
<tr>
<td style="text-align:left"><code>DATE</code></td>
<td style="text-align:left"><code>SELECT DATE('2022-07-30 16:13:30')</code></td>
<td style="text-align:left"><code>2022-07-30</code></td>
<td style="text-align:left">将给定日期和时间值的日期提取出来</td>
</tr>
<tr>
<td style="text-align:left"><code>DATE_ADD</code></td>
<td style="text-align:left"><code>DATE_ADD('2022-07-30 16:13:30', INTERVAL 2 DAY)</code></td>
<td style="text-align:left"><code>2022-08-01 16:13:30</code></td>
<td style="text-align:left">将给定的日期和时间值添加指定的时间间隔</td>
</tr>
<tr>
<td style="text-align:left"><code>DATE_SUB</code></td>
<td style="text-align:left"><code>DATE_SUB('2022-07-30 16:13:30', INTERVAL 2 DAY)</code></td>
<td style="text-align:left"><code>2022-07-28 16:13:30</code></td>
<td style="text-align:left">将给定的日期和时间值减去指定的时间间隔</td>
</tr>
<tr>
<td style="text-align:left"><code>DATEDIFF</code></td>
<td style="text-align:left"><code>DATEDIFF('2022-07-30', '2022-10-01')</code></td>
<td style="text-align:left"><code>-63</code></td>
<td style="text-align:left">返回两个日期之间的天数（负数代表前一个参数代表的日期比较小）</td>
</tr>
<tr>
<td style="text-align:left"><code>DATE_FORMAT</code></td>
<td style="text-align:left"><code>DATE_FORMAT(NOW(),'%m-%d-%Y')</code></td>
<td style="text-align:left"><code>07-30-2022</code></td>
<td style="text-align:left">用给定的格式显示日期和时间</td>
</tr>
</tbody>
</table>
<p>在使用这些函数时需要注意一些地方：</p>
<ul>
<li>
<p>在使用 <code>DATE_ADD</code> 和 <code>DATE_SUB</code> 这两个函数时，增加或减去的时间间隔单位可以自己定义，下面是 MySQL 支持的一些时间单位：</p>
<ul>
<li><code>MICROSECOND</code>：毫秒</li>
<li><code>SECOND</code>：秒</li>
<li><code>MINUTE</code>：分钟</li>
<li><code>HOUR</code>：小时</li>
<li><code>DAY</code>：天</li>
<li><code>WEEK</code>：星期</li>
<li><code>MONTH</code>：月</li>
<li><code>QUARTER</code>：季度</li>
<li><code>YEAR</code>：年</li>
</ul>
</li>
<li>
<p>在使用 <code>DATE_FORMAT</code> 函数时需要注意，我们可以通过一些格式符，自定义日期和时间的显示格式，下面是 MySQL 中常用的一些日期和时间的格式符以及它们对应的含义：</p>
<ul>
<li><code>%b</code>：简写的月份名称（Jan、Feb、...、Dec)</li>
<li><code>%D</code>：带有英文后缀的月份中的日期（0th、1st、2nd、...、31st)）</li>
<li><code>%d</code>：数字格式的月份中的日期(00、01、02、...、31)</li>
<li><code>%f</code>：微秒（000000-999999）</li>
<li><code>%H</code>：二十四小时制的小时 (00-23)</li>
<li><code>%h</code>：十二小时制的小时 (01-12)</li>
<li><code>%i</code>：数值格式的分钟(00-59)</li>
<li><code>%M</code>：月份名（January、February、...、December）</li>
<li><code>%m</code>：数值形式的月份(00-12)</li>
<li><code>%p</code>：上午或下午（AM 代表上午、PM 代表下午）</li>
<li><code>%S</code>：秒（00-59）</li>
<li><code>%s</code>：秒（00-59）</li>
<li><code>%W</code>：星期名（Sunday、Monday、...、Saturday）</li>
<li><code>%w</code>：周内第几天 （0=星期日、1=星期一、6=星期六）</li>
<li><code>%Y</code>：4 位数字形式的年（例如 2022）</li>
<li><code>%y</code>：2 位数字形式的年（例如 22）</li>
</ul>
</li>
</ul>
<p>来举个实例：</p>
<div><pre><code>mysql<span>></span> <span>SELECT</span> DATE_FORMAT<span>(</span><span>NOW</span><span>(</span><span>)</span><span>,</span><span>'%b %d %Y %h:%i %p'</span><span>)</span><span>;</span>
<span>+</span><span>----------------------------------------+</span>
<span>|</span> DATE_FORMAT<span>(</span><span>NOW</span><span>(</span><span>)</span><span>,</span><span>'%b %d %Y %h:%i %p'</span><span>)</span> <span>|</span>
<span>+</span><span>----------------------------------------+</span>
<span>|</span> Jul <span>30</span> <span>2022</span> <span>04</span>:<span>29</span> PM                   <span>|</span>
<span>+</span><span>----------------------------------------+</span>
<span>1</span> <span>row</span> <span>in</span> <span>set</span> <span>(</span><span>0.00</span> sec<span>)</span>

mysql<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><code>'%b %d %Y %h:%i %p'</code> 就是一个用格式符描述的显示格式，意味着对应的日期和时间应该以下边描述的方式展示：</p>
<ul>
<li>先输出简写的月份名称（格式符 <code>%b</code>），也就是示例中的 <code>Jul</code>，然后输出一个空格</li>
<li>再输出用数字格式表示的的月份中的日期（格式符 <code>%d</code>），也就是示例中的 <code>30</code>，然后输出一个空格</li>
<li>再输出 4 位数字形式的年（格式符 <code>%Y</code>），也就是示例中的 <code>2022</code>，然后输出一个空格</li>
<li>再输出十二小时制的小时（格式符 <code>%h</code>），也就是示例中的 <code>04</code>，然后输出一个冒号<code>:</code></li>
<li>再输出数值格式的分钟（格式符 <code>%i</code>），也就是示例中的 <code>29</code>，然后输出一个空格</li>
<li>最后输出上午或者下午（格式符 <code>%p</code>），也就是示例中的 <code>PM</code></li>
</ul>
<h3 id="数值处理函数"> 数值处理函数</h3>
<p>下面列举一些数学上常用到的函数，在遇到需要数学计算的业务时会很有用：</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">调用示例</th>
<th style="text-align:left">示例结果</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>ABS</code></td>
<td style="text-align:left"><code>ABS(-1)</code></td>
<td style="text-align:left"><code>1</code></td>
<td style="text-align:left">取绝对值</td>
</tr>
<tr>
<td style="text-align:left"><code>Pi</code></td>
<td style="text-align:left"><code>PI()</code></td>
<td style="text-align:left"><code>3.141593</code></td>
<td style="text-align:left">返回圆周率</td>
</tr>
<tr>
<td style="text-align:left"><code>COS</code></td>
<td style="text-align:left"><code>COS(PI())</code></td>
<td style="text-align:left"><code>-1</code></td>
<td style="text-align:left">返回一个角度的余弦</td>
</tr>
<tr>
<td style="text-align:left"><code>EXP</code></td>
<td style="text-align:left"><code>EXP(1)</code></td>
<td style="text-align:left"><code>2.718281828459045</code></td>
<td style="text-align:left">返回 e 的指定次方</td>
</tr>
<tr>
<td style="text-align:left"><code>MOD</code></td>
<td style="text-align:left"><code>MOD(5,2)</code></td>
<td style="text-align:left"><code>1</code></td>
<td style="text-align:left">返回除法的余数</td>
</tr>
<tr>
<td style="text-align:left"><code>RAND</code></td>
<td style="text-align:left"><code>RAND()</code></td>
<td style="text-align:left"><code>0.7537623539136372</code></td>
<td style="text-align:left">返回一个随机数</td>
</tr>
<tr>
<td style="text-align:left"><code>SIN</code></td>
<td style="text-align:left"><code>SIN(PI()/2)</code></td>
<td style="text-align:left"><code>1</code></td>
<td style="text-align:left">返回一个角度的正弦</td>
</tr>
<tr>
<td style="text-align:left"><code>SQRT</code></td>
<td style="text-align:left"><code>SQRT(9)</code></td>
<td style="text-align:left"><code>3</code></td>
<td style="text-align:left">返回一个数的平方根</td>
</tr>
<tr>
<td style="text-align:left"><code>TAN</code></td>
<td style="text-align:left"><code>TAN(0)</code></td>
<td style="text-align:left"><code>0</code></td>
<td style="text-align:left">返回一个角度的正切</td>
</tr>
</tbody>
</table>
<h3 id="聚集函数-统计函数"> 聚集函数（统计函数）</h3>
<p>如果将上面介绍的那些函数以函数调用的形式放在查询列表中，那么会为表中符合 <code>WHERE</code> 条件的每一条记录调用一次该函数。就像这样：</p>
<div><pre><code><span>SELECT</span> number<span>,</span> <span>LEFT</span><span>(</span>name<span>,</span> <span>1</span><span>)</span> <span>FROM</span> student_info <span>WHERE</span> number <span>&lt;</span> <span>20220106</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>表中符合 <code>number &lt; 20220106</code> 搜索条件的每一条记录的 <code>name</code> 字段会依次被当作 <code>LEFT</code> 函数的参数，结果就是把这些人的名字的首个字符给提取出来了</p>
<p>但是有些函数是用来统计数据的，比如统计一下表中的行数，某一列数据的最大值是什么，我们把这种函数称之为聚集函数（这个翻译有点奇怪，其实叫统计函数好一些），下面是 MySQL 中常用的几种聚集函数：</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数名</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>COUNT</code></td>
<td style="text-align:left">返回某列的行数</td>
</tr>
<tr>
<td style="text-align:left"><code>MAX</code></td>
<td style="text-align:left">返回某列的最大值</td>
</tr>
<tr>
<td style="text-align:left"><code>MIN</code></td>
<td style="text-align:left">返回某列的最小值</td>
</tr>
<tr>
<td style="text-align:left"><code>SUM</code></td>
<td style="text-align:left">返回某列值之和</td>
</tr>
<tr>
<td style="text-align:left"><code>AVG</code></td>
<td style="text-align:left">返回某列的平均值</td>
</tr>
</tbody>
</table>
<h4 id="count-函数"> COUNT 函数</h4>
<p><code>COUNT</code> 函数是用来统计行数的，它有两种使用方式：</p>
<ul>
<li><code>COUNT(*)</code>：对表中行的数目进行计数，不管列的值是不是 <code>NULL</code></li>
<li><code>COUNT(列名)</code>：对特定的列进行计数，会忽略掉该列为 <code>NULL</code> 的行</li>
</ul>
<p>两者的区别：<strong>会不会忽略统计列的值为 <code>NULL</code> 的行</strong></p>
<p>使用例子：</p>
<div><pre><code><span>SELECT</span> <span>COUNT</span><span>(</span><span>*</span><span>)</span> <span>FROM</span> student_info<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="max-函数"> MAX 函数</h4>
<p><code>MAX</code> 函数是用来查询某列中数据的最大值，以 <code>student_score</code> 表中的 <code>score</code> 列为例：</p>
<div><pre><code><span>SELECT</span> <span>MAX</span><span>(</span>score<span>)</span> <span>FROM</span> student_score<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="min-函数"> MIN 函数</h4>
<p><code>MIN</code> 函数是用来查询某列中数据的最小值，以 <code>student_score</code> 表中的 <code>score</code> 列为例：</p>
<div><pre><code><span>SELECT</span> <span>MIN</span><span>(</span>score<span>)</span> <span>FROM</span> student_score<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="sum-函数"> SUM 函数</h4>
<p><code>SUM</code> 函数是用来计算某列数据的和，还是以 <code>student_score</code> 表中的 <code>score</code> 列为例：</p>
<div><pre><code><span>SELECT</span> <span>SUM</span><span>(</span>score<span>)</span> <span>FROM</span> student_score<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="avg-函数"> AVG 函数</h4>
<p><code>AVG</code> 函数是用来计算某列数据的平均数，仍旧以 <code>student_score</code> 表中的 <code>score</code> 列为例：</p>
<div><pre><code><span>SELECT</span> <span>AVG</span><span>(</span>score<span>)</span> <span>FROM</span> student_score<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="给定搜索条件下聚集函数的使用"> 给定搜索条件下聚集函数的使用</h4>
<p>聚集函数并不是一定要统计一个表中的所有记录，我们也可以指定搜索条件来限定这些聚集函数作用的范围。比如我们只想统计 <code>&quot;高等数学&quot;</code> 这门课程的平均分可以这么写：</p>
<div><pre><code><span>SELECT</span> <span>AVG</span><span>(</span>score<span>)</span> <span>FROM</span> student_score <span>WHERE</span> subject <span>=</span> <span>'高等数学'</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>换句话说就是：不在搜索条件中的那些记录是不参与统计的</p>
<h4 id="聚集函数中-distinct-的使用"> 聚集函数中 DISTINCT 的使用</h4>
<p>默认情况下，聚集函数将计算指定列的所有非 <code>NULL</code> 数据，如果我们指定的列中有重复数据的话，可以选择使用 <code>DISTINCT</code> 来过滤掉这些重复数据</p>
<p>比如我们想查看一下 <code>student_info</code> 表中存储了多少个专业的学生信息，就可以这么写：</p>
<div><pre><code><span>SELECT</span> <span>COUNT</span><span>(</span><span>DISTINCT</span> major<span>)</span> <span>FROM</span> student_info<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="组合聚集函数"> 组合聚集函数</h4>
<p>聚集函数也可以集中在一个查询中使用，比如这样：</p>
<div><pre><code>mysql<span>></span> <span>SELECT</span> <span>COUNT</span><span>(</span><span>*</span><span>)</span> <span>AS</span> 成绩记录总数<span>,</span> <span>MAX</span><span>(</span>score<span>)</span> <span>AS</span> 最高成绩<span>,</span> <span>MIN</span><span>(</span>score<span>)</span> <span>AS</span> 最低成绩<span>,</span> <span>AVG</span><span>(</span>score<span>)</span> <span>AS</span> 平均成绩 <span>FROM</span> student_score<span>;</span>
<span>+</span><span>--------------------+--------------+--------------+--------------+</span>
<span>|</span> 成绩记录总数       <span>|</span> 最高成绩     <span>|</span> 最低成绩     <span>|</span> 平均成绩     <span>|</span>
<span>+</span><span>--------------------+--------------+--------------+--------------+</span>
<span>|</span>                  <span>8</span> <span>|</span>          <span>100</span> <span>|</span>           <span>46</span> <span>|</span>      <span>73.1250</span> <span>|</span>
<span>+</span><span>--------------------+--------------+--------------+--------------+</span>
<span>1</span> <span>row</span> <span>in</span> <span>set</span> <span>(</span><span>0.00</span> sec<span>)</span>

mysql<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="隐式类型转换"> 隐式类型转换</h2>
<p>只要某个值的类型与上下文要求的类型不符，MySQL 就会根据上下文环境中需要的类型对该值进行类型转换，由于这些类型转换都是 MySQL 自动完成的，所以也可以被称为隐式类型转换</p>
<h3 id="隐式类型转换的场景"> 隐式类型转换的场景</h3>
<h4 id="_1-把操作数类型转换为适合操作符计算的相应类型"> 1）把操作数类型转换为适合操作符计算的相应类型</h4>
<p>比如对于加法操作符 <code>+</code> 来说，它要求两个操作数都必须是数字才能进行计算，所以如果某个操作数不是数字的话，会将其隐式转换为数字：</p>
<div><pre><code><span>1</span> + <span>2</span>       →   <span>3</span>
<span>'1'</span> + <span>2</span>     →   <span>3</span>
<span>'1'</span> + <span>'2'</span>   →   <span>3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id="_2-将函数参数转换为该函数期望的类型"> 2）将函数参数转换为该函数期望的类型</h4>
<p>拿用于拼接字符串的 <code>CONCAT</code> 函数举例，这个函数以字符串类型的值作为参数，如果我们在调用这个函数的时候，传入了别的类型的值作为参数，MySQL 会自动把这些值的类型转换为字符串类型的：</p>
<div><pre><code>CONCAT<span>(</span><span>'1'</span>, <span>'2'</span><span>)</span>    →   <span>'12'</span>
CONCAT<span>(</span><span>'1'</span>, <span>2</span><span>)</span>      →   <span>'12'</span>
CONCAT<span>(</span><span>1</span>, <span>2</span><span>)</span>        →   <span>'12'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id="_3-存储数据时-把某个值转换为某个列需要的类型"> 3）存储数据时，把某个值转换为某个列需要的类型</h4>
<p>如果创建表时是这么定义的：</p>
<div><pre><code><span>CREATE</span> <span>TABLE</span> test <span>(</span>
    column_a <span>TINYINT</span><span>,</span>
    column_b <span>TINYINT</span><span>,</span>
    column_c <span>VARCHAR</span><span>(</span><span>100</span><span>)</span>
<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>接着在存储数据的时候填入的不是期望的类型，就像这样：</p>
<div><pre><code><span>INSERT</span> <span>INTO</span> t<span>(</span>i1<span>,</span> i2<span>,</span> s<span>)</span> <span>VALUES</span><span>(</span><span>'100'</span><span>,</span> <span>'100'</span><span>,</span> <span>200</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>可以发现虽然三个列的类型都不对，但也能插入成功，这是由于隐式类型转换的存在，在插入数据的时候它们被转换成了应有的类型</p>
<h3 id="类型转换的注意事项"> 类型转换的注意事项</h3>
<h4 id="_1-mysql-会尽量把值转换为表达式中需要的类型-而不是产生错误"> 1）MySQL 会尽量把值转换为表达式中需要的类型，而不是产生错误</h4>
<p>按理说 <code>'123abc'</code> 这个字符串无法转换为数字，但是 MySQL 规定只要字符串的开头部分包含数字，那么就把这个字符串转换为开头的数字，如果开头并没有包含数字，那么将被转换成 <code>0</code>，比如这样：</p>
<div><pre><code><span>'123abc'</span>         →   <span>123</span>
<span>'2022-07-30'</span>     →   <span>2022</span>
<span>'17:02:56'</span>       →   <span>17</span>
<span>'asd'</span>            →   <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>看个例子：</p>
<div><pre><code>mysql<span>></span> <span>SELECT</span> <span>'123abc'</span> <span>+</span> <span>0</span><span>,</span> <span>'asd'</span> <span>+</span> <span>0</span><span>;</span>
<span>+</span><span>--------------+-----------+</span>
<span>|</span> <span>'123abc'</span> <span>+</span> <span>0</span> <span>|</span> <span>'asd'</span> <span>+</span> <span>0</span> <span>|</span>
<span>+</span><span>--------------+-----------+</span>
<span>|</span>          <span>123</span> <span>|</span>         <span>0</span> <span>|</span>
<span>+</span><span>--------------+-----------+</span>
<span>1</span> <span>row</span> <span>in</span> <span>set</span><span>,</span> <span>2</span> <span>warnings</span> <span>(</span><span>0.00</span> sec<span>)</span>

mysql<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>不过需要注意的是，这种强制转换不能用于存储数据中，否则会报错：</p>
<div><pre><code>mysql<span>></span> <span>INSERT</span> <span>INTO</span> test<span>(</span>column_a<span>,</span> column_b<span>,</span> column_c<span>)</span> <span>VALUES</span><span>(</span><span>'123abc'</span><span>,</span> <span>'asd'</span><span>,</span> <span>'up'</span><span>)</span><span>;</span>
ERROR <span>1265</span> <span>(</span><span>01000</span><span>)</span>: <span>Data</span> truncated <span>for</span> <span>column</span> <span>'column_a'</span> at <span>row</span> <span>1</span>
mysql<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id="_2-在运算时会自动提升操作数的类型"> 2）在运算时会自动提升操作数的类型</h4>
<p>不同数据类型能表示的数值范围是不一样的，再小的数据类型经过算数计算后得出的结果可能大于该可以表示的范围。比如 <code>test</code> 表中有一条记录如下：</p>
<div><pre><code>mysql<span>></span> <span>SELECT</span> <span>*</span> <span>FROM</span> test<span>;</span>
<span>+</span><span>----------+----------+----------+</span>
<span>|</span> column_a <span>|</span> column_b <span>|</span> column_c <span>|</span>
<span>+</span><span>----------+----------+----------+</span>
<span>|</span>      <span>100</span> <span>|</span>      <span>100</span> <span>|</span> <span>200</span>      <span>|</span>
<span>+</span><span>----------+----------+----------+</span>
<span>1</span> <span>row</span> <span>in</span> <span>set</span> <span>(</span><span>0.00</span> sec<span>)</span>

mysql<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>其中的 <code>column_a</code> 列和 <code>column_b</code> 列的类型都是 <code>TINYINT</code>，而 <code>TINYINT</code> 能表示的最大正整数是 <code>127</code></p>
<p>如果我们把 <code>column_a</code> 列的值和 <code>column_b</code> 列的值相加：</p>
<div><pre><code>mysql<span>></span> <span>SELECT</span> column_a <span>+</span> column_b <span>FROM</span> test<span>;</span>
<span>+</span><span>---------------------+</span>
<span>|</span> column_a <span>+</span> column_b <span>|</span>
<span>+</span><span>---------------------+</span>
<span>|</span>                 <span>200</span> <span>|</span>
<span>+</span><span>---------------------+</span>
<span>1</span> <span>row</span> <span>in</span> <span>set</span> <span>(</span><span>0.00</span> sec<span>)</span>

mysql<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>结果超出了 <code>TINYINT</code> 类型的表示范围，但依旧能显示。这是因为在运算的过程中，MySQL 自动将整数类型的操作数提升到了 <code>BIGINT</code>，这样就不会产生运算结果太大超过 <code>TINYINT</code> 能表示的数值范围的尴尬情况了</p>
<p>类似的，有浮点数的运算过程会把操作数自动转型为 <code>DOUBLE</code> 类型</p>
<div><p>小贴士</p>
<p>有隐式类型转换，自然也有显式类型转换。在 MySQL 中，可以使用 <code>CAST</code> 函数完成显式地类型转换，就是我们明确指定要将特定的数值转换为某种特定类型，需要用到的话可以到文档中查一下</p>
</div>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">分组查询语法</title>
    <id>https://www.snowji.cn/databases/mysql/group-query/</id>
    <link href="https://www.snowji.cn/databases/mysql/group-query/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="分组查询语法"> 分组查询语法</h1>
<p>分组就是：针对某个列，将该列的值相同的记录分到一个组中</p>
<p>按照科目（<code>subject</code>）列分组的意思就是将 <code>subject</code> 列的值相同的记录划分到一个组中，分组后能更方便地统计每门学科的成绩等信息</p>
<p>如果不分组，就要写 N 个条件查询语句，每个语句进行 <code>WHERE subject = '高等数学'</code> 这样的过滤</p>
<h2 id="group-by-子句"> GROUP BY 子句</h2>
<p>能实现分组功能的就是 <code>GROUP BY</code> 子句，语法如下：</p>
<div><pre><code><span>SELECT</span> 列名<span>1</span><span>,</span> <span>AVG</span><span>(</span>列名<span>2</span><span>)</span> <span>FROM</span> 表名 <span>GROUP</span> <span>BY</span> 列名<span>1</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>用这个语法来查询看看：</p>
<div><pre><code>mysql<span>></span> <span>SELECT</span> subject<span>,</span> <span>AVG</span><span>(</span>score<span>)</span> <span>FROM</span> student_score <span>GROUP</span> <span>BY</span> subject<span>;</span>
<span>+</span><span>--------------+------------+</span>
<span>|</span> subject      <span>|</span> <span>AVG</span><span>(</span>score<span>)</span> <span>|</span>
<span>+</span><span>--------------+------------+</span>
<span>|</span> 大学英语     <span>|</span>    <span>73.2500</span> <span>|</span>
<span>|</span> 高等数学     <span>|</span>    <span>73.0000</span> <span>|</span>
<span>+</span><span>--------------+------------+</span>
<span>2</span> <span>rows</span> <span>in</span> <span>set</span> <span>(</span><span>0.00</span> sec<span>)</span>

mysql<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>这个查询的执行过程就是按照 <code>subject</code> 中的值将所有的记录分成 N 组（<code>subject</code> 列中有多少不重复的课程，那就会有多少个分组），然后分别对每个分组中记录的 <code>score</code> 列调用 <code>AVG</code> 函数进行数据统计</p>
<p>注意：分组的存在仅仅是为了方便我们分别统计各个分组中的信息，所以在 <code>查询列表</code> 处一般只放置 <code>分组列</code> 和 <code>聚集函数</code>，就像上面的例子那样</p>
<p>如果非分组列出现在查询列表中，是会报错的，比如下面这个查询（查询列表里多了 <code>number</code> 列）：</p>
<div><pre><code>mysql<span>></span> <span>SELECT</span> number<span>,</span> subject<span>,</span> <span>AVG</span><span>(</span>score<span>)</span> <span>FROM</span> student_score <span>GROUP</span> <span>BY</span> subject<span>;</span>
ERROR <span>1055</span> <span>(</span><span>42000</span><span>)</span>: Expression <span>#1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'school.student_score.number' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by</span>
mysql<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="带有-where-子句的分组查询"> 带有 WHERE 子句的分组查询</h2>
<p>可以在分组前，借助 WHERE 子句先将某些记录过滤掉</p>
<p>比如老师觉得各个科目的平均分太低了，所以想先把分数低于 60 分的记录去掉之后再统计平均分，就可以这么写：</p>
<div><pre><code><span>SELECT</span> subject<span>,</span> <span>AVG</span><span>(</span>score<span>)</span> <span>FROM</span> student_score <span>WHERE</span> score <span>>=</span> <span>60</span> <span>GROUP</span> <span>BY</span> subject<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>这个过程可以分成两个步骤理解：</p>
<ul>
<li>先将记录进行过滤后分组</li>
<li>再分别对各个分组进行数据统计</li>
</ul>
<h2 id="作用于分组的过滤条件"> 作用于分组的过滤条件</h2>
<p>有时候 <code>GROUP BY</code> 子句可能会产生非常多的分组，如果我们不想在结果集中得到这么多记录，只想把那些符合某些条件的分组加入到结果集，从而减少结果集中记录的条数，那就需要把<strong>针对分组的条件</strong>放到 <code>HAVING</code> 子句了</p>
<p>比如老师想要查询平均分大于 80 分的课程，就可以这么写：</p>
<div><pre><code><span>SELECT</span> subject<span>,</span> <span>AVG</span><span>(</span>score<span>)</span> <span>FROM</span> student_score <span>GROUP</span> <span>BY</span> subject <span>HAVING</span> <span>AVG</span><span>(</span>score<span>)</span> <span>></span> <span>80</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>其实这里所谓的 <code>针对分组的条件</code> 一般是指下面这两种：</p>
<ul>
<li>
<p><strong>分组列</strong></p>
<p>也就是说我们可以把用于分组的列放到 <code>HAVING</code> 子句的条件中，比如这样：</p>
<div><pre><code><span>SELECT</span> subject<span>,</span> <span>AVG</span><span>(</span>score<span>)</span> <span>FROM</span> student_score <span>GROUP</span> <span>BY</span> subject <span>having</span> subject <span>=</span> <span>'高等数学'</span><span>;</span> 
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p><strong>作用于分组的聚集函数</strong></p>
<p>这里并不是说 <code>HAVING</code> 子句中只能放置在查询列表出现的那些聚集函数，只要是针对这个分组进行统计的聚集函数都可以。比如老师想查询最高分大于 98 分的课程的平均分，可以这么写：</p>
<div><pre><code><span>SELECT</span> subject<span>,</span> <span>AVG</span><span>(</span>score<span>)</span> <span>FROM</span> student_score <span>GROUP</span> <span>BY</span> subject <span>HAVING</span> <span>MAX</span><span>(</span>score<span>)</span> <span>></span> <span>98</span><span>;</span> 
</code></pre>
<div><span>1</span><br></div></div><p>其中的 <code>MAX(score)</code> 这个聚集函数并没有出现在查询列表中，但仍然可以作为 <code>HAVING</code> 子句中表达式的一部分</p>
</li>
</ul>
<h2 id="分组和排序"> 分组和排序</h2>
<p>如果想对各个分组查询出来的统计数据进行排序，需要为查询列表中有聚集函数的表达式添加别名</p>
<p>比如想按照各个学科的平均分从大到小降序排序，可以这么写：</p>
<div><pre><code>mysql<span>></span> <span>SELECT</span> subject<span>,</span> <span>AVG</span><span>(</span>score<span>)</span> <span>AS</span> avg_score <span>FROM</span> student_score <span>GROUP</span> <span>BY</span> subject <span>ORDER</span> <span>BY</span> avg_score <span>DESC</span><span>;</span>
<span>+</span><span>--------------+-----------+</span>
<span>|</span> subject      <span>|</span> avg_score <span>|</span>
<span>+</span><span>--------------+-----------+</span>
<span>|</span> 大学英语     <span>|</span>   <span>73.2500</span> <span>|</span>
<span>|</span> 高等数学     <span>|</span>   <span>73.0000</span> <span>|</span>
<span>+</span><span>--------------+-----------+</span>
<span>2</span> <span>rows</span> <span>in</span> <span>set</span> <span>(</span><span>0.00</span> sec<span>)</span>

mysql<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="嵌套分组"> 嵌套分组</h2>
<p>一个分组内可以被继续划分成更小的分组，只需要在 <code>GROUP BY</code> 子句中把各个分组列依次写上，用逗号 <code>,</code> 分隔开就好了</p>
<p>比如对于 <code>student_info</code> 表，我们可以先按照学院（<code>department</code>）来进行分组，再按照专业（<code>major</code>）来继续分组：</p>
<div><pre><code>mysql<span>></span> <span>SELECT</span> department<span>,</span> major<span>,</span> <span>COUNT</span><span>(</span><span>*</span><span>)</span> <span>FROM</span> student_info <span>GROUP</span> <span>BY</span> department<span>,</span> major<span>;</span>
<span>+</span><span>-----------------+--------------------------+----------+</span>
<span>|</span> department      <span>|</span> major                    <span>|</span> <span>COUNT</span><span>(</span><span>*</span><span>)</span> <span>|</span>
<span>+</span><span>-----------------+--------------------------+----------+</span>
<span>|</span> 计算机学院      <span>|</span> 计算机科学与工程         <span>|</span>        <span>2</span> <span>|</span>
<span>|</span> 计算机学院      <span>|</span> 软件工程                 <span>|</span>        <span>2</span> <span>|</span>
<span>|</span> 航天学院        <span>|</span> 飞行器设计               <span>|</span>        <span>1</span> <span>|</span>
<span>|</span> 航天学院        <span>|</span> 电子信息                 <span>|</span>        <span>1</span> <span>|</span>
<span>+</span><span>-----------------+--------------------------+----------+</span>
<span>4</span> <span>rows</span> <span>in</span> <span>set</span> <span>(</span><span>0.00</span> sec<span>)</span>

mysql<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>可以看到，在嵌套分组中，聚集函数将作用在最后一个分组列上，在这个例子中就是 <code>major</code> 列</p>
<h2 id="使用分组注意事项"> 使用分组注意事项</h2>
<p>使用分组来统计数据给我们带来了非常大的便利，但是要随时提防有坑的地方：</p>
<ul>
<li>
<p>如果分组列中含有 <code>NULL</code> 值，那么 <code>NULL</code> 也会作为一个独立的分组存在</p>
</li>
<li>
<p>如果存在多个分组列，也就是 <code>嵌套分组</code>，聚集函数将作用在最后的那个分组列上</p>
</li>
<li>
<p>如果查询语句中存在 <code>WHERE</code> 子句和 <code>ORDER BY</code> 子句，那么 <code>GROUP BY</code> 子句必须出现在 <code>WHERE</code> 子句之后，<code>ORDER BY</code> 子句之前</p>
</li>
<li>
<p><code>非分组列</code> 不能单独出现在检索列表中（可以被放到聚集函数中）</p>
</li>
<li>
<p><code>GROUP BY</code> 子句后也可以跟随 <code>表达式</code>（但不能是聚集函数）</p>
<p>这个特性挺有意思，<code>GROUP BY</code> 后跟随的除了可以是表中的某个列或者某些列，其实一个表达式也可以，比如这样：</p>
<div><pre><code>mysql<span>></span> <span>SELECT</span> concat<span>(</span><span>'专业：'</span><span>,</span> major<span>)</span><span>,</span> <span>COUNT</span><span>(</span><span>*</span><span>)</span> <span>FROM</span> student_info <span>GROUP</span> <span>BY</span> concat<span>(</span><span>'专业：'</span><span>,</span> major<span>)</span><span>;</span>
<span>+</span><span>-----------------------------------+----------+</span>
<span>|</span> concat<span>(</span><span>'专业：'</span><span>,</span> major<span>)</span>           <span>|</span> <span>COUNT</span><span>(</span><span>*</span><span>)</span> <span>|</span>
<span>+</span><span>-----------------------------------+----------+</span>
<span>|</span> 专业：计算机科学与工程            <span>|</span>        <span>2</span> <span>|</span>
<span>|</span> 专业：软件工程                    <span>|</span>        <span>2</span> <span>|</span>
<span>|</span> 专业：飞行器设计                  <span>|</span>        <span>1</span> <span>|</span>
<span>|</span> 专业：电子信息                    <span>|</span>        <span>1</span> <span>|</span>
<span>+</span><span>-----------------------------------+----------+</span>
<span>4</span> <span>rows</span> <span>in</span> <span>set</span> <span>(</span><span>0.00</span> sec<span>)</span>

mysql<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>MySQL 会根据这个表达式的值来对记录进行分组，使用表达式进行分组的时候需要特别注意，<strong>查询列表中的表达式和 <code>GROUP BY</code> 子句中的表达式必须完全一样</strong>。不过一般情况下我们也不会用表达式进行分组，所以目前基本没啥用</p>
</li>
<li>
<p><code>WHERE</code> 子句和 <code>HAVING</code> 子句的区别：</p>
<p><code>WHERE</code> 子句在分组前进行过滤，作用于每一条记录，<code>WHERE</code> 子句过滤掉的记录将不包括在分组中。而 <code>HAVING</code> 子句在数据分组后进行过滤，作用于整个分组</p>
</li>
</ul>
<h2 id="简单查询语句中各子句的顺序"> 简单查询语句中各子句的顺序</h2>
<p>在查询语句的各个子句中，除了 <code>SELECT</code> 之外，其他的子句全都是可以省略的</p>
<p>但如果在一个查询语句中出现了多个子句，那么它们之间的顺序是不能乱放的，顺序如下所示：</p>
<div><pre><code><span>SELECT</span> <span>[</span><span>DISTINCT</span><span>]</span> 查询列表
<span>[</span><span>FROM</span> 表名<span>]</span>
<span>[</span><span>WHERE</span> 布尔表达式<span>]</span>
<span>[</span><span>GROUP</span> <span>BY</span> 分组列表 <span>]</span>
<span>[</span><span>HAVING</span> 分组过滤条件<span>]</span>
<span>[</span><span>ORDER</span> <span>BY</span> 排序列表<span>]</span>
<span>[</span><span>LIMIT</span> 开始行<span>,</span> 限制条数<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>其中中括号 <code>[]</code> 中的内容表示可以省略，我们在书写查询语句的时候各个子句必须严格遵守这个顺序，不然会报错的！</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">MySql 锁</title>
    <id>https://www.snowji.cn/databases/mysql/lock/</id>
    <link href="https://www.snowji.cn/databases/mysql/lock/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="mysql-锁"> MySql 锁</h1>
<p>作用：为了解决资源(数据库中的数据)竞争的问题</p>
<p>存储引擎支持的锁：</p>
<ul>
<li>InnoDB 中支持行锁和表锁</li>
<li>MYISAM 中只支持表锁</li>
</ul>
<h2 id="锁的分类"> 锁的分类</h2>
<p><img src="./images/transation4.png" alt="transation" /></p>
<h3 id="行锁"> 行锁</h3>
<h4 id="共享锁-s-锁"> 共享锁(S 锁)</h4>
<p><strong>定义</strong>：</p>
<ul>
<li>又称为读锁</li>
<li>多个事务对于同一个数据可以共享一把锁，都能访问到数据，但是只能读不能修改</li>
</ul>
<p><strong>加锁方式</strong>：</p>
<div><pre><code><span>select</span> * from student where <span>id</span> <span>=</span> <span>1</span> LOCK IN SHARE MODE<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>解锁</strong>:</p>
<div><pre><code>commit/rollback<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="排他锁-x-锁"> 排他锁(X 锁)</h4>
<p><strong>定义</strong>:</p>
<ul>
<li>又称为写锁</li>
<li>不能与其他锁并存</li>
<li>一个事务获取了一个数据行的排它锁，其他事务就不能再获取该行的锁</li>
<li>只有获取了排它锁的事务是可以对数据行进行读取和修改</li>
</ul>
<p><strong>加锁方式</strong>：</p>
<div><pre><code><span># 自动</span>
delete/update/insert 默认加上 X 锁
<span># 手动</span>
<span>select</span> * from student where <span>id</span> <span>=</span> <span>1</span> FOR UPDATE<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>解锁</strong>:</p>
<div><pre><code>commit/rollback<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="意向锁"> 意向锁</h3>
<ul>
<li>是一种表锁</li>
<li>由数据库引擎自己维护</li>
<li>用户无法手动操作意向锁</li>
</ul>
<p>使用意向锁的目的：提高加表锁的效率的一个标志</p>
<h4 id="意向共享锁-is-锁"> 意向共享锁(IS 锁)</h4>
<p><strong>定义</strong>:</p>
<ul>
<li>表示事务准备给数据行加入共享锁</li>
<li>一个数据行加共享锁前必须先取得该表的 IS 锁</li>
</ul>
<h4 id="意向排它锁-ix-锁"> 意向排它锁(IX 锁)</h4>
<p><strong>定义</strong>:</p>
<ul>
<li>表示事务准备给数据行加入排它锁</li>
<li>一个数据行加排它锁前必须先取得该表的 IX 锁</li>
</ul>
<div><p>表锁与行锁的区别：</p>
<ul>
<li>锁定粒度：表锁 &gt; 行锁</li>
<li>加锁效率：表锁 &gt; 行锁</li>
<li>冲突概率：表锁 &gt; 行锁</li>
<li>并发性能：表锁 &lt; 行锁</li>
</ul>
</div>
<h3 id="锁的算法"> 锁的算法</h3>
<h4 id="记录锁"> 记录锁</h4>
<p>作用：锁定记录</p>
<p>使用场景：</p>
<p><img src="./images/lock1.png" alt="lock" /></p>
<h4 id="间隙锁"> 间隙锁</h4>
<p>作用：锁定范围</p>
<p>目的：阻塞插入</p>
<p>使用条件：</p>
<p><img src="./images/lock2.png" alt="lock" /></p>
<h4 id="临键锁"> 临键锁</h4>
<p>作用：锁定范围加记录</p>
<p>使用条件：</p>
<p><img src="./images/lock3.png" alt="lock" /></p>
<h2 id="mysql-锁到底锁住了什么"> MySQL 锁到底锁住了什么</h2>
<p><strong>锁定了聚簇索引项</strong></p>
<h2 id="参考文档"> 参考文档</h2>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html" target="_blank" rel="noopener noreferrer">InnoDB 存储引擎</a></p>
<p><a href="https://www.bilibili.com/video/BV1x54y1979n?spm_id_from=333.337.search-card.all.click" target="_blank" rel="noopener noreferrer">MySql 锁</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">连接查询语法</title>
    <id>https://www.snowji.cn/databases/mysql/join-query/</id>
    <link href="https://www.snowji.cn/databases/mysql/join-query/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="连接查询语法"> 连接查询语法</h1>
<p>连接查询就是把各个表中的记录都取出来，组成新的更大的记录，这个组合后的结果集可以方便我们分析数据，就不用老是两个表对照着看了</p>
<h2 id="基本语法"> 基本语法</h2>
<blockquote>
<p>下面用 <code>t1</code> 和 <code>t2</code> 分别指代两张表的名字，<code>m</code> 和 <code>n</code> 指代表中的列名</p>
</blockquote>
<p>在 MySQL 中，连接查询的语法是在 <code>FROM</code> 语句后边用多个用逗号 <code>,</code> 隔开表名，就像这样：</p>
<div><pre><code><span>SELECT</span> <span>*</span> <span>FROM</span> t1<span>,</span> t2<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>查询列表处的 <code>*</code> 代表从 <code>FROM</code> 语句后列出的表中选取每个列，也可以指定需要查询出来的列名：</p>
<div><pre><code><span>SELECT</span> t1<span>.</span>m1<span>,</span> t2<span>.</span>m2 <span>FROM</span> t1<span>,</span> t2<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>或者查询某张表的全部列，另一张表的指定列：</p>
<div><pre><code><span>SELECT</span> t1<span>.</span><span>*</span><span>,</span> t2<span>.</span>m2 <span>FROM</span> t1<span>,</span> t2<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>携带过滤条件的连接查询：</p>
<div><pre><code><span>SELECT</span> <span>*</span> <span>FROM</span> t1<span>,</span> t2 <span>WHERE</span> t1<span>.</span>m1 <span>></span> <span>1</span> <span>AND</span> t1<span>.</span>m1 <span>=</span> t2<span>.</span>m2 <span>AND</span> t2<span>.</span>n2 <span>&lt;</span> <span>'d'</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>在上面这个两表连接查询中，假定把 <code>t1</code> 表作为第一个需要查询的表，于是它称之为 <code>驱动表</code>，相应的 <code>t2</code> 表称之为 <code>被驱动表</code>。在执行过程中，会先在 <code>t1</code> 表中找出所有满足条件的记录，对于获取到的每一条记录，都需要到 <code>t2</code> 表中查找匹配的记录</p>
<p>因此<strong>在两表连接查询中，驱动表只需要查询一次，被驱动表可能会被查询多次</strong></p>
<div><p>小贴士</p>
<p>上面这种连接查询有个特点，就是如果 <code>t1</code>（驱动表）中查出来的记录，在 <code>t2</code>（被驱动表）中没有对应的记录，就直接不显示到结果集了</p>
<p>那么如果换个需求：驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。为了解决这个问题，就有了内连接和外连接的概念</p>
</div>
<h2 id="内连接和外连接"> 内连接和外连接</h2>
<h3 id="区别"> 区别</h3>
<ul>
<li><strong>对于内连接的两个表</strong>，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集，前面提到的连接都是所谓的内连接</li>
<li><strong>对于外连接的两个表</strong>，驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集</li>
</ul>
<p>在 MySQL 中，根据选取驱动表的不同，外连接可以细分为 2 种：</p>
<ul>
<li>左外连接：选取左侧的表为驱动表</li>
<li>右外连接：选取右侧的表为驱动表</li>
</ul>
<div><p>小贴士</p>
<p>左外连接和右外连接可以简称左连接和右连接</p>
</div>
<h3 id="where-和-on-子句"> WHERE 和 ON 子句</h3>
<p>即使对于外连接来说，有时候我们也并不想把驱动表的全部记录都加入到最后的结果集。于是过滤条件的写法除了 <code>WHERE</code> 子句，又引入了 <code>ON</code> 子句</p>
<ul>
<li>
<p><code>WHERE</code> 子句中的过滤条件</p>
<p><code>WHERE</code> 子句中的过滤条件就是我们平时见的那种，不论是内连接还是外连接，凡是不符合 <code>WHERE</code> 子句中的过滤条件的记录都不会被加入最后的结果集</p>
</li>
<li>
<p><code>ON</code> 子句中的过滤条件</p>
<p>对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配 <code>ON</code> 子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用 <code>NULL</code> 值填充</p>
</li>
</ul>
<p>需要注意的是，这个 <code>ON</code> 子句是专门为外连接驱动表中的记录在被驱动表找不到匹配记录时应不应该把该记录加入结果集这个场景下提出的，所以如果把 <code>ON</code> 子句放到内连接中，MySQL 会把它和 WHERE 子句一样对待，也就是说：<strong>内连接中的 <code>WHERE</code> 子句和 <code>ON</code> 子句是等价的</strong></p>
<p>一般情况下，我们都把只涉及单表的过滤条件放到 <code>WHERE</code> 子句中，把涉及两表的过滤条件都放到 <code>ON</code> 子句中，我们也一般把放到 <code>ON</code> 子句中的过滤条件也称之为<strong>连接条件</strong></p>
<h3 id="左-外-连接的语法"> 左（外）连接的语法</h3>
<h4 id="语法"> 语法：</h4>
<div><pre><code><span>SELECT</span> <span>*</span> <span>FROM</span> t1 <span>LEFT</span> <span>[</span><span>OUTER</span><span>]</span> <span>JOIN</span> t2 <span>ON</span> 连接条件 <span>[</span><span>WHERE</span> 普通过滤条件<span>]</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>中括号里的 <code>OUTER</code> 单词是可以省略的</li>
<li>对于 <code>LEFT JOIN</code> 类型的连接来说，放在左边的表称之为外表或者驱动表，右边的表称之为内表或者被驱动表</li>
<li>对于左连接和右连接来说，必须使用 <code>ON</code> 子句来指出连接条件</li>
</ul>
<h4 id="示例"> 示例：</h4>
<p>要求把所有的学生的成绩信息都查询出来，即使是缺考的考生也应该被放到结果集中（这里用到了<a href="/basic-skills/mysql/data-insert-delete-update/">数据的增删改</a>里插入的表和数据）</p>
<div><pre><code>mysql<span>></span> <span>SELECT</span> student_info<span>.</span>number<span>,</span> name<span>,</span> major<span>,</span> subject<span>,</span> score <span>FROM</span> student_info <span>LEFT</span> <span>JOIN</span> student_score <span>ON</span> student_info<span>.</span>number <span>=</span> student_score<span>.</span>number<span>;</span>
<span>+</span><span>----------+-----------+--------------------------+--------------+-------+</span>
<span>|</span> number   <span>|</span> name      <span>|</span> major                    <span>|</span> subject      <span>|</span> score <span>|</span>
<span>+</span><span>----------+-----------+--------------------------+--------------+-------+</span>
<span>|</span> <span>20220101</span> <span>|</span> 张星星    <span>|</span> 计算机科学与工程         <span>|</span> 大学英语     <span>|</span>    <span>88</span> <span>|</span>
<span>|</span> <span>20220101</span> <span>|</span> 张星星    <span>|</span> 计算机科学与工程         <span>|</span> 高等数学     <span>|</span>    <span>78</span> <span>|</span>
<span>|</span> <span>20220102</span> <span>|</span> 王二狗    <span>|</span> 计算机科学与工程         <span>|</span> 大学英语     <span>|</span>    <span>98</span> <span>|</span>
<span>|</span> <span>20220102</span> <span>|</span> 王二狗    <span>|</span> 计算机科学与工程         <span>|</span> 高等数学     <span>|</span>   <span>100</span> <span>|</span>
<span>|</span> <span>20220103</span> <span>|</span> 陈珊珊    <span>|</span> 软件工程                 <span>|</span> 大学英语     <span>|</span>    <span>61</span> <span>|</span>
<span>|</span> <span>20220103</span> <span>|</span> 陈珊珊    <span>|</span> 软件工程                 <span>|</span> 高等数学     <span>|</span>    <span>59</span> <span>|</span>
<span>|</span> <span>20220104</span> <span>|</span> 李思思    <span>|</span> 软件工程                 <span>|</span> 大学英语     <span>|</span>    <span>46</span> <span>|</span>
<span>|</span> <span>20220104</span> <span>|</span> 李思思    <span>|</span> 软件工程                 <span>|</span> 高等数学     <span>|</span>    <span>55</span> <span>|</span>
<span>|</span> <span>20220105</span> <span>|</span> 孙小武    <span>|</span> 飞行器设计               <span>|</span> <span>NULL</span>         <span>|</span>  <span>NULL</span> <span>|</span>
<span>|</span> <span>20220106</span> <span>|</span> 刘大彪    <span>|</span> 电子信息                 <span>|</span> <span>NULL</span>         <span>|</span>  <span>NULL</span> <span>|</span>
<span>+</span><span>----------+-----------+--------------------------+--------------+-------+</span>
<span>10</span> <span>rows</span> <span>in</span> <span>set</span> <span>(</span><span>0.00</span> sec<span>)</span>

mysql<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>从结果集中可以看出来，虽然 <code>孙小武</code> 和 <code>刘大彪</code> 并没有对应的成绩记录，但是由于采用的是连接类型为左（外）连接，所以仍然把它放到了结果集中，只不过在对应的成绩记录的各列使用了 <code>NULL</code> 值填充</p>
<h3 id="右-外-连接的语法"> 右（外）连接的语法</h3>
<h4 id="语法-2"> 语法：</h4>
<p>右（外）连接和左（外）连接的原理是一样一样的，语法也只是把 <code>LEFT</code> 换成 <code>RIGHT</code> 而已</p>
<div><pre><code><span>SELECT</span> <span>*</span> <span>FROM</span> t1 <span>RIGHT</span> <span>[</span><span>OUTER</span><span>]</span> <span>JOIN</span> t2 <span>ON</span> 连接条件 <span>[</span><span>WHERE</span> 普通过滤条件<span>]</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>只不过驱动表是右边的表，被驱动表是左边的表，具体就不重复展开了</p>
<h3 id="内连接的语法"> 内连接的语法</h3>
<p>内连接和外连接的根本区别就是在驱动表中的记录不符合 <code>ON</code> 子句中的连接条件时不会把该记录加入到最后的结果集</p>
<p>本文一开始写的连接查询都是内连接，不过之前仅仅提到了一种最简单的内连接语法，就是直接把需要连接的多个表都放到 <code>FROM</code> 子句后边</p>
<p>其实针对内连接，MySQL 提供了好多不同的语法，以 <code>t1</code> 和 <code>t2</code> 表为例：</p>
<div><pre><code><span>SELECT</span> <span>*</span> <span>FROM</span> t1 <span>[</span><span>INNER</span> <span>|</span> <span>CROSS</span><span>]</span> <span>JOIN</span> t2 <span>[</span><span>ON</span> 连接条件<span>]</span> <span>[</span><span>WHERE</span> 普通过滤条件<span>]</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>也就是说在 MySQL 中，下边这几种内连接的写法都是等价的：</p>
<ul>
<li><code>SELECT * FROM t1 JOIN t2;</code></li>
<li><code>SELECT * FROM t1 INNER JOIN t2;</code></li>
<li><code>SELECT * FROM t1 CROSS JOIN t2;</code></li>
</ul>
<p>这些写法和直接把需要连接的表名放到 <code>FROM</code> 语句之后，用逗号 <code>,</code> 分隔开的写法也是等价的：</p>
<div><pre><code> <span>SELECT</span> <span>*</span> <span>FROM</span> t1<span>,</span> t2<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>虽然有多种内连接的书写方式，不过还是推荐 <code>INNER JOIN</code> 的形式书写内连接（因为语义很明确，可以和 <code>LEFT JOIN</code> 及 <code>RIGHT JOIN</code> 很轻松地区分开）</p>
<p>由于在内连接中 <code>ON</code> 子句和 <code>WHERE</code> 子句是等价的，所以内连接中不强制要求写明 <code>ON</code> 子句</p>
<h2 id="总结"> 总结</h2>
<p>连接的本质就是把各个连接表中的记录都取出来，将依次匹配的组合加入结果集并返回给用户。不论哪个表作为驱动表，两表连接产生的结果集数量肯定是一样的</p>
<p>而对于内连接来说，由于凡是不符合 <code>ON</code> 子句或 <code>WHERE</code> 子句中的条件的记录都会被过滤掉，其实也就相当于从两表连接的结果集中把不符合过滤条件的记录给踢出去，所以对于内连接来说，驱动表和被驱动表是可以互换的，并不会影响最后的查询结果</p>
<p>但是对于外连接来说，由于驱动表中的记录即使在被驱动表中找不到符合 <code>ON</code> 子句连接条件的记录也会被加入结果集，所以此时驱动表和被驱动表的关系就很重要了，也就是说左外连接和右外连接的驱动表和被驱动表不能轻易互换</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">MySQL 的安装与卸载</title>
    <id>https://www.snowji.cn/databases/mysql/installation-of-mysql/</id>
    <link href="https://www.snowji.cn/databases/mysql/installation-of-mysql/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="mysql-的安装与卸载"> MySQL 的安装与卸载</h1>
<h2 id="windows-下安装"> Windows 下安装</h2>
<blockquote>
<p>Windows 下的 MySQL 不能用于生产，一般用于开发目的或者尝鲜体验</p>
</blockquote>
<h3 id="安装-mysql"> 安装 MySQL</h3>
<p>我比较喜欢免安装版本的，轻便干净，删起来方便</p>
<p>到官网的开发者专区下载 MySQL（Community版）免安装软件包：</p>
<ul>
<li><a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener noreferrer">下载地址</a></li>
<li>安装包名字：mysql-8.0.28-winx64.zip</li>
</ul>
<blockquote>
<p>当前最新版本是 8.0，如果需要下载其它版本，可以点击页面中的 <strong>Looking for previous GA versions?</strong>（网站可能会更新，未来入口也许会变化）</p>
</blockquote>
<h3 id="解压压缩包"> 解压压缩包</h3>
<p>将下载的软件包解压并重命名到 <code>D:\mysql-8.0</code> 目录下</p>
<div><pre><code>├── mysql-8.0
    │── bin
    │── docs
    │── include
    │── lib
    │── share
    │── LICENSE
    └── README
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="进入命令行终端"> 进入命令行终端</h3>
<p>以 Window10 为例，有两种方法能以管理员身份运行 CMD 命令提示符：</p>
<ul>
<li>在<strong>开始菜单</strong>上，单击<strong>鼠标右键</strong>，在出现的菜单中，选择**命令提示符（管理员）**点击打开这样即可</li>
<li>点击开始菜单，在 <strong>Windows 系统</strong>中找到<strong>命令提示符</strong>，然后这时候在命令提示符上单击鼠标右键，选择<strong>以管理员身份打开命令提示符</strong></li>
</ul>
<p>进入终端后，在终端中依次输入如下指令：</p>
<div><pre><code>d:
<span>cd</span> D:<span>\</span>mysql-8.0<span>\</span>bin
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="初始化-mysql"> 初始化 MySQL</h3>
<p>初始化可以选择带有随机密码或无密码，建议采用无密码初始化（可以设置密码），以免随机密码丢失</p>
<div><pre><code><span># 随机密码</span>
.<span>\</span>mysqld --initialize

<span># 无密码</span>
.<span>\</span>mysqld --initialize-insecure
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>执行完初始化命令后，可以发现解压路径下多了一个 <code>data</code> 的文件夹，在里面找到 <code>计算机名.err</code> 的文件，并打开。如果你设置了随机密码，在里面就能找到初始密码：<code>root@localhost: (这个位置的字符串就是临时密码)</code></p>
<h3 id="安装-mysqld"> 安装 mysqld</h3>
<p>继续在当前路径下执行下列命令，安装 Windows 服务：</p>
<div><pre><code>.<span>\</span>mysqld -install
</code></pre>
<div><span>1</span><br></div></div><p>PS：<code>mysql</code> 用于执行 SQL 命令，<code>mysqld</code> 用于执行数据库命令：</p>
<h3 id="启动-mysql-服务"> 启动 MySQL 服务</h3>
<p>安装提示 success 后，可以准备启动数据库并连接了</p>
<div><pre><code><span># 启动数据库</span>
net start mysql

<span># 使用 root 连接数据库，没有密码的话直接回车即可</span>
.<span>\</span>mysql -u root -p

<span># 关闭数据库</span>
net stop mysql
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="添加-修改-root-账号登录密码"> 添加/修改 root 账号登录密码</h3>
<p>启动数据库并登录 MySQL：</p>
<div><pre><code>net start mysql
.<span>\</span>mysql -u root -p
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>查询用户密码，可以看到，root 用户的密码是空的：</p>
<div><pre><code><span>select</span> host,user,authentication_string from mysql.user<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>修改 root 用户的密码，执行命令：</p>
<div><pre><code>ALTER <span>USER</span> <span>'root'</span>@<span>'localhost'</span> IDENTIFIED WITH mysql_native_password BY <span>'123456'</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>这里的密码就随意填写，生产环境不建议使用过于简单的 <code>123456</code>、<code>root</code>、<code>admin</code> 之类的密码。该命令执行完毕会得到结果：<code>Query OK, 0 rows affected (0.01 sec)</code></p>
<p>接着需要继续执行命令：</p>
<div><pre><code>flush privileges<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>该命令作用是刷新 MySQL 的系统权限相关表，这样才能使刚刚的密码修改成功</p>
<p>每次 MySQL 新设置用户或更改密码后都需要用 <code>flush privileges;</code> 来刷新 MySQL 的系统权限相关表，否则会出现拒绝访问。还有一种方法，就是重新启动 MySQL 服务，来使新设置生效</p>
<p>退出登录，并重新登录，此时必须使用刚才添加的密码才能登录 MySQL：</p>
<div><pre><code><span># 退出登录</span>
quit

<span># 重新登录</span>
.<span>\</span>mysql -u root -p
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="卸载-mysql"> 卸载 MySQL</h3>
<p>同样是以管理员身份运行命名提示符，先停止服务，然后执行卸载命令卸载：</p>
<div><pre><code>net stop mysql
.<span>\</span>mysqld --remove mysql
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="centos-7-6-下安装"> CentOS 7.6 下安装</h2>
<h3 id="安装对比"> 安装对比</h3>
<p>MySQL 有两种安装方式：</p>
<ul>
<li>yum 安装：安装过程人为无法干预，不能按需安装。rpm 包里面有什么就安装什么，安装的版本也比较低</li>
<li>源码包安装：分为编译安装和免编译安装：可以设定参数，按照需求进行安装，并且安装的版本，可以自己选择，灵活性比较大</li>
</ul>
<p>这里我们采用源码包 - 免编译的方式安装 MySQL</p>
<h3 id="下载并解压安装包"> 下载并解压安装包</h3>
<p>MySQL 源码包下载地址：<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener noreferrer">https://dev.mysql.com/downloads/mysql/</a></p>
<p>CentOS 是基于红帽的，因此操作系统选择 Red Hat，OS 版本选择 Linux 7 (x86, 64-bit)</p>
<p>选择 <strong>Compressed TAR Archive</strong> 点击 Download，获取到下载链接如下：</p>
<div><pre><code>https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.28-el7-x86_64.tar.gz
</code></pre>
<div><span>1</span><br></div></div><p>登录服务器，切换到 <code>/opt</code> 目录并新建一个 <code>mysql</code> 文件夹，下载 MySQL 安装包（如果下载慢的话，可以在本地下载后传到服务器）：</p>
<div><pre><code><span># 切换目录</span>
<span>cd</span> /opt
<span># 新建一个文件夹用于放 mysql</span>
<span>mkdir</span> mysql
<span># 切换目录</span>
<span>cd</span> mysql/
<span># 下载安装包</span>
<span>wget</span> https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.28-el7-x86_64.tar.gz
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>解压并重命名：</p>
<div><pre><code><span># 解压</span>
<span>tar</span> -zxvf mysql-8.0.28-el7-x86_64.tar.gz
<span># 重命名，原来的名字太长了</span>
<span>mv</span> ./mysql-8.0.28-el7-x86_64 mysql-8.0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="创建数据文件夹以及用户并赋予权限"> 创建数据文件夹以及用户并赋予权限</h3>
<p>以下步骤需要在 <code>/opt/mysql/</code> 目录下执行</p>
<p>创建数据文件夹：</p>
<div><pre><code><span># 创建 data 目录（用于放置 mysql 数据文件）</span>
<span>mkdir</span> data
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>创建用户组，并授权操作：</p>
<div><pre><code><span># 为 MySQL 创建一个不能 ssh 登陆的用户，且不创建用户主目录</span>
<span>useradd</span> mysql -s /sbin/nologin -M
<span># 修改文件所有者</span>
<span>chown</span> -R mysql:mysql /opt/mysql/
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>
<p>在 useradd 命令后跟了两个参数，它们分别表示：</p>
<ul>
<li>-s：表示指定用户所用的 shell，此处为 <code>/sbin/nologin</code>，表示不登录</li>
<li>-M：表示不创建用户主目录</li>
</ul>
</blockquote>
<h3 id="初始化数据库"> 初始化数据库</h3>
<p>以下步骤需要在 <code>/opt/mysql/</code> 目录下执行。</p>
<p>初始化数据库：</p>
<div><pre><code>/opt/mysql/mysql-8.0/bin/mysqld --initialize --user<span>=</span>mysql --basedir<span>=</span>/opt/mysql/mysql-8.0/ --datadir<span>=</span>/opt/mysql/data/ --lower_case_table_names<span>=</span><span>1</span>
</code></pre>
<div><span>1</span><br></div></div><blockquote>
<p>MySQL 8.0 后，在 Linux 端，对于 <code>lower_case_table_names</code> 参数，只又在初始化的时候设置才有效，若初始化的时候没设置，后面修改配置文件后再启动服务就会报错了</p>
</blockquote>
<p>在这行命令的输出中，这里我们会看到初始密码（应该实在最后一行），记下来：</p>
<div><pre><code>A temporary password is generated <span>for</span> root@localhost: <span>(</span>这个位置的字符串就是临时密码<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="创建-mysql-配置文件-my-cnf"> 创建 MySQL 配置文件 my.cnf</h3>
<p>通过阅读 <code>support-files/mysql.server</code> 这个脚本知道，如果我们的 MySQL 不是安装在默认的 <code>/usr/local/mysql</code> 里，就需要新建一个 <code>/etc/my.cnf</code> 文件，在 <code>[mysqld]</code> 段中设置 <code>basedir</code> 参数</p>
<p>新建文本文档 <code>my.cnf</code>：</p>
<div><pre><code><span># 该配置文件必须建立在该目录下</span>
<span>vim</span> /etc/my.cnf
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>将下面的内容添加到该配置文件中（此处是学习用的配置示例，生产环境需要根据实际情况定制，详细参数<a href="https://dev.mysql.com/doc/refman/8.0/en/server-configuration-defaults.html" target="_blank" rel="noopener noreferrer">见官网</a>）：</p>
<div><pre><code>[mysqld]
# mysql 服务的唯一编号，每个 mysql 服务 id 需唯一
server-id=1

# mysql 服务端口号，默认 3306
port=3306

# mysql 安装目录，默认 /usr
basedir=/opt/mysql/mysql-8.0

# mysql 数据文件放置位置
datadir=/opt/mysql/data

# 记录的是当前 mysqld 进程的 pid
pid-file=/opt/mysql/mysql-8.0/mysql.pid

# 设置 socket 文件所在目录
socket=/opt/mysql/mysql-8.0/mysql.sock

# 设置用来保存临时文件的目录
tmpdir=/opt/mysql/mysql-8.0/tmp

# 用户
user=mysql

# 允许访问的 IP 网段（系统默认配置监听所有网卡，即允许所有 IP 访问）
# 生产环境下建议设置为：127.0.0.1（只允许本机访问）或某个网卡的 IP
bind-address=0.0.0.0

# 数据库默认字符集为 utf8，并支持一些特殊表情符号（占用 4 个字节）
character-set-server=utf8mb4

# 数据库字符集对应一些排序等规则，注意要和 character-set-server 对应
collation-server=utf8mb4_general_ci

# 是否对 sql 语句大小写敏感，1 表示不敏感
lower_case_table_names=1

# 允许最大连接进程数
max_connections=400

# 最大错误连接数，这是为了防止有人从该主机试图攻击数据库系统
# 如果某个用户发起的连接 error 超过该数值，则该用户的下次连接将被阻塞，直到管理员执行 flush hosts
max_connect_errors=100

# TIMESTAMP 如果没有显示声明 NOT NULL，允许 NULL 值
explicit_defaults_for_timestamp=true

# SQL 数据包发送的大小，如果有 BLOB 对象建议修改成 1G
max_allowed_packet=128M

# MySQL连接闲置超过一定时间后（秒）将会被强行关闭
# MySQL 默认的 wait_timeout 值为 8 个小时，interactive_timeout 参数需要同时配置才能生效
interactive_timeout=1800
wait_timeout=1800

# 内部内存临时表的最大值，设置成 128M
# 比如大数据量的 group by，order by 时可能用到临时表
# 超过了这个值将写入磁盘，系统 IO 压力增大
tmp_table_size=128M
max_heap_table_size=128M

# 数据库错误日志文件
log-error=/opt/mysql/mysql-8.0/err/mysqld.err

# 数据库日志文件存放的位置（一般不会开启该功能，因为 log 的量会非常庞大）
general_log_file=/opt/mysql/mysql-8.0/log/mysql.log
# 日志文件是否开启(0 是关闭、1 是开启)
general_log=0

[client]
# 默认路径是在 /tmp/mysql.sock
# 因为我们修改了默认的路径，所以需要在 [client] 段再指定一下
# 如果不指定，虽然数据库能正常启动，但使用 mysql 命令时还是会报找不到 mysql.sock 错误
socket=/opt/mysql/mysql-8.0/mysql.sock
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br></div></div><p>创建配置文件中所需的目录：</p>
<div><pre><code><span>mkdir</span> /opt/mysql/mysql-8.0/err /opt/mysql/mysql-8.0/tmp
<span>echo</span> <span>""</span> <span>></span> /opt/mysql/mysql-8.0/err/mysqld.err
<span># 新建了文件，需要再次修改文件所有者</span>
<span>chown</span> -R mysql:mysql /opt/mysql/
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="配置全局环境变量"> 配置全局环境变量</h3>
<p>MySQL 命令默认读取的是 <code>/usr/local/bin</code> 目录，由于我们修改了 MySQL 的默认安装路径。为了可直接使用 <code>mysql</code> 命令，而不用 <code>/opt/mysql/mysql-8.0/bin/mysql</code> 这样一大串，可以添加环境变量：</p>
<div><pre><code><span>vim</span> /etc/profile
</code></pre>
<div><span>1</span><br></div></div><p>在最下面添加这两行代码：</p>
<div><pre><code># MySQL
export PATH=$PATH:/opt/mysql/mysql-8.0/bin
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>保存文件后，执行刷新操作：</p>
<div><pre><code><span>source</span> /etc/profile
</code></pre>
<div><span>1</span><br></div></div><h3 id="启动-mysql-服务并修改密码"> 启动 MySQL 服务并修改密码</h3>
<div><pre><code><span># 启动 MySQL 服务</span>
/opt/mysql/mysql-8.0/support-files/mysql.server start

<span># 登录 root 用户，记得输入之前默认生成的密码</span>
mysql -uroot -p
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>通过下面这句代码就可直接修改密码，不用像之前的老版本一样那么复杂：</p>
<div><pre><code><span># 注意跟 5.7 版本的改密命令不同</span>
ALTER <span>USER</span> <span>'root'</span>@<span>'localhost'</span> IDENTIFIED WITH mysql_native_password BY <span>'新密码'</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>接着需要继续执行命令：</p>
<div><pre><code><span># 刷新权限</span>
flush privileges<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="开机自启配置"> 开机自启配置</h3>
<p>下面的命令是将服务文件拷贝到 <code>/etc/init.d/</code> 下，并重命名为 <code>mysqld</code>：</p>
<div><pre><code><span>cp</span> /opt/mysql/mysql-8.0/support-files/mysql.server /etc/init.d/mysqld
</code></pre>
<div><span>1</span><br></div></div><p>赋予可执行权限：</p>
<div><pre><code><span>chmod</span> +x /etc/init.d/mysqld
</code></pre>
<div><span>1</span><br></div></div><p>添加服务：</p>
<div><pre><code><span>chkconfig</span> --add mysqld
</code></pre>
<div><span>1</span><br></div></div><p>显示服务列表：</p>
<div><pre><code><span>chkconfig</span> --list
</code></pre>
<div><span>1</span><br></div></div><p>注：如果看到 mysqld 的服务，并且 3，4，5 都是 <code>on</code> 的话则成功，如果是 <code>off</code>，则：</p>
<div><pre><code><span>chkconfig</span> --level <span>345</span> mysqld on
</code></pre>
<div><span>1</span><br></div></div><p>测试开机自启，重启电脑：</p>
<div><pre><code><span>reboot</span>
<span># 重启后查看 mysql 服务是否开机自启</span>
<span>ps</span> -ef <span>|</span> <span>grep</span> mysql
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>接下来可以通过一些命令操作 MySQL 服务：</p>
<ul>
<li>启动 MySQL 服务：<code>service mysql start</code></li>
<li>停止 MySQL 服务：<code>service mysql stop</code></li>
<li>查看错误日志（如果上面两个命令执行后没效果）：<code>systemctl status mysqld</code></li>
</ul>
<h3 id="开放远程连接"> 开放远程连接</h3>
<p>先通过 <code>mysql -uroot -p</code> 命令连接 MySQL，然后在 MySQL 窗口下执行如下命令：</p>
<div><pre><code><span># 选择 mysql 这个数据库</span>
use mysql<span>;</span>
<span># 查看原来数据，方便修改以后重置回来</span>
<span>select</span> host, user, authentication_string, plugin from user<span>;</span>
<span># 修改值</span>
update user <span>set</span> <span>host</span><span>=</span><span>'%'</span> where <span>user</span><span>=</span><span>'root'</span> limit <span>1</span><span>;</span>
<span># 刷新权限</span>
flush privileges<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>
<ul>
<li><code>host='%'</code> 指的是允许访问 MySQL 的 IP，默认是 <code>localhost</code> 或 <code>127.0.0.1</code>，可以指定具体的某个 IP，也可以是 <code>%</code>（所有 IP 均可访问)</li>
<li><code>user='root'</code> 表示用于访问 MySQL 的用户名，可以改为你自己定义的用户名</li>
</ul>
</blockquote>
<p>如果使用 Navicat 连接时报 <code>2003 - Can't connect to MySQL server on ...</code> 错误，就要先看下服务器是不是开启了防火墙但又没开放端口（你可以选择不开防火墙，或者开完防火墙后记得开放 MySQL 监听的端口号）</p>
<div><pre><code><span># 查看状态，发现当前是 dead 状态，即防火墙未开启</span>
systemctl status firewalld

<span># 开启防火墙，没有任何提示即开启成功</span>
<span># 再次查看状态，显示 running 即已开启了</span>
systemctl start firewalld

<span># 开放默认端口号 3306，提示 success，表示设置成功</span>
firewall-cmd --permanent --zone<span>=</span>public --add-port<span>=</span><span>3306</span>/tcp

<span># 修改后需要重新加载配置才生效</span>
firewall-cmd --reload<span>;</span>

<span># 查看已经开放的端口</span>
firewall-cmd --permanent --list-port

<span># 关闭默认的端口号 3306（如果需要的话，执行这个命令就行了）</span>
firewall-cmd --permanent --zone<span>=</span>public --remove-port<span>=</span><span>3306</span>/tcp

<span># 关闭防火墙（如果需要的话，执行这个命令就行了）</span>
systemctl stop firewalld
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>另外，如果使用的是阿里云等云厂家的服务器，无法连接的原因可能是需要去云管理平台进行一些设置。大致的入口是：</p>
<p>进入云服务管理控制平台 ——&gt; 进入云服务器 ——&gt; 选择实例 ——&gt; 管理</p>
<ul>
<li>阿里云就找到：本实例安全组 --&gt; 配置规则 --&gt; 添加安全组规则，端口范围写 <code>3306/3306</code>，授权对象写 <code>0.0.0.0/0</code></li>
<li>腾讯云就找到：防火墙 --&gt; 管理规则 --&gt; 添加规则，应用类型下拉框选择 MySQL(3306) 就可以了</li>
<li>如果改了 MySQL 的默认端口，或者想进行更多限制，或者是别的云服务商，稍微摸索下即可，这个没多少坑</li>
</ul>
<h3 id="卸载-mysql-2"> 卸载 MySQL</h3>
<p>首先输入命令 <code>ps -ef | grep mysql</code> 检查一下 MySQL 服务是否在运行，在卸载之前需要先停止服务：</p>
<div><pre><code><span>service</span> mysql stop
</code></pre>
<div><span>1</span><br></div></div><p>关闭并删除自启动脚本：</p>
<div><pre><code><span>cd</span> /etc/init.d
<span># 查看该服务进程状态</span>
<span>chkconfig</span> --list mysqld
<span># 删除 chkconfig 管理的 MySQL 启动服务</span>
<span>chkconfig</span> --del /etc/init.d/mysqld
<span># 删除自启动脚本</span>
<span>rm</span> -rf /etc/init.d/mysqld
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>删除 MySQL 安装目录（如果是按照我上文的步骤安装，删除安装目录的命令如下）：</p>
<div><pre><code><span>rm</span> -rf /opt/mysql/
</code></pre>
<div><span>1</span><br></div></div><p>删除 MySQL 配置文件：</p>
<div><pre><code><span>rm</span> /etc/my.cnf
</code></pre>
<div><span>1</span><br></div></div><p>删除环境变量：</p>
<div><pre><code><span>vim</span> /etc/profile
</code></pre>
<div><span>1</span><br></div></div><p>删掉之前添加的 MySQL 相关的代码后，保存文件后，执行刷新操作：</p>
<div><pre><code><span>source</span> /etc/profile
</code></pre>
<div><span>1</span><br></div></div><p>find 查找相关文件并删除：</p>
<div><pre><code><span># 查找相关文件</span>
<span>find</span> / -name mysql

<span># 判断是否能删除后，执行删除命令</span>
<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>删除 mysql 用户和用户组：</p>
<div><pre><code><span>id</span> mysql
<span>userdel</span> -rf mysql
<span>groupdel</span> mysql
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><blockquote>
<p>注意：<code>-rf</code> 参数表示删除当前已登陆的用户，并删除与其相关的所有文件</p>
<p>慎用 <code>-r</code> 选项，如果用户目录下有重要文件，删除前请备份</p>
</blockquote>
<h2 id="参考资料"> 参考资料</h2>
<ul>
<li><a href="https://blog.51cto.com/luecsc/1953842" target="_blank" rel="noopener noreferrer">那些你不知道的MySQL配置文件的坑</a></li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">索引结构</title>
    <id>https://www.snowji.cn/databases/mysql/index-principle/</id>
    <link href="https://www.snowji.cn/databases/mysql/index-principle/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="索引结构"> 索引结构</h1>
<p>先来看个例子：</p>
<div><pre><code># 建表
create table t_emp(id int primary key,name varchar(20),age int);

# 插入数据
insert into t_emp values(5,&#39;d&#39;,22);
insert into t_emp values(6,&#39;d&#39;,23);
insert into t_emp values(4,&#39;e&#39;,25);
insert into t_emp values(1,&#39;a&#39;,24);
insert into t_emp values(2,&#39;b&#39;,26);
insert into t_emp values(3,&#39;f&#39;,22);

# 查询数据
select * from t_emp
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>查询结果中发现，数据根据主键索引排序了</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>a</td>
<td>24</td>
</tr>
<tr>
<td>2</td>
<td>b</td>
<td>26</td>
</tr>
<tr>
<td>3</td>
<td>f</td>
<td>22</td>
</tr>
<tr>
<td>4</td>
<td>e</td>
<td>25</td>
</tr>
<tr>
<td>5</td>
<td>d</td>
<td>22</td>
</tr>
<tr>
<td>6</td>
<td>d</td>
<td>23</td>
</tr>
</tbody>
</table>
<p><strong>排序的目的</strong>：为了快速查询</p>
<h2 id="索引原理"> 索引原理</h2>
<p>根据上面的例子，数据的存储结构图：</p>
<p><img src="./images/index1.png" alt="index" /></p>
<p><strong>优点</strong>：</p>
<ul>
<li>每一块都含有 id、数据、指针(磁盘地址信息)</li>
<li>根据指针将数据按顺序链接起来</li>
<li>查询数据的时候就比较快</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>如果在数据量特别大的时候，比如查询第 1w 条数据，那就要查询 1w 次</li>
<li>排序链表的时间复杂度(On)非常大</li>
</ul>
<p>针对上面的缺点，MySQL 进行了优化，基于<strong>页的管理</strong>：</p>
<p><img src="./images/index2.png" alt="index" /></p>
<ul>
<li>将链表进行分页管理，InnoDB 中默认每页存储 16KB</li>
<li>生成页目录管理</li>
<li>页目录中存储每一页的第一个 id 值和指针</li>
<li>页目录中的指针指向每一页的数据</li>
<li>进行数据匹配时，会先在页目录中匹配在哪页，然后去相应的页中匹配数据</li>
<li>页目录中也是页，每一页也是 16KB，如果数据太多，也可以分页向上在来一层</li>
</ul>
<p>这种多层级的由上而下的就是 <strong>B+树</strong></p>
<div><p>注意</p>
<ul>
<li>一般 MySQL 的树 2~4 层</li>
<li>如果达到三层，就能存储 10亿 左右的数据</li>
</ul>
</div>
<p>我们可以算下上面 t_emp 的数据量：</p>
<p>int 类型：4 个字节</p>
<p>vachar 类型：20 个字节</p>
<p>指针：4~8 个字节</p>
<p>一条数据的字节数：4+20+4+8=36</p>
<p>一页的数据条数：16KB * 1024 / 36 = 455</p>
<p>页目录中的一页的页数：16KB * 1024 / 12 = 1368</p>
<p>一页的数据量：1368 * 455 = 622440</p>
<h2 id="b-树"> B+树</h2>
<p><strong>B+树</strong>：</p>
<ul>
<li>B+树是在 B树的基础上的一种优化</li>
<li>只有叶子节点才存储数据，非叶子节点不存储数据，减少树的深度</li>
</ul>
<p><strong>B树</strong>：</p>
<ul>
<li>无论是叶子还是非叶子节点都存储数据</li>
<li>页目录上存储数据后会使得页数变少，同样的数据量会使得树的深度更深</li>
</ul>
<div><p>重点</p>
<ul>
<li>MySQL 会将树根常驻内存，加快查询速度</li>
<li>查找某一键值的行记录时最多只需要 1~3 次 I/O 操作</li>
<li>非聚簇索引(非主键索引)在查询数据时，会先根据索引查相应数据的 id ，然后再根据主键索引查询
<ul>
<li>比如根据 name 索引查询数据，会先在 name 索引结构中查询到相应列在索引中的 id</li>
<li>根据 id 去主键索引中查询，相应的数据</li>
</ul>
</li>
<li>主键索引使用 int 类型的原因就是 int 类型能排序</li>
</ul>
</div>
<h2 id="参考文档"> 参考文档</h2>
<p><a href="https://www.bilibili.com/video/BV19y4y127h4?p=2" target="_blank" rel="noopener noreferrer">索引结构</a>)</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">MySQL 数据库设计规范</title>
    <id>https://www.snowji.cn/databases/mysql/db-design-spec/</id>
    <link href="https://www.snowji.cn/databases/mysql/db-design-spec/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="mysql-数据库设计规范"> MySQL 数据库设计规范</h1>
<p>一个平台或系统随着时间的推移和用户量的增多，数据库操作往往会变慢。而在服务端开发中数据库更是尤为重要，绝大多数情况下数据库的性能决定了程序的性能，如若前期埋下的坑越多到后期数据库就会成为整个系统的瓶颈。因此，更规范化地使用 MySQL 在开发中是不可或缺的</p>
<h2 id="数据库命名规范"> 数据库命名规范</h2>
<ul>
<li>数据库所有表前缀均使用系统或模块的英文名称缩写</li>
<li>库名、表名、字段名必须使用小写字母并采用下划线分割</li>
<li>库名、表名、字段名禁止超过 32 个字符，须见名知意</li>
<li>库名、表名、字段名支持最多 64 个字符，统一规范、易于辨识以及减少传输量不要超过 32</li>
<li>库名、表名、字段名禁止使用 MySQL 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）</li>
<li>临时库、临时表名必须以系统或模块的英文名称缩写 + <code>_tmp_</code> 为前缀并以日期为后缀，例如（<code>pro_tmp_20220302</code>）</li>
<li>备份库、备份表名必须以系统或模块的英文名称缩写 + <code>_bak_</code> 为前缀并以日期为后缀，例如（<code>pro_bak_20220302</code>）</li>
<li>所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）</li>
</ul>
<h2 id="基本设计规范"> 基本设计规范</h2>
<h4 id="_1-若无特殊说明-建表时一律采用-innodb-存储引擎"> 1）若无特殊说明，建表时一律采用 InnoDB 存储引擎</h4>
<p>选择合适的引擎可以提高数据库性能，如 InnoDB 和 MyISAM，InnoDB 和 MyISAM 是许多人在使用 MySQL 时最常用的两个表类型，这两个表类型各有优劣，视具体应用而定；基本的差别为：MyISAM 类型不支持事务处理等高级处理，而 InnoDB 类型支持；MyISAM 类型的表强调的是性能，其执行数度比 InnoDB 类型更快，但是不提供事务支持，而 InnoDB 提供事务支持以及外部键等高级数据库功能；因此，其支持事务处理、支持外键、支持崩溃修复能力和并发控制是我们建表时首选的存储引擎</p>
<h4 id="_2-数据库和表的字符集统一使用-utf8mb4-5-5-3-版本以上支持"> 2）数据库和表的字符集统一使用 <code>utf8mb4</code>（5.5.3 版本以上支持）</h4>
<p>数据库和表的字符集统一使用 utf8，若是有字段需要存储 emoji 表情之类的，则将表或字段设置成 <code>utf8mb4</code>；因为，utf8 号称万国码，其无需转码、无乱码风险且节省空间，而 utf8mb4 又向下兼容 utf8</p>
<h4 id="_3-设计数据库时所有表和字段必须添加注释"> 3）设计数据库时所有表和字段必须添加注释</h4>
<p>使用 comment 从句添加表和列的备注，或直接在数据库连接工具的注释栏添加注释，从项目开始就进行数据字典的维护</p>
<p>使用 comment 从句添加注释如：</p>
<div><pre><code><span># 创建表</span>
CREATE TABLE t1<span>(</span>id varchar2<span>(</span><span>32</span><span>)</span> primary key,name VARCHAR2<span>(</span><span>8</span><span>)</span> NOT NULL,age number<span>)</span><span>;</span>
<span># 添加表注释</span>
comment on table t1 is <span>'个人信息'</span><span>;</span>
<span># 添加字段注释：</span>
comment on <span>column</span> t1.id is <span>'id'</span><span>;</span>
comment on <span>column</span> t1.nameis <span>'姓名'</span><span>;</span>
comment on <span>column</span> t1.age is <span>'年龄'</span><span>;</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>也可以使用可视化的数据库连接工具添加注释</p>
<h4 id="_4-单个表的数据量大小控制在500万以内"> 4）单个表的数据量大小控制在500万以内</h4>
<p>尽量控制单表数据量的大小，建议控制在500万以内。500万并不是 MySQL 数据库的极限，但数据量太多不利于对表结构进行修改、备份和恢复数据</p>
<p>可以适当采用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制单表数据量的大小</p>
<h4 id="_5-谨慎使用-mysql-分区表"> 5）谨慎使用 MySQL 分区表</h4>
<p>业务生命周期内，评估单表数据量是否在500万以内，超出此范围需考虑分库分表可扩展性</p>
<p>分区是将一个表的数据按照某种方式，比如按照时间上的月份，分成多个较小的，更容易管理的部分，但是逻辑上仍是一个表。分区表在物理上表现为多个文件，在逻辑上仍表现为同一个表，需要谨慎选择分区键。跨分区查询效率可能会更低，建议使用物理分区表等方式管理大数据</p>
<h4 id="_6-尽量做到冷热数据分离-减小表的宽度"> 6）尽量做到冷热数据分离，减小表的宽度</h4>
<p>MySQL 限制每个表最多存储 4096 列，并且每一行数据的大小不超过 65535 字节，为了减少磁盘 IO 线程的开销，就要适当控制表的宽度，因为表越宽，把表装载进内存缓冲池时所占用的内存也就越大，就会消耗更多的 IO 线程。除此之外，为了保证热数据的内存缓存命中率，更有效的利用缓存，避免读入无用的冷数据，尽量把经常使用到的列放到同一个表中，避免不必要的关联操作</p>
<h4 id="_7-建立预留字段需谨慎"> 7）建立预留字段需谨慎</h4>
<p>部分开发者在设计数据库表时，不仅设计了当前所需要的字段，而且还在其中留出几个字段作为备用。比方说，我设计了一个人员表（person），其中已经添加了各种必要的字段，包括姓名（Name）、性别（Sex）、出生年月日（birthday）等等；为了以防万一，比如之后可能 Person 表会涉及到毕业院校、工作单位、是否婚配和相片等信息，于是就加入 5 个 varchar2 型的字段，分别叫做 text1、text2……text5</p>
<p>这一手操作看似防范于未然，其实也并不见得，因为大量预留字段会浪费空间、预留字段不能做到见名知意、预留字段无法确认存储的数据类型且修改其字段类型还可能会造成锁表等问题</p>
<p>针对此等情况可以参考以下两点解决方案：</p>
<ul>
<li>如果数量很少，而且信息的性质与原表密切相关，那么就可以直接在原表上增加字段，并将相关的数据更新进去</li>
<li>如果数量较大，或者并非是原表对象至关重要的属性，那么就可以新增一个表，然后通过键值连接起来</li>
</ul>
<h4 id="_8-数据库中禁止存储图片、文件等大的二进制数据"> 8）数据库中禁止存储图片、文件等大的二进制数据</h4>
<p>若往数据库表中存储文件，而文件通常很大，当数据库进行读取操作时，会进行大量的随机 IO 操作，大文件使得 IO 操作很耗时耗性能，造成短时间内数据量快速增长。所以，通常将图片、文件存储在文件服务器中，数据库只用于存储文件地址信息</p>
<h4 id="_9-禁止在线上做数据库压力测试"> 9）禁止在线上做数据库压力测试</h4>
<h4 id="_10-禁止从开发环境-测试环境直接连接生成环境数据库"> 10）禁止从开发环境，测试环境直接连接生成环境数据库</h4>
<h2 id="数据库字段设计规范"> 数据库字段设计规范</h2>
<h4 id="_1-优先选择符合存储需要的最小的数据类型"> 1）优先选择符合存储需要的最小的数据类型</h4>
<p>主要是考虑索引的性能，因为列的字段越大，建立索引时所需要的空间也越大，这样一页中能存储的索引节点的数量也就越少，在遍历时需要的 IO 次数也就越多，索引的性能也就越差</p>
<p>建议：</p>
<ul>
<li>将字符串转换成数字类型存储，如：将 IP 地址转换成整形数据</li>
<li>对于非负型的数据（如自增 ID、整型 IP）来说，要优先使用无符号整型来存储。因为，无符号相对于有符号可以多出一倍的存储空间，VARCHAR(N) 中的 N 代表的是字符数，而不是字节数。使用 UTF8 存储 255 个汉字，Varchar(255)=765 个字节。过大的长度会消耗更多的内存</li>
</ul>
<h4 id="_2-避免使用-text、blob-数据类型"> 2）避免使用 TEXT、BLOB 数据类型</h4>
<p>最常见的 TEXT 类型可以存储 64K 数据，MySQL 内存临时表不支持 TEXT、BLOB 这样的大数据类型，若查询中包含这样的数据，在执行排序等操作时就不能使用内存临时表，必须使用磁盘临时表执行操作</p>
<p>但是不是说一定不能使用这样的数据类型，如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，查询时一定不要使用 <code>select *</code> 而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询</p>
<p>注意：出于内存和性能考虑，MySQL 对索引字段长度是有限制的。所以 TEXT 或 BLOB 类型只能使用前缀索引，并且 TEXT 列上是不能有默认值的</p>
<h4 id="_3-避免使用-enum-枚举类型"> 3）避免使用 ENUM 枚举类型</h4>
<ul>
<li>修改 ENUM 值需要使用 <code>ALTER</code> 语句</li>
<li>ENUM 类型的 <code>ORDER BY</code>操作效率低</li>
<li>禁止使用数值作为 <code>ENUM</code> 的枚举值</li>
</ul>
<h4 id="_4-尽可能把所有列定义为-not-null"> 4）尽可能把所有列定义为 NOT NULL</h4>
<ul>
<li>如果查询中包含可为 NULL 的列，对 MySQL 来说更难优化，因为可为 NULL 的列使得索引，索引统计和值比较都更复杂（在 where 子句中对字段进行 null 值判断，将导致引擎放弃使用索引而进行全表扫描）</li>
<li>含 NULL 复合索引无效</li>
<li>可为 NULL 的列会使用更多的存储空间，在 MySQL 中也需要特殊处理</li>
<li>当可为 NULL 的列被索引时，每个索引记录需要一个额外的字节，在 MyISAM 里甚至还可能导致固定大小的索引（例如只有一个整数列的索引）变成可变大小的索引</li>
</ul>
<p>通常把可为 NULL 的列改为 NOT NULL 带来的性能提升比较小，所以（调优时）没有必要首先在现有 schema 中查找并修改掉这种情况，除非确定这会导致问题。但是，如果计划在列上建索引，就应该尽量避免设计成可为 NULL 的列</p>
<h4 id="_5-使用-timestamp-4-字节-或-datetime-8-字节-类型存储时间"> 5）使用 TIMESTAMP（4 字节）或 DATETIME（8 字节）类型存储时间</h4>
<p>TIMESTAMP 存储的时间范围为：1970-01-01 00:00:01 ~ 2038-01-19-03:14:07</p>
<p>TIMESTAMP 占用 4 字节和 INT 相同，但可读性比 INT 类型的高，同时 TIMESTAMP 具有自动赋值以及自动更新的特性。若是超出 TIMESTAMP 取值范围的则使用 DATETIME 类型存储</p>
<p>用字符串类型存储时间的缺点：无法使用日期函数进行比较计算、字符串存储占有更多的空间</p>
<h4 id="_6-财务相关的金额类数据必须使用-decimal-类型"> 6）财务相关的金额类数据必须使用 DECIMAL 类型</h4>
<ul>
<li>精准浮点：DECIMAL</li>
<li>非精准浮点：FLOAT、DOUBLE</li>
</ul>
<p>DECIMAL 类型为精准浮点数，在计算时不会丢失精度。占有空间大小由定义的宽度决定，每 4 个字节可以存储 9 位数字，且小数点也要占有一个字节。另外，DECIMAL 类型可用于存储比 BIGINT 更大的数据类型</p>
<h4 id="_7-建议使用-unsigned-存储非负数值"> 7）建议使用 UNSIGNED 存储非负数值</h4>
<p>同样的字节数，非负存储的数值范围更大。如 TINYINT 有符号为 -128-127，无符号为 0-255</p>
<h4 id="_8-建议使用-int-unsigned-存储-ipv4"> 8）建议使用 INT UNSIGNED 存储 IPV4</h4>
<p>用 UNSINGED INT 存储 IP 地址占用 4 字节，CHAR(15) 则占用 15 字节。另外，计算机处理整数类型比字符串类型快。使用 INT UNSIGNED 而不是 CHAR(15) 来存储 IPV4 地址，通过 MySQL 函数 <code>inet_ntoa</code> 和 <code>inet_aton</code> 来进行转化。IPv6 地址目前没有转化函数，需要使用 DECIMAL 或两个 BIGINT 来存储</p>
<p>例如：</p>
<div><pre><code>SELECT INET_ATON<span>(</span><span>'209.207.224.40'</span><span>)</span><span>;</span> <span># 3520061480</span>
SELECT INET_NTOA<span>(</span><span>3520061480</span><span>)</span><span>;</span>       <span># 209.207.224.40</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h4 id="_9-建议使用-tinyint-来代替-enum-类型"> 9）建议使用 TINYINT 来代替 ENUM 类型</h4>
<p>ENUM 类型在需要修改或增加枚举值时，需要在线 DDL，成本较高。且 ENUM 列值如果含有数字类型，可能会引起默认值混淆</p>
<h4 id="_10-使用-varbinary-存储大小写敏感的变长字符串或二进制内容"> 10）使用 VARBINARY 存储大小写敏感的变长字符串或二进制内容</h4>
<p>VARBINARY 默认区分大小写，没有字符集概念，速度快</p>
<h4 id="_11-禁止在数据库中存储明文密码"> 11）禁止在数据库中存储明文密码</h4>
<h2 id="索引设计规范"> 索引设计规范</h2>
<p>建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少</p>
<p>索引是一把双刃剑，可提高查询效率，但也会降低插入和更新的速度并占用磁盘空间</p>
<h4 id="_1-每张表的索引数量不超过-5-个"> 1）每张表的索引数量不超过 5 个</h4>
<p>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会增加 MySQL 优化器生成执行计划时间，降低查询性能</p>
<h4 id="_2-禁止给表中的每一列都建立单独的索引"> 2）禁止给表中的每一列都建立单独的索引</h4>
<p>5.6 版本之前，一个 SQL 只能使用到一个表中的一个索引；5.6 以后，虽然有了合并索引的优化方式，但远没有使用联合索引的查询方式效率高</p>
<h4 id="_3-每个-innodb-表必须有一个主键"> 3）每个 InnoDB 表必须有一个主键</h4>
<p>InnoDB 是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的</p>
<p>每个表都可以有多个索引，但是表的存储顺序只能有一种，InnoDB 是按照主键索引的顺序来组织表的，因此不要使用更新频繁的列、UUID、MD5、HASH 和字符串列作为主键，这些列无法保证数据的顺序增长，主键建议使用自增 ID 值</p>
<h4 id="_4-使用短索引"> 4）使用短索引</h4>
<p>对字符串使用前缀索引，前缀索引长度不超过 10 个字符</p>
<p>举例：如有一个 CHAR(200) 列，在前 10 个字符内，多数值是惟一的，就可不要对整个列进行索引。只对前 10 个字符进行索引能够节省大量索引空间，也可能会使查询更快</p>
<h4 id="_5-避免冗余或重复索引"> 5）避免冗余或重复索引</h4>
<p>合理创建联合索引（避免冗余），index(a,b,c) 相当于 index(a)、index(a,b)、index(a,b,c)</p>
<ul>
<li>索引不是越多越好，按实际需要进行创建，每个额外的索引都要占用额外的磁盘空间，并降低写操作的性能。</li>
<li>不在低基数列上建立索引，例如「性别」</li>
<li>不在索引列进行数学运算和函数运算</li>
</ul>
<h4 id="_6-尽量避免使用外键约束"> 6）尽量避免使用外键约束</h4>
<ul>
<li>不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引</li>
<li>外键虽然可以保证数据的参照完整性，但外键也会影响父表和子表的写操作从而降低性能，还会使得表更耦合，建议在业务端实现</li>
</ul>
<h4 id="_7-不使用-前导的查询-如-like-xxx"> 7）不使用 <code>%</code> 前导的查询，如 <code>like &quot;%xxx&quot;</code></h4>
<p>无法使用索引</p>
<h4 id="_8-不使用反向查询-如-not-in-not-like"> 8）不使用反向查询，如 <code>not in</code> / <code>not like</code></h4>
<p>无法使用索引，导致全表扫描，全表扫描导致 bufferpool 利用降低</p>
<h4 id="_9-索引列建议"> 9）索引列建议</h4>
<p>① 出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列</p>
<p>② 包含在 ORDER BY、GROUP BY、DISTINCT 中的字段</p>
<p>③ 多表 join 的关联列</p>
<p>注意：并不要将符合 ① 和 ② 中的字段的列都建立一个索引，通常将 ①、② 中的字段建立联合索引效果更好</p>
<h4 id="_10-如何选择索引列的顺序"> 10）如何选择索引列的顺序</h4>
<ul>
<li>区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）</li>
<li>尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）</li>
<li>使用最频繁的列放到联合索引的左侧（这样可较少的建立一些索引）</li>
</ul>
<h4 id="_11-避免建立冗余索引和重复索引"> 11）避免建立冗余索引和重复索引</h4>
<p>冗余/重复索引会增加查询优化器生成执行计划的时间</p>
<ul>
<li>重复索引示例：primary key(id)、index(id)、unique index(id)</li>
<li>冗余索引示例：index(a,b,c)、index(a,b)、index(a)</li>
</ul>
<h4 id="_12-优先考虑覆盖索引"> 12）优先考虑覆盖索引</h4>
<p>对于频繁的查询优先考虑使用覆盖索引</p>
<p>覆盖索引：即包含了所有查询字段（where，select，order by，group by 包含的字段）的索引</p>
<p>覆盖索引的好处：</p>
<ul>
<li>避免 InnoDB 表进行索引的二次查询
<ul>
<li>InnoDB 是以聚集索引的顺序来存储的，对于 InnoDB 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据，在查找到相应的键值后，还需通过主键进行二次查询才能获取我们真实所需要的数据。</li>
<li>而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询，减少了 IO 操作，提升了查询效率。</li>
</ul>
</li>
<li>可以把随机 IO 变成顺序 IO 加快查询效率
<ul>
<li>由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO</li>
</ul>
</li>
</ul>
<h2 id="数据库-sql-开发规范"> 数据库 SQL 开发规范</h2>
<h4 id="_1-建议使用预编译语句进行数据库操作"> 1）建议使用预编译语句进行数据库操作</h4>
<p>预编译语句可以重复使用，相同的 SQL 语句可以一次解析，多次使用，减少 SQL 编译所需要的时间，提高处理效率；此外，还可以有效解决动态 SQL 带来的 SQL 注入问题</p>
<h4 id="_2-避免数据类型的隐式转换"> 2）避免数据类型的隐式转换</h4>
<p>隐式转换如：<code>SELECT 1 + &quot;1&quot;</code>。数值型 + 字符型 的隐式转换有可能会导致索引失效，以及一些意想不到的结果等</p>
<h4 id="_3-充分利用表中存在的索引"> 3）充分利用表中存在的索引</h4>
<ul>
<li>避免使用双 <code>%</code> 号的查询条件
<ul>
<li>如 <code>WHERE first_name like '%James%'</code>，若无前置 <code>%</code>，只有后置 <code>%</code>，则执行 SQL 语句时会用到列上的索引，双 <code>%</code> 号则不会使用列上的索引</li>
</ul>
</li>
<li>一条 SQL 语句只能使用复合索引中的一列进行范围查询
<ul>
<li>例如有 weight、age、sex 三列的联合索引，在查询条件中有 weight 列的范围查询，则在 age 和 sex 列上的索引将不会被使用。因此，在定义联合索引时，若某列需要用到范围查询，则将该列放到联合索引的右侧</li>
</ul>
</li>
<li>使用 <code>not exists</code> 代替 <code>not in</code>
<ul>
<li>因为 <code>not in</code> 在 SQL 语句中执行时会导致索引失效</li>
</ul>
</li>
</ul>
<h4 id="_4-杜绝使用-select-必须使用-select-字段列表-查询"> 4）杜绝使用 <code>SELECT *</code> ，必须使用 <code>SELECT &lt;字段列表&gt;</code> 查询</h4>
<p>因为使用 <code>SELECT *</code> 查询会消耗更多的 CPU、IO 和网络宽带资源，并且查询时无法使用覆盖索引</p>
<h4 id="_5-禁止使用不含字段列表的-insert-语句"> 5）禁止使用不含字段列表的 <code>INSERT</code> 语句</h4>
<p>如：<code>INSERT into table_name values ('1','2','3');</code></p>
<p>改为带字段列表的 INSERT 语句：<code>INSERT into table_name('c1','c2','c3') values ('1','2','3');</code></p>
<h4 id="_6-避免使用子查询-可以把子查询优化为-join-关联操作"> 6）避免使用子查询，可以把子查询优化为 <code>join</code> 关联操作</h4>
<p>但是，通常子查询在 <code>in</code> 子句中，且子查询中为简单 SQL（即不包含 <code>union</code>、<code>group by</code>、<code>order by</code>、<code>limit</code> 从句）时，才可以把子查询转化为 <code>join</code> 关联查询进行优化</p>
<p>子查询性能差的原因：</p>
<ul>
<li>子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响</li>
<li>由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。</li>
</ul>
<h4 id="_7-避免使用-join-关联太多表"> 7）避免使用 <code>JOIN</code> 关联太多表</h4>
<ul>
<li>在 MySQL 中，对于同一个 SQL 关联（join）多个表，每个 <code>join</code> 就会多分配一个关联缓存，如果在一个 SQL 中关联的表越多，所占用的内存也就越大</li>
<li>如果程序中大量的使用了多表关联的操作，同时 join_buffer_size（MySQL 允许关联缓存的个数）设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响服务器数据库性能的稳定性</li>
<li>此外，对于关联操作来说，会产生临时表影响查询效率，而 MySQL 最多允许关联 61 个表，建议不超过 5 个</li>
</ul>
<h4 id="_8-对同一列对象进行-or-判断时-使用-in-替代-or"> 8）对同一列对象进行 <code>or</code> 判断时，使用 <code>in</code> 替代 <code>or</code></h4>
<p><code>in</code> 的值只要涉及不超过 500 个，则 <code>in</code> 操作可以更有效的利用索引，<code>or</code> 大多数情况下很少能利用到索引</p>
<h4 id="_9-禁止使用-order-by-rand-进行随机排序"> 9）禁止使用 <code>order by rand()</code> 进行随机排序</h4>
<p>随机排序会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的 CPU 和 IO 及内存资源</p>
<p>简单来说：<code>order by rand()</code> 会将数据从磁盘中读取，进行排序，会消耗大量的 IO 和 CPU</p>
<p>推荐在程序中获取一个随机值，然后从数据库中获取对应的数据</p>
<h4 id="_10-禁止在-where-从句中对列进行函数转换和计算"> 10）禁止在 <code>WHERE</code> 从句中对列进行函数转换和计算</h4>
<p>因为在 <code>WHERE</code> 从句中对列进行函数转换或计算时会导致索引无法使用</p>
<div><pre><code><span># 不推荐</span>
where date<span>(</span>end_time<span>)</span><span>=</span><span>'20190101'</span>

<span># 推荐</span>
where end_time <span>>=</span> <span>'20190101'</span> and end_time <span>&lt;</span> <span>'20190102'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="_11-在明显不会有重复值时使用-union-all-而不是-union"> 11）在明显不会有重复值时使用 <code>UNION ALL</code> 而不是 <code>UNION</code></h4>
<ul>
<li><code>UNION</code> 会把两个结果集的所有数据放到临时表中后再进行去重操作</li>
<li><code>UNION ALL</code> 不会再对结果集进行去重操作</li>
</ul>
<h4 id="_12-把复杂、较长的-sql-拆分为多个小-sql-执行"> 12）把复杂、较长的 SQL 拆分为多个小 SQL 执行</h4>
<ul>
<li>大 SQL 在逻辑上比较复杂，是需要占用大量 CPU 进行计算一条 SQL 语句</li>
<li>在 MySQL 中，一条 SQL 语句只能使用一个 CPU 进行计算</li>
<li>SQL 拆分后可以通过并行执行来提高处理效率</li>
</ul>
<h4 id="_13-避免在数据库中进行数学运算"> 13）避免在数据库中进行数学运算</h4>
<ul>
<li>容易将业务逻辑和 DB 耦合在一起</li>
<li>MySQL 不擅长数学运算和逻辑判断</li>
<li>无法使用索引</li>
</ul>
<h2 id="数据库行为规范"> 数据库行为规范</h2>
<h4 id="_1-超过100万行数据的批量操作-update-delete-insert-分多次进行"> 1）超过100万行数据的批量操作（update delete insert），分多次进行</h4>
<ul>
<li>大批量操作可能回造成严重的主从延迟
<ul>
<li>主从环境中，大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，只有当主库上执行完成后，才会在其他从库上执行，会造成主库与从库长时间的延迟情况</li>
</ul>
</li>
<li>binlog 日志为 row 格式时会产生大量的日志
<ul>
<li>大批量写操作会产生大量日志，特别是对于 row 格式二进制数据而言，由于在 row 格式中会记录每一行数据的修改，一次修改的数据越多，产生的日志量也会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因</li>
</ul>
</li>
<li>避免产生大事务操作
<ul>
<li>大批量修改数据，一定是在一个事务中进行的，这会造成表中大批量数据进行锁定，导致大量的阻塞，阻塞会对 MySQL 的性能影响很大。尤其是长时间的阻塞会占满所有数据库的可用连接，会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批</li>
</ul>
</li>
</ul>
<h4 id="_2-对于大表使用-pt-online-schema-change-修改表结构"> 2）对于大表使用 pt-online-schema-change 修改表结构</h4>
<ul>
<li>可避免大表修改产生的主从延迟</li>
<li>可避免在对表字段进行修改时进行锁表</li>
</ul>
<p>生产环境中，对大表数据结构的修改一定要谨慎，会造成严重的锁表操作</p>
<blockquote>
<p>pt-online-schema-change 它首先会建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器</p>
<p>接着，把原表中新增的数据也复制到新表中，在将所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉，其实是把原来一个 DDL 操作，分解成多个小的批次执行</p>
<p>这也是对表进行碎片整理/重组的一个常用方式</p>
</blockquote>
<h4 id="_3-禁止给程序使用的账号授予-super-权限"> 3）禁止给程序使用的账号授予 super 权限</h4>
<p>原因：当 MySQL 达到最大连接数限制时，此刻还运行 1 个有super权限的用户连接，super 权限只能留给 DBA 处理问题的账号使用</p>
<h4 id="_4-对于程序连接数据库账号-遵循权限最小原则"> 4）对于程序连接数据库账号，遵循权限最小原则</h4>
<p>程序使用数据库账号只能在一个数据库下使用，不准跨库，且程序使用的账号原则上不授予 drop 权限</p>
<h4 id="_5-其他一些操作规范"> 5）其他一些操作规范</h4>
<ul>
<li>任何数据库的线上操作，必须走工单</li>
<li>禁止在主库上执行统计类的功能查询</li>
<li>有大规模市场推广、运营活动必须提前通知 DBA 进行流量评估</li>
<li>对单表的多次 alter 操作必须合并为一次操作</li>
<li>不在 MySQ L数据库中存放业务逻辑，即可创建存储过程</li>
<li>重大项目的数据库方案选型和设计必须提前通知 DBA 参与</li>
<li>数据必须有备份机制和定期的恢复演练</li>
<li>不在业务高峰期批量更新、查询数据库</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">索引</title>
    <id>https://www.snowji.cn/databases/mysql/mysql-index/</id>
    <link href="https://www.snowji.cn/databases/mysql/mysql-index/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="索引"> 索引</h1>
<h2 id="什么是索引"> 什么是索引</h2>
<p><strong>官方定义</strong>：一种帮助 MySql 提高查询速率的数据结构</p>
<p>索引：</p>
<ul>
<li>一种数据结构</li>
<li>帮助 MySql 高效获取数据的数据结构</li>
<li>存储在文件系统中</li>
<li>索引的文件存储形式与存储引擎有关</li>
<li>索引文件的结构
<ul>
<li>hash</li>
<li>二叉树</li>
<li>B 树</li>
<li>B+ 树</li>
</ul>
</li>
</ul>
<p><strong>索引的优点</strong>：</p>
<ul>
<li>大大加快查询速度</li>
</ul>
<p><strong>索引的缺点</strong>：</p>
<ul>
<li>维护索引需要耗费数据库资源</li>
<li>索引需要占用磁盘空间</li>
<li>当对表的数据进行增删改的时候，因为要维护索引，速度会受到影响</li>
</ul>
<h2 id="索引的分类"> 索引的分类</h2>
<p><strong>InnoDB</strong>：</p>
<ul>
<li>主键索引(primary key)
<ul>
<li>唯一的标识，主键不可重复，只能有一个列作为主键</li>
<li>主键索引在主键被创建的时候自动创建，InnoDB 为聚簇索引</li>
<li>索引列的值不能为空</li>
</ul>
</li>
<li>唯一索引(unique key)
<ul>
<li>避免重复的列出现，唯一索引可以重复，多个列都可以标识唯一索引</li>
<li>唯一索引列值可以为 null，但是只能存在一个 null</li>
</ul>
</li>
<li>单值(普通)索引(key/index)
只包含单个列，一个表中可以有多个单列索引</li>
<li>复合索引
一个索引包含多个列</li>
</ul>
<p><strong>MyISAM</strong>：</p>
<ul>
<li>全文索引(fulltext)
<ul>
<li>MySQL 5.7 版本之前只用于 MyISAM</li>
<li>在特定的数据库引擎下才有，MyISAM</li>
<li>快速定位数据</li>
</ul>
</li>
</ul>
<h2 id="索引的使用"> 索引的使用</h2>
<h3 id="索引的创建"> 索引的创建</h3>
<h4 id="创建表时创建"> 创建表时创建</h4>
<p><strong>语法</strong>：</p>
<div><pre><code>   create table tbl_name(字段名称 字段类型[完整性约束条件]，

    ....,

    [unique|fulltext|spatial] index|key [索引名称] (字段名称 [( 长度)] [asc|desc])

    )
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><strong>示例</strong>：</p>
<ul>
<li>创建主键索引</li>
</ul>
<div><pre><code>create table t_user(id varchar(20) primary key, name varchar(20))
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>创建单值索引</li>
</ul>
<div><pre><code>create table t_user(id varchar(20) primary key, name varchar(20),key(name))
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>创建唯一索引</li>
</ul>
<div><pre><code>create table t_user(id varchar(20) primary key, name varchar(20),age int, unique key(name))
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>创建唯一索引</li>
</ul>
<div><pre><code>create table t_user(id varchar(20) primary key, name varchar(20),age int, unique key(name))
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>创建复合索引</li>
</ul>
<div><pre><code>create table t_user(id varchar(20) primary key, name varchar(20),age int, key(name，age))
</code></pre>
<div><span>1</span><br></div></div><h4 id="在已存在的表上创建索引"> 在已存在的表上创建索引</h4>
<p><strong>语法</strong>：</p>
<div><pre><code>  create [unique|fulltext|spatial] index 索引名称 on 表名(字段名[(长度)] [asc|desc])
  
  alter table tbl_name add [unique|fulltext|spatial] index 索引名称(字段名称[(长度)] [asc|desc])

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>示例</strong>：</p>
<div><pre><code>create index name on t_user1(name)
</code></pre>
<div><span>1</span><br></div></div><div><p>重点</p>
<p>复合索引：</p>
<ul>
<li>最左前缀原则</li>
<li>MySQL 引擎在查询为了更好利用索引，在查询过程中会动态调整查询字段顺序以便利用索引</li>
</ul>
<p>比如：给一个表添加了复合索引，添加顺序为：name age bir
基于 name ：可以使用索引
基于 name age：可以使用索引
基于 name age bir：可以使用索引
基于 name bir age：可以使用索引
基于 bir age name：可以使用索引</p>
<p><strong>总结</strong>：必须要包含最左边的 name 才可以使用索引</p>
</div>
<h3 id="查询索引"> 查询索引</h3>
<div><pre><code>show index from tbl_name
</code></pre>
<div><span>1</span><br></div></div><p>全文索引查询：select * from tbl_name where match(要查询的列名) against（'查询匹配的字符'）</p>
<h3 id="删除索引"> 删除索引</h3>
<div><pre><code>  drop index 索引名称 on tbl_name

  alter table tbl_name drop index 索引名称
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="参考文档"> 参考文档</h2>
<p><a href="https://www.bilibili.com/video/BV19y4y127h4?p=1" target="_blank" rel="noopener noreferrer">MySql 索引</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">MySQL 主键和自增 ID</title>
    <id>https://www.snowji.cn/databases/mysql/primary-key-and-increment-id/</id>
    <link href="https://www.snowji.cn/databases/mysql/primary-key-and-increment-id/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="mysql-主键和自增-id"> MySQL 主键和自增 ID</h1>
<h2 id="必备的三个字段"> 必备的三个字段</h2>
<p>通常情况下，我们每个表必备三个字段：<code>id</code>，<code>create_time</code>，<code>update_time</code></p>
<p>其中 <code>id</code> 为主键，类型为 BIGINT UNSIGNED，自增、步长为 <code>1</code></p>
<p><code>create_time</code> 和 <code>update_time</code> 均为 DATETIME 类型</p>
<h2 id="为什么用自增-id-做主键"> 为什么用自增 ID 做主键</h2>
<blockquote>
<p>MySQL 官方推荐创建主键的时候尽量使用自增主键而不是使用业务生成的值当做主键 —— <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_primary_key" target="_blank" rel="noopener noreferrer">dev.mysql.com/doc/refman/…</a></p>
</blockquote>
<p>很多时候我们存储的对象自身都会有个唯一值，比如身份证号、流水单号、GUID，那为什么不直接用这些唯一值当做主键，而是要设置一个和业务无关的自增 id 用来当做主键？</p>
<p>先说答案：</p>
<ul>
<li>自增 id 可以唯一标识一行数据，在 InnoDB 构建索引树的时候会使用主键</li>
<li>自增 id 是顺序的，可以保证索引树上的数据比较紧凑，有更高的空间利用率以及减少数据页的分裂合并等操作，提高效率</li>
<li>一般使用身份证号、流水单号作为主键等并不能保证顺序性</li>
<li>流水号一般相对较长，比如 32 位，<strong>过长的话二级索引占用空间较多</strong></li>
</ul>
<p>这里涉及到几个知识点：索引、索引树、二级索引。仅介绍针对 InnoDB 引擎进行介绍（现在一般都是用这种引擎）：</p>
<h3 id="索引分类"> 索引分类</h3>
<p>索引有两种：</p>
<ul>
<li>聚簇索引：表存储是根据主键列的值组织的，以加快涉及主键列的查询和排序</li>
<li>二级索引：也可以叫辅助索引，在辅助索引中会记录对应的主键列以及辅助索引列。根据辅助索引进行搜索的时候，会先根据辅助索引获取到对应的主键列，然后再根据主键去聚簇索引里面搜索。<strong>一般不建议主键很长，因为主键很长辅助索引就会使用更多的空间</strong></li>
</ul>
<p>每个 InnoDB 表有一个特殊的索引，即聚簇索引，用来存储行数据。通常，聚簇索引和主键同义：</p>
<ul>
<li>如果声明主键，InnoDB 会将主键作为聚簇索引</li>
<li>如果未声明主键，会在 UNIQUE 所有键列所在位置找到第一个索引，NOT NULL 并将其作为聚簇索引</li>
<li>如果未声明且找不到合适的 UNIQUE 索引，则内部生成一个隐藏的聚簇索引 GEN_CLUST_INDEX，这个隐藏的行 ID 是 6 字节且单调递增</li>
</ul>
<h2 id="自增-id-用完会发生什么"> 自增 ID 用完会发生什么</h2>
<p>如果主键设置成自增 ID，在 MySQL 中 INT 类型是 4 个字节，有符号位的话取值范围就是 [-2^31^ , 2^31^ - 1]，最大值为 2147483647，也就是说能存储大约 21 亿数据</p>
<p>这个时候表里有一条 id 达到有符号位的最大值上限的数据，再次执行插入语句时就会报错：</p>
<p><code>1062 - Duplicate entry '2147483647' for key 'PRIMARY', Time: 0.000000s</code></p>
<p>也就是说，如果设置了主键并且自增的话，达到自增主键上限就会报错重复的主键</p>
<h2 id="自增-id-用完的解决方案"> 自增 ID 用完的解决方案</h2>
<h3 id="innodb-系统自增-row-id"> InnoDB 系统自增 row_id</h3>
<p>如果没有手动设置主键的话，InnoDB 会自动创建一个 6 个字节的 <code>row_id</code>（代码上使用的是 BIGINT UNSIGNED 类型，但实际上只给 <code>row_id</code> 留 了6 字节），由于 <code>row_id</code> 是无符号的，所以能写入表中的值范围是 [0 , 2^48^-1]，即最大值为 281474976710655</p>
<p>这个 <code>row_id</code> 是由 InnoDB 维护在全局的（<code>dict_sys.row_id</code>），所有无主键的 InnoDB 表，每插入一行数据，都将当前的 <code>dict_sys.row_id</code> 值作为要插入数据的 <code>row_id</code>，然后加 <code>1</code></p>
<p>当达到上限时，如果再有插入数据的行为要来申请 <code>row_id</code>，拿到的就是 <code>0</code>，存在主键冲突的可能性</p>
<h3 id="bigint"> BIGINT</h3>
<p>将 MySQL 主键改为 BIGINT，也就是 8 个字节，如果是无符号 BIGINT，那么自增长范围是 [0 , 2^64^ – 1]</p>
<p>这个范围对我们正常项目开发而言已经非常非常大了，正常使用基本不存在超出范围问题（非正常使用：创建表时指定自增长值接近越界值）</p>
<p>退一万步讲，就算一张表里的数据真能达到这么多，那么其实在自增 ID 用完前就已经有数据库性能问题了，此时不等自增长值接近越界值，早就应该做分库分表操作了</p>
<p>所以不要再去纠结要是这个自增长值超出最大值咋办，基本遇不到这样的场景</p>
<h3 id="redis-自增主键"> Redis 自增主键</h3>
<p>外部自增主键的生成方式有很多，Redis 是常用的一种，因为它有很多优点：</p>
<p>Redis 自身是原子性的，因此高并发也是线程安全的。假设主键字段长度 <code>20</code>，我们以「时间 + 自增数」来构成主键，例如：「8位日期 + 12位自增数」。根据业务性质可以决定时间取年月日或者到毫秒级，那么在毫秒之间自增数的重复概率是极小极小的，基本的业务都能适用</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">简单查询语法</title>
    <id>https://www.snowji.cn/databases/mysql/simple-query/</id>
    <link href="https://www.snowji.cn/databases/mysql/simple-query/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="简单查询语法"> 简单查询语法</h1>
<h2 id="查询列的语句"> 查询列的语句</h2>
<h3 id="查询单个列"> 查询单个列</h3>
<p>查看某个表中的某一列的数据，语法格式如下：</p>
<div><pre><code><span>SELECT</span> 列名 <span>FROM</span> 表名<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>列名为星号（<code>*</code>）表示把记录中的所有列都查出来。有时候会很方便，但是查询不需要的列通常会降低性能，视情况而用吧</p>
<h3 id="列的别名"> 列的别名</h3>
<p>可以为结果集中的列重新定义一个别名，语法格式如下：</p>
<div><pre><code><span>SELECT</span> 列名 <span>[</span><span>AS</span><span>]</span> 列的别名 <span>FROM</span> 表名<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>这里的 <code>AS</code> 加了个中括号，意思是这个指定别名的语法中，<code>AS</code> 这个单词是可有可无的（不过我觉得加上这个单词可以增加可读性）</p>
<p>定义别名后，用 SELECT 语法查询出来的结果里，原列名就被别名替代了。不过别名只在本次查询得到的结果集中展示，并不会改变真实表中的列名。下一次查询中取其他的别名也可以</p>
<h3 id="查询多个列"> 查询多个列</h3>
<p>如果想查询多个列的数据，可以在 <code>SELECT</code> 后边写多个列名，用逗号 <code>,</code> 分隔开就好：</p>
<div><pre><code><span>SELECT</span> 列名<span>1</span><span>,</span> 列名<span>2</span><span>,</span> <span>.</span><span>.</span><span>.</span> 列名n <span>FROM</span> 表名<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>查询语句中的列名可以按任意顺序摆放，结果集将按照我们指定的列名顺序显示</p>
<h2 id="查询结果去重"> 查询结果去重</h2>
<h3 id="去除单列的重复结果"> 去除单列的重复结果</h3>
<p>有的时候我们查询某个列的数据时会有一些重复的结果，比如我们查询 <code>student_info</code> 表的学院信息，会有重复的学院名</p>
<p>如果想去除重复结果的话，可以将 <code>DISTINCT</code> 放在被查询的列前面，语法格式如下：</p>
<div><pre><code><span>SELECT</span> <span>DISTINCT</span> 列名 <span>FROM</span> 表名<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>这样的结果集里，就只剩下不重复的信息了，比如从学生表里查一下这个学校一共有哪些学院</p>
<h3 id="去除多列的重复结果"> 去除多列的重复结果</h3>
<p>对于查询多列的情况，两条结果重复的意思是：两条结果的每一个列中的值都相同。比如查询学院和专业信息，这两个列的值都相同（都是 <code>计算机学院</code> 下面的 <code>软件工程</code> 专业）</p>
<p>如果想对多列查询的结果去重的话，可以直接把 <code>DISTINCT</code> 放在被查询的列的最前面：</p>
<div><pre><code><span>SELECT</span> <span>DISTINCT</span> 列名<span>1</span><span>,</span> 列名<span>2</span><span>,</span> <span>.</span><span>.</span><span>.</span> 列名n <span>FROM</span> 表名<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="限制查询结果条数"> 限制查询结果条数</h2>
<p>在查询语句的末尾使用 <code>LIMIT</code> 关键字可以限制结果集中的记录条数</p>
<div><pre><code><span>LIMIT</span> 开始行<span>,</span> 限制条数<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li><code>开始行</code> 指的是我们想从第几行数据开始查询，从 <code>0</code> 开始计数</li>
<li><code>限制条数</code> 是结果集中最多包含多少条记录</li>
</ul>
<p><code>LIMIT</code> 后面也可以只有一个参数，那这个参数就代表着<strong>限制行数</strong>，此时默认的开始行就是第 <code>0</code> 行</p>
<h2 id="对查询结果排序"> 对查询结果排序</h2>
<p>MySQL 默认会按照数据底层<strong>存储的顺序</strong>来给我们返回数据，如果想让返回结果中的记录按照某种特定的规则排序，就必须显式地指定排序规则</p>
<h3 id="按照单个列的值进行排序"> 按照单个列的值进行排序</h3>
<div><pre><code><span>ORDER</span> <span>BY</span> 列名 <span>ASC</span><span>|</span><span>DESC</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li><code>ASC</code> 指按照指定列的值进行由小到大进行排序，也叫做升序</li>
<li><code>DESC</code> 指按照指定列的值进行由大到小进行排序，也叫做降序</li>
<li>省略排序方向时默认时升序，即 <code>ASC</code></li>
</ul>
<h3 id="按照多个列的值进行排序"> 按照多个列的值进行排序</h3>
<p>同时指定多个排序的列，多个排序列之间用逗号 <code>,</code> 隔开</p>
<div><pre><code><span>ORDER</span> <span>BY</span> 列<span>1</span> <span>ASC</span><span>|</span><span>DESC</span><span>,</span> 列<span>2</span> <span>ASC</span><span>|</span><span>DESC</span> <span>.</span><span>.</span><span>.</span>
</code></pre>
<div><span>1</span><br></div></div><p>表示查询结果先按照 <code>列1</code> 排序，再按照 <code>列2</code> 排序</p>
<h3 id="order-by-结合-limit"> ORDER BY 结合 LIMIT</h3>
<p>这两个语句结合使用时，<code>ORDER BY</code> 语句必须放在 <code>LIMIT</code> 语句前面：</p>
<div><pre><code><span>SELECT</span> <span>*</span> <span>FROM</span> 表名 <span>ORDER</span> <span>BY</span> 列<span>1</span> <span>LIMIT</span> <span>1</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>比如这条语句可以找出 <code>列1</code> 值最小的那条记录</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">条件查询语法</title>
    <id>https://www.snowji.cn/databases/mysql/query-by-search-conditions/</id>
    <link href="https://www.snowji.cn/databases/mysql/query-by-search-conditions/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="条件查询语法"> 条件查询语法</h1>
<p>主要用到 <code>WHERE</code> 关键字，后面跟上搜索条件</p>
<h2 id="简单搜索条件"> 简单搜索条件</h2>
<p>把 <code>搜索条件</code> 放在 <code>WHERE</code> 子句中，搜索条件中可以使用如下几种比较操作符：</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">示例</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>=</code></td>
<td style="text-align:left"><code>a = b</code></td>
<td style="text-align:left">a 等于 b</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;&gt;</code> 或者 <code>!=</code></td>
<td style="text-align:left"><code>a &lt;&gt; b</code></td>
<td style="text-align:left">a 不等于 b</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;</code></td>
<td style="text-align:left"><code>a &lt; b</code></td>
<td style="text-align:left">a 小于 b</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;=</code></td>
<td style="text-align:left"><code>a &lt;= b</code></td>
<td style="text-align:left">a 小于或等于 b</td>
</tr>
<tr>
<td style="text-align:left"><code>&gt;</code></td>
<td style="text-align:left"><code>a &gt; b</code></td>
<td style="text-align:left">a 大于 b</td>
</tr>
<tr>
<td style="text-align:left"><code>&gt;=</code></td>
<td style="text-align:left"><code>a &gt;= b</code></td>
<td style="text-align:left">a 大于或等于 b</td>
</tr>
<tr>
<td style="text-align:left"><code>BETWEEN</code></td>
<td style="text-align:left"><code>a BETWEEN b AND c</code></td>
<td style="text-align:left">满足 b &lt;= a &lt;= c</td>
</tr>
<tr>
<td style="text-align:left"><code>NOT BETWEEN</code></td>
<td style="text-align:left"><code>a NOT BETWEEN b AND c</code></td>
<td style="text-align:left">不满足 b &lt;= a &lt;= c</td>
</tr>
</tbody>
</table>
<p>比如想查询 <code>student_info</code> 表中名字是 <code>&quot;张星星&quot;</code> 的学生的一些信息，可以这么写：</p>
<div><pre><code><span>SELECT</span> number<span>,</span> name<span>,</span> id_number<span>,</span> major <span>FROM</span> student_info <span>WHERE</span> name <span>=</span> <span>'张星星'</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>想查询学号不在 <code>20220102</code> ~ <code>20220104</code> 这个区间内的所有学生信息，可以这么写：</p>
<div><pre><code><span>SELECT</span> number<span>,</span> name<span>,</span> id_number<span>,</span> major <span>FROM</span> student_info <span>WHERE</span> number <span>NOT</span> <span>BETWEEN</span> <span>20220102</span> <span>AND</span> <span>20220104</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="匹配列表中的元素"> 匹配列表中的元素</h2>
<p>如果搜索条件中指定的匹配值并不是单个值，而是一个列表，只要匹配到列表中的某一项就算匹配成功，这种情况可以使用 <code>IN</code> 操作符：</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">示例</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>IN</code></td>
<td style="text-align:left"><code>a IN (b1, b2, ...)</code></td>
<td style="text-align:left">a 是 b1, b2, ... 中的某一个</td>
</tr>
<tr>
<td style="text-align:left"><code>NOT IN</code></td>
<td style="text-align:left"><code>a NOT IN (b1, b2, ...)</code></td>
<td style="text-align:left">a 不是 b1, b2, ... 中的任意一个</td>
</tr>
</tbody>
</table>
<p>比如想查询软件工程和飞行器设计专业的学生信息，可以这么写：</p>
<div><pre><code><span>SELECT</span> number<span>,</span> name<span>,</span> id_number<span>,</span> major <span>FROM</span> student_info <span>WHERE</span> major <span>IN</span> <span>(</span><span>'软件工程'</span><span>,</span> <span>'飞行器设计'</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="匹配-null-值"> 匹配 NULL 值</h2>
<p><code>NULL</code> 代表没有值，在判断某一列是否为 <code>NULL</code> 的时候不能单纯的使用 <code>=</code> 操作符，而是需要专门判断值是否是 <code>NULL</code> 的操作符：</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">示例</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>IS NULL</code></td>
<td style="text-align:left"><code>a IS NULL</code></td>
<td style="text-align:left">a 的值是 <code>NULL</code></td>
</tr>
<tr>
<td style="text-align:left"><code>IS NOT NULL</code></td>
<td style="text-align:left"><code>a IS NOT NULL</code></td>
<td style="text-align:left">a 的值不是 <code>NULL</code></td>
</tr>
</tbody>
</table>
<p>比如想看一下 <code>student_info</code> 表的 <code>name</code> 列是 <code>NULL</code> 的学生记录有哪些，可以这么写：</p>
<div><pre><code><span>SELECT</span> number<span>,</span> name<span>,</span> id_number<span>,</span> major <span>FROM</span> student_info <span>WHERE</span> name <span>IS</span> <span>NULL</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="多个搜索条件的查询"> 多个搜索条件的查询</h2>
<p>上边都是指定单个搜索条件的查询，也可以在一个查询语句中指定多个搜索条件</p>
<h3 id="and-操作符"> AND 操作符</h3>
<p>用于查询出符合所有搜索条件的结果集，例如：</p>
<div><pre><code><span>SELECT</span> <span>*</span> <span>FROM</span> student_score <span>WHERE</span> subject <span>=</span> <span>'高等数学'</span> <span>AND</span> score <span>></span> <span>75</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="or-操作符"> OR 操作符</h3>
<p>用于查询出只要符合任意给定搜索条件的结果集，例如：</p>
<div><pre><code><span>SELECT</span> <span>*</span> <span>FROM</span> student_score <span>WHERE</span> score <span>></span> <span>95</span> <span>OR</span> score <span>&lt;</span> <span>55</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="更复杂的搜索条件的组合"> 更复杂的搜索条件的组合</h3>
<p>当搜索条件中要结合多个 AND 和 OR 操作符时，<strong>AND 操作符的优先级高于 OR 操作符</strong></p>
<p>为了避免错误，此时最好使用小括号 <code>()</code> 来显式的指定各个搜索条件的检测顺序，比如：</p>
<div><pre><code><span>SELECT</span> <span>*</span> <span>FROM</span> student_score <span>WHERE</span> <span>(</span>score <span>></span> <span>95</span> <span>OR</span> score <span>&lt;</span> <span>55</span><span>)</span> <span>AND</span> subject <span>=</span> <span>'高等数学'</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面的语法如果不加小括号，那么查询出来的结果集和期望的（找出课程为 <code>&quot;高等数学&quot;</code>，并且成绩大于 <code>95</code> 分或者小于 <code>55</code> 分的记录）是有出入的</p>
<h2 id="通配符"> 通配符</h2>
<p>就是模糊查询的场景，使用下面这两个操作符来支持模糊查询：</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">示例</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>LIKE</code></td>
<td style="text-align:left"><code>a LIKE b</code></td>
<td style="text-align:left">a 匹配 b</td>
</tr>
<tr>
<td style="text-align:left"><code>NOT LIKE</code></td>
<td style="text-align:left"><code>a NOT LIKE b</code></td>
<td style="text-align:left">a 不匹配 b</td>
</tr>
</tbody>
</table>
<p>然后需要用某个符号（称为通配符）来替代这些模糊的信息。MySQL 中支持下边这两个通配符：</p>
<ul>
<li>
<p><code>%</code>：代表任意一个字符串</p>
<div><pre><code><span>SELECT</span> number<span>,</span> name<span>,</span> id_number<span>,</span> major <span>FROM</span> student_info <span>WHERE</span> name <span>LIKE</span> <span>'张%'</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p><code>_</code>：代表任意一个字符（用于精确知道字符串长度的情况）</p>
<div><pre><code><span>SELECT</span> number<span>,</span> name<span>,</span> id_number<span>,</span> major <span>FROM</span> student_info <span>WHERE</span> name <span>LIKE</span> <span>'_星_'</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div></li>
</ul>
<div><p>小贴士</p>
<p><code>LIKE</code> 或者 <code>NOT LIKE</code> 操作符只用于<strong>字符串</strong>匹配。另外，通配符不能代表 <code>NULL</code>，如果需要匹配 <code>NULL</code> 的话，需要使用 <code>IS NULL</code> 或者 <code>IS NOT NULL</code></p>
</div>
<h2 id="转义通配符"> 转义通配符</h2>
<p>如果待匹配的字符串中本身就包含普通字符 <code>'%'</code> 或者 <code>'_'</code>，就需要在它们前边加一个反斜杠 <code>\</code> 来和通配符区分开，也就是说：</p>
<ul>
<li><code>'\%'</code> 代表普通字符 <code>'%'</code></li>
<li><code>'\_'</code> 代表普通字符 <code>'_'</code></li>
</ul>
<p>例如查询名字叫 <code>张_</code> 的学生：</p>
<div><pre><code><span>SELECT</span> number<span>,</span> name<span>,</span> id_number<span>,</span> major <span>FROM</span> student_info <span>WHERE</span> name <span>LIKE</span> <span>'张\_'</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">子查询语法</title>
    <id>https://www.snowji.cn/databases/mysql/sub-query/</id>
    <link href="https://www.snowji.cn/databases/mysql/sub-query/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="子查询语法"> 子查询语法</h1>
<p>在有些场景中，我们需要使用两条或多条查询语句，而恰好第二条查询语句的搜索条件其实是用到了第一条查询语句的查询结果。为了书写简便，我们可以把这两条语句合并到一条语句中，从而减少了把第一条查询语句的结果复制粘贴到第二条查询语句中的步骤</p>
<p>在书写上，只需要把第二条查询语句用小括号 <code>()</code> 扩起来作为一个操作数放到第一条的搜索条件处，这样就起到了合并两条查询语句的作用</p>
<p>小括号中的查询语句也被称为<strong>子查询</strong>或者<strong>内层查询</strong>，使用内层查询的结果作为搜索条件的查询称为<strong>外层查询</strong>。如果在一个查询语句中需要用到更多的表的话，那么在一个子查询中可以继续嵌套另一个子查询，在执行查询语句时，将按照<strong>从内到外</strong>的顺序依次执行这些查询</p>
<div><p>小贴士</p>
<p>所有的子查询都必须用小括号扩起来，否则是非法的</p>
</div>
<h2 id="标量子查询"> 标量子查询</h2>
<p>如果子查询的结果只有一个值，这种子查询称之为<strong>标量子查询</strong>。比如下面这个，子查询的结果是一个学号（<code>number</code>）：</p>
<div><pre><code><span>SELECT</span> <span>*</span> <span>FROM</span> student_score <span>WHERE</span> number <span>=</span> <span>(</span><span>SELECT</span> number <span>FROM</span> student_info <span>WHERE</span> name <span>=</span> <span>'张星星'</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>因为标量子查询单纯的代表一个值，所以它可以作为表达式的操作数来参与运算，它除了用在外层查询的搜索条件中以外，也可以被放到查询列表处，比如这样：</p>
<div><pre><code><span>SELECT</span> <span>(</span><span>SELECT</span> number <span>FROM</span> student_info <span>WHERE</span> name <span>=</span> <span>'张星星'</span><span>)</span> <span>AS</span> 学号<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>标量子查询单纯的代表一个值，由标量子查询作为的操作数组成的搜索条件只要符合表达语法就可以。比如来查询学号大于 <code>&quot;张星星&quot;</code> 的学号的学生成绩，可以这么写：</p>
<div><pre><code><span>SELECT</span> <span>*</span> <span>FROM</span> student_score <span>WHERE</span> number <span>></span> <span>(</span><span>SELECT</span> number <span>FROM</span> student_info <span>WHERE</span> name <span>=</span> <span>'张星星'</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="列子查询"> 列子查询</h2>
<p>如果子查询语句的结果集中并不是一个单独的值，而是一个列，该子查询也被称之为<strong>列子查询</strong></p>
<p>因为列子查询得到的结果是多个值，相当于一个列表。那么就可以使用 <code>IN</code> 和 <code>NOT IN</code> 操作符搭配子查询的结果组成表达式来作为外层查询的搜索条件的</p>
<p>就像这样一个场景：查询 <code>&quot;计算机科学与工程&quot;</code> 专业的学生的成绩：</p>
<div><pre><code><span>SELECT</span> <span>*</span> <span>FROM</span> student_score <span>WHERE</span> number <span>IN</span> <span>(</span><span>SELECT</span> number <span>FROM</span> student_info <span>WHERE</span> major <span>=</span> <span>'计算机科学与工程'</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="行子查询"> 行子查询</h2>
<p>有列子查询，自然就有行子查询。只要子查询的结果集中最多只包含一条记录，而且这条记录中有超过一个列的数据（如果该条记录只包含一个列的话，该子查询就成了标量子查询），那么这个子查询就可以被称之为<strong>行子查询</strong></p>
<div><pre><code><span>SELECT</span> <span>*</span> <span>FROM</span> student_score <span>WHERE</span> <span>(</span>number<span>,</span> subject<span>)</span> <span>=</span> <span>(</span><span>SELECT</span> number<span>,</span> <span>'高等数学'</span> <span>FROM</span> student_info <span>LIMIT</span> <span>1</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>看上面这句查询语句，子查询的查询列表是 <code>number</code>（列名）, <code>'高等数学'</code>（常数），在子查询语句中加了 <code>LIMIT 1</code> 这个子句，意味着子查询最多只能返回一条记录，所以该子查询就可以被看作一个行子查询</p>
<p>这句查询语句表达的语义就是：先获取到子查询的执行结果，然后再执行外层查询，如果 <code>student_score</code> 中记录的 <code>number</code> 等于子查询结果中的 <code>number</code> 列并且 <code>subject</code> 列等于子查询结果中的 <code>'高等数学'</code>，那么就将该记录加入到结果集</p>
<p>因为子查询执行后产生的结果集是一个行（包含 2 个列），所以外层查询里用作等值比较的另一个操作数也得是 2 个值，本例中就是 <code>(number, subject)</code>（并且必须用小括号 <code>()</code> 扩住，否则会产生歧义）</p>
<div><p>小贴士</p>
<p>在想要得到标量子查询或者行子查询，但又不能保证子查询的结果集只有一条记录时，应该使用 <code>LIMIT 1</code> 子句来限制记录数量</p>
</div>
<h2 id="表子查询"> 表子查询</h2>
<p>如果子查询结果集中包含多行多列，那么这个子查询也可以被称之为<strong>表子查询</strong>，比如这样：</p>
<div><pre><code><span>SELECT</span> <span>*</span> <span>FROM</span> student_score <span>WHERE</span> <span>(</span>number<span>,</span> subject<span>)</span> <span>IN</span> <span>(</span><span>SELECT</span> number<span>,</span> <span>'高等数学'</span> <span>FROM</span> student_info <span>WHERE</span> major <span>=</span> <span>'计算机科学与工程'</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>在这个例子中的子查询执行之后的结果集中包含多行多列，所以可以被看作是一个表子查询</p>
<h2 id="exists-和-not-exists-子查询"> EXISTS 和 NOT EXISTS 子查询</h2>
<p>有时候外层查询并不关心子查询中的结果是什么，而只关心子查询的结果集是不是为空集，这时可以用到下边这两个操作符：</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">示例</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>EXISTS</code></td>
<td style="text-align:left"><code>EXISTS (SELECT ...)</code></td>
<td style="text-align:left">当子查询结果集不是空集时表达式为真</td>
</tr>
<tr>
<td style="text-align:left"><code>NOT EXISTS</code></td>
<td style="text-align:left"><code>NOT EXISTS (SELECT ...)</code></td>
<td style="text-align:left">当子查询结果集是空集时表达式为真</td>
</tr>
</tbody>
</table>
<p>举个例子：</p>
<div><pre><code>mysql<span>></span> <span>SELECT</span> <span>*</span> <span>FROM</span> student_score <span>WHERE</span> <span>EXISTS</span> <span>(</span><span>SELECT</span> <span>*</span> <span>FROM</span> student_info <span>WHERE</span> number <span>=</span> <span>20200108</span><span>)</span><span>;</span>
Empty <span>set</span> <span>(</span><span>0.00</span> sec<span>)</span>

mysql<span>></span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>其中子查询的意思是在 <code>student_info</code> 表中查找学号为 <code>20200108</code> 的学生信息，很显然并没有该学生，所以子查询的结果集是一个空集，于是 <code>EXISTS</code> 表达式的结果为 <code>FALSE</code>，所以外层查询也就不查了，直接返回了一个 <code>Empty set</code>，表示没有结果</p>
<p><code>NOT EXISTS</code> 的用法同理</p>
<h2 id="不相关子查询和相关子查询"> 不相关子查询和相关子查询</h2>
<p>所谓<strong>不相关子查询</strong>，就是子查询和外层查询都没有依赖关系，子查询可以独立运行并产生结果之后，再拿结果作为外层查询的条件去执行外层查询</p>
<p>而有时候我们需要在子查询的语句中引用到外层查询的值，这样的话子查询就不能当作一个独立的语句去执行，这种子查询被称为<strong>相关子查询</strong></p>
<p>比如说我们想查看一些学生的基本信息，但是前提是这些学生在 <code>student_score</code> 表中有成绩记录，那可以这么写：</p>
<div><pre><code>mysql<span>></span> <span>SELECT</span> number<span>,</span> name<span>,</span> id_number<span>,</span> major <span>FROM</span> student_info <span>WHERE</span> <span>EXISTS</span> <span>(</span><span>SELECT</span> <span>*</span> <span>FROM</span> student_score <span>WHERE</span> student_score<span>.</span>number <span>=</span> student_info<span>.</span>number<span>)</span><span>;</span>
<span>+</span><span>----------+-----------+--------------------+--------------------------+</span>
<span>|</span> number   <span>|</span> name      <span>|</span> id_number          <span>|</span> major                    <span>|</span>
<span>+</span><span>----------+-----------+--------------------+--------------------------+</span>
<span>|</span> <span>20220101</span> <span>|</span> 张星星    <span>|</span> <span>158177199901044792</span> <span>|</span> 计算机科学与工程         <span>|</span>
<span>|</span> <span>20220102</span> <span>|</span> 王二狗    <span>|</span> <span>151008199801178529</span> <span>|</span> 计算机科学与工程         <span>|</span>
<span>|</span> <span>20220103</span> <span>|</span> 陈珊珊    <span>|</span> <span>17156319980116959</span>X <span>|</span> 软件工程                 <span>|</span>
<span>|</span> <span>20220104</span> <span>|</span> 李思思    <span>|</span> <span>141992199701078600</span> <span>|</span> 软件工程                 <span>|</span>
<span>+</span><span>----------+-----------+--------------------+--------------------------+</span>
<span>4</span> <span>rows</span> <span>in</span> <span>set</span> <span>(</span><span>0.00</span> sec<span>)</span>

mysql<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><p>小贴士</p>
<p><code>student_info</code> 和 <code>student_score</code> 表里都有 <code>number</code> 列，所以在子查询的 <code>WHERE</code> 语句中书写 <code>number = number</code> 会造成二义性，也就是让服务器懵逼，不知道这个 <code>number</code> 列到底是哪个表的。为了区分，在列名前边加上了表名，并用点 <code>.</code> 连接起来，这种显式的将列所属的表名书写出来的名称称为该列的全限定名</p>
<p>上边子查询的 <code>WHERE</code> 语句中用了列的全限定名：<code>student_score.number = student_info.number</code></p>
</div>
<p>这条查询语句可以分成这么两部分来理解：</p>
<ul>
<li>我们要查询学生的一些基本信息</li>
<li>这些学生必须符合这样的条件：<code>必须有成绩记录保存在 student_score 表中</code></li>
</ul>
<p>所以这个例子中的<strong>相关子查询</strong>的查询过程是这样的：</p>
<ul>
<li>先执行外层查询获得到 <code>student_info</code> 表的第一条记录，发现它的 <code>number</code> 值是 <code>20220101</code>。把 <code>20220101</code> 当作参数传入到子查询，此时子查询的意思是判断 <code>student_score</code> 表的 <code>number</code> 字段是否有 <code>20220101</code> 这个值存在，子查询的结果是该值存在，所以整个 <code>EXISTS</code> 表达式的值为 <code>TRUE</code>，那么 <code>student_info</code> 表的第一条记录可以被加入到结果集</li>
<li>再执行外层查询获得到 <code>student_info</code> 表的第二条记录，发现它的 <code>number</code> 值是 <code>20220102</code>，与上面的步骤相同，<code>student_info</code> 表的第二条记录也可以被加入到结果集</li>
<li>与上面类似，<code>student_info</code> 表的第三条记录也可以被加入到结果集</li>
<li>与上面类似，<code>student_info</code> 表的第四条记录也可以被加入到结果集</li>
<li>再执行外层查询获得到 <code>student_info</code> 表的第五条记录，发现它的 <code>number</code> 值是 <code>20220105</code>，把 <code>20220105</code> 当作参数传入到它的子查询，此时子查询的意思是判断 <code>student_score</code> 表的 <code>number</code> 字段是否有 <code>20220105</code> 这个值存在，子查询的结果是该值不存在，所以整个 <code>EXISTS</code> 表达式的值为 <code>FALSE</code>，那么 <code>student_info</code> 表的第五条记录就不被加入结果集中</li>
<li>与上一步骤类似，<code>student_info</code> 表的第六条记录也不被加入结果集中</li>
<li><code>student_info</code> 表没有更多的记录了，结束查询</li>
</ul>
<p>所以最后的查询结果是上面展示的 4 条记录</p>
<h2 id="对同一个表的子查询"> 对同一个表的子查询</h2>
<p>不只是在涉及多个表查询的时候会用到子查询，在只涉及单个表的查询中有时也会用到子查询</p>
<p>比如我们想看看在 <code>student_score</code> 表的 <code>'高等数学'</code> 这门课的成绩中，有哪些超过了平均分的记录，根据字面意思第一反应是这么写：</p>
<div><pre><code>mysql<span>></span> <span>SELECT</span> <span>*</span> <span>FROM</span> student_score <span>WHERE</span> subject <span>=</span> <span>'高等数学'</span> <span>AND</span> score <span>></span> <span>AVG</span><span>(</span>score<span>)</span><span>;</span>
ERROR <span>1111</span> <span>(</span>HY000<span>)</span>: Invalid <span>use</span> <span>of</span> <span>group</span> <span>function</span>
mysql<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>很抱歉，报错了。为啥呢？因为聚集函数是用来对分组做数据统计的（如果没有 <code>GROUP BY</code> 语句那么意味着只有一个分组），而 <code>WHERE</code> 子句是以记录为单位来执行过滤操作的，在 <code>WHERE</code> 子句执行完成之后才会得到分组，也就是说：<strong>聚集函数不能放到 <code>WHERE</code> 子句中</strong></p>
<p>如果想实现上面的需求，就需要搞一个 <code>student_score</code> 表的副本，就相当于有了两个 <code>student_score</code> 表，在一个表上使用聚集函数统计，统计完了之后拿着统计结果再到另一个表中进行过滤，这个过程可以这么写：</p>
<div><pre><code>mysql<span>></span> <span>SELECT</span> <span>*</span> <span>FROM</span> student_score <span>WHERE</span> subject <span>=</span> <span>'高等数学'</span> <span>AND</span> score <span>></span> <span>(</span><span>SELECT</span> <span>AVG</span><span>(</span>score<span>)</span> <span>FROM</span> student_score <span>WHERE</span> subject <span>=</span> <span>'高等数学'</span><span>)</span><span>;</span>
<span>+</span><span>----------+--------------+-------+</span>
<span>|</span> number   <span>|</span> subject      <span>|</span> score <span>|</span>
<span>+</span><span>----------+--------------+-------+</span>
<span>|</span> <span>20220101</span> <span>|</span> 高等数学     <span>|</span>    <span>78</span> <span>|</span>
<span>|</span> <span>20220102</span> <span>|</span> 高等数学     <span>|</span>   <span>100</span> <span>|</span>
<span>+</span><span>----------+--------------+-------+</span>
<span>2</span> <span>rows</span> <span>in</span> <span>set</span> <span>(</span><span>0.00</span> sec<span>)</span>

mysql<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>我们使用子查询先统计出了 <code>'高等数学'</code> 这门课的平均分，然后再到外层查询中使用这个平均分组成的表达式来作为搜索条件去查找大于平均分的记录</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">组合查询语法</title>
    <id>https://www.snowji.cn/databases/mysql/union-query/</id>
    <link href="https://www.snowji.cn/databases/mysql/union-query/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="组合查询语法"> 组合查询语法</h1>
<p>将多条查询语句产生的结果集合并起来的查询方式称为<strong>合并查询</strong>，或者<strong>组合查询</strong></p>
<h2 id="涉及单表的组合查询"> 涉及单表的组合查询</h2>
<p>使用 <code>UNION</code> 连接多个查询语句，要求：</p>
<ul>
<li>各查询语句的查询列表处，表达式数量相同</li>
<li>各查询语句的查询列表中，位置相同的表达式的类型应该是相同的（建议，非强制，因为 MySQL 将会自动的进行类型转换）</li>
<li>组合查询的结果集中显示的列名将以第一个查询中的列名为准</li>
</ul>
<p>例如：</p>
<div><pre><code><span>SELECT</span> m1<span>,</span> n1 <span>FROM</span> t1 <span>WHERE</span> m1 <span>&lt;</span> <span>2</span> <span>UNION</span> <span>SELECT</span> n1<span>,</span> m1 <span>FROM</span> t1 <span>WHERE</span> m1 <span>></span> <span>2</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>第一个语句的查询列表是 <code>m1</code>，<code>n1</code>，第二个查询语句的查询列表是 <code>n1</code>，<code>m1</code></li>
<li>第一个查询的查询列表处的 <code>m1</code> 和第二个查询的查询列表的 <code>n1</code> 对应；第一个查询的查询列表处的 <code>n1</code> 和第二个查询的查询列表的 <code>m1</code> 对应</li>
<li>最终的结果集中，显示的列名将以第一个查询中的列名为准，即第一个查询中的 <code>m1</code>，<code>n1</code> 作为结果集的列名</li>
</ul>
<h2 id="涉及不同表的组合查询"> 涉及不同表的组合查询</h2>
<p>如果只在同一个表中进行组合查询，貌似体现不出组合查询的强大（完全可以用 <code>OR</code> 操作符把两个查询语句中的搜索条件连起来），很多情况下组合查询还是用在涉及不同表的查询语句中的</p>
<h3 id="包含或去除重复的行"> 包含或去除重复的行</h3>
<p>使用 <code>UNION</code> 来合并多个查询的记录会默认过滤掉重复的记录</p>
<p>如果想要保留重复记录，可以使用 <code>UNION ALL</code> 来连接多个查询：</p>
<div><pre><code><span>SELECT</span> m1<span>,</span> n1 <span>FROM</span> t1 <span>UNION</span> <span>ALL</span> <span>SELECT</span> m2<span>,</span> n2 <span>FROM</span> t2<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="组合查询中的-order-by-和-limit-子句"> 组合查询中的 ORDER BY 和 LIMIT 子句</h3>
<p>组合查询会把各个查询的结果汇总到一块，如果我们想对最终的结果集进行排序或者只保留几行的话，可以在组合查询的语句末尾加上 <code>ORDER BY</code> 和 <code>LIMIT</code> 子句，就像这样：</p>
<div><pre><code><span>(</span><span>SELECT</span> m1<span>,</span> n1 <span>FROM</span> t1<span>)</span> <span>UNION</span> <span>(</span><span>SELECT</span> m2<span>,</span> n2 <span>FROM</span> t2<span>)</span> <span>ORDER</span> <span>BY</span> m1 <span>DESC</span> <span>LIMIT</span> <span>2</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><div><p>小贴士</p>
<p>一般会为各个小的查询语句加上括号 <code>()</code> 让整体的语句更清晰</p>
</div>
<p>由于最后的结果集展示的列名是第一个查询中给定的列名，所以 <code>ORDER BY</code> 子句中指定的排序列也必须是第一个查询中给定的列名（别名也可以）</p>
<div><p>小贴士</p>
<p>为各个小查询加入 <code>ORDER BY</code> 子句是不起作用的，因为组合查询并不保证最后汇总起来的大结果集中的顺序是按照各个小查询的结果集中的顺序排序的</p>
</div>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Hash 类型</title>
    <id>https://www.snowji.cn/databases/redis/Hash/</id>
    <link href="https://www.snowji.cn/databases/redis/Hash/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="hash-类型"> Hash 类型</h1>
<h2 id="hset-hmset-hget-hmget-hgetall"> hset/hmset/hget/hmget/hgetall</h2>
<p>添加和获取元素</p>
<p><strong>语法</strong>：</p>
<div><pre><code>hset key field value<span>[</span>field value,field value<span>..</span><span>..</span><span>..</span><span>]</span>
hget key field value<span>[</span>field value,field value<span>..</span><span>..</span><span>..</span><span>]</span>
hmset key field value<span>[</span>field value,field value<span>..</span><span>..</span><span>..</span><span>]</span>
hmget key field <span>[</span>field,field<span>..</span><span>..</span><span>]</span>
hgetall key 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> hset myhash field1 redis   <span># set 一个具体的 key-value</span>
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> hget myhash field1                <span># 获取一个字段值</span>
<span>"redis"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> hmset myhash field1 hello field2 world  <span># 同时 set 多个具体的 key-value</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> hmget myhash field1 field2             <span># 获取多个字段值</span>
<span>1</span><span>)</span> <span>"hello"</span>
<span>2</span><span>)</span> <span>"world"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> hgetall myhash                             <span># 获取所有字段值</span>
<span>1</span><span>)</span> <span>"field1"</span>
<span>2</span><span>)</span> <span>"hello"</span>
<span>3</span><span>)</span> <span>"field2"</span>
<span>4</span><span>)</span> <span>"world"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id="hdel"> hdel</h2>
<p>删除指定的字段</p>
<p><strong>语法</strong>：</p>
<div><pre><code>hdel key field<span>[</span>field,field<span>..</span><span>..</span>.<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> hdel myhash field1     <span># 删除指定的field字段，对应的 value 也被删除</span>
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> hgetall myhash 
<span>1</span><span>)</span> <span>"field2"</span>
<span>2</span><span>)</span> <span>"world"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="hlen"> hlen</h2>
<p>获取 Hash 表中的字段数量</p>
<p><strong>语法</strong>：</p>
<div><pre><code>hlen key
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> hlen myhash
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> hmset myhash field1 hello field2 world
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> hlen myhash
<span>(</span>integer<span>)</span> <span>2</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> hgetall myhash
<span>1</span><span>)</span> <span>"field2"</span>
<span>2</span><span>)</span> <span>"world"</span>
<span>3</span><span>)</span> <span>"field1"</span>
<span>4</span><span>)</span> <span>"hello"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="hexists"> hexists</h2>
<p>判断 Hash 表中的字段是否存在</p>
<p><strong>语法</strong>：</p>
<div><pre><code>hexists key field
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> HEXISTS myhash field1   <span># 判断 Hash 中指定字段是否存在</span>
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> HEXISTS myhash field3
<span>(</span>integer<span>)</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="hkeys-hvals"> hkeys/hvals</h2>
<p>只获得 key 或 value</p>
<p><strong>语法</strong>:</p>
<div><pre><code>hkeys key
hvals key
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> hkeys myhash
<span>1</span><span>)</span> <span>"field2"</span>
<span>2</span><span>)</span> <span>"field1"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> hvals myhash
<span>1</span><span>)</span> <span>"world"</span>
<span>2</span><span>)</span> <span>"hello"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="hincrby"> hincrby</h2>
<p>hincrby：按步长自增</p>
<p><strong>语法</strong>：</p>
<div><pre><code>hincrby key field increment
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> hset myhash field3 <span>6</span>
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> hincrby myhash field3 <span>1</span>
<span>(</span>integer<span>)</span> <span>7</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> hincrby myhash field3 -1
<span>(</span>integer<span>)</span> <span>6</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="hsetnx"> hsetnx</h2>
<p>判断字段是否存在，不存在则添加</p>
<p><strong>语法</strong>：</p>
<div><pre><code>hsetnx key field value
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> hsetnx myhsah field4 reids
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> hsetnx myhsah field4 mongodb
<span>(</span>integer<span>)</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><p>总结</p>
<ul>
<li>
<p>Hash 存储变更的数据 user name age，尤其是用户信息之类的，经常变动的信息</p>
</li>
<li>
<p><strong>Hash 更适合于对象的存储，Sring 更加适合字符串存储</strong></p>
</li>
</ul>
</div>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">BitMap 位图</title>
    <id>https://www.snowji.cn/databases/redis/BitMaps/</id>
    <link href="https://www.snowji.cn/databases/redis/BitMaps/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="bitmap-位图"> BitMap 位图</h1>
<ul>
<li>使用位存储，信息状态只有 0 和 1</li>
<li>BitMap是一串连续的 2 进制数字（0或1），每一位所在的位置为偏移(offset)</li>
<li>在 BitMap上可执行 AND、OR、XOR、NOT 以及其它位操作</li>
</ul>
<h2 id="setbit-getbit"> setbit/getbit</h2>
<p>setbit：为指定 key 的 offset 位设置值</p>
<p>getbit：获取 offset 位的值</p>
<p><strong>语法</strong>：</p>
<div><pre><code>setbit key offset value
getbit key offset
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> setbit sign <span>0</span> <span>1</span>
<span>(</span>integer<span>)</span> <span>0</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> setbit sign <span>1</span> <span>0</span>
<span>(</span>integer<span>)</span> <span>0</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> setbit sign <span>2</span> <span>0</span>
<span>(</span>integer<span>)</span> <span>0</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> setbit sign <span>3</span> <span>1</span> 
<span>(</span>integer<span>)</span> <span>0</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> setbit sign <span>4</span> <span>1</span>
<span>(</span>integer<span>)</span> <span>0</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> setbit sign <span>5</span> <span>0</span>
<span>(</span>integer<span>)</span> <span>0</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> setbit sign <span>6</span> <span>0</span>
<span>(</span>integer<span>)</span> <span>0</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> getbit sign <span>3</span>
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> getbit sign <span>6</span>
<span>(</span>integer<span>)</span> <span>0</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id="bitcount"> bitcount</h2>
<p>统计字符串被设置为 1 的 bit 数，也可以指定统计范围按字节</p>
<p><strong>语法</strong>：</p>
<div><pre><code>bitcount key start end <span>[</span>BYTE<span>|</span>BIT<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> bitcount sign   <span># 统计打卡数</span>
<span>(</span>integer<span>)</span> <span>3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><p>应用场景</p>
<ul>
<li>签到统计</li>
<li>登录状态统计</li>
<li>用户活跃度</li>
</ul>
</div>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">事务</title>
    <id>https://www.snowji.cn/databases/redis/affairs/</id>
    <link href="https://www.snowji.cn/databases/redis/affairs/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="事务"> 事务</h1>
<h2 id="什么是-redis-事务"> 什么是 Redis 事务</h2>
<p><strong>事务的本质</strong>：</p>
<ul>
<li>Redis 事务的本质是一组命令的集合</li>
<li>一个事务中的所有命令都会被序列化</li>
<li>事务执行过程中，会按照顺序执行</li>
</ul>
<p><strong>事务特性</strong>：</p>
<ul>
<li>一次性</li>
<li>顺序性</li>
<li>排他性</li>
</ul>
<div><p>注意</p>
<ul>
<li>Redis 单条命令是保证原子性的，但是事务不保证原子性</li>
<li>Redis 事务没有隔离级别的概念</li>
</ul>
</div>
<h2 id="redis-事务操作过程"> Redis 事务操作过程</h2>
<ul>
<li>开启事务（multi）</li>
<li>命令入队</li>
<li>执行事务（exec）</li>
</ul>
<p>事务中的命令在加入时都没有被执行，直到提交时才会开始执行(exec)一次性完成</p>
<h3 id="正常执行事务"> 正常执行事务</h3>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> multi               <span># 开启事务</span>
OK
<span>127.0</span>.0.1:6379<span>(</span>TX<span>)</span><span>></span> <span>set</span> k1 v1
QUEUED
<span>127.0</span>.0.1:6379<span>(</span>TX<span>)</span><span>></span> <span>set</span> k2 v2
QUEUED
<span>127.0</span>.0.1:6379<span>(</span>TX<span>)</span><span>></span> get k2
QUEUED
<span>127.0</span>.0.1:6379<span>(</span>TX<span>)</span><span>></span> <span>set</span> k3 v3
QUEUED
<span>127.0</span>.0.1:6379<span>(</span>TX<span>)</span><span>></span> <span>exec</span>                 <span># 执行事务</span>
<span>1</span><span>)</span> OK
<span>2</span><span>)</span> OK
<span>3</span><span>)</span> <span>"v2"</span>
<span>4</span><span>)</span> OK
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="取消事务"> 取消事务</h3>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> multi                    <span># 开启事务</span>
OK
<span>127.0</span>.0.1:6379<span>(</span>TX<span>)</span><span>></span> <span>set</span> k1 v1
QUEUED
<span>127.0</span>.0.1:6379<span>(</span>TX<span>)</span><span>></span> <span>set</span> k2 v2
QUEUED
<span>127.0</span>.0.1:6379<span>(</span>TX<span>)</span><span>></span> <span>set</span> k4 v4
QUEUED
<span>127.0</span>.0.1:6379<span>(</span>TX<span>)</span><span>></span> discard            <span># 取消事务</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> get k4                <span># 事务队列中命令都不会被执行</span>
<span>(</span>nil<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="事务错误"> 事务错误</h2>
<h3 id="命令语法错误-编译时异常"> 命令语法错误(编译时异常)</h3>
<p>事务中所有的命令都不会被执行</p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> multi
OK
<span>127.0</span>.0.1:6379<span>(</span>TX<span>)</span><span>></span> <span>set</span> k1 v1
QUEUED
<span>127.0</span>.0.1:6379<span>(</span>TX<span>)</span><span>></span> <span>set</span> k2 v2
QUEUED
<span>127.0</span>.0.1:6379<span>(</span>TX<span>)</span><span>></span> <span>set</span> k3 v3
QUEUED
<span>127.0</span>.0.1:6379<span>(</span>TX<span>)</span><span>></span> getset k3                <span># 错误的命令</span>
<span>(</span>error<span>)</span> ERR wrong number of arguments <span>for</span> <span>'getset'</span> <span>command</span>
<span>127.0</span>.0.1:6379<span>(</span>TX<span>)</span><span>></span> <span>set</span> k4 v4
QUEUED
<span>127.0</span>.0.1:6379<span>(</span>TX<span>)</span><span>></span> <span>set</span> k5 v5
QUEUED
<span>127.0</span>.0.1:6379<span>(</span>TX<span>)</span><span>></span> <span>exec</span>                <span># 执行事务报错</span>
<span>(</span>error<span>)</span> EXECABORT Transaction discarded because of previous errors.
<span>127.0</span>.0.1:637<span><span>9</span>></span> get k5                      <span># 所有的命令都不会被执行</span>
<span>(</span>nil<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id="命令执行时错误-运行时异常"> 命令执行时错误(运行时异常)</h3>
<p>其他命令可以正常执行</p>
<p>这就是事务不保证原子性的原因</p>
<div><pre><code><span>127.0</span>.0.1:6379<span>(</span>TX<span>)</span><span>></span> <span>set</span> k1 <span>"v1"</span>
QUEUED
<span>127.0</span>.0.1:6379<span>(</span>TX<span>)</span><span>></span> multi
<span>(</span>error<span>)</span> ERR MULTI calls can not be nested
<span>127.0</span>.0.1:6379<span>(</span>TX<span>)</span><span>></span> incr k1                 <span># 会执行失败</span>
QUEUED
<span>127.0</span>.0.1:6379<span>(</span>TX<span>)</span><span>></span> <span>set</span> k2 v2
QUEUED
<span>127.0</span>.0.1:6379<span>(</span>TX<span>)</span><span>></span> <span>set</span> k3 v3
QUEUED
<span>127.0</span>.0.1:6379<span>(</span>TX<span>)</span><span>></span> get k3
QUEUED
<span>127.0</span>.0.1:6379<span>(</span>TX<span>)</span><span>></span> <span>exec</span>
<span>1</span><span>)</span> OK
<span>2</span><span>)</span> OK
<span>3</span><span>)</span> OK
<span>4</span><span>)</span> OK
<span>5</span><span>)</span> OK
<span>6</span><span>)</span> <span>(</span>error<span>)</span> ERR value is not an integer or out of range    <span># 第一条命令执行报错，其他命令执行成功</span>
<span>7</span><span>)</span> OK
<span>8</span><span>)</span> OK
<span>9</span><span>)</span> <span>"v3"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> get k2
<span>"v2"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> get k3
<span>"v3"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Redis 的 ACL 安全策略</title>
    <id>https://www.snowji.cn/databases/redis/access-control-list/</id>
    <link href="https://www.snowji.cn/databases/redis/access-control-list/"/>
    <updated>2022-09-26T12:16:43.000Z</updated>
    <content type="html"><![CDATA[<h1 id="redis-的-acl-安全策略"> Redis 的 ACL 安全策略</h1>
<blockquote>
<p>ACL 是 Redis 6.0 的新特性，主要是做权限控制的</p>
<p>它的出现是因为在 Redis 6.0 版本之前是没有权限的概念的，所有连接的客户端都可以对 Redis 里面的数据进行操作，也可以使用所有高危命令，比如 <code>flushall</code> 或 <code>flushdb</code> 清空掉数据库里面的所有数据</p>
</blockquote>
<h2 id="背景"> 背景</h2>
<p>最近给新安装的 Redis 设置密码时，按照以前的方式，因为在 Redis 6.0 之前，Redis 只有一个 default 用户也是 Redis 中的超级管理员用户，所以要将其设置密码，只需要修改 Redis 配置文件中如下项：</p>
<div><pre><code>requirepass <span>123456</span>
</code></pre>
<div><span>1</span><br></div></div><p>然后重启 Redis 就可以了。</p>
<p>这就是在 Redis 6.0 之前给 Redis 用户创建密码的方式，只有一个 <code>default</code> 用户也是 Redis 中的超级管理员用户</p>
<p>但是这次安装的是 Redis 7，在一次开启公网调试并用代码访问时，发现通过配置文件设置的密码并未生效。又重新看了下配置文件，果然在这一项的上面注释中写着：<code>requirepass</code> 与 ACL 不兼容，如果开启了 ACL，那么这项配置将被忽略</p>
<p>看来有必要了解一下 ACL 这个新特性了</p>
<h2 id="acl-简介"> ACL 简介</h2>
<p>在 Redis 6.0 之前的版本，我们只能使用 <code>requirepass</code> 参数给 <code>default</code> 用户配置登录密码，同一个 Redis 集群的所有开发都共享 <code>default</code> 用户，难免会出现误操作把别人的 key 删掉或者数据泄露的情况</p>
<p>因此 Redis 6.0 版本推出了 ACL（Access Controller List）访问控制权限的功能，基于此功能，我们可以设置多个用户，并且给每个用户单独设置命令权限和数据权限。在用户连接之后，它的工作方式是需要客户端进行身份验证，以提供用户名和有效密码：如果身份验证阶段成功，则连接与给定用户关联，并且该用户具有限制</p>
<p>为了保证向下兼容，Redis 6.0 保留了 <code>default</code> 用户和使用 <code>requirepass</code> 的方式给 <code>default</code> 用户设置密码，默认情况下 <code>default</code> 用户拥有 Redis 最大权限，我们使用 redis-cli 连接时如果没有指定用户名，用户也是默认 <code>default</code></p>
<h2 id="配置-acl"> 配置 ACL</h2>
<p>配置 ACL 的方式有两种，一种是在 conf 文件中直接配置，另一种是在外部 aclfile 中配置。配置的命令是一样的，<strong>但是两种方式只能选择其中一种</strong></p>
<p>在讲具体的配置方式之前，需要先简单介绍一下定义 ACL 时用到的 DSL 语法</p>
<h3 id="dsl-语法"> DSL 语法</h3>
<p>ACL 是使用 DSL 定义的，该 DSL 就是一个规则，描述了指定用户可以执行的操作，且是按照从左到右、从第一个到最后一个的顺序实施，因为有时规则的顺序对于理解用户的实际能力很重要</p>
<div><p>小贴士</p>
<p>DSL（domain specific language）是领域专用语言，其基本思想是「求专不求全」，不像通用目的语言那样目标范围涵盖一切软件问题，而是具有受限的表达，专门针对某一特定问题的计算机语言</p>
<ul>
<li>Java、Python、C 都是通用性编程语言，也就是我们可以用于多个不同的领域，普通应用编程</li>
<li>HTML、SQL 都算得上是领域专用语言，需要寄生在宿主语言中。比如 React 或者 Vue 支持的 JSX 语法都属于 DSL，「寄生」于前端 HTML 中</li>
</ul>
</div>
<p>以查看默认用户的 ACL 为例，默认情况下，只有一个用户定义，称为 <code>default</code>。我们可以使用 <a href="https://redis.io/commands/acl-list/" target="_blank" rel="noopener noreferrer"><code>ACL LIST</code></a> 命令来检查当前活动的 ACL 并验证新启动的，默认的 Redis 实例的配置是：</p>
<div><pre><code><span>[</span>root@VM-16-7-centos ~<span>]</span><span># redis-cli -h 127.0.0.1 -p 6379</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> acl list
<span>1</span><span>)</span> <span>"user default on nopass sanitize-payload ~* &amp;* +@all"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>解释一下返回值：</p>
<ul>
<li>第一个是固定单词 <code>user</code>，后面跟上用户名（此处是 <code>default</code>）</li>
<li>默认用户已配置为活动状态（<code>on</code>），不需要密码（<code>nopass</code>）</li>
<li>权限是访问所有可能的键（<code>~*</code>）和 发布/订阅（Pub/Sub）频道（<code>&amp;*</code>），并能够调用所有可能的命令（<code>+@all</code>）</li>
</ul>
<p>对于这个默认用户，具有 <code>nopass</code> 规则意味着新连接将自动与默认用户进行身份验证，而无需任何显式的 auth 调用</p>
<p>至于 ACL 规则用 DSL 怎么写，最后再讲，现在有个大概的概念就行。下面展开来讲两种配置方式</p>
<h3 id="使用-conf-配置-acl"> 使用 conf 配置 ACL</h3>
<p>我们之前使用 <code>requirepass</code> 给 <code>default</code> 用户设置密码默认就是使用的 conf 方式。并且 6.0 版本开始，在用之前方式给 <code>default</code> 用户配置密码后，再执行 <code>config rewrite</code> 重写配置，就会自动在 conf 文件最下面新增一行记录来配置 <code>default</code> 的密码和权限</p>
<p>使用 conf 文件配置 default 和其他用户的 ACL 权限，操作步骤如下：</p>
<h4 id="_1-第一步-在-conf-文件中配置-default-用户的密码"> 1）第一步，在 conf 文件中配置 <code>default</code> 用户的密码</h4>
<div><pre><code><span># The requirepass is not compatible with aclfile option and the ACL LOAD</span>
<span># command, these will cause requirepass to be ignored.</span>
<span>#</span>
requirepass <span>123456</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id="_2-第二步-重启-redis-服务-进入命令行执行-config-rewrite-命令"> 2）第二步，重启 redis 服务，进入命令行执行 <code>config rewrite</code> 命令</h4>
<div><pre><code><span>[</span>root@VM-16-7-centos ~<span>]</span><span># redis-cli -h 127.0.0.1 -p 6379</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> config rewrite
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这时候可以看到 conf 文件的最后面自动新增了 <code>default</code> 用户的 ACL，如下所示：</p>
<div><pre><code>user default on nopass sanitize-payload ~* <span>&amp;</span>* +@all
</code></pre>
<div><span>1</span><br></div></div><h4 id="_3-在-conf-文件中注释-aclfile-的路径配置-默认是注释的"> 3）在 conf 文件中注释 aclfile 的路径配置（默认是注释的）</h4>
<p>原因是因为两种配置方式（conf 方式和 aclfile 方式）是冲突的，只能开启一个。</p>
<div><div><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br></div><pre><code><span># Using an external ACL file</span>
<span>#</span>
<span># Instead of configuring users here in this file, it is possible to use</span>
<span># a stand-alone file just listing users. The two methods cannot be mixed:</span>
<span># if you configure users here and at the same time you activate the external</span>
<span># ACL file, the server will refuse to start.</span>
<span>#</span>
<span># The format of the external ACL user file is exactly the same as the</span>
<span># format that is used inside redis.conf to describe users.</span>
<span>#</span>
<span># aclfile /etc/redis/users.acl</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h4 id="_4-重启-redis-服务来加载配置"> 4）重启 Redis 服务来加载配置</h4>
<p>加载配置需要重启 Redis 服务。</p>
<h4 id="_5-查看新的-acl-list"> 5）查看新的 acl list</h4>
<div><pre><code><span>[</span>root@VM-16-7-centos ~<span>]</span><span># redis-cli -h 127.0.0.1 -p 6379</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> acl list
<span>1</span><span>)</span> <span>"user default on nopass sanitize-payload ~* &amp;* +@all"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>因此我们可以直接在 conf 配置文件中，使用类似上面 <code>default</code> 用户的这行 DSL 命令来设置用户权限，或者我们也可以配置外部 aclfile 配置权限</p>
<h3 id="使用外部-aclfile-配置-acl"> 使用外部 aclfile 配置 ACL</h3>
<blockquote>
<p>如果我们有较多的用户且希望有一个单独的配置文件时，可以使用这种方式</p>
</blockquote>
<p>配置 aclfile 需要先将 conf 中配置的 DSL 注释掉或直接删除，因为 Redis 不允许两种 ACL 管理方式同时使用，否则在启动 Redis的时候会报下面的错误：</p>
<div><pre><code><span># Configuring Redis with users defined in redis.conf and at the same setting an ACL file path is invalid. This setup is very likely to lead to configuration errors and security holes, please define either an ACL file or declare users directly in your redis.conf, but not both.</span>
</code></pre>
<div><span>1</span><br></div></div><p>使用外部 aclfile 文件配置 <code>default</code> 和其他用户的 ACL 权限，操作步骤如下：</p>
<h4 id="_1-第一步-注释-conf-文件中所有已授权的-acl-命令"> 1）第一步，注释 conf 文件中所有已授权的 ACL 命令</h4>
<p>如果先前是用 <code>config rewrite</code> 命令生成的 ACL 语句，那么它们一般是在 conf 文件最末尾，例如 <code>default</code> 用户的这行，把它注释掉：</p>
<div><pre><code><span># user default on nopass sanitize-payload ~* &amp;* +@all</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="_2-第二步-在-conf-文件中配置外部-aclfile-路径"> 2）第二步，在 conf 文件中配置外部 aclfile 路径</h4>
<ul>
<li>在 conf 文件中注释掉 <code>default</code> 用户的密码，因为开启 aclfile 之后，<code>requirepass</code> 的密码就失效了</li>
<li>在 conf 文件中配置 aclfile 的路径，然后创建该文件，否则重启 Redis 服务会报错找不到该文件</li>
</ul>
<div><div><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br></div><pre><code><span># Using an external ACL file</span>
<span>#</span>
<span># Instead of configuring users here in this file, it is possible to use</span>
<span># a stand-alone file just listing users. The two methods cannot be mixed:</span>
<span># if you configure users here and at the same time you activate the external</span>
<span># ACL file, the server will refuse to start.</span>
<span>#</span>
<span># The format of the external ACL user file is exactly the same as the</span>
<span># format that is used inside redis.conf to describe users.</span>
<span>#</span>
aclfile /usr/local/redis/acl/users.acl

<span># IMPORTANT NOTE: starting with Redis 6 "requirepass" is just a compatibility</span>
<span># layer on top of the new ACL system. The option effect will be just setting</span>
<span># the password for the default user. Clients will still authenticate using</span>
<span># AUTH &lt;password> as usually, or more explicitly with AUTH default &lt;password></span>
<span># if they follow the new protocol: both will work.</span>
<span>#</span>
<span># The requirepass is not compatible with aclfile option and the ACL LOAD</span>
<span># command, these will cause requirepass to be ignored.</span>
<span>#</span>
<span># requirepass 123456</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>新建一个文件夹 <code>acl/</code>，然后新建一个文件 <code>users.acl</code>，将用户权限相关的配置（DSL 语法）拷贝到 <code>users.acl</code> 中：</p>
<div><pre><code><span>cd</span> /usr/local/redis/
<span>mkdir</span> acl
<span>cd</span> acl
<span>vim</span> users.acl
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>然后将信息写入到配置文件中：</p>
<div><pre><code>user default on nopass sanitize-payload ~* <span>&amp;</span>* +@all
</code></pre>
<div><span>1</span><br></div></div><p>上面这段 DSL 是从前面复制的，由<code>config rewrite</code> 命令生成的。也就是有最高权限的 <code>default</code> 用户</p>
<h4 id="_3-第三步-重启-redis-服务来加载配置"> 3）第三步，重启 Redis 服务来加载配置</h4>
<p>加载配置需要重启 Redis 服务</p>
<p>PS：经测试，首次将 conf 方式改为 aclfile 方式，必须要重启 Redis 服务才行（否则会报错 <code>(error) ERR This Redis instance is not configured to use an ACL file.（此处省略 100 字）</code>）</p>
<p>而以后修改 <code>users.acl</code> 文件里面的 DSL 语句后，只需要在命令行执行 <code>acl load</code> 即可将将最新的 aclfile 中的权限加载至 Redis服务中）</p>
<h4 id="_4-查看新的-acl-list"> 4）查看新的 acl list</h4>
<div><pre><code><span>[</span>root@VM-16-7-centos ~<span>]</span><span># redis-cli -h 127.0.0.1 -p 6379</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> acl list
<span>1</span><span>)</span> <span>"user default on nopass sanitize-payload ~* &amp;* +@all"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="对比-conf-和-aclfile-两种方式"> 对比 conf 和 aclfile 两种方式</h3>
<p>在 conf 和 aclfile 两种方式中配置 DSL，官方更推荐使用 aclfile，因为如果在 conf 中配置了权限之后需要重启 redis 服务才能将配置的权限加载至 Redis 服务中来，但如果使用 aclfile 模式，可以调用 <code>acl load</code> 命令将 aclfile 中配置的 ACL 权限热加载进环境中，类似于 MySQL 中的 <code>flush privileges</code></p>
<p><svg id="SvgjsSvg1006" width="611" height="235" xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.com/svgjs"><defs id="SvgjsDefs1007"></defs><g id="SvgjsG1008" transform="translate(25,67)"><path id="SvgjsPath1009" d="M0 0L165.9999 0L165.9999 35.75 L0 35.75Z" stroke="rgba(201,208,227,1)" stroke-width="1" fill-opacity="1" fill="#f5f7fb"></path><path id="SvgjsPath1010" d="M165.9999 0L373.96259999999995 0L373.96259999999995 35.75 L165.9999 35.75Z" stroke="rgba(201,208,227,1)" stroke-width="1" fill-opacity="1" fill="#f5f7fb"></path><path id="SvgjsPath1011" d="M373.9626 0L561 0L561 35.75 L373.9626 35.75Z" stroke="rgba(201,208,227,1)" stroke-width="1" fill-opacity="1" fill="#f5f7fb"></path><path id="SvgjsPath1012" d="M0 35.75L165.9999 35.75L165.9999 71.5 L0 71.5Z" stroke="rgba(201,208,227,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><path id="SvgjsPath1013" d="M165.9999 35.75L373.96259999999995 35.75L373.96259999999995 71.5 L165.9999 71.5Z" stroke="rgba(201,208,227,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><path id="SvgjsPath1014" d="M373.9626 35.75L561 35.75L561 71.5 L373.9626 71.5Z" stroke="rgba(201,208,227,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><path id="SvgjsPath1015" d="M0 71.5L165.9999 71.5L165.9999 107.25 L0 107.25Z" stroke="rgba(201,208,227,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><path id="SvgjsPath1016" d="M165.9999 71.5L373.96259999999995 71.5L373.96259999999995 107.25 L165.9999 107.25Z" stroke="rgba(201,208,227,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><path id="SvgjsPath1017" d="M373.9626 71.5L561 71.5L561 107.25 L373.9626 107.25Z" stroke="rgba(201,208,227,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><path id="SvgjsPath1018" d="M0 107.25L165.9999 107.25L165.9999 143 L0 143Z" stroke="rgba(201,208,227,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><path id="SvgjsPath1019" d="M165.9999 107.25L373.96259999999995 107.25L373.96259999999995 143 L165.9999 143Z" stroke="rgba(201,208,227,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><path id="SvgjsPath1020" d="M373.9626 107.25L561 107.25L561 143 L373.9626 143Z" stroke="rgba(201,208,227,1)" stroke-width="1" fill-opacity="1" fill="#ffffff"></path><g id="SvgjsG1021"><text id="SvgjsText1022" font-family="微软雅黑" text-anchor="start" font-size="16px" width="166px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="start" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="3.875" transform="rotate(0)"></text></g><g id="SvgjsG1023"><text id="SvgjsText1024" font-family="微软雅黑" text-anchor="start" font-size="16px" width="208px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="start" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="3.875" transform="rotate(0)"><tspan id="SvgjsTspan1025" dy="20" x="165.9999"><tspan id="SvgjsTspan1026" style="text-decoration:;">  redis.conf</tspan></tspan></text></g><g id="SvgjsG1027"><text id="SvgjsText1028" font-family="微软雅黑" text-anchor="start" font-size="16px" width="188px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="start" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="3.875" transform="rotate(0)"><tspan id="SvgjsTspan1029" dy="20" x="373.9626"><tspan id="SvgjsTspan1030" style="text-decoration:;">  users.acl</tspan></tspan></text></g><g id="SvgjsG1031"><text id="SvgjsText1032" font-family="微软雅黑" text-anchor="start" font-size="16px" width="166px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="start" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="39.625" transform="rotate(0)"><tspan id="SvgjsTspan1033" dy="20" x="0"><tspan id="SvgjsTspan1034" style="text-decoration:;">  配置方式</tspan></tspan></text></g><g id="SvgjsG1035"><text id="SvgjsText1036" font-family="微软雅黑" text-anchor="start" font-size="16px" width="208px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="start" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="39.625" transform="rotate(0)"><tspan id="SvgjsTspan1037" dy="20" x="165.9999"><tspan id="SvgjsTspan1038" style="text-decoration:;">  DSL</tspan></tspan></text></g><g id="SvgjsG1039"><text id="SvgjsText1040" font-family="微软雅黑" text-anchor="start" font-size="16px" width="188px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="start" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="39.625" transform="rotate(0)"><tspan id="SvgjsTspan1041" dy="20" x="373.9626"><tspan id="SvgjsTspan1042" style="text-decoration:;">  DSL</tspan></tspan></text></g><g id="SvgjsG1043"><text id="SvgjsText1044" font-family="微软雅黑" text-anchor="start" font-size="16px" width="166px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="start" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="75.375" transform="rotate(0)"><tspan id="SvgjsTspan1045" dy="20" x="0"><tspan id="SvgjsTspan1046" style="text-decoration:;">  加载 ACL 配置</tspan></tspan></text></g><g id="SvgjsG1047"><text id="SvgjsText1048" font-family="微软雅黑" text-anchor="start" font-size="16px" width="208px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="start" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="75.375" transform="rotate(0)"><tspan id="SvgjsTspan1049" dy="20" x="165.9999"><tspan id="SvgjsTspan1050" style="text-decoration:;">  重启 Redis 服务</tspan></tspan></text></g><g id="SvgjsG1051"><text id="SvgjsText1052" font-family="微软雅黑" text-anchor="start" font-size="16px" width="188px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="start" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="75.375" transform="rotate(0)"><tspan id="SvgjsTspan1053" dy="20" x="373.9626"><tspan id="SvgjsTspan1054" style="text-decoration:;">  ACL LOAD 命令</tspan></tspan></text></g><g id="SvgjsG1055"><text id="SvgjsText1056" font-family="微软雅黑" text-anchor="start" font-size="16px" width="166px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="start" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="111.125" transform="rotate(0)"><tspan id="SvgjsTspan1057" dy="20" x="0"><tspan id="SvgjsTspan1058" style="text-decoration:;">  持久化 ACL 配置</tspan></tspan></text></g><g id="SvgjsG1059"><text id="SvgjsText1060" font-family="微软雅黑" text-anchor="start" font-size="16px" width="208px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="start" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="111.125" transform="rotate(0)"><tspan id="SvgjsTspan1061" dy="20" x="165.9999"><tspan id="SvgjsTspan1062" style="text-decoration:;">  CONFIG REWRITE 命令</tspan></tspan></text></g><g id="SvgjsG1063"><text id="SvgjsText1064" font-family="微软雅黑" text-anchor="start" font-size="16px" width="188px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="start" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="111.125" transform="rotate(0)"><tspan id="SvgjsTspan1065" dy="20" x="373.9626"><tspan id="SvgjsTspan1066" style="text-decoration:;">  ACL SAVE 命令</tspan></tspan></text></g></g><g id="SvgjsG1067" transform="translate(168,25)"><path id="SvgjsPath1068" d="M 0 0L 250 0L 250 39L 0 39Z" stroke="none" fill="none"></path><g id="SvgjsG1069"><text id="SvgjsText1070" font-family="微软雅黑" text-anchor="middle" font-size="16px" width="250px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="16px" weight="400" font-style="" opacity="1" y="5.5" transform="rotate(0)"><tspan id="SvgjsTspan1071" dy="20" x="125"><tspan id="SvgjsTspan1072" style="text-decoration:;">对比 conf 和 aclfile 两种方式</tspan></tspan></text></g></g></svg></p>
<h2 id="通过命令行来管理用户"> 通过命令行来管理用户</h2>
<p>上面可以看到，我们在安装好 Redis 后，需要通过编辑文件来选择使用哪种 ACL 模式（conf 还是外部 aclfile）。并且我们知道无论哪种方式，里面都是存一些 DSL 语句，那么自然我们可以直接在配置文件中配置各用户的 ACL 权限，但每次编辑完后都需要执行 <code>ACL LOAD</code> 或者重启 Redis 服务才能生效</p>
<p>事实上我们可以直接在命令行下配置 ACL，<strong>在命令行模式下配置的权限无需重启服务即可生效</strong></p>
<p>只是我们在命令行模式下配置 ACL 后，必须要将其持久化到 aclfile 或者 conf 文件中，因为只有将权限持久化，下次重启才会自动加载该权限，<strong>如果忘记持久化，一旦服务宕机或重启，该权限就会丢失</strong></p>
<h3 id="持久化的方式"> 持久化的方式</h3>
<div><pre><code><span># 如果使用 conf 模式，将 ACL 权限持久化到 redis.conf 文件中使用下面的命令：</span>
config rewrite

<span># 如果使用 aclfile 模式，将 ACL 权限持久化到 users.acl 文件中使用下面的命令：</span>
acl save
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>下面看如何使用命令来创建、编辑用户以及它们的 ACL。</p>
<h3 id="增删改查用户"> 增删改查用户</h3>
<h4 id="_1-创建和修改用户"> 1）创建和修改用户</h4>
<p>使用 <a href="https://redis.io/commands/acl-setuser/" target="_blank" rel="noopener noreferrer"><code>ACL SETUSER</code></a> 命令来创建和编辑用户 ACL</p>
<div><pre><code><span># username 区分大小写 </span>
<span># 若用户不存在，则按默认规则创建用户，并为其增加 &lt;rules>。若用户存在则在已有规则上增加 &lt;rules></span>
ACL SETUSER <span>&lt;</span>username<span>></span> <span>&lt;</span>rules<span>></span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>默认规则下新增的用户处于非活跃状态，且没有密码，同时也没有任何命令和 key 的权限：</p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> acl setuser zhangsan
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> acl list
<span>1</span><span>)</span> <span>"user default on nopass sanitize-payload ~* &amp;* +@all"</span>
<span>2</span><span>)</span> <span>"user zhangsan off resetchannels -@all"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>所以我们可以在新增用户时，指定一些规则，包含密码和权限等：</p>
<div><pre><code><span># 创建 lisi 用户，on 为活跃状态，密码为 123456，允许对所有 demo 开头的 key 使用 get 和 set 命令</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> acl setuser lisi on <span>></span><span>123456</span> ~demo* +get +set

<span># 让之前创建的 zhangsan 用户可用，并给它新增一个密码 123456</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> acl setuser zhangsan on <span>></span><span>123456</span>

<span># 为 zhangsan 用户新增 list 类别下所有命令的权限</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> acl setuser zhangsan on +@list
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>查看现在的 <code>acl list</code>，可以发现密码都是一个 sha256 码的字符串，不是明文存储，还是比较安全的：</p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> acl list
<span>1</span><span>)</span> <span>"user default on nopass sanitize-payload ~* &amp;* +@all"</span>
<span>2</span><span>)</span> <span>"user lisi on #8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 ~demo* resetchannels -@all +get +set"</span>
<span>3</span><span>)</span> <span>"user zhangsan on #8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 resetchannels -@all +@list"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>需要注意的是，多次调用 <code>SETUSER</code> 不会重置用户，而只会将 ACL 规则应用于现有用户。什么意思呢？</p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> acl setuser zhangsan +get
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> acl setuser zhangsan +set
OK
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>以上两次调用 <code>SETUSER</code> 将导致 <code>zhangsan</code> 这个用户能够调用 <a href="https://redis.io/commands/get/" target="_blank" rel="noopener noreferrer"><code>GET</code></a> 和 <a href="https://redis.io/commands/set/" target="_blank" rel="noopener noreferrer"><code>SET</code></a></p>
<h4 id="_2-查询用户"> 2）查询用户</h4>
<div><pre><code><span># 查看所有用户名</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> acl <span>users</span>

<span># 查看所有用户的 acl 信息</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> acl list

<span># 查看当前登录的用户名</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> acl <span>whoami</span>

<span># 查看指定用户的 ACL 权限</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> acl getuser <span>&lt;</span>username<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h4 id="_3-删除用户"> 3）删除用户</h4>
<div><pre><code><span># 删除指定用户</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> acl deluser <span>&lt;</span>username<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="登录和切换指定用户"> 登录和切换指定用户</h3>
<h4 id="_1-登录指定用户"> 1）登录指定用户</h4>
<p>对于用 ACL 管理的用户，需要使用 <code>redis-cli --user xxx --pass yyy</code> 来登陆：</p>
<div><pre><code><span>[</span>root@VM-16-7-centos ~<span>]</span><span># redis-cli -h 127.0.0.1 -p 6379 --user lisi --pass 123456</span>
Warning: Using a password with <span>'-a'</span> or <span>'-u'</span> option on the <span>command</span> line interface may not be safe.
<span>127.0</span>.0.1:637<span><span>9</span>></span> acl <span>whoami</span>
<span>(</span>error<span>)</span> NOPERM this user has no permissions to run the <span>'acl|whoami'</span> <span>command</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span>

<span>[</span>root@VM-16-7-centos ~<span>]</span><span># redis-cli -h 127.0.0.1 -p 6379 --user wangwu --pass 123456</span>
Warning: Using a password with <span>'-a'</span> or <span>'-u'</span> option on the <span>command</span> line interface may not be safe.
<span>127.0</span>.0.1:637<span><span>9</span>></span> acl <span>whoami</span>
<span>"wangwu"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h4 id="_2-切换到指定用户"> 2）切换到指定用户</h4>
<div><pre><code><span># 使用 auth 命令切换用户</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> auth <span>&lt;</span>username<span>></span> <span>&lt;</span>password<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="热加载命令"> 热加载命令</h3>
<p>如果直接在 aclfile 中修改或新增 ACL 权限，修改之后不会立刻生效，需要执行如下命令将配置热加载至 Redis 服务中</p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> acl load
</code></pre>
<div><span>1</span><br></div></div><h3 id="持久化命令"> 持久化命令</h3>
<p>如果是通过命令行修改或新增 ACL 权限，需要将其持久化到配置文件中，否则在重启 Redis 服务后，这些 ACL 权限就会丢失</p>
<div><pre><code><span># 如果使用的是 aclfile 方式，将 ACL 权限持久化到磁盘的 aclfile 中</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> acl save

<span># 如果使用的是 conf 方式，将 ACL 权限持久化到 redis.conf 中</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> config rewrite
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="查看命令类别-用于授权"> 查看命令类别，用于授权</h3>
<p>命令类别的出现就是为了方便我们定义用户权限。因为如果通过一个接一个地指定所有命令来设置用户 ACL 确实很烦人，所以我们这样做：</p>
<div><pre><code><span># 通过 +@all 和 -@dangerous，我们包含了所有命令，然后在 Redis 命令表中删除了所有标记为危险的命令</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> acl setuser zhangsan on +@all -@dangerous <span>></span><span>123456</span><span>..</span>. ~*
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>那么有哪些命令类别可供选择呢？可以用如下命令进行查看：</p>
<div><pre><code><span># acl cat 显示所有的命令类别</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> acl <span>cat</span>
 <span>1</span><span>)</span> <span>"keyspace"</span>
 <span>2</span><span>)</span> <span>"read"</span>
 <span>3</span><span>)</span> <span>"write"</span>
 <span>4</span><span>)</span> <span>"set"</span>
 <span>5</span><span>)</span> <span>"sortedset"</span>
 <span>6</span><span>)</span> <span>"list"</span>
 <span>7</span><span>)</span> <span>"hash"</span>
 <span>8</span><span>)</span> <span>"string"</span>
 <span>9</span><span>)</span> <span>"bitmap"</span>
<span>10</span><span>)</span> <span>"hyperloglog"</span>
<span>11</span><span>)</span> <span>"geo"</span>
<span>12</span><span>)</span> <span>"stream"</span>
<span>13</span><span>)</span> <span>"pubsub"</span>
<span>14</span><span>)</span> <span>"admin"</span>
<span>15</span><span>)</span> <span>"fast"</span>
<span>16</span><span>)</span> <span>"slow"</span>
<span>17</span><span>)</span> <span>"blocking"</span>
<span>18</span><span>)</span> <span>"dangerous"</span>
<span>19</span><span>)</span> <span>"connection"</span>
<span>20</span><span>)</span> <span>"transaction"</span>
<span>21</span><span>)</span> <span>"scripting"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>每一个命令类别具体包含了哪些命令呢？可以用如下命令进行查看：</p>
<div><pre><code><span># acl cat &lt;category> 显示指定类别下的所有命令</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> acl <span>cat</span> list
 <span>1</span><span>)</span> <span>"rpushx"</span>
 <span>2</span><span>)</span> <span>"lrange"</span>
 <span>3</span><span>)</span> <span>"lindex"</span>
 <span>4</span><span>)</span> <span>"blpop"</span>
 <span>5</span><span>)</span> <span>"lpop"</span>
 <span>6</span><span>)</span> <span>"brpoplpush"</span>
 <span>7</span><span>)</span> <span>"lset"</span>
 <span>8</span><span>)</span> <span>"rpoplpush"</span>
 <span>9</span><span>)</span> <span>"lpos"</span>
<span>10</span><span>)</span> <span>"lrem"</span>
<span>11</span><span>)</span> <span>"lpushx"</span>
<span>12</span><span>)</span> <span>"llen"</span>
<span>13</span><span>)</span> <span>"blmove"</span>
<span>14</span><span>)</span> <span>"brpop"</span>
<span>15</span><span>)</span> <span>"sort"</span>
<span>16</span><span>)</span> <span>"rpop"</span>
<span>17</span><span>)</span> <span>"ltrim"</span>
<span>18</span><span>)</span> <span>"sort_ro"</span>
<span>19</span><span>)</span> <span>"rpush"</span>
<span>20</span><span>)</span> <span>"blmpop"</span>
<span>21</span><span>)</span> <span>"lmove"</span>
<span>22</span><span>)</span> <span>"lmpop"</span>
<span>23</span><span>)</span> <span>"lpush"</span>
<span>24</span><span>)</span> <span>"linsert"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h3 id="其他常用-acl-命令"> 其他常用 ACL 命令</h3>
<div><pre><code><span># 查看 ACL 安全日志</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> acl log

<span># 查看 help 文档</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> acl <span>help</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="acl-规则"> ACL 规则</h2>
<p>前面大量介绍了 ACL 的一些命令，ACL 是使用 DSL（Domain specific language）定义的，一个 DSL 中最核心也是最难记忆的就是规则的写法</p>
<p>以下是整理的一些 ACL 规则的列表，某些规则只是一个单词，用于激活或删除标志或对用户 ACL 执行更改。其他规则是与命令或类别名称、键模式等、关联的字符前缀</p>
<h3 id="启用和禁用用户"> 启用和禁用用户</h3>
<ul>
<li><code>on</code>：启用用户，可以以该用户身份进行认证</li>
<li><code>off</code>：禁用用户，不再可以使用此用户进行身份验证，但是已经通过身份验证的连接仍然可以使用</li>
</ul>
<h3 id="允许和禁止调用命令"> 允许和禁止调用命令</h3>
<ul>
<li><code>+&lt;command&gt;</code>：将命令添加到用户可以调用的命令列表中</li>
<li><code>-&lt;command&gt;</code>：将命令从用户可以调用的命令列表中移除</li>
<li><code>+@&lt;category&gt;</code>：允许用户调用 <code>&lt;category&gt;</code> 类别中的所有命令，有效类别为 <code>@admin</code>，<code>@set</code>，<code>@sortedset</code> 等，可通过调用 <a href="https://redis.io/commands/acl-cat/" target="_blank" rel="noopener noreferrer"><code>ACL CAT</code></a> 命令查看完整列表。特殊类别 <code>@all</code> 表示所有命令，包括当前和未来版本中存在的所有命令</li>
<li><code>-@&lt;category&gt;</code>：禁止用户调用 <code>&lt;category&gt;</code> 类别中的所有命令</li>
<li><code>+&lt;command&gt;|subcommand</code>：允许使用已禁用命令的特定子命令</li>
<li><code>allcommands</code>：<code>+@all</code> 的别名，包括当前存在的命令以及将来通过模块加载的所有命令</li>
<li><code>nocommands</code>：<code>-@all</code> 的别名，禁止调用所有命令</li>
</ul>
<h3 id="允许和禁止访问某些-key"> 允许和禁止访问某些 Key</h3>
<ul>
<li><code>~&lt;pattern&gt;</code>：添加可以在命令中提及的键模式。例如 <code>~*</code> 允许所有键</li>
<li><code>allkeys</code>：<code>~*</code> 的别名</li>
<li><code>resetkeys</code>：刷新允许的键模式列表。例如 ACL <code>~foo:* ~bar:* resetkeys ~objects:*</code>，将导致客户端只能访问与模式 <code>objects:*</code> 匹配的键</li>
</ul>
<h3 id="为用户配置有效密码"> 为用户配置有效密码</h3>
<ul>
<li><code>&gt;&lt;password&gt;</code>：将此密码添加到用户的有效密码列表中。例如，<code>&gt;mypass</code>将 <code>mypass</code> 添加到有效密码列表中。该命令会清除用户的 <code>nopass</code> 标记。每个用户可以有任意数量的有效密码</li>
<li><code>&lt;&lt;password&gt;</code>：从有效密码列表中删除此密码。若该用户的有效密码列表中没有此密码则会返回错误信息。</li>
<li><code>#&lt;hash&gt;</code>：将此 SHA-256 哈希值添加到用户的有效密码列表中。该哈希值将与为 ACL 用户输入的密码的哈希值进行比较。允许用户将哈希存储在 users.acl 文件中，而不是存储明文密码。仅接受 SHA-256 哈希值，因为密码哈希必须为 64 个字符且小写的十六进制字符</li>
<li><code>!&lt;hash&gt;</code>：从有效密码列表中删除该哈希值。当不知道哈希值对应的明文是什么时很有用</li>
<li><code>nopass</code>：移除该用户已设置的所有密码，并将该用户标记为 <code>nopass</code> 无密码状态：任何密码都可以登录。<code>resetpass</code> 命令可以清除 <code>nopass</code> 这种状态</li>
<li><code>resetpass</code>：清空该用户的所有密码列表，而且移除 <code>nopass</code> 状态。<code>resetpass</code> 之后用户没有关联的密码同时也无法使用无密码登录，因此 <code>resetpass</code> 之后必须添加密码或改为 <code>nopass</code> 状态才能正常登录</li>
<li><code>reset</code>：重置用户状态为初始状态。执行以下操作 <code>resetpass</code>，<code>resetkeys</code>，<code>off</code>，<code>-@all</code></li>
</ul>
<h2 id="参考文档"> 参考文档</h2>
<ul>
<li><a href="https://redis.io/docs/manual/security/acl/" target="_blank" rel="noopener noreferrer">官方文档 - ACL</a></li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-26T12:16:43.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">持久化之 AOF</title>
    <id>https://www.snowji.cn/databases/redis/aof/</id>
    <link href="https://www.snowji.cn/databases/redis/aof/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="持久化之-aof"> 持久化之 AOF</h1>
<h2 id="什么是-aof"> 什么是 AOF</h2>
<p>AOF：Append Only File</p>
<ul>
<li>以日志的形式记录每个写的操作</li>
<li>只许追加文件，但不可以改写文件</li>
<li>Redis 启动时会读取这个文件，将所有指令重新执行</li>
<li>默认不开启，需要修改配置文件手动开启</li>
<li>AOF 保存的是 appendonly.aof 文件</li>
</ul>
<div><pre><code><span># Please check https://redis.io/topics/persistence for more information.</span>
appendonly no

appendfilename <span>"appendonly.aof"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>修改配置文件后，重启 Redis 即可</p>
<p>默认文件路径在 appendonlydir 目录下</p>
<p><img src="./images/aof1.png" alt="aof" /></p>
<h2 id="实现原理"> 实现原理</h2>
<p><img src="./images/aof3.png" alt="aof" /></p>
<p>连接 Redis 进行一些操作后，查看该文件:</p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> <span>set</span> key1 v1
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> <span>set</span> key2 v2
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> <span>set</span> key3 v3
OK
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><img src="./images/aof2.png" alt="aof" /></p>
<div><p>注意</p>
<p>如果 AOF 文件有错误，这时 Redis 是启动不成功的，需要修复这个 AOF 文件</p>
<p>Redis 给我们提供了一个工具 <code>redis-check-aof --fix</code></p>
</div>
<p><img src="./images/aof4.png" alt="aof" /></p>
<p>文件正常后就可以正常启动</p>
<h2 id="aof-优缺点"> AOF 优缺点</h2>
<div><pre><code>appendonly no                <span>#默认是不开启 aof模式的，默认是使用 rdb 方式持久化的，在大部分所有的情况下，rdb 完全够用！</span>
appendfilename <span>"appendonly.aof"</span>    <span>#持久化的文件的名字</span>
<span># appendfsync always               #每次修改都会 sync，消耗性能</span>
appendfsync everysec               <span>#每秒执行一次 sync，可能会丢失这 1s 的数据！</span>
<span># appendfsync no                   #不执行 sync，这个时候操作系统自己同步数据，速度最快！</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>优点</strong>：</p>
<ul>
<li>每一次修改都会同步，文件的完整性会更加好</li>
<li>没秒同步一次，可能会丢失一秒的数据</li>
<li>从不同步，效率最高</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>相对于数据文件来说，AOF 远远大于 RDB，修复速度比 RDB 慢！</li>
<li>AOF 运行效率也要比  RDB 慢，所以我们redis默认的配置就是 RDB 持久化</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">基本命令</title>
    <id>https://www.snowji.cn/databases/redis/basic-commands/</id>
    <link href="https://www.snowji.cn/databases/redis/basic-commands/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="基本命令"> 基本命令</h1>
<h2 id="操作数据库"> 操作数据库</h2>
<ul>
<li>Redis 默认有 16 个数据库，为 DB 0~DB 15，可以通过 conf 文件查看</li>
<li>默认使用第 0 个</li>
</ul>
<div><pre><code># Set the number of databases. The default database is DB 0, you can select
# a different one on a per-connection basis using SELECT &lt;dbid&gt; where
# dbid is a number between 0 and &#39;databases&#39;-1
databases 16
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="切换数据库"> 切换数据库</h3>
<p><strong>语法</strong>:</p>
<div><pre><code><span>select</span> n
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> <span>select</span> <span>2</span>
OK
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="查看数据库大小"> 查看数据库大小</h3>
<p>数据库大小与 key 的数量有关</p>
<p><strong>语法</strong>:</p>
<div><pre><code>dbsize
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>127.0</span>.0.1:6379<span>[</span><span>2</span><span>]</span><span>></span> DBSIZE
<span>(</span>integer<span>)</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="键值操作"> 键值操作</h2>
<div><p>注意</p>
<p>不同数据库之间数据是不能互通的</p>
</div>
<div><pre><code><span>127.0</span>.0.1:6379<span>[</span><span>2</span><span>]</span><span>></span> <span>set</span> name redis   <span># 设置键 name</span>
OK
<span>127.0</span>.0.1:6379<span>[</span><span>2</span><span>]</span><span>></span> keys *			<span># 查看所有键值</span>
<span>1</span><span>)</span> <span>"name"</span>
<span>127.0</span>.0.1:6379<span>[</span><span>2</span><span>]</span><span>></span> DBSIZE           <span># 查看数据库大小</span>
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:6379<span>[</span><span>2</span><span>]</span><span>></span> flushdb         <span># 清除当前数据库数据</span>
OK
<span>127.0</span>.0.1:6379<span>[</span><span>2</span><span>]</span><span>></span> get name
<span>(</span>nil<span>)</span>
<span>127.0</span>.0.1:6379<span>[</span><span>2</span><span>]</span><span>></span> <span>select</span> <span>0</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> <span>set</span> name <span>123</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> flushall         <span># 清除所有数据库数据</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> get name
<span>(</span>nil<span>)</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><ul>
<li>exists key：判断键是否存在</li>
<li>del key：删除键值对</li>
<li>move key db：将键值对移动到指定数据库</li>
<li>expire key second：设置键值对的过期时间</li>
<li>type key：查看 value 的数据类型</li>
</ul>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> keys * <span># 查看当前数据库所有key</span>
<span>(</span>empty list or <span>set</span><span>)</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> <span>set</span> name qinjiang <span># set key</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> <span>set</span> age <span>20</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> keys *
<span>1</span><span>)</span> <span>"age"</span>
<span>2</span><span>)</span> <span>"name"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> move age <span>1</span> <span># 将键值对移动到指定数据库</span>
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> EXISTS age <span># 判断键是否存在</span>
<span>(</span>integer<span>)</span> <span>0</span> <span># 不存在</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> EXISTS name
<span>(</span>integer<span>)</span> <span>1</span> <span># 存在</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> SELECT <span>1</span>
OK
<span>127.0</span>.0.1:6379<span>[</span><span>1</span><span>]</span><span>></span> keys *
<span>1</span><span>)</span> <span>"age"</span>
<span>127.0</span>.0.1:6379<span>[</span><span>1</span><span>]</span><span>></span> del age <span># 删除键值对</span>
<span>(</span>integer<span>)</span> <span>1</span> <span># 删除个数</span>


<span>127.0</span>.0.1:637<span><span>9</span>></span> <span>set</span> age <span>20</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> EXPIRE age <span>15</span> <span># 设置键值对的过期时间</span>

<span>(</span>integer<span>)</span> <span>1</span> <span># 设置成功 开始计数</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> ttl age <span># 查看key的过期剩余时间</span>
<span>(</span>integer<span>)</span> <span>13</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> ttl age
<span>(</span>integer<span>)</span> <span>11</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> ttl age
<span>(</span>integer<span>)</span> <span>9</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> ttl age
<span>(</span>integer<span>)</span> -2 <span># -2 表示key过期，-1表示key未设置过期时间</span>

<span>127.0</span>.0.1:637<span><span>9</span>></span> get age <span># 过期的key 会被自动delete</span>
<span>(</span>nil<span>)</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> keys *
<span>1</span><span>)</span> <span>"name"</span>

<span>127.0</span>.0.1:637<span><span>9</span>></span> <span>type</span> name <span># 查看value的数据类型</span>
string

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><p><strong>关于 TTL 命令</strong>:</p>
<p>Redis 的 key，通过 TTL 命令返回 key 的过期时间，一般来说有3种：</p>
<ul>
<li>当前 key 没有设置过期时间，所以会返回 -1</li>
<li>当前 key 有设置过期时间，而且 key 已经过期，所以会返回 -2</li>
<li>当前 key 有设置过期时间，且 key 还没有过期，故会返回 key 的正常剩余时间</li>
<li>关于重命名 RENAME 和 RENAMENX</li>
</ul>
<p>RENAME key newkey 修改 key 的名称
RENAMENX key newkey 仅当 newkey 不存在时，将 key 改名为 newkey</p>
<h2 id="参考文档"> 参考文档</h2>
<p><a href="https://www.redis.net.cn/order/" target="_blank" rel="noopener noreferrer">命令</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">redis.conf 详解</title>
    <id>https://www.snowji.cn/databases/redis/config/</id>
    <link href="https://www.snowji.cn/databases/redis/config/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="redis-conf-详解"> redis.conf 详解</h1>
<p>了解配置文件，能更好的对 Redis 进行配置</p>
<h2 id="容量单位"> 容量单位</h2>
<p>不区分大小写</p>
<div><pre><code><span># 1k => 1000 bytes</span>
<span># 1kb => 1024 bytes</span>
<span># 1m => 1000000 bytes</span>
<span># 1mb => 1024*1024 bytes</span>
<span># 1g => 1000000000 bytes</span>
<span># 1gb => 1024*1024*1024 bytes</span>
<span>#</span>
<span># units are case insensitive so 1GB 1Gb 1gB are all the same.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="include"> include</h2>
<p>可以使用 include 组合多个配置</p>
<div><pre><code><span># include /path/to/local.conf</span>
<span># include /path/to/other.conf</span>
<span># include /path/to/fragments/*.conf</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="network-网络配置"> network 网络配置</h2>
<div><pre><code><span># 绑定 ip</span>
<span>bind</span> <span>127.0</span>.0.1 -::1
<span># 保护模式</span>
protected-mode <span>yes</span>
<span># 端口，配置集群时可以在此设置端口号</span>
port <span>6379</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="general-通用配置"> general 通用配置</h2>
<div><pre><code><span># 以守护进程的方式运行，默认是 no</span>
daemonize <span>yes</span> 
<span># 如果以后台的方式运行，我们就需要指定一个 pid 文件</span>
pidfile /var/run/redis_6379.pid   
<span># 日志</span>
<span># 日志级别</span>
<span># Specify the server verbosity level.</span>
<span># This can be one of:</span>
<span># debug (a lot of information, useful for development/testing)</span>
<span># verbose (many rarely useful info, but not a mess like the debug level)</span>
<span># notice (moderately verbose, what you want in production probably)  生产环境</span>
<span># warning (only very important / critical messages are logged)</span>
loglevel notice 
<span># 日志文件位置</span>
logfile <span>""</span>
<span># 数据库的容量，默认是 16 个</span>
databases <span>16</span>
<span># 是否总是显示 logo</span>
always-show-logo <span>yes</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id="snapshotting-持久化"> SNAPSHOTTING 持久化</h2>
<ul>
<li>在规定的时间内，执行了多少次操作，则会持久化到文件 .rdb.aof</li>
<li>Redis 是内存数据库，如果没有持久化，那么数据断电及失</li>
<li>持久化方式：RDB、AOF</li>
</ul>
<p>RDB（默认不开启）:</p>
<div><pre><code><span># 如果 3600s 内至少一个 key 进行了修改，就就行持久化，如果 300s 内有至少 10 个 key 进行了修改，就进行持久化......</span>
<span># save 3600 1 300 100 60 10000</span>

<span>#持久化如果出错，是否还需要继续工作！</span>
stop-writes-on-bgsave-error <span>yes</span>

<span>#是否压缩rdb文件，需要消耗一些cpu资源！</span>
rdbcompression <span>yes</span>

<span>#保存rdb文件的时候，进行错误的检查校验！</span>
rdbchecksum <span>yes</span>

<span># rdb 的文件名</span>
dbfilename dump.rdb

<span>#rdb 文件保存的目录！</span>
<span>dir</span> ./
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id="replication-主从复制"> REPLICATION 主从复制</h2>
<p>后面在主从复制时详解</p>
<div><pre><code><span>################################# REPLICATION #################################</span>

<span># Master-Replica replication. Use replicaof to make a Redis instance a copy of</span>
<span># another Redis server. A few things to understand ASAP about Redis replication.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="security-中进行密码设置"> Security 中进行密码设置</h2>
<p>配置文件中设置</p>
<div><pre><code><span># 设置密码，默认密码没有开启</span>
<span># requirepass foobared</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>命令行设置密码</p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span>ping
PONG
<span>127.0</span>.0.1:637<span><span>9</span>></span>config get requirepass          <span>#获取 redis的密码</span>
<span>1</span><span>)</span> <span>"requirepass"</span>
<span>2</span><span>)</span> <span>""</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span>config <span>set</span> requirepass <span>"123456"</span>             <span>#设置redis的密码</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span>config get requirepass           <span>#发现所有的命令都没有权限了</span>
<span>(</span>error<span>)</span>NOAUTH Authentication required.
<span>127.0</span>.0.1:637<span><span>9</span>></span>ping
<span>(</span>error<span>)</span>NOAUTH Authentication required.
<span>127.0</span>.0.1:637<span><span>9</span>></span>auth <span>123456</span>                     <span>#使用密码进行登录！</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span>config get requirepass
<span>1</span><span>)</span><span>"requirepass"</span>
<span>2</span><span>)</span><span>"123456"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="clients-客户端限制"> CLIENTS 客户端限制</h2>
<div><pre><code>maxclients <span>10000</span>              <span># 设置能连接上 Redis 的最大客户端的数量</span>
maxmemory  <span>&lt;</span>bytes<span>></span>            <span># Redis 配置最大的内存容量</span>
maxmemory-policy noeviction   <span># 内存到达上限之后的处理策略</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>maxmemory-policy 六种方式:</p>
<ul>
<li>1、volatile-lru：只对设置了过期时间的 key 进行 LRU（默认值）</li>
<li>2、allkeys-lru：删除 lru 算法的 key</li>
<li>3、volatile-random：随机删除即将过期 key</li>
<li>4、allkeys-random：随机删除</li>
<li>5、volatile-ttl：删除即将过期的</li>
<li>6、noeviction：永不过期，返回错误</li>
</ul>
<p>设置方式：</p>
<div><pre><code>config <span>set</span> maxmemory-policy volatile-lru
</code></pre>
<div><span>1</span><br></div></div><h2 id="append-only-mode"> APPEND ONLY MODE</h2>
<div><pre><code>appendonly no                <span>#默认是不开启 aof模式的，默认是使用 rdb 方式持久化的，在大部分所有的情况下，rdb 完全够用！</span>
appendfilename <span>"appendonly.aof"</span>    <span>#持久化的文件的名字</span>
<span># appendfsync always               #每次修改都会 sync，消耗性能</span>
appendfsync everysec               <span>#每秒执行一次 sync，可能会丢失这 1s 的数据！</span>
<span># appendfsync no                   #不执行 sync，这个时候操作系统自己同步数据，速度最快！</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>具体的配置，在持久化中详解</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">缓存穿透与雪崩</title>
    <id>https://www.snowji.cn/databases/redis/cache/</id>
    <link href="https://www.snowji.cn/databases/redis/cache/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="缓存穿透与雪崩"> 缓存穿透与雪崩</h1>
<p>Redis 缓存的使用，极大的提升了数据查询方面的性能和效率</p>
<p>同时也带来了一些问题：</p>
<ul>
<li>
<p>其中最严重的就是数据一致性问题，如果对数据的一致性要求很高，就不能使用缓存</p>
</li>
<li>
<p>另外典型的问题：缓存穿透、缓存击穿和缓存雪崩</p>
</li>
</ul>
<h2 id="缓存穿透"> 缓存穿透</h2>
<h3 id="什么是缓存穿透"> 什么是缓存穿透</h3>
<p>一般在数据库之前都会有一个缓存</p>
<p><img src="./images/cache1.png" alt="cache" /></p>
<ul>
<li>
<p>默认情况下，用户请求数据时，会先在缓存中查找</p>
</li>
<li>
<p>若在缓存中没找到，再去数据库查找</p>
</li>
<li>
<p>数量少时可能问题不大，一旦大量的请求数据(如秒杀场景)缓存中都没有命中，就会全部转移到数据库上，给数据库造成极大的压力，可能导致其崩溃</p>
</li>
</ul>
<div><p>总结</p>
<p>缓存穿透的主要原因就是：<strong>查不到</strong></p>
</div>
<h3 id="解决方案"> 解决方案</h3>
<h4 id="布隆过滤器"> 布隆过滤器</h4>
<p><img src="./images/cache2.png" alt="cache" /></p>
<ul>
<li>对所有可能查询的参数以 Hash 形式存储</li>
<li>在控制层先进行校验，不符合规则丢弃，避免了对底层存储系统的查询压力</li>
</ul>
<h4 id="缓存空对象"> 缓存空对象</h4>
<p><img src="./images/cache3.png" alt="cache" /></p>
<ul>
<li>当存储层不命中后，将返回的空对象也缓存起来，同时设置一个过期时间</li>
<li>之后在访问这个数据会从缓存中获取，保护后端数据源</li>
</ul>
<p><strong>但这种方法存在两个问题</strong>：</p>
<ul>
<li>
<p>存储空对象也需要空间，大量的空对象会耗费一定的空间，存储效率并不高，解决这个问题的方式就是设置较短过期时间</p>
</li>
<li>
<p>即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响</p>
</li>
</ul>
<h2 id="缓存击穿"> 缓存击穿</h2>
<h3 id="什么缓存击穿"> 什么缓存击穿</h3>
<p>相较于缓存穿透，缓存击穿的目的性更强</p>
<ul>
<li>
<p>一个热点的 key ，大并发集中对这一个点进行访问</p>
</li>
<li>
<p>在缓存过期的一刻，这些请求都会击穿到 DB，造成瞬时 DB  请求量大、压力骤增</p>
</li>
<li>
<p>这就是缓存被击穿，只是针对其中某个key 的缓存不可用而导致击穿，但是其他的 key 依然可以使用缓存响应</p>
</li>
</ul>
<p>比如热搜排行榜，一个热点新闻被同时大量访问就可能导致缓存击穿</p>
<div><p>总结</p>
<p>缓存击穿的主要原因就是：<strong>量太大，缓存过期</strong></p>
</div>
<h3 id="解决方案-2"> 解决方案</h3>
<h4 id="设置热点数据永不过期"> 设置热点数据永不过期</h4>
<ul>
<li>从缓存层面，没有设置过期时间，就不会出现热点数据过期的情况</li>
<li>但是当 Redis 内存空间满的时候也会清理部分数据，而且此种方案会占用空间，一旦热点数据多了起来，就会占用部分空间</li>
</ul>
<h4 id="加互斥锁"> 加互斥锁</h4>
<ul>
<li>使用分布式锁，保证对于每个 key 同时只有一个线程去查询后端</li>
<li>其他线程没有获得分布式锁的权限，只需等待即可</li>
<li>这种方式将高并发的压力转移到了分布式锁</li>
</ul>
<h2 id="缓存雪崩"> 缓存雪崩</h2>
<h3 id="什么是缓存雪崩"> 什么是缓存雪崩</h3>
<ul>
<li>在指定某一个时间段，大量缓存集中过期或缓存服务宕机</li>
<li>造成瞬时 DB 请求量大、压力骤增，引起雪崩</li>
</ul>
<p><img src="./images/cache4.png" alt="cache" /></p>
<h3 id="解决方案-3"> 解决方案</h3>
<h4 id="redis-高可用"> Redis 高可用</h4>
<ul>
<li>既然 Redis 有可能挂掉，那我多增设几台 Redis</li>
<li>一台挂掉之后其他的还可以继续工作，其实就是搭建的集群</li>
</ul>
<h4 id="限流降级"> 限流降级</h4>
<ul>
<li>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量</li>
<li>比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待</li>
</ul>
<h4 id="数据预热"> 数据预热</h4>
<ul>
<li>在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中</li>
<li>在即将发生大并发访问前手动触发加载缓存不同的 key，设置不同的过期时间，让缓存失效的时间点尽量均匀</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">list 类型</title>
    <id>https://www.snowji.cn/databases/redis/list/</id>
    <link href="https://www.snowji.cn/databases/redis/list/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="list-类型"> list 类型</h1>
<ul>
<li>基本的数据类型</li>
<li>list 可应用在栈、队列、阻塞队列中</li>
<li>所有的 list 命令都是以 l 开头的</li>
</ul>
<h2 id="lpush-rpush"> lpush/rpush</h2>
<p>为 list 添加值</p>
<p><strong>语法</strong>：</p>
<div><pre><code>lpush key value<span>[</span>value,value<span>..</span><span>..</span><span>]</span>
rpush key value<span>[</span>value,value<span>..</span><span>..</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> lpush list one   <span># 将一个值或多个值，插入列表的头部（左边）</span>
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> lpush list teo
<span>(</span>integer<span>)</span> <span>2</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> lpush list three
<span>(</span>integer<span>)</span> <span>3</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> lrange list <span>0</span> -1   <span># 获取 list 中的所有值</span>
<span>1</span><span>)</span> <span>"three"</span>
<span>2</span><span>)</span> <span>"teo"</span>
<span>3</span><span>)</span> <span>"one"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> lrange list <span>0</span> <span>1</span>     <span># 通过区间获取具体的值</span>
<span>1</span><span>)</span> <span>"three"</span>
<span>2</span><span>)</span> <span>"teo"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> rpush list right   <span># 将一个值或多个值，插入列表的尾部（右边）</span>
<span>(</span>integer<span>)</span> <span>4</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> lrange list <span>0</span> -1
<span>1</span><span>)</span> <span>"three"</span>
<span>2</span><span>)</span> <span>"teo"</span>
<span>3</span><span>)</span> <span>"one"</span>
<span>4</span><span>)</span> <span>"right"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><div><p>注意</p>
<ul>
<li>lpush 方式插入的值获取时最后插入的先显示</li>
<li>rpush 方式插入的值获取时最后插入的后显示</li>
</ul>
</div>
<h2 id="lpop-rpop"> lpop/rpop</h2>
<p>移除 list 中的值</p>
<p><strong>语法</strong>：</p>
<div><pre><code>lpop key <span>[</span>count<span>]</span>
rpop key <span>[</span>count<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> lrange list <span>0</span> -1
<span>1</span><span>)</span> <span>"three"</span>
<span>2</span><span>)</span> <span>"teo"</span>
<span>3</span><span>)</span> <span>"one"</span>
<span>4</span><span>)</span> <span>"right"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> lpop list      <span># 移除列表的第一个元素</span>
<span>"three"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> rpop list     <span># 移除列表的最后一个元素</span>
<span>"right"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> lrange list <span>0</span> -1
<span>1</span><span>)</span> <span>"teo"</span>
<span>2</span><span>)</span> <span>"one"</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="lindex"> lindex</h2>
<p>根据下标获取值</p>
<p><strong>语法</strong>：</p>
<div><pre><code>lindex key index
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> lrange list <span>0</span> -1
<span>1</span><span>)</span> <span>"teo"</span>
<span>2</span><span>)</span> <span>"one"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> lindex list <span>1</span>     <span># 通过下标获得某一个值</span>
<span>"one"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> lindex list <span>0</span>
<span>"teo"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> 

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="llen"> llen</h2>
<p>获取列表长度</p>
<p><strong>语法</strong>:</p>
<div><pre><code>llen key
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> lpush list one
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> lpush list two three
<span>(</span>integer<span>)</span> <span>3</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> lrange list <span>0</span> -1
<span>1</span><span>)</span> <span>"three"</span>
<span>2</span><span>)</span> <span>"two"</span>
<span>3</span><span>)</span> <span>"one"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> llen list     <span># 返回列表长度</span>
<span>(</span>integer<span>)</span> <span>3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="lrem"> lrem</h2>
<p>移除指定值</p>
<p><strong>语法</strong>：</p>
<div><pre><code>lrem key count value
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> lpush list one two three three one
<span>(</span>integer<span>)</span> <span>5</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> lrange list <span>0</span> -1
<span>1</span><span>)</span> <span>"one"</span>
<span>2</span><span>)</span> <span>"three"</span>
<span>3</span><span>)</span> <span>"three"</span>
<span>4</span><span>)</span> <span>"two"</span>
<span>5</span><span>)</span> <span>"one"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> lrem list <span>1</span> one  <span># 移除 list 集合中指定个数的 value，精确匹配</span>
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> lrange list <span>0</span> -1
<span>1</span><span>)</span> <span>"three"</span>
<span>2</span><span>)</span> <span>"three"</span>
<span>3</span><span>)</span> <span>"two"</span>
<span>4</span><span>)</span> <span>"one"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> lrem list <span>2</span> three
<span>(</span>integer<span>)</span> <span>2</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> lrange list <span>0</span> -1
<span>1</span><span>)</span> <span>"two"</span>
<span>2</span><span>)</span> <span>"one"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h2 id="ltrim"> ltrim</h2>
<p>截取 list</p>
<p><strong>语法</strong>：</p>
<div><pre><code>ltrim key start stop
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> rpush mylist <span>"hello"</span>
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> rpush mylist <span>"hell1"</span> <span>"hello2"</span> <span>"hello3"</span>
<span>(</span>integer<span>)</span> <span>4</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> lrange mylist <span>0</span> -1
<span>1</span><span>)</span> <span>"hello"</span>
<span>2</span><span>)</span> <span>"hell1"</span>
<span>3</span><span>)</span> <span>"hello2"</span>
<span>4</span><span>)</span> <span>"hello3"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> ltrim mylist <span>1</span> <span>2</span>   <span># 通过下标截取指定的长度</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> lrange mylist <span>0</span> -1
<span>1</span><span>)</span> <span>"hell1"</span>
<span>2</span><span>)</span> <span>"hello2"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><p>注意</p>
<p>使用 ltrim 截取时，会改变 list 中的值，只剩下截取的元素了</p>
</div>
<h2 id="rpoplpush"> rpoplpush</h2>
<p>移除列表的最后一个元素，将他移动到新的列表中</p>
<p><strong>语法</strong>:</p>
<div><pre><code>rpoplpush <span>source</span> destination
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> rpush mylist <span>"hello"</span> <span>"hello1"</span> <span>"hello2"</span>
<span>(</span>integer<span>)</span> <span>3</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> rpoplpush mylist otherlist <span>#移除列表的最后一个元素，将他移动到新的列表中</span>
<span>"hello2"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> lrange mylist <span>0</span> -1  <span># 查看原来的列表</span>
<span>1</span><span>)</span> <span>"hello"</span>
<span>2</span><span>)</span> <span>"hello1"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> lrange otherlist <span>0</span> -1    <span># 查看目标列表中确实存在数值</span>
<span>1</span><span>)</span> <span>"hello2"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="lset"> lset</h2>
<p>将列表中指定下标的值替换为另一个值</p>
<p><strong>语法</strong>:</p>
<div><pre><code>lset key index value
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> exists list    <span># 判断列表是否存在</span>
<span>(</span>integer<span>)</span> <span>0</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> lpush list value1
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> lrange list <span>0</span> <span>0</span>
<span>1</span><span>)</span> <span>"value1"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> lset list <span>0</span> items     <span># 如果 list 存在则更新下标的值，不存在则报错</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> lrange list <span>0</span> <span>0</span>
<span>1</span><span>)</span> <span>"items"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> lset list <span>1</span> other      <span># 如果 list 的下标不存在则报错</span>
<span>(</span>error<span>)</span> ERR index out of range

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="linsert"> linsert</h2>
<p>将某个具体的值插入到列表中某个元素的前面或后面</p>
<p><strong>语法</strong>:</p>
<div><pre><code>LINSERT key BEFORE<span>|</span>AFTER pivot value
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> rpush mylist <span>"hello"</span> <span>"world"</span>
<span>(</span>integer<span>)</span> <span>2</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> linsert mylist before <span>"world"</span> <span>"other"</span>   <span># 在 world 前插入</span>
<span>(</span>integer<span>)</span> <span>3</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> lrange mylist <span>0</span> -1
<span>1</span><span>)</span> <span>"hello"</span>
<span>2</span><span>)</span> <span>"other"</span>
<span>3</span><span>)</span> <span>"world"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> linsert mylist after <span>"world"</span> <span>"other1"</span>   <span># 在 world 后插入</span>
<span>(</span>integer<span>)</span> <span>4</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> lrange mylist <span>0</span> -1
<span>1</span><span>)</span> <span>"hello"</span>
<span>2</span><span>)</span> <span>"other"</span>
<span>3</span><span>)</span> <span>"world"</span>
<span>4</span><span>)</span> <span>"other1"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><div><p>总结</p>
<ul>
<li>list实际上是一个链表，before Node after，left，right 都可以插入值</li>
<li><strong>如果 key 不存在，则创建新的链表</strong></li>
<li>如果 key 存在，新增内容</li>
<li>如果移除了所有值，空链表，也代表不存在</li>
<li>在两边插入或者改动值，效率最高！修改中间元素，效率相对较低</li>
</ul>
</div>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Hyperloglog 基数统计</title>
    <id>https://www.snowji.cn/databases/redis/hyperloglog/</id>
    <link href="https://www.snowji.cn/databases/redis/hyperloglog/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="hyperloglog-基数统计"> Hyperloglog 基数统计</h1>
<ul>
<li>Redis 2.8.9 版本就更新了 Hyperloglog 数据结构</li>
<li>Redis Hyperloglog 基数统计的算法</li>
<li>底层使用 String 数据类型</li>
</ul>
<h2 id="什么是基数"> 什么是基数</h2>
<p>数据集中不重复的元素的个数</p>
<p>比如：{1, 3, 5, 7, 5, 7, 8}</p>
<p>那这个数据集的基数就是 5</p>
<h2 id="命令"> 命令</h2>
<h3 id="pfadd-pfcount-pfmerge"> pfadd/pfcount/pfmerge</h3>
<p>pfadd：添加指定元素到 HyperLogLog 中</p>
<p>pfcount：统计指定元素的基数数量</p>
<p>pfmerge：合并 2 组 HyperLogLog 中的元素，取并集</p>
<p><strong>语法</strong>：</p>
<div><pre><code>pfadd key element <span>[</span>element<span>..</span><span>..</span><span>..</span><span>]</span>
pfcount key <span>[</span>key<span>..</span><span>..</span>.<span>]</span>
pfmerge destkey sourcekey <span>[</span>sourcekey<span>..</span><span>..</span>.<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> pfadd mykey a b c d e f j  <span># 创建第一组元素 mykey</span>
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> pfcount mykey     <span># 统计 mykey 元素的基数数量</span>
<span>(</span>integer<span>)</span> <span>7</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> pfadd mykey2 i j a z c x b     <span># 创建第二组元素 mykey2</span>
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> pfcount mykey2
<span>(</span>integer<span>)</span> <span>7</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> pfmerge mykey3 mykey mykey2   <span># 合并 mykey 和 mykey2 =》mykey3</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> pfcount mykey3   <span># 查看并集的基数数量</span>
<span>(</span>integer<span>)</span> <span>10</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="应用场景"> 应用场景</h2>
<p>网页的访问量（UV）：一个用户多次访问，也只能算作一个人</p>
<p>传统方式：</p>
<ul>
<li>
<p>存储用户的id,然后每次进行比较</p>
</li>
<li>
<p>当用户变多之后这种方式及其浪费空间，而我们的目的只是<strong>计数</strong></p>
</li>
<li>
<p>Hyperloglog 就能帮助我们利用最小的空间完成</p>
</li>
</ul>
<p><strong>Hyperloglog 优点</strong>：</p>
<ul>
<li>
<p>占用的内存是固定的</p>
</li>
<li>
<p>2^64 个不同元素的基数，只需要 12 KB 内存</p>
</li>
<li>
<p>HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身</p>
</li>
</ul>
<p><strong>Hyperloglog 缺点</strong>：</p>
<ul>
<li>
<p>会有 0.81% 的错误率</p>
</li>
<li>
<p>如果允许容错，那么一定可以使用 Hyperloglog</p>
</li>
<li>
<p>如果不允许容错，就使用 Set 或者自己的数据类型即可</p>
</li>
</ul>
<h2 id="参考文档"> 参考文档</h2>
<p><a href="https://www.redis.net.cn/tutorial/3513.html" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Redis 主从复制</title>
    <id>https://www.snowji.cn/databases/redis/master-slave/</id>
    <link href="https://www.snowji.cn/databases/redis/master-slave/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="redis-主从复制"> Redis 主从复制</h1>
<h2 id="什么是主从复制"> 什么是主从复制</h2>
<ul>
<li>将一台 Redis 服务器的数据，复制到其他 Redis 服务器</li>
<li>前者称为主节点，后者称为从节点</li>
<li><strong>数据的复制是单向的，只能由主节点复制到从节点</strong></li>
<li>主节点以写为主，从节点以读为主</li>
</ul>
<h2 id="主从复制的作用"> 主从复制的作用</h2>
<ul>
<li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式</li>
<li>故障恢复：当主节点故障时，从节点可以暂时替代主节点提供服务，是一种服务冗余的方式</li>
<li>负载均衡：在主从复制的基础上，配合读写分离，由主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的场景下，通过多个从节点分担负载，提高并发量</li>
<li>高可用基石：主从复制还是哨兵和集群能够实施的基础</li>
</ul>
<h2 id="为什么要使用集群"> 为什么要使用集群</h2>
<ul>
<li>单台服务器难以负载大量的请求</li>
<li>单台服务器故障率高，系统崩坏概率大</li>
<li>单台服务器内存容量有限</li>
</ul>
<h2 id="集群环境配置"> 集群环境配置</h2>
<p>主要实现的是单机多服务集群</p>
<h3 id="以命令的形式配置"> 以命令的形式配置</h3>
<p>查看当前库的信息：</p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> info replication
<span># Replication</span>
role:master             <span># 角色</span>
connected_slaves:0      <span># 从机数量</span>
master_failover_state:no-failover
master_replid:053d096358fe090b7c3ec8616e4ae90402ccd42d
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:0
second_repl_offset:-1
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h4 id="一主二从配置"> 一主二从配置</h4>
<p><strong>第一步</strong>：</p>
<ul>
<li>需要启动多个服务，就需要多个配置文件</li>
<li>每个配置文件对应修改以下信息
<ul>
<li>端口号</li>
<li>pid 文件名</li>
<li>日志文件名</li>
<li>rdb 文件名</li>
</ul>
</li>
</ul>
<p>启动单机多服务集群，查看进程：</p>
<div><pre><code><span>[</span>root@test redis-config<span>]</span><span># ps -ef|grep redis</span>
root     <span>30315</span>     <span>1</span>  <span>0</span> <span>11</span>:24 ?        00:00:00 redis-server <span>127.0</span>.0.1:6379
root     <span>30321</span>     <span>1</span>  <span>0</span> <span>11</span>:24 ?        00:00:00 redis-server <span>127.0</span>.0.1:6380
root     <span>30328</span>     <span>1</span>  <span>0</span> <span>11</span>:25 ?        00:00:00 redis-server <span>127.0</span>.0.1:6381
root     <span>30335</span> <span>30283</span>  <span>0</span> <span>11</span>:25 pts/5    00:00:00 <span>grep</span> redis
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>第二步</strong>：</p>
<ul>
<li>
<p>默认情况下，每台 Redis 服务都是主节点</p>
</li>
<li>
<p>使用 <code>slaveof host post</code> 配置从机</p>
</li>
</ul>
<p>将 80、81 配置为从机</p>
<div><pre><code>----------------------------80---------------------------------
<span>127.0</span>.0.1:638<span><span>0</span>></span> SLAVEOF <span>127.0</span>.0.1 <span>6379</span>
OK
<span>127.0</span>.0.1:638<span><span>0</span>></span> info replication
<span># Replication</span>
role:slave                                <span># 变成从机了</span>
master_host:127.0.0.1
master_port:6379
master_link_status:up
master_last_io_seconds_ago:4
master_sync_in_progress:0
slave_read_repl_offset:42
slave_repl_offset:42
slave_priority:100
slave_read_only:1
replica_announced:1
connected_slaves:0
master_failover_state:no-failover
master_replid:727048f272ec1e7bff9d178bdd2b97a8c37eb6cf
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:42
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:15
repl_backlog_histlen:28

----------------------------81---------------------------------
<span>127.0</span>.0.1:638<span><span>1</span>></span> SLAVEOF <span>127.0</span>.0.2 <span>6379</span>
OK
<span>127.0</span>.0.1:638<span><span>1</span>></span> info replication
<span># Replication</span>
role:slave                              <span># 变成从机了</span>
master_host:127.0.0.1
master_port:6379
master_link_status:down
master_last_io_seconds_ago:-1
master_sync_in_progress:0
slave_read_repl_offset:0
slave_repl_offset:0
master_link_down_since_seconds:-1
slave_priority:100
slave_read_only:1
replica_announced:1
connected_slaves:0
master_failover_state:no-failover
master_replid:ae95e721f4791b7b7dc28df51329f44e24f5533d
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:0
second_repl_offset:-1
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br></div></div><p>主机上查看：</p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> info replication
<span># Replication</span>
role:master
connected_slaves:2                      <span># 有 2 个从机</span>
slave0:ip<span>=</span><span>127.0</span>.0.1,port<span>=</span><span>6380</span>,state<span>=</span>online,offset<span>=</span><span>350</span>,lag<span>=</span><span>1</span>
slave1:ip<span>=</span><span>127.0</span>.0.1,port<span>=</span><span>6381</span>,state<span>=</span>online,offset<span>=</span><span>350</span>,lag<span>=</span><span>0</span>
master_failover_state:no-failover
master_replid:727048f272ec1e7bff9d178bdd2b97a8c37eb6cf
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:350
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:350

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h4 id="使用规则"> 使用规则</h4>
<ul>
<li>从机只能读，不能写，主机可读可写，一般主机主要用于写</li>
</ul>
<div><pre><code>----------------------------主机79-------------------------------
<span>127.0</span>.0.1:637<span><span>9</span>></span> <span>set</span> k1 v1
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> <span>set</span> k2 v2
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> get k2
<span>"v2"</span>
----------------------------从机80-------------------------------
<span>127.0</span>.0.1:638<span><span>0</span>></span> <span>set</span> k3 v3
<span>(</span>error<span>)</span> READONLY You can<span>'t write against a read only replica.    # 写入失败
127.0.0.1:6380> get k2
"v2"
----------------------------从机81-------------------------------
127.0.0.1:6381> set k4 v4
(error) READONLY You can'</span>t <span>write</span> against a <span>read</span> only replica.   <span># 写入失败</span>
<span>127.0</span>.0.1:638<span><span>0</span>></span> get k2
<span>"v2"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><ul>
<li>当主机断电宕机后，默认情况下从机的角色不会发生变化 ，集群中只是失去了写操作，当主机恢复以后，又会连接上从机恢复原状</li>
<li>当从机断电宕机后，若不是使用配置文件配置的从机，再次启动后会作为主机，无法获取之前主机的数据的，若此时重新配置称为从机，又可以获取到主机的所有数据</li>
<li>第二条中提到，默认情况下，主机故障后，不会出现新的主机，有两种方式可以产生新的主机：
<ul>
<li>从机手动执行命令 <code>slaveof no one</code>，这样执行以后从机会独立出来成为一个主机</li>
<li>使用哨兵模式（自动选举）</li>
</ul>
</li>
</ul>
<h3 id="以配置文件形式配置"> 以配置文件形式配置</h3>
<p>上面是以命令的形式进行配置的，这种是短暂的</p>
<p>如果要进行永久配置，是需要修改配置文件的</p>
<p><img src="./images/ms1.png" alt="master" /></p>
<h2 id="主从复制原理"> 主从复制原理</h2>
<ul>
<li>slave 启动成功连接到 master 后会发送一个 sync 同步命令</li>
<li>master 接到指令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令</li>
<li>在后台进程执行完毕后，master 将传送整个数据文件到 slave，并完成一次同步</li>
</ul>
<p><strong>全量复制</strong>：slave 服务在接收到数据库文件数据后，将其存盘并加载到内存</p>
<p><strong>增量复制</strong>：master 继续将新的所有收集到的修改命令依次传给 slave，完成同步</p>
<div><p>总结</p>
<p>slave 在第一次启动时，实行的是全量复制，后续是增量复制</p>
</div>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">geospatial 地理位置</title>
    <id>https://www.snowji.cn/databases/redis/geospatial/</id>
    <link href="https://www.snowji.cn/databases/redis/geospatial/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="geospatial-地理位置"> geospatial 地理位置</h1>
<h2 id="geoadd"> geoadd</h2>
<p>添加地址位置</p>
<p><strong>语法</strong>：</p>
<div><pre><code>geoadd key longitude latitude member<span>[</span>longitude latitude member<span>..</span><span>..</span><span>..</span><span>]</span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> geoadd china:city <span>116.40</span> <span>39.90</span> beijing <span>121.47</span> <span>31.23</span> shanghai <span>106.50</span> <span>29.53</span> chongqing <span>114.05</span> <span>22.52</span> shenzhen 
<span>(</span>integer<span>)</span> <span>4</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> geoadd china:city <span>120.16</span> <span>30.24</span> hangzhou <span>108.96</span> <span>34.26</span> xian
<span>(</span>integer<span>)</span> <span>2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><p>注意</p>
<ul>
<li>有效的经度从 -180 度到 180 度</li>
<li>有效的纬度从 -85.05112878 度到 85.05112878 度</li>
<li>当坐标位置超出上述指定范围时，该命令将会返回一个错误</li>
</ul>
</div>
<h2 id="geopos"> geopos</h2>
<p>获得当前位置：一定是一个坐标值</p>
<p><strong>语法</strong>：</p>
<div><pre><code>geopos key member<span>[</span>member<span>..</span><span>..</span>.<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> geopos china:city beijing    <span>#获取指定的城市的经度和纬度</span>
<span>1</span><span>)</span> <span>1</span><span>)</span> <span>"116.39999896287918091"</span>
   <span>2</span><span>)</span> <span>"39.90000009167092543"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> geopos china:city beijing chongqing
<span>1</span><span>)</span> <span>1</span><span>)</span> <span>"116.39999896287918091"</span>
   <span>2</span><span>)</span> <span>"39.90000009167092543"</span>
<span>2</span><span>)</span> <span>1</span><span>)</span> <span>"106.49999767541885376"</span>
   <span>2</span><span>)</span> <span>"29.52999957900659211"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="geodist"> geodist</h2>
<p>查看两地之间的距离</p>
<p>单位：</p>
<ul>
<li>m 表示单位为米</li>
<li>km 表示单位为千米</li>
<li>mi 表示单位为英里</li>
<li>ft 表示单位英尺</li>
</ul>
<p><strong>语法</strong>：</p>
<div><pre><code>geodist key member1 member2 <span>[</span>M<span>|</span>KM<span>|</span>FT<span>|</span>MI<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> geodist china:city beijing shanghai km     <span># 查看上海到北京的直线距离</span>
<span>"1067.3788"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> geodist china:city beijing chongqing km   <span># 查看重庆到北京的直线距离</span>
<span>"1464.0708"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> geodist china:city beijing chongqing m
<span>"1464070.8051"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="georadius"> georadius</h2>
<p>以给定你的经纬度为中心，找出某一半径内的元素</p>
<p><strong>语法</strong>：</p>
<div><pre><code>georadius key longitude latitude radius M<span>|</span>KM<span>|</span>FT<span>|</span>MI <span>[</span>withcoord<span>]</span> <span>[</span>withdist<span>]</span> <span>[</span>COUNT count <span>[</span>ANY<span>]</span><span>]</span> <span>[</span>ASC<span>|</span>DESC<span>]</span> <span>[</span>STORE key<span>]</span> <span>[</span>STOREDIST key<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> georadius china:city <span>110</span> <span>30</span> <span>1000</span> km   <span>#以110、30 这个经纬度为中心，寻找方圆1000km内的城市</span>
<span>1</span><span>)</span> <span>"chongqing"</span>
<span>2</span><span>)</span> <span>"xian"</span>
<span>3</span><span>)</span> <span>"shenzhen"</span>
<span>4</span><span>)</span> <span>"hangzhou"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> georadius china:city <span>110</span> <span>30</span> <span>500</span> km
<span>1</span><span>)</span> <span>"chongqing"</span>
<span>2</span><span>)</span> <span>"xian"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> georadius china:city <span>110</span> <span>30</span> <span>500</span> km withdist   <span>#显示到中间距离的位置</span>
<span>1</span><span>)</span> <span>1</span><span>)</span> <span>"chongqing"</span>
   <span>2</span><span>)</span> <span>"341.9374"</span>
<span>2</span><span>)</span> <span>1</span><span>)</span> <span>"xian"</span>
   <span>2</span><span>)</span> <span>"483.8340"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> georadius china:city <span>110</span> <span>30</span> <span>500</span> km withcoord <span># 显示他人的定位信息</span>
<span>1</span><span>)</span> <span>1</span><span>)</span> <span>"chongqing"</span>
   <span>2</span><span>)</span> <span>1</span><span>)</span> <span>"106.49999767541885376"</span>
      <span>2</span><span>)</span> <span>"29.52999957900659211"</span>
<span>2</span><span>)</span> <span>1</span><span>)</span> <span>"xian"</span>
   <span>2</span><span>)</span> <span>1</span><span>)</span> <span>"108.96000176668167114"</span>
      <span>2</span><span>)</span> <span>"34.25999964418929977"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> georadius china:city <span>110</span> <span>30</span> <span>500</span> km withcoord withdist count <span>1</span> <span># 筛选指定的结果</span>
<span>1</span><span>)</span> <span>1</span><span>)</span> <span>"chongqing"</span>
   <span>2</span><span>)</span> <span>"341.9374"</span>
   <span>3</span><span>)</span> <span>1</span><span>)</span> <span>"106.49999767541885376"</span>
      <span>2</span><span>)</span> <span>"29.52999957900659211"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> georadius china:city <span>110</span> <span>30</span> <span>500</span> km withcoord withdist count <span>2</span>
<span>1</span><span>)</span> <span>1</span><span>)</span> <span>"chongqing"</span>
   <span>2</span><span>)</span> <span>"341.9374"</span>
   <span>3</span><span>)</span> <span>1</span><span>)</span> <span>"106.49999767541885376"</span>
      <span>2</span><span>)</span> <span>"29.52999957900659211"</span>
<span>2</span><span>)</span> <span>1</span><span>)</span> <span>"xian"</span>
   <span>2</span><span>)</span> <span>"483.8340"</span>
   <span>3</span><span>)</span> <span>1</span><span>)</span> <span>"108.96000176668167114"</span>
      <span>2</span><span>)</span> <span>"34.25999964418929977"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><p>应用：附近的人</p>
<h2 id="georadiusbymember"> georadiusbymember</h2>
<p>找出位于指定元素周围的其他元素</p>
<p><strong>语法</strong>：</p>
<div><pre><code>georadiusbymember key member radius M<span>|</span>KM<span>|</span>FT<span>|</span>MI <span>[</span>withcoord<span>]</span> <span>[</span>withdist<span>]</span> <span>[</span>COUNT count <span>[</span>ANY<span>]</span><span>]</span> <span>[</span>ASC<span>|</span>DESC<span>]</span> <span>[</span>STORE key<span>]</span> <span>[</span>STOREDIST key<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> GEORADIUSBYMEMBER china:city beijing <span>1000</span> km
<span>1</span><span>)</span> <span>"beijing"</span>
<span>2</span><span>)</span> <span>"xian"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> GEORADIUSBYMEMBER china:city shanghai <span>400</span> km
<span>1</span><span>)</span> <span>"hangzhou"</span>
<span>2</span><span>)</span> <span>"shanghai"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="geohash"> geohash</h2>
<p>返回一个或多个位置元素 11 个字符的 Geohash 字符串</p>
<p><strong>语法</strong>:</p>
<div><pre><code>geohash key member<span>[</span>member<span>..</span><span>..</span>.<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span># 将二维的经纬度转为一维的字符串，如果两个字符串越接近，那么则距离越近</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> GEOHASH china:city beijing chongqing
<span>1</span><span>)</span> <span>"wx4fbxxfke0"</span>
<span>2</span><span>)</span> <span>"wm5xzrybty0"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="底层原理"> 底层原理</h2>
<ul>
<li>
<p>geo 的底层实现原理就是 Zset</p>
</li>
<li>
<p>可以使用 Zset 命令操作 geo</p>
</li>
</ul>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> zrange china:city <span>0</span> -1
<span>1</span><span>)</span> <span>"chongqing"</span>
<span>2</span><span>)</span> <span>"xian"</span>
<span>3</span><span>)</span> <span>"shenzhen"</span>
<span>4</span><span>)</span> <span>"hangzhou"</span>
<span>5</span><span>)</span> <span>"shanghai"</span>
<span>6</span><span>)</span> <span>"beijing"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> zrem china:city beijing
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> zrange china:city <span>0</span> -1
<span>1</span><span>)</span> <span>"chongqing"</span>
<span>2</span><span>)</span> <span>"xian"</span>
<span>3</span><span>)</span> <span>"shenzhen"</span>
<span>4</span><span>)</span> <span>"hangzhou"</span>
<span>5</span><span>)</span> <span>"shanghai"</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><div><p>应用</p>
<ul>
<li>朋友的定位</li>
<li>附近的人</li>
<li>打车的距离</li>
</ul>
</div>
<h2 id="参考文档"> 参考文档</h2>
<p><a href="https://www.redis.net.cn/order/3685.html" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">持久化之 RBD</title>
    <id>https://www.snowji.cn/databases/redis/rdb/</id>
    <link href="https://www.snowji.cn/databases/redis/rdb/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="持久化之-rbd"> 持久化之 RBD</h1>
<h2 id="什么是-rdb"> 什么是 RDB</h2>
<p>RDB：Redis Databases</p>
<ul>
<li>持久化实现的方式之一</li>
<li>在指定时间间隔后，将内存中的数据集快照写入数据库</li>
<li>在恢复的时候，直接读取快照文件，进行数据恢复</li>
<li>默认情况下，Redis 将 RDB 保存在 dump.rdb 文件中，可以在配置文件中自定义</li>
</ul>
<p><img src="./images/rdb3.png" alt="rdb" /></p>
<h2 id="工作原理"> 工作原理</h2>
<p>先了解下 RDB 的两个命令：save 和 bgsave</p>
<h3 id="save-命令"> save 命令</h3>
<ul>
<li>使用 save 命令，会直接调用 rdbsave 函数，立刻对当前内存中的数据进行持久化</li>
<li>会阻塞 Redis 主线程，直到数据同步保存完成，不会接收其他操作</li>
<li>若 Redis 数据非常多时，save 执行的速度会非常慢</li>
</ul>
<h3 id="bgsave-命令"> bgsave 命令</h3>
<ul>
<li>会 fork 一个子进程，负责调用 rdbsave 函数</li>
<li>在保存完毕完成后向主线程发送信号通知主进程保存完毕</li>
<li>主进程可以处理其他客户端操作</li>
</ul>
<h3 id="rdb-实现"> RDB 实现</h3>
<p><img src="./images/rbd1.png" alt="rdb" /></p>
<p>在进行 RDB 的时候，Redis 的主线程是不会做 io 操作的，主线程会 fork 一个子线程来完成该操作；</p>
<ul>
<li>Redis 调用 fork，同时拥有父进程和子进程</li>
<li>子进程将数据集写入到一个临时 RDB 文件中</li>
<li>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件</li>
<li>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益(因为是使用子进程进行写操作，而父进程依然可以接收来自客户端的请求)</li>
</ul>
<h2 id="触发机制"> 触发机制</h2>
<ul>
<li>save 的规则满足的情况下，会自动触发 RDB 原则</li>
<li>执行 flushall 命令，也会触发我们的 RDB 原则</li>
<li>退出 redis，也会自动产生 RDB 文件</li>
</ul>
<p><img src="./images/rdb2.png" alt="rdb" /></p>
<p><strong>恢复 RDB 文件</strong>：</p>
<ul>
<li>只需要将 RDB 文件放在 Redis 启动目录就行，Redis 启动会自动检查 dump.rdb 恢复其中的数据</li>
<li>查看需要存放的位置</li>
</ul>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> config get <span>dir</span>
<span>1</span><span>)</span> <span>"dir"</span>
<span>2</span><span>)</span> <span>"usr/local/bin"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="rdb-优缺点"> RDB 优缺点</h2>
<p><strong>优点</strong>:</p>
<ul>
<li>适合大规模的数据恢复</li>
<li>对数据的完整性要求不高</li>
</ul>
<p><strong>缺点</strong>:</p>
<ul>
<li>需要一定的时间间隔进行操作，如果 Redis 意外宕机了，这个最后一次修改的数据就没有了</li>
<li>fork 进程的时候，会占用一定的内容空间</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">安装 Redis</title>
    <id>https://www.snowji.cn/databases/redis/redis-install/</id>
    <link href="https://www.snowji.cn/databases/redis/redis-install/"/>
    <updated>2022-10-05T11:53:00.000Z</updated>
    <content type="html"><![CDATA[<h1 id="安装-redis"> 安装 Redis</h1>
<p>官网：https://redis.io/</p>
<p>中文网：http://www.redis.cn/</p>
<p>推荐使用 Linux 服务器学习</p>
<p>Windows 版本的 Redis 已经停更很久了…</p>
<h2 id="windows-安装"> Windows 安装</h2>
<p>下载安装包后解压安装包</p>
<p><img src="./images/install-1.png" alt="install" /></p>
<p>启动 redis-server.exe</p>
<p>启动 redis-cli.exe 测试</p>
<p><img src="./images/install-2.png" alt="install" /></p>
<h2 id="centos-7-6-下安装"> CentOS 7.6 下安装</h2>
<h3 id="准备依赖环境"> 准备依赖环境</h3>
<p>Redis 是由 C 语言开发，因此安装之前需要确保服务器已经安装了 gcc，可以通过以下命令检查服务器是否安装：</p>
<div><pre><code>gcc -v
</code></pre>
<div><span>1</span><br></div></div><p>如果没有安装则通过以下命令安装：</p>
<div><pre><code>yum <span>install</span> -y gcc
</code></pre>
<div><span>1</span><br></div></div><h3 id="下载、编译、安装"> 下载、编译、安装</h3>
<p>从<a href="https://redis.io/download/" target="_blank" rel="noopener noreferrer">官网下载</a> Redis7.0（截至 2022.5.3 最新版）并解压、编译、安装，设置连接 ip 和访问密码。</p>
<div><pre><code><span># 我一般喜欢把这些中间件暂时下载到这里</span>
<span>cd</span> /opt

<span># 下载</span>
<span>wget</span> https://download.redis.io/releases/redis-7.0.0.tar.gz

<span># 解压</span>
<span>tar</span> -zxvf redis-7.0.0.tar.gz

<span>cd</span> redis-7.0.0

<span># 编译</span>
<span>make</span>

<span># 安装到 /usr/local/redis 目录里</span>
<span>make</span> <span>install</span> <span>PREFIX</span><span>=</span>/usr/local/redis
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="redis-服务配置"> Redis 服务配置</h3>
<p>先在 redis 目录下面创建 conf 文件夹和 data 文件夹：</p>
<div><pre><code><span>cd</span> /usr/local/redis
<span>mkdir</span> conf
<span>mkdir</span> data
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>然后从安装包复制一份 redis.conf 到 conf 文件夹下面：</p>
<div><pre><code><span>cp</span> /opt/redis-7.0.0/redis.conf /usr/local/redis/conf/redis-6379.conf
</code></pre>
<div><span>1</span><br></div></div><p>修改配置文件，并设置启动模式为后台模式，绑定 ip 修改为 0.0.0.0（生产环境禁止！！！），支持远程登录：</p>
<div><pre><code><span># 默认绑定</span>
<span>bind</span> <span>0.0</span>.0.0 -::1

<span># 监听端口号</span>
port <span>6379</span>

<span># 设置密码，去掉 # 注释，并把后面的密码设置成需要的密码</span>
requirepass your_password

<span># 是否守护进程，默认是 no，改成 yes 以后会以后台运行模式启动</span>
daemonize <span>yes</span>

<span># 日志文件名称</span>
logfile <span>"redis-6379.log"</span>

<span># 指定 data 存放路径</span>
<span>dir</span> /usr/local/redis/data
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>配置文件以后查看 Redis 的运行状态，OK，运行成功了。</p>
<div><pre><code><span>cd</span> /usr/local/redis

redis-server conf/redis-6379.conf 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>前台启动运行测试一下：</p>
<div><pre><code><span># 查看服务</span>
<span>ps</span> -ef<span>|</span><span>grep</span> redis

<span>[</span>root@VM-16-7-centos redis<span>]</span><span># ps -ef|grep redis</span>
root     <span>18460</span>  <span>2522</span>  <span>0</span> <span>11</span>:57 pts/1    00:00:00 redis-server <span>127.0</span>.0.1:6379
root     <span>18480</span> <span>17576</span>  <span>0</span> <span>11</span>:57 pts/2    00:00:00 <span>grep</span> --color<span>=</span>auto redis

<span>[</span>root@VM-16-7-centos redis<span>]</span><span># redis-cli -p 6379</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> <span>ping</span>
PONG
<span>127.0</span>.0.1:637<span><span>9</span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>测试结束，停止 Redis 服务：</p>
<div><pre><code><span>cd</span> /usr/local/redis

redis-cli <span>shutdown</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="设置开机启动"> 设置开机启动</h3>
<p>从 redis 解压目录中，拷贝启动脚本到 <code>/etc/init.d</code> 文件夹：</p>
<div><pre><code><span>cp</span> /opt/redis-7.0.0/utils/redis_init_script /etc/init.d/redis
</code></pre>
<div><span>1</span><br></div></div><p>修改 Redis 启动脚本，主要修改 <code>EXEC</code> 和 <code>CLIEXEC</code> 执行启动命令的脚本目录和 <code>CONF</code> 配置文件目录。截取脚本中部分相关的内容，如下：</p>
<div><pre><code><span># 指定运行的客户端</span>
<span>EXEC</span><span>=</span>/usr/local/redis/bin/redis-server
<span># 客户端</span>
<span>CLIEXEC</span><span>=</span>/usr/local/redis/bin/redis-cli
<span># 核心配置文件</span>
<span>CONF</span><span>=</span><span>"/usr/local/redis/conf/redis-<span>${REDISPORT}</span>.conf"</span>

<span># 脚本里面只有 start 和 stop 脚本，可以增加 status 和 restart 脚本（在"*)"上面写入）</span>
    status<span>)</span>  
        <span>if</span> <span>[</span> -f <span>$PIDPROFILE</span> <span>]</span>  
        <span>then</span>  
            <span>echo</span> <span>'Redis is running'</span>  
        <span>else</span>  
            <span>echo</span> <span>"Redis is not running"</span>  
        <span>fi</span>  
        <span>;</span><span>;</span>  
    restart<span>)</span>  
        <span>$0</span> stop  
        <span>$0</span> start  
        <span>;</span><span>;</span>

<span># 如果 Redis 设置了访问密码，stop) 脚本需要做以下修改，主要是执行 redis-cli 命令时加上密码</span>
<span>$CLIEXEC</span> -a your_password -p <span>$REDISPORT</span> <span>shutdown</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>修改脚本执行权限：</p>
<div><pre><code><span>cd</span> /etc/init.d/
<span>chmod</span> <span>777</span> redis
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>脚本执行检查：</p>
<div><pre><code><span>[</span>root@VM-16-7-centos ~<span>]</span><span># /etc/init.d/redis start</span>
Starting Redis server<span>..</span>.
<span>[</span>root@VM-16-7-centos ~<span>]</span><span># ps -ef|grep redis</span>
root     <span>29683</span>     <span>1</span>  <span>0</span> <span>12</span>:56 ?        00:00:00 /usr/local/redis/bin/redis-server <span>127.0</span>.0.1:6379
root     <span>29729</span>  <span>2522</span>  <span>0</span> <span>12</span>:57 pts/1    00:00:00 <span>grep</span> --color<span>=</span>auto redis
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>开机启动管理：</p>
<div><pre><code><span># 进入目录，该目录是 Linux 系统中专门放置系统服务启停脚本的</span>
<span>cd</span> /etc/init.d/

<span># 查看目前已经加入开机自启的服务进程</span>
<span>chkconfig</span> --list nginx

<span># 添加 Redis 启动脚本为 chkconfig 管理的一个服务</span>
<span>chkconfig</span> --add redis

<span># 将 Redis 加入开机自启</span>
<span>chkconfig</span> redis on

<span># 关闭 Redis 开机启动</span>
<span>chkconfig</span> redis off

<span># 删除 chkconfig 管理的 Redis 启动服务（如果确实不需要了）</span>
<span>chkconfig</span> --del redis 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>重启 Linux 操作系统并进行测试：</p>
<div><pre><code><span># 重启操作系统</span>
<span>[</span>root@VM-16-7-centos init.d<span>]</span><span># shutdown -r now</span>
Connection closing<span>..</span>.Socket close.

Connection closed by foreign host.

Disconnected from remote host<span>(</span>学习机<span>)</span> at <span>14</span>:30:09.

<span># 重启完成，SSH 重新连接，进行测试</span>
<span>[</span>root@VM-16-7-centos ~<span>]</span><span># ps -ef|grep redis</span>
root      <span>1244</span>     <span>1</span>  <span>0</span> <span>14</span>:30 ?        00:00:00 /usr/local/redis/bin/redis-server <span>127.0</span>.0.1:6379
root      <span>2522</span>  <span>2422</span>  <span>0</span> <span>14</span>:32 pts/0    00:00:00 <span>grep</span> --color<span>=</span>auto redis
<span>[</span>root@VM-16-7-centos ~<span>]</span><span># redis-cli -p 6379</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> <span>ping</span>
PONG
<span>127.0</span>.0.1:637<span><span>9</span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>可以看到 Redis 服务已经启动成功，大功告成。</p>
<h3 id="防火墙相关问题"> 防火墙相关问题</h3>
<p>如果 Redis 需要开放远程连接（生产环境不推荐），那么可能会遇到防火墙的问题。</p>
<p>首先，如果使用的是阿里云等云厂家的服务器，无法连接的原因可能是需要去云管理平台，在可视化界面操作来开放相应的端口。</p>
<p>其次，如果是自己内部的服务器，那可能是管理员添加了防火墙策略，如下查看并操作即可（非学习环境下，一定要跟运维人员确认，获取操作许可）：</p>
<div><pre><code><span># 检查防火墙状态，看到 active(running) 就意味着防火墙打开了</span>
<span>sudo</span> systemctl status firewalld

<span># 关闭防火墙</span>
<span>sudo</span> systemctl stop firewalld
<span># 开启防火墙</span>
<span>sudo</span> systemctl start firewalld

<span># 上面的命令是临时的，重启后就失效了</span>
<span># 彻底关闭防火墙</span>
<span>sudo</span> systemctl disable firewalld
 
<span># 开放 Redis 端口</span>
firewall-cmd --zone<span>=</span>public --add-port<span>=</span><span>6379</span>/tcp --permanent
<span># 应用</span>
firewall-cmd --reload
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="卸载-redis"> 卸载 Redis</h3>
<ul>
<li>先停止 Redis 服务</li>
<li>关闭 Redis 开机启动，并将其从 chkconfig 托管中删除</li>
<li>删除 Redis 安装目录</li>
<li>如果还想更干净可以通过 <code>find / -name redis</code> 命令，将查到的文件夹及目录都删除即可</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Redis 哨兵模式</title>
    <id>https://www.snowji.cn/databases/redis/sentinel/</id>
    <link href="https://www.snowji.cn/databases/redis/sentinel/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="redis-哨兵模式"> Redis 哨兵模式</h1>
<p>前面学习到主从切换技术的方法：</p>
<ul>
<li>当主服务器宕机后，需要手动把一台从服务器切换为主服务器</li>
<li>需要人工干预，费事费力，还会造成一段时间内服务不可用</li>
</ul>
<p>这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式</p>
<h2 id="什么是哨兵模式"> 什么是哨兵模式</h2>
<ul>
<li>哨兵模式是一种特殊的模式</li>
<li>哨兵是一个独立的进程，会独立运行</li>
<li>哨兵通过发送命令，等待 Redis 服务器响应，从而监控运行的多个 Redis 实例</li>
</ul>
<p><img src="./images/sentinel1.png" alt="sentiel" /></p>
<p>哨兵的作用：</p>
<ul>
<li>通过发送命令，让 Redis 服务器返回监控其运行状态，包括主服务器和从服务器</li>
<li>当哨兵监测到 master 宕机，会自动将 slave 切换成 master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机</li>
</ul>
<p>一个哨兵进程对 Redis 服务器进行监控，可能会出现问题，可以使用多个哨兵进行监控</p>
<p>各个哨兵之间还会进行监控，这样就形成了多哨兵模式</p>
<p><img src="./images/sentinel2.png" alt="sentiel" /></p>
<p>故障切换（failover）的过程:</p>
<ul>
<li>主服务器宕机，哨兵1 先检测到这个结果，系统并不会马上进行 failover 过程</li>
<li>仅仅是哨兵1 主观的认为主服务器不可用，这个现象成为<strong>主观下线</strong></li>
<li>当其他哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行 failover 操作</li>
<li>切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong></li>
</ul>
<h2 id="哨兵模式配置"> 哨兵模式配置</h2>
<p>以一主二从为例配置</p>
<p><strong>配置哨兵配置文件 sentinel.conf</strong>：</p>
<div><pre><code><span># sentinel monitor 监控的名称 监控的主机 端口号 1</span>
sentinel monitor mymaster <span>127.0</span>.0.1 <span>6379</span> <span>1</span>

<span># 1: 表示主机挂了，slave 进行投票，投票最高的成为主机</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>启动哨兵</strong>：</p>
<div><pre><code>redis-sentinel config/sentinel.conf 
</code></pre>
<div><span>1</span><br></div></div><p><img src="./images/sentinel3.png" alt="sentinel" /></p>
<p>断开主机，哨兵日志：</p>
<p><img src="./images/sentinel5.png" alt="sentinel" /></p>
<h2 id="哨兵模式优缺点"> 哨兵模式优缺点</h2>
<p><strong>优点</strong>：</p>
<ul>
<li>哨兵集群，基于主从复制模式，所有主从复制的优点，它都有</li>
<li>主从可以切换，故障可以转移，系统的可用性更好</li>
<li>哨兵模式是主从模式的升级，手动到自动，更加健壮</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>Redis 不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦</li>
<li>实现哨兵模式的配置其实是很麻烦的，里面有很多配置项</li>
</ul>
<h2 id="哨兵模式的全部配置"> 哨兵模式的全部配置</h2>
<p>完整的哨兵模式配置文件 sentinel.conf</p>
<div><pre><code><span># Example sentinel.conf</span>
 
<span># 哨兵sentinel实例运行的端口 默认26379</span>
port <span>26379</span>
 
<span># 哨兵sentinel的工作目录</span>
<span>dir</span> /tmp
 
<span># 哨兵sentinel监控的redis主节点的 ip port </span>
<span># master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符".-_"组成</span>
<span># quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了</span>
<span># sentinel monitor &lt;master-name> &lt;ip> &lt;redis-port> &lt;quorum></span>
sentinel monitor mymaster <span>127.0</span>.0.1 <span>6379</span> <span>1</span>
 
<span># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span>
<span># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span>
<span># sentinel auth-pass &lt;master-name> &lt;password></span>
sentinel auth-pass mymaster MySUPER--secret-0123passw0rd
 
 
<span># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span>
<span># sentinel down-after-milliseconds &lt;master-name> &lt;milliseconds></span>
sentinel down-after-milliseconds mymaster <span>30000</span>
 
<span># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，</span>
这个数字越小，完成failover所需的时间就越长，
但是如果这个数字越大，就意味着越 多的slave因为replication而不可用
可以通过将这个值设为 <span>1</span> 来保证每次只有一个slave 处于不能处理命令请求的状态
<span># sentinel parallel-syncs &lt;master-name> &lt;numslaves></span>
sentinel parallel-syncs mymaster <span>1</span>
 
 
 
<span># 故障转移的超时时间 failover-timeout 可以用在以下这些方面：</span>
<span>#1. 同一个sentinel对同一个master两次failover之间的间隔时间</span>
<span>#2. 当一个slave从一个错误的master那里同步数据开始计算时间直到slave被纠正为向正确的master那里同步数据时</span>
<span>#3.当想要取消一个正在进行的failover所需要的时间  </span>
<span>#4.当进行failover时，配置所有slaves指向新的master所需的最大时间不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span>
<span># 默认三分钟</span>
<span># sentinel failover-timeout &lt;master-name> &lt;milliseconds></span>
sentinel failover-timeout mymaster <span>180000</span>
 
<span># SCRIPTS EXECUTION</span>
 
<span>#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员</span>
<span>#对于脚本的运行结果有以下规则：</span>
<span>#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span>
<span>#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行</span>
<span>#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同</span>
<span>#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行</span>
 
<span>#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，</span>
<span>#这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息调用该脚本时，将传给脚本两个参数，</span>
<span>#一个是事件的类型，</span>
<span>#一个是事件的描述</span>
<span>#如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功</span>
<span>#通知脚本</span>
<span># sentinel notification-script &lt;master-name> &lt;script-path></span>
  sentinel notification-script mymaster /var/redis/notify.sh
 
<span># 客户端重新配置主节点参数脚本</span>
<span># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息</span>
<span># 以下参数将会在调用脚本时传给脚本:</span>
<span># &lt;master-name> &lt;role> &lt;state> &lt;from-ip> &lt;from-port> &lt;to-ip> &lt;to-port></span>
<span># 目前&lt;state>总是“failover”,</span>
<span># &lt;role>是“leader”或者“observer”中的一个 </span>
<span># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span>
<span># 这个脚本应该是通用的，能被多次调用，不是针对性的</span>
<span># sentinel client-reconfig-script &lt;master-name> &lt;script-path></span>
sentinel client-reconfig-script mymaster /var/redis/reconfig.sh


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br></div></div><p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Set 类型</title>
    <id>https://www.snowji.cn/databases/redis/set/</id>
    <link href="https://www.snowji.cn/databases/redis/set/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="set-类型"> Set 类型</h1>
<p>Set 是无序不重复集合</p>
<h2 id="sadd"> sadd</h2>
<p>添加元素</p>
<p><strong>语法</strong>：</p>
<div><pre><code>sadd key member<span>[</span>member<span>..</span><span>..</span>.<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> sadd myset <span>"hello"</span>     <span># set 中添加元素</span>
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> sadd myset <span>"redis"</span>
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> smembers myset        <span># 查看指定 set 的所有值</span>
<span>1</span><span>)</span> <span>"hello"</span>
<span>2</span><span>)</span> <span>"redis"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> sismember myset hello    <span># 判断某一个是不是在 set 中存在</span>
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> sismember myset other
<span>(</span>integer<span>)</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="scard"> scard</h2>
<p>获取当前 Set 中的元素个数</p>
<p><strong>语法</strong>：</p>
<div><pre><code>scard key
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> scard myset
<span>(</span>integer<span>)</span> <span>2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="srem"> srem</h2>
<p>移除 Set 中的某一个值</p>
<p><strong>语法</strong>：</p>
<div><pre><code>srem key member<span>[</span>member<span>..</span><span>..</span><span>]</span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> srem myset hello   <span># 移除 set 集合中的指定元素</span>
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> scard myset
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> smembers myset
<span>1</span><span>)</span> <span>"redis"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="srandmember"> srandmember</h2>
<p>随机获取 Set 中的元素</p>
<p><strong>语法</strong>:</p>
<div><pre><code>srandmember key <span>[</span>count<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> sadd myset value1 value2 value3
<span>(</span>integer<span>)</span> <span>3</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> SRANDMEMBER myset      <span># 随机抽选一个元素</span>
<span>"redis"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> SRANDMEMBER myset 
<span>"world"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> SRANDMEMBER myset <span>2</span>    <span># 随机抽选指定个数的元素</span>
<span>1</span><span>)</span> <span>"value2"</span>
<span>2</span><span>)</span> <span>"redis"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="spop"> spop</h2>
<p>删除随机的元素</p>
<p><strong>语法</strong>:</p>
<div><pre><code>spop key
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> spop myset     <span># 随机删除一个元素</span>
<span>"redis"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> spop myset
<span>"value2"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> smembers myset
<span>1</span><span>)</span> <span>"value3"</span>
<span>2</span><span>)</span> <span>"world"</span>
<span>3</span><span>)</span> <span>"value1"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="smove"> smove</h2>
<p>将一个指定的值移动到另外一个 Set 集合中</p>
<p><strong>语法</strong>:</p>
<div><pre><code>smove <span>source</span> destination member
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> sadd myset hello world redis other
<span>(</span>integer<span>)</span> <span>4</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> sadd myset1 set1
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> smove myset myset1 redis
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> smembers myset
<span>1</span><span>)</span> <span>"hello"</span>
<span>2</span><span>)</span> <span>"world"</span>
<span>3</span><span>)</span> <span>"other"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> smembers myset1
<span>1</span><span>)</span> <span>"set1"</span>
<span>2</span><span>)</span> <span>"redis"</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id="sdiff-sinter-sunion"> sdiff/sinter/sunion</h2>
<p>查看两个 Set 的 差集、交集、并集</p>
<p>应用：微博等共同关注（并集）</p>
<p><strong>语法</strong>：</p>
<div><pre><code><span>sdiff</span> key<span>[</span>key<span>..</span><span>..</span><span>]</span>
sinter key<span>[</span>key<span>..</span><span>..</span><span>]</span> 
sunion key<span>[</span>key<span>..</span><span>..</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> sadd key1 a b c
<span>(</span>integer<span>)</span> <span>3</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> sadd key2 c d e
<span>(</span>integer<span>)</span> <span>3</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> <span>sdiff</span> key1 key2      <span># 查看差集</span>
<span>1</span><span>)</span> <span>"b"</span>
<span>2</span><span>)</span> <span>"a"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> sinter key1 key2     <span># 查看交集</span>
<span>1</span><span>)</span> <span>"c"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> sunion key1 key2     <span># 查看并集</span>
<span>1</span><span>)</span> <span>"b"</span>
<span>2</span><span>)</span> <span>"a"</span>
<span>3</span><span>)</span> <span>"c"</span>
<span>4</span><span>)</span> <span>"e"</span>
<span>5</span><span>)</span> <span>"d"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Redis 发布订阅</title>
    <id>https://www.snowji.cn/databases/redis/subscribe/</id>
    <link href="https://www.snowji.cn/databases/redis/subscribe/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="redis-发布订阅"> Redis 发布订阅</h1>
<h2 id="什么是-redis-发布订阅"> 什么是 Redis 发布订阅</h2>
<ul>
<li>是一种消息通信模式</li>
<li>发送者(pub)发送消息，订阅者(sub)接收消息</li>
<li>Redis 客户端可以订阅任意数量的频道</li>
</ul>
<p>订阅/发布消息图：</p>
<p><img src="./images/xx1.png" alt="pub/sub" /></p>
<p>下图展示了频道 channel1，以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p>
<p><img src="./images/xx2.png" alt="pub/sub" /></p>
<p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时，这个消息就会被发送给订阅它的三个客户端：</p>
<p><img src="./images/xx3.png" alt="pub/sub" /></p>
<h2 id="发布订阅命令"> 发布订阅命令</h2>
<p>列出了常用的发布订阅命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>PSUBSCRIBE pattern [pattern ...]</td>
<td>订阅一个或多个符合给定模式的频道</td>
</tr>
<tr>
<td>PUBSUB subcommand [argument [argument ...]]</td>
<td>查看订阅与发布系统状态</td>
</tr>
<tr>
<td>PUBLISH channel message</td>
<td>将信息发送到指定的频道</td>
</tr>
<tr>
<td>PUNSUBSCRIBE [pattern [pattern ...]]</td>
<td>退订所有给定模式的频道</td>
</tr>
<tr>
<td>SUBSCRIBE channel [channel ...]</td>
<td>订阅给定的一个或多个频道的信息</td>
</tr>
<tr>
<td>UNSUBSCRIBE [channel [channel ...]]</td>
<td>退订一个或多个频道</td>
</tr>
</tbody>
</table>
<p><strong>示例</strong>：</p>
<div><pre><code>---------------------------订阅端-----------------------------
<span>127.0</span>.0.1:637<span><span>9</span>></span> SUBSCRIBE redisChat
 
Reading messages<span>..</span>. <span>(</span>press Ctrl-C to quit<span>)</span>
<span>1</span><span>)</span> <span>"subscribe"</span>
<span>2</span><span>)</span> <span>"redisChat"</span>
<span>3</span><span>)</span> <span>(</span>integer<span>)</span> <span>1</span>
<span># 订阅者的客户端会显示如下消息</span>
<span>1</span><span>)</span> <span>"message"</span>
<span>2</span><span>)</span> <span>"redisChat"</span>
<span>3</span><span>)</span> <span>"Redis is a great caching technique"</span>
<span>1</span><span>)</span> <span>"message"</span>
<span>2</span><span>)</span> <span>"redisChat"</span>
<span>3</span><span>)</span> <span>"Learn redis by w3cschool.cc"</span>

---------------------------消息发布端-----------------------------
<span>127.0</span>.0.1:637<span><span>9</span>></span> PUBLISH redisChat <span>"Redis is a great caching technique"</span>
 
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> PUBLISH redisChat <span>"Learn redis by w3cschool.cc"</span>
 
<span>(</span>integer<span>)</span> <span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h2 id="原理"> 原理</h2>
<ul>
<li>通过 SUBSCRIBE 命令订阅频道后，redis-server 服务器进程都维护着一个字典</li>
<li>字典的键为正在被订阅的频道，而字典的值则是一个链表</li>
<li>链表中保存了所有订阅这个频道的客户端</li>
<li>SUBSCRIBE 命令的关键就是将客户端添加到指定 channel 的订阅链表中</li>
</ul>
<p><img src="./images/xx4.png" alt="pub/sub" /></p>
<p>客户端订阅，就被链接到对应频道的链表的尾部，退订则就是将客户端节点从链表中移除</p>
<ul>
<li>通过 PUBLISH 命令向订阅者发送消息，redis-server 会使用指定的频道作为键</li>
<li>在所维护的 channel 字典中查找订阅了该频道的所有客户端链表</li>
<li>遍历链表，将消息发送给所有订阅者</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>如果一个客户端订阅了频道，但读取消息的速度不快，不断积压的消息会使 Redis 输出缓冲区的体积变得越来越大，这可能使得 Redis 本身的速度变慢，甚至直接崩溃</li>
<li>这和数据传输可靠性有关，如果在订阅方断线，那么他将会丢失所有在短线期间发布者发布的消息</li>
</ul>
<p><strong>应用场景</strong>:</p>
<ul>
<li>消息订阅：公众号订阅，微博关注等等（起始更多是使用消息队列来进行实现）</li>
<li>实时聊天（频道当作聊天室，将信息回显给所有人）</li>
<li>实时消息系统</li>
</ul>
<p>稍微复杂的场景就会使用消息中间件 MQ 处理</p>
<h2 id="参考文档"> 参考文档</h2>
<p><a href="https://www.redis.net.cn/tutorial/3514.html" target="_blank" rel="noopener noreferrer">官方文档-Redis 发布订阅</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">String 类型</title>
    <id>https://www.snowji.cn/databases/redis/string/</id>
    <link href="https://www.snowji.cn/databases/redis/string/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="string-类型"> String 类型</h1>
<h2 id="append"> append</h2>
<p><strong>语法</strong>：</p>
<div><pre><code>append key value
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> <span>set</span> key1 v1
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> APPEND key1 <span>"hello"</span>
<span>(</span>integer<span>)</span> <span>7</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> get key1
<span>"v1hello"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><div><p>注意</p>
<p>如果 append 的键不存在，会新建值然后赋值</p>
</div>
<h2 id="strlen"> strlen</h2>
<p><strong>语法</strong>：</p>
<div><pre><code>STRLEN key 
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> STRLEN key1
<span>(</span>integer<span>)</span> <span>7</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="incr-decr"> incr/decr</h2>
<p><strong>语法</strong>：</p>
<div><pre><code>incr key
decr key
incrby key value
decrby key value
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> <span>set</span> views <span>0</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> incr views   <span># 自增1 </span>
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> incr views
<span>(</span>integer<span>)</span> <span>2</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> decr views  <span># 自减1</span>
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> decr views
<span>(</span>integer<span>)</span> <span>0</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> incrby views <span>10</span>   <span># 按步长自增</span>
<span>(</span>integer<span>)</span> <span>10</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> incrby views <span>10</span>
<span>(</span>integer<span>)</span> <span>20</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> decrby views <span>5</span>    <span># 按步长自减</span>
<span>(</span>integer<span>)</span> <span>15</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id="getrange-setrange"> getrange/setrange</h2>
<p><strong>语法</strong>：</p>
<div><pre><code>getrange key start end
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> <span>set</span> key1 <span>"hello,redis"</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> get key1
<span>"hello,redis"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> getrange key1 <span>0</span> <span>3</span>   <span># 截取字符串 [0,3]</span>
<span>"hell"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> getrange key1 <span>0</span> -1  <span># 截取全部字符串</span>
<span>"hello,redis"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> <span>set</span> key2 abcdefg   
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> get key2
<span>"abcdefg"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> setrange key2 <span>1</span> xx   <span># 替换指定位置开始的字符串</span>
<span>(</span>integer<span>)</span> <span>7</span> 
<span>127.0</span>.0.1:637<span><span>9</span>></span> get key2
<span>"axxdefg"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="setex-setnx"> setex/setnx</h2>
<p><strong>语法</strong>：</p>
<div><pre><code>setex<span>(</span>set with expire<span>)</span> key seconds value               <span># 设置过期时间</span>
setnx<span>(</span>set <span>if</span> not exist<span>)</span>  key value             <span># 不存在在设置(在分布式锁中会常常使用)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> setex key3 <span>30</span> <span>"hello"</span>  <span># 设置 key3 的值 30 秒后过期</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> ttl key3
<span>(</span>integer<span>)</span> <span>24</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> setnx mykey <span>"redis"</span>   <span>#  如果 mykey 不存在，创建 mykey</span>
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> keys *
<span>1</span><span>)</span> <span>"mykey"</span>
<span>2</span><span>)</span> <span>"key1"</span>
<span>3</span><span>)</span> <span>"key3"</span>
<span>4</span><span>)</span> <span>"key2"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> ttl keys3
<span>(</span>integer<span>)</span> -2
<span>127.0</span>.0.1:637<span><span>9</span>></span> setnx mykey <span>"mongodb"</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> get mykey
<span>"mongodb"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id="批量-set-get"> 批量 set/get</h2>
<p><strong>语法</strong>：</p>
<div><pre><code>MSET key1 value1 <span>[</span>key2 value2<span>..</span><span>]</span>
MGET key1 <span>[</span>key2<span>..</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> mset k1 v1 k2 v2 k3 v3  <span># 同时设置多个值</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> keys *
<span>1</span><span>)</span> <span>"k1"</span>
<span>2</span><span>)</span> <span>"k3"</span>
<span>3</span><span>)</span> <span>"k2"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> mget k1 k2 k3    <span># 同时获取多个值</span>
<span>1</span><span>)</span> <span>"v1"</span>
<span>2</span><span>)</span> <span>"v2"</span>
<span>3</span><span>)</span> <span>"v3"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> msetnx k1 v1 k4 v4  <span># msetnx 是一个原子性操作，要么一起成功，要么一起失败</span>
<span>(</span>integer<span>)</span> <span>0</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="设置对象"> 设置对象</h2>
<p><strong>语法</strong>：</p>
<div><pre><code><span>set</span> user:1 <span>{</span>name:zhangsan,age:3<span>}</span>  <span># 设置一个user:1 对象，值为 json 字符串来保存一个对象</span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> mset user:1:name  zhangsan 
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> mget user:1:name
<span>1</span><span>)</span> <span>"zhangsan"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="getset"> getset</h2>
<p><strong>语法</strong>：</p>
<div><pre><code>getset key value     <span># 先 get 在 set，返回key的上一个值</span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> getset db redis   <span># 不存在值，返回 nil</span>
<span>(</span>nil<span>)</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> get db
<span>"redis"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> getset db mongodb   <span># 存在值，则返回原来的值，并设置新的值</span>
<span>"redis"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> get db
<span>"mongodb"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><p>总结</p>
<p>String 类型中的 value 除了是字符串还可以是数字，使用场景：</p>
<ul>
<li>计数器</li>
<li>统计多单位的数量：uid:123666：follow 0</li>
<li>粉丝数</li>
<li>对象存储缓存</li>
</ul>
</div>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Zset 类型</title>
    <id>https://www.snowji.cn/databases/redis/zset/</id>
    <link href="https://www.snowji.cn/databases/redis/zset/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="zset-类型"> Zset 类型</h1>
<ul>
<li>有序集合</li>
<li>在 Set 的基础上增加了一个值</li>
</ul>
<h2 id="zadd"> zadd</h2>
<p>添加有序的成员</p>
<p><strong>语法</strong>:</p>
<div><pre><code>zadd key score member<span>[</span>score menber<span>..</span><span>..</span><span>]</span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> zadd myset <span>1</span> one <span>2</span> two
<span>(</span>integer<span>)</span> <span>2</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> zget myset
<span>(</span>error<span>)</span> ERR unknown <span>command</span> <span>'zget'</span>, with args beginning with: <span>'myset'</span> 
<span>127.0</span>.0.1:637<span><span>9</span>></span> zrange myset <span>0</span> -1
<span>1</span><span>)</span> <span>"one"</span>
<span>2</span><span>)</span> <span>"two"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="zrangebyscore-zrevrange"> zrangebyscore/zrevrange</h2>
<p>zrangebyscore：根据 score 进行升序</p>
<p>zrevrange：降序</p>
<p><strong>语法</strong>：</p>
<div><pre><code>zrangebyscore key min max <span>[</span>withscores<span>]</span> <span>[</span>limit offest count<span>]</span>
zrevrange key start stop <span>[</span>withscores<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> zadd salary <span>2500</span> xiaohong <span>5000</span> zhangsan <span>500</span> lisi 
<span>(</span>integer<span>)</span> <span>3</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> ZRANGEBYSCORE salary -inf +inf     <span># 显示全部的用户按从小到大排序</span>
<span>1</span><span>)</span> <span>"lisi"</span>
<span>2</span><span>)</span> <span>"xiaohong"</span>
<span>3</span><span>)</span> <span>"zhangsan"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> ZRANGEBYSCORE salary -inf +inf withscores <span># 显示全部的用户按从小到大排序并且附带成绩</span>
<span>1</span><span>)</span> <span>"lisi"</span>
<span>2</span><span>)</span> <span>"500"</span>
<span>3</span><span>)</span> <span>"xiaohong"</span>
<span>4</span><span>)</span> <span>"2500"</span>
<span>5</span><span>)</span> <span>"zhangsan"</span>
<span>6</span><span>)</span> <span>"5000"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> ZRANGEBYSCORE salary -inf <span>2500</span> withscores   <span># 显示小于2500 的升序排列</span>
<span>1</span><span>)</span> <span>"lisi"</span>
<span>2</span><span>)</span> <span>"500"</span>
<span>3</span><span>)</span> <span>"xiaohong"</span>
<span>4</span><span>)</span> <span>"2500"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> ZREVRANGE salary <span>0</span> -1      <span># 按从大到小降序</span>
<span>1</span><span>)</span> <span>"zhangsan"</span>
<span>2</span><span>)</span> <span>"lisi"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h2 id="zrem-zcard"> zrem/zcard</h2>
<p>移除元素/查看元素个数</p>
<p><strong>语法</strong>:</p>
<div><pre><code>zrem key member<span>[</span>member<span>..</span><span>..</span><span>]</span>
zcard key
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> zrange salary <span>0</span> -1
<span>1</span><span>)</span> <span>"lisi"</span>
<span>2</span><span>)</span> <span>"xiaohong"</span>
<span>3</span><span>)</span> <span>"zhangsan"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> zrem salary xiaohong      <span># 移除有序集合中的指定元素</span>
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> zrange salary <span>0</span> -1
<span>1</span><span>)</span> <span>"lisi"</span>
<span>2</span><span>)</span> <span>"zhangsan"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> zcard salary       <span># 获取有序集合中的元素个数</span>
<span>(</span>integer<span>)</span> <span>2</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="zcount"> zcount</h2>
<p>获取指定区间的元素个数</p>
<p><strong>语法</strong>：</p>
<div><pre><code>zcount key min max
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> zadd myset <span>1</span> hello <span>2</span> world <span>3</span> redis
<span>(</span>integer<span>)</span> <span>3</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> zcount myset <span>1</span> <span>2</span>    <span># 获取指定区间的元素个数</span>
<span>(</span>integer<span>)</span> <span>2</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> zcount myset <span>1</span> <span>3</span>
<span>(</span>integer<span>)</span> <span>3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><p>应用案例：</p>
<ul>
<li>Set 排序存储班级成绩表，工资表排序</li>
<li>普通消息，1 代表重要消息 ，2 代表带权重进行判断</li>
<li>排行榜应用实现，取 Top N 测试</li>
</ul>
</div>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">更新日志</title>
    <id>https://www.snowji.cn/history/</id>
    <link href="https://www.snowji.cn/history/"/>
    <updated>2022-08-25T01:58:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="更新日志"> 更新日志</h1>
<p>记录走过的每一步……</p>
<h2 id="_1-自动化测试系列"> 1. 自动化测试系列</h2>
<ul>
<li>2020.07   添加 Web 自动化测试 的《xxx》章节。</li>
<li>2020.07   添加小程序自动化测试的《xx》章节。</li>
</ul>
<h2 id="_2-测试基础系列"> 2. 测试基础系列</h2>
<ul>
<li>2021.05 添加测试基础的 《API如何测试》章节。</li>
<li>2021.05 添加测试基础的 《测试覆盖率》章节。</li>
<li>2021.05 添加测试基础的 《测试工程师核心竞争力》章节。</li>
<li>2021.05 添加测试基础的 《代码级测试方法》章节。</li>
<li>2021.05 添加测试基础的 《互联网产品如何设计测试策略》章节。</li>
<li>2021.05 添加测试基础的 《开篇之典项用户登录》章节。</li>
<li>2021.05 添加测试基础的 《如何才能做好测试计划》章节。</li>
<li>2021.05 添加测试基础的 《如何高效填写缺陷》章节。</li>
<li>2021.05 添加测试基础的 《如何设计好的测试用例》章节。</li>
<li>2021.05 添加测试基础的 《深入浅出静态方法》章节。</li>
<li>2021.05 添加测试基础的 《微服务下的API测试》章节。</li>
<li>2021.05 添加测试基础的 《移动应用测试方法及思路》章节。</li>
<li>2021.05 添加测试基础的 《自动化理解及应用场景》章节。</li>
</ul>
<h2 id="_3-nginx-系列"> 3. Nginx 系列</h2>
<ul>
<li>2021.05 添加 Nginx 的 《配置文件》章节。</li>
<li>2021.05 添加 Nginx 的 《安装》章节。</li>
<li>2021.05 添加 Nginx 的 《基础配置》章节。</li>
</ul>
<h2 id="_4-docker-系列"> 4. Docker 系列</h2>
<ul>
<li>2021.06 添加 Docker 的 《docker常用命令》章节。</li>
<li>2021.06 添加 Docker 的 《docker安装》章节。</li>
<li>2021.06 添加 Docker 的 《docker镜像制作》章节。</li>
<li>2021.06 添加 Docker 的 《docker网络》章节。</li>
</ul>
<h2 id="_5-linux-系列"> 5. Linux 系列</h2>
<ul>
<li>2021.07 添加 Linux 的 《权限操作》章节。</li>
<li>2021.07 添加 Linux 的 《文件打包与压缩》章节。</li>
<li>2021.07 添加 Linux 的 《常用文件和目录操作命令》章节。</li>
</ul>
<h2 id="_6-network-系列"> 6. Network 系列</h2>
<ul>
<li>2021.11 添加 Network 的《ARP协议》章节。</li>
<li>2021.11 添加 Network 的《DHCP协议》章节。</li>
<li>2021.11 添加 Network 的《DNS协议》章节。</li>
<li>2021.11 添加 Network 的《HTTP协议》章节。</li>
<li>2021.11 添加 Network 的《IP协议》章节。</li>
<li>2021.12 添加 Network 的《IP地址》章节。</li>
<li>2021.12 添加 Network 的《TCP协议》章节。</li>
<li>2021.12 添加 Network 的《网络分层》章节。</li>
<li>2021.12 添加 Network 的《子网掩码》章节。</li>
<li>2021.12 添加 Network 的《UDP协议》章节。</li>
</ul>
<h2 id="_7-python-系列"> 7. Python 系列</h2>
<ul>
<li>2020.09      添加 Python 的 《基础语法》章节。</li>
<li>2021.03      添加 Python 的 《内存回收机制》章节。</li>
<li>2021.04      添加 Python 的 《装饰器》章节。</li>
<li>2021.07      添加 Python 的 《继承》章节。</li>
<li>2021.07      添加 Python 的 《闭包》章节。</li>
<li>2021.07      添加 Python 的 《类与实例》章节。</li>
<li>2021.07      添加 Python 的 《迭代器》章节。</li>
<li>2021.08      添加 Python 的 《变量作用域》章节。</li>
<li>2021.08      添加 Python 的 《数据类型》章节。</li>
<li>2021.08      添加 Python 的 《推导式》章节。</li>
<li>2021.08      添加 Python 的 《循环》章节。</li>
<li>2021.08      添加 Python 的 《pip安装和应用》章节。</li>
<li>2021.08      添加 Python 的 《函数》章节。</li>
<li>2021.09      添加 Python 的 《命名规范》章节。</li>
<li>2021.11      添加 Python 的 《PEP8》章节。</li>
</ul>
<h2 id="_8-数据库系列"> 8. 数据库系列</h2>
<ul>
<li>2021.11.15  添加数据库的《索引》章节。</li>
<li>2021.11.20     添加数据库的《查询》章节。</li>
<li>2021.12.20     添加数据库的《IFNULL函数》章节。</li>
</ul>
<h2 id="_9-产品与运营系列"> 9. 产品与运营系列</h2>
<ul>
<li>2020.08.15  添加产品的《xxx》章节。</li>
<li>2020.08.15   添加运营的《xxx促销案例拆解》章节。</li>
</ul>
<h2 id="_10-个人总结系列"> 10. 个人总结系列</h2>
<ul>
<li>2020.07.26   添加《2020 上半年总结》。</li>
</ul>
<h2 id="_11-读书笔记系列"> 11. 读书笔记系列</h2>
<ul>
<li>2020.08  添加书籍《数据思维》。</li>
<li>2020.08  添加书籍《终身成长》。</li>
<li>2020.08  添加书籍《刻意练习》。</li>
<li>2020.08  添加书籍《掌控习惯》。</li>
<li>2020.10  添加书籍《终结拖延症》。</li>
<li>2021.11     添加书籍《游戏改变世界》。</li>
</ul>
<h2 id="_12-其他系列"> 12. 其他系列</h2>
<ul>
<li>2020.09  添加如何写总结。</li>
<li>2021.02     2020 年终总结</li>
</ul>
<h2 id="维护"> 维护</h2>
<ul>
<li>2020.07   购买域名，部署上线。</li>
<li>2020.07   使用 VuePress 在 Github Pages 上搭建技能书。</li>
</ul>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T01:58:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">PEP8</title>
    <id>https://www.snowji.cn/languages/python/basics/PEP8/</id>
    <link href="https://www.snowji.cn/languages/python/basics/PEP8/"/>
    <updated>2022-10-30T08:58:48.000Z</updated>
    <content type="html"><![CDATA[<h1 id="pep8"> PEP8</h1>
<h2 id="什么是-pep8-风格"> 什么是 PEP8 风格</h2>
<ul>
<li>Python Enhancement Proposal #8 叫作 PEP 8</li>
<li>它是一份针对 Python 代码格式而编订的风格指南</li>
<li>尽管只要语法正确，代码随便怎么写都行，但采用一致的风格可以使代码更易读、更易懂</li>
</ul>
<h2 id="与空白有关的建议"> 与空白有关的建议</h2>
<p>在 Python 中，空白（whitespace）在语法上相当重要</p>
<ul>
<li>用<strong>空格</strong>（space）表示缩进，而不要用制表符（tab）</li>
<li>和语法相关的每一层缩进都用 <strong>4</strong> 个空格表示</li>
<li>每行不超过 <strong>79</strong> 个字符</li>
<li>对于占据多行的长表达式来说，除了首行之外的其余各行都应该在通常的缩进级别之上再加 4 个空格</li>
<li>在同一份文件中，函数与类之间用 <strong>2</strong> 个空行隔开</li>
<li>在同一个类中，方法与方法之间用 <strong>1</strong> 个空行隔开</li>
<li>使用字典时，键与冒号之间不加空格，写在同一行的冒号和值之间应该加 <strong>1</strong> 个空格</li>
<li>给变量赋值时，赋值符号的左边和右边各加 <strong>1</strong> 个空格，并且只加一个空格就好</li>
<li>给变量的类型做注解（annotation）时，不要把变量名和冒号隔开，但在类型信息前应该有一个空格</li>
</ul>
<p>这个其实不用硬背，用 PyCharm 的话代码格式化会自动完成这些事。</p>
<h2 id="与命名有关的建议"> 与命名有关的建议</h2>
<h4 id="函数、变量及属性"> 函数、变量及属性</h4>
<ul>
<li>用小写字母来拼写，各单词之间用下划线相连</li>
<li><code>lowercase_underscore</code></li>
</ul>
<h4 id="受保护的实例属性"> 受保护的实例属性</h4>
<ul>
<li>用一个下划线开头</li>
<li><code>_leading_underscore</code></li>
</ul>
<h4 id="私有的实例属性"> 私有的实例属性</h4>
<ul>
<li>用两个下划线开头</li>
<li><code>__double_leading_underscore</code></li>
</ul>
<h4 id="类-包括异常-命名"> 类（包括异常）命名</h4>
<ul>
<li>每个单词的首字母均大写</li>
<li><code>CapitalizedWord</code></li>
</ul>
<h4 id="模块级别的常量"> 模块级别的常量</h4>
<ul>
<li>所有字母都大写，各单词之间用下划线相连</li>
<li><code>ALL_CAPS</code></li>
</ul>
<h4 id="类中的实例方法"> 类中的实例方法</h4>
<p>应该把第一个参数命名为 <code>self</code>，用来表示该对象本身</p>
<h4 id="类方法"> 类方法</h4>
<p>第一个参数，应该命名为 <code>cls</code>，用来表示这个类本身</p>
<h2 id="与表达式和语句有关的建议"> 与表达式和语句有关的建议</h2>
<h4 id="采用行内否定"> 采用行内否定</h4>
<ul>
<li>把否定词直接写在<strong>要否定的内容前面</strong>，而不要放在整个表达式的前面</li>
<li>例如应该写 <code>if a is not b</code>，而不是 <code>if not a is b</code></li>
</ul>
<h4 id="不要通过长度判断容器或序列是不是空的"> 不要通过长度判断容器或序列是不是空的</h4>
<ul>
<li>例如不要通过 <code>if len(somelist) == 0</code> 判断 <code>somelist</code> 是否为 <code>[]</code> 或 <code>''</code> 等空值</li>
<li>而是应该采用 <code>if not somelist</code> 这样的写法来判断，因为 Python 会把空值自动评估为 <code>False</code></li>
</ul>
<h4 id="不要把-if-语句、for-循环、while-循环及-except-复合语句挤在一行"> 不要把 if 语句、for 循环、while 循环及 except 复合语句挤在一行</h4>
<ul>
<li>应该把这些语句分成多行来写，这样更加清晰</li>
<li>如果表达式一行写不下，可以用<strong>括号</strong>将其括起来，而且要适当地添加换行与缩进以便于阅读</li>
</ul>
<h4 id="多行的表达式"> 多行的表达式</h4>
<p>应该用括号括起来，而不要用 <code>\</code></p>
<div><pre><code><span># 错误示范</span>
folder<span>[</span><span>"interfaces"</span><span>]</span> <span>=</span> db<span>.</span>query<span>(</span>Interface<span>)</span><span>.</span> \
    <span>filter</span><span>(</span>folder_id <span>==</span> Interface<span>.</span>folder_id<span>,</span>
           Interface<span>.</span>is_delete <span>==</span> <span>0</span><span>)</span><span>.</span> \
    <span>all</span><span>(</span><span>)</span>

<span># 正确示范</span>
folder<span>[</span><span>"interfaces"</span><span>]</span> <span>=</span> <span>(</span>
    db<span>.</span>query<span>(</span>Interface<span>)</span>
    <span>.</span><span>filter</span><span>(</span>folder_id <span>==</span> Interface<span>.</span>folder_id<span>,</span> Interface<span>.</span>is_delete <span>==</span> <span>0</span><span>)</span>
    <span>.</span><span>all</span><span>(</span><span>)</span>
<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="与-import-有关的建议"> 与 import 有关的建议</h2>
<ul>
<li>import 语句（含 <code>from x import y</code>）总是应该放在<strong>文件开头</strong></li>
<li>引入模块时，总是应该使用绝对名称，而不应该根据当前模块路径来使用相对名称</li>
<li>例如，要引入 bar 包中的 foo 模块，应该完整地写出 <code>from bar import foo</code>，即便当前路径为 bar 包里，也不应该简写为 <code>import foo</code></li>
<li>如果一定要用相对名称来编写 import 语句，那就应该明确地写成 <code>from . import foo</code></li>
</ul>
<h4 id="文件中的-import-语句应该按顺序划分成三个部分"> 文件中的 import 语句应该按顺序划分成三个部分</h4>
<ul>
<li>首先引入标准库里的模块</li>
<li>然后引入第三方模块</li>
<li>最后引入自己的模块</li>
</ul>
<p>属于同一个部分的 import 语句按<strong>字母</strong>顺序排列</p>
<blockquote>
<p>不想自己手动来保证 import 的顺序是符合规范的，可以借助 <a href="https://pycqa.github.io/isort/index.html" target="_blank" rel="noopener noreferrer"><code>isort</code></a> 这个工具来自动完成。</p>
<div><pre><code><span># 安装</span>
pip <span>install</span> isort

<span># 指定文件</span>
isort mypythonfile.py mypythonfile2.py

<span># 当前目录所有文件</span>
isort <span>.</span>

<span># 查看修改建议，但不会修改文件</span>
isort mypythonfile.py --diff
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></blockquote>
<h2 id="pylint"> Pylint</h2>
<ul>
<li>是 Python 源码静态分析工具</li>
<li>它可以自动检查受测代码是否符合 PEP 8 风格指南，而且还能找出 Python 程序里的许多种常见错误</li>
<li>感兴趣可以自行百度学习，这里不展开讲解了</li>
</ul>
<h2 id="参考资料"> 参考资料</h2>
<ul>
<li><a href="https://peps.python.org/pep-0008/" target="_blank" rel="noopener noreferrer">官方</a></li>
<li><a href="https://www.cnblogs.com/ajianbeyourself/p/4377933.html" target="_blank" rel="noopener noreferrer">中文翻译博客</a></li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T06:24:56.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Python 简介</title>
    <id>https://www.snowji.cn/languages/python/basics/</id>
    <link href="https://www.snowji.cn/languages/python/basics/"/>
    <updated>2022-09-02T06:24:56.000Z</updated>
    <content type="html"><![CDATA[<h1 id="python-简介"> Python 简介</h1>
<h2 id="简介"> 简介</h2>
<p>Python 是一种计算机设计语言，常被称作解释性语言，与 Javascript 一样是一门动态的语言，语法上没有像其他语言严谨，如：Java 、C 语言等。相比之下，语法更简单，更容易入门。</p>
<h2 id="解释器"> 解释器</h2>
<ul>
<li>
<p>CPython</p>
<p>从官方下载的 Python 安装文件后安装成功后，就会得到一个 CPython 解释器，因此解释器使用 C 语言编写的，因此叫 CPython，是一种常用的 Python 解释器。</p>
</li>
<li>
<p>IPython</p>
<p>是基于 CPython 之上的一个交互式解释器，只是在交互方式上有所增强，但是执行代码的能力和 CPython 是一样的。</p>
</li>
<li>
<p>PyPy</p>
<p>是另一种解释器，执行速度快。采用 JIT 技术，对代码进行动态编译，可以显著提高执行速度</p>
</li>
<li>
<p>JPython</p>
<p>是运行在 Java 平台上的 Python 解释器，可以直接把 Python 代码编译成 Java 代码</p>
</li>
</ul>
<h2 id="环境搭建"> 环境搭建</h2>
<p>目前 Python 2 从 2020.01.01 日起，将不支持更新，本博客基于 Python3 。</p>
<ul>
<li>从  https://www.python.org/getit/  网站上，根据情况下载相应的安装包</li>
<li>安装后，需要将安装目录下的 python.exe 所在目录路径添加至环境变量中</li>
<li>完成后，在 cmd 或 shell 中输入 <code>python -V</code> 查看是否安装成功</li>
</ul>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T06:24:56.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">__name__ =__main__</title>
    <id>https://www.snowji.cn/languages/python/basics/__name__/</id>
    <link href="https://www.snowji.cn/languages/python/basics/__name__/"/>
    <updated>2022-09-20T02:59:07.000Z</updated>
    <content type="html"><![CDATA[<h1 id="name-main"> <code>__name__ =__main__</code></h1>
<p>先来看个例子：</p>
<p><code>test_one.py</code>：</p>
<div><pre><code>PI <span>=</span> <span>3.14</span>

<span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span>print</span> <span>"PI:"</span><span>,</span> PI

main<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><code>test_two.py</code>：从 <code>test_one.py</code> 中引入 PI</p>
<div><pre><code><span>from</span> const <span>import</span> PI

<span>def</span> <span>calc_round_area</span><span>(</span>radius<span>)</span><span>:</span>
    <span>return</span> PI <span>*</span> <span>(</span>radius <span>**</span> <span>2</span><span>)</span>

<span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span>print</span> <span>"round area: "</span><span>,</span> calc_round_area<span>(</span><span>2</span><span>)</span>

main<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>运行 <code>test_two.py</code>：</p>
<div><pre><code>PI<span>:</span> <span>3.14</span>
<span>round</span> area<span>:</span>  <span>12.56</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>发现 <code>test_one.py</code> 中的函数被执行了，这是为什么呢？</p>
<p><strong>原因</strong>：</p>
<p>Python 是从上至下，边解释边执行，在模块被导入时，会将模块中的代码先执行</p>
<p>那如果希望被引入的模块中的函数不执行，可以使用<code>if __name__=='__main__'</code></p>
<p>修改下 <code>test_one.py</code> 中的代码：</p>
<div><pre><code>PI <span>=</span> <span>3.14</span>

<span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span>print</span> <span>"PI:"</span><span>,</span> PI

<span>if</span> __name__ <span>==</span> <span>"__main__"</span><span>:</span>
    main<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>再次执行 <code>test_two.py</code> 时，就不会执行 <code>test_one.py</code> 中的函数了：</p>
<div><pre><code>PI<span>:</span> <span>3.14</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="name"> <code>__name__</code></h2>
<ul>
<li>是内置变量</li>
<li>表示当前模块的名字</li>
</ul>
<p><strong><code>if __name__ == '__main__'</code> 的作用</strong>：</p>
<ul>
<li>如果作为脚本直接运行，<code>if __name__ == '__main__'</code> 前后的代码都会被执行</li>
<li>如果作为模块被调用，<code>if __name__ == '__main__'</code> 前的代码都会被执行</li>
</ul>
<div><p>运行原理</p>
<ul>
<li>每个 Python 文件都会包含内置的变量 <code>__name__</code></li>
<li>当该模块直接执行时，<code>__name__ == '__main__'</code></li>
<li>如果作为模块被引入到其他模块，<code>__name__ == 模块名称</code>（不包含后缀<code>.py</code>）</li>
<li><code>__main__</code>始终指当前执行模块的名称（包含后缀<code>.py</code>）</li>
</ul>
</div>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-19T07:17:03.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">类与实例</title>
    <id>https://www.snowji.cn/languages/python/basics/class-and-instance/</id>
    <link href="https://www.snowji.cn/languages/python/basics/class-and-instance/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="类与实例"> 类与实例</h1>
<h2 id="类与实例定义"> 类与实例定义</h2>
<h3 id="类"> 类</h3>
<p><strong>定义</strong>： 具有相同属性和方法的对象的集合</p>
<p><strong>基本结构</strong>：</p>
<div><pre><code><span>class</span> 类名<span>(</span>父类列表<span>)</span>：
	<span>pass</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>命名方式</strong>：驼峰式命名</p>
<p><strong>继承</strong>：</p>
<ul>
<li>可同时继承多个父类（也叫基类、超类）</li>
<li>继承的基类有先后顺序</li>
</ul>
<h3 id="实例"> 实例</h3>
<p><strong>定义</strong>：  根据类创建出来的一个个具体的“对象”</p>
<p><strong>实例化方法 <code>__init__</code></strong>：构建类的实例</p>
<div><pre><code><span>class</span> <span>Student</span><span>:</span>   
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>,</span> age<span>)</span><span>:</span>
        self<span>.</span>name <span>=</span> name
        self<span>.</span>age <span>=</span> age
        
zhang <span>=</span> Student<span>(</span><span>"张三"</span><span>,</span> <span>23</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><p>类创建对象的过程：</p>
<ul>
<li>类在实例化时，会先调用 <code>__new__</code> 方法创建实例，然后对实例进行 <code>__init__</code> 初始化</li>
<li>如果类没有指定 <code>__new__</code> 方法，就会调用 Object 的</li>
</ul>
</div>
<h2 id="类与实例变量"> 类与实例变量</h2>
<h3 id="类变量"> 类变量</h3>
<p><strong>定义</strong>： 在类中，但在方法之外的变量</p>
<div><pre><code><span>class</span> <span>Student</span><span>:</span>
    classroom <span>=</span> <span>'101'</span>       <span># 类变量</span>
    address <span>=</span> <span>'beijing'</span>     <span># 类变量</span>

    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>,</span> age<span>)</span><span>:</span>
        self<span>.</span>name <span>=</span> name
        self<span>.</span>age <span>=</span> age

    <span>def</span> <span>print_age</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'%s: %s'</span> <span>%</span> <span>(</span>self<span>.</span>name<span>,</span> self<span>.</span>age<span>)</span><span>)</span>
zhang <span>=</span> Student<span>(</span><span>"张三"</span><span>,</span> <span>23</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><strong>使用</strong>：</p>
<ul>
<li>通过 类名.变量名(Student.classroom) 使用</li>
<li>通过 实例.变量名(zhang.classroom) 使用</li>
</ul>
<h3 id="实例变量"> 实例变量</h3>
<p><strong>定义</strong>： 实例本身拥有的变量</p>
<div><pre><code><span>class</span> <span>Student</span><span>:</span>
    classroom <span>=</span> <span>'101'</span>     
    address <span>=</span> <span>'beijing'</span>     

    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>,</span> age<span>)</span><span>:</span>
        self<span>.</span>name <span>=</span> name   <span>#实例变量</span>
        self<span>.</span>age <span>=</span> age     <span>#实例变量</span>

    <span>def</span> <span>print_age</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'%s: %s'</span> <span>%</span> <span>(</span>self<span>.</span>name<span>,</span> self<span>.</span>age<span>)</span><span>)</span>

li <span>=</span> Student<span>(</span><span>"李四"</span><span>,</span> <span>24</span><span>)</span>
zhang <span>=</span> Student<span>(</span><span>"张三"</span><span>,</span> <span>23</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><strong>使用</strong>：</p>
<ul>
<li>通过 实例名.变量名 方式</li>
</ul>
<p><strong>注意</strong>：使用上方式使用变量时</p>
<ul>
<li>现在实例变量列表中查询是否有该实例变量</li>
<li>实例变量列表中没有，再去类变量列表中查询</li>
</ul>
<div><pre><code><span>>></span><span>></span> <span>class</span> <span>Student</span><span>:</span>              <span># 类的定义体</span>
    classroom <span>=</span> <span>'101'</span>           <span># 类变量</span>
    address <span>=</span> <span>'beijing'</span>

    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>,</span> age<span>)</span><span>:</span>
        self<span>.</span>name <span>=</span> name
        self<span>.</span>age <span>=</span> age

    <span>def</span> <span>print_age</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'%s: %s'</span> <span>%</span> <span>(</span>self<span>.</span>name<span>,</span> self<span>.</span>age<span>)</span><span>)</span>


<span>>></span><span>></span> li <span>=</span> Student<span>(</span><span>"李四"</span><span>,</span> <span>24</span><span>)</span>        <span># 创建一个实例</span>
<span>>></span><span>></span> zhang <span>=</span> Student<span>(</span><span>"张三"</span><span>,</span> <span>23</span><span>)</span>     <span># 创建第二个实例</span>
<span>>></span><span>></span> li<span>.</span>classroom <span># li本身没有classroom实例变量，所以去寻找类变量，它找到了！</span>
<span>'101'</span>
<span>>></span><span>></span> zhang<span>.</span>classroom <span># 与li同理</span>
<span>'101'</span>
<span>>></span><span>></span> Student<span>.</span>classroom   <span># 通过类名访问类变量</span>
<span>'101'</span>
<span>>></span><span>></span> li<span>.</span>classroom <span>=</span> <span>'102'</span>    <span># 关键的一步！实际是为li创建了独有的实例变量，只不过名字和类变量一样，都叫做classroom。</span>
<span>>></span><span>></span> li<span>.</span>classroom    <span># 再次访问的时候，访问到的是li自己的实例变量classroom</span>
<span>'102'</span>
<span>>></span><span>></span> zhang<span>.</span>classroom <span># zhang没有实例变量classroom，依然访问类变量classroom</span>
<span>'101'</span>
<span>>></span><span>></span> Student<span>.</span>classroom   <span># 保持不变</span>
<span>'101'</span>
<span>>></span><span>></span> <span>del</span> li<span>.</span>classroom    <span># 删除了li的实例变量classroom</span>
<span>>></span><span>></span> li<span>.</span>classroom        <span># 一切恢复了原样</span>
<span>'101'</span>
<span>>></span><span>></span> zhang<span>.</span>classroom
<span>'101'</span>
<span>>></span><span>></span> Student<span>.</span>classroom
<span>'101'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><p>防止发生上面的混淆情况，对于类变量，请使用<code>类名.类变量</code>的访问方式，不要用实例去访问类变量</p>
<p><strong>特点</strong>：  实例的变量名虽然一样，但他们保存的值却是各自独立的</p>
<div><pre><code>print(li.name)
print(li.age)
print(zhang.name)
print(zhang.age)
------------------------
李四
24
张三
23
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="类中的方法"> 类中的方法</h2>
<h3 id="实例方法"> 实例方法</h3>
<p><strong>特点</strong>：</p>
<ul>
<li>由实例调用，至少包含一个<code>self</code> 参数</li>
<li>执行实例方法时，会自动将调用该方法的实例赋值给 <code>self</code></li>
<li><code>self</code> 代表的是类的实例，而非类本身</li>
<li><code>self</code> 不是关键字，而是 Python 约定成俗的命名</li>
</ul>
<p>Student 类中的 print_age() 就是实例方法  :</p>
<div><pre><code><span>def</span> <span>print_age</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'%s: %s'</span> <span>%</span> <span>(</span>self<span>.</span>name<span>,</span> self<span>.</span>age<span>)</span><span>)</span>

<span># --------------------------</span>
<span># 调用方法</span>
li<span>.</span>print_age<span>(</span><span>)</span>
zhang<span>.</span>print_age<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="静态方法"> 静态方法</h3>
<p><strong>特点</strong>：</p>
<ul>
<li>由类调用，无默认参数</li>
<li>实例方法参数中的 self 去掉，然后在方法定义上方加上 @staticmethod</li>
<li>属于类，和实例无关</li>
<li>建议只使用 类名.静态方法 的调用方式</li>
</ul>
<div><pre><code><span>class</span> <span>Foo</span><span>:</span>

    <span>@staticmethod</span>
    <span>def</span> <span>static_method</span><span>(</span><span>)</span><span>:</span>
        <span>pass</span>

<span>#调用方法</span>
Foo<span>.</span>static_method<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="类方法"> 类方法</h3>
<p><strong>特点</strong>：</p>
<ul>
<li>由类调用</li>
<li>用 @classmethod 装饰，至少传入一个 cls（代指类本身，类似 self）参数</li>
<li>执行类方法时，自动将调用该方法的类赋值给 cls</li>
<li>建议只使用 类名.类方法 的调用方式</li>
</ul>
<div><pre><code><span>class</span> <span>Foo</span><span>:</span>
    <span>@classmethod</span>
    <span>def</span> <span>class_method</span><span>(</span>cls<span>)</span><span>:</span>
        <span>pass</span>

Foo<span>.</span>class_method<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="类与实例中变量、方法在内存中的保存"> 类与实例中变量、方法在内存中的保存</h2>
<p><img src="./../images/类与实例.jpg" alt="类与实例" /></p>
<p><strong>总结</strong>：</p>
<ul>
<li>类、类的所有方法以及类变量在内存中只有一份，所有的实例共享</li>
<li>每一个实例都在内存中独立的保存自己和自己的实例变量</li>
<li>创建实例时，会保存一个类对象指针，该值指向实例所属的类的地址</li>
<li>实例可以寻找到自己的类，并进行相关调用，而类无法寻找到自己的某个实例</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T06:24:56.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">闭包</title>
    <id>https://www.snowji.cn/languages/python/basics/closure/</id>
    <link href="https://www.snowji.cn/languages/python/basics/closure/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="闭包"> 闭包</h1>
<p><strong>定义：</strong></p>
<p>在一个内部函数中，对外部作用域的变量进行引用，(并且一般外部函数的返回值为内部函数)，那么内部函数就被认为是闭包</p>
<p><strong>闭包格式：</strong></p>
<div><pre><code><span>def</span> 外层函数<span>(</span>参数<span>)</span><span>:</span>
    <span>def</span> 内层函数<span>(</span><span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"内层函数执行"</span><span>,</span> 参数<span>)</span>

    <span>return</span> 内层函数


内层函数的引用 <span>=</span> 外层函数<span>(</span><span>"传入参数"</span><span>)</span>
内层函数的引用<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>外层函数中的参数，不一定要有，据情况而定，但是一般情况下都会有并在内函数中使用到</p>
<p>举个例子：</p>
<div><pre><code><span>def</span> <span>add</span><span>(</span><span>)</span><span>:</span>
    a <span>=</span> <span>1</span>
    <span>def</span> <span>add_one</span><span>(</span>b<span>)</span><span>:</span>
         <span>return</span> a <span>+</span> b
    <span>return</span> add_one

add_one <span>=</span> add<span>(</span><span>)</span>
<span>print</span><span>(</span>add_one<span>(</span><span>1</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>上面的结果：2</p>
<p><strong>原理：</strong></p>
<ul>
<li>内函数中引用外函数的临时变量，此时会将该临时变量与内函数进行绑定，在内存中保留</li>
<li>外函数结束了，但临时变量还在，可以被内函数引用</li>
</ul>
<p><strong>内函数修改外函数的值</strong>:使用 nonlocal 关键字</p>
<div><pre><code><span>def</span> <span>func</span><span>(</span>a<span>,</span> b<span>)</span><span>:</span>
    <span>def</span> <span>line</span><span>(</span>x<span>)</span><span>:</span>
        <span>nonlocal</span> a
        a <span>=</span> <span>3</span>
        <span>return</span> a <span>*</span> x <span>-</span> b

    <span>return</span> line


line <span>=</span> func<span>(</span><span>2</span><span>,</span> <span>3</span><span>)</span>
<span>print</span><span>(</span>line<span>(</span><span>5</span><span>)</span><span>)</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>结果为：12</p>
<p><strong>闭包的用途</strong>:</p>
<p>​    Python 中主要用于装饰器</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T06:24:56.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">推导式</title>
    <id>https://www.snowji.cn/languages/python/basics/comprehensions/</id>
    <link href="https://www.snowji.cn/languages/python/basics/comprehensions/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="推导式"> 推导式</h1>
<h2 id="列表推导式"> 列表推导式</h2>
<p>一种快速生成列表的方式</p>
<div><pre><code>lis = [x * x for x in range(1, 10)]

print(lis)
------------------------------------
结果：[1, 4, 9, 16, 25, 36, 49, 64, 81]
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>运行过程：</strong></p>
<ul>
<li>首先执行 for 循环，对每一个 x，代入 x*x 中进行运算</li>
<li>将运算结果逐一添加到一个新列表内，循环结束，得到最终列表</li>
</ul>
<p>相当于：</p>
<div><pre><code>lis = []
for i in range(1, 10):
    lis.append(i*i)

print(lis)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>用法：</strong></p>
<ul>
<li>
<p>增加条件语句</p>
<p>条件语句在最后面</p>
<div><pre><code>&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0]
[4, 16, 36, 64, 100]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>嵌套循环</p>
<div><pre><code>&gt;&gt;&gt; [a + b for a in ‘123&#39; for b in ‘abc&#39;]
[&#39;1a&#39;, &#39;1b&#39;, &#39;1c&#39;, &#39;2a&#39;, &#39;2b&#39;, &#39;2c&#39;, &#39;3a&#39;, &#39;3b&#39;, &#39;3c&#39;]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>更多语法</p>
<div><pre><code>&gt;&gt;&gt; dic = {&quot;k1&quot;:&quot;v1&quot;,&quot;k2&quot;:&quot;v2&quot;}
&gt;&gt;&gt; a = [k+&quot;:&quot;+v for k,v in dic.items()]
&gt;&gt;&gt; a
[&#39;k1:v1&#39;, &#39;k2:v2&#39;]
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
</ul>
<h2 id="字典推导式"> 字典推导式</h2>
<p>与列表推导式类似，使用 {} 生成</p>
<div><pre><code>&gt;&gt;&gt; dic = {x: x**2 for x in (2, 4, 6)}
&gt;&gt;&gt; dic
{2: 4, 4: 16, 6: 36}
&gt;&gt;&gt; type(dic)
&lt;class &#39;dict&#39;&gt;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>注意：</strong> <code>x: x**2</code>的写法，中间的冒号，表示左边的是key右边的是value</p>
<h2 id="集合推导式"> 集合推导式</h2>
<p>同样使用 {} 生成</p>
<div><pre><code>&gt;&gt; a = {x for x in &#39;abracadabra&#39; if x not in &#39;abc&#39;}
&gt;&gt;&gt; a
{&#39;d&#39;, &#39;r&#39;}
&gt;&gt;&gt; type(a)
&lt;class &#39;set&#39;&gt;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>面试题：</strong></p>
<div><pre><code>result = [lambda x: x + i for i in range(10)]
print(result[0](10))
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>你以为的：10</p>
<p>实际上的：19，且result<code>[0~9](10)</code>都是19</p>
<p><strong>原因：</strong></p>
<p>由于列表内返回的是匿名函数，即在循环结束后是：</p>
<div><pre><code>result = [lambda x: x + i,lambda x: x + i.....]
</code></pre>
<div><span>1</span><br></div></div><p>使用 result<code>[0](10)</code> 调用时，此时需要找 i 的值，由于此时循环已完成，值为 9，所以值为 19</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T06:24:56.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Context Manager 上下文管理器</title>
    <id>https://www.snowji.cn/languages/python/basics/context-manager/</id>
    <link href="https://www.snowji.cn/languages/python/basics/context-manager/"/>
    <updated>2022-10-13T07:33:56.000Z</updated>
    <content type="html"><![CDATA[<h1 id="context-manager-上下文管理器"> Context Manager 上下文管理器</h1>
<h2 id="什么是上下文管理器"> 什么是上下文管理器</h2>
<p>简单一句话：</p>
<p>同时包含 <code>__enter__()</code> 和<code>__exit__()</code> 方法的对象就是上下文管理器</p>
<h3 id="enter"> <code>__enter__()</code></h3>
<ul>
<li>进入上下文管理器自动调用的方法</li>
<li>该方法会在 <code>with ... as ...</code> 代码块执行之前执行</li>
<li>如果 with 语句有 as 子句，且该方法有返回值，那么该方法的返回值会被赋值给 as 子句后的变量，最常见的 <code>with open('file_path', 'w') as file:</code></li>
<li>如果 with 语句没有 as 子句，上下文管理器的<code>__enter__</code>方法还是正常执行，只是这个返回值并没有赋给一个变量，with 下面的代码块也不能使用这个返回值</li>
<li>该方法可以返回多个值，因此在 as 子句后面也可以指定多个变量（多个变量必须由“()”括起来组成元组）</li>
</ul>
<h3 id="enter-exc-type-exc-value-exc-traceback"> <code>__enter__(exc_type, exc_value, exc_traceback)</code></h3>
<ul>
<li>退出上下文管理器自动调用的方法，会返回一个布尔类型的值</li>
<li>该方法会在 <code>with ... as ...</code>代码块执行之后执行</li>
<li>如果<code>with ... as ...</code>代码块成功执行结束，程序自动调用该方法，且三个参数都为 None</li>
<li>如果 <code>with ... as ...</code> 代码块执行时发生异常，通过 <code>sys.exc_info()</code> 得到异常信息，三个参数值分别是：异常类型、异常信息、异常回溯信息类型（type(e)，str(e)，<code>e.__traceback__</code>）</li>
</ul>
<h2 id="为什么要使用上下文管理器"> 为什么要使用上下文管理器</h2>
<p>日常场景中，在操作了一些资源，比如文件、数据库连接等，操作完成后不管成功与否，最重要的就是<strong>关闭资源</strong>，通常我们的代码会这么写：</p>
<div><pre><code>f <span>=</span> <span>open</span><span>(</span><span>'file.txt'</span><span>,</span> <span>'w'</span><span>)</span>
<span>try</span><span>:</span>
    f<span>.</span>write<span>(</span><span>"Hello"</span><span>)</span>
<span>finally</span><span>:</span>
    f<span>.</span>close<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>但 <code>close()</code>是必须要操作的，就没必要显示地调用，Python 提供了一种更优雅的方式，使用 with 语句：</p>
<div><pre><code><span>with</span> <span>open</span><span>(</span><span>'file.txt'</span><span>,</span> <span>'w'</span><span>)</span> <span>as</span> f<span>:</span>
    f<span>.</span>write<span>(</span><span>"Hello"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>在退出 with 语句下的代码块之后，f  对象会自动执行自己的 close 方法，实现资源的释放，简洁优雅</p>
<p><strong>执行顺序</strong>：</p>
<ul>
<li>先执行 open() 的 <code>__enter__()</code> 方法，将返回值赋值给 f</li>
<li>执行 <code>f.write(&quot;hello&quot;)</code></li>
<li>最后执行 open() 的 <code>__exit__()</code>方法</li>
</ul>
<h3 id="上下文管理器原理"> 上下文管理器原理</h3>
<div><pre><code><span>with</span> EXPR <span>as</span> VAR<span>:</span>
    BLOCK
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上述代码执行过程等价于：</p>
<div><pre><code>ContextManager <span>=</span> EXPR
VAR <span>=</span> ContextManager<span>.</span>__enter__<span>(</span><span>)</span>
<span>try</span><span>:</span>
    BLOCK
<span>finally</span><span>:</span>
    ContextManager<span>.</span>__exit__<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>f  对象就是把自己的 close 方法定义在了它的 <code>__exit__</code> 方法内部，实现了代码块执行完之后自动关闭自身</p>
<h2 id="自定义上下文管理器"> 自定义上下文管理器</h2>
<blockquote>
<p>基于类实现</p>
</blockquote>
<p>只需要给对象添加一个 <code>__enter__</code> 和一个 <code>__exit__</code> 方法</p>
<div><pre><code><span>import</span> sys

<span>class</span> <span>Resource</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>)</span><span>:</span>
        self<span>.</span>name <span>=</span> name
        <span>print</span><span>(</span><span>"== 初始化方法 =="</span><span>)</span>

    <span>def</span> <span>__enter__</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span><span>f"进入上下文管理器自动调用：name is </span><span><span>{</span>self<span>.</span>name<span>}</span></span><span>"</span></span><span>)</span>
        <span># 可以返回任意类型的值</span>
        <span>return</span> <span>{</span><span>"name"</span><span>:</span> self<span>.</span>name<span>}</span>

    <span>def</span> <span>__exit__</span><span>(</span>self<span>,</span> exc_type<span>=</span><span>None</span><span>,</span> exc_val<span>=</span><span>None</span><span>,</span> exc_tb<span>=</span><span>None</span><span>)</span><span>:</span>
        <span>print</span><span>(</span><span><span>f"退出上下文管理器自动调用："</span></span><span>,</span> sys<span>.</span>exc_info<span>(</span><span>)</span><span>,</span> exc_type<span>,</span> exc_val<span>,</span> exc_tb<span>)</span>
        <span>if</span> exc_tb <span>is</span> <span>None</span><span>:</span>
            <span>print</span><span>(</span><span>"没有异常时关闭资源"</span><span>)</span>
        <span>else</span><span>:</span>
            <span>print</span><span>(</span><span>"遇到异常时关闭资源"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>通过 <code>with...as</code> 调用上下文管理器（也称为：使用 <code>with ... as ...</code> 管理资源）</p>
<div><pre><code><span>with</span> Resource<span>(</span><span>"TEST"</span><span>)</span> <span>as</span> f<span>:</span>
    <span>print</span><span>(</span>f<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>结果：</p>
<div><pre><code><span>==</span> 初始化方法 <span>==</span>
进入上下文管理器自动调用：name <span>is</span> TEST
<span>{</span><span>'name'</span><span>:</span> <span>'TEST'</span><span>}</span>
退出上下文管理器自动调用： <span>(</span><span>None</span><span>,</span> <span>None</span><span>,</span> <span>None</span><span>)</span> <span>None</span> <span>None</span> <span>None</span>
没有异常时关闭资源
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>无异常时，<code>__exit__</code> 中的三个值都是 None</p>
<p>with 有异常时：</p>
<div><pre><code><span>with</span> Resource<span>(</span><span>"异常TEST"</span><span>)</span> <span>as</span> r<span>:</span>
    <span>print</span><span>(</span><span>'[with代码块] 异常之前的代码'</span><span>)</span>
    <span>raise</span> Exception<span>(</span><span>"抛出了 Exception"</span><span>)</span>
    <span>print</span><span>(</span><span>'[with代码块] ~~~~~~~~异常之后的代码'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>结果：</p>
<div><pre><code><span>==</span> 初始化方法 <span>==</span>
进入上下文管理器自动调用：name <span>is</span> 异常TEST
<span>[</span><span>with</span>代码块<span>]</span> 异常之前的代码
退出上下文管理器自动调用： <span>(</span><span>&lt;</span><span>class</span> <span>'Exception'</span><span>></span><span>,</span> Exception<span>(</span><span>'抛出了 Exception'</span><span>)</span><span>,</span> <span>&lt;</span>traceback <span>object</span> at <span>0x00000215E3F57140</span><span>></span><span>)</span> <span>&lt;</span><span>class</span> <span>'Exception'</span><span>></span> 抛出了 Exception <span>&lt;</span>traceback <span>object</span> at <span>0x00000215E3F57140</span><span>></span>
遇到异常时关闭资源
Traceback <span>(</span>most recent call last<span>)</span><span>:</span>
  File <span>"G:\test\test_one.py"</span><span>,</span> line <span>206</span><span>,</span> <span>in</span> <span>&lt;</span>module<span>></span>
    <span>raise</span> Exception<span>(</span><span>"抛出了 Exception"</span><span>)</span>
Exception<span>:</span> 抛出了 Exception
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>代码块抛出异常的时候，可以看到 <code>__exit__()</code>方法的三个参数值的确来源于 <code>sys.exc_info()</code></p>
<p><strong><code>__exit()__</code> 返回 True</strong>：</p>
<div><pre><code><span>import</span> sys

<span>class</span> <span>Resource</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>)</span><span>:</span>
        self<span>.</span>name <span>=</span> name
        <span>print</span><span>(</span><span>"== 初始化方法 =="</span><span>)</span>

    <span>def</span> <span>__enter__</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span><span>f"进入上下文管理器自动调用：name is </span><span><span>{</span>self<span>.</span>name<span>}</span></span><span>"</span></span><span>)</span>
        <span># 可以返回任意类型的值</span>
        <span>return</span> <span>{</span><span>"name"</span><span>:</span> self<span>.</span>name<span>}</span>

    <span>def</span> <span>__exit__</span><span>(</span>self<span>,</span> exc_type<span>,</span> exc_val<span>,</span> exc_tb<span>)</span><span>:</span>
        <span>print</span><span>(</span><span><span>f"退出上下文管理器自动调用："</span></span><span>,</span> sys<span>.</span>exc_info<span>(</span><span>)</span><span>,</span> exc_type<span>,</span> exc_val<span>,</span> exc_tb<span>)</span>
        <span>if</span> exc_tb <span>is</span> <span>None</span><span>:</span>
            <span>print</span><span>(</span><span>"没有异常时关闭资源"</span><span>)</span>
        <span>else</span><span>:</span>
            <span>print</span><span>(</span><span>"遇到异常时关闭资源"</span><span>)</span>
            <span>return</span> <span>True</span>

    <span># 再次运行</span>
<span>with</span> Resource<span>(</span><span>"异常TEST"</span><span>)</span> <span>as</span> r<span>:</span>
    <span>print</span><span>(</span><span>'[with代码块] 抛出异常之前的代码'</span><span>)</span>
    <span>raise</span> Exception
    <span>print</span><span>(</span><span>'[with代码块] 抛出异常之后的代码'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>结果：</p>
<div><pre><code><span>==</span> 初始化方法 <span>==</span>
进入上下文管理器自动调用：name <span>is</span> 异常TEST
<span>[</span><span>with</span>代码块<span>]</span> 抛出异常之前的代码
退出上下文管理器自动调用： <span>(</span><span>&lt;</span><span>class</span> <span>'Exception'</span><span>></span><span>,</span> Exception<span>(</span><span>)</span><span>,</span> <span>&lt;</span>traceback <span>object</span> at <span>0x0000011A654B7180</span><span>></span><span>)</span> <span>&lt;</span><span>class</span> <span>'Exception'</span><span>></span>  <span>&lt;</span>traceback <span>object</span> at <span>0x0000011A654B7180</span><span>></span>
遇到异常时关闭资源
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>没有抛出异常</p>
<div><p>小结</p>
<ul>
<li>无论 with 代码块是否有异常，最终都会自动调用 <code>__exit__()</code> 方法</li>
<li>当抛出异常时，<code>__exit__()</code>默认返回 None，会重新抛出异常到外面，让<code>with ... as ...</code>以外的代码来处理异常</li>
<li>反之，如果返回 True，就会忽略异常，不再对异常进行处理</li>
</ul>
</div>
<blockquote>
<p>基于生成器实现</p>
</blockquote>
<ul>
<li>通过装饰器 <code>contextlib.contextmanager</code>，来定义自己所需的基于生成器的上下文管理器</li>
<li>该装饰器将生成器中的代码通过 yield 语句分成两部分，yield 之前的代码为<code>__enter__</code>方法，yield 之后的代码为<code>__exit__</code>方法</li>
<li>yield 的返回值即<code>__enter__</code>方法的返回值，用于赋给 as 后的变量</li>
</ul>
<div><pre><code><span>from</span> contextlib <span>import</span> contextmanager

<span>@contextmanager</span>
<span>def</span> <span>open_file</span><span>(</span>filename<span>,</span> mode<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>'进入'</span><span>)</span>
    f <span>=</span> <span>open</span><span>(</span>filename<span>,</span> mode<span>)</span>
    <span>try</span><span>:</span>
        <span>yield</span> f
    <span>finally</span><span>:</span>
        <span>print</span><span>(</span><span>'退出'</span><span>)</span>
        f<span>.</span>close<span>(</span><span>)</span>
        
        
<span>with</span> open_file<span>(</span><span>'file.txt'</span><span>,</span> <span>'w'</span><span>)</span> <span>as</span> f<span>:</span>
    <span>print</span><span>(</span><span>"正在写入..."</span><span>)</span>
    f<span>.</span>write<span>(</span><span>'Hello'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>这里使用 <code>try/finally</code> 是确保 yield 的过程中就算出现异常，文件也能正常关闭，当然这里也能处理异常，使用 <code>try/except/finally</code> 即可</p>
<div><p>小结</p>
<ul>
<li>基于生成器的上下文管理器时，不再用定义 <code>__enter__()</code> 和 <code>__exit__()</code> 方法</li>
<li>但需要加上装饰器 <code>@contextmanager</code></li>
</ul>
</div>
<h2 id="参考资料"> 参考资料</h2>
<p><a href="https://realpython.com/python-with-statement/" target="_blank" rel="noopener noreferrer">Context Managers</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-22T07:06:33.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">数据类型</title>
    <id>https://www.snowji.cn/languages/python/basics/data-type/</id>
    <link href="https://www.snowji.cn/languages/python/basics/data-type/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="数据类型"> 数据类型</h1>
<h2 id="数字类型"> 数字类型</h2>
<p>数字类型是不可变类型</p>
<p>支持 3 种类型：</p>
<ul>
<li>
<p>整数</p>
<p><strong>说明</strong>：整型，不带小数点</p>
<p><strong>特殊</strong>：python3 种的整型可以当作 Long 类型</p>
<p><strong>长度</strong>：</p>
<ul>
<li>32 位，通常连续分配内存空间</li>
<li>可以使用 id(1) 进行查看内存地址</li>
</ul>
<p><strong>小整数对象池</strong>：</p>
<ul>
<li>初始化时，会创建小整数对象池，方便调用，会一直存在</li>
<li>范围从 -5 到 256</li>
<li>目的：减小开销，提高性能</li>
<li>在不创建 1 时直接使用 id(1)，可查看内存地址</li>
</ul>
<p><strong>缓冲区</strong>：刚被删除的整数不会立即被回收，而会在后台缓冲一段时间，等待下一次的可能调用</p>
<p>例：</p>
<div><pre><code>&gt;&gt;&gt; a = 1000000
&gt;&gt;&gt; id(a)
45818160
&gt;&gt;&gt; del a       # 删除变量a
&gt;&gt;&gt; b = 1000000
&gt;&gt;&gt; id(b)
45818160
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
<li>
<p>浮点数</p>
<ul>
<li>通常说的小数</li>
<li>对于很大或很小的浮点数，一般用科学计数法表示</li>
</ul>
<div><pre><code>1.23x10^9==1.23e9
0.000012==1.2e-5
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>复数</p>
<ul>
<li>由实数部分和虚数部分构成</li>
<li>a + bj,或者 complex(a,b) 表示</li>
<li>复数的实部 a 和虚部 b 都是浮点型</li>
</ul>
</li>
</ul>
<h2 id="布尔类型"> 布尔类型</h2>
<p>类型值：Ture/False</p>
<p>布尔运算：计算结果时 Ture 或 False 的过程</p>
<p><strong>布尔类型可以进行 and、or 和 not 运算</strong></p>
<div><pre><code>&gt;&gt;&gt; True and True
True
&gt;&gt;&gt; True or True
True
&gt;&gt;&gt; not True
False
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>其他运算：</strong></p>
<div><pre><code>比较运算：
&gt;&gt;&gt; True &gt; False
True
&gt;&gt;&gt; True &lt; False
False
&gt;&gt;&gt; True &gt;=False
True

四则运算：
&gt;&gt;&gt; True -1
0
&gt;&gt;&gt; True + 1
2
&gt;&gt;&gt; True *3
3
&gt;&gt;&gt; False -1
-1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p><strong>注意 None（空值）：</strong></p>
<ul>
<li>空值不是布尔类型，也不是数字类型</li>
<li><strong>是NoneType</strong></li>
</ul>
<div><pre><code>&gt;&gt;&gt; bool(None)
False
&gt;&gt;&gt; type(None)
&lt;class &#39;NoneType&#39;&gt;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="列表"> 列表</h2>
<p>有序可重复的元素集合</p>
<p><strong>数据结构：</strong></p>
<p>以  alist = [1, “a”, [11,22], {“k1”:”v1”}]  为例：</p>
<p><img src="./../images/列表.jpg" alt="列表" /></p>
<h2 id="元组"> 元组</h2>
<p>序列结构，元组中的内容不可变</p>
<p><strong>不允许的操作：</strong></p>
<ul>
<li>新增</li>
<li>删除</li>
<li>修改</li>
</ul>
<p><strong>创建元组注意：</strong></p>
<p>创建只有 1 个元素的元组时，必须加上逗号</p>
<div><pre><code>&gt;&gt;&gt; tup1 = (50,)        # 创建只包含一个元素的元组时，要在元素的后面跟个逗号
</code></pre>
<div><span>1</span><br></div></div><p><strong>元组只保证它的一级子元素不可变，对于嵌套的元素内部，不保证不可变！</strong></p>
<div><pre><code>&gt;&gt;&gt; tup = (&#39;a&#39;, &#39;b&#39;, [&#39;A&#39;, &#39;B&#39;])
&gt;&gt;&gt; tup[2][0] = &#39;X&#39;
&gt;&gt;&gt; tup[2][1] = &#39;Y&#39;
&gt;&gt;&gt; tup 
(&#39;a&#39;, &#39;b&#39;, [&#39;X&#39;, &#39;Y&#39;])
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="字符串"> 字符串</h2>
<p>不可变的序列数据类型</p>
<h3 id="字符串格式化"> 字符串格式化</h3>
<h4 id="百分符格式化方法"> % 百分符格式化方法</h4>
<div><pre><code><span>print</span> <span>(</span><span>"我叫 %s 今年 %d 岁!"</span> <span>%</span> <span>(</span><span>'小明'</span><span>,</span> <span>10</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>"%(name)s hello"</span> <span>%</span><span>{</span><span>'name'</span><span>:</span><span>"www"</span><span>}</span><span>)</span>
<span># 对于百分数需要写 2 个 %</span>
<span>print</span><span>(</span><span>"%s已下载了90%%了"</span> <span>%</span><span>"电影"</span><span>)</span>     
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id="str-format-格式化方法"> str.format() 格式化方法</h4>
<ul>
<li>
<p>1.{0}、{1}、{2}:这一类是位置参数，引用必须按顺序，不能随意调整，否则就乱了。例如：</p>
<div><pre><code>tpl = &quot;i am {0}, age {1}, really {0}&quot;.format(&quot;seven&quot;, 18)
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>2.{name}、{age}、{gender}：这一类是关键字参数，引用时必须以键值对的方式，可以随意调整顺序。例如：</p>
<div><pre><code>tpl = &quot;i am {name}, age {age}, really {name}&quot;.format(name=&quot;seven&quot;, age=18)
</code></pre>
<div><span>1</span><br></div></div></li>
</ul>
<h2 id="字典"> 字典</h2>
<p><strong>不定长、可变、散列的集合类型</strong></p>
<p><strong>特点：</strong></p>
<ul>
<li>
<p>元素个数不限，值得类型是任何数据</p>
</li>
<li>
<p>key 的值必须是不可变对象</p>
</li>
<li>
<p>key 唯一</p>
</li>
</ul>
<p>字典遍历：</p>
<div><pre><code>dic = {&#39;Name&#39;: &#39;Jack&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;}

# 1  直接遍历字典获取键，根据键取值
for key in dic:
    print(key, dic[key])

# 2  利用items方法获取键值，速度很慢，少用！
for key,value in dic.items():
    print(key,value)

#3  利用keys方法获取键
for key in dic.keys():
    print(key, dic[key])

#4  利用values方法获取值，但无法获取对应的键。
for value in dic.values():
    print(value)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id="集合"> 集合</h2>
<ul>
<li>无序不重复元素的集</li>
<li>集合中的元素不可改变</li>
</ul>
<p><strong>核心</strong>：自动去重</p>
<div><pre><code>&gt;&gt;&gt; s = set([1,1,2,3,3,4])
&gt;&gt;&gt; s
{1, 2, 3, 4}        # 自动去重
&gt;&gt;&gt; set(&quot;it is a nice day&quot;)     # 对于字符串，集合会把它一个一个拆开，然后去重
{&#39;s&#39;, &#39;e&#39;, &#39;y&#39;, &#39;t&#39;, &#39;c&#39;, &#39;n&#39;, &#39; &#39;, &#39;d&#39;, &#39;i&#39;, &#39;a&#39;}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>集合类型</strong>：</p>
<ul>
<li>可变集合 set</li>
<li>不可变集合 frozenset</li>
</ul>
<h3 id="集合操作"> 集合操作</h3>
<h4 id="增加元素"> 增加元素</h4>
<p>add(key) 方法可以添加元素到set中</p>
<div><pre><code>&gt;&gt;&gt; s = {1, 2, 3, 4}
&gt;&gt;&gt; s
{1, 2, 3, 4}
&gt;&gt;&gt; s.add(5)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id="更新集合"> 更新集合</h4>
<p>update() 方法，将另一个对象更新到已有的集合中，会进行去重</p>
<div><pre><code>&gt;&gt;&gt; s
{1, 2, 3, 4, 5}
&gt;&gt;&gt; s.update(&quot;hello&quot;)
&gt;&gt;&gt; s
{1, 2, 3, 4, 5, &#39;e&#39;, &#39;o&#39;, &#39;l&#39;, &#39;h&#39;}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="删除集合中的元素"> 删除集合中的元素</h4>
<ul>
<li>remove(key) 方法删除指定元素，</li>
</ul>
<div><pre><code>&gt;&gt;&gt; s
{1, 2, 3, 4, 5, &#39;e&#39;, &#39;o&#39;, &#39;l&#39;, &#39;h&#39;}
&gt;&gt;&gt; s.remove(&quot;l&quot;)
&gt;&gt;&gt; s
{1, 2, 3, 4, 5, &#39;e&#39;, &#39;o&#39;, &#39;h&#39;}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li>pop() 随机删除</li>
</ul>
<div><pre><code><span>>></span><span>></span> s<span>.</span>pop<span>(</span><span>)</span>
<span>1</span>
<span>>></span><span>></span> s
<span>{</span><span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>'e'</span><span>,</span> <span>'o'</span><span>,</span> <span>'h'</span><span>}</span>
<span>>></span><span>></span> s<span>.</span>pop<span>(</span><span>3</span><span>)</span>
Traceback <span>(</span>most recent call last<span>)</span><span>:</span>
  File <span>"&lt;pyshell#22>"</span><span>,</span> line <span>1</span><span>,</span> <span>in</span> <span>&lt;</span>module<span>></span>
    s<span>.</span>pop<span>(</span><span>3</span><span>)</span>
TypeError<span>:</span> pop<span>(</span><span>)</span> takes no arguments <span>(</span><span>1</span> given<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ul>
<li>discard()</li>
</ul>
<div><pre><code><span>>></span><span>></span> s
<span>{</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>'e'</span><span>,</span> <span>'o'</span><span>,</span> <span>'l'</span><span>,</span> <span>'h'</span><span>}</span>
<span>>></span><span>></span> s<span>.</span>remove<span>(</span><span>"l"</span><span>)</span>
<span>>></span><span>></span> s
<span>{</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>'e'</span><span>,</span> <span>'o'</span><span>,</span> <span>'h'</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li>clear() 清空集合</li>
</ul>
<div><pre><code>
</code></pre>
<div><span>1</span><br></div></div><h3 id="数学意义上的集合操作"> 数学意义上的集合操作</h3>
<div><pre><code>&gt;&gt;&gt; s
{1, 2, 3, 4, 5, &#39;e&#39;, &#39;o&#39;, &#39;l&#39;, &#39;h&#39;}
&gt;&gt;&gt; s.remove(&quot;l&quot;)
&gt;&gt;&gt; s
{1, 2, 3, 4, 5, &#39;e&#39;, &#39;o&#39;, &#39;h&#39;}
&gt;&gt;&gt; s.pop()
1
&gt;&gt;&gt; s
{2, 3, 4, 5, &#39;e&#39;, &#39;o&#39;, &#39;h&#39;}
&gt;&gt;&gt; s.pop(3)
Traceback (most recent call last):
  File &quot;&lt;pyshell#22&gt;&quot;, line 1, in &lt;module&gt;
    s.pop(3)
TypeError: pop() takes no arguments (1 given)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id="bytes"> bytes</h2>
<p><strong>特点：</strong></p>
<ul>
<li>不可变的序列对象</li>
<li>以字节为单位处理</li>
</ul>
<p>创建方法：</p>
<div><pre><code>b = b&#39;&#39;         # 创建一个空的bytes
b = bytes()      # 创建一个空的bytes
b = b&#39;hello&#39;    #  直接指定这个hello是bytes类型
b = bytes(&#39;string&#39;,encoding=&#39;编码类型&#39;)  #利用内置bytes方法，将字符串转换为指定编码的bytes
b = str.encode(&#39;编码类型&#39;)   # 利用字符串的encode方法编码成bytes，默认为utf-8类型

bytes.decode(&#39;编码类型&#39;)：将bytes对象解码成字符串，默认使用utf-8进行解码。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>与字符串的简单转换：</p>
<p><strong>string = b'xxxxxx'.decode()</strong> 直接以默认的 utf-8 编码解码 bytes 成 string</p>
<p><strong>b = string.encode()</strong> 直接以默认的 utf-8 编码 string 为 bytes</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T06:24:56.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">watch 监控</title>
    <id>https://www.snowji.cn/databases/redis/watch/</id>
    <link href="https://www.snowji.cn/databases/redis/watch/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="watch-监控"> watch 监控</h1>
<p><strong>悲观锁</strong>：</p>
<p>很悲观，认为什么时候都会出现问题，无论做什么都会加锁</p>
<p><strong>乐观锁</strong>：</p>
<ul>
<li>很乐观，认为什么时候都不会出现问题，所以不会上锁</li>
<li>更新数据的时候去判断一下，在此期间是否有人修改过这个数据</li>
<li>获取 version</li>
<li>更新的时候比较 version</li>
</ul>
<h2 id="watch"> watch</h2>
<p>Redis 使用 <code>watch</code> 监控指定的数据，相当于乐观锁加锁</p>
<p><strong>语法</strong>:</p>
<div><pre><code><span>watch</span> key<span>[</span>key<span>..</span><span>..</span><span>]</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="正常执行事务"> 正常执行事务</h3>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> <span>set</span> money <span>100</span>            <span># 设置余额 100</span>
OK 
<span>127.0</span>.0.1:637<span><span>9</span>></span> <span>set</span> use <span>0</span>               <span># 支出使用 0</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> <span>watch</span> money              <span># 监视 money（上锁）</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> multi
OK
<span>127.0</span>.0.1:6379<span>(</span>TX<span>)</span><span>></span> decrby money <span>20</span>
QUEUED
<span>127.0</span>.0.1:6379<span>(</span>TX<span>)</span><span>></span> incrby use <span>20</span>
QUEUED
<span>127.0</span>.0.1:6379<span>(</span>TX<span>)</span><span>></span> <span>exec</span>                  <span># 监视值没有被中途修改，事务正常执行</span>
<span>1</span><span>)</span> <span>(</span>integer<span>)</span> <span>80</span>
<span>2</span><span>)</span> <span>(</span>integer<span>)</span> <span>20</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="修改监视值执行事务"> 修改监视值执行事务</h3>
<p>启动两个客户端模拟插队线程</p>
<p>线程 1：</p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> <span>watch</span> money
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> multi
OK
<span>127.0</span>.0.1:6379<span>(</span>TX<span>)</span><span>></span> decrby money <span>20</span>
QUEUED
<span>127.0</span>.0.1:6379<span>(</span>TX<span>)</span><span>></span> incrby use <span>20</span>
QUEUED
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>线程 2：</p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> <span>set</span> money <span>1000</span>             <span># 设置 money 的值为 1000，改变了 money 的值</span>
OK
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>回到线程 1 ，执行事务</p>
<div><pre><code><span>127.0</span>.0.1:6379<span>(</span>TX<span>)</span><span>></span> <span>exec</span>           <span># 监视的值 money 被改变，执行事务失败</span>
<span>(</span>nil<span>)</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> get money         <span># money 的值被线程 2 修改了</span>
<span>"1000"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> get use
<span>"20"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>执行失败的事务，可以先使用 <code>unwatch</code> 解锁在操作</p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> unwatch               <span># 解锁</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> <span>watch</span> money          <span># 获取最新的值，再次监控</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> multi
OK
<span>127.0</span>.0.1:6379<span>(</span>TX<span>)</span><span>></span> decrby money <span>1</span>
QUEUED
<span>127.0</span>.0.1:6379<span>(</span>TX<span>)</span><span>></span> incrby use <span>1</span>
QUEUED
<span>127.0</span>.0.1:6379<span>(</span>TX<span>)</span><span>></span> <span>exec</span>                <span># 对比监视的值是否发生变化，没有变化则执行成功</span>
<span>1</span><span>)</span> <span>(</span>integer<span>)</span> <span>999</span>
<span>2</span><span>)</span> <span>(</span>integer<span>)</span> <span>21</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">NoSQL</title>
    <id>https://www.snowji.cn/databases/redis/nosql/</id>
    <link href="https://www.snowji.cn/databases/redis/nosql/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="nosql"> NoSQL</h1>
<h2 id="为什么要使用-nosql"> 为什么要使用 NoSQL</h2>
<h3 id="发展历程"> 发展历程</h3>
<h4 id="单机-mysql"> 单机 MySql</h4>
<p>90 年代 一个网站的访问量一般不会太大，单个数据库完全够用</p>
<p><img src="./images/1.png" alt="redis" /></p>
<p>但随着用户增多，会出现以下问题：</p>
<ul>
<li>数据量增加到一定程度，单机数据库就放不下了</li>
<li>数据的索引（B+ Tree）,一个机器内存也存放不下</li>
<li>访问量变大后（读写混合），一台服务器承受不住</li>
</ul>
<p>为了解决上述的问题，可以加入缓存和将表垂直拆分</p>
<h4 id="memcached-缓存-mysql-垂直拆分-读写分离"> Memcached(缓存) + Mysql + 垂直拆分（读写分离）</h4>
<ul>
<li>
<p>网站 80% 的情况都是在读，每次都要去查询数据库的话就十分的麻烦</p>
</li>
<li>
<p>希望减轻数据库的压力，可以使用缓存来保证效率</p>
</li>
</ul>
<p><img src="./images/2.png" alt="redis" /></p>
<p><strong>优化过程经历了以下几个过程</strong>：</p>
<ul>
<li>
<p>优化数据库的数据结构和索引(难度大)</p>
</li>
<li>
<p>文件缓存，通过 IO 流获取比每次都访问数据库效率略高，但是流量爆炸式增长时候，IO 流也承受不了</p>
</li>
<li>
<p>MemCache，通过在数据库和数据库访问层之间加上一层缓存，第一次访问时查询数据库，将结果保存到缓存，后续的查询先检查缓存，若有直接拿去使用，效率显著提升</p>
</li>
</ul>
<h4 id="分库分表-水平拆分-mysql-集群"> 分库分表 + 水平拆分 + Mysql 集群</h4>
<p><img src="./images/3.png" alt="redis" /></p>
<h3 id="为什么要用nosql"> 为什么要用NoSQL</h3>
<p>目前一个基本的互联网项目</p>
<p><img src="./images/4.png" alt="redis" /></p>
<ul>
<li>如今信息量井喷式增长，各种各样的数据出现（用户定位数据，图片数据等）</li>
<li>用户的个人信息，社交网络，地理位置</li>
<li>用户自己产生的数据，用户日志等等爆发式增长</li>
</ul>
<p>这时候就需要使用 NoSQL 数据库的，NoSQL 可以很好的处理以上的情况</p>
<h2 id="什么是-nosql"> 什么是 NoSQL</h2>
<p><strong>NoSQL = Not Only SQL（不仅仅是SQL）</strong></p>
<p>关系型数据库：列+行，同一个表下数据的结构是一样的</p>
<p>非关系型数据库：数据存储没有固定的格式，并且可以进行横向扩展</p>
<p>NoSQL 泛指非关系型数据库</p>
<h2 id="nosql-的特点"> NoSQL 的特点</h2>
<ul>
<li>
<p>方便扩展：数据之间没有关系，很好扩展</p>
</li>
<li>
<p>大数据量高性能：Redis 一秒可以写 8 万次，读 11 万次，NoSQL 的缓存记录级，是一种细粒度的缓存，性能会比较高</p>
</li>
<li>
<p>数据类型是多样型的：不需要事先设计数据库，随取随用</p>
</li>
<li>
<p>传统的 RDBMS 和 NoSQL</p>
</li>
</ul>
<p>**传统的 RDBMS **：</p>
<ul>
<li>结构化组织</li>
<li>SQL</li>
<li>数据和关系都存在单独的表中</li>
<li>严格的一致性</li>
<li>基础的事务</li>
<li>.....</li>
</ul>
<p>**NoSQL **：</p>
<ul>
<li>不仅仅是数据</li>
<li>没有固定的查询语言</li>
<li>键值对存储、列存储、文档存储、图形存储</li>
<li>最终一致性</li>
<li>高性能、高可用、高扩展</li>
<li>.....</li>
</ul>
<h2 id="nosql-的四大分类"> NoSQL 的四大分类</h2>
<h3 id="kv-键值对"> KV 键值对</h3>
<ul>
<li>新浪：<strong>Redis</strong></li>
<li>美团：Redis + Tair</li>
<li>阿里、百度：Redis + Memcache</li>
</ul>
<h3 id="文档型数据库-bson-格式"> 文档型数据库(bson 格式)</h3>
<ul>
<li>MongoDB
<ul>
<li>基于分布式文件存储的数据库</li>
<li>C++编写，用于处理大量文档</li>
<li>MongoDB 是 RDBMS 和 NoSQL 的中间产品</li>
<li>MongoDB 是非关系型数据库中功能最丰富的，NoSQL 中最像关系型数据库的数据库</li>
</ul>
</li>
<li>ConthDB</li>
</ul>
<h3 id="列存储数据库"> 列存储数据库</h3>
<ul>
<li>HBase(大数据必学)</li>
<li>分布式文件系统</li>
</ul>
<h3 id="图关系数据库"> 图关系数据库</h3>
<ul>
<li>用于广告推荐，社交网络</li>
<li><strong>Neo4j</strong>、InfoGrid</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">copy 与 deepcopy</title>
    <id>https://www.snowji.cn/languages/python/basics/copy-deepcopy/</id>
    <link href="https://www.snowji.cn/languages/python/basics/copy-deepcopy/"/>
    <updated>2022-09-02T06:24:56.000Z</updated>
    <content type="html"><![CDATA[<h1 id="copy-与-deepcopy"> copy 与 deepcopy</h1>
<h2 id="可变对象"> 可变对象</h2>
<p>主要是 list 和 dict</p>
<p>直接上例子</p>
<div><pre><code><span>import</span> copy

a <span>=</span> <span>{</span><span>'key'</span><span>:</span><span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>]</span><span>}</span>
b <span>=</span> copy<span>.</span>copy<span>(</span>a<span>)</span>
c <span>=</span> copy<span>.</span>deepcopy<span>(</span>a<span>)</span>

<span>print</span><span>(</span>a<span>,</span>b<span>,</span>c<span>)</span>
<span>print</span><span>(</span><span>id</span><span>(</span>a<span>)</span><span>,</span><span>id</span><span>(</span>b<span>)</span><span>,</span><span>id</span><span>(</span>c<span>)</span><span>)</span>
<span>print</span><span>(</span>a<span>[</span><span>'key'</span><span>]</span><span>,</span>b<span>[</span><span>'key'</span><span>]</span><span>,</span>c<span>[</span><span>'key'</span><span>]</span><span>)</span>
<span>print</span><span>(</span><span>id</span><span>(</span>a<span>[</span><span>'key'</span><span>]</span><span>)</span><span>,</span><span>id</span><span>(</span>b<span>[</span><span>'key'</span><span>]</span><span>)</span><span>,</span><span>id</span><span>(</span>c<span>[</span><span>'key'</span><span>]</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>结果：</p>
<div><pre><code><span>{</span><span>'key'</span><span>:</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>}</span> <span>{</span><span>'key'</span><span>:</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>}</span> <span>{</span><span>'key'</span><span>:</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>}</span>
<span>2021806902080</span> <span>2021806902336</span> <span>2021806902464</span>
<span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span>
<span>2021810163264</span> <span>2021810163264</span> <span>2021810160768</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><p>由上面的结果可以看出：</p>
<ul>
<li>copy 可变对象时，子元素的地址没变，引用之前的子元素的地址</li>
<li>deepcopy 子元素的地址也被拷贝</li>
</ul>
</div>
<h2 id="不可变对象"> 不可变对象</h2>
<p>主要是针对元组、字符串、数字，只要创建就不能改的元素</p>
<h3 id="对于纯不可变对象"> 对于纯不可变对象</h3>
<p>上代码</p>
<div><pre><code>a <span>=</span> <span>(</span><span>'a'</span><span>,</span><span>'b'</span><span>,</span><span>'c'</span><span>)</span>
b <span>=</span> copy<span>.</span>copy<span>(</span>a<span>)</span>
c <span>=</span> copy<span>.</span>deepcopy<span>(</span>a<span>)</span>
<span>if</span> b <span>==</span> c<span>:</span>    
	<span>print</span><span>(</span><span>"b和c的值相等"</span><span>)</span>
<span>if</span> <span>id</span><span>(</span>b<span>)</span> <span>==</span> <span>id</span><span>(</span>c<span>)</span><span>:</span>    
	<span>print</span><span>(</span><span>"b和c的地址相等"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>结果：</p>
<div><pre><code>b和c的值相等
b和c的地址相等
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><p>由上面的结果可以看出：</p>
<p>copy 和 deepcopy 的值一致，存储的地址空间也一致</p>
</div>
<h3 id="当不可变元素中含有可变元素时-如元组含有可变元素"> 当不可变元素中含有可变元素时，如元组含有可变元素</h3>
<div><pre><code>a <span>=</span> <span>(</span><span>1</span><span>,</span><span>2</span><span>,</span><span>[</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>]</span><span>)</span>
b <span>=</span> copy<span>.</span>copy<span>(</span>a<span>)</span>
c <span>=</span> copy<span>.</span>deepcopy<span>(</span>a<span>)</span>
<span>print</span><span>(</span>a<span>,</span>b<span>,</span>c<span>)</span>
<span>print</span><span>(</span><span>id</span><span>(</span>a<span>)</span><span>,</span><span>id</span><span>(</span>b<span>)</span><span>,</span><span>id</span><span>(</span>c<span>)</span><span>)</span>
<span>print</span><span>(</span><span>id</span><span>(</span>a<span>[</span><span>2</span><span>]</span><span>)</span><span>,</span><span>id</span><span>(</span>b<span>[</span><span>2</span><span>]</span><span>)</span><span>,</span><span>id</span><span>(</span>c<span>[</span><span>2</span><span>]</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>结果：</p>
<div><pre><code><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>[</span><span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>]</span><span>)</span> <span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>[</span><span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>]</span><span>)</span> <span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>[</span><span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>]</span><span>)</span>
<span>1541483727872</span> <span>1541483727872</span> <span>1541484299072</span>
<span>1541485940288</span> <span>1541485940288</span> <span>1541485937536</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><p>由上面的结果可以看出：</p>
<p>对于不可变对象中含有可变对象时，浅拷贝的父元素和子元素地址没改变，而深拷贝的会将父元素和子元素都复制一份，地址都会改变</p>
</div>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T06:24:56.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">枚举</title>
    <id>https://www.snowji.cn/languages/python/basics/enumeration/</id>
    <link href="https://www.snowji.cn/languages/python/basics/enumeration/"/>
    <updated>2022-09-14T13:32:29.000Z</updated>
    <content type="html"><![CDATA[<h1 id="枚举"> 枚举</h1>
<h2 id="什么是枚举"> 什么是枚举</h2>
<ul>
<li>Python 中枚举是一种类，存放在 enum 模块</li>
<li>枚举类型可以给一组标签赋予一组特定的值</li>
</ul>
<h2 id="枚举的特点"> 枚举的特点</h2>
<ul>
<li>枚举类中不能存在相同的标签名</li>
<li>枚举是可迭代的</li>
<li>不同的枚举标签可以对应相同的值，但它们都会被视为该值对应第一个标签的别名</li>
<li>如果要限制定义枚举时，不能定义相同值的成员，可以使用装饰器 <code>@unique</code>（需要导入 unique 模块）</li>
<li>枚举成员之间不能进行大小比较，可进行等值和同一性比较</li>
<li>枚举成员为单例，不可实例化，不可更改</li>
</ul>
<blockquote>
<p>枚举的意义重在标签而不在于数值，最好全部使用大写</p>
</blockquote>
<h2 id="枚举类"> 枚举类</h2>
<blockquote>
<p>Python 中所有枚举类型都是 enum 模块下的 Enum 类的子类</p>
</blockquote>
<div><pre><code><span>from</span> enum <span>import</span> Enum
<span>class</span> <span>Color</span><span>(</span>Enum<span>)</span><span>:</span>
    YELLOW <span>=</span> <span>1</span>
    GREEN <span>=</span> <span>2</span>
    BLACK <span>=</span> <span>3</span>
    RED <span>=</span> <span>4</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>如果让标签的值唯一，需要 <code>@unique</code> 装饰器修饰类</p>
<div><pre><code><span>from</span> enum <span>import</span> Enum<span>,</span> unique

<span>@unique</span>
<span>class</span> <span>Color</span><span>(</span>Enum<span>)</span><span>:</span>
    YELLOW <span>=</span> <span>1</span>
    GREEN <span>=</span> <span>2</span>
    BLACK <span>=</span> <span>3</span>
    RED <span>=</span> <span>4</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="枚举类型、名称、值获取"> 枚举类型、名称、值获取</h3>
<blockquote>
<p>获取枚举类型中的数值：<code>class.value</code>
获取枚举类型中的标签：<code>class.name</code>
获取数值的标签：<code>class(value).name</code></p>
</blockquote>
<div><pre><code><span>from</span> enum <span>import</span> Enum<span>,</span> unique

<span>class</span> <span>Color</span><span>(</span>Enum<span>)</span><span>:</span>
    YELLOW <span>=</span> <span>1</span>
    GREEN <span>=</span> <span>2</span>
    BLACK <span>=</span> <span>3</span>
    RED <span>=</span> <span>4</span>

<span>print</span><span>(</span>Color<span>.</span>YELLOW<span>.</span>value<span>)</span>
<span>print</span><span>(</span>Color<span>.</span>YELLOW<span>.</span>name<span>)</span>
<span>print</span><span>(</span>Color<span>.</span>YELLOW<span>)</span>
<span>print</span><span>(</span>Color<span>[</span><span>'YELLOW'</span><span>]</span><span>)</span>
<span>print</span><span>(</span>Color<span>(</span><span>1</span><span>)</span><span>.</span>name<span>)</span>
<span>print</span><span>(</span><span>type</span><span>(</span>Color<span>.</span>YELLOW<span>.</span>value<span>)</span><span>)</span>
<span>print</span><span>(</span><span>type</span><span>(</span>Color<span>.</span>YELLOW<span>.</span>name<span>)</span><span>)</span>
<span>print</span><span>(</span><span>type</span><span>(</span>Color<span>.</span>YELLOW<span>)</span><span>)</span>
<span>print</span><span>(</span><span>type</span><span>(</span>Color<span>[</span><span>'YELLOW'</span><span>]</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>结果：</p>
<div><pre><code><span>1</span>                <span># 枚举的值</span>
YELLOW           <span># 枚举的标签</span>
Color<span>.</span>YELLOW     <span># 通过枚举标签获取枚举类型</span>
Color<span>.</span>YELLOW     <span># 通过枚举标签获取枚举类型</span>
YELLOW           <span># 通过值获取标签名</span>
<span>&lt;</span><span>class</span> <span>'int'</span><span>></span>    <span># 枚举值的值类型</span>
<span>&lt;</span><span>class</span> <span>'str'</span><span>></span>    <span># 枚举标签的类型</span>
<span>&lt;</span>enum <span>'Color'</span><span>></span>   <span># 通过枚举标签获取枚举类型</span>
<span>&lt;</span>enum <span>'Color'</span><span>></span>   <span># 通过枚举标签获取枚举类型</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><blockquote>
<p>遍历枚举</p>
</blockquote>
<p>使用 <code>for..in..</code></p>
<div><pre><code><span>for</span> color <span>in</span> Color<span>:</span>
    <span>print</span><span>(</span>color<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>结果：</p>
<div><pre><code>Color<span>.</span>YELLOW
Color<span>.</span>GREEN
Color<span>.</span>BLACK
Color<span>.</span>RED
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果枚举中有标签的值重复时，在遍历时，默认结果中不会显示重复值的标签名</p>
<div><pre><code><span>class</span> <span>Color</span><span>(</span>Enum<span>)</span><span>:</span>
    YELLOW <span>=</span> <span>1</span>
    GREEN <span>=</span> <span>2</span>
    BLACK <span>=</span> <span>3</span>
    RED <span>=</span> <span>4</span>
    WHITE <span>=</span> <span>1</span>  
<span>for</span> color <span>in</span> Color<span>:</span>
    <span>print</span><span>(</span>color<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>结果，没有显示 WHITE 这个标签：</p>
<div><pre><code>Color<span>.</span>YELLOW
Color<span>.</span>GREEN
Color<span>.</span>BLACK
Color<span>.</span>RED
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果想要输出这个重复值的标签时，可以通过迭代<code>__members__</code>来显示所有成员标签</p>
<div><pre><code><span>for</span> color <span>in</span> Color<span>.</span>__members__<span>:</span>
    <span>print</span><span>(</span>color<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>结果：</p>
<div><pre><code>YELLOW
GREEN
BLACK
RED
WHITE
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><blockquote>
<p>枚举的比较运算</p>
</blockquote>
<ul>
<li>枚举类型之间可以进行等值比较，但直接比较会返回 False</li>
</ul>
<div><pre><code><span>print</span><span>(</span>Color<span>.</span>YELLOW<span>==</span><span>1</span><span>)</span>           <span># False</span>
<span>print</span><span>(</span>Color<span>.</span>YELLOW<span>.</span>value <span>==</span> <span>1</span><span>)</span>   <span># True</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>枚举类型之间不支持大小操作符比较</li>
<li>枚举类型可以进行<code>is</code>比较</li>
</ul>
<div><pre><code><span>print</span><span>(</span>Color<span>.</span>YELLOW <span>is</span> Color<span>.</span>YELLOW<span>)</span>   <span># True</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>不同枚举类中的枚举类型进行比较都会返回 False</li>
</ul>
<div><p>总结</p>
<ul>
<li>Enum：不限制枚举类型数值的数据类型</li>
<li>IntEnum：限制枚举类型数值必须为整型</li>
<li>枚举是单例模式，不能实例化</li>
<li><code>@unique</code>：标签值唯一</li>
</ul>
</div>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-08T14:27:27.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">装饰器</title>
    <id>https://www.snowji.cn/languages/python/basics/decorator/</id>
    <link href="https://www.snowji.cn/languages/python/basics/decorator/"/>
    <updated>2022-09-03T14:10:02.000Z</updated>
    <content type="html"><![CDATA[<h1 id="装饰器"> 装饰器</h1>
<h2 id="前提准备"> 前提准备</h2>
<p>在学习装饰器之前，需要了解以下几个内容：</p>
<ul>
<li>关于函数“变量”（或“变量”函数）的理解</li>
<li>关于高阶函数的理解</li>
<li>关于嵌套函数的理解</li>
</ul>
<h2 id="什么是装饰器"> 什么是装饰器</h2>
<p><strong>定义</strong>：装饰对象的器件</p>
<p><strong>本质</strong>：闭包</p>
<p><strong>作用</strong>：</p>
<ul>
<li>
<p>不修改被装饰的函数的源代码</p>
</li>
<li>
<p>不修改被装饰的函数的调用方式</p>
</li>
<li>
<p>满足前面两种情况下给程序增添功能</p>
</li>
</ul>
<p><strong>装饰器的原则组成</strong>：</p>
<p>函数 + 实参高阶函数 + 返回值高阶函数 + 嵌套函数 + 语法糖 = 装饰器</p>
<h2 id="为什么要使用装饰器"> 为什么要使用装饰器</h2>
<p>先来看个需求：</p>
<div><pre><code>improt time
<span>def</span> <span>test</span><span>(</span><span>)</span><span>:</span>
    time<span>.</span>sleep<span>(</span><span>2</span><span>)</span>
    <span>print</span><span>(</span><span>"test is running!"</span><span>)</span>
test<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>需要统计上述代码的执行时间，但是原有的代码不能被修改，这时装饰器的作用就体现了</p>
<h2 id="如何自定义装饰器"> 如何自定义装饰器</h2>
<p>分析上面的需求，可以重新定义一个函数，并把当前函数传入，然后在新的函数中运行，就可以实现了</p>
<div><pre><code>improt time

<span>def</span> <span>test</span><span>(</span><span>)</span><span>:</span>
    time<span>.</span>sleep<span>(</span><span>2</span><span>)</span>
    <span>print</span><span>(</span><span>"test is running!"</span><span>)</span>
<span>print</span><span>(</span><span>"test id:{}"</span><span>.</span><span>format</span><span>(</span><span>id</span><span>(</span>test<span>)</span><span>)</span><span>)</span>
    
<span>def</span> <span>deco</span><span>(</span>func<span>)</span><span>:</span>
    start <span>=</span> time<span>.</span>time<span>(</span><span>)</span>
    <span>print</span><span>(</span><span>id</span><span>(</span>func<span>)</span><span>)</span>
    func<span>(</span><span>)</span> 
    stop <span>=</span> time<span>.</span>time<span>(</span><span>)</span>
    <span>print</span><span>(</span>stop<span>-</span>start<span>)</span>

deco<span>(</span>test<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>结果：</p>
<div><pre><code>test <span>id</span><span>:</span><span>2731040652976</span>
func <span>id</span><span>:</span><span>2731040652976</span>
test <span>is</span> running!
<span>1.0034470558166504</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>从结果中看出，此时 test == func，指向同一个地址</p>
<p>虽然上述优化的代码，实现了统计时间的功能，但是<strong>修改了函数的运行方式</strong>，运行的是 <code>deco()</code> 这个函数，而不是运行 <code>test()</code></p>
<p>基于函数的运行方式，重新修改代码：</p>
<div><pre><code>improt time

<span>def</span> <span>test</span><span>(</span><span>)</span><span>:</span>
    time<span>.</span>sleep<span>(</span><span>2</span><span>)</span>
    <span>print</span><span>(</span><span>"test is running!"</span><span>)</span>

<span>def</span> <span>deco</span><span>(</span>func<span>)</span><span>:</span>  
    <span>print</span><span>(</span>func<span>)</span>
    <span>return</span> func 
t <span>=</span> deco<span>(</span>test<span>)</span>
t<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面的方案，test == func == t ，虽然最后原函数的调用方式没变，但是无法统计运行时间</p>
<p>既要能统计运行时间，又要保证原函数的调用方式不变，那要如何设计？</p>
<p>综合上面的一些设计，分析：</p>
<ul>
<li>要想统计运行时间，就必须在 test 运行前后进行统计</li>
<li>要想保留原函数的调用方式，那就必须最后执行的函数要使用 <code>test()</code> 方式执行</li>
<li>结合上面两次修改的代码，发现可以使用嵌套函数来实现</li>
</ul>
<div><pre><code><span>import</span> time

<span>def</span> <span>test</span><span>(</span><span>)</span><span>:</span>
    time<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
    <span>print</span><span>(</span><span>"test is running!"</span><span>)</span>

<span>print</span><span>(</span><span>"test1 id:{}"</span><span>.</span><span>format</span><span>(</span><span>id</span><span>(</span>test<span>)</span><span>)</span><span>)</span>

<span>def</span> <span>timer</span><span>(</span>func<span>)</span><span>:</span>
    <span>def</span> <span>deco</span><span>(</span><span>)</span><span>:</span>
        start <span>=</span> time<span>.</span>time<span>(</span><span>)</span>
        <span>print</span><span>(</span><span>"func id:{}"</span><span>.</span><span>format</span><span>(</span><span>id</span><span>(</span>func<span>)</span><span>)</span><span>)</span>
        func<span>(</span><span>)</span>
        stop <span>=</span> time<span>.</span>time<span>(</span><span>)</span>
        <span>print</span><span>(</span>stop <span>-</span> start<span>)</span>
    <span>return</span> deco

test <span>=</span> timer<span>(</span>test<span>)</span>
<span>print</span><span>(</span><span>"test2 id:{}"</span><span>.</span><span>format</span><span>(</span><span>id</span><span>(</span>test<span>)</span><span>)</span><span>)</span>
test<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>结果：</p>
<div><pre><code>test1 <span>id</span><span>:</span><span>1627287797424</span>
test2 <span>id</span><span>:</span><span>1627288937824</span>
func <span>id</span><span>:</span><span>1627287797424</span>
test <span>is</span> running!
<span>1.002009630203247</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>由结果可以看出，test == func == test</p>
<p><strong>流程</strong>：</p>
<p><img src="./../images/decorator1.png" alt="pytest" /></p>
<p>至此，上面的需求已经实现了，但用 timer 来装饰函数时，都要写上下面的一行代码</p>
<div><pre><code>test <span>=</span> timer<span>(</span>test<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>Python 提供了一种语法糖，使用 @timer 与上面作用等同：</p>
<div><pre><code><span>@timer</span>
<span>def</span> <span>test</span><span>(</span>parameter<span>)</span><span>:</span> 
    time<span>.</span>sleep<span>(</span><span>2</span><span>)</span>
    <span>print</span><span>(</span><span>"test is running!"</span><span>)</span> 
test<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="被装饰的函数带参"> 被装饰的函数带参</h3>
<p>上面的原函数是没有参数的，那如果原函数有参数，使用装饰器需要怎么传参呢？</p>
<p>以上面的 test 为例</p>
<p><strong>分析</strong>：</p>
<ul>
<li>test 有参数，就等于在 deco 中的 func 有参数</li>
<li>要给 test 传参，那就可以在 deco 中传参，内部的 func 可以读取参数</li>
</ul>
<div><pre><code>improt time
<span>def</span> <span>timer</span><span>(</span>func<span>)</span><span>:</span>
    <span>def</span> <span>deco</span><span>(</span><span>*</span>args<span>,</span><span>**</span>kwargs<span>)</span><span>:</span>
        start <span>=</span> time<span>.</span>time<span>(</span><span>)</span>
        <span># print("func id:{}".format(id(func)))</span>
        func<span>(</span><span>*</span>args<span>,</span><span>**</span>kwargs<span>)</span>
        stop <span>=</span> time<span>.</span>time<span>(</span><span>)</span>
        <span>print</span><span>(</span>stop <span>-</span> start<span>)</span>
    <span>return</span> deco

<span>@timer</span>
<span>def</span> <span>test</span><span>(</span>num<span>)</span><span>:</span>
    time<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
    <span>print</span><span>(</span><span>"test is running!"</span><span>)</span>
    <span>print</span><span>(</span>num<span>+</span><span>1</span><span>)</span>

test<span>(</span><span>2</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>结果：</p>
<div><pre><code>test <span>is</span> running!
<span>3</span>
<span>1.0060534477233887</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id="如果原函数有返回值"> 如果原函数有返回值</h4>
<p>只需要将 func 执行的结果返回即可</p>
<div><pre><code>improt time
<span>def</span> <span>timer</span><span>(</span>func<span>)</span><span>:</span>
    <span>def</span> <span>deco</span><span>(</span><span>*</span>args<span>,</span><span>**</span>kwargs<span>)</span><span>:</span>
        start <span>=</span> time<span>.</span>time<span>(</span><span>)</span>
        <span># print("func id:{}".format(id(func)))</span>
        res <span>=</span> func<span>(</span><span>*</span>args<span>,</span><span>**</span>kwargs<span>)</span>
        stop <span>=</span> time<span>.</span>time<span>(</span><span>)</span>
        <span>print</span><span>(</span>stop <span>-</span> start<span>)</span>
        <span>return</span> res
    <span>return</span> deco

<span>@timer</span>
<span>def</span> <span>test</span><span>(</span>num<span>)</span><span>:</span>
    time<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
    <span>print</span><span>(</span><span>"test is running!"</span><span>)</span>
    <span>return</span> num<span>+</span><span>1</span>

res <span>=</span> test<span>(</span><span>2</span><span>)</span>
<span>print</span><span>(</span>res<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h3 id="装饰器有参数"> 装饰器有参数</h3>
<p>比如有一个新的需求：</p>
<div><pre><code><span>def</span> <span>task1</span><span>(</span><span>)</span><span>:</span>
    time<span>.</span>sleep<span>(</span><span>2</span><span>)</span>
    <span>print</span><span>(</span><span>"in the task1"</span><span>)</span>

<span>def</span> <span>task2</span><span>(</span><span>)</span><span>:</span>
    time<span>.</span>sleep<span>(</span><span>2</span><span>)</span>
    <span>print</span><span>(</span><span>"in the task2"</span><span>)</span>

task1<span>(</span><span>)</span>
task2<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>要对这两个函数分别统计运行时间，但是要求统计之后输出:</p>
<div><pre><code>the task1<span>/</span>task2 run time <span>is</span> <span>:</span> <span>2.00</span>……
</code></pre>
<div><span>1</span><br></div></div><p>于是就要构造一个装饰器，要告诉装饰器哪个是 task1，哪个是 task2</p>
<div><pre><code><span>@timer</span><span>(</span>parameter<span>=</span><span>'task1'</span><span>)</span> 
<span>def</span> <span>task1</span><span>(</span><span>)</span><span>:</span>
    time<span>.</span>sleep<span>(</span><span>2</span><span>)</span>
    <span>print</span><span>(</span><span>"in the task1"</span><span>)</span>

<span>@timer</span><span>(</span>parameter<span>=</span><span>'task2'</span><span>)</span> 
<span>def</span> <span>task2</span><span>(</span><span>)</span><span>:</span>
    time<span>.</span>sleep<span>(</span><span>2</span><span>)</span>
    <span>print</span><span>(</span><span>"in the task2"</span><span>)</span>

task1<span>(</span><span>)</span>
task2<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>方法有了，那我们如何把这个 parameter 参数传递到装饰器中？</p>
<p>那就再加一层函数来接受参数，根据嵌套函数的概念，要想执行内函数，就要先执行外函数，才能调用到内函数：</p>
<div><pre><code><span>import</span> time

<span>def</span> <span>timer</span><span>(</span>parameter<span>)</span><span>:</span>
    <span>def</span> <span>outer_wrapper</span><span>(</span>func<span>)</span><span>:</span>
        <span>def</span> <span>wrapper</span><span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span>
            <span>if</span> parameter <span>==</span> <span>'task1'</span><span>:</span>
                start <span>=</span> time<span>.</span>time<span>(</span><span>)</span>
                func<span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span>
                stop <span>=</span> time<span>.</span>time<span>(</span><span>)</span>
                <span>print</span><span>(</span><span>"the task1 run time is :"</span><span>,</span> stop <span>-</span> start<span>)</span>
            <span>elif</span> parameter <span>==</span> <span>'task2'</span><span>:</span>
                start <span>=</span> time<span>.</span>time<span>(</span><span>)</span>
                func<span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span>
                stop <span>=</span> time<span>.</span>time<span>(</span><span>)</span>
                <span>print</span><span>(</span><span>"the task2 run time is :"</span><span>,</span> stop <span>-</span> start<span>)</span>
        <span>return</span> wrapper
    <span>return</span> outer_wrapper

<span>@timer</span><span>(</span><span>'task1'</span><span>)</span>
<span>def</span> <span>task1</span><span>(</span><span>)</span><span>:</span>
    time<span>.</span>sleep<span>(</span><span>2</span><span>)</span>
    <span>print</span><span>(</span><span>"in the task1"</span><span>)</span>

<span>@timer</span><span>(</span><span>'task2'</span><span>)</span>
<span>def</span> <span>task2</span><span>(</span><span>)</span><span>:</span>
    time<span>.</span>sleep<span>(</span><span>2</span><span>)</span>
    <span>print</span><span>(</span><span>"in the task2"</span><span>)</span>

task1<span>(</span><span>)</span>
task2<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>结果：</p>
<div><pre><code><span>in</span> the task1
the task1 run time <span>is</span> <span>:</span> <span>2.009113073348999</span>
<span>in</span> the task2
the task2 run time <span>is</span> <span>:</span> <span>2.0099661350250244</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>timer(parameter)，接收参数 parameter=’task1/2’，而 @timer(parameter) 也恰巧带了括号，那么就会执行这个函数，那么就是相当于：</p>
<div><pre><code>timer <span>=</span> timer<span>(</span>parameter<span>)</span>
task1 <span>=</span> timer<span>(</span>task1<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="类装饰器"> 类装饰器</h2>
<p>上面讲的都是函数装饰器</p>
<p>类装饰器的原理与函数装饰器的一致</p>
<h3 id="不带参类装饰器"> 不带参类装饰器</h3>
<div><pre><code><span>import</span> time

<span>class</span> <span>Timer</span><span>(</span><span>)</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span>func<span>)</span><span>:</span>
        self<span>.</span>func <span>=</span> func

    <span>def</span> <span>__call__</span><span>(</span>self<span>,</span> <span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span>
        start <span>=</span> time<span>.</span>time<span>(</span><span>)</span>
        self<span>.</span>func<span>(</span><span>)</span>
        stop <span>=</span> time<span>.</span>time<span>(</span><span>)</span>
        <span>print</span><span>(</span>stop <span>-</span> start<span>)</span>

<span>@Timer</span>
<span>def</span> <span>run</span><span>(</span><span>)</span><span>:</span>
    time<span>.</span>sleep<span>(</span><span>2</span><span>)</span>
    <span>print</span><span>(</span><span>"hello"</span><span>)</span>

run<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id="被装饰的函数带参-2"> 被装饰的函数带参</h3>
<div><pre><code><span>class</span> <span>Timer</span><span>(</span><span>)</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span>func<span>)</span><span>:</span>
        self<span>.</span>func <span>=</span> func

    <span>def</span> <span>__call__</span><span>(</span>self<span>,</span> <span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span>
        start <span>=</span> time<span>.</span>time<span>(</span><span>)</span>
        res <span>=</span> self<span>.</span>func<span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span>
        stop <span>=</span> time<span>.</span>time<span>(</span><span>)</span>
        <span>print</span><span>(</span>stop <span>-</span> start<span>)</span>
        <span>return</span> res

<span>@Timer</span>
<span>def</span> <span>run</span><span>(</span>a<span>,</span>b<span>)</span><span>:</span>
    time<span>.</span>sleep<span>(</span><span>2</span><span>)</span>
    <span>return</span> a<span>+</span>b

<span>print</span><span>(</span>run<span>(</span><span>1</span><span>,</span><span>4</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id="装饰器有参数-2"> 装饰器有参数</h3>
<div><pre><code><span>import</span> time

<span>class</span> <span>Timer</span><span>(</span><span>)</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span>prefix<span>)</span><span>:</span>
        self<span>.</span>prefix <span>=</span> prefix

    <span>def</span> <span>__call__</span><span>(</span>self<span>,</span> func<span>)</span><span>:</span>
        <span>def</span> <span>wrapper</span><span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span>
            start <span>=</span> time<span>.</span>time<span>(</span><span>)</span>
            res <span>=</span> func<span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span>
            stop <span>=</span> time<span>.</span>time<span>(</span><span>)</span>
            <span>print</span><span>(</span><span><span>f'</span><span><span>{</span>self<span>.</span>prefix<span>}</span></span><span>:</span><span><span>{</span>stop <span>-</span> start<span>}</span></span><span>'</span></span><span>)</span>
            <span>return</span> res
        <span>return</span> wrapper


<span>@Timer</span><span>(</span><span>'curent time:'</span><span>)</span>
<span>def</span> <span>run</span><span>(</span>a<span>,</span>b<span>)</span><span>:</span>
    time<span>.</span>sleep<span>(</span><span>2</span><span>)</span>
    <span>return</span> a<span>+</span>b

<span>print</span><span>(</span>run<span>(</span><span>1</span><span>,</span><span>4</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h2 id="参考文档"> 参考文档</h2>
<p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017451662295584" target="_blank" rel="noopener noreferrer">装饰器</a></p>
<p><a href="https://blog.csdn.net/u013471155/article/details/68960244" target="_blank" rel="noopener noreferrer">Python 装饰器</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T06:24:56.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">函数</title>
    <id>https://www.snowji.cn/languages/python/basics/function/</id>
    <link href="https://www.snowji.cn/languages/python/basics/function/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="函数"> 函数</h1>
<p><strong>作用</strong>:</p>
<ul>
<li>函数的使用可以重用代码，提高代码的重复利用率</li>
<li>函数能封装内部实现，保护内部数据，实现对用户的透明</li>
<li>函数使得程序模块化</li>
</ul>
<h2 id="参数的传递"> 参数的传递</h2>
<p><strong>存在的情况</strong>:</p>
<ul>
<li>Python 的函数参数传递的是实际对象的内存地址</li>
<li>Python 的数据类型分可变数据类型和不可变数据类型</li>
</ul>
<p>不可变类型：</p>
<div><pre><code>a = 1
def func(a):
    print(&quot;在函数内部修改之前,变量a的内存地址为：%s&quot; % id(a))
    a = 2
    print(&quot;在函数内部修改之后,变量a的内存地址为：%s&quot; % id(a))
    print(&quot;函数内部的a为：%s&quot; % a)


print(&quot;调用函数之前,变量a的内存地址为：%s&quot; % id(a))
func(a)
print(&quot;函数外部的a为：%s&quot; % a)


结果：
调用函数之前,变量a的内存地址为：1401140288
在函数内部修改之前,变量a的内存地址为：1401140288
在函数内部修改之后,变量a的内存地址为：1401140320
函数内部的a为：2
函数外部的a为：1

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>可变类型：</p>
<div><pre><code>a = [1, 2, 3]

def func(b):
    print(&quot;在函数内部修改之前,变量b的内存地址为：%s&quot; % id(b))
    b.append(4)
    print(&quot;在函数内部修改之后,变量b的内存地址为：%s&quot; % id(b))
    print(&quot;函数内部的b为：%s&quot; % b)


print(&quot;调用函数之前,变量a的内存地址为：%s&quot; % id(a))
func(a)
print(&quot;函数外部的a为：%s&quot; % a)


结果：
调用函数之前,变量a的内存地址为：34875720
在函数内部修改之前,变量b的内存地址为：34875720
在函数内部修改之后,变量b的内存地址为：34875720
函数内部的b为：[1, 2, 3, 4]
函数外部的a为：[1, 2, 3, 4]
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p><strong>存在差异原因</strong>:</p>
<ul>
<li>“=” 赋值语句，会创建新的变量</li>
<li>b.append(4)  不会创建新的变量</li>
</ul>
<h2 id="参数类型"> 参数类型</h2>
<h3 id="位置参数"> 位置参数</h3>
<p><strong>特点</strong>:</p>
<ul>
<li>必须在调用函数时明确提供的参数</li>
<li>位置参数必须按先后顺序，一一对应</li>
</ul>
<div><pre><code>def add(a, b, c):
    return a+b+c

result = add(&quot;haha&quot;, 2,  3)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="默认参数"> 默认参数</h3>
<p><strong>特点</strong>:</p>
<ul>
<li>参数有默认值</li>
<li>可以使用默认值，也可以自定义</li>
</ul>
<div><pre><code>def power(x, n = 2):
    return x**n

ret1 = power(10)   # 使用默认的参数值n=2
ret2 = power(10, 4)  # 将4传给n，实际计算10**4的值
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>默认参数的注意点</strong>:</p>
<ul>
<li>
<p>必须在位置参数的后面</p>
<div><pre><code>def power(x,n = 2):
    return x**n
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>使用的一些方式</strong>:</p>
<ul>
<li>
<p>有多个默认参数时，通常将常用的放在前面，变化较少的放在后面</p>
<div><pre><code>def student(name, sex, age, classroom=&quot;101&quot;, tel=&quot;88880000&quot;, address=&quot;...&quot;):
    pass
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>函数调用时，尽量给实际参数提供默认参数名</p>
<div><pre><code>def student(name, sex, age, classroom=&quot;101&quot;, tel=&quot;88880000&quot;, address=&quot;...&quot;):
    pass

student(&#39;jack&#39;,&#39;male&#39;,17)       # 其它全部使用默认值
student(&#39;tom&#39;,&#39;male&#39;,18,&#39;102&#39;,&#39;666666&#39;,&#39;beijing&#39;)    # 全部指定默认参数的值
student(&#39;mary&#39;,&#39;female&#39;,18,&#39;102&#39;,tel=&#39;666666&#39;)  # 挑着来
student(&#39;mary&#39;,&#39;female&#39;,18,tel=&#39;666666&#39;,&#39;beijing&#39;)   #  这是错误的参数传递方式
student(&quot;mary&quot;,&quot;female&quot;,18,tel=&quot;666666&quot;,address=&quot;beijing&quot;)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></li>
</ul>
</li>
<li>
<p>使用参数名传递参数</p>
<p>位置参数指定参数名时，调用时参数可不安顺序</p>
<div><pre><code>def student(name, age, classroom, tel, address=&quot;...&quot;):
    pass

student(classroom=101, name=&quot;Jack&quot;, tel=66666666, age=20)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>**注意：**使用上面的方式，参数名和位置参数名必须一致</p>
</li>
<li>
<p>默认参数尽量指向不变的对象</p>
<p>举个例子：</p>
<div><pre><code>def func(a=[]):
    a.append(&quot;A&quot;)
    return a

print(func())
print(func())
print(func())
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>你以为的答案：</p>
<div><pre><code>[&#39;A&#39;]
[&#39;A&#39;]
[&#39;A&#39;]
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>实际上的答案：</p>
<div><pre><code>[&#39;A&#39;]
[&#39;A&#39;, &#39;A&#39;]
[&#39;A&#39;, &#39;A&#39;, &#39;A&#39;]
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>原因</strong>:</p>
<ul>
<li>a 指向列表的地址，这个列表不会变</li>
<li>每次调用时向 a 中添加数据</li>
</ul>
</li>
</ul>
<h2 id="动态参数"> 动态参数</h2>
<p>参数的个数不确定</p>
<p><strong>注意：动态参数，必须放在所有的位置参数和默认参数后面</strong></p>
<div><pre><code>def func(name, age, sex=&#39;male&#39;, *args, **kwargs):
    pass
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>种类：</p>
<ul>
<li>
<p>*args</p>
<p><strong>特点</strong>:</p>
<ul>
<li>
<p>一个星号表示接收任意个参数</p>
</li>
<li>
<p>调用时，会将实际参数打包成一个元组传入形式参数</p>
</li>
<li>
<p>如果参数是个列表，会将整个列表当做一个参数传入</p>
</li>
</ul>
<div><pre><code>def func(*args):
    for arg in args:
        print(arg)

func(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)

li = [1, 2, 3]
func(li)

a
b
c
[1, 2, 3]
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>想要将列表中的每个元素当作参数传入，可以在列表前加个*实现：</p>
<div><pre><code>def func(*args):
    for arg in args:
        print(arg)

li = [1, 2, 3]
func(*li)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上述这种实现方式，同样适合元组、字符串、字典等，但字典传入的是 key 的值</p>
</li>
<li>
<p>**kwargs</p>
<p><strong>特点</strong>:</p>
<ul>
<li>两个星表示接受键值对的动态参数，数量任意</li>
<li>调用的时候会将实际参数打包成字典</li>
</ul>
<div><pre><code>def func(**kwargs):
    for kwg in kwargs:
        print(kwg, kwargs[kwg])
        print(type(kwg))

func(k1=&#39;v1&#39;, k2=[0, 1, 2])

k1 v1
&lt;class &#39;str&#39;&gt;
k2 [0, 1, 2]
&lt;class &#39;str&#39;&gt;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>思考：如果传入的参数就是个 dict 会怎样？</p>
<div><pre><code>def func(**kwargs):
    for kwg in kwargs:
        print(kwg, kwargs[kwg])

dic = {
    &#39;k1&#39;: &#39;v1&#39;,
    &#39;k2&#39;: &#39;v2&#39;
}

func(dic)


结果：
Traceback (most recent call last):
  File &quot;F:/Python/pycharm/201705/func.py&quot;, line 10, in &lt;module&gt;
    func(dic)
TypeError: func() takes 0 positional arguments but 1 was given
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>原因：这种传入时，将字典当作一个位置参数传入了，但函数不接受位置参数</p>
<p>再次思考：那需要怎么传值，才能识别字典？</p>
<p>使用两个 ** 号：将字典内的键值对传入</p>
<div><pre><code>def func(**kwargs):
    for kwg in kwargs:
        print(kwg, kwargs[kwg])

dic = {
    &#39;k1&#39;: &#39;v1&#39;,
    &#39;k2&#39;: &#39;v2&#39;
}

func(**dic)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div></li>
<li>
<p>万能参数</p>
<p>*args 和 **kwargs 组合起来使用</p>
<p>结合一下普通参数和万能参数 ：</p>
<div><pre><code>def func(a, b, c=1, *args, **kwargs):
    for arg in args:
        print(arg)

    for kwg in kwargs:
        print(kwg, kwargs[kwg])


lis = [&#39;aaa&#39;, &#39;bbb&#39;, &#39;ccc&#39;]
dic = {
    &#39;k1&#39;: &#39;v1&#39;,
    &#39;k2&#39;: &#39;v2&#39;
}

func(1, 2, *lis, **dic)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>你以为的：</p>
<div><pre><code>aaa
bbb
ccc
k1 v1
k2 v2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>实际上的：</p>
<div><pre><code>bbb
ccc
k1 v1
k2 v2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>原因：根据 python 参数传递规则，aaa 被传给 默认参数 c 了</p>
</li>
<li>
<p>关键字参数</p>
<p><strong>特点</strong>:</p>
<ul>
<li>
<p>使用 * 进行分割</p>
</li>
<li>
<p><code>*</code>前是 位置参数和默认参数</p>
</li>
<li>
<p><code>*</code>后是 关键字参数</p>
</li>
</ul>
<div><pre><code>def student(name, age, *, sex):
    pass

student(name=&quot;jack&quot;, age=18, sex=&#39;male&#39;)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>函数中有 *args 参数了，就不需要使用 * 分割</p>
<div><pre><code>def student(name, age=10, *args, sex, classroom, **kwargs):
    pass

student(name=&quot;jack&quot;, age=18, sex=&#39;male&#39;, classroom=&quot;202&quot;, k1=&quot;v1&quot;)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T06:24:56.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">生成器</title>
    <id>https://www.snowji.cn/languages/python/basics/generator/</id>
    <link href="https://www.snowji.cn/languages/python/basics/generator/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="生成器"> 生成器</h1>
<p><strong>特点：</strong></p>
<ul>
<li>在循环的过程中不断推算出后续的元素，不必创建完整的元素集合</li>
<li>节省大量空间</li>
</ul>
<div><pre><code>&gt;&gt;&gt; g = (x * x for x in range(1, 4))
&gt;&gt;&gt; g
&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>通过 next() 获取下一个返回值，无值可取时抛出异常：</p>
<div><pre><code>&gt;&gt;&gt; next(g)
1
&gt;&gt;&gt; next(g)
4
&gt;&gt;&gt; next(g)
9
&gt;&gt;&gt; next(g)
Traceback (most recent call last):
  File &quot;&lt;pyshell#14&gt;&quot;, line 1, in &lt;module&gt;
    next(g)
StopIteration
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><strong>获取生成器值得方法：</strong></p>
<ul>
<li>for 循环取值</li>
</ul>
<div><pre><code>for i in g:
    print(i)
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>使用 yield 关键字
<ul>
<li>使用 yield 返回得函数会变成一个生成器</li>
<li>调用生成器的过程中，每次遇到yield时函数会暂停并保存当前所有的运行信息，返回yield的值</li>
<li>在下一次执行 next() 方法时从当前位置继续运行</li>
</ul>
</li>
</ul>
<div><pre><code>def fibonacci(n):    
    a, b, counter = 0, 1, 0
    while True:
        if counter &gt; n:
            return
        yield a             # yield让该函数变成一个生成器
        a, b = b, a + b
        counter += 1

fib = fibonacci(10)           # fib是一个生成器
print(type(fib))
for i in fib:
    print(i, end=&quot; &quot;)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>（完）</p>
<p>​</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T06:24:56.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">继承</title>
    <id>https://www.snowji.cn/languages/python/basics/inherit/</id>
    <link href="https://www.snowji.cn/languages/python/basics/inherit/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="继承"> 继承</h1>
<p><strong>语法结构</strong>：</p>
<div><pre><code><span>class</span> <span>Foo</span><span>(</span>superA<span>,</span> superB<span>,</span>superC<span>.</span><span>.</span><span>.</span><span>.</span><span>)</span><span>:</span>
    <span>pass</span>
<span>class</span> <span>DerivedClassName</span><span>(</span>modname<span>.</span>BaseClassName<span>)</span><span>:</span> <span>## 当父类定义在另外的模块时</span>
    <span>pass</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>优点</strong>：</p>
<ul>
<li>实现了代码的复用，多个类公用的代码部分可以只在一个类中提供，其他类只需要继承这个类即可</li>
<li>子类获得了父类的全部变量和方法的同时，又可以根据需要进行修改、拓展</li>
</ul>
<h2 id="继承方式"> 继承方式</h2>
<h3 id="单继承"> 单继承</h3>
<p><strong>定义</strong>：只继承于一个父类</p>
<div><pre><code><span># 父类定义</span>
<span>class</span> <span>people</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>,</span> age<span>,</span> weight<span>)</span><span>:</span>
        self<span>.</span>name <span>=</span> name
        self<span>.</span>age <span>=</span> age
        self<span>.</span>__weight <span>=</span> weight
    <span>def</span> <span>speak</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"%s 说: 我 %d 岁。"</span> <span>%</span> <span>(</span>self<span>.</span>name<span>,</span> self<span>.</span>age<span>)</span><span>)</span>

<span># 单继承示例</span>
<span>class</span> <span>student</span><span>(</span>people<span>)</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>,</span> age<span>,</span> weight<span>,</span> grade<span>)</span><span>:</span>
        <span># 调用父类的实例化方法</span>
        people<span>.</span>__init__<span>(</span>self<span>,</span> name<span>,</span> age<span>,</span> weight<span>)</span>
        self<span>.</span>grade <span>=</span> grade
    <span># 重写父类的speak方法</span>
    <span>def</span> <span>speak</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"%s 说: 我 %d 岁了，我在读 %d 年级"</span> <span>%</span> <span>(</span>self<span>.</span>name<span>,</span> self<span>.</span>age<span>,</span> self<span>.</span>grade<span>)</span><span>)</span>

s <span>=</span> student<span>(</span><span>'ken'</span><span>,</span> <span>10</span><span>,</span> <span>30</span><span>,</span> <span>3</span><span>)</span>
s<span>.</span>speak<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h3 id="多继承"> 多继承</h3>
<p><strong>定义</strong>：有多个父类</p>
<div><pre><code><span>class</span> <span>A</span><span>:</span>
    <span>pass</span>
<span>class</span> <span>B</span><span>:</span>
    <span>pass</span>
<span>class</span> <span>C</span><span>(</span>A<span>,</span>B<span>)</span><span>:</span>
    <span>pass</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>注意</strong>：需要注意括号内基类的顺序</p>
<p>多继承时，若是基类中有相同的方法名，并且在子类使用时未指定，Python 会从左至右搜索基类中是否包含该方法。一旦查找到则直接调用，后面不再继续查找</p>
<h2 id="继承机制"> 继承机制</h2>
<p>Python3 的继承机制不同于 Python2</p>
<h3 id="python3"> Python3</h3>
<p><strong>核心原则</strong>：</p>
<ul>
<li>子类在调用某个方法或变量的时候，首先在自己内部查找，如果没有找到，则开始根据继承机制在父类里查找。</li>
<li>根据父类定义中的顺序，以<strong>深度优先</strong>的方式逐一查找父类</li>
</ul>
<p><strong>深度优先</strong>：</p>
<p>例：</p>
<div><pre><code><span>class</span> <span>D</span><span>:</span>
    <span>def</span> <span>show</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"i am D"</span><span>)</span>
    <span>pass</span>

<span>class</span> <span>C</span><span>(</span>D<span>)</span><span>:</span>
    <span>pass</span>

<span>class</span> <span>B</span><span>(</span>C<span>)</span><span>:</span>

    <span>pass</span>

<span>class</span> <span>G</span><span>:</span>
    <span>pass</span>

<span>class</span> <span>F</span><span>(</span>G<span>)</span><span>:</span>
    <span>pass</span>

<span>class</span> <span>E</span><span>(</span>F<span>)</span><span>:</span> 
    <span>def</span> <span>show</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"i am E"</span><span>)</span>
    <span>pass</span>

<span>class</span> <span>A</span><span>(</span>B<span>,</span> E<span>)</span><span>:</span>
    <span>pass</span>

a <span>=</span> A<span>(</span><span>)</span>
a<span>.</span>show<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>查询顺序：</p>
<p><img src="./../images/结果1.jpg" alt="结果1" /></p>
<p>再例：</p>
<div><pre><code><span>class</span> <span>H</span><span>:</span>
    <span>def</span> <span>show</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"i am H"</span><span>)</span>
    <span>pass</span>

<span>class</span> <span>D</span><span>(</span>H<span>)</span><span>:</span>
    <span>pass</span>

<span>class</span> <span>C</span><span>(</span>D<span>)</span><span>:</span>
    <span>pass</span>

<span>class</span> <span>B</span><span>(</span>C<span>)</span><span>:</span>
    <span>pass</span>

<span>class</span> <span>G</span><span>(</span>H<span>)</span><span>:</span>
    <span>pass</span>

<span>class</span> <span>F</span><span>(</span>G<span>)</span><span>:</span>
    <span>pass</span>

<span>class</span> <span>E</span><span>(</span>F<span>)</span><span>:</span> 
    <span>def</span> <span>show</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"i am E"</span><span>)</span>
    <span>pass</span>

<span>class</span> <span>A</span><span>(</span>B<span>,</span> E<span>)</span><span>:</span>
    <span>pass</span>

a <span>=</span> A<span>(</span><span>)</span>
a<span>.</span>show<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>你以为的结果：&quot;i am H&quot;</p>
<p>实际上的结果：&quot;i am E&quot;</p>
<p>搜索顺序：</p>
<p><img src="./../images/深度优先.png" alt="结果1" /></p>
<h3 id="super-函数"> super() 函数</h3>
<p><strong>作用</strong>：super调用父类的实例化方法 <code>__init__</code></p>
<p><strong>语法</strong>：</p>
<div><pre><code><span>super</span><span>(</span>子类名<span>,</span> self<span>)</span><span>.</span>方法名<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>例：</p>
<div><pre><code><span>class</span> <span>A</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>)</span><span>:</span>
        self<span>.</span>name <span>=</span> name
        <span>print</span><span>(</span><span>"父类的__init__方法被执行了！"</span><span>)</span>
    <span>def</span> <span>show</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"父类的show方法被执行了！"</span><span>)</span>

<span>class</span> <span>B</span><span>(</span>A<span>)</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>,</span> age<span>)</span><span>:</span>
        <span>super</span><span>(</span>B<span>,</span> self<span>)</span><span>.</span>__init__<span>(</span>name<span>=</span>name<span>)</span>
        self<span>.</span>age <span>=</span> age

    <span>def</span> <span>show</span><span>(</span>self<span>)</span><span>:</span>
        <span>super</span><span>(</span>B<span>,</span> self<span>)</span><span>.</span>show<span>(</span><span>)</span>

obj <span>=</span> B<span>(</span><span>"jack"</span><span>,</span> <span>18</span><span>)</span>
obj<span>.</span>show<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id="多态"> 多态</h2>
<p>子类继承了父类后，也拥有父类的类型</p>
<div><pre><code><span>class</span> <span>Animal</span><span>:</span>

    <span>def</span> <span>kind</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"i am animal"</span><span>)</span>


<span>class</span> <span>Dog</span><span>(</span>Animal<span>)</span><span>:</span>

    <span>def</span> <span>kind</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"i am a dog"</span><span>)</span>


<span>class</span> <span>Cat</span><span>(</span>Animal<span>)</span><span>:</span>

    <span>def</span> <span>kind</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"i am a cat"</span><span>)</span>
        
<span>def</span> <span>show_kind</span><span>(</span>animal<span>)</span><span>:</span>
    animal<span>.</span>kind<span>(</span><span>)</span>
    
d <span>=</span> Dog<span>(</span><span>)</span>
c <span>=</span> Cat<span>(</span><span>)</span>

<span>print</span><span>(</span>instance<span>(</span>d<span>,</span>Animal<span>)</span><span>)</span>
show_kind<span>(</span>d<span>)</span>
show_kind<span>(</span>c<span>)</span>
<span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span>
结果：
i am a dog
i am a cat
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T06:24:56.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">迭代器</title>
    <id>https://www.snowji.cn/languages/python/basics/iterator/</id>
    <link href="https://www.snowji.cn/languages/python/basics/iterator/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="迭代器"> 迭代器</h1>
<p>**迭代：**通过 for 循环遍历对象的每一个元素的过程</p>
<p>**判断对象是否可迭代：**通过 collections 模块中的 iterable</p>
<div><pre><code>&gt;&gt;&gt; from collections import Iterable
&gt;&gt;&gt; isinstance(&#39;abc&#39;, Iterable)         # str是否可迭代
True
&gt;&gt;&gt; isinstance([1,2,3], Iterable)       # list是否可迭代
True
&gt;&gt;&gt; isinstance(123, Iterable)           # 整数是否可迭代
False
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><strong>迭代器：</strong></p>
<p>​	**定义：**一种可被遍历的对象，并且能作用于 next() 函数</p>
<p>​	**特点：**从集合的第一个元素开始访问，只能往后遍历不能回溯</p>
<p>​	<strong>基本方法：</strong></p>
<ul>
<li>iter()</li>
<li>next()</li>
</ul>
<div><pre><code>&gt;&gt;&gt; lis=[1,2,3,4]
&gt;&gt;&gt; it = iter(lis)     # 使用Python内置的iter()方法创建迭代器对象
&gt;&gt;&gt; next(it)           # 使用next()方法获取迭代器的下一个元素
1
&gt;&gt;&gt; next(it)
2
&gt;&gt;&gt; next(it)
3
&gt;&gt;&gt; next(it)
4
&gt;&gt;&gt; next(it)            # 当后面没有元素可以next的时候，弹出错误
Traceback (most recent call last):
  File &quot;&lt;pyshell#6&gt;&quot;, line 1, in &lt;module&gt;
    next(it)
StopIteration
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>类实现成为迭代器：实现 <code>__iter__()</code> 和 <code>__next__()</code> 方法</p>
<p><strong>迭代器(Iterator)和可迭代(Iterable)的区别</strong>：</p>
<ul>
<li>凡是可作用于 for 循环的对象都是可迭代类型；</li>
<li>凡是可作用于 next() 函数的对象都是迭代器类型；</li>
<li>list、dict、str 等是可迭代的但不是迭代器，因为 next() 函数无法调用它们，可通过 iter() 函数将它们转换成迭代器。</li>
<li>Python的 for 循环本质上就是通过不断调用 next() 函数实现的</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li>表示的是一个元素流，可以被 next() 函数调用并不断返回下一个元素</li>
<li>通过 next() 取值，节省内存和空间</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T06:24:56.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Python 内存回收</title>
    <id>https://www.snowji.cn/languages/python/basics/memory-recovery/</id>
    <link href="https://www.snowji.cn/languages/python/basics/memory-recovery/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="python-内存回收"> Python 内存回收</h1>
<p>在 Python 中主要通过<strong>引用计数器</strong>来进行垃圾回收，但只通过引用计数器会存在循环引用的问题，引入<strong>标记清除</strong>和<strong>分代回收</strong>的机制进行完善</p>
<h2 id="引用计数器"> 引用计数器</h2>
<h3 id="_1-环状双向链表-refchain"> 1. 环状双向链表（refchain）</h3>
<p><img src="./../images/refchain1.png" alt="refchain" /></p>
<p>在运行 Python 文件时，底层会建立一张环状双向链表，所有创建的对象都会被加入这个 refchain 中，如：</p>
<div><pre><code>a <span>=</span> <span>99</span>
b <span>=</span> <span>"hello"</span>
c <span>=</span> <span>[</span><span>1</span><span>,</span><span>3</span><span>,</span><span>4</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>运行上面的代码时，会开辟一块空间用来存储 99、“hello”、[1,3,4]，这 3 个对象，，并把这三个对象加入 refchain 中，并存储一些基本的数据：</p>
<ul>
<li>对象的值</li>
<li>引用的次数：默认是1</li>
<li>上一个对象地址</li>
<li>下一个对象地址</li>
</ul>
<p><img src="./../images/refchain.png" alt="refchain" /></p>
<p>由上图可以看出，对于列表这种对象，除了存储以上 4 个基本的数据外，还会存储一些特有的数据，如：元素个数等。</p>
<div><pre><code>d = a
</code></pre>
<div><span>1</span><br></div></div><p>当执行到此行时，由于 d 指向的还是 99 这个对象，因此会在 refchain 中将次对象的数据中的引用次数 +1，此时该对象的引用次数就变成 2</p>
<div><pre><code>del d
del a
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>当执行到 del b 这句时，会将 d 指向的对象，在 refchain 中将该对象的引用次数 -1</p>
<p>当执行到 del a 这句时，会将 a 指向的对象，在 refchain 中将该对象的引用次数 -1</p>
<p>此时，该对象的引用次数为 0 ，系统会对引用次数为 0 的对象进行垃圾回收或内存释放。</p>
<h3 id="_2-循环引用"> 2. 循环引用</h3>
<div><pre><code>a = [1,2,3]
b = [4,5,6]
a.append(b)    //在 [1,2,3] 列表中添加第 4 个元素[4,5,6]
b.append(a)    //在 [4,5,6] 列表中添加第 4 个元素[1,2,3]

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>运行第一行时，[1,2,3] 这个列表对象在 refchain 中的引用计数器为 1</p>
<p>运行第二行时，[4,5,6] 这个列表对象在 refchain 中的引用计数器为 1</p>
<p>运行第三行时，由于将 [4,5,6] 对象作为元素添加到 [1,2,3] 中，所以 [4,5,6] 这个对象在 refchain 中的引用次数 +1，为 2</p>
<p>运行第四行时，由于将 [1,2,3] 对象作为元素添加到 [4,5,6] 中，所以 [1,2,3] 这个对象在 refchain 中的引用次数 +1，为 2</p>
<div><pre><code>del a 
del b
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>当运行此时，[1,2,3] 和 [4,5,6] 在 refchain 中的引用计数 -1 ，为 1，但程序已经删除了这两个对象引用的变量了，也就意味着这两个对象没有被引用，对没有被引用的对象，系统应该是要对其进行垃圾回收的，但是由于 refchain 中的值不为 0，Python 是不会对这两个对象进行垃圾回收，而且会一直占用内存，这就是循环引用带来的问题，为解决此问题，引入了标记清除机制。</p>
<h2 id="标记清除"> 标记清除</h2>
<p>在底层除了建立一张 refchain 表存储所有的对象外，另外在建立一张表存储那些可能存在<strong>循环引用</strong>的对象，也就是说，此时底层会有 2 张表：</p>
<p><img src="./../images/mark.png" alt="mark" /></p>
<p>可能存在循环引用的类型（元素可以是对象的数据类型）：</p>
<ul>
<li>
<p>列表</p>
</li>
<li>
<p>字典</p>
</li>
<li>
<p>元祖</p>
</li>
<li>
<p>集合</p>
</li>
</ul>
<p>系统会对存储可能存在循环引用对象的链表中对每一个对象进行扫描，看是否有循环引用，有的话会将双方的引用计数器减 1 ，此时会有 2 个问题：</p>
<ul>
<li>什么时候会扫描这个链表</li>
<li>如果链表中存储的对象比较多，每次扫描时耗时会很长</li>
</ul>
<p>为了解决这个问题，引入了分代回收机制</p>
<h2 id="分代回收"> 分代回收</h2>
<p>会将标记清除的链表，分成 3 代进行回收：</p>
<p><img src="./../images/fendai.png" alt="fendai" /></p>
<ul>
<li>
<p>什么时候扫描？</p>
<p>0 代：链表中的对象个数大于 700 时，扫描一次，会回收掉一些不引用的对象，剩下的对象将会被添加到 1 代中</p>
<p>1 代：0 代扫描 10 超过 10 次，则 1 代扫描一次，会回收掉一些不引用的对象，剩下的对象将会被添加到 2 代中</p>
<p>2 代：1 代扫描 10 超过 10 次，则 2 代扫描一次，</p>
</li>
</ul>
<h2 id="缓存机制"> 缓存机制</h2>
<p>在 Python 中为了提高性能，Python 使用了池和 free_list 两种缓存的机制，来进行数据的缓存。</p>
<ul>
<li>
<p>池</p>
<ul>
<li>
<p>int 类型：</p>
<p>在运行 Python 的时候，系统会为我们创建一个小数据池，缓存常用的数，范围是从 -5 -4~~257，超过此范围的时候，系统会为其开辟内存空间，并加入到 refchain 中。在此范围的对象，系统不会为其重新创建内存空间，会从池中直接取，其引用计数器的值会在默认 1 的基础上加 1</p>
</li>
<li>
<p>str 类型</p>
<ul>
<li>
<p>单字符：使用池的机制，将 ASII 字符进行缓存到 unicode_latiml，后续不会再创建相应的对象，直接从池中取</p>
</li>
<li>
<p>字符串：对于由字母、数字、下划线组成的字符，且长度不超过 20 的有驻留机制，如果内存中有，不会再被创建</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>free_list</p>
</li>
</ul>
<p>将一些引用计数器为 0 的对象从 refchain 中移除后，将其加入 free_list 缓存，等下次创建通类型的时候，直接从 free_list 中取，放入 refchain 中</p>
<ul>
<li>
<p>float：默认free_list 个数为100个，超过的会直接清除</p>
</li>
<li>
<p>list：默认free_list 个数为 80个，超过的会直接清除</p>
</li>
<li>
<p>tuple：存储的容量是20，相当于20个索引，每个索引下可以存 2000 个对象</p>
</li>
<li>
<p>dict：默认free_list 个数为 80个，超过的会直接清除</p>
</li>
</ul>
<h2 id="参考文档"> 参考文档</h2>
<p><a href="https://www.bilibili.com/video/BV1F54114761?p=1" target="_blank" rel="noopener noreferrer">内存管理与垃圾回收</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T06:24:56.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">循环</title>
    <id>https://www.snowji.cn/languages/python/basics/loop/</id>
    <link href="https://www.snowji.cn/languages/python/basics/loop/"/>
    <updated>2022-09-02T06:24:56.000Z</updated>
    <content type="html"><![CDATA[<h1 id="循环"> 循环</h1>
<h2 id="while"> while</h2>
<p><strong>while的else从句：</strong></p>
<ul>
<li>当 while 循环正常执行完毕，会执行 else 语句</li>
</ul>
<div><pre><code>number = 10
i = 0
# i = 11
while i &lt; number:
    print(i)
    i += 1
else:
    print(&quot;执行完毕！&quot;)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ul>
<li>被 break 等机制强制提前终止的循环，不会执行 else 语句</li>
</ul>
<div><pre><code>number = 10
i = 0
while i &lt; number:
    print(i)
    i += 1
    if i == 7:
        break           
else:
    print(&quot;执行完毕！&quot;)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="for"> for</h2>
<p><strong>for循环的else 子句：</strong></p>
<p>与 while 一样，正常结束循环时，else 子句执行。被中途 break 时，则不执行</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T06:24:56.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Python 特殊函数</title>
    <id>https://www.snowji.cn/languages/python/basics/magic-method/</id>
    <link href="https://www.snowji.cn/languages/python/basics/magic-method/"/>
    <updated>2022-09-02T06:24:56.000Z</updated>
    <content type="html"><![CDATA[<h1 id="python-特殊函数"> Python 特殊函数</h1>
<p>介绍一些 Python 常用的魔术方法，如 <code>__init__</code>、<code>__new__</code> 等。</p>
<h2 id="init"> <code>__init__</code></h2>
<p>这是一个实例函数，主要是用来初始化对象属性的，当对象创建的时候，就会自动调用这个函数，如果有属性时，会给对象赋予相应的属性</p>
<div><pre><code><span>#__init__函数</span>
<span>class</span> <span>A</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>)</span><span>:</span>  <span># 实例方法</span>
        <span>print</span><span>(</span><span>'开始给对象赋予属性了'</span><span>)</span>
        self<span>.</span>name <span>=</span> name
a <span>=</span> A<span>(</span><span>"hello"</span><span>)</span>
<span>print</span><span>(</span>a<span>.</span>name<span>)</span>
<span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span>
开始给对象赋予属性了
hello
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="new"> <code>__new__</code></h2>
<p>这是个类方法，用来创建对象，创建对象的时候最先调用的方法，通常会用来做单例模式和对象创建计数，<code>*args</code>，<code>**kwargs</code> 是用来接收和传递创建对象时的参数</p>
<div><pre><code><span>class</span> <span>A</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>,</span> age<span>)</span><span>:</span>  <span># 实例方法</span>
        <span>print</span><span>(</span><span>'开始给对象赋予属性了'</span><span>)</span>
        self<span>.</span>name <span>=</span> name
        self<span>.</span>age <span>=</span> age

    <span>def</span> <span>__new__</span><span>(</span>cls<span>,</span> <span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span> <span># 类方法</span>
        <span>print</span><span>(</span><span>'开始新建对象了'</span><span>)</span>
        <span>print</span><span>(</span><span>'我是参数args'</span><span>,</span> args<span>)</span>
        <span>print</span><span>(</span><span>'我是参数kwargs'</span><span>,</span> kwargs<span>)</span>
        <span>return</span> <span>object</span><span>.</span>__new__<span>(</span>cls<span>)</span>
        <span># 必须要有返回值 返回创建出来的实例</span>

a <span>=</span> A<span>(</span><span>'小明'</span><span>,</span> <span>2</span><span>)</span>
<span>print</span><span>(</span>a<span>.</span>name<span>,</span>a<span>.</span>age<span>)</span>
<span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span>
开始新建对象了
我是参数args <span>(</span><span>'小明'</span><span>,</span> <span>2</span><span>)</span>
我是参数kwargs <span>{</span><span>}</span>
开始给对象赋予属性了
小明 <span>2</span>
<span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span>

<span>class</span> <span>A</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>,</span> age<span>=</span><span>1</span><span>)</span><span>:</span>  <span># 实例方法</span>
        <span>print</span><span>(</span><span>'开始给对象赋予属性了'</span><span>)</span>
        self<span>.</span>name <span>=</span> name
        self<span>.</span>age <span>=</span> age

    <span>def</span> <span>__new__</span><span>(</span>cls<span>,</span> <span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span> <span># 类方法</span>
        <span>print</span><span>(</span><span>'开始新建对象了'</span><span>)</span>
        <span>print</span><span>(</span><span>'我是参数args'</span><span>,</span> args<span>)</span>
        <span>print</span><span>(</span><span>'我是参数kwargs'</span><span>,</span> kwargs<span>)</span>
        <span>return</span> <span>object</span><span>.</span>__new__<span>(</span>cls<span>)</span>
        <span># 必须要有返回值 返回创建出来的实例</span>


a <span>=</span> A<span>(</span><span>'小明'</span><span>,</span> age<span>=</span><span>2</span><span>)</span>
<span>print</span><span>(</span>a<span>.</span>name<span>,</span>a<span>.</span>age<span>)</span>
<span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span>
开始新建对象了
我是参数args <span>(</span><span>'小明'</span><span>,</span><span>)</span>
我是参数kwargs <span>{</span><span>'age'</span><span>:</span> <span>2</span><span>}</span>
开始给对象赋予属性了
小明 <span>2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><p>由上面的例子可以看出，此函数会在<code>__init__</code>函数之前调用，返回一个实例对象</p>
<h2 id="del"> <code>__del__</code></h2>
<p>对象不在被变量引用时，删除该对象的引用，由垃圾回收机制回收相应的内存，方式有两种：</p>
<ul>
<li>当对象在某个作用域中调用完毕，在跳出其作用域的同时析构函数会被调用一次，这样可以删除对象引用</li>
</ul>
<div><pre><code><span>class</span> <span>A</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"实例被初始化"</span><span>)</span>

    <span>def</span> <span>__del__</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"实例被销毁"</span><span>)</span>

a <span>=</span> A<span>(</span><span>)</span>
<span>print</span><span>(</span><span>'我是最后一行代码'</span><span>)</span>
<span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span>
实例被初始化
我是最后一行代码
实例被销毁
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>执行到 a = A() 后，由于当前作用域中还有一行代码，在执行最后一行代码后，执行了 A 中的析构函数，删除了 a 的引用</p>
<ul>
<li>当使用 del 删除对象时，会调用他本身的析构函数, 删除了 a 的引用</li>
</ul>
<div><pre><code><span>class</span> <span>A</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"实例被初始化"</span><span>)</span>

    <span>def</span> <span>__del__</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"实例被销毁"</span><span>)</span>

a <span>=</span> A<span>(</span><span>)</span>
<span>del</span> a
<span>print</span><span>(</span><span>'我是最后一行代码'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><code>del a</code> 语句执行时候, 内存立即被回收, 即执行打印&quot;实例被销毁&quot;. 最后才是执行打印&quot;我是最后一行代码&quot;</p>
<h2 id="call"> <code>__call__</code></h2>
<p>类中实现这一方法可以使该类的实例（对象）像函数一样被调用</p>
<div><pre><code><span>class</span> <span>People</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span>name<span>)</span><span>:</span>
        self<span>.</span>name <span>=</span> name

    <span>def</span> <span>__call__</span><span>(</span>self<span>,</span> <span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'hello '</span><span>+</span> self<span>.</span>name<span>)</span>

p <span>=</span> People<span>(</span><span>"Alex"</span><span>)</span>
p<span>.</span>__call__<span>(</span><span>)</span>     <span># 调用方式一</span>
p<span>(</span><span>)</span>              <span># 调用方式二</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T06:24:56.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">元类</title>
    <id>https://www.snowji.cn/languages/python/basics/metaclass/</id>
    <link href="https://www.snowji.cn/languages/python/basics/metaclass/"/>
    <updated>2022-09-02T06:24:56.000Z</updated>
    <content type="html"><![CDATA[<h1 id="元类"> 元类</h1>
<p>在了解元类之前，需要学习 Python 中的类，以及使用类创建对象的过程，才能更好的理解</p>
<p>可参考 <a href="/languages/python/python/类与实例.html">类与实例</a></p>
<h2 id="什么是元类"> 什么是元类</h2>
<p>学过类的都知道，实例对象是由类创建的，那有没有想过类是由谁创建的？</p>
<div><p>type</p>
<p>类默认是由 type 创建的</p>
</div>
<p><strong>使用 type 查看类的类型</strong>：</p>
<div><pre><code><span>class</span> <span>Foo</span><span>:</span>
    v1 <span>=</span> <span>123</span>

    <span>def</span> <span>func</span><span>(</span>self<span>)</span><span>:</span>
        <span>return</span> <span>666</span>

<span>print</span><span>(</span>Foo<span>)</span>
<span>print</span><span>(</span><span>type</span><span>(</span>Foo<span>)</span><span>)</span>

结果：
<span>&lt;</span><span>class</span> <span>'__main__.Foo'</span><span>></span>
<span>&lt;</span><span>class</span> <span>'type'</span><span>></span>
 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>可以看到我们创建类的类型为 <strong>type</strong></p>
<p>对比上面的传统模式，可以使用 <strong>type</strong> 方式来创建类</p>
<h3 id="type-方式创建类"> <strong>type 方式创建类</strong>：</h3>
<p><strong>语法</strong>：</p>
<div><pre><code><span>type</span><span>(</span>name<span>,</span> base<span>,</span><span>dict</span><span>)</span>

name<span>:</span> 需要创建的类名
base：继承的类
<span>dict</span>：类中的成员

源码：
    <span>def</span> <span>__init__</span><span>(</span>cls<span>,</span> what<span>,</span> bases<span>=</span><span>None</span><span>,</span> <span>dict</span><span>=</span><span>None</span><span>)</span><span>:</span> <span># known special case of type.__init__</span>
        <span>"""
        type(object_or_name, bases, dict)
        type(object) -> the object's type
        type(name, bases, dict) -> a new type
        # (copied from class doc)
        """</span>
        <span>pass</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>示例：</p>
<div><pre><code><span># 创建类</span>
Fa <span>=</span> <span>type</span><span>(</span><span>"Foo"</span><span>,</span><span>(</span><span>object</span><span>,</span><span>)</span><span>,</span><span>{</span><span>'v1'</span><span>:</span><span>123</span><span>,</span><span>'func'</span><span>:</span><span>lambda</span> self<span>:</span><span>666</span><span>}</span><span>)</span>
<span>print</span><span>(</span>Fa<span>)</span>
<span># 根据类创建对象</span>
obj <span>=</span> Fa<span>(</span><span>)</span>
<span># 调用实例中的方法</span>
<span>print</span><span>(</span>obj<span>.</span>func<span>(</span><span>)</span><span>)</span>

结果：
<span>&lt;</span><span>class</span> <span>'__main__.Foo'</span><span>></span>
<span>666</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>可以看到，type 是可以来创建一个类的</p>
<div><p>什么是元类</p>
<ul>
<li>
<p>创建类的就叫<strong>元类</strong></p>
</li>
<li>
<p>type 就是一个内置的元类</p>
</li>
</ul>
</div>
<h2 id="为什么要使用元类"> 为什么要使用元类</h2>
<p>作用：指定类由谁创建</p>
<h2 id="如何自定义元类创建类"> 如何自定义元类创建类</h2>
<p>既然类默认是由 type 创建的，那我们是否可以自定义一个元类来创建类？</p>
<p>例如：</p>
<p>新建 MyType 元类，继承于 type</p>
<div><pre><code><span>class</span> <span>MyType</span><span>(</span><span>type</span><span>)</span><span>:</span>
    <span>def</span> <span>__new__</span><span>(</span>cls<span>,</span> <span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"__new__"</span><span>)</span>
        new_cls <span>=</span> <span>super</span><span>(</span><span>)</span><span>.</span>__new__<span>(</span>cls<span>,</span> <span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span>
        <span>print</span><span>(</span>new_cls<span>)</span>
        <span>return</span> new_cls

    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'__init__'</span><span>)</span>
        <span>super</span><span>(</span><span>)</span><span>.</span>__init__<span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>使用 MyType 创建 Foo 类</p>
<div><pre><code><span>class</span> <span>Foo</span><span>(</span>metaclass<span>=</span>MyType<span>)</span><span>:</span>
    <span>pass</span>

<span>print</span><span>(</span>Foo<span>)</span>

结果：
<span>&lt;</span><span>class</span> <span>'__main__.Foo'</span><span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><div><p>理解上述代码</p>
<ul>
<li>Python 中一切皆为对象，类也是对象</li>
<li>Foo 由 MyType 创建，而 MyType 是一个类，可以理解创建 Foo 类即为创建 MyType 的一个实例对象</li>
<li>MyType 既然为类，在创建对象时，就会先执行 <code>__new__</code> 函数创建一个对象，然后再执行 <code>__init__</code> 进行初始化</li>
</ul>
</div>
<p>理解了上面的代码，再来思考下，那如何实例化元类创建的类呢？</p>
<ul>
<li>Foo 是由 MyType 创建的一个类，既然是类，那就可以创建实例对象</li>
<li>但上述的理解，Foo 是 MyType 的实例对象，那执行 Foo() 时，实际上是在实例对象后加上 ()</li>
<li>在 Python 中，如果在实例对象后添上 () 时，需要执行类中的 <code>__call__</code> 函数</li>
<li>由此就需要在 MyType 中实现 <code>__call__</code> 函数</li>
<li>在类实例化时，需要执行 <code>__new__</code> 和 <code>__init__</code>，因此需要在 <code>__call__</code> 函数中实现这两个方法</li>
</ul>
<div><pre><code><span>class</span> <span>MyType</span><span>(</span><span>type</span><span>)</span><span>:</span>
    <span>def</span> <span>__new__</span><span>(</span>cls<span>,</span> <span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span>
        <span># print("__new__")</span>
        new_cls <span>=</span> <span>super</span><span>(</span><span>)</span><span>.</span>__new__<span>(</span>cls<span>,</span> <span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span>
        <span># print(new_cls)</span>
        <span>return</span> new_cls

    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span>
        <span># print('__init__')</span>
        <span>super</span><span>(</span><span>)</span><span>.</span>__init__<span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span>

    <span>def</span> <span>__call__</span><span>(</span>self<span>,</span> <span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span>
        empty_object <span>=</span> self<span>.</span>__new__<span>(</span>self<span>)</span>
        self<span>.</span>__init__<span>(</span>empty_object<span>,</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span>
        <span>return</span> empty_object

<span>class</span> <span>Foo</span><span>(</span>metaclass<span>=</span>MyType<span>)</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span>name<span>)</span><span>:</span>
        self<span>.</span>name <span>=</span> name

v1 <span>=</span> Foo<span>(</span><span>"ALEX"</span><span>)</span>
<span>print</span><span>(</span>v1<span>.</span>name<span>)</span>

结果：
ALEX
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T06:24:56.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Redis</title>
    <id>https://www.snowji.cn/databases/redis/redis-basic/</id>
    <link href="https://www.snowji.cn/databases/redis/redis-basic/"/>
    <updated>2022-08-26T07:58:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="redis"> Redis</h1>
<h2 id="redis-是什么"> Redis 是什么</h2>
<p>Redis（Remote Dictionary Server )：远程字典服务</p>
<ul>
<li>一个开源的使用 ANSI</li>
<li>C 语言编写、支持网络、可基于内存亦可持久化的日志型、<strong>Key-Value 数据库</strong></li>
<li>提供多种语言的 API</li>
<li>为了提高效率，<strong>数据都是缓存在内存中</strong></li>
<li>周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件</li>
<li>实现了 master-slave(主从)同步</li>
<li><strong>Redis 是单线程的，Redis 是基于内存操作的</strong></li>
<li>Redis 的性能瓶颈不是 CPU，而是机器内存和网络带宽</li>
</ul>
<h3 id="为什么-redis-单线程还这么快"> 为什么 Redis 单线程还这么快？</h3>
<ul>
<li>Redis 是将所有的数据放在内存中的，使用单线程去操作效率就是最高的，多线程（CPU 上下文会切换：耗时的操作！）</li>
<li>对于内存系统来说，如果没有上下文切换效率就是最高的，多次读写都是在一个 CPU 上的，在内存存储数据情况下，单线程就是最佳的方案</li>
</ul>
<h2 id="redis-的作用"> Redis 的作用</h2>
<h3 id="作用"> 作用</h3>
<ul>
<li>
<p>内存存储、持久化，内存是断电即失的，所以需要持久化（RDB、AOF）</p>
</li>
<li>
<p>高效率、用于高速缓冲</p>
</li>
<li>
<p>发布订阅系统</p>
</li>
<li>
<p>地图信息分析</p>
</li>
<li>
<p>计时器、计数器(eg：浏览量)</p>
</li>
<li></li>
</ul>
<h3 id="特性"> 特性</h3>
<ul>
<li>多样的数据类型</li>
<li>持久化</li>
<li>集群</li>
<li>事务</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-26T07:58:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">多线程</title>
    <id>https://www.snowji.cn/languages/python/basics/multi-threading/</id>
    <link href="https://www.snowji.cn/languages/python/basics/multi-threading/"/>
    <updated>2022-09-02T06:24:56.000Z</updated>
    <content type="html"><![CDATA[<h1 id="多线程"> 多线程</h1>
<p>之前了解了进程，接下来了解下线程</p>
<h2 id="什么是线程"> 什么是线程</h2>
<ul>
<li>是计算机中可以被 CPU 调度的最小单元</li>
<li>一个进程可以有多个线程</li>
<li>多线程可以共享进程的资源</li>
</ul>
<p>类比：</p>
<ul>
<li>一个工厂，至少有一个车间，一个车间至少有一个工人，最终是工人在工作</li>
<li>一个程序，至少有一个进程，一个进程中至少有一个线程，最终是线程在工作</li>
</ul>
<h2 id="为什么需要多线程"> 为什么需要多线程</h2>
<p>提高代码执行效率</p>
<h2 id="如何创建多线程"> 如何创建多线程</h2>
<p>有两种方式来创建线程：</p>
<ul>
<li>一种是继承 Thread 类，并重写它的 run() 方法</li>
<li>另一种是在实例化 <code>threading.Thread</code> 对象的时候，将线程要执行的任务函数作为参数传入线程</li>
</ul>
<h3 id="方式一-继承-thread-类"> 方式一：继承 Thread 类</h3>
<div><pre><code><span>import</span> threading

<span>class</span> <span>MyThread</span><span>(</span>threading<span>.</span>Thread<span>)</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> thread_name<span>)</span><span>:</span>
        <span># 注意：一定要显式的调用父类的初始化函数。</span>
        <span>super</span><span>(</span>MyThread<span>,</span> self<span>)</span><span>.</span>__init__<span>(</span>name<span>=</span>thread_name<span>)</span>

    <span>def</span> <span>run</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"%s正在运行中......"</span> <span>%</span> self<span>.</span>name<span>)</span>

<span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>    
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>10</span><span>)</span><span>:</span>
        MyThread<span>(</span><span>"thread-"</span> <span>+</span> <span>str</span><span>(</span>i<span>)</span><span>)</span><span>.</span>start<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="方式二-实例化-threading-thread-对象"> 方式二：实例化 <code>threading.Thread</code> 对象</h3>
<div><pre><code><span>import</span> threading
<span>import</span> time

<span>def</span> <span>show</span><span>(</span>arg<span>)</span><span>:</span>
    time<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
    <span>print</span><span>(</span><span>'thread '</span><span>+</span><span>str</span><span>(</span>arg<span>)</span><span>+</span><span>" running...."</span><span>)</span>

<span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>10</span><span>)</span><span>:</span>
        t <span>=</span> threading<span>.</span>Thread<span>(</span>target<span>=</span>show<span>,</span> args<span>=</span><span>(</span>i<span>,</span><span>)</span><span>)</span>
        t<span>.</span>start<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="thread-源码"> Thread 源码</h3>
<p>我们来看下 Thread 这个类的源码：</p>
<div><pre><code><span>def</span> <span>__init__</span><span>(</span>self<span>,</span> group<span>=</span><span>None</span><span>,</span> target<span>=</span><span>None</span><span>,</span> name<span>=</span><span>None</span><span>,</span>
                 args<span>=</span><span>(</span><span>)</span><span>,</span> kwargs<span>=</span><span>None</span><span>,</span> <span>*</span><span>,</span> daemon<span>=</span><span>None</span><span>)</span><span>:</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>参数说明</strong>：</p>
<ul>
<li>group：是预留的，用于将来扩展</li>
<li>target：是一个可调用对象，在线程启动后执行</li>
<li>name：是线程的名字，默认值为 “Thread-N“，N 是一个数字</li>
<li>args 和 kwargs：分别表示调用 target 时的参数列表和关键字参数</li>
</ul>
<p>Thread 类定义了以下常用方法与属性：</p>
<table>
<thead>
<tr>
<th>方法与属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>start()</td>
<td>启动线程，等待 CPU 调度</td>
</tr>
<tr>
<td>run()</td>
<td>线程被 CPU 调度后自动执行的方法</td>
</tr>
<tr>
<td>getName()、setName() 和name</td>
<td>用于获取和设置线程的名称</td>
</tr>
<tr>
<td>setDaemon()</td>
<td>设置为后台线程或前台线程（默认是False，前台线程）<br />如果是后台线程，主线程执行过程中，后台线程也在进行，主线程执行完毕后，后台线程不论成功与否，均停止<br />如果是前台线程，主线程执行过程中，前台线程也在进行，主线程执行完毕后，等待前台线程执行完成后，程序才停止</td>
</tr>
<tr>
<td>ident</td>
<td>获取线程的标识符<br />线程标识符是一个非零整数，只有在调用了 start() 方法之后该属性才有效，否则它只返回None</td>
</tr>
<tr>
<td>is_alive()</td>
<td>判断线程是否是激活的（alive）<br />从调用 start() 方法启动线程，到 run() 方法执行完毕或遇到未处理异常而中断这段时间内，线程是激活的</td>
</tr>
<tr>
<td>isDaemon() 方法和 daemon属性</td>
<td>是否为守护线程</td>
</tr>
<tr>
<td>join([timeout])</td>
<td>调用该方法将会使主调线程堵塞，直到被调用线程运行结束或超时<br />参数 timeout 是一个数值类型，表示超时时间，如果未提供该参数，那么主调线程将一直堵塞到被调线程结束</td>
</tr>
</tbody>
</table>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T06:24:56.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">规范</title>
    <id>https://www.snowji.cn/languages/python/basics/naming-notations/</id>
    <link href="https://www.snowji.cn/languages/python/basics/naming-notations/"/>
    <updated>2022-09-02T06:24:56.000Z</updated>
    <content type="html"><![CDATA[<h1 id="规范"> 规范</h1>
<h2 id="命名规范"> 命名规范</h2>
<ul>
<li>
<p>变量命名</p>
<p>第一个字符必须是字母或 _ 开头</p>
<p><strong>变量名可以为中文：</strong></p>
<div><pre><code>&gt;&gt;&gt; 什么 = &quot;apple&quot;
&gt;&gt;&gt; print(什么)
apple
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>特殊性:</strong></p>
<ul>
<li>
<p>以 _（单下划线）开头</p>
<p>表示禁止外部访问的类成员，需要通过类提供接口访问</p>
<p>不能用 from xxx import * 导入</p>
</li>
<li>
<p>以 __（双下划线）开头</p>
<p>代表类的私有成员</p>
</li>
<li>
<p>以 __（双下划线）开头和结尾</p>
<p>是 python 里特殊方法专用的标识</p>
</li>
<li>
<p>区分大小写</p>
</li>
</ul>
</li>
<li>
<p>函数命名</p>
<p>小写加上下划线： total_number</p>
</li>
<li>
<p>类名</p>
<p>使用大驼峰： ThreadMixIn</p>
</li>
<li>
<p>模块和包</p>
<p>使用小写</p>
</li>
</ul>
<h2 id="注释"> 注释</h2>
<ul>
<li>
<p>单行注释</p>
<p>开头使用 #</p>
</li>
<li>
<p>多行注释</p>
<p>没有真正意义上的只是在每行开头写上 #</p>
</li>
<li>
<p>注释文档</p>
<div><pre><code> &quot;&quot;&quot;
    这个是函数的说明文档。
    :param a: 加数
    :param b: 加数
    :return: 和
 &quot;&quot;&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T06:24:56.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">更改默认 pip 下载源</title>
    <id>https://www.snowji.cn/languages/python/basics/pip-download-source/</id>
    <link href="https://www.snowji.cn/languages/python/basics/pip-download-source/"/>
    <updated>2022-09-03T14:10:02.000Z</updated>
    <content type="html"><![CDATA[<h1 id="更改默认-pip-下载源"> 更改默认 pip 下载源</h1>
<h2 id="问题描述"> 问题描述</h2>
<p>一般在命令行中安装 Python 工具包时，大多是从国外源进行下载，导致速度很慢</p>
<h2 id="解决方案"> 解决方案</h2>
<div><p>常用 pip 源</p>
<p>豆瓣(douban) http://pypi.douban.com/simple/
阿里云 http://mirrors.aliyun.com/pypi/simple/
中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/
清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/
中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/</p>
<p>安装命令：pip install -i https://pypi.douban.com/simple 模块名</p>
</div>
<h3 id="pip-下载时设置下载源"> pip 下载时设置下载源</h3>
<p>比如下载：pytest，设置阿里云的下载源</p>
<div><pre><code>pip install -i http://mirrors.aliyun.com/pypi/simple/ selenium
</code></pre>
<div><span>1</span><br></div></div><h3 id="设置默认安装源"> 设置默认安装源</h3>
<h4 id="windows"> windows</h4>
<h5 id="方式一"> 方式一：</h5>
<p>使用命令行，输入：</p>
<div><pre><code>pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple
</code></pre>
<div><span>1</span><br></div></div><p>运行后可以在 C:\Users\电脑用户\AppData\Roaming\pip 文件夹中自动生成 pip.ini 文件</p>
<p><img src="./../images/pip1.png" alt="pip" /></p>
<h5 id="方式二"> 方式二：</h5>
<ul>
<li>进入 C:\Users\电脑用户\AppData\Roaming</li>
<li>新建 pip 文件夹并在文件夹中新建 pip.ini 配置文件</li>
<li>新增 pip.ini 配置文件内容</li>
</ul>
<div><pre><code>[global]
index-url = https://pypi.tuna.tsinghua.edu.cn/simple
[install]
use-mirrors = true
mirrors = http:https://pypi.tuna.tsinghua.edu.cn/simple
trusted-host = pypi.tuna.tsinghua.edu.cn
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id="linux"> Linux</h4>
<ul>
<li>
<p>在用户根目录下 ~ 下创建 .pip 隐藏文件夹，如果已经有了可以跳过</p>
<div><pre><code>mkdir ~/.pip
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>进入 .pip 隐藏文件夹并创建 pip.conf 配置文件</p>
<div><pre><code>cd ~/.pip &amp;&amp; touch pip.conf 
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>启动 Finder 按 <code>cmd+shift+g</code> 进入，输入 <code>~/.pip</code>  回车进入</p>
</li>
<li>
<p>新增 <code>pip.conf</code> 配置文件内容</p>
<div><pre><code>[global]
index-url = https://pypi.tuna.tsinghua.edu.cn/simple
[install]
use-mirrors = true
mirrors = http:https://pypi.tuna.tsinghua.edu.cn/simple
trusted-host = pypi.tuna.tsinghua.edu.cn
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T06:24:56.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">property 属性</title>
    <id>https://www.snowji.cn/languages/python/basics/property/</id>
    <link href="https://www.snowji.cn/languages/python/basics/property/"/>
    <updated>2022-09-02T06:24:56.000Z</updated>
    <content type="html"><![CDATA[<h1 id="property-属性"> property 属性</h1>
<h2 id="什么是-property-属性"> 什么是 property 属性</h2>
<p>对象中的某个函数，可以通过 <code>对象.xxxx</code> 的方式调用</p>
<p><strong>作用</strong>：</p>
<ul>
<li>使用 property 来创建只读属性</li>
<li>property 会将方法转换为相同名称的只读属性,可以与所定义的属性配合使用，这样可以防止属性被修改</li>
</ul>
<h2 id="为什么要使用-property-属性"> 为什么要使用 property 属性</h2>
<ul>
<li>调用函数方便</li>
<li>防止属性被随意修改</li>
</ul>
<h2 id="使用方式"> 使用方式</h2>
<h3 id="property-装饰器"> @property 装饰器</h3>
<div><pre><code><span>class</span> <span>Basic</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
        self<span>.</span>__name <span>=</span> <span>"alex"</span>
    <span>@property</span>
    <span>def</span> <span>get_name</span><span>(</span>self<span>)</span><span>:</span>
        <span>return</span> self<span>.</span>__name

    <span>@get_name<span>.</span>setter</span>
    <span>def</span> <span>get_name</span><span>(</span>self<span>,</span>value<span>)</span><span>:</span>
        self<span>.</span>__name <span>=</span> value

<span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>
    b <span>=</span> Basic<span>(</span><span>)</span>
    <span>print</span><span>(</span>b<span>.</span>get_name<span>)</span>
    b<span>.</span>get_name <span>=</span> <span>"hello"</span>
    <span>print</span><span>(</span>b<span>.</span>get_name<span>)</span>
    
    
结果：
alex
hello
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><div><p>注意</p>
<ul>
<li><code>@get_name.setter</code> 只能在新式类(Python 3)中使用</li>
<li>新式类中设置 <code>property</code> 属性的值，必须使用 <code>@get_name.setter</code> 修饰</li>
<li><code>@property</code> 与 <code>@get_name.setter</code> 修饰的函数名必须相同</li>
<li><code>@property</code> 修饰的函数必须在 <code>@get_name.setter</code> 修饰的函数前</li>
</ul>
</div>
<h3 id="property-函数"> property() 函数</h3>
<div><pre><code><span>class</span> <span>Pepole</span><span>:</span>

    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
        self<span>.</span>age <span>=</span> <span>18</span>

    <span>def</span> <span>set_setter</span><span>(</span>self<span>,</span>value<span>)</span><span>:</span>
        <span>if</span> value <span>></span> <span>100</span><span>:</span>
            <span>raise</span> ValueError
        <span>if</span> value <span>&lt;=</span> <span>0</span><span>:</span>
            <span>raise</span> ValueError
        self<span>.</span>age <span>=</span> value

    <span>def</span> <span>get_setter</span><span>(</span>self<span>)</span><span>:</span>
        <span>return</span> self<span>.</span>age

    BAP <span>=</span> <span>property</span><span>(</span>get_setter<span>,</span>set_setter<span>)</span>

<span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>
    B <span>=</span> Pepole<span>(</span><span>)</span>
    <span>print</span><span>(</span>B<span>.</span>BAP<span>)</span>
    B<span>.</span>set_setter<span>(</span><span>80</span><span>)</span>
    <span>print</span><span>(</span>B<span>.</span>BAP<span>)</span>

结果：
<span>18</span>
<span>80</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><div><p>注意</p>
<p><code>property()</code> 函数中的参数分别是：</p>
<ul>
<li>
<p>第一个参数是方法名，调用 实例.属性 时自动执行的方法</p>
</li>
<li>
<p>第二个参数是方法名，调用 实例.属性 ＝ XXX 时自动执行的方法</p>
</li>
<li>
<p>第三个参数是方法名，调用 del 实例.属性 时自动执行的方法</p>
</li>
<li>
<p>第四个参数是字符串，调用 实例.属性 <code>.__doc__</code> 时的描述信息</p>
</li>
</ul>
</div>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T06:24:56.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">pip 安装和应用</title>
    <id>https://www.snowji.cn/languages/python/basics/pip-install/</id>
    <link href="https://www.snowji.cn/languages/python/basics/pip-install/"/>
    <updated>2022-09-02T06:24:56.000Z</updated>
    <content type="html"><![CDATA[<h1 id="pip-安装和应用"> pip 安装和应用</h1>
<h2 id="pip-安装"> pip 安装</h2>
<ul>
<li>
<p>easy_install 安装</p>
<p>进入 easy_install 脚本的目录下，运行 easy_install pip</p>
</li>
<li>
<p>get-pip.py 安装</p>
<ul>
<li>下载：curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py</li>
<li>运行 python get_pip.py</li>
<li>同时安装 setuptools 和 wheel 工具</li>
</ul>
</li>
<li>
<p>Linux 下安装</p>
<ul>
<li>ubuntu：sudo apt-get install python-pip</li>
<li>sudo yum install python-pip</li>
</ul>
</li>
<li>
<p>Windows 下安装</p>
<p>python 目录下 scripts 下运行  easy_install pip</p>
</li>
</ul>
<h2 id="pip-更新"> pip 更新</h2>
<ul>
<li>
<p>Linux 或 mac：</p>
<p>pip install -U pip</p>
</li>
<li>
<p>windows：</p>
<p>python -m pip install -U pip</p>
</li>
</ul>
<h2 id="pip-应用"> pip 应用</h2>
<ul>
<li>
<p>安装库为最新版本</p>
<div><pre><code>pip install pillow
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>安装指定版本</p>
<p>使用 ==, &gt;=, &lt;=, &gt;, &lt; 指定一个版本号</p>
<div><pre><code>pip install  Markdown<span>&lt;</span><span>2.0</span> 
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>卸载已安装的库</p>
<div><pre><code>pip uninstall pillow
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>将已安装的库保存到文件中</p>
<div><pre><code>pip freeze <span>></span> requirements<span>.</span>txt
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>根据 requirements 进行安装</p>
<div><pre><code>pip install <span>-</span>r requirements<span>.</span>txt
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>列出已安装的库</p>
<div><pre><code>pip <span>list</span>
</code></pre>
<div><span>1</span><br></div></div></li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T06:24:56.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">单实例模式</title>
    <id>https://www.snowji.cn/languages/python/basics/single-instance/</id>
    <link href="https://www.snowji.cn/languages/python/basics/single-instance/"/>
    <updated>2022-09-02T06:24:56.000Z</updated>
    <content type="html"><![CDATA[<h1 id="单实例模式"> 单实例模式</h1>
<h2 id="什么是单实例模式"> 什么是单实例模式</h2>
<p><strong>概念</strong>：</p>
<ul>
<li>一种常用的软件设计模式</li>
<li>主要是确保一个类只有一个实例存在</li>
</ul>
<p>例如：</p>
<div><pre><code><span>class</span> <span>A</span><span>:</span>
    <span>pass</span>

a1 <span>=</span> A<span>(</span><span>)</span>
a2 <span>=</span> A<span>(</span><span>)</span>
a3 <span>=</span> A<span>(</span><span>)</span>
<span>print</span><span>(</span><span>id</span><span>(</span>a1<span>)</span><span>)</span>
<span>print</span><span>(</span><span>id</span><span>(</span>a2<span>)</span><span>)</span>
<span>print</span><span>(</span><span>id</span><span>(</span>a3<span>)</span><span>)</span>

结果：
<span>2800308103648</span>
<span>2800308103456</span>
<span>2800308103552</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>上述代码中，实例化了 3次 A 这个对象，每个实例的地址不同，显然这不是单实例模式</p>
<h2 id="为什么要使用单例模式"> 为什么要使用单例模式</h2>
<p><strong>举个例子</strong>：</p>
<ul>
<li>某个服务器程序的配置信息存放在一个文件中，客户端通过一个 AppConfig 的类来读取配置文件的信息</li>
<li>在程序运行期间，有很多地方都需要使用配置文件的内容，很多地方都需要创建 AppConfig 对象的实例，这就导致系统中存在多个 AppConfig 的实例对象，而这样会严重浪费内存资源，尤其是在配置文件内容很多的情况下</li>
<li>类似 AppConfig 这样的类，我们希望在程序运行期间只存在一个实例对象</li>
</ul>
<p><strong>作用</strong>：防止一个全局使用的类频繁地创建与销毁</p>
<h2 id="如何实现单实例模式"> 如何实现单实例模式</h2>
<h3 id="方式一-将实例赋值给变量"> 方式一：将实例赋值给变量</h3>
<p>这是最简单实现单实例的方式</p>
<p>修改下上面的代码：</p>
<div><pre><code><span>class</span> <span>A</span><span>:</span>
    <span>pass</span>

a <span>=</span> A<span>(</span><span>)</span>

a1 <span>=</span> a
a2 <span>=</span> a
a3 <span>=</span> a
<span>print</span><span>(</span><span>id</span><span>(</span>a1<span>)</span><span>)</span>
<span>print</span><span>(</span><span>id</span><span>(</span>a2<span>)</span><span>)</span>
<span>print</span><span>(</span><span>id</span><span>(</span>a3<span>)</span><span>)</span>

结果：
<span>1546662907040</span>
<span>1546662907040</span>
<span>1546662907040</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>结果发现 3 个实例的地址相同</p>
<h3 id="方式二-通过类的-new-方法"> 方式二：通过类的 <code>__new__</code> 方法</h3>
<p>这种方式比较常用，实现很方便，推荐使用</p>
<div><p>原理</p>
<ul>
<li>类在实例化时，会先调用 <code>__new__</code> 方法创建实例，然后对实例进行 <code>__init__</code> 初始化</li>
<li>如果类没有指定 <code>__new__</code> 方法，就会调用 Object 的</li>
<li>通过重写 <code>__new__</code> 方法，判断是否有实例存在，没有则创建，有则返回实例对象，从而实现单例模式</li>
<li><code>__new__</code> 方法是个类方法</li>
</ul>
</div>
<div><pre><code><span>class</span> <span>A</span><span>:</span>
    <span>def</span> <span>__new__</span><span>(</span>cls<span>,</span> <span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'__new__ is call'</span><span>)</span>
        <span>if</span> <span>not</span> <span>hasattr</span><span>(</span>cls<span>,</span><span>"_instance"</span><span>)</span><span>:</span>
            cls<span>.</span>_instance <span>=</span> <span>super</span><span>(</span><span>)</span><span>.</span>__new__<span>(</span>cls<span>)</span>
        <span>return</span> cls<span>.</span>_instance

    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'__init__ is call'</span><span>)</span>

a1 <span>=</span> A<span>(</span><span>)</span>
a2 <span>=</span> A<span>(</span><span>)</span>
a3 <span>=</span> A<span>(</span><span>)</span>
<span>print</span><span>(</span><span>id</span><span>(</span>a1<span>)</span><span>)</span>
<span>print</span><span>(</span><span>id</span><span>(</span>a2<span>)</span><span>)</span>
<span>print</span><span>(</span><span>id</span><span>(</span>a3<span>)</span><span>)</span>

结果：
__new__ <span>is</span> call
__init__ <span>is</span> call
__new__ <span>is</span> call
__init__ <span>is</span> call
__new__ <span>is</span> call
__init__ <span>is</span> call
<span>1772512061104</span>
<span>1772512061104</span>
<span>1772512061104</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>结果可以看出实例对象地址相同</p>
<h3 id="方式三-使用装饰器实现"> 方式三：使用装饰器实现</h3>
<p>此方式需要了解装饰器的一些知识，可参考 <a href="/languages/python/python/装饰器.html">装饰器</a></p>
<div><pre><code><span>def</span> <span>singleton</span><span>(</span>cls<span>)</span><span>:</span>
    _instance <span>=</span> <span>{</span><span>}</span>

    <span>def</span> <span>inner</span><span>(</span><span>)</span><span>:</span>
        <span>if</span> cls <span>not</span> <span>in</span> _instance<span>:</span>
            _instance<span>[</span>cls<span>]</span> <span>=</span> cls<span>(</span><span>)</span>
        <span>return</span> _instance<span>[</span>cls<span>]</span>
    <span>return</span> inner
    
<span>@singleton</span>
<span>class</span> <span>Cls</span><span>(</span><span>object</span><span>)</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
        <span>pass</span>

cls1 <span>=</span> Cls<span>(</span><span>)</span>
cls2 <span>=</span> Cls<span>(</span><span>)</span>
<span>print</span><span>(</span><span>id</span><span>(</span>cls1<span>)</span><span>)</span>
<span>print</span><span>(</span><span>id</span><span>(</span>cls2<span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>结果：</p>
<div><pre><code><span>2323106588384</span>
<span>2323106588384</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="方式四-使用元类实现"> 方式四：使用元类实现</h3>
<p>此方式需要了解元类的一些知识，可参考 <a href="/languages/python/python/metaclass">元类</a></p>
<div><pre><code><span>class</span> <span>MyType</span><span>(</span><span>type</span><span>)</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span>name<span>,</span>base<span>,</span>attrs<span>)</span><span>:</span>
        self<span>.</span>instance <span>=</span> <span>None</span>
        <span>super</span><span>(</span><span>)</span><span>.</span>__init__<span>(</span>name<span>,</span>base<span>,</span>attrs<span>)</span>

    <span>def</span> <span>__call__</span><span>(</span>self<span>,</span> <span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span>
        <span># 判断是否有 instance</span>
        <span>if</span> <span>not</span> self<span>.</span>instance<span>:</span>
            self<span>.</span>instance <span>=</span> self<span>.</span>__new__<span>(</span>self<span>)</span>
        self<span>.</span>__init__<span>(</span>self<span>.</span>instance<span>,</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span>
        <span>return</span> self<span>.</span>instance

<span>class</span> <span>Foo</span><span>(</span>metaclass<span>=</span>MyType<span>)</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
        <span>pass</span>

v1 <span>=</span> Foo<span>(</span><span>)</span>
v2 <span>=</span> Foo<span>(</span><span>)</span>

<span>print</span><span>(</span>v1<span>)</span>
<span>print</span><span>(</span>v2<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>结果：</p>
<div><pre><code><span>&lt;</span>__main__<span>.</span>Foo <span>object</span> at <span>0x0000015BB8167DF0</span><span>></span>
<span>&lt;</span>__main__<span>.</span>Foo <span>object</span> at <span>0x0000015BB8167DF0</span><span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T06:24:56.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">sort 与 sorted</title>
    <id>https://www.snowji.cn/languages/python/basics/sort-sorted/</id>
    <link href="https://www.snowji.cn/languages/python/basics/sort-sorted/"/>
    <updated>2022-09-17T13:32:24.000Z</updated>
    <content type="html"><![CDATA[<h1 id="sort-与-sorted"> sort 与 sorted</h1>
<h2 id="sort"> sort</h2>
<p><code>sort()</code> 是 Python 中列表的方法</p>
<p><strong>语法</strong>：</p>
<div><pre><code><span>list</span><span>.</span>sort<span>(</span>key<span>=</span><span>None</span><span>,</span> reverse<span>=</span><span>False</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>key</td>
<td>按指定值进行排序</td>
</tr>
<tr>
<td>reverse</td>
<td>排序方式：<br />Ture：倒序<br />False（默认）：升序</td>
</tr>
</tbody>
</table>
<div><pre><code>a <span>=</span> <span>[</span><span>1</span><span>,</span> <span>6</span><span>,</span> <span>8</span><span>,</span> <span>11</span><span>,</span> <span>9</span><span>,</span> <span>1</span><span>,</span> <span>8</span><span>,</span> <span>6</span><span>,</span> <span>8</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>]</span>
b <span>=</span> a<span>.</span>sort<span>(</span>reverse<span>=</span><span>False</span><span>)</span>
<span>print</span><span>(</span>a<span>)</span>
<span>print</span><span>(</span>b<span>)</span>

结果：
<span>[</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>6</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>8</span><span>,</span> <span>8</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>,</span> <span>11</span><span>]</span>
<span>None</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>从上面的结果中发现：</p>
<ul>
<li>原列表 a 发生了变化</li>
<li><code>a.sort(reverse=False)</code>无返回值</li>
</ul>
<h2 id="sorted"> sorted</h2>
<p><code>sorted()</code> 是 Python 的内置函数</p>
<p><strong>语法</strong>：</p>
<div><pre><code><span>sorted</span><span>(</span>iterable<span>=</span><span>None</span><span>,</span> key<span>=</span><span>None</span><span>,</span> reverse<span>=</span><span>False</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>iterable</td>
<td>需要排序的可迭代对象</td>
</tr>
<tr>
<td>key</td>
<td>按指定值进行排序</td>
</tr>
<tr>
<td>reverse</td>
<td>排序方式：<br />Ture：倒序<br />False（默认）：升序</td>
</tr>
</tbody>
</table>
<div><pre><code>a <span>=</span> <span>[</span><span>1</span><span>,</span> <span>6</span><span>,</span> <span>8</span><span>,</span> <span>11</span><span>,</span> <span>9</span><span>,</span> <span>1</span><span>,</span> <span>8</span><span>,</span> <span>6</span><span>,</span> <span>8</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>]</span>
b <span>=</span> <span>sorted</span><span>(</span>a<span>)</span>
<span>print</span><span>(</span>a<span>)</span>
<span>print</span><span>(</span>b<span>)</span>

结果：
<span>[</span><span>1</span><span>,</span> <span>6</span><span>,</span> <span>8</span><span>,</span> <span>11</span><span>,</span> <span>9</span><span>,</span> <span>1</span><span>,</span> <span>8</span><span>,</span> <span>6</span><span>,</span> <span>8</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>]</span>
<span>[</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>6</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>8</span><span>,</span> <span>8</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>,</span> <span>11</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>从上面的结果中发现：</p>
<ul>
<li>原列表 a 没有发生变化</li>
<li><code>sorted(a)</code>返回一个新列表</li>
</ul>
<div><p>总结</p>
<ul>
<li><code>sort()</code> 无返回值，会直接修改原列表</li>
<li><code>sorted()</code> 会返回一个新的列表</li>
</ul>
</div>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-16T03:08:39.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">异常处理</title>
    <id>https://www.snowji.cn/languages/python/basics/try-except-finally/</id>
    <link href="https://www.snowji.cn/languages/python/basics/try-except-finally/"/>
    <updated>2022-09-02T06:24:56.000Z</updated>
    <content type="html"><![CDATA[<h1 id="异常处理"> 异常处理</h1>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T06:24:56.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">作用域</title>
    <id>https://www.snowji.cn/languages/python/basics/variable-scope/</id>
    <link href="https://www.snowji.cn/languages/python/basics/variable-scope/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="作用域"> 作用域</h1>
<p><strong>定义</strong>：作用域指的是变量的有效范围</p>
<p><strong>注意</strong>：Python 中没有块级作用域</p>
<div><pre><code><span>>></span><span>></span> <span>if</span> <span>True</span><span>:</span>            <span># if语句块没有作用域</span>
    x <span>=</span> <span>1</span>   
<span>>></span><span>></span> x
<span>1</span>
<span>>></span><span>></span> <span>def</span> <span>func</span><span>(</span><span>)</span><span>:</span>         <span># 函数有作用域</span>
    a <span>=</span> <span>8</span>   
<span>>></span><span>></span> a
Traceback <span>(</span>most recent call last<span>)</span><span>:</span>
  File <span>"&lt;pyshell#3>"</span><span>,</span> line <span>1</span><span>,</span> <span>in</span> <span>&lt;</span>module<span>></span>
    a
NameError<span>:</span> name <span>'a'</span> <span>is</span> <span>not</span> defined
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><ul>
<li>if 中的 x 能被外部访问</li>
<li>函数中的 a 不能被外部访问</li>
</ul>
<p><strong>作用域层：</strong></p>
<ul>
<li>局部作用域（local）</li>
<li>闭包函数外的函数中（enclosing）</li>
<li>全局作用域（global）</li>
<li>内建作用域（built-in）</li>
</ul>
<div><pre><code>x <span>=</span> <span>int</span><span>(</span><span>2.9</span><span>)</span>  <span># 内建作用域，查找int函数</span>

global_var <span>=</span> <span>0</span>  <span># 全局作用域</span>
<span>def</span> <span>outer</span><span>(</span><span>)</span><span>:</span>
    out_var <span>=</span> <span>1</span>  <span># 闭包函数外的函数中</span>
    <span>def</span> <span>inner</span><span>(</span><span>)</span><span>:</span>
        inner_var <span>=</span> <span>2</span>  <span># 局部作用域</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>查找变量的顺序：<strong><code>L –&gt; E –&gt; G –&gt;B</code></strong></p>
<div><pre><code>a <span>=</span> <span>1</span>

<span>def</span> <span>func</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span>a<span>)</span>

<span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>全局变量和局部变量</strong>：</p>
<p><strong>定义</strong>：</p>
<ul>
<li>
<p>函数内部定义的变量有局部作用域，被叫做局部局部变量，函数外的叫全局变量</p>
</li>
<li>
<p>局部变量是相对的，也可能是更小范围的全局变量</p>
</li>
<li>
<p>局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问</p>
</li>
</ul>
<div><pre><code>a <span>=</span> <span>1</span>               <span># 全局变量</span>

<span>def</span> <span>func</span><span>(</span><span>)</span><span>:</span>
    b <span>=</span> <span>2</span>           <span># 局部变量</span>
    <span>print</span><span>(</span>a<span>)</span>        <span># 可访问全局变量a,无法访问它内部的c</span>

    <span>def</span> <span>inner</span><span>(</span><span>)</span><span>:</span>
        c <span>=</span> <span>3</span>       <span># 更局部的变量</span>
        <span>print</span><span>(</span>a<span>)</span>    <span># 可以访问全局变量a</span>
        <span>print</span><span>(</span>b<span>)</span>    <span># b对于inner函数来说，就是外部变量</span>
        <span>print</span><span>(</span>c<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><strong>global 和 nonlocal 关键字</strong>：</p>
<ul>
<li>
<p>global</p>
<p>看个例子：</p>
<div><pre><code>total <span>=</span> <span>0</span>                        <span># total是一个全局变量</span>

<span>def</span> <span>plus</span><span>(</span> arg1<span>,</span> arg2 <span>)</span><span>:</span>
    total <span>=</span> arg1 <span>+</span> arg2          <span># total在这里是局部变量.</span>
    <span>print</span><span>(</span><span>"函数内局部变量total=  "</span><span>,</span> total<span>)</span>
    <span>print</span><span>(</span><span>"函数内的total的内存地址是: "</span><span>,</span> <span>id</span><span>(</span>total<span>)</span><span>)</span>
    <span>return</span> total

plus<span>(</span><span>10</span><span>,</span> <span>20</span><span>)</span>
<span>print</span><span>(</span><span>"函数外部全局变量total= "</span><span>,</span> total<span>)</span>
<span>print</span><span>(</span><span>"函数外的total的内存地址是: "</span><span>,</span> <span>id</span><span>(</span>total<span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面例子中两个 total 是不一样的，但想在函数内部访问全局变量中的 total ，使用关键字：global</p>
<div><pre><code>total <span>=</span> <span>0</span>                        <span># total是一个全局变量</span>

<span>def</span> <span>plus</span><span>(</span> arg1<span>,</span> arg2 <span>)</span><span>:</span>
    <span>global</span> total    <span># 使用global关键字申明此处的total引用外部的total</span>
    total <span>=</span> arg1 <span>+</span> arg2          
    <span>print</span><span>(</span><span>"函数内局部变量total=  "</span><span>,</span> total<span>)</span>
    <span>print</span><span>(</span><span>"函数内的total的内存地址是: "</span><span>,</span> <span>id</span><span>(</span>total<span>)</span><span>)</span>
    <span>return</span> total

plus<span>(</span><span>10</span><span>,</span> <span>20</span><span>)</span>
<span>print</span><span>(</span><span>"函数外部全局变量total= "</span><span>,</span> total<span>)</span>
<span>print</span><span>(</span><span>"函数外的total的内存地址是: "</span><span>,</span> <span>id</span><span>(</span>total<span>)</span><span>)</span>

<span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span>
函数内局部变量total<span>=</span>   <span>30</span>
函数内的total的内存地址是<span>:</span>  <span>503494624</span>
函数外部全局变量total<span>=</span>  <span>30</span>
函数外的total的内存地址是<span>:</span>  <span>503494624</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div></li>
<li>
<p>nonlocal</p>
<p>还是先看个例子：</p>
<div><pre><code>a <span>=</span> <span>1</span>
<span>print</span><span>(</span><span>"函数outer调用之前全局变量a的内存地址："</span><span>,</span> <span>id</span><span>(</span>a<span>)</span><span>)</span>

<span>def</span> <span>outer</span><span>(</span><span>)</span><span>:</span>
    a <span>=</span> <span>2</span>
    <span>print</span><span>(</span><span>"函数outer调用之时闭包外部的变量a的内存地址："</span><span>,</span> <span>id</span><span>(</span>a<span>)</span><span>)</span>
    <span>def</span> <span>inner</span><span>(</span><span>)</span><span>:</span>
        a <span>=</span> <span>3</span>
        <span>print</span><span>(</span><span>"函数inner调用之后闭包内部变量a的内存地址："</span><span>,</span> <span>id</span><span>(</span>a<span>)</span><span>)</span>
    inner<span>(</span><span>)</span>
    <span>print</span><span>(</span><span>"函数inner调用之后，闭包外部的变量a的内存地址："</span><span>,</span> <span>id</span><span>(</span>a<span>)</span><span>)</span>
outer<span>(</span><span>)</span>
<span>print</span><span>(</span><span>"函数outer执行完毕，全局变量a的内存地址："</span><span>,</span> <span>id</span><span>(</span>a<span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>理解了之前的知识，知道这 3 个 a 都是各自的，但想 inner 内想访问 outer 中的 a 咋办？</p>
<p>对于 inner 来说 outer 中的 a 相当于全局变量，使用 global，来试下：</p>
<div><pre><code>a <span>=</span> <span>1</span>
<span>print</span><span>(</span><span>"函数outer调用之前全局变量a的内存地址："</span><span>,</span> <span>id</span><span>(</span>a<span>)</span><span>)</span>
<span>def</span> <span>outer</span><span>(</span><span>)</span><span>:</span>
    a <span>=</span> <span>2</span>
    <span>print</span><span>(</span><span>"函数outer调用之时闭包外部的变量a的内存地址："</span><span>,</span> <span>id</span><span>(</span>a<span>)</span><span>)</span>
    <span>def</span> <span>inner</span><span>(</span><span>)</span><span>:</span>
        <span>global</span> a   <span># 注意这行</span>
        a <span>=</span> <span>3</span>
        <span>print</span><span>(</span><span>"函数inner调用之后闭包内部变量a的内存地址："</span><span>,</span> <span>id</span><span>(</span>a<span>)</span><span>)</span>
    inner<span>(</span><span>)</span>
    <span>print</span><span>(</span><span>"函数inner调用之后，闭包外部的变量a的内存地址："</span><span>,</span> <span>id</span><span>(</span>a<span>)</span><span>)</span>
outer<span>(</span><span>)</span>
<span>print</span><span>(</span><span>"函数outer执行完毕，全局变量a的内存地址："</span><span>,</span> <span>id</span><span>(</span>a<span>)</span><span>)</span>

<span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span>
函数outer调用之前全局变量a的内存地址： <span>494384192</span>
函数outer调用之时闭包外部的变量a的内存地址： <span>494384224</span>
函数inner调用之后闭包内部变量a的内存地址：  <span>494384256</span>
函数inner调用之后，闭包外部的变量a的内存地址：  <span>494384224</span>
函数outer执行完毕，全局变量a的内存地址：  <span>494384256</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>纳尼？竟然用的是全局的 a，只想用个 outer 中的 a ,使用 nonlocal 试试</p>
<div><pre><code>a <span>=</span> <span>1</span>
<span>print</span><span>(</span><span>"函数outer调用之前全局变量a的内存地址： "</span><span>,</span> <span>id</span><span>(</span>a<span>)</span><span>)</span>
<span>def</span> <span>outer</span><span>(</span><span>)</span><span>:</span>
    a <span>=</span> <span>2</span>
    <span>print</span><span>(</span><span>"函数outer调用之时闭包外部的变量a的内存地址： "</span><span>,</span> <span>id</span><span>(</span>a<span>)</span><span>)</span>
    <span>def</span> <span>inner</span><span>(</span><span>)</span><span>:</span>
        <span>nonlocal</span>  a   <span># 注意这行</span>
        a <span>=</span> <span>3</span>
        <span>print</span><span>(</span><span>"函数inner调用之后闭包内部变量a的内存地址： "</span><span>,</span> <span>id</span><span>(</span>a<span>)</span><span>)</span>
    inner<span>(</span><span>)</span>
    <span>print</span><span>(</span><span>"函数inner调用之后，闭包外部的变量a的内存地址： "</span><span>,</span> <span>id</span><span>(</span>a<span>)</span><span>)</span>
outer<span>(</span><span>)</span>
<span>print</span><span>(</span><span>"函数outer执行完毕，全局变量a的内存地址： "</span><span>,</span> <span>id</span><span>(</span>a<span>)</span><span>)</span>

<span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span>
函数outer调用之前全局变量a的内存地址：  <span>497726528</span>
函数outer调用之时闭包外部的变量a的内存地址：  <span>497726560</span>
函数inner调用之后闭包内部变量a的内存地址：  <span>497726592</span>
函数inner调用之后，闭包外部的变量a的内存地址：  <span>497726592</span>
函数outer执行完毕，全局变量a的内存地址：  <span>497726528</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>这下终于好了！</p>
</li>
</ul>
<p><strong>Python 中的一些规则</strong>：</p>
<ul>
<li>
<p>函数内部修改变量时，必须在之前声明了这个变量</p>
<div><pre><code>a <span>=</span> <span>10</span>
<span>def</span> <span>test</span><span>(</span><span>)</span><span>:</span>
    a <span>+=</span> <span>1</span>
    <span>print</span><span>(</span>a<span>)</span>
test<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>你以为的答案：11</p>
<p>实际上的：<strong>报错</strong></p>
<p>纳尼？简直不敢相信</p>
<p><strong>原因</strong>：a +=1 实际上是 a=a+1，python 中规定，修改一个变量之前这个变量必须被声明，例子中没有声明变量就修改，与语法不符，所以报错</p>
</li>
<li>
<p><strong>Python 函数的作用域取决于其函数代码块在整体代码中的位置，而不是调用时机的位置</strong></p>
</li>
</ul>
<div><pre><code>name <span>=</span><span>'jack'</span>

<span>def</span> <span>f1</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span>name<span>)</span>

<span>def</span> <span>f2</span><span>(</span><span>)</span><span>:</span>
    name <span>=</span> <span>'eric'</span>
    f1<span>(</span><span>)</span>

f2<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>你以为的：'eric'</p>
<p>实际上的：'jack'</p>
<p>不玩了不玩了，要疯了，说好的内部没有往外找呢</p>
<p><strong>原因</strong>： f1 是定义在 f2 外部的，对于 f1 来说它的外部就是全局，符合 Python 查找变量的规则</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T06:24:56.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">venv</title>
    <id>https://www.snowji.cn/languages/python/basics/venv/</id>
    <link href="https://www.snowji.cn/languages/python/basics/venv/"/>
    <updated>2022-09-02T06:24:56.000Z</updated>
    <content type="html"><![CDATA[<h1 id="venv"> venv</h1>
<h2 id="什么是-venv"> 什么是 venv</h2>
<ul>
<li>Python 的虚拟环境</li>
<li>相当于是一个独立的容器，可以在该容器中安装需要的依赖包</li>
<li>不同的虚拟环境相互隔离</li>
</ul>
<h2 id="为什么要用-venv"> 为什么要用 venv</h2>
<ul>
<li>在开发 Python 应用程序的时候，系统安装的 Python3 只有一个，所有第三方的包都会被<code>pip</code>安装到 Python3 的<code>site-packages</code>目录下</li>
<li>如果我们同时开发多个应用程序，那这些应用程序都会共用一个Python，就是安装在系统的Python 3，如果应用 A 需要 jinja 2.7，而应用 B 需要 jinja 2.6 怎么办</li>
<li>这种情况下，每个应用可能需要各自拥有一套“独立”的 Python 运行环境</li>
</ul>
<h2 id="如何创建虚拟环境"> 如何创建虚拟环境</h2>
<p>Python 3.3 以后，自带的库</p>
<h3 id="windows-下-venv-的使用"> Windows 下 venv 的使用：</h3>
<p><strong>在指定文件夹新建环境</strong></p>
<div><pre><code>python -m venv [环境名称]
</code></pre>
<div><span>1</span><br></div></div><p><strong>激活环境</strong>
进入创建的环境下的 Script 目录，执行下面的命令</p>
<div><pre><code>activate
或
activate.bat
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>退出环境</strong>
进入创建的环境下的 Script 目录，执行下面的命令</p>
<div><pre><code>deactivate<span>.</span>bat
</code></pre>
<div><span>1</span><br></div></div><p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T06:24:56.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">进程</title>
    <id>https://www.snowji.cn/languages/python/basics/multi-progress/</id>
    <link href="https://www.snowji.cn/languages/python/basics/multi-progress/"/>
    <updated>2022-09-02T06:24:56.000Z</updated>
    <content type="html"><![CDATA[<h1 id="进程"> 进程</h1>
<h2 id="什么是多任务"> 什么是多任务</h2>
<p>同一时间有多个任务执行，表现形式为：</p>
<ul>
<li>并发：单核 cpu 交替执行多任务</li>
<li>并行：多核 cpu 同时执行多任务</li>
</ul>
<h2 id="什么是进程"> 什么是进程</h2>
<ul>
<li>概念</li>
</ul>
<p>进程是系统分配资源的最小单位，比如打开一个 QQ 软件，这是一个进程；再比如打开一个微信软件，这也是一个进程。</p>
<ul>
<li>作用</li>
</ul>
<p>多进程可以开启多个任务，使单 CPU 实现多任务并发</p>
<h2 id="创建多进程的步骤"> 创建多进程的步骤</h2>
<ul>
<li>创建进程对象</li>
<li>指定进程任务</li>
<li>开启进程</li>
</ul>
<h2 id="多进程实现"> 多进程实现</h2>
<h3 id="函数不带参数"> 函数不带参数</h3>
<div><pre><code><span>import</span> multiprocessing
<span>import</span> time
<span>import</span> os


<span>def</span> <span>sin</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span>os<span>.</span>getpid<span>(</span><span>)</span><span>)</span>  <span>//</span>获取当前进程 <span>id</span>
    <span>print</span><span>(</span>os<span>.</span>getppid<span>(</span><span>)</span><span>)</span> <span>//</span>获取父进程 <span>id</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>3</span><span>)</span><span>:</span>
        time<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
        <span>print</span><span>(</span><span>"唱歌......"</span><span>)</span>


<span>def</span> <span>dance</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span>os<span>.</span>getpid<span>(</span><span>)</span><span>)</span>  <span>//</span> 获取当前进程 <span>id</span>
    <span>print</span><span>(</span>os<span>.</span>getppid<span>(</span><span>)</span><span>)</span> <span>//</span>获取父进程 <span>id</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>3</span><span>)</span><span>:</span>
        time<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
        <span>print</span><span>(</span><span>"跳舞......"</span><span>)</span>


<span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>
    process1 <span>=</span> multiprocessing<span>.</span>Process<span>(</span>target<span>=</span>sin<span>)</span>  <span>//</span>创建多进程
    process2 <span>=</span> multiprocessing<span>.</span>Process<span>(</span>target<span>=</span>dance<span>)</span> 
    process1<span>.</span>start<span>(</span><span>)</span>   <span>//</span>启动多进程
    process2<span>.</span>start<span>(</span><span>)</span>
<span>6596</span>
<span>13816</span>
<span>5688</span>
<span>13816</span>
唱歌<span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
跳舞<span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
唱歌<span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
跳舞<span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
唱歌<span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
跳舞<span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>

由上可以看出，两个进程的父进程 <span>id</span> 是同一个
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><h3 id="函数带参"> 函数带参</h3>
<ul>
<li>
<p>使用 args 传参：需要注意 args 中的参数必须与函数中的一一对应</p>
<div><pre><code><span>import</span> multiprocessing
<span>import</span> time
<span>import</span> os


<span>def</span> <span>sin</span><span>(</span>num<span>)</span><span>:</span>
    <span>print</span><span>(</span>os<span>.</span>getpid<span>(</span><span>)</span><span>)</span>  <span>//</span>获取当前进程 <span>id</span>
    <span>print</span><span>(</span>os<span>.</span>getppid<span>(</span><span>)</span><span>)</span> <span>//</span>获取父进程 <span>id</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span>num<span>)</span><span>:</span>
        time<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
        <span>print</span><span>(</span><span>"唱歌......"</span><span>)</span>


<span>def</span> <span>dance</span><span>(</span>num<span>)</span><span>:</span>
    <span>print</span><span>(</span>os<span>.</span>getpid<span>(</span><span>)</span><span>)</span>  <span>//</span> 获取当前进程 <span>id</span>
    <span>print</span><span>(</span>os<span>.</span>getppid<span>(</span><span>)</span><span>)</span> <span>//</span>获取父进程 <span>id</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span>num<span>)</span><span>:</span>
        time<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
        <span>print</span><span>(</span><span>"跳舞......"</span><span>)</span>


<span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>
    process1 <span>=</span> multiprocessing<span>.</span>Process<span>(</span>target<span>=</span>sin<span>,</span>args<span>=</span><span>(</span><span>3</span><span>,</span><span>)</span><span>)</span>  <span>//</span>创建多进程
    process2 <span>=</span> multiprocessing<span>.</span>Process<span>(</span>target<span>=</span>dance<span>,</span> args<span>=</span><span>(</span><span>3</span><span>,</span><span>)</span><span>)</span> 
    process1<span>.</span>start<span>(</span><span>)</span>   <span>//</span>启动多进程
    process2<span>.</span>start<span>(</span><span>)</span>
    
    
结果：
<span>15392</span>
<span>15104</span>
<span>1836</span>
<span>15104</span>
唱歌<span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
跳舞<span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
唱歌<span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
跳舞<span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
唱歌<span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
跳舞<span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div></li>
<li>
<p>使用 kwargs 传参</p>
<div><pre><code><span>import</span> multiprocessing
<span>import</span> time
<span>import</span> os


<span>def</span> <span>sin</span><span>(</span>num<span>)</span><span>:</span>
    <span>print</span><span>(</span>os<span>.</span>getpid<span>(</span><span>)</span><span>)</span>  <span>//</span>获取当前进程 <span>id</span>
    <span>print</span><span>(</span>os<span>.</span>getppid<span>(</span><span>)</span><span>)</span> <span>//</span>获取父进程 <span>id</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span>num<span>)</span><span>:</span>
        time<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
        <span>print</span><span>(</span><span>"唱歌......"</span><span>)</span>


<span>def</span> <span>dance</span><span>(</span>num<span>)</span><span>:</span>
    <span>print</span><span>(</span>os<span>.</span>getpid<span>(</span><span>)</span><span>)</span>  <span>//</span> 获取当前进程 <span>id</span>
    <span>print</span><span>(</span>os<span>.</span>getppid<span>(</span><span>)</span><span>)</span> <span>//</span>获取父进程 <span>id</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span>num<span>)</span><span>:</span>
        time<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
        <span>print</span><span>(</span><span>"跳舞......"</span><span>)</span>


<span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>
    process1 <span>=</span> multiprocessing<span>.</span>Process<span>(</span>target<span>=</span>sin<span>,</span>kwargs<span>=</span><span>{</span><span>"num"</span><span>:</span><span>3</span><span>}</span><span>)</span>  <span>//</span>创建多进程
    process2 <span>=</span> multiprocessing<span>.</span>Process<span>(</span>target<span>=</span>dance<span>,</span> kwargs<span>=</span><span>{</span><span>"num"</span><span>:</span><span>3</span><span>}</span><span>)</span> 
    process1<span>.</span>start<span>(</span><span>)</span>   <span>//</span>启动多进程
    process2<span>.</span>start<span>(</span><span>)</span>
    
    
结果：
<span>5688</span>
<span>18800</span>
<span>12920</span>
<span>18800</span>
唱歌<span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
跳舞<span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
唱歌<span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
跳舞<span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
唱歌<span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
跳舞<span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div></li>
</ul>
<div><p>注意</p>
<p>问题：如果不在 <code>__name__ == '__main__'</code> 中创建进程并执行时，会报错</p>
<p>原因：不同系统支持多进程的机制不一样</p>
<ul>
<li>Win：默认支持 spawn</li>
<li>Linux ：默认支持 fork 机制</li>
<li>Mac :  支持 spawn 和 fork ，Python 3.8 之后默认支持 spawn</li>
</ul>
<p>解决：可以设置支持的机制</p>
<div><pre><code>multiprocessing<span>.</span>set_start_method<span>(</span><span>'fork'</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div></div>
<p>进程守护：主进程会在所有的子进程结束后再结束</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T06:24:56.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">使用 logging 输出日志信息</title>
    <id>https://www.snowji.cn/languages/python/modules/python-lib-logging/</id>
    <link href="https://www.snowji.cn/languages/python/modules/python-lib-logging/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="使用-logging-输出日志信息"> 使用 logging 输出日志信息</h1>
<h2 id="关于-logging"> 关于 logging</h2>
<ul>
<li>logging 库是 Python 内置的常用的记录日志库</li>
<li>开发过程中，可以通过该模块，灵活的完成日志的记录</li>
</ul>
<p>提供 2 种记录日志的方式：</p>
<ul>
<li>使用 logging 提供的模块级别的函数（logging.basicConfig，logging.debug，logging.info…）</li>
<li>使用 logging 模块的组件（loggers，handlers，filters，formatters）</li>
</ul>
<h2 id="日志级别"> 日志级别</h2>
<table>
<thead>
<tr>
<th>日志级别（level）</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>DEBUG</td>
<td>调试级别，一般用于问题的排查，日志的信息最为详细</td>
</tr>
<tr>
<td>INFO</td>
<td>仅记录普通的信息，日志信息的详细程度仅次于 DEBUG</td>
</tr>
<tr>
<td>WARNING</td>
<td>警告信息，一般这类信息不会影响程序的正常运行</td>
</tr>
<tr>
<td>ERROR</td>
<td>错误信息，出现错误信息时，程序一般已不能正常运行</td>
</tr>
<tr>
<td>CRITICAL</td>
<td>更严重的错误信息，程序不能继续运行</td>
</tr>
</tbody>
</table>
<p><strong>日志等级严重性</strong>：</p>
<p>DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICAL</p>
<h2 id="通过-logging-模块级别的函数记录日志"> 通过 logging 模块级别的函数记录日志</h2>
<p>示例：</p>
<div><pre><code><span>import</span> logging

logging<span>.</span>debug<span>(</span><span>'debug message'</span><span>)</span>  
logging<span>.</span>info<span>(</span><span>'info message'</span><span>)</span>  
logging<span>.</span>warning<span>(</span><span>'warning message'</span><span>)</span>  
logging<span>.</span>error<span>(</span><span>'error message'</span><span>)</span>  
logging<span>.</span>critical<span>(</span><span>'critical message'</span><span>)</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>输出结果：</p>
<div><pre><code>WARNING<span>:</span>root<span>:</span>warning message
ERROR<span>:</span>root<span>:</span>error message
CRITICAL<span>:</span>root<span>:</span>critical message
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>结果分析：</p>
<ul>
<li>只打印了 warning 及以上的日志信息，说明 logging <strong>默认的日志级别是 warning</strong></li>
<li>日志会直接打印到标准输出中</li>
</ul>
<h3 id="使用-basicconfig"> 使用 basicConfig</h3>
<p>示例：</p>
<div><pre><code><span>import</span> logging

logging<span>.</span>basicConfig<span>(</span>level<span>=</span>logging<span>.</span>DEBUG<span>,</span> 
                    <span>format</span><span>=</span><span>'%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s'</span><span>,</span>                       <span># 设置日志格式</span>
                    datefmt<span>=</span><span>'%Y-%m-%d %H:%M:%S'</span><span>,</span>    <span># 时间格式：2022-06-15 16:36:21</span>
                    filename<span>=</span><span>'test.log'</span><span>,</span>    <span># 日志的输出路径</span>
                    filemode<span>=</span><span>'a'</span><span>)</span>                      <span># 追加模式</span>

logging<span>.</span>debug<span>(</span><span>'debug message'</span><span>)</span>  
logging<span>.</span>info<span>(</span><span>'info message'</span><span>)</span>  
logging<span>.</span>warning<span>(</span><span>'warning message'</span><span>)</span>  
logging<span>.</span>error<span>(</span><span>'error message'</span><span>)</span>  
logging<span>.</span>critical<span>(</span><span>'critical message'</span><span>)</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>程序运行后，日志信息会直接记录到指定的文件中（test.log），且日志级别为 DEBUG，所以所有的日志都会被输出，日志信息如下：</p>
<div><pre><code><span>2022</span><span>-</span><span>06</span><span>-</span><span>15</span> <span>16</span><span>:</span><span>37</span><span>:</span><span>28</span> test1<span>.</span>py<span>[</span>line<span>:</span><span>33</span><span>]</span> DEBUG debug message
<span>2022</span><span>-</span><span>06</span><span>-</span><span>15</span> <span>16</span><span>:</span><span>37</span><span>:</span><span>28</span> test1<span>.</span>py<span>[</span>line<span>:</span><span>34</span><span>]</span> INFO info message
<span>2022</span><span>-</span><span>06</span><span>-</span><span>15</span> <span>16</span><span>:</span><span>37</span><span>:</span><span>28</span> test1<span>.</span>py<span>[</span>line<span>:</span><span>35</span><span>]</span> WARNING warning message
<span>2022</span><span>-</span><span>06</span><span>-</span><span>15</span> <span>16</span><span>:</span><span>37</span><span>:</span><span>28</span> test1<span>.</span>py<span>[</span>line<span>:</span><span>36</span><span>]</span> ERROR error message
<span>2022</span><span>-</span><span>06</span><span>-</span><span>15</span> <span>16</span><span>:</span><span>37</span><span>:</span><span>28</span> test1<span>.</span>py<span>[</span>line<span>:</span><span>37</span><span>]</span> CRITICAL critical message
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>logging.basicConfig() 函数的参数</strong>：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>filename</td>
<td>设置日志输出的文件名</td>
</tr>
<tr>
<td>filemode</td>
<td>设置日志写入文件的模式</td>
</tr>
<tr>
<td>format</td>
<td>设置日志显示格式</td>
</tr>
<tr>
<td>datefmt</td>
<td>指定日期时间格式</td>
</tr>
<tr>
<td>level</td>
<td>设置日志级别</td>
</tr>
<tr>
<td>stream</td>
<td>用指定的 stream 创建 StreamHandler<br />指定输出到 sys.stderr,sys.stdout 或者文件(f=open(‘test.log’,’w’))，默认为sys.stderr<br />若同时列出了 filename 和 stream 两个参数，则 stream 参数会被忽略</td>
</tr>
</tbody>
</table>
<p><strong>format 参数中可能用到的格式化串</strong>：</p>
<table>
<thead>
<tr>
<th>格式化串</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>%(name)s</td>
<td>Logger 的名字</td>
</tr>
<tr>
<td>%(levelno)s</td>
<td>数字形式的日志级别</td>
</tr>
<tr>
<td>%(levelname)s</td>
<td>文本形式的日志级别</td>
</tr>
<tr>
<td>%(pathname)s</td>
<td>调用日志输出函数的模块的完整路径名，可能没有</td>
</tr>
<tr>
<td>%(filename)s</td>
<td>调用日志输出函数的模块的文件名</td>
</tr>
<tr>
<td>%(module)s</td>
<td>调用日志输出函数的模块名</td>
</tr>
<tr>
<td>%(funcName)s</td>
<td>调用日志输出函数的函数名</td>
</tr>
<tr>
<td>%(lineno)d</td>
<td>调用日志输出函数的语句所在的代码行</td>
</tr>
<tr>
<td>%(created)f</td>
<td>当前时间，用 UNIX 标准的表示时间的浮点数表示</td>
</tr>
<tr>
<td>%(relativeCreated)d</td>
<td>输出日志信息时的，自 Logger 创建以来的毫秒数</td>
</tr>
<tr>
<td>%(asctime)s</td>
<td>字符串形式的当前时间<br />默认格式是 “2018-11-13 00:00:00,896”<br />逗号后面的是毫秒</td>
</tr>
<tr>
<td>%(thread)d</td>
<td>线程 ID，可能没有</td>
</tr>
<tr>
<td>%(threadName)s</td>
<td>线程名，可能没有</td>
</tr>
<tr>
<td>%(process)d</td>
<td>进程 ID，可能没有</td>
</tr>
<tr>
<td>%(message)s</td>
<td>用户输出的消息</td>
</tr>
</tbody>
</table>
<h2 id="通过-logging-模块的组件记录日志"> 通过 logging 模块的组件记录日志</h2>
<p>使用 logging 模块级别的函数记录日志，无法实现将日志输出到多个路径下</p>
<p><strong>logging 模块中用于记录日志的 4 大组件</strong>：</p>
<table>
<thead>
<tr>
<th>组件名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Logger</td>
<td>日志器，提供了应用程序可一直使用的接口</td>
</tr>
<tr>
<td>Handler</td>
<td>将 logger 产生的日志发送到指定的路径下（例如可以是终端，也可以是文件）</td>
</tr>
<tr>
<td>Filter</td>
<td>若有多个 Logger，可根据名称过滤出指定的 Logger 来记录日志</td>
</tr>
<tr>
<td>Formatter</td>
<td>定义日志格式</td>
</tr>
</tbody>
</table>
<p><strong>logging 模块组件记录日志的大致步骤如下</strong>：</p>
<ul>
<li>logging.getLogger() 获取 logger 对象</li>
<li>logger.setLevel(logging.DEBUG) 设置日志级别</li>
<li>创建一个或多个 handler，用于指定日志信息的输出流向</li>
<li>创建一个或多个 formatter，指定日志的格式，并分别将 formatter 绑定到 上</li>
<li>将 handler 绑定到 logger对象 上</li>
<li>最后便可使用 logger 对象 记录日志</li>
</ul>
<p>示例：</p>
<div><pre><code><span>import</span> logging

<span># 获取 logger对象</span>
logger <span>=</span> logging<span>.</span>getLogger<span>(</span><span>)</span>

<span># 创建一个 handler，用于写入日志文件</span>
fh <span>=</span> logging<span>.</span>FileHandler<span>(</span><span>'/tmp/test.log'</span><span>)</span>

<span># 再创建一个 handler，用于输出到控制台</span>
ch <span>=</span> logging<span>.</span>StreamHandler<span>(</span><span>)</span>

<span># 创建一个 formatter，两个 handler 使用相同的日志格式</span>
formatter <span>=</span> logging<span>.</span>Formatter<span>(</span><span>'%(asctime)s - %(name)s - %(levelname)s - %(message)s'</span><span>)</span>

<span># 绑定 formatter 到 handler 上</span>
fh<span>.</span>setFormatter<span>(</span>formatter<span>)</span>
ch<span>.</span>setFormatter<span>(</span>formatter<span>)</span>

<span># 绑定 handler 到 logger对象 上</span>
logger<span>.</span>addHandler<span>(</span>fh<span>)</span> <span>#logger对象可以添加多个fh和ch对象</span>
logger<span>.</span>addHandler<span>(</span>ch<span>)</span>

<span># 设置日志级别</span>
logger<span>.</span>setLevel<span>(</span>logging<span>.</span>WARNING<span>)</span>

logger<span>.</span>debug<span>(</span><span>'logger debug message'</span><span>)</span>
logger<span>.</span>info<span>(</span><span>'logger info message'</span><span>)</span>
logger<span>.</span>warning<span>(</span><span>'logger warning message'</span><span>)</span>
logger<span>.</span>error<span>(</span><span>'logger error message'</span><span>)</span>
logger<span>.</span>critical<span>(</span><span>'logger critical message'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>输出结果：</p>
<div><pre><code>终端输出：
<span>2022</span><span>-</span><span>06</span><span>-</span><span>15</span> <span>16</span><span>:</span><span>37</span><span>:</span><span>28</span> <span>-</span> root <span>-</span> WARNING <span>-</span> logger warning message
<span>2022</span><span>-</span><span>06</span><span>-</span><span>15</span> <span>16</span><span>:</span><span>37</span><span>:</span><span>28</span> <span>-</span> root <span>-</span> ERROR <span>-</span> logger error message
<span>2022</span><span>-</span><span>06</span><span>-</span><span>15</span> <span>16</span><span>:</span><span>37</span><span>:</span><span>28</span> <span>-</span> root <span>-</span> CRITICAL <span>-</span> logger critical message

文件输出：
<span>2022</span><span>-</span><span>06</span><span>-</span><span>15</span> <span>16</span><span>:</span><span>37</span><span>:</span><span>28</span> <span>-</span> root <span>-</span> WARNING <span>-</span> logger warning message
<span>2022</span><span>-</span><span>06</span><span>-</span><span>15</span> <span>16</span><span>:</span><span>37</span><span>:</span><span>28</span> <span>-</span> root <span>-</span> ERROR <span>-</span> logger error message
<span>2022</span><span>-</span><span>06</span><span>-</span><span>15</span> <span>16</span><span>:</span><span>37</span><span>:</span><span>28</span> <span>-</span> root <span>-</span> CRITICAL <span>-</span> logger critical message
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>当使用 handler 来设置日志级别时，存在如下两种情况：</p>
<ul>
<li>若 handler 设置的日志级别小于等于 logger 的日志级别时，则以 logger 的日志级别为准</li>
<li>若 handler 设置的日志级别大于 logger 的日志级别时，则以 handler 的日志级别为准</li>
</ul>
<p>示例：</p>
<p>handler 日志级别设置为 CRITICAL，logger 设置为 ERROR</p>
<div><pre><code><span>import</span> logging

logger <span>=</span> logging<span>.</span>getLogger<span>(</span><span>)</span>
ch <span>=</span> logging<span>.</span>StreamHandler<span>(</span><span>)</span>
formatter <span>=</span> logging<span>.</span>Formatter<span>(</span><span>'%(asctime)s - %(name)s - %(levelname)s - %(message)s'</span><span>)</span>

<span># handler 日志级别设置为 CRITICAL，logger 设置为 ERROR</span>
ch<span>.</span>setLevel<span>(</span>logging<span>.</span>CRITICAL<span>)</span>
logger<span>.</span>setLevel<span>(</span>logging<span>.</span>ERROR<span>)</span>

ch<span>.</span>setFormatter<span>(</span>formatter<span>)</span>
logger<span>.</span>addHandler<span>(</span>ch<span>)</span>

logger<span>.</span>debug<span>(</span><span>'logger debug message'</span><span>)</span>
logger<span>.</span>info<span>(</span><span>'logger info message'</span><span>)</span>
logger<span>.</span>warning<span>(</span><span>'logger warning message'</span><span>)</span>
logger<span>.</span>error<span>(</span><span>'logger error message'</span><span>)</span>
logger<span>.</span>critical<span>(</span><span>'logger critical message'</span><span>)</span>

输出结果：
<span>2022</span><span>-</span><span>06</span><span>-</span><span>15</span> <span>16</span><span>:</span><span>37</span><span>:</span><span>28</span><span>,</span><span>279</span> <span>-</span> root <span>-</span> CRITICAL <span>-</span> logger critical message
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h3 id="filter-组件的使用"> filter 组件的使用</h3>
<ul>
<li>filter 组件用来过滤 logger 对象</li>
<li>一个 filter 可以直接添加到 logger 对象上，也可以添加到 handler 对象上</li>
</ul>
<p><strong>示例</strong>：</p>
<p>在 handler 上添加 filter</p>
<div><pre><code><span>import</span> logging

logger1 <span>=</span> logging<span>.</span>getLogger<span>(</span><span>'a.b.c'</span><span>)</span>
logger2 <span>=</span> logging<span>.</span>getLogger<span>(</span><span>'a.c'</span><span>)</span>

<span># 定义一个 filter</span>
<span>filter</span> <span>=</span> logging<span>.</span>Filter<span>(</span>name<span>=</span><span>'a.b'</span><span>)</span>

<span># 定义一个 handler</span>
ch <span>=</span> logging<span>.</span>StreamHandler<span>(</span><span>)</span>
formatter <span>=</span> logging<span>.</span>Formatter<span>(</span><span>'%(asctime)s - %(name)s - %(levelname)s - %(message)s'</span><span>)</span>
ch<span>.</span>setFormatter<span>(</span>formatter<span>)</span>

<span># 若两个 logger对象 的日志级别相同，且都是用通过一个 handler，可以在这个 handler 上设置日志级别</span>
ch<span>.</span>setLevel<span>(</span>logging<span>.</span>ERROR<span>)</span>

<span># 在 handler 上放置过滤器</span>
ch<span>.</span>addFilter<span>(</span><span>filter</span><span>)</span>

logger1<span>.</span>addHandler<span>(</span>ch<span>)</span>
logger2<span>.</span>addHandler<span>(</span>ch<span>)</span>
logger1<span>.</span>error<span>(</span><span>'logger1 error message'</span><span>)</span>
logger2<span>.</span>error<span>(</span><span>'logger2 error message'</span><span>)</span>

输出结果：
<span>2022</span><span>-</span><span>06</span><span>-</span><span>15</span> <span>17</span><span>:</span><span>33</span><span>:</span><span>42</span><span>,</span><span>409</span> <span>-</span> a<span>.</span>b<span>.</span>c <span>-</span> ERROR <span>-</span> logger1 error message
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>在 logger 对象上添加 filter</p>
<div><pre><code><span>import</span> logging

logger1 <span>=</span> logging<span>.</span>getLogger<span>(</span><span>'a.b.c'</span><span>)</span>
logger2 <span>=</span> logging<span>.</span>getLogger<span>(</span><span>'a.c'</span><span>)</span>

<span># 定义一个 filter</span>
<span>filter</span> <span>=</span> logging<span>.</span>Filter<span>(</span>name<span>=</span><span>'a.b'</span><span>)</span>

<span># 定义一个 handler</span>
ch <span>=</span> logging<span>.</span>StreamHandler<span>(</span><span>)</span>
formatter <span>=</span> logging<span>.</span>Formatter<span>(</span><span>'%(asctime)s - %(name)s - %(levelname)s - %(message)s'</span><span>)</span>
ch<span>.</span>setFormatter<span>(</span>formatter<span>)</span>

<span># 若两个 logger对象 的日志级别相同，且都是用通过一个 handler，可以在这个 handler 上设置日志级别</span>
ch<span>.</span>setLevel<span>(</span>logging<span>.</span>ERROR<span>)</span>

<span># 在 logger 上放置过滤器</span>
logger1<span>.</span>addFilter<span>(</span><span>filter</span><span>)</span>
logger2<span>.</span>addFilter<span>(</span><span>filter</span><span>)</span>

logger1<span>.</span>addHandler<span>(</span>ch<span>)</span>
logger2<span>.</span>addHandler<span>(</span>ch<span>)</span>
logger1<span>.</span>error<span>(</span><span>'logger1 error message'</span><span>)</span>
logger2<span>.</span>error<span>(</span><span>'logger2 error message'</span><span>)</span>

输出结果：
<span>2022</span><span>-</span><span>06</span><span>-</span><span>15</span> <span>17</span><span>:</span><span>36</span><span>:</span><span>42</span><span>,</span><span>669</span> <span>-</span> a<span>.</span>b<span>.</span>c <span>-</span> ERROR <span>-</span> logger1 error message
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><ul>
<li>输出结果一致，即仅有 logger1 输出日志</li>
<li>将 filter 添加到 logger 上，这个 filter 将直接作用于这个 logger，貌似这么意义不大，很少这样使用</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T06:24:56.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">使用 openpyxl 处理新版本 Excel</title>
    <id>https://www.snowji.cn/languages/python/modules/python-lib-openpyxl/</id>
    <link href="https://www.snowji.cn/languages/python/modules/python-lib-openpyxl/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="使用-openpyxl-处理新版本-excel"> 使用 openpyxl 处理新版本 Excel</h1>
<h2 id="关于-openpyxl"> 关于 openpyxl</h2>
<p>openpyxl 是读写新版本 Excel（<code>.xlsx</code>） 的第三方库，是一个比较综合的工具，能够同时读取和修改 Excel 文档。支持的格式有 <code>.xlsx</code>、<code>.xlsm</code>、<code>.xltx</code> 和 <code>.xltm</code></p>
<p>安装比较简单，直接用 pip 工具即可，安装命令如下：</p>
<div><pre><code><span>sudo</span> pip <span>install</span> openpyxl
</code></pre>
<div><span>1</span><br></div></div><h2 id="写入-excel"> 写入 Excel</h2>
<p>下面是一个使用 openpyxl 写入数据到 Excel 的代码示例，大致逻辑是：遍历源数据，通过指定行号和列号，依次插入 Excel 表格的每个单元格中</p>
<div><p>注意</p>
<ul>
<li>Python 中数组的索引是从 0 开始的</li>
<li>而 openpyxl 在指定单元格时索引是从 1 开始的（<code>sheet.cell(row, column, value)</code>）</li>
<li>因此，openpyxl 的首行、首列是 (1, 1) 而不是 (0, 0)</li>
</ul>
</div>
<div><pre><code><span>#!/usr/bin/env python</span>
<span># -*- coding: utf-8 -*-</span>

<span>"""
使用第三方库：pip install openpyxl
一般用于处理新版本 Excel(.xlsx)
"""</span>

<span>import</span> openpyxl


<span># 数据形如：[['张三', '信息与通信工程', '数值分析', 88]]</span>
<span>def</span> <span>write_excel</span><span>(</span>sheet_name<span>,</span> head<span>,</span> data<span>,</span> path<span>)</span><span>:</span>
    <span># 实例化一个工作薄对象</span>
    workbook <span>=</span> openpyxl<span>.</span>Workbook<span>(</span><span>)</span>
    <span># 激活一个 Sheet 表（工作表），并为它设置一个 title</span>
    sheet <span>=</span> workbook<span>.</span>active
    sheet<span>.</span>title <span>=</span> sheet_name

    <span># data 中添加表头（不需要表头可以不用加）</span>
    data<span>.</span>insert<span>(</span><span>0</span><span>,</span> <span>list</span><span>(</span>head<span>)</span><span>)</span>

    <span># 开始遍历并插入数据</span>
    <span># row: 行  col: 列</span>
    <span>for</span> row_index<span>,</span> row_item <span>in</span> <span>enumerate</span><span>(</span>data<span>)</span><span>:</span>
        <span>for</span> col_index<span>,</span> col_item <span>in</span> <span>enumerate</span><span>(</span>row_item<span>)</span><span>:</span>
            <span># 写入单元格</span>
            sheet<span>.</span>cell<span>(</span>row<span>=</span>row_index <span>+</span> <span>1</span><span>,</span> column<span>=</span>col_index <span>+</span> <span>1</span><span>,</span> value<span>=</span>col_item<span>)</span>

    workbook<span>.</span>save<span>(</span>path<span>)</span>


<span>if</span> __name__ <span>==</span> <span>"__main__"</span><span>:</span>
    <span># mock 数据</span>
    sheet_name <span>=</span> <span>'成绩'</span>
    head <span>=</span> <span>[</span><span>'姓名'</span><span>,</span> <span>'专业'</span><span>,</span> <span>'科目'</span><span>,</span> <span>'成绩'</span><span>]</span>
    data <span>=</span> <span>[</span>
        <span>[</span><span>'张三'</span><span>,</span> <span>'信息与通信工程'</span><span>,</span> <span>'数值分析'</span><span>,</span> <span>88</span><span>]</span><span>,</span>
        <span>[</span><span>'李四'</span><span>,</span> <span>'物联网工程'</span><span>,</span> <span>'数字信号处理分析'</span><span>,</span> <span>95</span><span>]</span><span>,</span>
        <span>[</span><span>'王华'</span><span>,</span> <span>'电子与通信工程'</span><span>,</span> <span>'模糊数学'</span><span>,</span> <span>90</span><span>]</span><span>,</span>
        <span>[</span><span>'王欢'</span><span>,</span> <span>'通信工程'</span><span>,</span> <span>'机器学习'</span><span>,</span> <span>89</span><span>]</span>
    <span>]</span>
    path <span>=</span> <span>'student.xlsx'</span>

    <span># 执行方法</span>
    write_excel<span>(</span>sheet_name，head<span>,</span> data<span>,</span> path<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><p>运行代码，结果会看到生成名为 student.xlsx 的 Excel 文件，打开文件查看如下图所示：</p>
<div style="text-align: center;">
  <img src="../images/write-xlsx.png" height="200" alt="使用 openpyxl 写入数据到 Excel">
</div>
<p>拓展：</p>
<ul>
<li>在实例化一个工作薄对象时，默认会产生一个 Sheet，默认名字是：<code>&quot;Sheet&quot;</code>，激活它后就可使用</li>
</ul>
<div><pre><code>workbook <span>=</span> openpyxl<span>.</span>Workbook<span>(</span><span>)</span>
sheet <span>=</span> workbook<span>.</span>active
sheet<span>.</span>title <span>=</span> sheet_name
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>新增第二个 Sheet 并使用</li>
</ul>
<div><pre><code>sheet_2 <span>=</span> workbook<span>.</span>create_sheet<span>(</span>title<span>=</span><span>"Sheet名"</span><span>)</span>
sheet_2<span>[</span><span>'F5'</span><span>]</span> <span>=</span> <span>3.14</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>遍历 Sheet 对象</li>
</ul>
<div><pre><code><span>for</span> sheet <span>in</span> workbook<span>:</span>
    <span>print</span><span>(</span><span>'sheet:'</span><span>,</span> sheet<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>遍历 Sheet 名然后通过名字获取 Sheet 对象</li>
</ul>
<div><pre><code>sheet_names <span>=</span> workbook<span>.</span>sheet_names
<span>for</span> sheet_name <span>in</span> sheet_names<span>:</span>
    sheet <span>=</span> workbook<span>[</span>sheet_name<span>]</span>
    <span>print</span><span>(</span><span>'sheet:'</span><span>,</span> sheet<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="读取-excel"> 读取 Excel</h2>
<p>下面是一个使用 openpyxl 读取 Excel 数据的代码示例，逻辑比较简单：先执行要读取的 Sheet 表，然后逐行遍历，每一行中依次读取每一列（即每个单元格的数据）</p>
<div><pre><code><span>#!/usr/bin/env python</span>
<span># -*- coding: utf-8 -*-</span>

<span>"""
使用第三方库：pip install openpyxl
一般用于处理新版本 Excel(.xlsx)
"""</span>

<span>import</span> openpyxl


<span>def</span> <span>read_excel</span><span>(</span>path<span>,</span> sheet_name<span>)</span><span>:</span>
    <span># 实例化一个工作薄对象</span>
    workbook <span>=</span> openpyxl<span>.</span>load_workbook<span>(</span>path<span>)</span>
    <span># 获取指定名字的 Sheet 表</span>
    sheet <span>=</span> workbook<span>[</span>sheet_name<span>]</span>

    <span># 定义一个数组，存放要输出的数据</span>
    result <span>=</span> <span>[</span><span>]</span>

    <span># sheet.rows 为表格内的每一行数据</span>
    <span># 循环获取表格内的每一行数据</span>
    <span>for</span> row_index<span>,</span> row_item <span>in</span> <span>enumerate</span><span>(</span>sheet<span>.</span>rows<span>)</span><span>:</span>
        <span># 定义一个空的数组用来存放每一行数据单元格的数据</span>
        current_row <span>=</span> <span>[</span><span>]</span>
        <span>for</span> col_index<span>,</span> col_item <span>in</span> <span>enumerate</span><span>(</span>row_item<span>)</span><span>:</span>
            <span># 获取单元格数据 追加到 return_row</span>
            current_row<span>.</span>append<span>(</span>col_item<span>.</span>value<span>)</span>
        <span># 把每一行数据追加到结果 return_data 中，最后输出</span>
        result<span>.</span>append<span>(</span>current_row<span>)</span>

    <span>return</span> result


<span>if</span> __name__ <span>==</span> <span>"__main__"</span><span>:</span>
    <span># mock 数据</span>
    sheet_name <span>=</span> <span>'成绩'</span>
    path <span>=</span> <span>'student.xlsx'</span>

    <span># 执行方法</span>
    result <span>=</span> read_excel<span>(</span>path<span>,</span> sheet_name<span>)</span>
    <span>print</span><span>(</span>result<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><p>输出如下结果：</p>
<div style="text-align: center;">
  <img src="../images/read-xlsx.png" height="133" alt="使用 openpyxl 从 Excel 读取数据">
</div>
<h2 id="常用读取-api"> 常用读取 API</h2>
<p>接下来列举通过 openpyxl 读写 Excel 时常用的 API</p>
<blockquote>
<p>如无特别标注，以下所有代码中的 <code>workbook</code> 为工作薄的实例对象，<code>sheet</code> 为工作表的实力对象</p>
</blockquote>
<h3 id="打开-excel-表格并获取表格名称"> 打开 Excel 表格并获取表格名称</h3>
<div><pre><code><span>from</span> openpyxl <span>import</span> load_workbook
workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
workbook<span>.</span>sheetnames
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="通过-sheet-名称获取表格"> 通过 Sheet 名称获取表格</h3>
<div><pre><code><span>from</span> openpyxl <span>import</span> load_workbook
workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
workbook<span>.</span>sheetnames
sheet <span>=</span> workbook<span>[</span><span>"Sheet1"</span><span>]</span>
<span>print</span><span>(</span>sheet<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="获取表格的尺寸大小"> 获取表格的尺寸大小</h3>
<p>这里所说的尺寸大小，指的是 Excel 表格中的数据有几行几列，针对的是不同的 Sheet 而言</p>
<div><pre><code>sheet<span>.</span>dimensions
</code></pre>
<div><span>1</span><br></div></div><h3 id="获取最大行、最大列"> 获取最大行、最大列</h3>
<p>注意：获取到的最大行与最大列都是基于起始索引 1 计算的</p>
<div><pre><code>sheet<span>.</span>max_row     <span># 最大行</span>
sheet<span>.</span>max_column  <span># 最大列</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="获取表格内某个格子的数据"> 获取表格内某个格子的数据</h3>
<ul>
<li><code>sheet[&quot;A1&quot;]</code> 方式</li>
</ul>
<div><pre><code><span>"""
workbook.active 打开激活的表格；
sheet["A1"] 获取A1格子的数据；
cell.value 获取格子中的值；
"""</span>

workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
sheet <span>=</span> workbook<span>.</span>active

cell1 <span>=</span> sheet<span>[</span><span>"A1"</span><span>]</span>
cell2 <span>=</span> sheet<span>[</span><span>"C11"</span><span>]</span>
<span>print</span><span>(</span>cell1<span>.</span>value<span>,</span> cell2<span>.</span>value<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><ul>
<li><code>sheet.cell(row=, column=)</code> 方式，这种方式更简单</li>
</ul>
<div><pre><code>workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
sheet <span>=</span> workbook<span>.</span>active

cell1 <span>=</span> sheet<span>.</span>cell<span>(</span>row<span>=</span><span>1</span><span>,</span>column<span>=</span><span>1</span><span>)</span>
cell2 <span>=</span> sheet<span>.</span>cell<span>(</span>row<span>=</span><span>11</span><span>,</span>column<span>=</span><span>3</span><span>)</span>
<span>print</span><span>(</span>cell1<span>.</span>value<span>,</span> cell2<span>.</span>value<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="获取某个单元格的行数、列数、坐标"> 获取某个单元格的行数、列数、坐标</h3>
<div><pre><code><span>"""
.row 获取某个格子的行数；
.columns 获取某个格子的列数；
.corordinate 获取某个格子的坐标；
"""</span>

workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
sheet <span>=</span> workbook<span>.</span>active

cell1 <span>=</span> sheet<span>[</span><span>"A1"</span><span>]</span>
cell2 <span>=</span> sheet<span>[</span><span>"C11"</span><span>]</span>
<span>print</span><span>(</span>cell1<span>.</span>value<span>,</span> cell1<span>.</span>row<span>,</span> cell1<span>.</span>column<span>,</span> cell1<span>.</span>coordinate<span>)</span>
<span>print</span><span>(</span>cell2<span>.</span>value<span>,</span> cell2<span>.</span>row<span>,</span> cell2<span>.</span>column<span>,</span> cell2<span>.</span>coordinate<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="获取一系列单元格"> 获取一系列单元格</h3>
<ul>
<li><code>sheet[]</code> 方式</li>
</ul>
<div><pre><code>workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
sheet <span>=</span> workbook<span>.</span>active

<span># 获取 A1:C2 区域的值</span>
cells <span>=</span> sheet<span>[</span><span>"A1:C2"</span><span>]</span>
<span>print</span><span>(</span>cells<span>)</span>
<span>for</span> row <span>in</span> cells<span>:</span>
    <span>for</span> col <span>in</span> row<span>:</span>
        <span>print</span><span>(</span>col<span>.</span>value<span>)</span>

<span># 如果我们只想获取"A列"，或者获取"A-C列"，可以采取如下方式：</span>
<span># sheet["A"]    --- 获取 A 列的数据</span>
<span># sheet["A:C"]  --- 获取 A,B,C 三列的数据</span>
<span># sheet[5]      --- 获取第 5 行的数据</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><ul>
<li><code>.iter_rows()</code> 和 <code>.iter_cols()</code> 方式</li>
</ul>
<div><pre><code>workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
sheet <span>=</span> workbook<span>.</span>active

<span># 按行获取值</span>
<span>for</span> row_item <span>in</span> sheet<span>.</span>iter_rows<span>(</span>min_row<span>=</span><span>2</span><span>,</span> max_row<span>=</span><span>5</span><span>,</span> min_col<span>=</span><span>1</span><span>,</span> max_col<span>=</span><span>2</span><span>)</span><span>:</span>
    <span>for</span> col_item <span>in</span> row_item<span>:</span>
        <span>print</span><span>(</span>col_item<span>.</span>value<span>)</span>

<span># 按列获取值</span>
<span>for</span> col_item <span>in</span> sheet<span>.</span>iter_cols<span>(</span>min_row<span>=</span><span>2</span><span>,</span> max_row<span>=</span><span>5</span><span>,</span> min_col<span>=</span><span>1</span><span>,</span> max_col<span>=</span><span>2</span><span>)</span><span>:</span>
    <span>for</span> row_item <span>in</span> col_item<span>:</span>
        <span>print</span><span>(</span>row_item<span>.</span>value<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><ul>
<li><code>sheet.rows</code> 获取所有行</li>
</ul>
<div><pre><code>workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
sheet <span>=</span> workbook<span>.</span>active

<span>for</span> row_item <span>in</span> sheet<span>.</span>rows<span>:</span>
    <span>print</span><span>(</span>row_item<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="常用写入-api"> 常用写入 API</h2>
<h3 id="向指定单元格写入数据并保存"> 向指定单元格写入数据并保存</h3>
<div><pre><code><span>"""
注意：下方代码将"A1"单元格的数据改为了"哈喽"，并另存为"哈喽.xlsx"文件。
如果我们保存的时候，不修改表名，相当于直接修改源文件。
"""</span>

workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
sheet <span>=</span> workbook<span>.</span>active

sheet<span>[</span><span>"A1"</span><span>]</span> <span>=</span> <span>"哈喽"</span>  <span># 这句代码也可以改为 cell = sheet["A1"] cell.value = "哈喽"</span>
workbook<span>.</span>save<span>(</span>filename<span>=</span><span>"哈喽.xlsx"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="向表格中插入行数据"> 向表格中插入行数据</h3>
<ul>
<li>使用 <code>.append()</code> 方法：会在表格已有的数据后面，追加新数据（按行插入）；</li>
<li>这个操作很有用，爬虫得到的数据，可以使用该方式保存成 Excel 文件</li>
</ul>
<div><pre><code><span>"""
下方代码会将 data 中的数据逐行追加到原表格数据后面
"""</span>

workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
sheet <span>=</span> workbook<span>.</span>active

data <span>=</span> <span>[</span>
    <span>[</span><span>"唐僧"</span><span>,</span> <span>"男"</span><span>,</span> <span>"180cm"</span><span>]</span><span>,</span>
    <span>[</span><span>"孙悟空"</span><span>,</span> <span>"男"</span><span>,</span> <span>"188cm"</span><span>]</span><span>,</span>
    <span>[</span><span>"猪八戒"</span><span>,</span> <span>"男"</span><span>,</span> <span>"175cm"</span><span>]</span><span>,</span>
    <span>[</span><span>"沙僧"</span><span>,</span> <span>"男"</span><span>,</span> <span>"176cm"</span><span>]</span>
<span>]</span>
<span>for</span> row <span>in</span> data<span>:</span>
    sheet<span>.</span>append<span>(</span>row<span>)</span>
workbook<span>.</span>save<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="使用-excel-函数公式-很有用"> 使用 Excel 函数公式(很有用)</h3>
<div><pre><code><span>"""
这是在 Excel 中输入的公式：
=IF(RIGHT(C2,2)="cm",C2,SUBSTITUTE(C2,"m","")*100&amp;"cm")
"""</span>

workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
sheet <span>=</span> workbook<span>.</span>active

sheet<span>[</span><span>"D1"</span><span>]</span> <span>=</span> <span>"标准身高"</span>
<span>for</span> i <span>in</span> <span>range</span><span>(</span><span>2</span><span>,</span> <span>16</span><span>)</span><span>:</span>
    sheet<span>[</span><span>"D{}"</span><span>.</span><span>format</span><span>(</span>i<span>)</span><span>]</span> <span>=</span> <span>'=IF(RIGHT(C{},2)="cm",C{},SUBSTITUTE(C{},"m","")*100&amp;"cm")'</span><span>.</span><span>format</span><span>(</span>i<span>,</span> i<span>,</span> i<span>)</span>
workbook<span>.</span>save<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="插入空行和空列"> 插入空行和空列</h3>
<p>使用 <code>.insert_cols()</code> 和 <code>.insert_rows()</code> 方法：</p>
<ul>
<li><code>.insert_cols(idx=数字编号, amount=要插入的列数)</code>，插入的位置是在 idx 列数的左侧插入</li>
<li><code>.insert_rows(idx=数字编号, amount=要插入的行数)</code>，插入的位置是在 idx 行数的下方插入</li>
</ul>
<div><pre><code>workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
sheet <span>=</span> workbook<span>.</span>active

sheet<span>.</span>insert_cols<span>(</span>idx<span>=</span><span>4</span><span>,</span>amount<span>=</span><span>2</span><span>)</span>
sheet<span>.</span>insert_rows<span>(</span>idx<span>=</span><span>5</span><span>,</span>amount<span>=</span><span>4</span><span>)</span>
workbook<span>.</span>save<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="删除指定行和列"> 删除指定行和列</h3>
<p>使用 <code>.delete_rows()</code> 和 <code>.delete_cols()</code> 方法：</p>
<ul>
<li><code>.delete_rows(idx=数字编号, amount=要删除的行数)</code></li>
<li><code>.delete_cols(idx=数字编号, amount=要删除的列数)</code></li>
</ul>
<div><pre><code>workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
sheet <span>=</span> workbook<span>.</span>active

<span># 删除第一列，第一行</span>
sheet<span>.</span>delete_cols<span>(</span>idx<span>=</span><span>1</span><span>)</span>
sheet<span>.</span>delete_rows<span>(</span>idx<span>=</span><span>1</span><span>)</span>
workbook<span>.</span>save<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="移动指定单元格"> 移动指定单元格</h3>
<p>使用 <code>.move_range(&quot;数据区域&quot;,rows=,cols=)</code> 方法：正整数为向下或向右、负整数为向左或向上</p>
<div><pre><code><span># 向左移动两列，向下移动两行</span>
sheet<span>.</span>move_range<span>(</span><span>"C1:D4"</span><span>,</span> rows<span>=</span><span>2</span><span>,</span> cols<span>=</span><span>-</span><span>1</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="创建新的-sheet-表"> 创建新的 Sheet 表</h3>
<p>使用 <code>.create_sheet(&quot;新的Sheet名&quot;)</code> 方法</p>
<div><pre><code>workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
sheet <span>=</span> workbook<span>.</span>active

workbook<span>.</span>create_sheet<span>(</span><span>"一个新的Sheet"</span><span>)</span>
<span>print</span><span>(</span>workbook<span>.</span>sheetnames<span>)</span>
workbook<span>.</span>save<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="删除指定-sheet-表"> 删除指定 Sheet 表</h3>
<p>使用 <code>.remove(&quot;Sheet名&quot;)</code> 方法</p>
<div><pre><code>workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
sheet <span>=</span> workbook<span>.</span>active
<span>print</span><span>(</span>workbook<span>.</span>sheetnames<span>)</span>

<span># 这个相当于通过名字来激活指定 Sheet 表，激活状态下，才可以操作</span>
sheet <span>=</span> workbook<span>[</span><span>'一个新的Sheet'</span><span>]</span>
workbook<span>.</span>remove<span>(</span>sheet<span>)</span>

<span>print</span><span>(</span>workbook<span>.</span>sheetnames<span>)</span>
workbook<span>.</span>save<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="复制一个-sheet-表到另外一份-excel"> 复制一个 Sheet 表到另外一份 Excel</h3>
<p>使用 <code>.copy_worksheet()</code> 方法：复制某个 Excel 表中的 Sheet 表，然后将文件存储到另外一个 Excel 中（追加到最后）</p>
<div><pre><code>workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>"test_src.xlsx"</span><span>)</span>
sheet <span>=</span> workbook<span>.</span>active
<span>print</span><span>(</span><span>"test_src.xlsx 中有这几个 Sheet 表："</span><span>,</span> workbook<span>.</span>sheetnames<span>)</span>

sheet <span>=</span> workbook<span>[</span><span>'姓名'</span><span>]</span>  
workbook<span>.</span>copy_worksheet<span>(</span>sheet<span>)</span>
workbook<span>.</span>save<span>(</span>filename<span>=</span><span>"test_dst.xlsx"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="修改-sheet-表的名称"> 修改 Sheet 表的名称</h3>
<p>使用 <code>.title = &quot;新的sheet表名&quot;</code></p>
<div><pre><code>workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
sheet <span>=</span> workbook<span>.</span>active
<span>print</span><span>(</span>sheet<span>)</span>

sheet<span>.</span>title <span>=</span> <span>"我是修改后的sheet名"</span>
<span>print</span><span>(</span>sheet<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="创建新的-excel-文件"> 创建新的 Excel 文件</h3>
<div><pre><code><span>from</span> openpyxl <span>import</span> Workbook

workbook <span>=</span> Workbook<span>(</span><span>)</span>
sheet <span>=</span> workbook<span>.</span>active
sheet<span>.</span>title <span>=</span> <span>"表格1"</span>
workbook<span>.</span>save<span>(</span>filename<span>=</span><span>"新建的Excel"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="冻结窗口"> 冻结窗口</h3>
<blockquote>
<p>冻结窗口以后，滑动垂直/水平滚动条，该单元格的位置不会改变</p>
</blockquote>
<p>使用 <code>.freeze_panes = &quot;单元格&quot;</code> 方法：需要确保指定的单元格不在第一行，因为 <code>freeze_panes</code> 将冻结给定单元格上方的行和左侧的列</p>
<div><pre><code><span>"""
sheet.freeze_panes = "B1"  # 冻结第一列
sheet.freeze_panes = "A2"  # 冻结第一行
sheet.freeze_panes = "B2"  # 同时冻结第一行和第一列
"""</span>

workbook<span>=</span>load_workbook<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
sheet <span>=</span> workbook<span>.</span>active

sheet<span>.</span>freeze_panes <span>=</span> <span>"A2"</span>  <span># 冻结第一行</span>
workbook<span>.</span>save<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="给表格添加筛选器"> 给表格添加筛选器</h3>
<p>使用 <code>sheet.auto_filter.ref</code> 方法</p>
<ul>
<li><code>.auto_filter.ref = sheet.dimension</code>：给所有字段添加筛选器</li>
<li><code>.auto_filter.ref = &quot;A1&quot;</code>：给 A1 这个格子添加筛选器，就是给第一列添加筛选器</li>
</ul>
<div><pre><code>workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
sheet <span>=</span> workbook<span>.</span>active

sheet<span>.</span>auto_filter<span>.</span>ref <span>=</span> sheet<span>[</span><span>"A1"</span><span>]</span>
workbook<span>.</span>save<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="常用格式化-api"> 常用格式化 API</h2>
<h3 id="修改字体样式"> 修改字体样式</h3>
<ul>
<li><code>Font(name=字体名称, size=字体大小, bold=是否加粗, italic=是否斜体, color=字体颜色)</code></li>
</ul>
<p>其中，color 是 RGB 的 16 进制表示</p>
<div><pre><code><span>from</span> openpyxl<span>.</span>styles <span>import</span> Font
<span>from</span> openpyxl <span>import</span> load_workbook


workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
sheet <span>=</span> workbook<span>.</span>active
cell <span>=</span> sheet<span>[</span><span>"A1"</span><span>]</span>
font <span>=</span> Font<span>(</span>name<span>=</span><span>"微软雅黑"</span><span>,</span>size<span>=</span><span>20</span><span>,</span>bold<span>=</span><span>True</span><span>,</span>italic<span>=</span><span>True</span><span>,</span>color<span>=</span><span>"FF0000"</span><span>)</span>
cell<span>.</span>font <span>=</span> font
workbook<span>.</span>save<span>(</span>filename <span>=</span> <span>"花园.xlsx"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="获取单元格的字体样式"> 获取单元格的字体样式</h3>
<div><pre><code><span>from</span> openpyxl<span>.</span>styles <span>import</span> Font
<span>from</span> openpyxl <span>import</span> load_workbook


workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
sheet <span>=</span> workbook<span>.</span>active
cell <span>=</span> sheet<span>[</span><span>"A2"</span><span>]</span>
font <span>=</span> cell<span>.</span>font
<span>print</span><span>(</span>font<span>.</span>name<span>,</span> font<span>.</span>size<span>,</span> font<span>.</span>bold<span>,</span> font<span>.</span>italic<span>,</span> font<span>.</span>color<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="设置对齐样式"> 设置对齐样式</h3>
<ul>
<li><code>Alignment(horizontal=水平对齐模式, vertical=垂直对齐模式, text_rotation=旋转角度, wrap_text=是否自动换行)</code>
<ul>
<li>水平对齐模式：'distributed'，'justify'，'center'，'leftfill'，'centerContinuous'，'right'，'general'</li>
<li>垂直对齐模式：'bottom'，'distributed'，'justify'，'center'，'top'</li>
</ul>
</li>
</ul>
<div><pre><code><span>from</span> openpyxl<span>.</span>styles <span>import</span> Alignment
<span>from</span> openpyxl <span>import</span> load_workbook


workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
sheet <span>=</span> workbook<span>.</span>active
cell <span>=</span> sheet<span>[</span><span>"A1"</span><span>]</span>
alignment <span>=</span> Alignment<span>(</span>horizontal<span>=</span><span>"center"</span><span>,</span> vertical<span>=</span><span>"center"</span><span>,</span> text_rotation<span>=</span><span>45</span><span>,</span> wrap_text<span>=</span><span>True</span><span>)</span>
cell<span>.</span>alignment <span>=</span> alignment
workbook<span>.</span>save<span>(</span>filename <span>=</span><span>"test.xlsx"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="设置边框样式"> 设置边框样式</h3>
<ul>
<li><code>Side(style=边线样式, color=边线颜色)</code> 和 <code>Border(left=左边线样式, right=右边线样式, top=上边线样式, bottom=下边线样式)</code>
<ul>
<li>style 参数：'double', 'mediumDashDotDot', 'slantDashDot', 'dashDotDot', 'dotted', 'hair', 'mediumDashed, 'dashed', 'dashDot', 'thin', 'mediumDashDot', 'medium', 'thick'</li>
</ul>
</li>
</ul>
<div><pre><code><span>from</span> openpyxl<span>.</span>styles <span>import</span> Side<span>,</span> Border
<span>from</span> openpyxl <span>import</span> load_workbook


workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
sheet <span>=</span> workbook<span>.</span>active
cell <span>=</span> sheet<span>[</span><span>"D6"</span><span>]</span>
side1 <span>=</span> Side<span>(</span>style<span>=</span><span>"thin"</span><span>,</span> color<span>=</span><span>"FF0000"</span><span>)</span>
side2 <span>=</span> Side<span>(</span>style<span>=</span><span>"thick"</span><span>,</span> color<span>=</span><span>"FFFF00"</span><span>)</span>
border <span>=</span> Border<span>(</span>left<span>=</span>side1<span>,</span> right<span>=</span>side1<span>,</span> top<span>=</span>side2<span>,</span> bottom<span>=</span>side2<span>)</span>
cell<span>.</span>border <span>=</span> border
workbook<span>.</span>save<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="设置填充样式"> 设置填充样式</h3>
<ul>
<li><code>PatternFill(fill_type=填充样式，fgColor=填充颜色）</code></li>
<li><code>GradientFill(stop=(渐变颜色1，渐变颜色2……))</code></li>
</ul>
<div><pre><code><span>from</span> openpyxl<span>.</span>styles <span>import</span> PatternFill<span>,</span>GradientFill
<span>from</span> openpyxl <span>import</span> load_workbook


workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
sheet <span>=</span> workbook<span>.</span>active
cell_b9 <span>=</span> sheet<span>[</span><span>"B9"</span><span>]</span>
pattern_fill <span>=</span> PatternFill<span>(</span>fill_type<span>=</span><span>"solid"</span><span>,</span>fgColor<span>=</span><span>"99ccff"</span><span>)</span>
cell_b9<span>.</span>fill <span>=</span> pattern_fill
cell_b10 <span>=</span> sheet<span>[</span><span>"B10"</span><span>]</span>
gradient_fill <span>=</span> GradientFill<span>(</span>stop<span>=</span><span>(</span><span>"FFFFFF"</span><span>,</span><span>"99ccff"</span><span>,</span><span>"000000"</span><span>)</span><span>)</span>
cell_b10<span>.</span>fill <span>=</span> gradient_fill
workbook<span>.</span>save<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="设置行高和列宽"> 设置行高和列宽</h3>
<ul>
<li><code>.row_dimensions[行编号].height = 行高</code></li>
<li><code>.column_dimensions[列编号].width = 列宽</code></li>
</ul>
<div><pre><code>workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
sheet <span>=</span> workbook<span>.</span>active
<span># 设置第1行的高度</span>
sheet<span>.</span>row_dimensions<span>[</span><span>1</span><span>]</span><span>.</span>height <span>=</span> <span>50</span>
<span># 设置B列的宽度</span>
sheet<span>.</span>column_dimensions<span>[</span><span>"B"</span><span>]</span><span>.</span>width <span>=</span> <span>20</span>
workbook<span>.</span>save<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>

<span>"""
也可以设置整个 Sheet 表的行高和列宽：
sheet.row_dimensions.height = 50
sheet.column_dimensions.width = 30
"""</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="合并单元格"> 合并单元格</h3>
<ul>
<li><code>.merge_cells(待合并的格子编号)</code></li>
<li><code>.merge_cells(start_row=起始行号，start_column=起始列号，end_row=结束行号，end_column=结束列号)</code></li>
</ul>
<div><pre><code>workbook <span>=</span> load_workbook<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
sheet <span>=</span> workbook<span>.</span>active
sheet<span>.</span>merge_cells<span>(</span><span>"C1:D2"</span><span>)</span>
sheet<span>.</span>merge_cells<span>(</span>start_row<span>=</span><span>7</span><span>,</span> start_column<span>=</span><span>1</span><span>,</span> end_row<span>=</span><span>8</span><span>,</span> end_column<span>=</span><span>3</span><span>)</span>
workbook<span>.</span>save<span>(</span>filename<span>=</span><span>"test.xlsx"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>也可以取消合并单元格，用法一致</p>
<ul>
<li><code>.unmerge_cells(待合并的格子编号)</code></li>
<li><code>.unmerge_cells(start_row=起始行号，start_column=起始列号，end_row=结束行号，end_column=结束列号)</code></li>
</ul>
<h2 id="参考资料"> 参考资料</h2>
<ul>
<li><a href="https://openpyxl.readthedocs.io/en/stable/" target="_blank" rel="noopener noreferrer">openpyxl</a></li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T06:24:56.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">使用 Fabric 执行 SSH</title>
    <id>https://www.snowji.cn/languages/python/modules/python-lib-fabric/</id>
    <link href="https://www.snowji.cn/languages/python/modules/python-lib-fabric/"/>
    <updated>2022-09-02T06:24:56.000Z</updated>
    <content type="html"><![CDATA[<h1 id="使用-fabric-执行-ssh"> 使用 Fabric 执行 SSH</h1>
<h2 id="关于-fabric"> 关于 Fabric</h2>
<p>Fabric 是 Python 库中的一个模块，它是基于 Paramiko 的基础上做了一层更高的封装，操作起来更加方便。我们可以用它通过网络进行系统管理和应用程序部署，也可以通过 SSH 执行 Shell 命令</p>
<p>由于 Fabric 是 Python 的一个第三方库，首先需要安装它：</p>
<div><pre><code><span>sudo</span> pip <span>install</span> fabric
</code></pre>
<div><span>1</span><br></div></div><blockquote>
<p>题外话：曾经有一段时间 Fabric 只支持到 Python2，所以有人 Fork 官方仓库后改写成了<a href="https://github.com/mathiasertl/fabric/" target="_blank" rel="noopener noreferrer">支持 Python3 的版本</a>，也就是网上大部分教程通过 <code>pip install fabric3</code> 安装的包
后来 <a href="https://github.com/fabric/fabric/" target="_blank" rel="noopener noreferrer">fabric 官方</a>对 Python3 做了支持，而后 Fabric3 的作者也在 README 中加了 deprecated 标识，意为不再维护
所以尽管 Fabric3 比较好用，大部分网上的教程和书籍也都是基于它在开发，但处于稳定性和持续维护性角度考虑，我在 Python3 中将继续沿用官方版本的 Fabric
关于三者的区别：<a href="https://github.com/fabric/fabric/issues/1791" target="_blank" rel="noopener noreferrer">Clarify fabric vs fabric2 vs fabric3 differences</a></p>
</blockquote>
<h2 id="一个简单的例子"> 一个简单的例子</h2>
<p>下面是一个使用 Fabric 连接远程设备的示例程序（<a href="https://github.com/wenyuan/practice-in-python/blob/main/devops-case/fabric_example.py" target="_blank" rel="noopener noreferrer"><code>fabric_example.py</code></a>）：</p>
<div><pre><code><span>#!/usr/bin/env python</span>
<span># -*- coding: utf-8 -*-</span>

<span>from</span> fabric <span>import</span> Connection
<span>from</span> paramiko <span>import</span> AuthenticationException


<span>def</span> <span>do_ssh</span><span>(</span>host<span>,</span> username<span>,</span> password<span>,</span> commands<span>)</span><span>:</span>
    <span>try</span><span>:</span>
        client <span>=</span> Connection<span>(</span>host<span>=</span>host<span>,</span> user<span>=</span>username<span>,</span> port<span>=</span><span>22</span><span>,</span> connect_kwargs<span>=</span><span>{</span><span>'password'</span><span>:</span> password<span>}</span><span>)</span>
        <span># 执行操作</span>
        <span>for</span> command <span>in</span> commands<span>:</span>
            res <span>=</span> client<span>.</span>run<span>(</span>command<span>,</span> hide<span>=</span><span>True</span><span>)</span>
            <span>print</span><span>(</span>res<span>.</span>stdout<span>)</span>
        client<span>.</span>close<span>(</span><span>)</span>
    <span>except</span> AuthenticationException<span>:</span>
        <span>print</span><span>(</span><span>'{host} 密码错误'</span><span>.</span><span>format</span><span>(</span>host<span>=</span>host<span>)</span><span>)</span>
    <span>except</span> Exception <span>as</span> e<span>:</span>
        <span>print</span><span>(</span><span>repr</span><span>(</span>e<span>)</span><span>)</span>


<span>if</span> __name__ <span>==</span> <span>"__main__"</span><span>:</span>
    host <span>=</span> <span>'192.168.10.x'</span>
    username <span>=</span> <span>'admin'</span>
    password <span>=</span> <span>'******'</span>
    commands <span>=</span> <span>[</span><span>'pwd'</span><span>,</span> <span>'ls'</span><span>]</span>
    do_ssh<span>(</span>host<span>,</span> username<span>,</span> password<span>,</span> commands<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>Fabric 模块里上面代码中用到的方法介绍：</p>
<ul>
<li><code>Connection</code> 类：用于创建连接</li>
<li><code>run()</code>：该方法可在连接的服务器上运行 Shell 命令。如果需要用管理员权限，则需替换成 <code>sudo()</code> 方法；如果要在本地执行 Shell 命令，则需替换成 <code>local()</code> 方法
<ul>
<li>参数 <code>warn</code>：默认为 <code>False</code>，默认情况下会因为 Shell 命令的错误输出而抛错, 也就是直接抛出 <code>stderr</code>。如果设为 <code>True</code>, 就会将 Shell 命令的错误输出写到 Result 对象的 <code>stderr</code> 内</li>
<li>参数 <code>hide</code>：默认为 <code>False</code>，默认情况下将远程的输出信息在当前命令行输出。为 <code>True</code> 时，则不会输出。但不论是什么, 都不会影响 Result 对象的 <code>stdout</code> 和 <code>stderr</code> 结果，还可以只隐藏 <code>stdout</code> 或 <code>stderr</code></li>
<li>参数 <code>watchers</code>：传入的是一个包含诺干 Responder 实例的列表。当需要运行交互式的命令时，可以用 Responder 对象来匹配输出，并写入输入，做自动化部署时很实用</li>
<li>参数 <code>pty</code>：默认为 <code>True</code>，这个参数最好别动，不然输出内容可能会混乱</li>
</ul>
</li>
</ul>
<p>关于 <code>run()</code> 的输出结果：</p>
<p>执行 Connection 类的 <code>run()</code> 方法后，直接输出的是一个 fabric.runners.Result 类，我们可以把其中的信息解析出来：</p>
<div><pre><code><span>print</span><span>(</span>result<span>.</span>stdout<span>)</span>  <span># /home/admin</span>
<span>print</span><span>(</span>result<span>.</span>exited<span>)</span>  <span># 0</span>
<span>print</span><span>(</span>result<span>.</span>ok<span>)</span>      <span># True</span>
<span>print</span><span>(</span>result<span>.</span>failed<span>)</span>  <span># False</span>
<span>print</span><span>(</span>result<span>.</span>command<span>)</span> <span># pwd</span>
<span>print</span><span>(</span>result<span>.</span>connection<span>.</span>host<span>)</span> <span># 192.xx.xx.xx</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="命令行用法"> 命令行用法</h2>
<p>上例代码可写在任意的 <code>.py</code> 脚本中，然后运行该脚本，或者稍微封装下再导入到其它脚本中使用</p>
<p>另外，Fabric 还是个命令行工具，可以通过 <code>fab</code> 命令来执行任务。如下代码示例：</p>
<div><pre><code><span># 文件名：fabfile.py</span>
<span>from</span> fabric <span>import</span> Connection
<span>from</span> fabric <span>import</span> task

host_ip <span>=</span> <span>'192.168.10.xx'</span>  <span># 服务器地址</span>
user_name <span>=</span> <span>'root'</span>         <span># 服务器用户名</span>
password <span>=</span> <span>'******'</span>        <span># 服务器密码</span>
cmd <span>=</span> <span>'date'</span>               <span># Shell 命令，查询服务器上的时间</span>

<span>@task</span>
<span>def</span> <span>test</span><span>(</span>c<span>)</span><span>:</span>
    <span>"""
    Get date from remote host.
    """</span>
    con <span>=</span> Connection<span>(</span>host_ip<span>,</span> user_name<span>,</span> connect_kwargs<span>=</span><span>{</span><span>'password'</span><span>:</span> password<span>}</span><span>)</span>
    result <span>=</span> con<span>.</span>run<span>(</span>cmd<span>,</span> hide<span>=</span><span>True</span><span>)</span>
    <span>print</span><span>(</span>result<span>.</span>stdout<span>)</span>  <span># 只打印时间</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>解释一下，需要注意的关键点有：</p>
<ul>
<li><code>fabfile.py</code> 文件名：入口代码的脚本名必须用这个名字</li>
<li><code>@task</code> 装饰器：需要从 fabric 中引入这个装饰器，它是对 invoke 的 <code>@task</code> 装饰器的封装，实际用法跟 invoke 一样（注意：它也需要有上下文参数 <code>c</code>，但实际上它并没有在代码块中使用，而是用了 Connection 类的实例）</li>
</ul>
<p>然后，在该脚本同级目录的命令行窗口中，可以查看和执行相应的任务：</p>
<div><pre><code><span>>></span><span>></span> fab -l
Available tasks:
  <span>test</span>   Get <span>date</span> from remote host.

<span>>></span><span>></span> fab <span>test</span>
Fri Feb <span>14</span> <span>16</span>:10:24 CST <span>2021</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>执行 <code>fab --help</code>，可以看到该命令支持的所有参数与解释：</p>
<ul>
<li><code>--prompt-for-login-password</code>：令程序在命令行中输入 SSH 登录密码（上例在代码中指定了 connect_kwargs.password 参数，若用此选项，可要求在执行时再手工输入密码）</li>
<li><code>--prompt-for-passphrase</code>：令程序在命令行中输入 SSH 私钥加密文件的路径</li>
<li><code>-H</code> 或 <code>--hosts</code>：指定要连接的 host 名</li>
<li><code>-i</code> 或 <code>--identity</code>：指定 SSH 连接所用的私钥文件</li>
<li><code>-S</code> 或 <code>--ssh-config</code>：指定运行时要加载的 SSH 配置文件</li>
</ul>
<p>关于 Fabric 的命令行接口，更多内容可<a href="https://docs.fabfile.org/en/2.5/cli.html" target="_blank" rel="noopener noreferrer">查看文档</a>。</p>
<h2 id="交互式操作"> 交互式操作</h2>
<p>上面的示例程序我们通过 Fabric 模块连接了一台远程服务器，执行命令后打印了输出结果</p>
<p>有时候远程服务器上若有交互式提示，要求输入密码或 yes 之类的信息，这就要求 Fabric 能够监听并作出回应</p>
<p>以下是一个简单示例。引入 invoke 的 Responder，初始化内容是一个正则字符串和回应信息，最后赋值给 watchers 参数：</p>
<div><pre><code><span>from</span> invoke <span>import</span> Responder
<span>from</span> fabric <span>import</span> Connection
c <span>=</span> Connection<span>(</span><span>'host'</span><span>)</span>
sudopass <span>=</span> Responder<span>(</span>
     pattern<span>=</span><span>r'\[sudo\] password:'</span><span>,</span>
     response<span>=</span><span>'mypassword\n'</span><span>)</span>
c<span>.</span>run<span>(</span><span>'sudo whoami'</span><span>,</span> pty<span>=</span><span>True</span><span>,</span> watchers<span>=</span><span>[</span>sudopass<span>]</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="传输文件"> 传输文件</h2>
<p>本地与服务器间的文件传输是常见用法。Fabric 在这方面做了很好的封装，Connection 类中有以下两个方法可用：</p>
<ul>
<li><code>get(*args, **kwargs)</code>：拉取远端文件到本地文件系统或类文件（file-like）对象</li>
<li><code>put(*args, **kwargs)</code>：推送本地文件或类文件对象到远端文件系统</li>
</ul>
<p>在已建立连接的情况下，示例：</p>
<div><pre><code><span># (略)</span>
con<span>.</span>get<span>(</span><span>'/opt/123.txt'</span><span>,</span> <span>'123.txt'</span><span>)</span>
con<span>.</span>put<span>(</span><span>'test.txt'</span><span>,</span> <span>'/opt/test.txt'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>第一个参数指的是要传输的源文件，第二个参数是要传输的目的地，可以指定成文件名或者文件夹（为空或 <code>None</code> 时，使用默认路径）：</p>
<div><pre><code><span># (略)</span>
con<span>.</span>get<span>(</span><span>'/opt/123.txt'</span><span>,</span> <span>''</span><span>)</span>  <span># 为空时，使用默认路径</span>
con<span>.</span>put<span>(</span><span>'test.txt'</span><span>,</span> <span>'/opt/'</span><span>)</span> <span># 指定路径 /opt/</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>get()</code> 方法的默认存储路径是 <code>os.getcwd()</code> ，而 <code>put()</code> 方法的默认存储路径是 <code>home</code> 目录</p>
<h2 id="服务器批量操作"> 服务器批量操作</h2>
<p>对于服务器集群的批量操作，最简单的实现方法是用 for 循环，然后逐一建立 connection 和执行操作，类似这样：</p>
<div><pre><code><span>for</span> host <span>in</span> <span>(</span><span>'server1'</span><span>,</span> <span>'server2'</span><span>,</span> <span>'server3'</span><span>)</span><span>:</span>
    result <span>=</span> Connection<span>(</span>host<span>)</span><span>.</span>run<span>(</span><span>'uname -s'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>但有时候，这样的方案会存在问题：</p>
<ul>
<li>如果存在多组不同的服务器集群，需要执行不同操作，那么需要写很多 for 循环</li>
<li>如果想把每组操作的结果聚合起来（例如字典形式，key-主机，value-结果），还得在 for 循环之外添加额外的操作</li>
<li>for 循环是顺序同步执行的，效率太低，而且缺乏异常处理机制（若中间出现异常，会导致跳出后续操作）</li>
</ul>
<p>对于这些问题，Fabric 提出了 Group 的概念，可将一组主机定义成一个 Group，它的 API 方法跟 Connection 一样，即一个 Group 可简化地视为一个 Connection</p>
<p>然后，开发者只需要简单地操作这个 Group，最后得到一个结果集即可，减少了自己在异常处理及执行顺序上的工作</p>
<p>Fabric 提供了一个 fabric.group.Group 基类，并由其派生出两个子类，区别是：</p>
<ul>
<li><code>SerialGroup(hosts, **kwargs)</code>：按串行方式执行操作</li>
<li><code>ThreadingGroup(hosts, **kwargs)</code>：按并发方式执行操作</li>
</ul>
<p>Group 的类型决定了主机集群的操作方式，我们只需要做出选择即可。然后，它们的执行结果是一个 fabric.group.GroupResult 类，它是 dict 的子类，存储了每个主机 connection 及其执行结果的对应关系</p>
<div><pre><code><span>from</span> fabric <span>import</span> SerialGroup
results <span>=</span> SerialGroup<span>(</span><span>'server1'</span><span>,</span> <span>'server2'</span><span>,</span> <span>'server3'</span><span>)</span><span>.</span>run<span>(</span><span>'uname -s'</span><span>)</span>
<span>print</span><span>(</span>results<span>)</span>

<span># 输出：</span>
<span>&lt;</span>GroupResult<span>:</span> <span>{</span>
    <span>&lt;</span>Connection <span>'server1'</span><span>></span><span>:</span> <span>&lt;</span>CommandResult <span>'uname -s'</span><span>></span><span>,</span>
    <span>&lt;</span>Connection <span>'server2'</span><span>></span><span>:</span> <span>&lt;</span>CommandResult <span>'uname -s'</span><span>></span><span>,</span>
    <span>&lt;</span>Connection <span>'server3'</span><span>></span><span>:</span> <span>&lt;</span>CommandResult <span>'uname -s'</span><span>></span><span>,</span>
<span>}</span><span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>另外，GroupResult 还提供了 failed 与 succeeded 两个属性，可以取出失败/成功的子集。由此，也可以方便地批量进行二次操作 <a href="https://docs.fabfile.org/en/2.5/api/group.html" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<h2 id="身份认证"> 身份认证</h2>
<p>Fabric 使用 SSH 协议来建立远程会话，它是一种相对安全的基于应用层的加密传输协议</p>
<p>基本来说，它有两种级别的安全认证方式：</p>
<ul>
<li>基于口令的身份认证：使用账号与密码来登录远程主机，安全性较低，容易受到「中间人」攻击</li>
<li>基于密钥的身份认证：使用密钥对方式（公钥放服务端，私钥放客户端），不会受到「中间人」攻击，但登录耗时较长</li>
</ul>
<p>前面在举例时，我们用了第一种方式，即通过指定 <code>connect_kwargs.password</code> 参数，使用口令来登录</p>
<p>Fabric 当然也支持采用第二种方式，有三种方法来指定私钥文件的路径，优先级如下：</p>
<ul>
<li>优先查找 <code>connect_kwargs.key_filename</code> 参数，找到则用作私钥</li>
<li>其次查找命令行用法的 <code>--identify</code> 选项</li>
<li>最后默认使用操作系统的 <code>ssh_config</code> 文件中的 <code>IdentityFile</code> 的值</li>
</ul>
<p>如果私钥文件本身还被加密过，则需要使用 <code>connect_kwargs.passphrase</code> 参数</p>
<h2 id="配置文件"> 配置文件</h2>
<p>Fabric 支持把一些参数项与业务代码分离，即通过配置文件来管理它们，例如前面提到的密码和私钥文件，可写在配置文件中，避免与代码耦合</p>
<p>Fabric 基本沿用了 Invoke 的配置文件体系（官方文档中列出了 9 层），同时增加了一些跟 SSH 相关的配置项。支持的文件格式有 .yaml、.yml、.json 与 .py（按此次序排优先级），推荐使用 yaml 格式（后缀可简写成 yml）</p>
<p>其中，比较常用的配置文件有：</p>
<ul>
<li>系统级的配置文件：<code>/etc/fabric.yml</code></li>
<li>用户级的配置文件：<code>~/.fabric.yml</code>（Windows 在 <code>C:\Users\xxx</code> 下）</li>
<li>项目级的配置文件：<code>/myproject/fabric.yml</code></li>
</ul>
<p>以上文件的优先级递减，由于我的本地开发机器是 Windows 系统，为了方便，我在用户目录建一个 <code>.fabric.yml</code> 文件，内容如下：</p>
<div><pre><code><span># filename:.fabric.yml</span>

user: root
connect_kwargs:
  password: xxxx
<span># 若用密钥，则如下</span>
<span>#  key_filename:</span>
<span>#    - your_key_file</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>我们把用户名和密码抽离出来了，所以脚本中就可以删掉这些内容：</p>
<div><pre><code><span># 文件名：fabfile.py</span>
<span>from</span> fabric <span>import</span> Connection
<span>from</span> fabric <span>import</span> task

host_ip <span>=</span> <span>'47.xx.xx.xx'</span>  <span># 服务器地址</span>
cmd <span>=</span> <span>'date'</span>             <span># Shell 命令，查询服务器上的时间</span>

<span>@task</span>
<span>def</span> <span>test</span><span>(</span>c<span>)</span><span>:</span>
    <span>"""
    Get date from remote host.
    """</span>
    con <span>=</span> Connection<span>(</span>host_ip<span>)</span>
    result <span>=</span> con<span>.</span>run<span>(</span>cmd<span>,</span> hide<span>=</span><span>True</span><span>)</span>
    <span>print</span><span>(</span>result<span>.</span>stdout<span>)</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>然后，在命令行中执行：</p>
<div><pre><code><span>>></span><span>></span> fab <span>test</span>
Tue Feb <span>18</span> <span>10</span>:33:38 CST <span>2021</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>配置文件中还可以设置很多参数，详细可<a href="https://docs.fabfile.org/en/2.5/concepts/configuration.html" target="_blank" rel="noopener noreferrer">查看文档</a></p>
<h2 id="网络网关"> 网络网关</h2>
<p>如果远程服务是网络隔离的，无法直接被访问到（处在不同局域网），这时候需要有网关/代理/隧道，这个中间层的机器通常被称为跳板机或堡垒机</p>
<p>Fabric 中有两种网关解决方案，对应到 OpenSSH 客户端的两种选项：</p>
<ul>
<li>ProxyJump：简单，开销少，可嵌套</li>
<li>ProxyCommand：开销大，不可嵌套，更灵活</li>
</ul>
<p>在创建 Fabric 的 Connection 对象时，可通过指定 gateway 参数来应用这两种方案</p>
<p>ProxyJump 方式就是在一个 Connection 中嵌套一个 Connection  作为前者的网关，后者使用 SSH 协议的 <code>direct-tcpip</code> 为前者打开与实际远程主机的连接，而且后者还可以继续嵌套使用自己的网关</p>
<div><pre><code><span>from</span> fabric <span>import</span> Connection

c <span>=</span> Connection<span>(</span><span>'internalhost'</span><span>,</span> gateway<span>=</span>Connection<span>(</span><span>'gatewayhost'</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>ProxyCommand 方式是客户端在本地用 ssh 命令（类似 <code>ssh -W %h:%p gatewayhost</code>），创建一个子进程，该子进程与服务端进行通信，同时它能读取标准输入和输出</p>
<p>这部分的实现细节分别在 <code>paramiko.channel.Channel</code> 和 <code>paramiko.proxy.ProxyCommand</code>，除了在参数中指定，也可以在 Fabric 支持的配置文件中定义。更多细节，请<a href="https://docs.fabfile.org/en/2.5/concepts/networking.html" target="_blank" rel="noopener noreferrer">查阅文档</a></p>
<h2 id="总结"> 总结</h2>
<p>本文把 Fabric 常见的几种用法都整理了一下，原因是 Fabric 之前对 Python3 的不兼容，导致出现了不同的分支。而网上关于 Fabric 的文章，甚至是最近两年出版的书籍，都是基于 Fabric3（非官方版）的，显然已经过时了。本文针对最新的官方文档，梳理出了较为全面的知识点。更详细的用法，还是得仔细研读官方的英文文档</p>
<h2 id="参考资料"> 参考资料</h2>
<ul>
<li><a href="https://www.fabfile.org/" target="_blank" rel="noopener noreferrer">Fabric</a></li>
<li>《Python自动化运维：技术与最佳实践》</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T06:24:56.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">os.walk()</title>
    <id>https://www.snowji.cn/languages/python/modules/python-lib-os-walk/</id>
    <link href="https://www.snowji.cn/languages/python/modules/python-lib-os-walk/"/>
    <updated>2022-09-22T02:38:50.000Z</updated>
    <content type="html"><![CDATA[<h1 id="os-walk"> os.walk()</h1>
<p><strong>作用</strong>：</p>
<ul>
<li>主要用来遍历一个目录内各个子目录和子文件</li>
<li>是一个简单易用的文件、目录遍历器，可以帮助我们高效的处理文件、目录方面的事情</li>
</ul>
<p><strong>原理</strong>：递归遍历目录</p>
<p><img src="./../images/walk.png" alt="walk" /></p>
<h2 id="方法参数介绍"> 方法参数介绍</h2>
<div><pre><code>os<span>.</span>walk<span>(</span>top<span>[</span><span>,</span> topdown<span>=</span><span>True</span><span>[</span><span>,</span> onerror<span>=</span><span>None</span><span>[</span><span>,</span> followlinks<span>=</span><span>False</span><span>]</span><span>]</span><span>]</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li><strong>top</strong> ：是要遍历的目录的地址, 返回的是一个三元组（dirpath, dirnames, filenames）</li>
<li><strong>topdown</strong> ：可选，True 则优先遍历 top 文件夹，与 top 文件夹中每一个子目录；否则优先遍历 top 的子目录（默认为开启）</li>
<li><strong>onerror</strong> ：可选，需要一个 callable 对象，当 walk 需要异常时，会调用</li>
<li><strong>followlinks</strong> ：可选，如果为 True，则会遍历目录下的快捷方式（linux 下是软连接 symbolic link ）实际所指的目录（默认关闭），如果为 False，则优先遍历 top 的子目录</li>
</ul>
<h3 id="返回的三元组介绍"> 返回的三元组介绍</h3>
<ul>
<li>
<p>dirpath：string，代表目录的路径</p>
</li>
<li>
<p>dirnames：list，包含了 dirpath 下所有子目录的名字</p>
</li>
</ul>
<ul>
<li>filenames：list，包含了非目录文件的名字</li>
</ul>
<h2 id="代码示例"> 代码示例</h2>
<div><pre><code>path <span>=</span> os<span>.</span>getcwd<span>(</span><span>)</span>
<span>for</span> dirpath<span>,</span> dirnames<span>,</span> filenames <span>in</span> os<span>.</span>walk<span>(</span>path<span>)</span><span>:</span>
    <span>print</span><span>(</span>dirpath<span>)</span>
    <span>print</span><span>(</span>dirnames<span>)</span>
    <span>print</span><span>(</span>filenames<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>结果：</p>
<div><pre><code>F<span>:</span>\pylearn\learn
<span>[</span><span>'test'</span><span>]</span>
<span>[</span><span>'bytes_str.py'</span><span>,</span> <span>'get_file_md5_test.py'</span><span>,</span> <span>'List_Tuple_Learning.py'</span><span>,</span> <span>'Number_Learning.py'</span><span>,</span> <span>'os_walk.py'</span><span>,</span> <span>'String_Learning.py'</span><span>,</span> <span>'__init__.py'</span><span>]</span>
F<span>:</span>\pylearn\learn\test
<span>[</span><span>]</span>
<span>[</span><span>'test.py'</span><span>,</span> <span>'__init__.py'</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><p>知识点</p>
<p>当 top 路径下还有目录时，是会递归查询的</p>
</div>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-21T08:28:13.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">使用 smtplib 发送电子邮件</title>
    <id>https://www.snowji.cn/languages/python/modules/python-lib-smtplib/</id>
    <link href="https://www.snowji.cn/languages/python/modules/python-lib-smtplib/"/>
    <updated>2022-09-03T14:10:02.000Z</updated>
    <content type="html"><![CDATA[<h1 id="使用-smtplib-发送电子邮件"> 使用 smtplib 发送电子邮件</h1>
<h2 id="准备"> 准备</h2>
<h3 id="_1-开启邮箱的-smtp-服务"> 1. 开启邮箱的 SMTP 服务</h3>
<p>这里使用第三方 SMTP 服务发送邮件，可以使用 QQ 邮箱，163，Gmail 等的 SMTP 服务，但需要做以下配置，以 QQ 邮箱为例</p>
<p>登录 QQ 邮箱，依次点击最上方的<strong>设置</strong> =&gt; <strong>账户</strong></p>
<div style="text-align: center;">
  <img src="../images/qq-smtp-setting-1.png" alt="QQ 邮箱设置">
</div>
<p>往下翻页，找到 <strong>POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV</strong> 这一版块，开启 <strong>POP3/SMTP 服务</strong>。（不同版本的 QQ 可能会不一样，总之就是找到 QQ 邮箱的「POP3/SMTP服务」开启按钮）</p>
<div style="text-align: center;">
  <img src="../images/qq-smtp-setting-2.png" alt="开启 POP3/SMTP 服务">
</div>
<p>成功开启 QQ 邮箱的 SMTP 服务后，我们会得到一串授权码，在后面的代码里，这串授权码就是我们邮箱的登录密码。开启 SMTP 服务可能需要进行手机验证，根据提示来就好</p>
<h3 id="_2-常用的邮件服务器配置"> 2. 常用的邮件服务器配置</h3>
<p>下面整理了常用的邮件服务器名称、地址及 SSL/非SSL 协议端口号</p>
<p><strong>网易 163 免费邮箱相关服务器信息：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">服务器名称</th>
<th style="text-align:center">服务器地址</th>
<th style="text-align:center">SSL协议端口号</th>
<th style="text-align:center">非SSL协议端口号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IMAP</td>
<td style="text-align:center">imap.163.com</td>
<td style="text-align:center">993</td>
<td style="text-align:center">143</td>
</tr>
<tr>
<td style="text-align:center">SMTP</td>
<td style="text-align:center">smtp.163.com</td>
<td style="text-align:center">454/994</td>
<td style="text-align:center">25</td>
</tr>
<tr>
<td style="text-align:center">POP3</td>
<td style="text-align:center">pop.163.com</td>
<td style="text-align:center">995</td>
<td style="text-align:center">110</td>
</tr>
</tbody>
</table>
<p><strong>网易 163 企业邮箱相关服务器信息：</strong>（免费企业邮箱的 smtp 服务器名及端口号为：smtp.ym.163.com / 25）</p>
<table>
<thead>
<tr>
<th style="text-align:center">服务器名称</th>
<th style="text-align:center">服务器地址</th>
<th style="text-align:center">SSL协议端口号</th>
<th style="text-align:center">非SSL协议端口号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IMAP</td>
<td style="text-align:center">imap.qiye.163.com</td>
<td style="text-align:center">993</td>
<td style="text-align:center">143</td>
</tr>
<tr>
<td style="text-align:center">SMTP</td>
<td style="text-align:center">smtp.qiye.163.com</td>
<td style="text-align:center">994</td>
<td style="text-align:center">25</td>
</tr>
<tr>
<td style="text-align:center">POP3</td>
<td style="text-align:center">pop.qiye.163.com</td>
<td style="text-align:center">995</td>
<td style="text-align:center">110</td>
</tr>
</tbody>
</table>
<p><strong>网易 126 免费邮箱相关服务器信息：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">服务器名称</th>
<th style="text-align:center">服务器地址</th>
<th style="text-align:center">SSL协议端口号</th>
<th style="text-align:center">非SSL协议端口号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IMAP</td>
<td style="text-align:center">imap.126.com</td>
<td style="text-align:center">993</td>
<td style="text-align:center">143</td>
</tr>
<tr>
<td style="text-align:center">SMTP</td>
<td style="text-align:center">smtp.126.com</td>
<td style="text-align:center">465/994</td>
<td style="text-align:center">25</td>
</tr>
<tr>
<td style="text-align:center">POP3</td>
<td style="text-align:center">pop.126.com</td>
<td style="text-align:center">995</td>
<td style="text-align:center">110</td>
</tr>
</tbody>
</table>
<p><strong>腾讯 QQ 免费邮箱相关服务器信息：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">服务器名称</th>
<th style="text-align:center">服务器地址</th>
<th style="text-align:center">SSL协议端口号</th>
<th style="text-align:center">非SSL协议端口号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IMAP</td>
<td style="text-align:center">imap.qq.com</td>
<td style="text-align:center">993</td>
<td style="text-align:center">143</td>
</tr>
<tr>
<td style="text-align:center">SMTP</td>
<td style="text-align:center">smtp.qq.com</td>
<td style="text-align:center">465/587</td>
<td style="text-align:center">25</td>
</tr>
<tr>
<td style="text-align:center">POP3</td>
<td style="text-align:center">pop.qq.com</td>
<td style="text-align:center">995</td>
<td style="text-align:center">110</td>
</tr>
</tbody>
</table>
<p><strong>腾讯 QQ 企业邮箱相关服务器信息：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">服务器名称</th>
<th style="text-align:center">服务器地址</th>
<th style="text-align:center">SSL协议端口号</th>
<th style="text-align:center">非SSL协议端口号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IMAP</td>
<td style="text-align:center">imap.exmail.qq.com</td>
<td style="text-align:center">993</td>
<td style="text-align:center">143</td>
</tr>
<tr>
<td style="text-align:center">SMTP</td>
<td style="text-align:center">smtp.exmail.qq.com</td>
<td style="text-align:center">465/587</td>
<td style="text-align:center">25</td>
</tr>
<tr>
<td style="text-align:center">POP3</td>
<td style="text-align:center">pop.exmail.qq.com</td>
<td style="text-align:center">995</td>
<td style="text-align:center">110</td>
</tr>
</tbody>
</table>
<p><strong>谷歌 Gmail 邮箱相关服务器信息：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">服务器名称</th>
<th style="text-align:center">服务器地址</th>
<th style="text-align:center">SSL协议端口号</th>
<th style="text-align:center">非SSL协议端口号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IMAP</td>
<td style="text-align:center">imap.gmail.com</td>
<td style="text-align:center">993</td>
<td style="text-align:center">143</td>
</tr>
<tr>
<td style="text-align:center">SMTP</td>
<td style="text-align:center">smtp.gmail.com</td>
<td style="text-align:center">465</td>
<td style="text-align:center">25</td>
</tr>
<tr>
<td style="text-align:center">POP3</td>
<td style="text-align:center">pop.gmail.com</td>
<td style="text-align:center">995</td>
<td style="text-align:center">110</td>
</tr>
</tbody>
</table>
<h2 id="发送纯文本邮件"> 发送纯文本邮件</h2>
<blockquote>
<p>下面所有示例使用 QQ 邮箱，注意 QQ 邮箱 SMTP 服务器地址：smtp.qq.com，ssl，端口：465。</p>
</blockquote>
<p>以下实例你需要修改：发件人邮箱（你的 QQ 邮箱），密码，收件人邮箱（可发给自己）</p>
<div><pre><code><span>#!/usr/bin/env python</span>
<span># -*- coding: utf-8 -*-</span>

<span>import</span> time
<span>import</span> smtplib
<span>from</span> email<span>.</span>header <span>import</span> Header
<span>from</span> email<span>.</span>mime<span>.</span>text <span>import</span> MIMEText

<span># ----- 需要修改的参数 -----</span>
<span># email相关</span>
sender <span>=</span> <span>'snowji@qq.com'</span>
password <span>=</span> <span>'******'</span>
smtp_server <span>=</span> <span>'smtp.qq.com'</span>
smtp_port <span>=</span> <span>465</span>
receivers <span>=</span> <span>[</span><span>'recever1@163.com'</span><span>,</span> <span>'recever2@qq.com'</span><span>]</span>
<span># ------------------------</span>


<span>def</span> <span>send_email</span><span>(</span>subject<span>,</span> detail<span>)</span><span>:</span>
    now_time <span>=</span> time<span>.</span>strftime<span>(</span><span>'%Y-%m-%d %H:%M:%S'</span><span>)</span>
    mail_msg <span>=</span> <span>"""
    时间：{now_time}
    详情：{detail}
    """</span><span>.</span><span>format</span><span>(</span>subject<span>=</span>subject<span>,</span> now_time<span>=</span>now_time<span>,</span> detail<span>=</span>detail<span>)</span>

    msg <span>=</span> MIMEText<span>(</span>mail_msg<span>,</span> <span>'plain'</span><span>,</span> <span>'utf-8'</span><span>)</span>
    msg<span>[</span><span>'From'</span><span>]</span> <span>=</span> Header<span>(</span><span>'snowji汇报人 &lt;%s>'</span> <span>%</span> sender<span>,</span> <span>'utf-8'</span><span>)</span>
    msg<span>[</span><span>'To'</span><span>]</span> <span>=</span> Header<span>(</span><span>'snowji订阅者'</span><span>,</span> <span>'utf-8'</span><span>)</span>
    msg<span>[</span><span>'Subject'</span><span>]</span> <span>=</span> Header<span>(</span>subject<span>,</span> <span>'utf-8'</span><span>)</span>

    <span>try</span><span>:</span>
        smtp <span>=</span> smtplib<span>.</span>SMTP_SSL<span>(</span>smtp_server<span>,</span> smtp_port<span>)</span>
        <span># smtp.set_debuglevel(1)    # 打印和SMTP服务器交互的所有信息</span>
        smtp<span>.</span>login<span>(</span>sender<span>,</span> password<span>)</span>
        smtp<span>.</span>sendmail<span>(</span>sender<span>,</span> receivers<span>,</span> msg<span>.</span>as_string<span>(</span><span>)</span><span>)</span>
        smtp<span>.</span>quit<span>(</span><span>)</span>
        <span>print</span><span>(</span><span>'邮件发送成功'</span><span>)</span>
    <span>except</span> smtplib<span>.</span>SMTPException <span>as</span> e<span>:</span>
        <span>print</span><span>(</span><span>'Error: 无法发送邮件'</span><span>)</span>
        <span>print</span><span>(</span>e<span>)</span>


<span>if</span> __name__ <span>==</span> <span>"__main__"</span><span>:</span>
    email_title <span>=</span> <span>'Python SMTP 纯文本邮件测试'</span>
    detail <span>=</span> <span>"""
    欢迎访问：www.snowji.cn
    这里是 SNOWJI 的测试开发手册，记录测试开发的知识体系
    """</span>
    send_email<span>(</span>email_title<span>,</span> detail<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><h2 id="发送-html-格式的邮件"> 发送 HTML 格式的邮件</h2>
<p>以下实例你需要修改：发件人邮箱（你的 QQ 邮箱），密码，收件人邮箱（可发给自己）</p>
<div><pre><code><span>#!/usr/bin/env python</span>
<span># -*- coding: utf-8 -*-</span>

<span>import</span> time
<span>import</span> smtplib
<span>from</span> email<span>.</span>header <span>import</span> Header
<span>from</span> email<span>.</span>mime<span>.</span>text <span>import</span> MIMEText

<span># ----- 需要修改的参数 -----</span>
<span># email相关</span>
sender <span>=</span> <span>'snowji@qq.com'</span>
password <span>=</span> <span>'******'</span>
smtp_server <span>=</span> <span>'smtp.qq.com'</span>
smtp_port <span>=</span> <span>465</span>
receivers <span>=</span> <span>[</span><span>'recever1@163.com'</span><span>,</span> <span>'recever2@qq.com'</span><span>]</span>
<span># ------------------------</span>


<span>def</span> <span>send_email</span><span>(</span>subject<span>,</span> detail<span>)</span><span>:</span>
    now_time <span>=</span> time<span>.</span>strftime<span>(</span><span>'%Y-%m-%d %H:%M:%S'</span><span>)</span>
    mail_msg <span>=</span> <span>"""
    &lt;h1 style='margin-top:10px;margin-bottom:10px;text-align:center'>{subject}&lt;/h1>
    &lt;hr>
    &lt;h2 style='margin-top:0;margin-bottom:10px'>时间&lt;/h2>
    &lt;div style='margin-left: 40px'>{now_time}&lt;/div>
    &lt;hr>
    &lt;h2 style='margin-top:0;margin-bottom:10px'>详情&lt;/h2>
    &lt;div style='margin-left: 40px'>{detail}&lt;/div>
    &lt;hr>
    """</span><span>.</span><span>format</span><span>(</span>subject<span>=</span>subject<span>,</span> now_time<span>=</span>now_time<span>,</span> detail<span>=</span>detail<span>)</span>

    msg <span>=</span> MIMEText<span>(</span>mail_msg<span>,</span> <span>'html'</span><span>,</span> <span>'utf-8'</span><span>)</span>
    msg<span>[</span><span>'From'</span><span>]</span> <span>=</span> Header<span>(</span><span>'snowji汇报人 &lt;%s>'</span> <span>%</span> sender<span>,</span> <span>'utf-8'</span><span>)</span>
    msg<span>[</span><span>'To'</span><span>]</span> <span>=</span> Header<span>(</span><span>'snowji订阅者'</span><span>,</span> <span>'utf-8'</span><span>)</span>
    msg<span>[</span><span>'Subject'</span><span>]</span> <span>=</span> Header<span>(</span>subject<span>,</span> <span>'utf-8'</span><span>)</span>

    <span>try</span><span>:</span>
        smtp <span>=</span> smtplib<span>.</span>SMTP_SSL<span>(</span>smtp_server<span>,</span> smtp_port<span>)</span>
        <span># smtp.set_debuglevel(1)    # 打印和SMTP服务器交互的所有信息</span>
        smtp<span>.</span>login<span>(</span>sender<span>,</span> password<span>)</span>
        smtp<span>.</span>sendmail<span>(</span>sender<span>,</span> receivers<span>,</span> msg<span>.</span>as_string<span>(</span><span>)</span><span>)</span>
        smtp<span>.</span>quit<span>(</span><span>)</span>
        <span>print</span><span>(</span><span>'邮件发送成功'</span><span>)</span>
    <span>except</span> smtplib<span>.</span>SMTPException <span>as</span> e<span>:</span>
        <span>print</span><span>(</span><span>'Error: 无法发送邮件'</span><span>)</span>
        <span>print</span><span>(</span>e<span>)</span>


<span>if</span> __name__ <span>==</span> <span>"__main__"</span><span>:</span>
    email_title <span>=</span> <span>'Python SMTP HTML格式邮件测试'</span>
    detail <span>=</span> <span>"""
    &lt;div>欢迎访问：&lt;a href="http://www.snowji.cn" target="_blank">www.snowji.cn&lt;/a>&lt;/div>
    &lt;div style='margin-bottom:5px'>这里是 SNOWJI 的测试开发手册，记录测试开发的知识体系。&lt;/div>
    """</span>
    send_email<span>(</span>email_title<span>,</span> detail<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div><h2 id="发送带附件的邮件"> 发送带附件的邮件</h2>
<p>以下实例你需要修改：发件人邮箱（你的 QQ 邮箱），密码，收件人邮箱（可发给自己）</p>
<div><pre><code><span>#!/usr/bin/env python</span>
<span># -*- coding: utf-8 -*-</span>

<span>import</span> time
<span>import</span> smtplib
<span>from</span> email<span>.</span>header <span>import</span> Header
<span>from</span> email<span>.</span>mime<span>.</span>text <span>import</span> MIMEText
<span>from</span> email<span>.</span>mime<span>.</span>multipart <span>import</span> MIMEMultipart

<span># ----- 需要修改的参数 -----</span>
<span># email相关</span>
sender <span>=</span> <span>'snowji@qq.com'</span>
password <span>=</span> <span>'******'</span>
smtp_server <span>=</span> <span>'smtp.qq.com'</span>
smtp_port <span>=</span> <span>465</span>
receivers <span>=</span> <span>[</span><span>'recever1@163.com'</span><span>,</span> <span>'recever2@qq.com'</span><span>]</span>
<span># ------------------------</span>


<span>def</span> <span>send_email</span><span>(</span>subject<span>,</span> detail<span>,</span> attach_list<span>)</span><span>:</span>
    now_time <span>=</span> time<span>.</span>strftime<span>(</span><span>'%Y-%m-%d %H:%M:%S'</span><span>)</span>
    mail_msg <span>=</span> <span>"""
    时间：{now_time}
    详情：{detail}
    """</span><span>.</span><span>format</span><span>(</span>subject<span>=</span>subject<span>,</span> now_time<span>=</span>now_time<span>,</span> detail<span>=</span>detail<span>)</span>

    <span># 创建一个带附件的实例</span>
    msg <span>=</span> MIMEMultipart<span>(</span><span>)</span>
    <span># msg = MIMEText(mail_msg, 'plain', 'utf-8')</span>
    msg<span>[</span><span>'From'</span><span>]</span> <span>=</span> Header<span>(</span><span>'snowji汇报人 &lt;%s>'</span> <span>%</span> sender<span>,</span> <span>'utf-8'</span><span>)</span>
    msg<span>[</span><span>'To'</span><span>]</span> <span>=</span> Header<span>(</span><span>'snowji订阅者'</span><span>,</span> <span>'utf-8'</span><span>)</span>
    msg<span>[</span><span>'Subject'</span><span>]</span> <span>=</span> Header<span>(</span>subject<span>,</span> <span>'utf-8'</span><span>)</span>

    <span># 邮件正文内容</span>
    msg<span>.</span>attach<span>(</span>MIMEText<span>(</span>mail_msg<span>,</span> <span>'plain'</span><span>,</span> <span>'utf-8'</span><span>)</span><span>)</span>
    <span># 构造附件，传送指定目录下的文件</span>
    <span>for</span> att_path <span>in</span> attach_list<span>:</span>
        att <span>=</span> MIMEText<span>(</span><span>open</span><span>(</span>att_path<span>,</span> <span>'rb'</span><span>)</span><span>.</span>read<span>(</span><span>)</span><span>,</span> <span>'base64'</span><span>,</span> <span>'utf-8'</span><span>)</span>
        att<span>[</span><span>"Content-Type"</span><span>]</span> <span>=</span> <span>'application/octet-stream'</span>
        <span># 这里的filename可以任意写，写什么名字，邮件中显示什么名字</span>
        att<span>[</span><span>"Content-Disposition"</span><span>]</span> <span>=</span> <span>'attachment; filename={filename}'</span><span>.</span><span>format</span><span>(</span>filename<span>=</span>att_path<span>)</span>
        msg<span>.</span>attach<span>(</span>att<span>)</span>

    <span>try</span><span>:</span>
        smtp <span>=</span> smtplib<span>.</span>SMTP_SSL<span>(</span>smtp_server<span>,</span> smtp_port<span>)</span>
        <span># smtp.set_debuglevel(1)    # 打印和SMTP服务器交互的所有信息</span>
        smtp<span>.</span>login<span>(</span>sender<span>,</span> password<span>)</span>
        smtp<span>.</span>sendmail<span>(</span>sender<span>,</span> receivers<span>,</span> msg<span>.</span>as_string<span>(</span><span>)</span><span>)</span>
        smtp<span>.</span>quit<span>(</span><span>)</span>
        <span>print</span><span>(</span><span>'邮件发送成功'</span><span>)</span>
    <span>except</span> smtplib<span>.</span>SMTPException <span>as</span> e<span>:</span>
        <span>print</span><span>(</span><span>'Error: 无法发送邮件'</span><span>)</span>
        <span>print</span><span>(</span>e<span>)</span>


<span>if</span> __name__ <span>==</span> <span>"__main__"</span><span>:</span>
    email_title <span>=</span> <span>'Python SMTP 带附件邮件测试'</span>
    detail <span>=</span> <span>"""
    欢迎访问：www.snowji.cn
    这里是 SNOWJI 的测试开发手册，记录测试开发的知识体系。
    附件是网站源码，请查收。
    """</span>
    attach_list <span>=</span> <span>[</span><span>'send_email.py'</span><span>,</span> <span>'README.md'</span><span>]</span>
    send_email<span>(</span>email_title<span>,</span> detail<span>,</span> attach_list<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br></div></div><h2 id="总结"> 总结</h2>
<p>以上就是通过 Python SMTP 发送邮件的代码示例，一般情况下是够用了。还有一些图片 email 等特殊邮件，因为需要考虑到兼容性问题，有些邮箱默认不显示图片，个人感觉不太常用，就不整理了</p>
<h2 id="参考资料"> 参考资料</h2>
<ul>
<li><a href="https://docs.python.org/3/library/smtplib.html" title="smtplib -- SMTP protocol client" target="_blank" rel="noopener noreferrer">smtplib</a></li>
<li><a href="https://docs.python.org/zh-cn/3/library/email.html" title="email -- 电子邮件与 MIME 处理包" target="_blank" rel="noopener noreferrer">email</a></li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T06:24:56.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">使用 xlrd 处理旧版本 Excel</title>
    <id>https://www.snowji.cn/languages/python/modules/python-lib-xlrd/</id>
    <link href="https://www.snowji.cn/languages/python/modules/python-lib-xlrd/"/>
    <updated>2022-09-03T14:10:02.000Z</updated>
    <content type="html"><![CDATA[<h1 id="使用-xlrd-处理旧版本-excel"> 使用 xlrd 处理旧版本 Excel</h1>
<h2 id="关于-xlrd"> 关于 xlrd</h2>
<p>xlrd 用于读取旧版本 Excel（<code>.xls</code>） 中的数据，配合 xlwt 和 xlutils 也可以对 Excel 进行写入和编辑</p>
<p>这三个库的职责分工如下：</p>
<ul>
<li>xlrd：用于读取 Excel 文件</li>
<li>xlwt：用于写入 Excel 文件</li>
<li>xlutils：用于操作 Excel 文件的实用工具，比如复制、分割、筛选等</li>
</ul>
<p>安装比较简单，直接用 pip 工具安装三个库即可，安装命令如下：</p>
<div><pre><code><span>sudo</span> pip <span>install</span> xlrd xlwt xlutils
</code></pre>
<div><span>1</span><br></div></div><h2 id="写入-excel"> 写入 Excel</h2>
<p>下面是一个使用 xlwt 写入数据到 Excel 的代码示例：</p>
<div><pre><code><span>#!/usr/bin/env python</span>
<span># -*- coding: utf-8 -*-</span>

<span>"""
使用第三方库：pip install xlwt
一般用于处理老版本 Excel(.xls)
"""</span>

<span>import</span> xlwt


<span>def</span> <span>write_excel</span><span>(</span><span>)</span><span>:</span>
    <span># 创建 xls 文件对象</span>
    workbook <span>=</span> xlwt<span>.</span>Workbook<span>(</span><span>)</span>

    <span># 新增两个表单页</span>
    sheet_1 <span>=</span> workbook<span>.</span>add_sheet<span>(</span><span>'成绩'</span><span>)</span>
    sheet_2 <span>=</span> workbook<span>.</span>add_sheet<span>(</span><span>'汇总'</span><span>)</span>

    <span># 然后按照位置来添加数据,第一个参数是行，第二个参数是列</span>
    <span># 写入第一个 sheet</span>
    sheet_1<span>.</span>write<span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>'姓名'</span><span>)</span>
    sheet_1<span>.</span>write<span>(</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>'专业'</span><span>)</span>
    sheet_1<span>.</span>write<span>(</span><span>0</span><span>,</span> <span>2</span><span>,</span> <span>'科目'</span><span>)</span>
    sheet_1<span>.</span>write<span>(</span><span>0</span><span>,</span> <span>3</span><span>,</span> <span>'成绩'</span><span>)</span>

    sheet_1<span>.</span>write<span>(</span><span>1</span><span>,</span> <span>0</span><span>,</span> <span>'张三'</span><span>)</span>
    sheet_1<span>.</span>write<span>(</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>'信息与通信工程'</span><span>)</span>
    sheet_1<span>.</span>write<span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>'数值分析'</span><span>)</span>
    sheet_1<span>.</span>write<span>(</span><span>1</span><span>,</span> <span>3</span><span>,</span> <span>88</span><span>)</span>

    sheet_1<span>.</span>write<span>(</span><span>2</span><span>,</span> <span>0</span><span>,</span> <span>'李四'</span><span>)</span>
    sheet_1<span>.</span>write<span>(</span><span>2</span><span>,</span> <span>1</span><span>,</span> <span>'物联网工程'</span><span>)</span>
    sheet_1<span>.</span>write<span>(</span><span>2</span><span>,</span> <span>2</span><span>,</span> <span>'数字信号处理分析'</span><span>)</span>
    sheet_1<span>.</span>write<span>(</span><span>2</span><span>,</span> <span>3</span><span>,</span> <span>95</span><span>)</span>

    sheet_1<span>.</span>write<span>(</span><span>3</span><span>,</span> <span>0</span><span>,</span> <span>'王华'</span><span>)</span>
    sheet_1<span>.</span>write<span>(</span><span>3</span><span>,</span> <span>1</span><span>,</span> <span>'电子与通信工程'</span><span>)</span>
    sheet_1<span>.</span>write<span>(</span><span>3</span><span>,</span> <span>2</span><span>,</span> <span>'模糊数学'</span><span>)</span>
    sheet_1<span>.</span>write<span>(</span><span>3</span><span>,</span> <span>3</span><span>,</span> <span>90</span><span>)</span>

    <span># 写入第二个 sheet</span>
    sheet_2<span>.</span>write<span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>'总分'</span><span>)</span>
    sheet_2<span>.</span>write<span>(</span><span>1</span><span>,</span> <span>0</span><span>,</span> <span>273</span><span>)</span>

    <span># 最后保存文件即可</span>
    workbook<span>.</span>save<span>(</span><span>'student.xls'</span><span>)</span>


<span>if</span> __name__ <span>==</span> <span>"__main__"</span><span>:</span>
    write_excel<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br></div></div><p>运行代码，结果会看到生成名为 student.xls 的 Excel 文件，打开文件查看如下图所示：</p>
<div style="text-align: center;">
  <img src="../images/write-xls-1.png" height="200" alt="使用 xlwt 写入数据到 sheet1">
</div>
<div style="text-align: center;">
  <img src="../images/write-xls-2.png" height="200" alt="使用 xlwt 写入数据到 sheet2">
</div>
<h2 id="读取-excel"> 读取 Excel</h2>
<p>下面是一个使用 xlrd 读取 Excel 数据的代码示例：</p>
<div><pre><code><span>#!/usr/bin/env python</span>
<span># -*- coding: utf-8 -*-</span>

<span>"""
使用第三方库：pip install xlrd
一般用于处理老版本 Excel(.xls)
"""</span>

<span>import</span> xlrd


<span>def</span> <span>read_excel</span><span>(</span><span>)</span><span>:</span>
    <span># 打开刚才我们写入的 student.xls 文件</span>
    workbook <span>=</span> xlrd<span>.</span>open_workbook<span>(</span><span>"student.xls"</span><span>)</span>

    <span># 获取并打印 sheet 数量</span>
    <span>print</span><span>(</span><span>"sheet 数量:"</span><span>,</span> workbook<span>.</span>nsheets<span>)</span>

    <span># 获取并打印 sheet 名称</span>
    <span>print</span><span>(</span><span>"sheet 名称:"</span><span>,</span> workbook<span>.</span>sheet_names<span>(</span><span>)</span><span>)</span>

    <span># 根据 sheet 索引获取内容</span>
    sheet_1 <span>=</span> workbook<span>.</span>sheet_by_index<span>(</span><span>0</span><span>)</span>
    <span># 或者</span>
    <span># 也可根据 sheet 名称获取内容</span>
    <span># sh = workbook.sheet_by_name('成绩')</span>

    <span># 获取并打印该 sheet 行数和列数</span>
    <span>print</span><span>(</span><span>"sheet %s 共 %d 行 %d 列"</span> <span>%</span> <span>(</span>sheet_1<span>.</span>name<span>,</span> sheet_1<span>.</span>nrows<span>,</span> sheet_1<span>.</span>ncols<span>)</span><span>)</span>

    <span># 获取并打印某个单元格的值</span>
    <span>print</span><span>(</span><span>"第一行第二列的值为:"</span><span>,</span> sheet_1<span>.</span>cell_value<span>(</span><span>0</span><span>,</span> <span>1</span><span>)</span><span>)</span>

    <span># 获取整行或整列的值</span>
    rows <span>=</span> sheet_1<span>.</span>row_values<span>(</span><span>0</span><span>)</span>  <span># 获取第一行内容</span>
    cols <span>=</span> sheet_1<span>.</span>col_values<span>(</span><span>1</span><span>)</span>  <span># 获取第二列内容</span>

    <span># 打印获取的行列值</span>
    <span>print</span><span>(</span><span>"第一行的值为:"</span><span>,</span> rows<span>)</span>
    <span>print</span><span>(</span><span>"第二列的值为:"</span><span>,</span> cols<span>)</span>

    <span># 获取单元格内容的数据类型</span>
    <span>print</span><span>(</span><span>"第二行第一列的值类型为:"</span><span>,</span> sheet_1<span>.</span>cell<span>(</span><span>1</span><span>,</span> <span>0</span><span>)</span><span>.</span>ctype<span>)</span>

    <span># 遍历所有表单内容</span>
    <span>for</span> sh <span>in</span> workbook<span>.</span>sheets<span>(</span><span>)</span><span>:</span>
        <span>for</span> r <span>in</span> <span>range</span><span>(</span>sh<span>.</span>nrows<span>)</span><span>:</span>
            <span># 输出指定行</span>
            <span>print</span><span>(</span>sh<span>.</span>row<span>(</span>r<span>)</span><span>)</span>


<span>if</span> __name__ <span>==</span> <span>"__main__"</span><span>:</span>
    read_excel<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><p>输出如下结果：</p>
<div style="text-align: center;">
  <img src="../images/read-xls.png" height="300" alt="使用 xlrd 从 Excel 读取数据">
</div>
<p>从输出结果我们看到：<code>第二行第一列的值类型为: 1</code>，这里返回的<strong>单元格的类型</strong>是个数字，它的实际对应关系如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">数值</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">empty</td>
<td style="text-align:left">空</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">string</td>
<td style="text-align:left">字符串</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">number</td>
<td style="text-align:left">数字</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">date</td>
<td style="text-align:left">日期</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">布尔值</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">error</td>
<td style="text-align:left">错误</td>
</tr>
</tbody>
</table>
<p>通过上面表格，我们可以知道刚才获取单元格类型返回的数字 <code>1</code> 对应的就是字符串类型</p>
<h2 id="修改-excel"> 修改 Excel</h2>
<p>上面介绍了写入和读取 Excel 数据，如果要修改 Excel，就需要用到 xlutils 中的方法了。直接上代码，来看下最简单的修改操作：</p>
<div><pre><code><span>#!/usr/bin/env python</span>
<span># -*- coding: utf-8 -*-</span>

<span>"""
使用第三方库：pip install xlrd xlutils
一般用于处理老版本 Excel(.xls)
"""</span>

<span>import</span> xlrd
<span>from</span> xlutils<span>.</span>copy <span>import</span> copy


<span># 修改 Excel</span>
<span>def</span> <span>edit_excel</span><span>(</span><span>)</span><span>:</span>
    <span># 打开刚才我们写入的 student.xls 文件</span>
    workbook <span>=</span> xlrd<span>.</span>open_workbook<span>(</span><span>"student.xls"</span><span>)</span>

    <span># 复制一份</span>
    new_workbook <span>=</span> copy<span>(</span>workbook<span>)</span>

    <span># 选取第一个表单</span>
    sheet_1 <span>=</span> new_workbook<span>.</span>get_sheet<span>(</span><span>0</span><span>)</span>

    <span># 在第五行新增写入数据</span>
    sheet_1<span>.</span>write<span>(</span><span>4</span><span>,</span> <span>0</span><span>,</span> <span>'王欢'</span><span>)</span>
    sheet_1<span>.</span>write<span>(</span><span>4</span><span>,</span> <span>1</span><span>,</span> <span>'通信工程'</span><span>)</span>
    sheet_1<span>.</span>write<span>(</span><span>4</span><span>,</span> <span>2</span><span>,</span> <span>'机器学习'</span><span>)</span>
    sheet_1<span>.</span>write<span>(</span><span>4</span><span>,</span> <span>3</span><span>,</span> <span>89</span><span>)</span>

    <span># 选取第二个表单</span>
    sheet_2 <span>=</span> new_workbook<span>.</span>get_sheet<span>(</span><span>1</span><span>)</span>

    <span># 替换总成绩数据</span>
    sheet_2<span>.</span>write<span>(</span><span>1</span><span>,</span> <span>0</span><span>,</span> <span>362</span><span>)</span>

    <span># 保存</span>
    new_workbook<span>.</span>save<span>(</span><span>'new_student.xls'</span><span>)</span>


<span>if</span> __name__ <span>==</span> <span>"__main__"</span><span>:</span>
    edit_excel<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><p>从上面代码可以看出，这里的修改 Excel 是通过 xlutils 库的 copy 方法将原来的 Excel 整个复制一份，然后再做修改操作，最后再保存。看下修改结果如下：</p>
<div style="text-align: center;">
  <img src="../images/edit-xls-1.png" height="200" alt="使用 xlutils 修改 sheet1 的数据">
</div>
<div style="text-align: center;">
  <img src="../images/edit-xls-2.png" height="200" alt="使用 xlutils 修改 sheet2 的数据">
</div>
<h2 id="格式化-excel"> 格式化 Excel</h2>
<p>在平时我们使用 Excel 时会对数据进行格式化，或者样式设置，接下来还是使用上面的数据，但在写入时对 Excel 进行格式化，使输出的格式稍微美观一点，代码如下：</p>
<div><pre><code><span>#!/usr/bin/env python</span>
<span># -*- coding: utf-8 -*-</span>

<span>"""
使用第三方库：pip install xlwt
一般用于处理老版本 Excel(.xls)
"""</span>

<span>import</span> xlwt


<span>def</span> <span>format_excel</span><span>(</span><span>)</span><span>:</span>
    <span># 设置写出格式字体红色加粗</span>
    style_head <span>=</span> xlwt<span>.</span>easyxf<span>(</span><span>'font: name Times New Roman, color-index red, bold on'</span><span>)</span>

    <span># 设置数字型格式为小数点后保留两位</span>
    style_num <span>=</span> xlwt<span>.</span>easyxf<span>(</span>num_format_str<span>=</span><span>'#,##0.00'</span><span>)</span>

    <span># 设置日期型格式显示为YYYY-MM-DD</span>
    style_date <span>=</span> xlwt<span>.</span>easyxf<span>(</span>num_format_str<span>=</span><span>'YYYY-MM-DD'</span><span>)</span>

    <span># 创建 xls 文件对象</span>
    workbook <span>=</span> xlwt<span>.</span>Workbook<span>(</span><span>)</span>

    <span># 新增两个表单页</span>
    sheet_1 <span>=</span> workbook<span>.</span>add_sheet<span>(</span><span>'成绩'</span><span>)</span>
    sheet_2 <span>=</span> workbook<span>.</span>add_sheet<span>(</span><span>'汇总'</span><span>)</span>

    <span># 然后按照位置来添加数据，第一个参数是行，第二个参数是列</span>
    sheet_1<span>.</span>write<span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>'姓名'</span><span>,</span> style_head<span>)</span>  <span># 设置表头字体为红色加粗</span>
    sheet_1<span>.</span>write<span>(</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>'日期'</span><span>,</span> style_head<span>)</span>  <span># 设置表头字体为红色加粗</span>
    sheet_1<span>.</span>write<span>(</span><span>0</span><span>,</span> <span>2</span><span>,</span> <span>'成绩'</span><span>,</span> style_head<span>)</span>  <span># 设置表头字体为红色加粗</span>

    <span># 插入数据</span>
    sheet_1<span>.</span>write<span>(</span><span>1</span><span>,</span> <span>0</span><span>,</span> <span>'张三'</span><span>,</span> <span>)</span>
    sheet_1<span>.</span>write<span>(</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>'2021-07-01'</span><span>,</span> style_date<span>)</span>
    sheet_1<span>.</span>write<span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>90</span><span>,</span> style_num<span>)</span>
    sheet_1<span>.</span>write<span>(</span><span>2</span><span>,</span> <span>0</span><span>,</span> <span>'李四'</span><span>)</span>
    sheet_1<span>.</span>write<span>(</span><span>2</span><span>,</span> <span>1</span><span>,</span> <span>'2021-08-02'</span><span>)</span>
    sheet_1<span>.</span>write<span>(</span><span>2</span><span>,</span> <span>2</span><span>,</span> <span>95</span><span>,</span> style_num<span>)</span>

    <span># 设置单元格内容居中的格式</span>
    alignment <span>=</span> xlwt<span>.</span>Alignment<span>(</span><span>)</span>
    alignment<span>.</span>horz <span>=</span> xlwt<span>.</span>Alignment<span>.</span>HORZ_CENTER
    style <span>=</span> xlwt<span>.</span>XFStyle<span>(</span><span>)</span>
    style<span>.</span>alignment <span>=</span> alignment

    <span># 合并 A4，B4 单元格，并将内容设置为居中</span>
    sheet_1<span>.</span>write_merge<span>(</span><span>3</span><span>,</span> <span>3</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>,</span> <span>'总分'</span><span>,</span> style<span>)</span>

    <span># 通过公式，计算 C2+C3 单元格的和</span>
    sheet_1<span>.</span>write<span>(</span><span>3</span><span>,</span> <span>2</span><span>,</span> xlwt<span>.</span>Formula<span>(</span><span>"C2+C3"</span><span>)</span><span>)</span>

    <span># 对 sheet2 写入数据</span>
    sheet_2<span>.</span>write<span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>'总分'</span><span>,</span> style_head<span>)</span>
    sheet_2<span>.</span>write<span>(</span><span>1</span><span>,</span> <span>0</span><span>,</span> <span>185</span><span>)</span>

    <span># 最后保存文件即可</span>
    workbook<span>.</span>save<span>(</span><span>'student.xls'</span><span>)</span>


<span>if</span> __name__ <span>==</span> <span>"__main__"</span><span>:</span>
    format_excel<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br></div></div><p>输出结果：</p>
<div style="text-align: center;">
  <img src="../images/format-xls.png" height="200" alt="使用 xlwt 格式化 Excel 的数据">
 </div>
<p>我们可以对字体、颜色、对齐、合并等平时 Excel 的操作进行设置，也可以格式化日期和数字类型的数据</p>
<p>当然了这里只是介绍了部分功能，想了解更多功能操作可以参考官网</p>
<h2 id="参考资料"> 参考资料</h2>
<ul>
<li><a href="https://pypi.org/project/xlrd/" target="_blank" rel="noopener noreferrer">xlrd</a></li>
<li><a href="https://pypi.org/project/xlwt/" target="_blank" rel="noopener noreferrer">xlwt</a></li>
<li><a href="http://www.python-excel.org/" target="_blank" rel="noopener noreferrer">python-excel</a></li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T06:24:56.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">2020 总结</title>
    <id>https://www.snowji.cn/others/others/2020-summary/</id>
    <link href="https://www.snowji.cn/others/others/2020-summary/"/>
    <updated>2022-08-25T01:58:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_2020-总结"> 2020 总结</h1>
<h2 id="疫情"> 疫情</h2>
<p>2020 不一样的一年，从 1 月份下旬开始，疫情开始爆发。因为突然，家里并没有准备充足的口罩。幸运的是，wuli 男朋友不惜高价在网上买了近 1000 快的口罩寄给了我，至此，在家呆了 2 个多月，直至 3 月初才从外出。</p>
<h2 id="工作"> 工作</h2>
<p>因疫情的影响，前公司的经济效益不好，加上一些个人原因，在 2020 年 3 月份决定跳槽。现在在公司的电商项目组，主要以小程序为主。对我来说也是一个提升，毕竟之前没有电商项目的经验。对于一些电商业务的逻辑也都是从小白开始进阶。经过快 1 年的时间，对于电商的测试技巧和业务理解提升了，但在小程序的性能和安全上还有提升空间。另外，在 12 月，给公司写了一套小程序自动化框架，虽然因为不适用经常迭代的小程序，但是提高了技术。</p>
<h2 id="阅读"> 阅读</h2>
<p>开始接触樊登读书这个 app 是在 wuli 男票的极力推荐下开始使用的，刚开始听书的目的也只是为了了解并解决 2 个人之间的矛盾，到后来是为了提升自己而听。以下是 2020 年阅读(阅读)的书籍：</p>
<p>《运动改造大脑》讲的是运动不仅能降压，也能改变人的思维；</p>
<p>《刻意练习》告诉我们的是杰出不是一种天赋，而是人人都可以学习的技巧，成为杰出的关键就是刻意练习；</p>
<p>《终生成长》可以帮助我们了解自己的思维模式：固定型或成长型，成长型思维的人才能更好的成长；</p>
<p>《关键对话》将帮助你利用沟通技巧，解决生活中难以应对的各种难题；</p>
<p>《先发影响力》</p>
<p>《可复制的领导力》</p>
<p>《非暴力沟通》</p>
<p>《反脆弱》</p>
<p>《思考，快与慢》</p>
<p>《掌控习惯》</p>
<p>《亲密关系》</p>
<p>《终结拖延症》</p>
<h2 id="学习"> 学习</h2>
<p>2020 年在学习方面主要有以下几个方面：</p>
<p>1、面试技巧，为了跳槽二准备</p>
<p>2、性能测试工具 PTS 和小程序的相关知识，主要是为了工作</p>
<p>3、重学 Python，更深的了解 Python 的基础</p>
<p>4、vue-press 框架的学习，主要是制作个人的 blog网站</p>
<h2 id="理财"> 理财</h2>
<p>目前还处于初级阶段，只是了解基金的基础知识，还有高级的知识需要学习。。。。</p>
<h2 id="总结"> 总结</h2>
<p>2020 年虽是不平凡的一年，但在这一年，体会过加班到凌晨的辛苦，体会了电商小程序的业务逻辑。做过小程序的性能测试、自动化测试，总的来说，2020 是充足的一年。2021，新的一年，继续加油！</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T01:58:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">如何写总结</title>
    <id>https://www.snowji.cn/others/others/</id>
    <link href="https://www.snowji.cn/others/others/"/>
    <updated>2022-08-25T01:58:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="如何写总结"> 如何写总结</h1>
<p>整理一些写总结的技巧，提高工作汇报的能力和质量。</p>
<h1 id="团建总结"> 团建总结</h1>
<ul>
<li>2020.09  地点：上海</li>
</ul>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T01:58:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">产品</title>
    <id>https://www.snowji.cn/product-and-operation/operation/</id>
    <link href="https://www.snowji.cn/product-and-operation/operation/"/>
    <updated>2022-08-25T01:58:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="产品"> 产品</h1>
<ul>
<li>产品经理：创造有价值的产品；</li>
<li><strong>产品运营：让产品能有效的发挥出它应有的价值。</strong></li>
</ul>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T01:58:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">如何写总结</title>
    <id>https://www.snowji.cn/others/others/summary/</id>
    <link href="https://www.snowji.cn/others/others/summary/"/>
    <updated>2022-08-25T01:58:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="如何写总结"> 如何写总结</h1>
<h2 id="_1-结构化"> 1. 结构化</h2>
<ul>
<li>切忌记流水账</li>
<li>需要总结</li>
</ul>
<h2 id="_2-文字易懂"> 2. 文字易懂</h2>
<h1 id="_3-ui-美化"> 3. UI 美化</h1>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T01:58:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">产品</title>
    <id>https://www.snowji.cn/product-and-operation/product/</id>
    <link href="https://www.snowji.cn/product-and-operation/product/"/>
    <updated>2022-08-25T01:58:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="产品"> 产品</h1>
<ul>
<li><strong>产品经理：创造有价值的产品；</strong></li>
<li>产品运营：让产品能有效的发挥出它应有的价值。</li>
</ul>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T01:58:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">团建总结</title>
    <id>https://www.snowji.cn/others/others/team-building/</id>
    <link href="https://www.snowji.cn/others/others/team-building/"/>
    <updated>2022-08-25T01:58:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="团建总结"> 团建总结</h1>
<h2 id="_2020-09-地点-上海"> 2020.09  地点：上海</h2>
<p>此次是入职某公司以来参与的第一次团队团建项目。整个团建分为 4 个 项目，前 3 个项目为分组比拼，最后一个项目为整个团队协作的项目。其中每个项目中体现的最对的就是团队合作，还有领导者的领导力。</p>
<p>在前 3 个项目中，不仅体现了同事之间的合作，还有信息之间的共享。在队长分配了任务后，每个人应该对自己需要负责的明确且清楚，在执行时又明确的目标，且在获取信息后，相互之间共享。虽然在最后的一个项目中，过程中有些混乱，但也通过这个项目才会使大家更加认识领导者的统筹，各部门之间的协作以及个人的目标是否明确是非常重要的。</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T01:58:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Python 反射机制</title>
    <id>https://www.snowji.cn/languages/python/basics/reflect/</id>
    <link href="https://www.snowji.cn/languages/python/basics/reflect/"/>
    <updated>2022-09-02T06:24:56.000Z</updated>
    <content type="html"><![CDATA[<h1 id="python-反射机制"> Python 反射机制</h1>
<h2 id="什么是反射机制"> 什么是反射机制</h2>
<p>反射就是一种基于字符串的事件驱动，通过字符串的形式：</p>
<ul>
<li>导入模块</li>
<li>去模块寻找指定函数，并执行</li>
<li>去对象（模块）中操作（查找/获取/删除/添加）成员</li>
</ul>
<p><strong>有四个内置函数</strong>：</p>
<ul>
<li>hasattr()</li>
<li>getattr()</li>
<li>setattr()</li>
<li>delattr()</li>
</ul>
<h2 id="如何使用反射机制"> 如何使用反射机制</h2>
<p>场景：需要根据用户输入 url 的不同，调用不同的函数，实现不同的操作</p>
<p>commons.py 中定义了 3 个函数：</p>
<div><pre><code><span># commons.py</span>

<span>def</span> <span>login</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"这是一个登陆页面！"</span><span>)</span>

<span>def</span> <span>logout</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"这是一个退出页面！"</span><span>)</span>

<span>def</span> <span>home</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"这是网站主页面！"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>要实现输入不同的 url 调用不同的函数，一般我们的思路：</p>
<div><pre><code><span># visit.py</span>

<span>import</span> commons

<span>def</span> <span>run</span><span>(</span><span>)</span><span>:</span>
    inp <span>=</span> <span>input</span><span>(</span><span>"请输入您想访问页面的url：  "</span><span>)</span><span>.</span>strip<span>(</span><span>)</span>
    <span>if</span> inp <span>==</span> <span>"login"</span><span>:</span>
        commons<span>.</span>login<span>(</span><span>)</span>
    <span>elif</span> inp <span>==</span> <span>"logout"</span><span>:</span>
        commons<span>.</span>logout<span>(</span><span>)</span>
    <span>elif</span> inp <span>==</span> <span>"home"</span><span>:</span>
        commons<span>.</span>home<span>(</span><span>)</span>
    <span>else</span><span>:</span>
        <span>print</span><span>(</span><span>"404"</span><span>)</span>

<span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>
    run<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>上述代码可以解决场景中的问题，但是如果 commons 中有成千上百个函数，难道 visit 中要写成千上百个 elif ？</p>
<p>显然这种代码是不合理的？那怎么办？</p>
<p>思路：</p>
<ul>
<li>观察 visit.py 中的代码发现用户输入的 url 字符串和相应调用的函数名好像</li>
<li>如果能用这个字符串直接调用函数就好了</li>
<li>但是字符串是不能用来调用函数的，这就可以使用到 Python 的反射机制</li>
</ul>
<p>修改 visit 的代码：</p>
<div><pre><code><span># visit.py</span>
   <span>import</span> commons 
   
   <span>def</span> <span>run</span><span>(</span><span>)</span><span>:</span>
       inp <span>=</span> <span>input</span><span>(</span><span>"请输入您想访问页面的url：  "</span><span>)</span><span>.</span>strip<span>(</span><span>)</span>
       func <span>=</span> <span>getattr</span><span>(</span>commons<span>,</span>inp<span>)</span>
       func<span>(</span><span>)</span> 
   
   <span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>
       run<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>func = getattr(commons,inp)</p>
<ul>
<li>通过 getattr() 函数，从 commons 模块里，查找到和 inp 字符串“外形”相同的函数名，并将其返回，然后赋值给 func 变量</li>
<li>变量 func 此时就指向那个函数，func() 就可以调用该函数</li>
</ul>
<p>getattr() 函数的使用方法：</p>
<div><pre><code><span>getattr</span><span>(</span>commons<span>,</span>inp<span>)</span>
接收 <span>2</span> 个参数，前面的是一个类或者模块，后面的是一个字符串
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>但上述代码有个问题，就是如果输入的 url 在 commons 中没有同名函数，就会报错，那怎么办？</p>
<p>可以使用 hasattr() 来进行判断</p>
<p>再次修改 visit 的代码：</p>
<div><pre><code><span># visit.py</span>
   <span>import</span> commons 
   
   <span>def</span> <span>run</span><span>(</span><span>)</span><span>:</span>
       inp <span>=</span> <span>input</span><span>(</span><span>"请输入您想访问页面的url：  "</span><span>)</span><span>.</span>strip<span>(</span><span>)</span>
       <span>if</span> <span>hasattr</span><span>(</span>commons<span>,</span>inp<span>)</span><span>:</span>
           func <span>=</span> <span>getattr</span><span>(</span>commons<span>,</span>inp<span>)</span>
           func<span>(</span><span>)</span>
       <span>else</span><span>:</span>
           <span>print</span><span>(</span><span>"404"</span><span>)</span>
   
   <span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>
       run<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="动态导入模块"> 动态导入模块</h2>
<h3 id="为什么要动态导入模块"> 为什么要动态导入模块</h3>
<ul>
<li>上述例子中的是所有处理函数都是在 commons 模块中，但实际中有可能处理函数处于不同的模块中</li>
<li>原则上是需要在 visit 中逐个导入每个视图模块</li>
<li>如果模块比较多，那在 visit 中就会有一堆的 import 语句</li>
</ul>
<p>解决方法：</p>
<p>使用 Python 内置的 <code>__import__(字符串参数)</code> 动态地导入同名的模块</p>
<p>再修改一下 visit.py 的代码：</p>
<div><pre><code><span># visit.py</span>

<span>def</span> <span>run</span><span>(</span><span>)</span><span>:</span>
    inp <span>=</span> <span>input</span><span>(</span><span>"请输入您想访问页面的url：  "</span><span>)</span><span>.</span>strip<span>(</span><span>)</span>
    modules<span>,</span> func <span>=</span> inp<span>.</span>split<span>(</span><span>"/"</span><span>)</span>
    obj <span>=</span> <span>__import__</span><span>(</span>modules<span>)</span>
    <span>if</span> <span>hasattr</span><span>(</span>obj<span>,</span> func<span>)</span><span>:</span>
        func <span>=</span> <span>getattr</span><span>(</span>obj<span>,</span> func<span>)</span>
        func<span>(</span><span>)</span>
    <span>else</span><span>:</span>
        <span>print</span><span>(</span><span>"404"</span><span>)</span>

<span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>
    run<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p><strong>注意</strong>：输入的时候要同时提供模块名和函数名字，并用斜杠分隔</p>
<p>但如果不同的模块在不同的包中呢？那上述的代码就有问题了，可以修改下 run 函数</p>
<div><pre><code><span>def</span> <span>run</span><span>(</span><span>)</span><span>:</span>
    inp <span>=</span> <span>input</span><span>(</span><span>"请输入您想访问页面的url：  "</span><span>)</span><span>.</span>strip<span>(</span><span>)</span>
    modules<span>,</span> func <span>=</span> inp<span>.</span>split<span>(</span><span>"/"</span><span>)</span>
    obj <span>=</span> <span>__import__</span><span>(</span><span>"lib."</span> <span>+</span> modules<span>,</span> fromlist<span>=</span><span>True</span><span>)</span>      <span>#注意字符串的拼接</span>
    <span>if</span> <span>hasattr</span><span>(</span>obj<span>,</span> func<span>)</span><span>:</span>
        func <span>=</span> <span>getattr</span><span>(</span>obj<span>,</span> func<span>)</span>
        func<span>(</span><span>)</span>
    <span>else</span><span>:</span>
        <span>print</span><span>(</span><span>"404"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><p>注意</p>
<ul>
<li><code>__import__()</code> 默认只会导入最开头的圆点左边的目录，也就是lib</li>
<li>需传入 <strong>fromlist=True</strong></li>
</ul>
</div>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T06:24:56.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">偷偷 @ 你，炸鸡分享桶，可得 9.9 现金券案例</title>
    <id>https://www.snowji.cn/product-and-operation/product/mcdonald/</id>
    <link href="https://www.snowji.cn/product-and-operation/product/mcdonald/"/>
    <updated>2022-08-25T01:58:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="偷偷-你-炸鸡分享桶-可得-9-9-现金券案例"> 偷偷 @ 你，炸鸡分享桶，可得 9.9 现金券案例</h1>
<h2 id="一、基本型案例拆解-sop"> 一、基本型案例拆解 SOP</h2>
<h3 id="_1、案例名称"> 1、案例名称</h3>
<p>偷偷 @ 你，炸鸡分享桶，可得 9.9 现金券</p>
<h3 id="_2、案例行业"> 2、案例行业</h3>
<p>快消，食品，新零售</p>
<h3 id="_3、案例目标"> 3、案例目标</h3>
<p>销售产品，建立分销体系</p>
<h3 id="_4、案例标签"> 4、案例标签</h3>
<p>分销</p>
<h3 id="_5、案例路径"> 5、案例路径</h3>
<p><img src="./images/mcdonald.png" alt="" /></p>
<h3 id="_6、产品亮点及可复用"> 6、产品亮点及可复用</h3>
<p>1、活动海报：原价 57.5 元，活动价 39 元，1 桶立省 18.5 元等文案，洞察用户喜欢占便宜的心理，吸引用户扫码进入下单。</p>
<p><img src="./images/mcdonald-hdhb.png" alt="" /></p>
<p>2、活动页面共有两个功能：</p>
<ul>
<li>立即购买</li>
<li>分销商品，超级爆款，“偷偷 @ 你，炸鸡分享桶，可得 9.9 现金券”，“通过海报购买，可获得 9.9 元现金券”醒目的文案，引导用户了解分校机制和操作方法。</li>
</ul>
<p>3、顶部的生成海报按钮和分享按钮，点击即可生成分销海报和生成分享链接，操作简单，有利于用户分享。</p>
<p><img src="./images/mcdonald-hdy.jpg" alt="" /></p>
<p><img src="./images/mcdonald-fxhb.jpg" alt="" /></p>
<h3 id="_7、待优化的点-解决方案"> 7、待优化的点&amp;解决方案</h3>
<p>生成分享海报后，需要先保存图片后，再分享给朋友或分享至朋友圈，不能直接分享，操作有点繁琐</p>
<h3 id="_8、思考的点"> 8、思考的点</h3>
<p>本次活动可以用于线下实体零售店，如面包、奶茶等客单价低的商品，用户分享好友后可以活动现金或者优惠券，提供用户的复购率。</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-25T01:58:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">JMeter 返回数据乱码问题</title>
    <id>https://www.snowji.cn/project/problems/Jmeter/jmeter-messy-code/</id>
    <link href="https://www.snowji.cn/project/problems/Jmeter/jmeter-messy-code/"/>
    <updated>2022-09-10T13:26:06.000Z</updated>
    <content type="html"><![CDATA[<h1 id="jmeter-返回数据乱码问题"> JMeter 返回数据乱码问题</h1>
<h2 id="问题原因"> 问题原因</h2>
<ul>
<li>当响应数据或页面没有设置编码时，JMeter 会按照 jmeter. properties 文件中<code>sampleresult.default.encoding</code> 设置的格式解析</li>
<li>默认是 ISO-8859-1</li>
</ul>
<p><img src="./images/coding1.png" alt="coding" /></p>
<h2 id="解决方法"> 解决方法</h2>
<p>有 2 种方式可以解决</p>
<h3 id="方案一"> 方案一：</h3>
<p>直接修改 jmeter.properties ：</p>
<p>设置 <code>sampleresult.default.encoding = UTF-8</code> 后，并将注释去掉，然后重启 JMeter</p>
<h3 id="方案二"> 方案二：</h3>
<p>使用 BeanShell PostProcessor 动态修改：</p>
<p>在请求节点下，添加 BeanShell PostProcessor，在其脚本框中输入：prev.setDataEncoding(&quot;UTF-8&quot;)</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-30T12:59:30.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">logging 日志重复输出</title>
    <id>https://www.snowji.cn/project/problems/python/logging-repeat-output/</id>
    <link href="https://www.snowji.cn/project/problems/python/logging-repeat-output/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="logging-日志重复输出"> logging 日志重复输出</h1>
<h2 id="问题描述"> 问题描述</h2>
<p>在接口自动化测试框架中，对测试用例增加日志输出时，会重复输出</p>
<p><img src="./images/logging1.png" alt="logging" /></p>
<h2 id="问题分析"> 问题分析</h2>
<p><strong>原因</strong>：没有移除 handler</p>
<p><strong>分析</strong>：</p>
<ul>
<li>在执行 <code>logger = logging.getLogger*(__name__)</code> 时，会先检查内存中是否存在 <code>logger.log</code> 的 logger 对象，存在则取出，不存在则新建</li>
<li>实例化的 logger 对象中有个 handlers 属性来存储 handler
<ul>
<li><code>logger.handlers</code> 起初是个空列表，执行 <code>logger.addHandler(console)</code> 时，会在 handlers 列表中添加一个 StreamHandler，用于输出一条日志</li>
<li>在第二次被调用时，<code>logger.handlers</code> 中已经存在一个 StreamHandler 了，再次执行 <code>logger.addHandler(console)</code> 时，就会在 handlers 中再次添加一个新的 StreamHandler，就会输出两条日志</li>
<li>以此类推，在重复被调用 N 次后，就会不断添加新的 StreamHandler，导致重复输出日志</li>
</ul>
</li>
</ul>
<h2 id="解决方案"> 解决方案</h2>
<p><strong>在日志记录完之后移除 Handler</strong></p>
<h3 id="方案一-推荐"> 方案一（推荐）</h3>
<blockquote>
<p>在 log 方法中做判断，如果已有 handler，则不再添加</p>
<p>这种方式类似于单例模式思想</p>
</blockquote>
<div><pre><code>    <span>if</span> <span>not</span> self<span>.</span>logger<span>.</span>handlers<span>:</span>
        <span># 把控制台日志对象给logging</span>
        self<span>.</span>logger<span>.</span>addHandler<span>(</span>file_log<span>)</span>
        self<span>.</span>logger<span>.</span>addHandler<span>(</span>console<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="方案二"> 方案二</h3>
<blockquote>
<p>每次创建不同 name 的 logger，每次都是新 logger，不会有添加多个 handler 的问题</p>
<p>这种方式会导致内存中会存在很多 logger 对象</p>
</blockquote>
<div><pre><code><span># 每次创建的时候 name 都是不同的</span>
self<span>.</span>logger <span>=</span> logging<span>.</span>getLogger<span>(</span>__name__<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="方案三"> 方案三</h3>
<blockquote>
<p>每次记录完日志之后，调用 removeHandler() 把这个 logger 里的 handler 移除掉</p>
<p>这种方式就会不断的进行添加删除操作</p>
</blockquote>
<div><pre><code>self<span>.</span>logger<span>.</span>removeHandler<span>(</span>console<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-28T13:31:15.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">@pytest.mark.parametrize 参数化</title>
    <id>https://www.snowji.cn/test/frameworks/pytest/@pytest.mark.parametrize/</id>
    <link href="https://www.snowji.cn/test/frameworks/pytest/@pytest.mark.parametrize/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="pytest-mark-parametrize-参数化"> @pytest.mark.parametrize 参数化</h1>
<h2 id="前言"> 前言</h2>
<p>Pytest 可以在以下级别上实现测试参数化：</p>
<ul>
<li><code>pytest.fixture()</code> 允许 fixture 有参数化功能（后面讲解）</li>
<li><code>@pytest.mark.parametrize</code> 允许在测试函数或类中定义多组参数和 fixtures</li>
<li><code>pytest_generate_tests</code> 允许定义自定义参数化方案或扩展（拓展）</li>
</ul>
<h2 id="为什么要参数化"> 为什么要参数化</h2>
<p>先来看个例子：</p>
<div><pre><code>   def test_1():
       assert 3 + 5 == 9
   
   def test_2():
       assert 2 + 4 == 6
   
   def test_3():
       assert 6 + 9 == 15
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>三个用例都是断言 2 个数相加的值，重复写了 3 遍，代码是不是有点冗余</p>
<p>如何改善减少代码，又能执行上面 3 个用例涉及的场景？</p>
<p>这就可以使用参数化实现</p>
<h2 id="如何进行参数化"> 如何进行参数化</h2>
<p>先来看下 parametrize 的源码：</p>
<div><pre><code><span>def</span> <span>parametrize</span><span>(</span>
       self<span>,</span>
       argnames<span>:</span> Union<span>[</span><span>str</span><span>,</span> List<span>[</span><span>str</span><span>]</span><span>,</span> Tuple<span>[</span><span>str</span><span>,</span> <span>.</span><span>.</span><span>.</span><span>]</span><span>]</span><span>,</span>
       argvalues<span>:</span> Iterable<span>[</span>Union<span>[</span>ParameterSet<span>,</span> Sequence<span>[</span><span>object</span><span>]</span><span>,</span> <span>object</span><span>]</span><span>]</span><span>,</span>
       indirect<span>:</span> Union<span>[</span><span>bool</span><span>,</span> Sequence<span>[</span><span>str</span><span>]</span><span>]</span> <span>=</span> <span>False</span><span>,</span>
       ids<span>:</span> Optional<span>[</span>
           Union<span>[</span>Iterable<span>[</span>Optional<span>[</span><span>object</span><span>]</span><span>]</span><span>,</span> Callable<span>[</span><span>[</span>Any<span>]</span><span>,</span> Optional<span>[</span><span>object</span><span>]</span><span>]</span><span>]</span>
       <span>]</span> <span>=</span> <span>None</span><span>,</span>
       scope<span>:</span> <span>"Optional[_ScopeName]"</span> <span>=</span> <span>None</span><span>,</span>
       <span>*</span><span>,</span>
       _param_mark<span>:</span> Optional<span>[</span>Mark<span>]</span> <span>=</span> <span>None</span><span>,</span>
   <span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><strong>argnames</strong> :</p>
<ul>
<li>参数的名字</li>
<li>格式：&quot;arg1,arg2,arg3&quot; 需要用逗号隔开</li>
</ul>
<p><strong>argvalues</strong> :</p>
<ul>
<li>参数值列表</li>
<li>单个参数时，值是列表，如：[1,2,3]</li>
<li>多个参数时，需要使用元组存放多个参数值，如：[(1,2),(2,3)]</li>
</ul>
<p><strong>indirect</strong> :</p>
<ul>
<li>默认 False，如果设置成True，则把传进来的参数当函数执行，而不是一个参数</li>
<li>与 fixture 传参时会用到，后面会讲到</li>
</ul>
<p><strong>ids</strong> :</p>
<ul>
<li>用例的 id ，表示每一个用例</li>
<li>格式：字符串列表</li>
<li>如果 id 为中文时，输出的可能是 unicode 编码，想要显示中文有 2 种方式：
<ul>
<li>conftest.py 文件中使用 pytest-collect-modifyitems 钩子函数，对输出的 item.name 和 item.nodeid 重新编码</li>
</ul>
<div><pre><code>    <span>def</span> pytest<span>-</span>collect<span>-</span>modifyitems<span>(</span>items<span>)</span><span>:</span>
        <span>for</span> item <span>in</span> items<span>:</span>
            item<span>.</span>name <span>=</span> item<span>.</span>name<span>.</span>encode<span>(</span><span>"utf-8"</span><span>)</span><span>.</span>decode<span>(</span><span>"unicode_escape"</span><span>)</span>
            item<span>.</span>_nodeid <span>=</span> item<span>.</span>nodeid<span>.</span>encode<span>(</span><span>"utf-8"</span><span>)</span><span>.</span>decode<span>(</span><span>"unicode_escape"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>
<li>pytest.ini 文件中设置</li>
</ul>
<div><pre><code>   <span>[</span>pytest<span>]</span>
    disable_test_id_escaping_and_forfeit_all_rights_tocommunity_support <span>=</span> <span>True</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
</ul>
<div><p>参数化设置</p>
<p>参数名：用来定义参数的名称</p>
<p>参数值：通过数组定义参数值，每个元组都是一条测试用例的测试数据</p>
<p>ids 参数：默认为 None，用来重新定义测试用例名称</p>
</div>
<p>了解了相关参数的作用，现在来改写上面例子中的测试用例：</p>
<div><pre><code>   @pytest.mark.parametrize(&quot;test_input,expected&quot;, [(&quot;3+5&quot;, 8), (&quot;2+4&quot;, 6), (&quot;6+9&quot;, 15)])
   def test_eval(test_input, expected):
       assert eval(test_input) == expected
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>测试结果：</p>
<p><img src="./images/10.png" alt="pytest" /></p>
<p>可以看到上面结果中执行了 3 次用例</p>
<p>除了上面函数，类和模块也可以使用参数化</p>
<h3 id="测试类使用参数化"> 测试类使用参数化</h3>
<div><pre><code>   @pytest.mark.parametrize(&quot;n,expected&quot;, [(1, 2), (3, 4)])
   class TestClass:
       def test_simple_case(self, n, expected):
           assert n + 1 == expected
   
       def test_weird_simple_case(self, n, expected):
           assert (n * 1) + 1 == expected
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>测试结果：</p>
<p><img src="./images/11.png" alt="pytest" /></p>
<p>可以看出对类进行参数化后，类下的每个测试方法都执行了 2 遍用例</p>
<h3 id="模块使用参数化"> 模块使用参数化</h3>
<div><p>全局参数化设置</p>
<p>如果要参数化模块下的所有用例，需要给全局变量 pytestmark 赋值</p>
</div>
<div><pre><code>   # 模块全局参数化
   pytestmark = pytest.mark.parametrize(&quot;n,expected&quot;, [(1, 2), (3, 4)])
   
   def test_simple_case(n, expected):
       assert n + 1 == expected
   
   def test_weird_simple_case( n, expected):
       assert (n * 1) + 1 == expected
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>测试结果：</p>
<p><img src="./images/12.png" alt="pytest" /></p>
<p>当前模块下的测试每个用例都执行了 2 遍</p>
<h3 id="pytest-mark-parametrize-叠加使用"> pytest.mark.parametrize 叠加使用</h3>
<p>直接看个例子</p>
<div><pre><code><span>import</span> pytest

<span>@pytest<span>.</span>mark<span>.</span>parametrize</span><span>(</span><span>'a,b,c'</span><span>,</span><span>[</span><span>(</span><span>1</span><span>,</span><span>1</span><span>,</span><span>2</span><span>)</span><span>,</span><span>(</span><span>2</span><span>,</span><span>2</span><span>,</span><span>0</span><span>)</span><span>,</span><span>(</span><span>3</span><span>,</span><span>3</span><span>,</span><span>1</span><span>)</span><span>,</span><span>(</span><span>4</span><span>,</span><span>4</span><span>,</span><span>0</span><span>)</span><span>]</span><span>)</span>
<span>def</span> <span>test_1</span><span>(</span>a<span>,</span>b<span>,</span>c<span>)</span><span>:</span>
    <span>print</span><span>(</span>a<span>,</span>b<span>,</span>c<span>)</span>

<span>@pytest<span>.</span>mark<span>.</span>parametrize</span><span>(</span><span>'a'</span><span>,</span><span>[</span><span>11</span><span>,</span><span>12</span><span>]</span><span>,</span>ids<span>=</span><span>[</span><span>'1叠加'</span><span>,</span><span>'2叠加'</span><span>]</span><span>)</span>
<span>@pytest<span>.</span>mark<span>.</span>parametrize</span><span>(</span><span>'b,c'</span><span>,</span><span>[</span><span>(</span><span>21</span><span>,</span><span>31</span><span>)</span><span>,</span><span>(</span><span>22</span><span>,</span><span>32</span><span>)</span><span>]</span><span>,</span>ids<span>=</span><span>[</span><span>'3叠加'</span><span>,</span><span>'4叠加'</span><span>]</span><span>)</span>
<span>def</span> <span>test_1</span><span>(</span>a<span>,</span>b<span>,</span>c<span>)</span><span>:</span>
    <span>print</span><span>(</span>a<span>,</span>b<span>,</span>c<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>执行结果：</p>
<div><pre><code>test_paramtrize<span>.</span>py<span>:</span><span>:</span>test_1<span>[</span><span>3</span>叠加<span>-</span><span>1</span>叠加<span>]</span> <span>11</span> <span>21</span> <span>31</span>
PASSED
test_paramtrize<span>.</span>py<span>:</span><span>:</span>test_1<span>[</span><span>3</span>叠加<span>-</span><span>2</span>叠加<span>]</span> <span>12</span> <span>21</span> <span>31</span>
PASSED
test_paramtrize<span>.</span>py<span>:</span><span>:</span>test_1<span>[</span><span>4</span>叠加<span>-</span><span>1</span>叠加<span>]</span> <span>11</span> <span>22</span> <span>32</span>
PASSED
test_paramtrize<span>.</span>py<span>:</span><span>:</span>test_1<span>[</span><span>4</span>叠加<span>-</span><span>2</span>叠加<span>]</span> <span>12</span> <span>22</span> <span>32</span>
PASSED
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><p>总结</p>
<ul>
<li>叠加使用和不叠加使用同时存在时，优先叠加使用</li>
<li>叠加后，ids 也会叠加，显示的顺序是下面的叠加在上面的前面</li>
<li>参数是组合使用，上面的在前</li>
</ul>
</div>
<h3 id="参数化实际应用场景"> 参数化实际应用场景：</h3>
<div><p>例如：登录场景</p>
<ul>
<li>需要测试账户名正确、密码错误等情况</li>
<li>设计的用例主要就是输入的数据和期望的结果不一样</li>
<li>使用参数化可以简化代码编写</li>
</ul>
</div>
<h2 id="参考文档"> 参考文档</h2>
<p><a href="https://docs.pytest.org/en/latest/how-to/parametrize.html?highlight=mark" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-28T07:39:59.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">问题记录</title>
    <id>https://www.snowji.cn/project/problems/</id>
    <link href="https://www.snowji.cn/project/problems/"/>
    <updated>2022-10-30T05:59:58.000Z</updated>
    <content type="html"><![CDATA[<h1 id="问题记录"> 问题记录</h1>
<p>记录工作和学习中遇到的一些典型问题。</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-28T13:31:15.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">解决 Jenkins 执行找不到 pytest 命令</title>
    <id>https://www.snowji.cn/project/problems/docker/jenkins-notfound-pytest/</id>
    <link href="https://www.snowji.cn/project/problems/docker/jenkins-notfound-pytest/"/>
    <updated>2022-09-08T13:43:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="解决-jenkins-执行找不到-pytest-命令"> 解决 Jenkins 执行找不到 pytest 命令</h1>
<h2 id="问题"> 问题</h2>
<ul>
<li>在 Jenkins 容器中执行 pytest 测试时，可以执行成功</li>
<li>在 Jenkins 中创建实例时，执行同样的命令时，却无法找到 pytest 命令
<img src="./images/jenkins5.png" alt="jenkins" /></li>
</ul>
<h2 id="问题分析"> 问题分析</h2>
<p>可能是 Jenkins 执行时，没有 pytest 命令的权限，导致提示找不到</p>
<h2 id="解决方案"> 解决方案</h2>
<h3 id="方式一"> 方式一</h3>
<p>在 Jenkins 执行 shell 的命令的框首行增加如下信息：</p>
<div><pre><code><span>#!/bin/bash il</span>
</code></pre>
<div><span>1</span><br></div></div><p>添加该命令后，重新构建，构建成功</p>
<h3 id="方式二"> 方式二</h3>
<p>将容器中的环境变量配置到 Jenkins 中</p>
<h4 id="获取容器中的环境变量"> 获取容器中的环境变量</h4>
<div><pre><code><span>echo</span> <span>$PATH</span>

/opt/java/openjdk/bin:/usr/local/src/py3.9/bin:/usr/local/src/allure/bin:/opt/java/openjdk/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id="将环境变量添加到-jenkins-中"> 将环境变量添加到 Jenkins 中</h4>
<ul>
<li>
<p>找到系统设置
<img src="./images/jenkins6.png" alt="jenkins" /></p>
</li>
<li>
<p>进入系统设置中，找到全局属性，并添加
<img src="./images/jenkins7.png" alt="jenkins" /></p>
</li>
<li>
<p>保存之后，重新构建，构建成功</p>
</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-08T13:43:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Pytest</title>
    <id>https://www.snowji.cn/test/frameworks/pytest/</id>
    <link href="https://www.snowji.cn/test/frameworks/pytest/"/>
    <updated>2022-08-27T13:54:00.000Z</updated>
    <content type="html"><![CDATA[<h1 id="pytest"> Pytest</h1>
<h2 id="简介"> 简介</h2>
<p>Pytest 是 Python 的一种单元测试框架，与 Python 自带的 Unittest 测试框架类似，但是比 Unittest 框架使用起来更简洁，效率更高</p>
<p>特点：</p>
<ul>
<li>非常容易上手，入门简单，文档丰富，文档中有很多实例可以参考</li>
<li>能够支持简单的单元测试和复杂的功能测试</li>
<li>支持参数化</li>
<li>执行测试过程中可以将某些测试跳过（skip），或者对某些预期失败的 case 标记成失败</li>
<li>支持重复执行(rerun)失败的 case</li>
<li>支持运行由 nose, Unittest 编写的测试 case</li>
<li>可生成 html 报告</li>
<li>方便的和持续集成工具 jenkins 集成</li>
<li>可支持执行部分用例</li>
<li>具有很多第三方插件，并且可以自定义扩展</li>
</ul>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-27T13:54:00.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">@allure.description/title 使用</title>
    <id>https://www.snowji.cn/test/frameworks/pytest/allure-description-title/</id>
    <link href="https://www.snowji.cn/test/frameworks/pytest/allure-description-title/"/>
    <updated>2022-08-28T07:39:59.000Z</updated>
    <content type="html"><![CDATA[<h1 id="allure-description-title-使用"> @allure.description/title 使用</h1>
<h2 id="allure-description"> @allure.description</h2>
<p><strong>作用</strong>：可以给测试用例添加详细的描述信息</p>
<p><strong>3 种语法格式</strong>：</p>
<ul>
<li>@allure.description(str）</li>
<li>在测试用例函数声明下方添加 &quot;&quot;&quot;  &quot;&quot;&quot;</li>
<li>@allure.description_html(str）：相当于传一个 HTML 代码组成的字符串，类似 <code>allure.attach()</code> 中传 HTML</li>
</ul>
<p>其中第一和第二种方式的效果一样的</p>
<h3 id="示例"> 示例</h3>
<div><pre><code><span>import</span> allure

<span># 方式一</span>
<span>@allure<span>.</span>description</span><span>(</span><span>"""
Multiline test description.
That comes from the allure.description decorator.

Nothing special about it.
"""</span><span>)</span>
<span>def</span> <span>test_description_from_decorator</span><span>(</span><span>)</span><span>:</span>
    <span>assert</span> <span>42</span> <span>==</span> <span>int</span><span>(</span><span>6</span> <span>*</span> <span>7</span><span>)</span>


<span># 方式二</span>
<span>def</span> <span>test_unicode_in_docstring_description</span><span>(</span><span>)</span><span>:</span>
    <span>"""Unicode in description.
    计算乘法
    """</span>
    <span>assert</span> <span>42</span> <span>==</span> <span>int</span><span>(</span><span>6</span> <span>*</span> <span>7</span><span>)</span>
    
<span># 方式三    </span>
<span>@allure<span>.</span>description_html</span><span>(</span><span>"""
&lt;h1>Test with some complicated html description&lt;/h1>
&lt;table style="width:100%">
  &lt;tr>
    &lt;th>Firstname&lt;/th>
    &lt;th>Lastname&lt;/th>
    &lt;th>Age&lt;/th>
  &lt;/tr>
  &lt;tr align="center">
    &lt;td>William&lt;/td>
    &lt;td>Smith&lt;/td>
    &lt;td>50&lt;/td>
  &lt;/tr>
  &lt;tr align="center">
    &lt;td>Vasya&lt;/td>
    &lt;td>Jackson&lt;/td>
    &lt;td>94&lt;/td>
  &lt;/tr>
&lt;/table>
"""</span><span>)</span>
<span>def</span> <span>test_html_description</span><span>(</span><span>)</span><span>:</span>
    <span>assert</span> <span>True</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><h4 id="测试结果"> 测试结果：</h4>
<h5 id="方式一"> 方式一：</h5>
<p><img src="./images/54.png" alt="pytest" /></p>
<h5 id="方式二"> 方式二：</h5>
<p><img src="./images/55.png" alt="pytest" /></p>
<h5 id="方式三"> 方式三：</h5>
<p><img src="./images/56.png" alt="pytest" /></p>
<h2 id="allure-title"> @allure.title</h2>
<p><strong>作用</strong>：</p>
<ul>
<li>可以自定义用例标题，使得测试用例的标题更具有可读性，可以写成中文</li>
<li>支持占位符传递关键字参数（动态标题，结合 <code>@pytest.mark.parametrize</code> 使用）</li>
</ul>
<p><strong>语法格式</strong>:</p>
<div><pre><code><span>@allure<span>.</span>title</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="示例-2"> 示例</h3>
<h4 id="使用-allure-title"> 使用 @allure.title</h4>
<p>先看个简单例子</p>
<div><pre><code><span>@allure<span>.</span>title</span><span>(</span><span>"多个参数{name},{phone},{age}"</span><span>)</span>
<span>@pytest<span>.</span>mark<span>.</span>parametrize</span><span>(</span><span>"name,phone,age"</span><span>,</span> <span>[</span>
    <span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>,</span>
    <span>(</span><span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>)</span><span>,</span>
    <span>(</span><span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>)</span>
<span>]</span><span>)</span>
<span>def</span> <span>test_test_test</span><span>(</span>name<span>,</span> phone<span>,</span> age<span>)</span><span>:</span>
    <span>print</span><span>(</span>name<span>,</span> phone<span>,</span> age<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>测试结果：</p>
<p><img src="./images/58.png" alt="pytest" /></p>
<p><strong>用到一些前面学到的特性和 fixture + parametrize 参数化</strong>:</p>
<div><pre><code><span>import</span> pytest<span>,</span> allure

<span>@allure<span>.</span>title</span><span>(</span><span>"前置操作：登录"</span><span>)</span>
<span>@pytest<span>.</span>fixture</span>
<span>def</span> <span>test_login</span><span>(</span>request<span>)</span><span>:</span>
    params <span>=</span> request<span>.</span>param
    name <span>=</span> params<span>[</span><span>"username"</span><span>]</span>
    pwd <span>=</span> params<span>[</span><span>"pwd"</span><span>]</span>
    allure<span>.</span>attach<span>(</span><span><span>f"这是测试用例传的参数</span><span><span>{</span>params<span>}</span></span><span>"</span></span><span>)</span>
    <span>print</span><span>(</span>name<span>,</span> pwd<span>,</span> params<span>)</span>
    <span>yield</span> name<span>,</span> pwd


<span># 占位符形式设置 title    </span>
<span>@allure<span>.</span>title</span><span>(</span><span>"成功登录，测试数据是：{test_login}"</span><span>)</span>
<span>@pytest<span>.</span>mark<span>.</span>parametrize</span><span>(</span><span>"test_login"</span><span>,</span> <span>[</span>
    <span>{</span><span>"username"</span><span>:</span> <span>"name1"</span><span>,</span> <span>"pwd"</span><span>:</span> <span>"pwd1"</span><span>}</span><span>,</span>
    <span>{</span><span>"username"</span><span>:</span> <span>"name2"</span><span>,</span> <span>"pwd"</span><span>:</span> <span>"pwd2"</span><span>}</span><span>]</span><span>,</span> indirect<span>=</span><span>True</span><span>)</span>
<span>def</span> <span>test_success_login</span><span>(</span>test_login<span>)</span><span>:</span>
    name<span>,</span> pwd <span>=</span> test_login
    allure<span>.</span>attach<span>(</span><span><span>f"账号</span><span><span>{</span>name<span>}</span></span><span>,密码</span><span><span>{</span>pwd<span>}</span></span><span>"</span></span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>测试结果：</p>
<p><img src="./images/57.png" alt="pytest" /></p>
<p>结果中左侧可以看见自定义设置的 title ，右边可以显示一些参数和前置操作</p>
<h2 id="参考资料"> 参考资料</h2>
<p><a href="https://docs.qameta.io/allure/#_pytest" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-28T07:39:59.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">allure 命令行参数</title>
    <id>https://www.snowji.cn/test/frameworks/pytest/allure-command/</id>
    <link href="https://www.snowji.cn/test/frameworks/pytest/allure-command/"/>
    <updated>2022-08-28T07:39:59.000Z</updated>
    <content type="html"><![CDATA[<h1 id="allure-命令行参数"> allure 命令行参数</h1>
<p>可以在 cmd 中输入</p>
<div><pre><code>allure <span>-</span><span>-</span><span>help</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="allure-语法格式"> allure 语法格式</h2>
<div><pre><code>allure <span>[</span>options<span>]</span> <span>[</span>command<span>]</span> <span>[</span>command options<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="options"> options</h3>
<div><pre><code>  Options<span>:</span>   
        <span>-</span><span>-</span><span>help</span>           命令行帮助文档   
        <span>-</span>q<span>,</span> <span>-</span><span>-</span>quiet      切换至安静模式，默认<span>:</span> false    
        <span>-</span>v<span>,</span> <span>-</span><span>-</span>verbose    切换至冗长模式，默认<span>:</span> false    
        <span>-</span><span>-</span>version        版本信息，默认<span>:</span> false
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="command"> command</h3>
<ul>
<li>generate</li>
<li>serve</li>
<li>open</li>
<li>plugin</li>
</ul>
<p>介绍前三个常用的</p>
<h4 id="generate-命令行参数"> generate 命令行参数</h4>
<p>生成 allure 的html 报告</p>
<h5 id="语法格式"> 语法格式</h5>
<div><pre><code>generate [options]  allure 结果目录
</code></pre>
<div><span>1</span><br></div></div><p><strong>注</strong>：allure 结果目录就是运行 pytest 命令，<code>--alluredir</code> 跟的那个目录</p>
<div><pre><code>pytest -sq --alluredir= ./allure
</code></pre>
<div><span>1</span><br></div></div><h5 id="命令选项"> 命令选项</h5>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c,--clean</td>
<td>删除 allure 报告生成的目录，就是 -o 后面的目录</td>
</tr>
<tr>
<td>--config</td>
<td>allure 命令行配置路径，如果指定会覆盖 <code>--profile</code> 和 <code>--configDirectory</code></td>
</tr>
<tr>
<td>--configDirectory</td>
<td>allure 命令行配置目录</td>
</tr>
<tr>
<td>--profile</td>
<td>allure 命令行配置文件</td>
</tr>
<tr>
<td>-o,--report-dir,--output</td>
<td>生成 allure 报告的目录<br />执行命令当前目录下的 <code>allure-report</code>，默认<br />没有目录则自动生成</td>
</tr>
</tbody>
</table>
<p>主要就是用 -c 、 -o 两个参数</p>
<h4 id="open-命令行参数"> open 命令行参数</h4>
<p>打开生成的 allure 报告，就是打开 generate 命令生成的报告</p>
<h5 id="语法格式-2"> 语法格式</h5>
<div><pre><code>open [options] allure报告目录
</code></pre>
<div><span>1</span><br></div></div><p><strong>注</strong>：allure 报告目录就是运行 allure generate 命令，-o 跟的那个目录</p>
<div><pre><code>allure generate -o ./allure-report
</code></pre>
<div><span>1</span><br></div></div><h5 id="命令选项-2"> 命令选项</h5>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-h,--host</td>
<td>该 host 将用于启动报告的 Web 服务器</td>
</tr>
<tr>
<td>-p,--port</td>
<td>该 port 将用于启动报告的 Web 服务器</td>
</tr>
</tbody>
</table>
<h4 id="serve-命令行参数"> serve 命令行参数</h4>
<p>启动 allure 服务，打开 allure 报告</p>
<h5 id="语法格式-3"> 语法格式</h5>
<div><pre><code>serve [options] allure 结果目录
</code></pre>
<div><span>1</span><br></div></div><p><strong>注</strong>：allure 结果目录就是运行 pytest 命令中 <code>--alluredir</code> 后面跟的那个目录</p>
<div><pre><code>pytest -sq --alluredir= ./allure
</code></pre>
<div><span>1</span><br></div></div><h5 id="命令选项-3"> 命令选项</h5>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>--config</td>
<td>allure 命令行配置路径，如果指定会覆盖 <code>--profile</code> 和 <code>--configDirectory</code></td>
</tr>
<tr>
<td>--configDirectory</td>
<td>allure 命令行配置目录</td>
</tr>
<tr>
<td>--profile</td>
<td>allure 命令行配置文件</td>
</tr>
<tr>
<td>-h,--host</td>
<td>该 host 将用于启动报告的 Web 服务器</td>
</tr>
<tr>
<td>-p,--port</td>
<td>该 port 将用于启动报告的 Web 服务器</td>
</tr>
</tbody>
</table>
<h2 id="浏览器打开-allure-报告的两种方式"> 浏览器打开 allure 报告的两种方式</h2>
<h3 id="allure-serve"> allure serve</h3>
<p>标准写法</p>
<div><pre><code><span># 执行 pytest，指定 allure 结果目录 </span>
pytest <span>-</span>sq <span>-</span><span>-</span>alluredir<span>=</span><span>.</span><span>/</span>allure
<span># 打开 allure 报告 </span>
allure serve <span>.</span><span>/</span>allure
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="allure-generate-allure-open"> allure generate + allure open</h3>
<p>标准写法:</p>
<div><pre><code><span># 执行 pytest，指定 allure 结果目录 </span>
pytest <span>-</span>sq <span>-</span><span>-</span>alluredir<span>=</span><span>.</span><span>/</span>allure 
<span># 生成 allure 的 html 报告 </span>
allure generate <span>-</span>c <span>-</span>o <span>.</span><span>/</span>allure<span>-</span>report <span>.</span><span>/</span>allure 
<span># 打开 allure 报告 </span>
allure <span>open</span> <span>.</span><span>/</span>allure<span>-</span>report
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>当然不写 -o 也可以</p>
<h4 id="allure-report-的目录结构"> allure-report 的目录结构</h4>
<p><img src="./images/40.png" alt="pytest" /></p>
<ul>
<li>这种方式的目录会好看很多，不只是一堆 json 文件</li>
<li>而且直接打开 index.html 也是能看到 allure 报告的</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-28T07:39:59.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Allure 环境准备</title>
    <id>https://www.snowji.cn/test/frameworks/pytest/allure-environment/</id>
    <link href="https://www.snowji.cn/test/frameworks/pytest/allure-environment/"/>
    <updated>2022-09-02T02:31:12.000Z</updated>
    <content type="html"><![CDATA[<h1 id="allure-环境准备"> Allure 环境准备</h1>
<p>Allure 是一款界面优美的测试报告</p>
<h2 id="windows-下-allure-环境准备"> Windows 下 Allure 环境准备</h2>
<p><strong>前提</strong>：已安装 Java 环境</p>
<h3 id="下载"> 下载</h3>
<p>下载地址：https://github.com/allure-framework/allure2/releases</p>
<p>这里下载了最新的版本</p>
<h3 id="环境变量设置"> 环境变量设置</h3>
<ul>
<li>
<p>下载完成后，解压到相应目录</p>
</li>
<li>
<p>将目录下的 bin 文件的目录添加到环境变量中</p>
<p><img src="./images/38.png" alt="pytest" /></p>
</li>
<li>
<p>设置完成后，在 cmd 窗口中输入 <code>allure</code> 命令</p>
<p><img src="./images/39.png" alt="pytest" /></p>
<p>出现上述结果说明配置成功</p>
</li>
</ul>
<div><p>注意</p>
<p>配置 Java 的环境变量时，如果使用了变量，在命令行输入 allure 时会报错:</p>
<div><pre><code>ERROR: JAVA_HOME is set to an invalid directory: D:\Program Files\Java\jdk1.8.0_321\bin
Please set the JAVA_HOME variable in your environment to match the
location of your Java installation.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>解决方案：不使用变量，直接添加到 PATH 中</p>
</div>
<h2 id="pytest-下安装-allure-pytest"> pytest 下安装 allure-pytest</h2>
<p>执行命令</p>
<div><pre><code>pip install allure<span>-</span>pytest
</code></pre>
<div><span>1</span><br></div></div><p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T02:31:12.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Allure 主要特性</title>
    <id>https://www.snowji.cn/test/frameworks/pytest/allure-features/</id>
    <link href="https://www.snowji.cn/test/frameworks/pytest/allure-features/"/>
    <updated>2022-08-28T07:39:59.000Z</updated>
    <content type="html"><![CDATA[<h1 id="allure-主要特性"> Allure 主要特性</h1>
<p>Allure 除了可以在命令行敲命令之外，还有一些内置的主要特性</p>
<h2 id="environment"> Environment</h2>
<ul>
<li>
<p>环境变量配置可以添加报告相关的配置参数，如运行的系统环境，版本号，测试环境，测试人员等基本信息</p>
</li>
<li>
<p>默认报告中是没有的</p>
</li>
<li>
<p>用处不大</p>
</li>
</ul>
<h3 id="配置方式"> 配置方式</h3>
<h4 id="方式一"> 方式一</h4>
<p>添加 <code>environment.properties</code> 文件放入 allure 目录中</p>
<div><pre><code>systemVersion<span>=</span>win11
pythonVersion<span>=</span><span>3.10</span><span>.0</span>
allureVersion<span>=</span><span>2.17</span><span>.0</span>
baseUrl<span>=</span>http<span>:</span><span>//</span><span>192.168</span><span>.1</span><span>.</span>x<span>:</span><span>8080</span>
projectName<span>=</span>test
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src="./images/44.png" alt="pytest" /></p>
<h4 id="方式二"> 方式二</h4>
<p>也可以用 <code>environment.xml</code> 文件，格式如下</p>
<div><pre><code><span>&lt;</span>environment<span>></span>
    <span>&lt;</span>parameter<span>></span>
        <span>&lt;</span>key<span>></span>Browser<span>&lt;</span><span>/</span>key<span>></span>
        <span>&lt;</span>value<span>></span>Chrome<span>&lt;</span><span>/</span>value<span>></span>
    <span>&lt;</span><span>/</span>parameter<span>></span>
    <span>&lt;</span>parameter<span>></span>
        <span>&lt;</span>key<span>></span>Browser<span>.</span>Version<span>&lt;</span><span>/</span>key<span>></span>
        <span>&lt;</span>value<span>></span><span>63.0</span><span>&lt;</span><span>/</span>value<span>></span>
    <span>&lt;</span><span>/</span>parameter<span>></span>
    <span>&lt;</span>parameter<span>></span>
        <span>&lt;</span>key<span>></span>Stand<span>&lt;</span><span>/</span>key<span>></span>
        <span>&lt;</span>value<span>></span>Production<span>&lt;</span><span>/</span>value<span>></span>
    <span>&lt;</span><span>/</span>parameter<span>></span>
<span>&lt;</span><span>/</span>environment<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><p>注意</p>
<p>都不可以写中文，会乱码</p>
</div>
<h4 id="报告展示"> 报告展示</h4>
<div><pre><code>pytest -sq --alluredir ./allure
allure serve ./report
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><img src="./images/45.png" alt="pytest" /></p>
<div><p>思考</p>
<p>在运行 Pytest 生成 Allure 报告的时候，有时候需要加 <code>--clean</code> 参数，清楚之前的报告记录，这样会之前清空 report 目录，<code>environment.properties</code> 文件也会被删除，那是不是每次都要重新新建这个文件？</p>
</div>
<p>解决方案：</p>
<p><strong>使用 copy 命令</strong>：</p>
<p>为了不让 <code>environment.properties</code> 文件删除掉，可以把 <code>environment.properties</code> 文件放项目根目录，在运行报告的时候，先 copy 到 allure 目录</p>
<p>Windows：</p>
<div><pre><code>pytest <span>-</span>sq <span>-</span><span>-</span>alluredir <span>.</span><span>/</span>allure <span>-</span><span>-</span>clean

copy environment<span>.</span>properties allure\environment<span>.</span>properties

allure serve <span>.</span><span>/</span>allure
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>Linux 使用 cp 命令：</p>
<div><pre><code>pytest <span>-</span>sq <span>-</span><span>-</span>alluredir <span>.</span><span>/</span>allure <span>-</span><span>-</span>clean
cp environment<span>.</span>properties <span>.</span><span>/</span>allure<span>/</span>environment<span>.</span>properties
allure serve <span>.</span><span>/</span>allure
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="categories"> categories</h2>
<p>测试用例结果的分类</p>
<p>默认情况下，有两类缺陷：</p>
<ul>
<li>Product defects 产品缺陷（测试结果：failed）</li>
<li>Test defects 测试缺陷（测试结果：error/broken）</li>
</ul>
<p>可以创建自定义缺陷分类的，将 <code>categories.json</code> 文件添加到 allure 目录即可（和上面 <code>environment.properties</code> 放同一个目录）</p>
<p>categories.json</p>
<div><pre><code>[
  {
    &quot;name&quot;: &quot;Ignored tests&quot;, 
    &quot;matchedStatuses&quot;: [&quot;skipped&quot;] 
  },
  {
    &quot;name&quot;: &quot;Infrastructure problems&quot;,
    &quot;matchedStatuses&quot;: [&quot;broken&quot;, &quot;failed&quot;],
    &quot;messageRegex&quot;: &quot;.*bye-bye.*&quot; 
  },
  {
    &quot;name&quot;: &quot;Outdated tests&quot;,
    &quot;matchedStatuses&quot;: [&quot;broken&quot;],
    &quot;traceRegex&quot;: &quot;.*FileNotFoundException.*&quot; 
  },
  {
    &quot;name&quot;: &quot;Product defects&quot;,
    &quot;matchedStatuses&quot;: [&quot;failed&quot;]
  },
  {
    &quot;name&quot;: &quot;Test defects&quot;,
    &quot;matchedStatuses&quot;: [&quot;broken&quot;]
  }
]
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><ul>
<li><strong>name</strong>：分类名称，<strong>可以是中文哦</strong></li>
<li><strong>matchedStatuses</strong>：测试用例的运行状态，默认[&quot;failed&quot;, &quot;broken&quot;, &quot;passed&quot;, &quot;skipped&quot;, &quot;unknown&quot;]</li>
<li><strong>messageRegex</strong>：测试用例运行的错误信息，默认是 .* ，是通过正则去匹配的</li>
<li><strong>traceRegex</strong>：测试用例运行的错误堆栈信息，默认是 .* ，也是通过正则去匹配的</li>
</ul>
<h2 id="flaky-test"> Flaky test</h2>
<p>可以将整个测试类标记为 Flaky</p>
<p><strong>用法</strong>：在类或者方法上直接加 @Flaky</p>
<h3 id="flaky-是什么"> Flaky 是什么</h3>
<ul>
<li>简单来说就是，不够稳定的测试用例集，有可能前阵子还运行成功，过阵子就运行失败，理解成“闪烁”</li>
<li>标记成 Flaky 的好处就是：当用例失败的情况下，我们能获取足够详细的信息，毕竟有可能某些测试用例是非常重要的</li>
<li>如果不标记为 Flaky 的话，可能就要禁用这些测试</li>
</ul>
<h2 id="参考资料"> 参考资料：</h2>
<p><a href="https://docs.qameta.io/allure/#_features" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-28T07:39:59.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Pytest + Allure 基础使用</title>
    <id>https://www.snowji.cn/test/frameworks/pytest/allure-pytest/</id>
    <link href="https://www.snowji.cn/test/frameworks/pytest/allure-pytest/"/>
    <updated>2022-08-28T07:39:59.000Z</updated>
    <content type="html"><![CDATA[<h1 id="pytest-allure-基础使用"> Pytest + Allure 基础使用</h1>
<h2 id="为什么要使用-allure"> 为什么要使用 Allure</h2>
<p>官方介绍：</p>
<ul>
<li>Allure Framework 是一种灵活的轻量级多语言测试报告工具，不仅可以以简洁的 Web 报告形式非常简洁地显示已测试的内容，也允许参与开发过程的每个人从日常测试中提取最大程度的有用信息</li>
<li>从开发/质量保证的角度来看，Allure 报告可以缩短常见缺陷的生命周期：可以将测试失败划分为 Bug 和损坏的测试，还可以配置 log，step，fixture，attachments，timings，历史记录以及与 TMS 的集成以及 Bug 跟踪系统，因此负责任的开发人员和测试人员将掌握所有信息</li>
<li>从管理人员的角度来看，Allure 提供了一个清晰的“全局”，涵盖了已涵盖的功能，缺陷聚集的位置，执行时间表的外观以及许多其他方便的事情</li>
<li>Allure 的模块化和可扩展性确保您始终能够微调某些东西，以使 Allure 更适合您</li>
</ul>
<p>总结：</p>
<ul>
<li>Allure 可以很直观、简洁的展示数据</li>
<li>相比于 pytest-html 报告来说，界面美观</li>
</ul>
<h2 id="如何使用-allure"> 如何使用 Allure</h2>
<h3 id="环境配置"> 环境配置</h3>
<p>之前已经讲过如何配置 Allure 的环境，可参考：[Allure 环境配置](/test/auto-test/pytest/allure 环境准备)</p>
<h3 id="示例"> 示例</h3>
<ul>
<li>allure-pytest 生成 allure 报告的 json 文件</li>
</ul>
<div><pre><code>pytest <span>-</span>sq <span>-</span><span>-</span>alluredir<span>=</span><span>.</span><span>/</span>alure 
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>运行完成后，可以看到当前目录下生成了 json 文件</li>
</ul>
<p><img src="./images/41.png" alt="pytest" /></p>
<ul>
<li>在 cmd 中当前目录下输入</li>
</ul>
<div><pre><code>G:\pytest_demo&gt;allure generate -c -o ./allure-report ./allure
</code></pre>
<div><span>1</span><br></div></div><p>会生成 .html 的报告，可以在浏览器中打开</p>
<p><img src="./images/40.png" alt="pytest" /></p>
<p><img src="./images/42.png" alt="pytest" /></p>
<p>查看用例明细：</p>
<p><img src="./images/43.png" alt="pytest" /></p>
<ul>
<li><strong>parameters</strong>：如果用了 @pytest.mark.parametrize ，在右侧的 parameters 是可以看到传了什么参数和对应的值</li>
<li><strong>set up</strong>：调用 fixture 的前置操作</li>
<li><strong>tear down</strong>：调用 fixture 的后置操作</li>
<li><strong>Description</strong>：测试用例的描述</li>
</ul>
<div><p>注意</p>
<ul>
<li>
<p>上述 cmd 中输入的命令，会在目录下生成一个文件夹，里面包含 .html 文件，可在浏览器中打开</p>
</li>
<li>
<p>如果使用 <code>allure serve allure</code> 会自动打开测试报告，且不会生成 .html 文件</p>
</li>
</ul>
</div>
<h2 id="allure报告结构"> Allure报告结构</h2>
<ul>
<li>Overview：总览</li>
<li>Categories：类别，默认是分了 failed 和 error，凡是执行结果是其中一个的都会被归到类里面，可以通过这里快捷查看哪些用例是 failed 和 error 的</li>
</ul>
<ul>
<li>Suites：测试套件，就是所有用例的层级关系，可以根据 package、module、类、方法来查找用例</li>
<li>Graphs：测试结果图形化，包括用例执行结果的分布图，优先级，耗时等</li>
<li>Timeline：可以看到测试用例精确的测试时序（执行顺序），包括执行时间</li>
<li>Behaviors：行为驱动，根据 epic、feature、story 来分组测试用例（后面会讲到）</li>
<li>Packages：这就是按照 package、module 来分组测试用例了</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-28T07:39:59.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">@allure.step/@allure.attach 使用</title>
    <id>https://www.snowji.cn/test/frameworks/pytest/allure-step-attach/</id>
    <link href="https://www.snowji.cn/test/frameworks/pytest/allure-step-attach/"/>
    <updated>2022-08-28T07:39:59.000Z</updated>
    <content type="html"><![CDATA[<h1 id="allure-step-allure-attach-使用"> @allure.step/@allure.attach 使用</h1>
<h2 id="allure-step"> @allure.step</h2>
<ul>
<li>可以理解为我们编写测试用例中的每一步操作步骤，而在 allure 中表示对每个测试用例进行非常详细的步骤说明</li>
<li>通过 <code>@allure.step()</code> 可以让测试用例在 allure 报告中显示更详细的测试过程</li>
</ul>
<h3 id="示例"> 示例</h3>
<div><pre><code><span>import</span> allure

<span>@allure<span>.</span>step</span><span>(</span><span>"打开网站首页"</span><span>)</span>
<span>def</span> <span>open</span><span>(</span><span>)</span><span>:</span>
    <span>pass</span>

<span>@allure<span>.</span>step</span><span>(</span><span>"输入账号、密码"</span><span>)</span>
<span>def</span> <span>input_UsernameAndPassWord</span><span>(</span><span>)</span><span>:</span>
    sendAndClickLogin<span>(</span><span>"xiaoqiang"</span><span>,</span> <span>"1"</span><span>)</span>

<span>@allure<span>.</span>step</span><span>(</span><span>"输入账号、密码{arg1}，{arg2}，并点击登录"</span><span>)</span>
<span>def</span> <span>sendAndClickLogin</span><span>(</span>arg1<span>,</span> arg2<span>)</span><span>:</span>
    <span>pass</span>

<span>@allure<span>.</span>step</span><span>(</span><span>"验证登录过程"</span><span>)</span>
<span>def</span> <span>test_login</span><span>(</span><span>)</span><span>:</span>
    <span>open</span><span>(</span><span>)</span>
    input_UsernameAndPassWord<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>测试报告显示：</p>
<p><img src="./images/51.png" alt="pytest" /></p>
<div><p>总结</p>
<ul>
<li>step(param)，参数就是标题，你传什么，在 allure 上的步骤名就显示什么</li>
<li>支持位置参数和关键字参数 {arg1}，{arg2}，可参考报告中“ 输入账号、密码 'xiaoqiang'，'1'，并点击登录”处，如果函数的参数没有匹配成功就会报错</li>
</ul>
</div>
<h2 id="allure-attach"> @allure.attach</h2>
<p><strong>作用</strong>：allure 报告还支持显示许多不同类型的附件，可以补充测试结果</p>
<h3 id="两种语法格式"> 两种语法格式</h3>
<h4 id="语法一"> 语法一：</h4>
<div><pre><code>allure<span>.</span>attach<span>(</span>body<span>,</span> name<span>,</span> attachment_type<span>,</span> extension<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>参数列表</strong>：</p>
<ul>
<li>body：要显示的内容（附件）</li>
<li>name：附件名字</li>
<li>attachment_type：附件类型，是 <code>allure.attachment_type</code> 里面的其中一种</li>
<li>extension：附件的扩展名（比较少用）</li>
</ul>
<p>allure.attachment_type 提供的附件类型:</p>
<div><pre><code>TEXT <span>=</span> <span>(</span><span>"text/plain"</span><span>,</span> <span>"txt"</span><span>)</span>
CSV <span>=</span> <span>(</span><span>"text/csv"</span><span>,</span> <span>"csv"</span><span>)</span>
TSV <span>=</span> <span>(</span><span>"text/tab-separated"</span><span>,</span> <span>"tsv"</span><span>)</span>
URi_LIST <span>=</span> <span>(</span><span>"text/uri-list"</span><span>,</span> <span>"uri"</span><span>)</span>

HTML <span>=</span> <span>(</span><span>"text/html"</span><span>,</span> <span>"html"</span><span>)</span>
XML <span>=</span> <span>(</span><span>"application/xml"</span><span>,</span> <span>"xml"</span><span>)</span>
JSON <span>=</span> <span>(</span><span>"application/json"</span><span>,</span> <span>"json"</span><span>)</span>
YAML <span>=</span> <span>(</span><span>"application/yaml"</span><span>,</span> <span>"yaml"</span><span>)</span>
PCAP <span>=</span> <span>(</span><span>"application/vnd.tcpdump.pcap"</span><span>,</span> <span>"pcap"</span><span>)</span>

PNG <span>=</span> <span>(</span><span>"image/png"</span><span>,</span> <span>"png"</span><span>)</span>
JPG <span>=</span> <span>(</span><span>"image/jpg"</span><span>,</span> <span>"jpg"</span><span>)</span>
SVG <span>=</span> <span>(</span><span>"image/svg-xml"</span><span>,</span> <span>"svg"</span><span>)</span>
GIF <span>=</span> <span>(</span><span>"image/gif"</span><span>,</span> <span>"gif"</span><span>)</span>
BMP <span>=</span> <span>(</span><span>"image/bmp"</span><span>,</span> <span>"bmp"</span><span>)</span>
TIFF <span>=</span> <span>(</span><span>"image/tiff"</span><span>,</span> <span>"tiff"</span><span>)</span>

MP4 <span>=</span> <span>(</span><span>"video/mp4"</span><span>,</span> <span>"mp4"</span><span>)</span>
OGG <span>=</span> <span>(</span><span>"video/ogg"</span><span>,</span> <span>"ogg"</span><span>)</span>
WEBM <span>=</span> <span>(</span><span>"video/webm"</span><span>,</span> <span>"webm"</span><span>)</span>

PDF <span>=</span> <span>(</span><span>"application/pdf"</span><span>,</span> <span>"pdf"</span><span>)</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h4 id="语法二"> 语法二</h4>
<div><pre><code>allure<span>.</span>attach<span>.</span><span>file</span><span>(</span>source<span>,</span> name<span>,</span> attachment_type<span>,</span> extension<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>参数列表</strong>：</p>
<ul>
<li>source : 文件路径，相当于传一个文件</li>
<li>其他参数和语法一中的一样</li>
</ul>
<h3 id="示例-2"> 示例</h3>
<div><pre><code><span>import</span> allure
<span>import</span> pytest

<span>@pytest<span>.</span>fixture</span>
<span>def</span> <span>attach_file_in_module_scope_fixture_with_finalizer</span><span>(</span>request<span>)</span><span>:</span>
    allure<span>.</span>attach<span>(</span><span>'A text attacment in module scope fixture'</span><span>,</span> <span>'blah blah blah'</span><span>,</span> allure<span>.</span>attachment_type<span>.</span>TEXT<span>)</span>
    <span>def</span> <span>finalizer_module_scope_fixture</span><span>(</span><span>)</span><span>:</span>
        allure<span>.</span>attach<span>(</span><span>'A text attacment in module scope finalizer'</span><span>,</span> <span>'blah blah blah blah'</span><span>,</span>
                      allure<span>.</span>attachment_type<span>.</span>TEXT<span>)</span>
    request<span>.</span>addfinalizer<span>(</span>finalizer_module_scope_fixture<span>)</span>

<span>def</span> <span>test_with_attacments_in_fixture_and_finalizer</span><span>(</span>attach_file_in_module_scope_fixture_with_finalizer<span>)</span><span>:</span>
    <span>pass</span>

<span>def</span> <span>test_multiple_attachments</span><span>(</span><span>)</span><span>:</span>
    allure<span>.</span>attach<span>.</span><span>file</span><span>(</span><span>'./result.json'</span><span>,</span> attachment_type<span>=</span>allure<span>.</span>attachment_type<span>.</span>JSON<span>)</span>
    allure<span>.</span>attach<span>(</span><span>'&lt;head>&lt;/head>&lt;body> a page &lt;/body>'</span><span>,</span> <span>'Attach with HTML type'</span><span>,</span> allure<span>.</span>attachment_type<span>.</span>HTML<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p><strong>运行结果</strong>：</p>
<p>txt 附件：</p>
<p><img src="./images/52.png" alt="pytest" /></p>
<p>用 allure.attach() 来插入一段自己写的 HTML 和 allure.attach.file() 来导入一个已存在的 JSON 文件</p>
<p><img src="./images/53.png" alt="pytest" /></p>
<h2 id="参考资料"> 参考资料</h2>
<p><a href="https://docs.qameta.io/allure/#_pytest" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-28T07:39:59.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">assert 断言</title>
    <id>https://www.snowji.cn/test/frameworks/pytest/assert/</id>
    <link href="https://www.snowji.cn/test/frameworks/pytest/assert/"/>
    <updated>2022-08-28T07:39:59.000Z</updated>
    <content type="html"><![CDATA[<h1 id="assert-断言"> assert 断言</h1>
<h2 id="前言"> 前言</h2>
<p>回顾下 Unittest 的断言：</p>
<ul>
<li>assertIn（expect，result）断言包含（被包含的写前面）</li>
<li>assertEqual（expect，result）断言相等</li>
<li>assertTure（条件）断言是否为真。返回 Ture 或 False</li>
</ul>
<p>Pytest 与 Unittest 不同，直接使用 Python 中 <strong>assert</strong> 关键字进行断言，关键字可接表达式，表达式值为 true 则通过，否则失败</p>
<h2 id="常用断言"> 常用断言</h2>
<ul>
<li>assert xx：判断 xx 为真</li>
<li>assert not xx：判断 xx 不为真</li>
<li>assert a in b：判断 b 包含 a</li>
<li>assert a == b：判断 a 等于 b</li>
<li>assert a !=b：判断 a 不等于 b</li>
</ul>
<h3 id="实例"> 实例</h3>
<p>想在异常的时候，输出一些提示信息，这样报错后，就方便查看是什么原因了</p>
<div><pre><code><span>def</span> <span>f</span><span>(</span><span>)</span><span>:</span>
    <span>return</span> <span>3</span>

<span>def</span> <span>test_function</span><span>(</span><span>)</span><span>:</span>
    a <span>=</span> f<span>(</span><span>)</span>
    <span>assert</span> a <span>%</span> <span>2</span> <span>==</span><span>0</span><span>,</span><span>"判断 a 为偶数，当前 a 的值为：%s"</span><span>%</span>a
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>结果：</p>
<p><img src="./images/7.png" alt="pytest" /></p>
<h2 id="异常断言"> 异常断言</h2>
<p>可以使用 pytest.raises 作为上下文管理器，当抛出异常时可以获取到对应的异常实例</p>
<div><pre><code><span>def</span> <span>test_zero_division</span><span>(</span><span>)</span><span>:</span>
    <span>with</span> pytest<span>.</span>raises<span>(</span>ZeroDivisionError<span>)</span><span>:</span>
        <span>1</span> <span>/</span> <span>0</span>
    <span>assert</span> <span>eval</span><span>(</span><span>"1+2"</span><span>)</span> <span>==</span><span>3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>结果：</p>
<p><img src="./images/8.png" alt="pytest" /></p>
<p>可以看到 raises 捕获了异常，并继续下面断言代码</p>
<div><p>注意</p>
<p>使用 <code>pytest.raises</code> 作为上下文管理器，是上下文管理器范围内的最后一行
后面在上下文管理器范围内的代码行将不会被执行</p>
</div>
<p>在捕获异常后，可以从上下文管理器中获取异常的一些详细信息，可以辅助我们更好的去断言</p>
<h3 id="实例-2"> 实例</h3>
<p><strong>断言场景</strong>：断言它抛的异常是不是预期想要的</p>
<p><strong>代码执行</strong>：1/0</p>
<p><strong>预期结果</strong>：抛的异常是 <code>ZeroDivisionError: division by zero</code></p>
<p><strong>如何断言</strong>：通常是断言异常的 type 和 value 值了</p>
<p><strong>具体方式</strong>：这里 1/0 的异常类型是 ZeroDivisionError，异常的 value 值是 <code>division by zero</code></p>
<div><pre><code><span>def</span> <span>test_zero_division</span><span>(</span><span>)</span><span>:</span>
    <span>'''断言异常'''</span>
    <span>with</span> pytest<span>.</span>raises<span>(</span>ZeroDivisionError<span>)</span> <span>as</span> excinfo<span>:</span>
        <span>1</span> <span>/</span> <span>0</span>

    <span># 断言异常类型type</span>
    <span>assert</span> excinfo<span>.</span><span>type</span> <span>==</span> ZeroDivisionError
    <span># 断言异常value值</span>
    <span>assert</span> <span>"division by zero"</span> <span>in</span> <span>str</span><span>(</span>excinfo<span>.</span>value<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>excinfo ：是一个异常信息实例</p>
<p><strong>主要属性</strong>：<code>.type</code> 、<code>.value</code> 、<code>.traceback</code></p>
<p><strong>注意</strong>：断言 type 的时候，异常类型是不需要加引号的，断言 value 值的时候需转 str</p>
<h3 id="match-参数"> match 参数</h3>
<p>可以将 match 关键字参数传递给上下文管理器，以测试正则表达式与异常的字符串表示形式是否匹配</p>
<p><strong>注意</strong>：这种方法只能断言 value，不能断言 type</p>
<div><pre><code># 自定义消息
def myfunc():
    raise ValueError(&quot;Exception 123 raised&quot;)

def test_match():
    with pytest.raises(ValueError, match=r&quot;.* 123 .*&quot;):
        myfunc()
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>该 match 方法的 regexp 参数与 <code>re.search</code> 函数匹配，因此在上面的示例中 <code>match='123'</code> 也可以使用</p>
<h3 id="检查断言装饰器"> 检查断言装饰器</h3>
<div><pre><code>@pytest.mark.xfail(raises=ZeroDivisionError)
def test_f():
    1 / 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src="./images/9.png" alt="pytest" /></p>
<div><p>总结</p>
<ul>
<li>代码抛出异常，但是和 raises 指定的异常类相匹配，所以不会断言失败</li>
<li>它相当于一个检查异常装饰器，功能：检查是否有异常，不确定是否有异常</li>
<li><code>with pytest.raise(ZeroDivisionError)</code> 对于故意测试异常代码的情况，使用可能会更好</li>
<li>而 <code>@pytest.mark.xfail(raises=ZeroDivisionError)</code> 对于检查未修复的错误（即，可能会发生异常），使用检查断言可能会更好</li>
</ul>
</div>
<h2 id="参考资料"> 参考资料</h2>
<p><a href="https://docs.pytest.org/en/latest/how-to/assert.html#assertraises" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-28T07:39:59.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">request</title>
    <id>https://www.snowji.cn/test/frameworks/pytest/fixture-request/</id>
    <link href="https://www.snowji.cn/test/frameworks/pytest/fixture-request/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="request"> request</h1>
<h2 id="作用"> 作用</h2>
<ul>
<li>获取 fixture 参数 params 的值，实现参数化</li>
<li>与 <code>@pytest.mark.parametrize</code> 结合实现参数化</li>
</ul>
<h2 id="request-params"> request + params</h2>
<p>前面在讲 fixture 的参数时，已经讲过 request 如何获取 params 的值，这里就不在讲述了</p>
<p>具体可以参考 <a href="/test/frameworks/pytest/fixture-params">fixture 参数之 params</a></p>
<h2 id="request-pytest-mark-parametrize"> request + <code>@pytest.mark.parametrize</code></h2>
<p>在 fixture 前置操作中使用参数化</p>
<h3 id="request-传入单个参数"> request 传入单个参数</h3>
<div><pre><code><span>import</span> pytest

<span># 单个传参</span>

test_user <span>=</span> <span>[</span><span>"admin1"</span><span>,</span><span>"admin2"</span><span>]</span>

<span>@pytest<span>.</span>fixture</span>
<span>def</span> <span>login</span><span>(</span>request<span>)</span><span>:</span>
    user <span>=</span> request<span>.</span>param
    <span>print</span><span>(</span><span>"{}登录成功"</span><span>.</span><span>format</span><span>(</span>user<span>)</span><span>)</span>
    <span>return</span> user

<span>@pytest<span>.</span>mark<span>.</span>parametrize</span><span>(</span><span>"login"</span><span>,</span>test_user<span>,</span>indirect<span>=</span><span>True</span><span>)</span>
<span>def</span> <span>test_001</span><span>(</span>login<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"执行测试用例1"</span><span>)</span>
    <span>assert</span> login <span>!=</span> <span>""</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>执行结果：</p>
<p><img src="./images/28.png" alt="pytest" /></p>
<div><p>注意</p>
<ul>
<li><code>indirect=True</code> 参数是为了把 login 当成一个函数去执行，而不是参数</li>
<li><code>def test_login(login)</code> 就是 login 的返回值</li>
</ul>
</div>
<h3 id="request-传入多个参数"> request 传入多个参数</h3>
<ul>
<li>多个参数时，需要使用字典去存储</li>
<li>不同的参数取对应的 key 值</li>
</ul>
<div><pre><code><span>import</span> pytest
test_user <span>=</span> <span>[</span><span>{</span><span>"user"</span><span>:</span> <span>"admin1"</span><span>,</span> <span>"psw"</span><span>:</span> <span>"111111"</span><span>}</span><span>,</span>
                  <span>{</span><span>"user"</span><span>:</span> <span>"admin1"</span><span>,</span> <span>"psw"</span><span>:</span> <span>""</span><span>}</span><span>]</span>

<span>@pytest<span>.</span>fixture</span>
<span>def</span> <span>login</span><span>(</span>request<span>)</span><span>:</span>
    user <span>=</span> request<span>.</span>param<span>[</span><span>"user"</span><span>]</span>
    pwd <span>=</span> request<span>.</span>param<span>[</span><span>"psw"</span><span>]</span>
    <span>print</span><span>(</span><span>"登录账户：{}"</span><span>.</span><span>format</span><span>(</span>user<span>)</span><span>)</span>
    <span>print</span><span>(</span><span>"账户密码：{}"</span><span>.</span><span>format</span><span>(</span>pwd<span>)</span><span>)</span>
    <span>if</span> pwd<span>:</span>
        <span>return</span> <span>True</span>
    <span>else</span><span>:</span>
        <span>return</span> <span>False</span>

<span>@pytest<span>.</span>mark<span>.</span>parametrize</span><span>(</span><span>"login"</span><span>,</span>test_user<span>,</span>indirect<span>=</span><span>True</span><span>)</span>
<span>def</span> <span>test_001</span><span>(</span>login<span>)</span><span>:</span>
    a <span>=</span> login
    <span>print</span><span>(</span><span>"测试用例中login的返回值:%s"</span> <span>%</span> a<span>)</span>
    <span>assert</span> a<span>,</span> <span>"失败原因：密码为空"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>测试结果：</p>
<p><img src="./images/29.png" alt="pytest" /></p>
<h3 id="多个-fixture-使用一个-pytest-mark-parametrize"> 多个 fixture 使用一个 <code>@pytest.mark.parametrize</code></h3>
<div><pre><code>test_user <span>=</span> <span>[</span><span>(</span> <span>"admin1"</span><span>,</span><span>"111111"</span><span>)</span><span>,</span><span>(</span><span>"admin2"</span><span>,</span><span>"222"</span><span>)</span><span>]</span>
<span>@pytest<span>.</span>fixture</span>
<span>def</span> <span>input_user</span><span>(</span>request<span>)</span><span>:</span>
    user <span>=</span> request<span>.</span>param
    <span>print</span><span>(</span><span>"登录账户：%s"</span> <span>%</span> user<span>)</span>
    <span>return</span> user

<span>@pytest<span>.</span>fixture</span>
<span>def</span> <span>input_psw</span><span>(</span>request<span>)</span><span>:</span>
    psw <span>=</span> request<span>.</span>param
    <span>print</span><span>(</span><span>"登录密码：%s"</span> <span>%</span> psw<span>)</span>
    <span>return</span> psw

<span>@pytest<span>.</span>mark<span>.</span>parametrize</span><span>(</span><span>"input_user,input_psw"</span><span>,</span>test_user<span>,</span>indirect<span>=</span><span>True</span><span>)</span>
<span>def</span> <span>test_login</span><span>(</span>input_user<span>,</span> input_psw<span>)</span><span>:</span>
    <span>'''登录用例'''</span>
    a <span>=</span> input_user
    b <span>=</span> input_psw
    <span>print</span><span>(</span><span>"测试数据a-> %s，b-> %s"</span> <span>%</span> <span>(</span>a<span>,</span>b<span>)</span><span>)</span>
    <span>assert</span> b
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>测试结果：</p>
<p><img src="./images/30.png" alt="pytest" /></p>
<h3 id="多个-fixture-使用多个-pytest-mark-parametrize-叠加"> 多个 fixture 使用多个 <code>@pytest.mark.parametrize</code> 叠加</h3>
<p>使用 parametrize 装饰器叠加时，用例组合是 2 个参数个数相乘</p>
<div><pre><code>test_user <span>=</span> <span>[</span><span>"admin1"</span><span>,</span> <span>"admin2"</span><span>]</span>
test_psw <span>=</span> <span>[</span><span>"11111"</span><span>,</span> <span>"22222"</span><span>]</span>

<span>@pytest<span>.</span>fixture</span><span>(</span>scope<span>=</span><span>"module"</span><span>)</span>
<span>def</span> <span>input_user</span><span>(</span>request<span>)</span><span>:</span>
    user <span>=</span> request<span>.</span>param
    <span>print</span><span>(</span><span>"登录账户：%s"</span> <span>%</span> user<span>)</span>
    <span>return</span> user

<span>@pytest<span>.</span>fixture</span><span>(</span>scope<span>=</span><span>"module"</span><span>)</span>
<span>def</span> <span>input_psw</span><span>(</span>request<span>)</span><span>:</span>
    psw <span>=</span> request<span>.</span>param
    <span>print</span><span>(</span><span>"登录密码：%s"</span> <span>%</span> psw<span>)</span>
    <span>return</span> psw

<span>@pytest<span>.</span>mark<span>.</span>parametrize</span><span>(</span><span>"input_user"</span><span>,</span> test_user<span>,</span> indirect<span>=</span><span>True</span><span>)</span>
<span>@pytest<span>.</span>mark<span>.</span>parametrize</span><span>(</span><span>"input_psw"</span><span>,</span> test_psw<span>,</span> indirect<span>=</span><span>True</span><span>)</span>
<span>def</span> <span>test_login</span><span>(</span>input_user<span>,</span> input_psw<span>)</span><span>:</span>
    <span>'''登录用例'''</span>
    a <span>=</span> input_user
    b <span>=</span> input_psw
    <span>print</span><span>(</span><span>"测试数据a-> %s，b-> %s"</span> <span>%</span> <span>(</span>a<span>,</span>b<span>)</span><span>)</span>
    <span>assert</span> b
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>测试结果：</p>
<p><img src="./images/31.png" alt="pytest" /></p>
<p>用例有 2*2 =4 个</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-28T07:39:59.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">--clean 清除历史记录</title>
    <id>https://www.snowji.cn/test/frameworks/pytest/clean/</id>
    <link href="https://www.snowji.cn/test/frameworks/pytest/clean/"/>
    <updated>2022-08-28T07:39:59.000Z</updated>
    <content type="html"><![CDATA[<h1 id="clean-清除历史记录"> --clean 清除历史记录</h1>
<h2 id="为什么使用-clean"> 为什么使用 --clean</h2>
<ul>
<li>pytest 运行 测试用例生成 allure 报告时，当测试用例名称修改后重新运行，会保留历史运行记录</li>
<li>又或者分开运行两个测试用例文件，但是 allure 报告生成目录是同一个，那么 allure 报告会同时显示两个文件的测试用例运行情况</li>
</ul>
<h2 id="示例"> 示例</h2>
<p><code>test_clean.py</code> 代码</p>
<div><pre><code><span>def</span> <span>test_1</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"执行测试用例1"</span><span>)</span>

<span>def</span> <span>test_2</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"执行测试用例2"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>执行用例，并打开报告：</p>
<p><img src="./images/46.png" alt="pytest" /></p>
<p>修改 <code>test_clean.py</code> 代码</p>
<div><pre><code><span>def</span> <span>test_12</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"执行测试用例12"</span><span>)</span>

<span>def</span> <span>test_22</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"执行测试用例22"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>执行用例，并打开报告：</p>
<p><img src="./images/47.png" alt="pytest" /></p>
<p>结果上可以看到，之前的测试用例也显示了</p>
<p>将这两个用例分开放到 2 个 py 文件中</p>
<p><code>test_clean.py</code></p>
<div><pre><code><span>def</span> <span>test_1</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"执行测试用例1"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>test_clean1.py</code></p>
<div><pre><code><span>def</span> <span>test_2</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"执行测试用例2"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>先运行 <code>test_clean.py</code></p>
<p>结果：</p>
<p><img src="./images/48.png" alt="pytest" /></p>
<p>再运行 <code>test_clean1.py</code></p>
<p>结果：</p>
<p><img src="./images/49.png" alt="pytest" /></p>
<p><strong>使用 <code>--clean</code></strong>：</p>
<div><pre><code>pytest <span>-</span>sq <span>-</span><span>-</span>alluredir<span>=</span>allure test_clean1<span>.</span>py <span>-</span><span>-</span>clean<span>-</span>alluredir
</code></pre>
<div><span>1</span><br></div></div><p>再次运行 <code>test_clean1.py</code></p>
<p><img src="./images/50.png" alt="pytest" /></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-28T07:39:59.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">conftest.py</title>
    <id>https://www.snowji.cn/test/frameworks/pytest/conftest.py/</id>
    <link href="https://www.snowji.cn/test/frameworks/pytest/conftest.py/"/>
    <updated>2022-08-28T07:39:59.000Z</updated>
    <content type="html"><![CDATA[<h1 id="conftest-py"> conftest.py</h1>
<h2 id="什么是-conftest-py"> 什么是 conftest.py</h2>
<ul>
<li>本质上就是一个 Python 文件</li>
<li>可以理解为一个配置文件</li>
</ul>
<h2 id="conftest-py-的作用"> conftest.py 的作用</h2>
<ul>
<li>存放共享的 fixture</li>
<li>可以写自己的本地插件</li>
</ul>
<h2 id="conftest-py-作用范围"> conftest.py 作用范围</h2>
<ul>
<li>根据 conftest.py 文件的存放位置来决定作用范围</li>
<li>不同的目录下的 conftest.py，作用范围只在该层级以及以下目录生效</li>
</ul>
<h2 id="配置-fixture-示例"> 配置 fixture 示例</h2>
<div><p>注意事项</p>
<ul>
<li>pytest 会默认读取 conftest.py 里面的所有 fixture</li>
<li>conftest.py 文件名称是固定的，不能改动</li>
<li>不同目录可以有自己的 conftest.py，一个项目中可以有多个 conftest.py</li>
<li>测试用例文件中不需要手动 <code>import conftest.py</code>，pytest 会自动查找</li>
</ul>
</div>
<h4 id="项目工程结构"> 项目工程结构</h4>
<div><pre><code>web_conf是工程名称
├─douban
│  │  conftest.py
│  │  test_douban.py
│  │  __init__.py
|
├─jd
│  │  test_jd.py
│        
├─taobao
│  │  conftest.py
│  │  test_taobao.py
│  │  __init__.py
│   
|  main.py
│  conftest.py
│  __init__.py
|  test_001.py
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h5 id="web-conf-下"> web_conf 下</h5>
<h6 id="conftest-py-代码"> conftest.py 代码</h6>
<p>设置全局的 fixture</p>
<div><pre><code><span>import</span> pytest
<span>@pytest<span>.</span>fixture</span><span>(</span>scope<span>=</span><span>"session"</span><span>)</span>
<span>def</span> <span>start</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"\n获取driver，全局获取一次"</span><span>)</span>
    driver <span>=</span> <span>"Chrom"</span>
    <span>yield</span> driver
    <span>print</span><span>(</span><span>"\n释放driver，全局释放一次"</span><span>)</span>

<span>@pytest<span>.</span>fixture</span><span>(</span>autouse<span>=</span><span>True</span><span>)</span>
<span>def</span> <span>get_driver</span><span>(</span>start<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"\n每个用例都要获取driver"</span><span>)</span>
    <span>return</span> start
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h6 id="main-py-代码"> main.py 代码</h6>
<p>运行所有用例</p>
<div><pre><code><span>import</span> pytest

<span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>
    pytest<span>.</span>main<span>(</span><span>[</span><span>"-s"</span><span>]</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h6 id="test-001-py-代码"> test_001.py 代码</h6>
<p>根目录下的测试用例</p>
<div><pre><code><span>def</span> <span>test_001</span><span>(</span>start<span>)</span><span>:</span>
    <span>print</span><span>(</span><span><span>f"\n测试用例1获取driver:</span><span><span>{</span>start<span>}</span></span><span>"</span></span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h5 id="web-conf-douban-下"> web_conf/douban 下</h5>
<h6 id="conftest-py-代码-2"> conftest.py 代码</h6>
<p>设置 douban 包下的 fixture</p>
<div><pre><code><span>import</span> pytest
<span>@pytest<span>.</span>fixture</span><span>(</span>scope<span>=</span><span>"module"</span><span>)</span>
<span>def</span> <span>open_douban</span><span>(</span>start<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"\n打开douban页面"</span><span>)</span>
    <span>return</span> start

<span>@pytest<span>.</span>fixture</span>
<span>def</span> <span>login</span><span>(</span>open_douban<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"\n登录成功"</span><span>)</span>
    token <span>=</span> <span>"douban"</span>
    <span>yield</span> token
    <span>print</span><span>(</span><span>"\n退出登录"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h6 id="test-douban-py-代码"> test_douban.py 代码</h6>
<p>douban 包下的测试用例</p>
<div><pre><code><span>def</span> <span>test_002</span><span>(</span>login<span>)</span><span>:</span>
    <span>print</span><span>(</span><span><span>f"\n</span><span><span>{</span>login<span>}</span></span><span> 操作douban111"</span></span><span>)</span>

<span>def</span> <span>test_003</span><span>(</span>login<span>)</span><span>:</span>
    <span>print</span><span>(</span><span><span>f"\n</span><span><span>{</span>login<span>}</span></span><span> 操作douban222"</span></span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h5 id="web-conf-jd-下"> web_conf/jd 下</h5>
<p>目录下没有 <code>__init__.py</code> 文件</p>
<h6 id="test-jdn-py-代码"> test_jdn.py 代码</h6>
<p>jd 包下的测试用例</p>
<div><pre><code><span>def</span> <span>test_005</span><span>(</span>start<span>)</span><span>:</span>
    <span>print</span><span>(</span><span><span>f"\n</span><span><span>{</span>start<span>}</span></span><span> 操作jd1234"</span></span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h5 id="web-conf-taobao-下"> web_conf/taobao 下</h5>
<h6 id="conftest-py-代码-3"> conftest.py 代码</h6>
<p>设置 taobao 包下的 fixture</p>
<div><pre><code><span>import</span> pytest
<span>@pytest<span>.</span>fixture</span><span>(</span>scope<span>=</span><span>"module"</span><span>)</span>
<span>def</span> <span>open_taobao</span><span>(</span>start<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"\n打开taobao页面"</span><span>)</span>
    <span>return</span> start

<span>@pytest<span>.</span>fixture</span>
<span>def</span> <span>login</span><span>(</span>open_taobao<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"\n登录成功"</span><span>)</span>
    token <span>=</span> <span>"taobao"</span>
    <span>yield</span> token
    <span>print</span><span>(</span><span>"\n退出登录"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h6 id="test-taobao-py-代码"> test_taobao.py 代码</h6>
<p>taobao 包下的测试用例</p>
<div><pre><code><span>def</span> <span>test_004</span><span>(</span>login<span>)</span><span>:</span>
    <span>print</span><span>(</span><span><span>f"\n</span><span><span>{</span>login<span>}</span></span><span> 操作taobao111"</span></span><span>)</span>

<span>def</span> <span>test_005</span><span>(</span>login<span>)</span><span>:</span>
    <span>print</span><span>(</span><span><span>f"\n</span><span><span>{</span>login<span>}</span></span><span> 操作taobao222"</span></span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h5 id="测试结果"> 测试结果</h5>
<div><pre><code>test_001<span>.</span>py 
获取driver，全局获取一次
每个用例都要获取driver
测试用例<span>1</span>获取driver<span>:</span>Chrom
<span>.</span>
douban\test_douban<span>.</span>py 
打开douban页面
每个用例都要获取driver
登录成功
douban 操作douban111
退出登录
每个用例都要获取driver
登录成功
douban 操作douban222
退出登录

jd\test_jd<span>.</span>py 
每个用例都要获取driver
Chrom 操作jd1234
<span>.</span>
taobao\test_taobao<span>.</span>py 
打开taobao页面
每个用例都要获取driver
登录成功
taobao 操作taobao111
退出登录
每个用例都要获取driver
登录成功
taobao 操作taobao222
退出登录

释放driver，全局释放一次
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>conftest.py 写入本地自定义插件后续更新........</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-28T07:39:59.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">params</title>
    <id>https://www.snowji.cn/test/frameworks/pytest/fixture-params/</id>
    <link href="https://www.snowji.cn/test/frameworks/pytest/fixture-params/"/>
    <updated>2022-08-28T07:39:59.000Z</updated>
    <content type="html"><![CDATA[<h1 id="params"> params</h1>
<h2 id="params-是什么"> params 是什么</h2>
<ul>
<li>fixture 的一个参数，支持列表传入</li>
<li>默认None，每个 param 的值 fixture 都会去调用执行一次</li>
<li>被 fixture 装饰的函数要调用是采用 <code>request.param</code> 的形式获取参数</li>
<li>可与参数 ids 一起使用，作为每个参数的标识</li>
</ul>
<h2 id="params-使用"> params 使用</h2>
<p>先看简单例子</p>
<div><pre><code><span>import</span> pytest
<span># 传入单个值</span>
<span>@pytest<span>.</span>fixture</span><span>(</span>params<span>=</span><span>"a"</span><span>)</span>
<span>def</span> <span>login</span><span>(</span>request<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"打开浏览器"</span><span>)</span>
    <span>yield</span> request<span>.</span>param
    <span>print</span><span>(</span><span>"关闭浏览器"</span><span>)</span>

<span>def</span> <span>test_001</span><span>(</span>login<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"执行用例1"</span><span>)</span>
    b <span>=</span> login
    <span>print</span><span>(</span>b<span>)</span>
    
<span># 传入列表</span>
<span>@pytest<span>.</span>fixture</span><span>(</span>params<span>=</span><span>range</span><span>(</span><span>5</span><span>)</span><span>)</span>
<span>def</span> <span>login1</span><span>(</span>request<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"打开浏览器1"</span><span>)</span>
    <span>return</span> request<span>.</span>param

<span>def</span> <span>test_002</span><span>(</span>login1<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"执行用例2"</span><span>)</span>
    b <span>=</span> login1
    <span>print</span><span>(</span>b<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>执行结果：</p>
<p><img src="./images/23.png" alt="pytest" /></p>
<p>结果可以看到列表中的每个值都被执行了</p>
<div><pre><code>param_data <span>=</span> <span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>]</span>
<span>def</span> <span>login2</span><span>(</span><span>)</span><span>:</span>
    <span>return</span> <span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>,</span><span>5</span><span>]</span>

<span># 传入函数值</span>
<span>@pytest<span>.</span>fixture</span><span>(</span>params<span>=</span>login2<span>(</span><span>)</span><span>)</span>
<span>def</span> <span>login</span><span>(</span>request<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"打开浏览器"</span><span>)</span>
    <span>yield</span> request<span>.</span>param
    <span>print</span><span>(</span><span>"关闭浏览器"</span><span>)</span>

<span>def</span> <span>test_001</span><span>(</span>login<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"执行用例1"</span><span>)</span>
    b <span>=</span> login
    <span>print</span><span>(</span>b<span>)</span>

<span># 传入变量值</span>
<span>@pytest<span>.</span>fixture</span><span>(</span>params<span>=</span>param_data<span>)</span>
<span>def</span> <span>login1</span><span>(</span>request<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"打开浏览器1"</span><span>)</span>
    <span>return</span> request<span>.</span>param

<span>def</span> <span>test_002</span><span>(</span>login1<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"执行用例2"</span><span>)</span>
    b <span>=</span> login1
    <span>print</span><span>(</span>b<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>测试结果：</p>
<p><img src="./images/24.png" alt="pytest" /></p>
<h3 id="标记参数"> 标记参数</h3>
<p>对某个参数添加 mark 标记，在 params 中使用 <code>pytest.param('789', marks=pytest.mark.skip)</code></p>
<div><pre><code><span>@pytest<span>.</span>fixture</span><span>(</span>params<span>=</span><span>[</span><span>'123'</span><span>,</span> <span>'456'</span><span>,</span> pytest<span>.</span>param<span>(</span><span>'789'</span><span>,</span> marks<span>=</span>pytest<span>.</span>mark<span>.</span>skip<span>)</span><span>]</span><span>)</span>
<span>def</span> <span>para_func</span><span>(</span>request<span>)</span><span>:</span>
    <span>return</span> request<span>.</span>param

<span>class</span> <span>TestLoginSuccess</span><span>:</span>
    <span>def</span> <span>test_fixt</span><span>(</span>self<span>,</span> para_func<span>)</span><span>:</span>
        <span>assert</span> para_func <span>==</span> <span>'123'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>结果：1 条用例 pass ，1 条用例 fail，1 条用例跳过</p>
<div><p>注意</p>
<p>这个和 <code>pytest-html</code> 插件一起使用的时候会报一些内容错误，但依然可以使用</p>
</div>
<h3 id="params-ids"> params + ids</h3>
<ul>
<li><code>ids</code> 是要结合着 <code>params</code> 一起使用的</li>
<li>当有多个 <code>params</code> 时，针对每一个 <code>param</code>，可以指定一个<code>id</code>，这个 <code>id</code> 会变成测试用例名字的一部分</li>
<li>如果没有提供 <code>id</code>，则 <code>id</code> 将自动生成</li>
<li>默认是 None</li>
</ul>
<div><pre><code><span>@pytest<span>.</span>fixture</span><span>(</span>params<span>=</span><span>[</span><span>'参数1'</span><span>,</span> <span>'参数2'</span><span>]</span><span>,</span> ids<span>=</span><span>[</span><span>"id-01"</span><span>,</span> <span>"id-02"</span><span>]</span><span>)</span>
<span>def</span> <span>my_fixture</span><span>(</span>request<span>)</span><span>:</span>
    <span>return</span> request<span>.</span>param

<span>def</span> <span>test_fixtures_01</span><span>(</span>my_fixture<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>'\n 执行test_fixtures_01'</span><span>)</span>
    <span>print</span><span>(</span>my_fixture<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>测试结果：</p>
<p><img src="./images/25.png" alt="pytest" /></p>
<p>可以看到指定的 id 变成了测试用例名字的一部分</p>
<h4 id="指定具体-id-执行用例"> 指定具体 id 执行用例</h4>
<div><pre><code><span># 动态生成 id</span>
<span>def</span> <span>init_data</span><span>(</span>param<span>)</span><span>:</span>
    <span>if</span> param <span>==</span> <span>1</span><span>:</span>
        <span>return</span> <span>"unsold"</span>
    <span>elif</span> param <span>==</span> <span>2</span><span>:</span>
        <span>return</span> <span>"onSale"</span>
    <span>elif</span> param <span>==</span> <span>3</span><span>:</span>
        <span>return</span> <span>"sellOut"</span>


<span>@pytest<span>.</span>fixture</span><span>(</span>params<span>=</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>,</span> ids<span>=</span>init_data<span>)</span>
<span>def</span> <span>my_method</span><span>(</span>request<span>)</span><span>:</span>
    req_param <span>=</span> request<span>.</span>param
    <span>print</span><span>(</span><span>"\n参数为：【{}】,执行sql--插入【{}】状态的数据"</span><span>.</span><span>format</span><span>(</span>req_param<span>,</span> req_param<span>)</span><span>)</span>
    <span>yield</span> req_param
    <span>print</span><span>(</span><span>"\n执行sql--清理参数为【{}】的测试数据"</span><span>.</span><span>format</span><span>(</span>req_param<span>,</span> req_param<span>)</span><span>)</span>
    <span>print</span><span>(</span><span>"\n----------------------------------------"</span><span>)</span>


<span>def</span> <span>test_01</span><span>(</span>my_method<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"\n正在执行【{}】的case--"</span><span>.</span><span>format</span><span>(</span>my_method<span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>使用 <code>pytest -s -v -k sellOut test_fixture_params.py</code> 执行</p>
<p>测试结果：</p>
<p><img src="./images/32.png" alt="pytest" /></p>
<h3 id="params-scope"> params + scope</h3>
<div><p>注意</p>
<ul>
<li>当 fixture 作用范围大于等于 module 时，Pytest 会自动按照参数进行分组，每一个参数只会初始化一次和结束一次</li>
<li>这样有可能会打乱正常的用例执行顺序</li>
</ul>
</div>
<div><pre><code><span>@pytest<span>.</span>fixture</span><span>(</span>scope<span>=</span><span>'module'</span><span>,</span> params<span>=</span><span>[</span><span>'13'</span><span>,</span> <span>'456'</span><span>]</span><span>)</span>
<span>def</span> <span>para_func</span><span>(</span>request<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>'开始'</span><span>)</span>
    <span>yield</span> request<span>.</span>param
    <span>print</span><span>(</span><span>'结束'</span><span>)</span>


<span>class</span> <span>TestLoginSuccess</span><span>:</span>
    <span>def</span> <span>test_01</span><span>(</span>self<span>,</span> para_func<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'执行1'</span><span>)</span>
        <span>assert</span> para_func <span>==</span> <span>'123'</span>

    <span>def</span> <span>test_02</span><span>(</span>self<span>,</span> para_func<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'执行2'</span><span>)</span>

        <span>assert</span> para_func <span>==</span> <span>'123'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>执行结果：开始--&gt;执行1--&gt;执行2--&gt;结束--&gt;开始--&gt;执行1--&gt;执行2--&gt;结束</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-28T07:39:59.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">fixture</title>
    <id>https://www.snowji.cn/test/frameworks/pytest/fixture/</id>
    <link href="https://www.snowji.cn/test/frameworks/pytest/fixture/"/>
    <updated>2022-08-28T07:39:59.000Z</updated>
    <content type="html"><![CDATA[<h1 id="fixture"> fixture</h1>
<h2 id="什么是-fixture"> 什么是 fixture</h2>
<p>本质上就是一个装饰器</p>
<h2 id="为什么要使用-fixture"> 为什么要使用 fixture</h2>
<ul>
<li>前面讲了 setup、teardown 可以实现在执行用例前或结束后加入一些操作，但这种都是针对整个脚本全局生效的</li>
<li>如果有以下场景：用例 1 需要先登录，用例 2 不需要登录，用例 3 需要先登录，很显然无法用 setup 和 teardown 来实现了</li>
<li>fixture 可以自定义测试用例的前置条件</li>
</ul>
<h3 id="fixture-优势"> fixture 优势：</h3>
<ul>
<li>命名方式灵活，不局限于 setup 和 teardown 这几个命名</li>
<li>conftest.py 配置里可以实现数据共享，不需要 import 就能自动找到一些配置</li>
<li><code>scope=”module”</code> 可以实现多个 .py 跨文件共享前置</li>
<li><code>scope=”session”</code> 以实现多个 .py 跨文件使用一个 session 来完成多个用例</li>
</ul>
<h2 id="fixture-使用"> fixture 使用</h2>
<h3 id="定义-fixture"> 定义 fixture</h3>
<ul>
<li>可以使用此装饰器（带或不带参数）来定义 fixture 功能</li>
<li>fixture 功能的名称可以在以后使用引用它会在运行测试之前调用它</li>
</ul>
<div><pre><code>@pytest.fixture(scope=&quot;function&quot;, params=None, autouse=False, ids=None, name=None)
</code></pre>
<div><span>1</span><br></div></div><p>参数说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>scope</td>
<td>fixture 的作用域<br />默认 function，还有其他三个级别：class、module、package/session</td>
</tr>
<tr>
<td>params</td>
<td>fixture 的参数化</td>
</tr>
<tr>
<td>autouse</td>
<td>默认 False<br />设置为 True 开启自动使用 fixture 功能</td>
</tr>
<tr>
<td>ids</td>
<td>配合 params 使用</td>
</tr>
<tr>
<td>name</td>
<td>设置 fixture 函数的别名，调用时可以使用别名调用</td>
</tr>
</tbody>
</table>
<h3 id="如何调用-fixture"> 如何调用 fixture</h3>
<p>调用 fixture 方式</p>
<ul>
<li>将 fixture 名称作为测试用例函数的输入参数</li>
<li>测试用例加上装饰器：<code>@pytest.mark.usefixtures(fixture_name)</code></li>
<li>fixture 设置 <code>autouse=True</code></li>
</ul>
<div><pre><code><span>import</span> pytest

<span>@pytest<span>.</span>fixture</span>
<span>def</span> <span>open</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"打开浏览器"</span><span>)</span>

<span># 使用方式一</span>
<span>def</span> <span>test_001</span><span>(</span><span>open</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"执行测试用例1"</span><span>)</span>

<span>def</span> <span>test_005</span><span>(</span>login<span>,</span><span>open</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"执行测试用例5"</span><span>)</span>

<span># 使用方式三</span>
<span>@pytest<span>.</span>fixture</span><span>(</span>autouse<span>=</span><span>True</span><span>)</span>
<span>def</span> <span>sql</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"先打开数据库"</span><span>)</span>

<span># 使用方式二：</span>
<span>@pytest<span>.</span>fixture</span>
<span>def</span> <span>login</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"先进行登录"</span><span>)</span>

<span>@pytest<span>.</span>mark<span>.</span>usefixtures</span><span>(</span><span>"open"</span><span>)</span>
<span>@pytest<span>.</span>mark<span>.</span>usefixtures</span><span>(</span><span>"login"</span><span>)</span>
<span>class</span> <span>Test_Case</span><span>(</span><span>)</span><span>:</span>
    <span>def</span> <span>test_002</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"执行测试用例2"</span><span>)</span>

    <span>def</span> <span>test_003</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"执行测试用例3"</span><span>)</span>



<span>def</span> <span>test_004</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"执行用例004"</span><span>)</span>

<span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>
    pytest<span>.</span>main<span>(</span><span>[</span><span>"-s"</span><span>,</span><span>"-v"</span><span>]</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><p>测试结果：</p>
<p><img src="./images/17.png" alt="pytest" /></p>
<div><p>总结</p>
<ul>
<li>在类声明上面加 <code>@pytest.mark.usefixtures()</code>，代表这个类里面所有测试用例都会调用该 fixture</li>
<li>可以叠加多个 <code>@pytest.mark.usefixtures()</code>，先执行的放底层，后执行的放上层</li>
<li>可以传多个 fixture 参数，先执行的放前面，后执行的放后面</li>
<li>如果 fixture 有返回值，用 <code>@pytest.mark.usefixtures()</code> 是无法获取到返回值的，必须用传参的方式（方式一）</li>
<li>自动使用（<code>autouse=True</code>）的 fixture 将在显式使用（传参或装饰器）的 fixture 之前实例化</li>
</ul>
</div>
<h3 id="fixture-实例化顺序"> fixture 实例化顺序</h3>
<ul>
<li>
<p>高级别 scope 的 fixture 在低级别 scope 的 fixture 之前实例化（session &gt; package &gt; module &gt; class &gt; function）</p>
</li>
<li>
<p>具有相同 scope 的 fixture 遵循测试函数中声明的顺序</p>
</li>
<li>
<p>遵循 fixture 之间的依赖关系（在 <code>fixture_A</code> 里面依赖的 <code>fixture_B</code> 优先实例化，然后到 <code>fixture_A</code> 实例化）</p>
</li>
</ul>
<div><pre><code>  <span>import</span> pytest
  
  order <span>=</span> <span>[</span><span>]</span>
  
  <span>@pytest<span>.</span>fixture</span><span>(</span>scope<span>=</span><span>"session"</span><span>)</span>
  <span>def</span> <span>s1</span><span>(</span><span>)</span><span>:</span>
      order<span>.</span>append<span>(</span><span>"s1"</span><span>)</span>
  
  <span>@pytest<span>.</span>fixture</span><span>(</span>scope<span>=</span><span>"session"</span><span>)</span>
  <span>def</span> <span>s2</span><span>(</span><span>)</span><span>:</span>
      order<span>.</span>append<span>(</span><span>"s2"</span><span>)</span>
  
  <span>@pytest<span>.</span>fixture</span><span>(</span>scope<span>=</span><span>"session"</span><span>)</span>
  <span>def</span> <span>s3</span><span>(</span><span>)</span><span>:</span>
      order<span>.</span>append<span>(</span><span>"s3"</span><span>)</span>
  
  <span>@pytest<span>.</span>fixture</span><span>(</span>scope<span>=</span><span>"session"</span><span>)</span>
  <span>def</span> <span>s4</span><span>(</span><span>)</span><span>:</span>
      order<span>.</span>append<span>(</span><span>"s4"</span><span>)</span>
  
  <span>@pytest<span>.</span>fixture</span><span>(</span>scope<span>=</span><span>"session"</span><span>)</span>
  <span>def</span> <span>s5</span><span>(</span>s7<span>)</span><span>:</span>
      order<span>.</span>append<span>(</span><span>"s5"</span><span>)</span>
  
  <span>@pytest<span>.</span>fixture</span><span>(</span>scope<span>=</span><span>"session"</span><span>)</span>
  <span>def</span> <span>s6</span><span>(</span><span>)</span><span>:</span>
      order<span>.</span>append<span>(</span><span>"s6"</span><span>)</span>
  
  <span>@pytest<span>.</span>fixture</span><span>(</span>scope<span>=</span><span>"session"</span><span>)</span>
  <span>def</span> <span>s7</span><span>(</span><span>)</span><span>:</span>
      order<span>.</span>append<span>(</span><span>"s7"</span><span>)</span>
  
  <span>@pytest<span>.</span>fixture</span><span>(</span>scope<span>=</span><span>"module"</span><span>)</span>
  <span>def</span> <span>m1</span><span>(</span><span>)</span><span>:</span>
      order<span>.</span>append<span>(</span><span>"m1"</span><span>)</span>
  
  <span>@pytest<span>.</span>fixture</span><span>(</span>scope<span>=</span><span>"module"</span><span>)</span>
  <span>def</span> <span>m2</span><span>(</span>s5<span>)</span><span>:</span>
      order<span>.</span>append<span>(</span><span>"m2"</span><span>)</span>
  
  <span>@pytest<span>.</span>fixture</span><span>(</span>scope<span>=</span><span>"module"</span><span>)</span>
  <span>def</span> <span>m3</span><span>(</span>s4<span>)</span><span>:</span>
      order<span>.</span>append<span>(</span><span>"m3"</span><span>)</span>
  
  <span>@pytest<span>.</span>fixture</span>
  <span>def</span> <span>f1</span><span>(</span>s2<span>,</span> f3<span>)</span><span>:</span>
      order<span>.</span>append<span>(</span><span>"f1"</span><span>)</span>
  
  <span>@pytest<span>.</span>fixture</span>
  <span>def</span> <span>f2</span><span>(</span>m2<span>,</span> s3<span>)</span><span>:</span>
      order<span>.</span>append<span>(</span><span>"f2"</span><span>)</span>
  
  <span>@pytest<span>.</span>fixture</span>
  <span>def</span> <span>f3</span><span>(</span>s6<span>)</span><span>:</span>
      order<span>.</span>append<span>(</span><span>"f3"</span><span>)</span>
  
  <span>def</span> <span>test_order</span><span>(</span>f2<span>,</span> f1<span>,</span> m3<span>,</span> m1<span>,</span> s1<span>)</span><span>:</span>
      <span>print</span><span>(</span>order<span>)</span> <span># ['s1', 's3', 's2', 's4', 's7', 's5', 's6', 'm3', 'm1', 'm2', 'f2', 'f3', 'f1']</span>
  
  
  <span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>
      pytest<span>.</span>main<span>(</span><span>[</span><span>"-s"</span><span>,</span><span>"-v"</span><span>]</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br></div></div><p>测试结果：</p>
<p><img src="./images/18.png" alt="pytest" /></p>
<div><p>注意：</p>
<p>添加了 @pytest.fixture ，如果 fixture 还想依赖其他 fixture，需要用函数传参的方式，不能用 @pytest.mark.usefixtures() 的方式，否则会不生效</p>
<p>如上述例子中的 s5</p>
</div>
<h3 id="fixture-实现-teardown"> fixture 实现 teardown</h3>
<p>前面讲的 fixture 都是实现的 setup</p>
<h4 id="yield"> yield</h4>
<p>fixture 实现 teardown 需要使用 yield</p>
<div><pre><code><span>import</span> pytest

<span>@pytest<span>.</span>fixture</span><span>(</span>scope<span>=</span><span>"module"</span><span>,</span>autouse<span>=</span><span>True</span><span>)</span>
<span>def</span> <span>login</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"打开浏览器"</span><span>)</span>
    <span>yield</span>
    <span>print</span><span>(</span><span>"关闭浏览器"</span><span>)</span>


<span>@pytest<span>.</span>fixture</span>
<span>def</span> <span>sql</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"连接数据库"</span><span>)</span>
    <span>yield</span>
    <span>print</span><span>(</span><span>"关闭数据库"</span><span>)</span>

<span>def</span> <span>test_001</span><span>(</span>sql<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"执行用例01"</span><span>)</span>

<span>def</span> <span>test_002</span><span>(</span>sql<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"执行用例02"</span><span>)</span>

<span>def</span> <span>test_003</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"执行用例03"</span><span>)</span>

<span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>
    pytest<span>.</span>main<span>(</span><span>[</span><span>"-s"</span><span>,</span><span>"-v"</span><span>]</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>测试结果：</p>
<p><img src="./images/19.png" alt="pytest" /></p>
<div><p>注意</p>
<ul>
<li>如果 yield 前面的代码，即 setup 部分已经抛出异常了，则不会执行 yield 后面的 teardown 内容</li>
</ul>
<ul>
<li>如果测试用例抛出异常，yield 后面的 teardown 内容还是会正常执行</li>
</ul>
</div>
<h5 id="yield-with"> yield + with</h5>
<p>yield 也可以配合 with 语句使用</p>
<div><pre><code>官方例子：
<span>@pytest<span>.</span>fixture</span><span>(</span>scope<span>=</span><span>"module"</span><span>)</span>
<span>def</span> <span>smtp</span><span>(</span><span>)</span><span>:</span>
    <span>with</span> smtplib<span>.</span>SMTP<span>(</span><span>"smtp.gmail.com"</span><span>)</span> <span>as</span> smtp<span>:</span>
        <span>yield</span> smtp  <span># provide the fixture value</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="addfinalizer"> addfinalizer</h4>
<p>Pytest 中做 teardown 的处理，除了使用带有 yield 的 fixture 函数，还可以在 <code>request-context</code> 对象中注册 addfinalizer 方法实现终结函数</p>
<h5 id="注册单个-request-addfinalizer"> 注册单个 request.addfinalizer</h5>
<div><pre><code><span>@pytest<span>.</span>fixture</span>
<span>def</span> <span>sql</span><span>(</span>request<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"连接数据库"</span><span>)</span>
    <span>def</span> <span>close</span><span>(</span><span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"关闭数据库"</span><span>)</span>
    <span># 注册 close 为终结函数</span>
    request<span>.</span>addfinalizer<span>(</span>close<span>)</span>

<span>def</span> <span>test_01</span><span>(</span>sql<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"执行用例01"</span><span>)</span>

<span>def</span> <span>test_02</span><span>(</span>sql<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"执行用例02"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>测试结果：</p>
<p><img src="./images/20.png" alt="pytest" /></p>
<p>效果上与 yield 一致</p>
<h5 id="注册多个-request-addfinalizer"> 注册多个 request.addfinalizer</h5>
<div><pre><code><span>@pytest<span>.</span>fixture</span>
<span>def</span> <span>sql</span><span>(</span>request<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"登录成功"</span><span>)</span>
    <span>print</span><span>(</span><span>"连接数据库"</span><span>)</span>
    <span>def</span> <span>logout</span><span>(</span><span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"注销登录"</span><span>)</span>
    <span>def</span> <span>close</span><span>(</span><span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"关闭数据库"</span><span>)</span>
    <span># 注册 close 为终结函数</span>
    request<span>.</span>addfinalizer<span>(</span>logout<span>)</span>
    request<span>.</span>addfinalizer<span>(</span>close<span>)</span>

<span>def</span> <span>test_01</span><span>(</span>sql<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"执行用例01"</span><span>)</span>

<span>def</span> <span>test_02</span><span>(</span>sql<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"执行用例02"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>测试结果：</p>
<p><img src="./images/21.png" alt="pytest" /></p>
<div><p>注意</p>
<ul>
<li>如果 <code>request.addfinalizer()</code> 前面的代码，即 setup 部分已经抛出异常了，则不会执行 <code>request.addfinalizer()</code> 的 teardown 内容（和 yield 相似，应该是最近新版本改成一致了）</li>
<li>可以声明多个终结函数并调用</li>
<li>多个终结器的情况下，执行的顺序是与注册时候相反的</li>
</ul>
</div>
<h2 id="参考资料"> 参考资料</h2>
<p><a href="https://docs.pytest.org/en/latest/explanation/fixtures.html?highlight=fixture" target="_blank" rel="noopener noreferrer">官方文档-关于 fixture</a></p>
<p><a href="https://docs.pytest.org/en/latest/how-to/fixtures.html#how-to-fixtures" target="_blank" rel="noopener noreferrer">官方文档-如何使用 fixture</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-28T07:39:59.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">环境准备与入门</title>
    <id>https://www.snowji.cn/test/frameworks/pytest/install/</id>
    <link href="https://www.snowji.cn/test/frameworks/pytest/install/"/>
    <updated>2022-08-28T07:39:59.000Z</updated>
    <content type="html"><![CDATA[<h1 id="环境准备与入门"> 环境准备与入门</h1>
<h2 id="安装-pytest"> 安装 Pytest</h2>
<p>安装方法</p>
<div><pre><code>pip install pytest
</code></pre>
<div><span>1</span><br></div></div><p>安装完成后查看版本信息</p>
<div><pre><code>pip show pytest
或
pytest <span>-</span><span>-</span>version
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="快速入门"> 快速入门</h2>
<h3 id="测试函数"> 测试函数</h3>
<p>新建 <code>test_sample.py</code> 文件</p>
<div><pre><code><span>def</span> <span>func</span><span>(</span>x<span>)</span><span>:</span>
    <span>return</span> x <span>+</span><span>1</span>

<span>def</span> <span>test_answer</span><span>(</span><span>)</span><span>:</span>
    <span>assert</span> func<span>(</span><span>3</span><span>)</span><span>==</span><span>5</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>在该 py 文件所在的路径下运行：<code>pytest</code></p>
<p><img src="./images/1.png" alt="pytest" /></p>
<p><strong>知识点</strong>：</p>
<p>查找当前目录及其子目录下以 <code>test_*.py</code> 或<code>*_test.py</code>文件，找到文件后，在文件中找到以 test 开头函数并执行</p>
<h3 id="测试类"> 测试类</h3>
<p>当用例有多个的时候，可以把多个测试用例，写到一个测试类里</p>
<p>新建一个 <code>test_class.py</code></p>
<div><pre><code><span>class</span> <span>TestClass</span><span>:</span>
    <span>def</span> <span>test_one</span><span>(</span>self<span>)</span><span>:</span>
        x <span>=</span> <span>"this"</span>
        <span>assert</span> <span>'h'</span> <span>in</span> x

    <span>def</span> <span>test_two</span><span>(</span>self<span>)</span><span>:</span>
        x <span>=</span> <span>"hello"</span>
        <span>assert</span> <span>hasattr</span><span>(</span>x<span>,</span> <span>'check'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>在该 py 文件所在的路径下指定该文件运行：<code>pytest -q test_class.py</code></p>
<p><img src="./images/2.png" alt="pytest" /></p>
<h2 id="用例设计原则"> 用例设计原则</h2>
<p>用 Pytest 写用例时候，一定要按照下面的规则去写，否则不符合规则的测试用例是不会执行的</p>
<ul>
<li>文件名以 <code>test_*.py</code> 文件和 <code>*_test.py</code></li>
<li>以 <code>test_</code> 开头的函数</li>
<li>以 Test 开头的类，不能包含<code>__init__</code> 方法</li>
<li>以 <code>test_</code> 开头的方法</li>
<li>所有的包 package 必须要有 <code>__init__.py</code> 文件</li>
</ul>
<h2 id="执行用例规则"> 执行用例规则</h2>
<p><strong>注意，下面讲的都是在 cmd 中执行 pytest 命令</strong></p>
<h3 id="某个目录下所有的用例"> 某个目录下所有的用例</h3>
<div><pre><code>pytest
</code></pre>
<div><span>1</span><br></div></div><h3 id="执行某一个-py-文件下用例"> 执行某一个 py 文件下用例</h3>
<div><pre><code>pytest 脚本名称.py
</code></pre>
<div><span>1</span><br></div></div><h3 id="运行-start-py-模块里面的某个函数-或者某个类-某个类里面的方法"> 运行 start.py 模块里面的某个函数，或者某个类，某个类里面的方法</h3>
<p>加v和不加 -v 都可以，加 -v 的话，打印的信息更详细</p>
<div><pre><code>pytest -v 08_mark.py::TestClass::test_method 
pytest start.py::test_answer
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="运行-start-py-模块里面-测试类里面的某个方法"> 运行 start.py 模块里面,测试类里面的某个方法</h3>
<div><pre><code>pytest start.py::TestClass::test_two
</code></pre>
<div><span>1</span><br></div></div><h3 id="m-标记表达式-后续讲解"> <code>-m</code> 标记表达式（后续讲解）</h3>
<div><pre><code> pytest -m login
</code></pre>
<div><span>1</span><br></div></div><p>将运行用 <code>@pytest.mark.login</code> 装饰器修饰的所有测试，后面再展开讲标记哦</p>
<h3 id="q-简单打印-只打印测试用例的执行结果"> <code>-q</code> 简单打印，只打印测试用例的执行结果</h3>
<div><pre><code> pytest -q start.py
</code></pre>
<div><span>1</span><br></div></div><h3 id="s-详细打印"> <code>-s</code> 详细打印</h3>
<div><pre><code> pytest -s start.py
</code></pre>
<div><span>1</span><br></div></div><h3 id="x-遇到错误时停止测试"> <code>-x</code> 遇到错误时停止测试</h3>
<div><pre><code>pytest start.py -x
</code></pre>
<div><span>1</span><br></div></div><h3 id="maxfail-num-当用例错误个数达到指定数量时-停止测试"> <code>--maxfail=num</code>，当用例错误个数达到指定数量时，停止测试</h3>
<div><pre><code>pytest start.py --maxfail=1
</code></pre>
<div><span>1</span><br></div></div><h3 id="k-匹配用例名称"> <code>-k</code> 匹配用例名称</h3>
<p>执行测试用例名称包含http的所有用例</p>
<div><pre><code>pytest -s -k http start.py
</code></pre>
<div><span>1</span><br></div></div><h3 id="k-根据用例名称排除某些用例"> <code>-k</code> 根据用例名称排除某些用例</h3>
<div><pre><code>pytest -s -k &quot;not http&quot; start.py
</code></pre>
<div><span>1</span><br></div></div><h3 id="k-同时匹配不同的用例名称"> <code>-k</code> 同时匹配不同的用例名称</h3>
<div><pre><code>pytest -s -k &quot;method or weibo&quot; start.py
</code></pre>
<div><span>1</span><br></div></div><div><p>Python 测试发现约定</p>
<ul>
<li>如果未指定任何参数，则收集从 testpaths（如果已配置）或当前目录开始</li>
<li>命令行参数可以在目录、文件名或节点 ID 的任何组合中使用</li>
<li>递归到目录，除非它们匹配 norecursedirs</li>
<li>在这些目录中，搜索 <code>test_*.py</code> 或 <code>*_test.py</code></li>
<li>从这些文件中，搜集测试项目：
<ul>
<li>在类之外拥有 test 前缀的测试函数或方法</li>
<li>在拥有 Test 前缀中的测试类(不含 <code>__init__</code> 方法)中的拥有 test 前缀的测试函数或方法</li>
</ul>
</li>
<li>可自定义测试发现规则</li>
<li>Pytest 是可以兼容 Unittest 脚本的，之前写的 Unittest 用例也能用 Pytest 框架去运行</li>
</ul>
</div>
<h2 id="pycharm-运行-pytest"> Pycharm 运行 Pytest</h2>
<p><img src="./images/3.png" alt="pytest" /></p>
<p><img src="./images/4.png" alt="pytest" /></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-28T07:39:59.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">scope</title>
    <id>https://www.snowji.cn/test/frameworks/pytest/fixture-scope/</id>
    <link href="https://www.snowji.cn/test/frameworks/pytest/fixture-scope/"/>
    <updated>2022-09-15T13:32:22.000Z</updated>
    <content type="html"><![CDATA[<h1 id="scope"> scope</h1>
<h2 id="scope-是什么"> scope 是什么</h2>
<ul>
<li>fixture 的一个参数</li>
<li>控制 fixture 的作用范围</li>
<li>有以下可选值：
<ul>
<li>function：默认，每个函数或方法都会调用</li>
<li>class：每个类会调用，一个类可以有多个方法</li>
<li>module：每一个 <code>.py</code> 文件调用一次，该文件内又有多个 function 和 class</li>
<li>package/session：多个文件调用一次，可以跨 <code>.py</code> 文件</li>
</ul>
</li>
</ul>
<h2 id="scope-作用范围顺序"> scope 作用范围顺序</h2>
<p>先来看个例子</p>
<div><pre><code>import pytest

@pytest.fixture(scope=&quot;function&quot;)
def login():
    print(&quot;先进行登录&quot;)

def test_001(login):
    print(&quot;执行用例001&quot;)

@pytest.fixture(scope=&quot;class&quot;)
def login1():
    print(&quot;先进行登录111&quot;)

@pytest.mark.usefixtures(&quot;login3&quot;,&quot;login2&quot;,&quot;login4&quot;,&quot;login1&quot;,&quot;login&quot;)
class Test_Case():
    def test_002(self):
        print(&quot;执行用例002&quot;)

    def test_003(self):
        print(&quot;执行用例003&quot;)

@pytest.fixture(scope=&quot;session&quot;)
def login2():
    print(&quot;先进行登录222&quot;)

@pytest.fixture(scope=&quot;package&quot;)
def login3():
    print(&quot;先进行登录333&quot;)

@pytest.fixture(scope=&quot;module&quot;)
def login4():
    print(&quot;先进行登录444&quot;)

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>执行结果：</p>
<p><img src="./images/22.png" alt="pytest" /></p>
<div><p>总结</p>
<ul>
<li>作用范围顺序：session &gt; package &gt; module &gt; class &gt; function</li>
<li>session/package、module 级别的 fixture 只执行了一次</li>
<li>session/package 可以结合 <code>conftest.py</code> 文件使用</li>
</ul>
</div>
<p>相关 <code>conftest.py</code> 可参考 <a href="test/frameworks/pytest/conftest.py">conftest.py</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-28T07:39:59.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">pytest-xdist</title>
    <id>https://www.snowji.cn/test/frameworks/pytest/pytest-xdist/</id>
    <link href="https://www.snowji.cn/test/frameworks/pytest/pytest-xdist/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="pytest-xdist"> pytest-xdist</h1>
<h2 id="什么是-pytest-xdist"> 什么是 pytest-xdist</h2>
<ul>
<li>Pytest 的一款插件</li>
<li>可以分布式执行测试用例</li>
</ul>
<h2 id="为什么要用-pytest-xdist"> 为什么要用 pytest-xdist</h2>
<ul>
<li>平常我们功能测试用例非常多时，比如有 1 千条用例，假设每个用例执行需要 1分钟，如果单个测试人员执行需要 1000 分钟才能跑完</li>
<li>当项目非常紧急时，会需要协调多个测试资源来把任务分成两部分，于是执行时间缩短一半，如果有 10 个小伙伴，那么执行时间就会变成十分之一，大大节省了测试时间</li>
<li>为了节省项目测试时间，10 个测试同时并行测试，这就是一种分布式场景</li>
<li>同样道理，当我们自动化测试用例非常多的时候，一条条按顺序执行会非常慢，<code>pytest-xdist</code> 的出现就是为了让自动化测试用例可以分布式执行，从而节省自动化测试时间</li>
<li><code>pytest-xdist</code> 是属于进程级别的并发</li>
</ul>
<h2 id="安装-pytest-xdist"> 安装 pytest-xdist</h2>
<div><pre><code>pip install pytest<span>-</span>xdist
</code></pre>
<div><span>1</span><br></div></div><div><p>pytest-xdist 通过一些独特的测试执行模式扩展了 Pytest:</p>
<ul>
<li>测试运行并行化：如果有多个 CPU 或主机，则可以将它们用于组合的测试运行，这样可以加快开发速度或使用远程计算机的特殊资源</li>
<li><code>--looponfail</code>：在子进程中重复运行测试，每次运行之后，Pytest 都会等到项目中的文件更改后再运行之前失败的测试，重复此过程，直到所有测试通过，然后再次执行完整运行</li>
<li>跨平台覆盖：您可以指定不同的 Python 解释程序或不同的平台，并在所有这些平台上并行运行测试</li>
</ul>
</div>
<h3 id="执行命令"> 执行命令</h3>
<div><pre><code>pytest <span>-</span>n <span>3</span> 
或
pytest <span>-</span>n auto
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong><code>-n 3</code></strong>: 指定具体的进程数</p>
<p><strong><code>-n auto</code></strong>: 使用与计算机 CPU 内核一样多的进程</p>
<h2 id="pytest-xdist-示例"> pytest-xdist 示例</h2>
<h3 id="项目工程结构"> 项目工程结构</h3>
<div><pre><code>web_conf是工程名称
├─douban
│  │  conftest.py
│  │  test_douban.py
│  │  __init__.py
|
├─jd
│  │  test_jd.py
│        
├─taobao
│  │  conftest.py
│  │  test_taobao.py
│  │  __init__.py
│   
|  main.py
│  conftest.py
│  __init__.py
|  test_001.py
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id="web-conf-下"> web_conf 下</h3>
<h4 id="conftest-py-代码"> conftest.py 代码</h4>
<details><summary>点击查看代码</summary>
<div><pre><code><span>import</span> pytest
<span>@pytest<span>.</span>fixture</span><span>(</span>scope<span>=</span><span>"session"</span><span>)</span>
<span>def</span> <span>start</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"\n获取driver，全局获取一次"</span><span>)</span>
    driver <span>=</span> <span>"Chrom"</span>
    <span>yield</span> driver
    <span>print</span><span>(</span><span>"\n释放driver，全局释放一次"</span><span>)</span>

<span>@pytest<span>.</span>fixture</span><span>(</span>autouse<span>=</span><span>True</span><span>)</span>
<span>def</span> <span>get_driver</span><span>(</span>start<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"\n每个用例都要获取driver"</span><span>)</span>
    <span>return</span> start
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div></details>
<h4 id="main-py-代码"> main.py 代码</h4>
<p>运行所有用例</p>
<details><summary>点击查看代码</summary>
<div><pre><code><span>import</span> pytest

<span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>
    pytest<span>.</span>main<span>(</span><span>[</span><span>"-s"</span><span>]</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></details>
<h4 id="test-001-py-代码"> test_001.py 代码</h4>
<p>根目录下的测试用例</p>
<details><summary>点击查看代码</summary>
<div><pre><code><span>from</span> time <span>import</span> sleep
<span>def</span> <span>test_001</span><span>(</span>start<span>)</span><span>:</span>
    sleep<span>(</span><span>1</span><span>)</span>
    <span>print</span><span>(</span><span><span>f"\n测试用例1获取driver:</span><span><span>{</span>start<span>}</span></span><span>"</span></span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></details>
<h3 id="web-conf-douban-下"> web_conf/douban 下</h3>
<h4 id="conftest-py-代码-2"> conftest.py 代码</h4>
<details><summary>点击查看代码</summary>
<div><pre><code><span>import</span> pytest
<span>@pytest<span>.</span>fixture</span><span>(</span>scope<span>=</span><span>"module"</span><span>)</span>
<span>def</span> <span>open_douban</span><span>(</span>start<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"\n打开douban页面"</span><span>)</span>
    <span>return</span> start

<span>@pytest<span>.</span>fixture</span>
<span>def</span> <span>login</span><span>(</span>open_douban<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"\n登录成功"</span><span>)</span>
    token <span>=</span> <span>"douban"</span>
    <span>yield</span> token
    <span>print</span><span>(</span><span>"\n退出登录"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div></details>
<h4 id="test-douban-py-代码"> test_douban.py 代码</h4>
<p>douban 包下的测试用例</p>
<details><summary>点击查看代码</summary>
<div><pre><code><span>import</span> pytest
<span>from</span> time <span>import</span> sleep

<span>@pytest<span>.</span>mark<span>.</span>repeat</span><span>(</span><span>5</span><span>)</span>
<span>def</span> <span>test_002</span><span>(</span>login<span>)</span><span>:</span>
    sleep<span>(</span><span>1</span><span>)</span>
    <span>print</span><span>(</span><span><span>f"\n</span><span><span>{</span>login<span>}</span></span><span> 操作douban111"</span></span><span>)</span>

<span>@pytest<span>.</span>mark<span>.</span>repeat</span><span>(</span><span>5</span><span>)</span>
<span>def</span> <span>test_003</span><span>(</span>login<span>)</span><span>:</span>
    sleep<span>(</span><span>1</span><span>)</span>
    <span>print</span><span>(</span><span><span>f"\n</span><span><span>{</span>login<span>}</span></span><span> 操作douban222"</span></span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div></details>
<h3 id="web-conf-jd-下"> web_conf/jd 下</h3>
<p>目录下没有 <code>__init__.py</code> 文件</p>
<h4 id="test-jdn-py-代码"> test_jdn.py 代码</h4>
<p>jd 包下的测试用例</p>
<details><summary>点击查看代码</summary>
<div><pre><code><span>import</span> pytest
<span>from</span> time <span>import</span> sleep

<span>@pytest<span>.</span>mark<span>.</span>repeat</span><span>(</span><span>5</span><span>)</span>
<span>def</span> <span>test_jd1</span><span>(</span>start<span>)</span><span>:</span>
    sleep<span>(</span><span>1</span><span>)</span>
    <span>print</span><span>(</span><span><span>f"\n</span><span><span>{</span>start<span>}</span></span><span> 操作jd1"</span></span><span>)</span>

<span>@pytest<span>.</span>mark<span>.</span>repeat</span><span>(</span><span>5</span><span>)</span>
<span>def</span> <span>test_jd2</span><span>(</span>start<span>)</span><span>:</span>
    sleep<span>(</span><span>1</span><span>)</span>
    <span>print</span><span>(</span><span><span>f"\n</span><span><span>{</span>start<span>}</span></span><span> 操作jd2"</span></span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div></details>
<h3 id="web-conf-taobao-下"> web_conf/taobao 下</h3>
<h4 id="conftest-py-代码-3"> conftest.py 代码</h4>
<p>设置 taobao 包下的 fixture</p>
<details><summary>点击查看代码</summary>
<div><pre><code><span>import</span> pytest

<span>@pytest<span>.</span>fixture</span><span>(</span>scope<span>=</span><span>"module"</span><span>)</span>
<span>def</span> <span>open_taobao</span><span>(</span>start<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"\n打开taobao页面"</span><span>)</span>
    <span>return</span> start

<span>@pytest<span>.</span>fixture</span>
<span>def</span> <span>login</span><span>(</span>open_taobao<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"\n登录成功"</span><span>)</span>
    token <span>=</span> <span>"taobao"</span>
    <span>yield</span> token
    <span>print</span><span>(</span><span>"\n退出登录"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div></details>
<h4 id="test-taobao-py-代码"> <code>test_taobao.py</code> 代码</h4>
<p>taobao 包下的测试用例</p>
<details><summary>点击查看代码</summary>
<div><pre><code><span>import</span> pytest
<span>from</span> time <span>import</span> sleep

<span>@pytest<span>.</span>mark<span>.</span>repeat</span><span>(</span><span>5</span><span>)</span>
<span>def</span> <span>test_taobao1</span><span>(</span>login<span>)</span><span>:</span>
    sleep<span>(</span><span>1</span><span>)</span>
    <span>print</span><span>(</span><span><span>f"\n</span><span><span>{</span>login<span>}</span></span><span> 操作taobao1"</span></span><span>)</span>

<span>@pytest<span>.</span>mark<span>.</span>repeat</span><span>(</span><span>5</span><span>)</span>
<span>def</span> <span>test_taobao2</span><span>(</span>login<span>)</span><span>:</span>
    sleep<span>(</span><span>1</span><span>)</span>
    <span>print</span><span>(</span><span><span>f"\n</span><span><span>{</span>login<span>}</span></span><span> 操作taobao2"</span></span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div></details>
<p><strong>不使用分布式测试和执行结果</strong>：</p>
<div><pre><code>pytest <span>-</span>s
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>#结果：</span>
<span>31</span> passed <span>in</span> <span>31</span><span>.</span>40s
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面每条用例执行之前都加了等待时间 1 s，总共 31 条用例，时间为 31 秒</p>
<p><strong>使用分布式测试和执行结果</strong>：
指定进程数 5：</p>
<div><pre><code>pytest <span>-</span>s <span>-</span>n <span>5</span>
</code></pre>
<div><span>1</span><br></div></div><p>结果：</p>
<p><img src="./images/37.png" alt="pytest" /></p>
<p>结果明显比不使用分布式时缩短了很多</p>
<div><p>pytest-xdist 可以和 pytest-html 结合使用</p>
<p>pytest -s -n auto --html=report.html --self-contained-html</p>
</div>
<h2 id="分布式执行用例设计原则-重点"> 分布式执行用例设计原则(重点)</h2>
<ul>
<li>用例之间是独立的，用例之间没有依赖关系，用例可以完全独立运行</li>
<li>用例执行没有顺序，随机顺序都能正常执行</li>
<li>每个用例都能重复运行，运行结果不会影响其他用例</li>
</ul>
<h2 id="pytest-xdist-执行顺序"> pytest-xdist 执行顺序</h2>
<p>pytest-xdist 默认是无序执行的，可以通过 <code>--dist</code> 参数来控制顺序</p>
<p><code>test_xdist1.py</code></p>
<details><summary>点击查看代码</summary>
<div><pre><code><span>def</span> <span>test1</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>'执行用例111'</span><span>)</span>

<span>class</span> <span>Test1</span><span>(</span><span>)</span><span>:</span>
    <span>def</span> <span>test12</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'执行用例121212'</span><span>)</span>

    <span>def</span> <span>test13</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'执行用例131313'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></details>
<p>test_xdist2.py</p>
<details><summary>点击查看代码</summary>
<div><pre><code><span>def</span> <span>test2</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>'执行用例2222'</span><span>)</span>

<span>class</span> <span>Test2</span><span>(</span><span>)</span><span>:</span>
    <span>def</span> <span>test22</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'执行用例22222'</span><span>)</span>

    <span>def</span> <span>test23</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'执行用例232323'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></details>
<h3 id="dist-load"> <code>--dist=load</code></h3>
<p>将待运行的用例随机发给可用的执行器 worker，用例执行顺序随机的，目前默认采用这种方式</p>
<p>执行命令：<code>pytest -s -v -n 3 --dist=load test_xdist1.py</code></p>
<p>执行结果：</p>
<details><summary>点击查看结果</summary>
<div><pre><code>test_xdist1<span>.</span>py<span>:</span><span>:</span>Test1<span>:</span><span>:</span>test13
test_xdist1<span>.</span>py<span>:</span><span>:</span>test1
test_xdist1<span>.</span>py<span>:</span><span>:</span>Test1<span>:</span><span>:</span>test12
<span>[</span>gw2<span>]</span> PASSED test_xdist1<span>.</span>py<span>:</span><span>:</span>Test1<span>:</span><span>:</span>test13
<span>[</span>gw0<span>]</span> PASSED test_xdist1<span>.</span>py<span>:</span><span>:</span>test1
<span>[</span>gw1<span>]</span> PASSED test_xdist1<span>.</span>py<span>:</span><span>:</span>Test1<span>:</span><span>:</span>test12
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></details>
<p>[gw0] 、[gw1] 、[gw2] 随机执行用例</p>
<h3 id="dist-loadscope"> <code>--dist=loadscope</code></h3>
<ul>
<li>将按照同一个模块 module 下的函数和同一个测试类 class 下的方法来分组，然后将每个测试组发给可以执行的 worker，确保同一个组的测试用例在同一个进程中执行</li>
<li>目前无法自定义分组，按类 class 分组优先于按模块 module 分组</li>
</ul>
<p>执行命令：<code>pytest -s -v -n 3 --dist=loadscope test_xdist1.py test_xdist2.py</code></p>
<p>执行结果：</p>
<details><summary>点击查看结果</summary>
<div><pre><code>结果：
test_xdist2.py::test2
test_xdist1.py::Test1::test12
test_xdist1.py::test1
[gw2] PASSED test_xdist2.py::test2
[gw0] PASSED test_xdist1.py::test1
[gw1] PASSED test_xdist1.py::Test1::test12
test_xdist1.py::Test1::test13
test_xdist2.py::Test2::test22
[gw1] PASSED test_xdist1.py::Test1::test13
[gw0] PASSED test_xdist2.py::Test2::test22
test_xdist2.py::Test2::test23
[gw0] PASSED test_xdist2.py::Test2::test23
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div></details>
<p>[gw0]: 执行 <code>test_xdist1.py::test1、test_xdist2.py::Test2::test22</code>、<code>test_xdist2.py::Test2::test23</code> 用例</p>
<p>[gw1]: 执行 <code>test_xdist1.py::Test1::test12</code>、<code>test_xdist1.py::Test1::test13</code> 用例</p>
<p>[gw2]: 执行 <code>test_xdist2.py::test2</code> 用例</p>
<h3 id="dist-loadfile"> <code>--dist=loadfile</code></h3>
<p>按照同一个文件名来分组，然后将每个测试组发给可以执行的 worker，确保同一个组的测试用例在同一个进程中执行</p>
<p>执行命令：<code>pytest -s -v -n 3 --dist=loadfile test_xdist1.py test_xdist2.py</code></p>
<p>执行结果：</p>
<details><summary>点击查看结果</summary>
<div><pre><code>test_xdist1<span>.</span>py<span>:</span><span>:</span>test1
test_xdist2<span>.</span>py<span>:</span><span>:</span>test2
<span>[</span>gw1<span>]</span> PASSED test_xdist2<span>.</span>py<span>:</span><span>:</span>test2
<span>[</span>gw0<span>]</span> PASSED test_xdist1<span>.</span>py<span>:</span><span>:</span>test1
test_xdist1<span>.</span>py<span>:</span><span>:</span>Test1<span>:</span><span>:</span>test12
test_xdist2<span>.</span>py<span>:</span><span>:</span>Test2<span>:</span><span>:</span>test22
<span>[</span>gw0<span>]</span> PASSED test_xdist1<span>.</span>py<span>:</span><span>:</span>Test1<span>:</span><span>:</span>test12
<span>[</span>gw1<span>]</span> PASSED test_xdist2<span>.</span>py<span>:</span><span>:</span>Test2<span>:</span><span>:</span>test22
test_xdist1<span>.</span>py<span>:</span><span>:</span>Test1<span>:</span><span>:</span>test13
test_xdist2<span>.</span>py<span>:</span><span>:</span>Test2<span>:</span><span>:</span>test23
<span>[</span>gw0<span>]</span> PASSED test_xdist1<span>.</span>py<span>:</span><span>:</span>Test1<span>:</span><span>:</span>test13
<span>[</span>gw1<span>]</span> PASSED test_xdist2<span>.</span>py<span>:</span><span>:</span>Test2<span>:</span><span>:</span>test23
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div></details>
<p>[gw0]: 执行 <code>test_xdist1.py</code> 下的所有用例</p>
<p>[gw1]: 执行 <code>test_xdist2.py</code> 下的所有用例</p>
<h3 id="dist-each"> <code>--dist=each</code></h3>
<p>是将每个用例，分别发给所有的执行器 worker，相当于开了几个执行器 worker，同一个用例就执行几遍</p>
<p>执行命令：<code>pytest -s -v -n 3 --dist=each test_xdist1.py</code></p>
<p>执行结果：</p>
<details><summary>点击查看结果</summary>
<div><pre><code>test_xdist1<span>.</span>py<span>:</span><span>:</span>test1
<span>[</span>gw2<span>]</span> PASSED test_xdist1<span>.</span>py<span>:</span><span>:</span>test1
<span>[</span>gw1<span>]</span> PASSED test_xdist1<span>.</span>py<span>:</span><span>:</span>test1
test_xdist1<span>.</span>py<span>:</span><span>:</span>Test1<span>:</span><span>:</span>test12
<span>[</span>gw0<span>]</span> PASSED test_xdist1<span>.</span>py<span>:</span><span>:</span>test1
test_xdist1<span>.</span>py<span>:</span><span>:</span>Test1<span>:</span><span>:</span>test12
<span>[</span>gw2<span>]</span> PASSED test_xdist1<span>.</span>py<span>:</span><span>:</span>Test1<span>:</span><span>:</span>test12
<span>[</span>gw0<span>]</span> PASSED test_xdist1<span>.</span>py<span>:</span><span>:</span>Test1<span>:</span><span>:</span>test12
test_xdist1<span>.</span>py<span>:</span><span>:</span>Test1<span>:</span><span>:</span>test12
<span>[</span>gw1<span>]</span> PASSED test_xdist1<span>.</span>py<span>:</span><span>:</span>Test1<span>:</span><span>:</span>test12
test_xdist1<span>.</span>py<span>:</span><span>:</span>Test1<span>:</span><span>:</span>test13
<span>[</span>gw2<span>]</span> PASSED test_xdist1<span>.</span>py<span>:</span><span>:</span>Test1<span>:</span><span>:</span>test13
<span>[</span>gw0<span>]</span> PASSED test_xdist1<span>.</span>py<span>:</span><span>:</span>Test1<span>:</span><span>:</span>test13
<span>[</span>gw1<span>]</span> PASSED test_xdist1<span>.</span>py<span>:</span><span>:</span>Test1<span>:</span><span>:</span>test13
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div></details>
<p>可以看到，每个用例都分别被 [gw0]、[gw1]、[gw2] 执行了一遍</p>
<h2 id="如何让-scope-session-的-fixture-在-test-session-中仅仅执行一次"> 如何让 <code>scope=session</code> 的 fixture 在 test session 中仅仅执行一次</h2>
<h3 id="存在问题"> 存在问题</h3>
<p>pytest-xdist 是让每个 worker 进程执行属于自己的测试用例集下的所有测试用例</p>
<p>这意味着在不同进程中，不同的测试用例可能会调用同一个 scope 范围级别较高（例如 session）的 fixture，该 fixture 则会被执行多次，这不符合 <code>scope=session</code> 的预期</p>
<h3 id="如何解决"> 如何解决</h3>
<p><code>pytest-xdist</code> 没有内置的支持来确保会话范围的夹具仅执行一次，但是可以通过使用锁定文件进行进程间通信来实现</p>
<p>例子：</p>
<div><pre><code><span>import</span> pytest
<span>from</span> filelock <span>import</span> FileLock

<span>@pytest<span>.</span>fixture</span><span>(</span>scope<span>=</span><span>"session"</span><span>)</span>
<span>def</span> <span>login</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"====登录功能，返回账号，token==="</span><span>)</span>
    <span>with</span> FileLock<span>(</span><span>"session.lock"</span><span>)</span><span>:</span>
        name <span>=</span> <span>"testyy"</span>
        token <span>=</span> <span>"npoi213bn4"</span>
        <span># web ui自动化</span>
        <span># 声明一个driver，再返回</span>

        <span># 接口自动化</span>
        <span># 发起一个登录请求，将token返回都可以这样写</span>
    <span>yield</span> name<span>,</span> token
    <span>print</span><span>(</span><span>"====退出登录！！！===="</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><ul>
<li>下面的示例只需要执行一次 login（因为它是只需要执行一次来定义配置选项，等等）</li>
<li>当第一次请求这个 fixture 时，则会利用 FileLock 仅产生一次 fixture 数据</li>
<li>当其他进程再次请求这个 fixture 时，则会从文件中读取数据</li>
</ul>
<div><p>思考</p>
<ul>
<li>对于用例中有阻断进程的操作，如 sleep 操作，<code>pytest-xdist</code> 分布式执行确实效果很显著</li>
<li>对于 <code>pytest-xdist</code> 有没有用例量级的限制？如果超过这个量级，<code>pytest-xdist</code> 分布式是否还有效果？这个暂时还没有得到这个量化</li>
<li>如果用例中使用了多线程，那 <code>pytest-xdist</code> 的方式还有效？这个待后续研究</li>
</ul>
</div>
<h2 id="参考资料"> 参考资料</h2>
<p><a href="https://pytest-xdist.readthedocs.io/en/latest/" target="_blank" rel="noopener noreferrer">官方文档-pytest-xdist</a></p>
<p><a href="https://www.jianshu.com/p/1c3c3095d2a9" target="_blank" rel="noopener noreferrer">Pytest 分布式执行 pytest-xdist</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-28T07:39:59.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">pytest-rerunfailures</title>
    <id>https://www.snowji.cn/test/frameworks/pytest/pytest-rerunfailures/</id>
    <link href="https://www.snowji.cn/test/frameworks/pytest/pytest-rerunfailures/"/>
    <updated>2022-08-28T07:39:59.000Z</updated>
    <content type="html"><![CDATA[<h1 id="pytest-rerunfailures"> pytest-rerunfailures</h1>
<p>用于对失败用例进行重跑的插件</p>
<h2 id="环境要求"> 环境要求</h2>
<ul>
<li>Python 3.5, 最高 3.8, or PyPy3</li>
<li>pytest 5.0 或更高版本</li>
</ul>
<h2 id="安装"> 安装</h2>
<div><pre><code>pip install pytest<span>-</span>rerunfailures
</code></pre>
<div><span>1</span><br></div></div><h2 id="pytest-rerunfailures-使用"> pytest-rerunfailures 使用</h2>
<p>有两种方式：</p>
<ul>
<li>命令行模式</li>
<li>装饰器模式</li>
</ul>
<h3 id="命令行模式"> 命令行模式</h3>
<h4 id="运行所有失败用例"> 运行所有失败用例</h4>
<p>使用 <code>--reruns</code> 需要指定最大运行次数</p>
<div><pre><code>pytest <span>-</span><span>-</span>reruns <span>5</span> <span>-</span>s
</code></pre>
<div><span>1</span><br></div></div><div><p>注意</p>
<p>运行失败的 fixture 或 <code>setup_class</code> 也会重新执行</p>
</div>
<p>要在两次之间增加延迟时间，使用 <code>--reruns-delay</code> 其中包含了希望在下一次测试重新开始之前等待的时间</p>
<div><pre><code>pytest <span>-</span><span>-</span>reruns <span>5</span> <span>-</span><span>-</span>reruns<span>-</span>delay <span>2</span> <span>-</span>s
</code></pre>
<div><span>1</span><br></div></div><h3 id="装饰器模式"> 装饰器模式</h3>
<h4 id="重新运行指定的测试用例"> 重新运行指定的测试用例</h4>
<p>要将单个测试用例添加 flaky 装饰器 <code>@pytest.mark.flaky(reruns=5)</code>，并在测试失败时自动重新运行，需要指定最大重新运行的次数</p>
<div><pre><code><span>import</span> pytest
<span>@pytest<span>.</span>mark<span>.</span>flaky</span><span>(</span>reruns<span>=</span><span>5</span><span>)</span>
<span>def</span> <span>test_example</span><span>(</span><span>)</span><span>:</span>
    <span>import</span> random
    <span>assert</span> random<span>.</span>choice<span>(</span><span>[</span><span>True</span><span>,</span> <span>False</span><span>,</span> <span>False</span><span>]</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>也可以指定重新运行的等待时间</p>
<div><pre><code><span>import</span> pytest
<span>@pytest<span>.</span>mark<span>.</span>flaky</span><span>(</span>reruns<span>=</span><span>5</span><span>,</span> reruns_delay<span>=</span><span>2</span><span>)</span>
<span>def</span> <span>test_example</span><span>(</span><span>)</span><span>:</span>
    <span>import</span> random
    <span>assert</span> random<span>.</span>choice<span>(</span><span>[</span><span>True</span><span>,</span> <span>False</span><span>,</span> <span>False</span><span>]</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><p>注意</p>
<p>如果使用装饰器形式指定了用例的重新运行次数，则在命令行添加 <code>--reruns</code> 对这些用例是不会生效的</p>
</div>
<h2 id="兼容性问题"> 兼容性问题</h2>
<ul>
<li>不可以与 fixture 装饰器一起使用：<code>@pytest.fixture()</code></li>
<li>该插件与 pytest-xdist 的 <code>--looponfail</code> 标志不兼容</li>
<li>该插件在使用<code>--pdb</code>调试时候会有不兼容性</li>
</ul>
<h2 id="参考资料"> 参考资料</h2>
<p><a href="https://github.com/pytest-dev/pytest-rerunfailures" target="_blank" rel="noopener noreferrer">官方文档:pytest-rerunfailures</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-28T07:39:59.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">pytest.ini 配置文件</title>
    <id>https://www.snowji.cn/test/frameworks/pytest/pytest.ini/</id>
    <link href="https://www.snowji.cn/test/frameworks/pytest/pytest.ini/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="pytest-ini-配置文件"> pytest.ini 配置文件</h1>
<h2 id="配置文件作用"> 配置文件作用</h2>
<p>Pytest 配置文件可以改变 Pytest 的运行方式，它是一个固定的文件 <code>pytest.ini</code> 文件，读取配置信息，按指定的方式去运行</p>
<div><p>pytest.ini 位置</p>
<p>只能在根目录下</p>
</div>
<h2 id="非-test-文件"> 非 test 文件</h2>
<p>Pytest 里面有些文件是非 test 文件</p>
<ul>
<li>pytest.ini: Pytest 的主配置文件，可以改变 Pytest 的默认行为</li>
<li>conftest.py: 测试用例的一些 fixture 配置</li>
<li><code>_init_.py</code>: 识别该文件夹为 Python 的 package 包</li>
<li>tox.ini 与 pytest.ini 类似，用 tox 工具时候才有用</li>
<li>setup.cfg 也是 ini 格式文件，影响 setup.py 的行为</li>
</ul>
<h2 id="pytest-ini-配置文件-2"> <code>pytest.ini</code> 配置文件</h2>
<h3 id="基本格式"> 基本格式</h3>
<div><pre><code>[pytest]

addopts = -rsxX
xfail_strict = true
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="查看-pytest-ini-的设置选项"> 查看 <code>pytest.ini</code> 的设置选项</h3>
<p>使用 <code>pytest -h</code> 命令，找到下面的内容</p>
<details><summary>相关设置选项</summary>
<div><pre><code>[pytest] ini-options in the first pytest.ini|tox.ini|setup.cfg file found:

  markers (linelist):   markers for test functions
  empty_parameter_set_mark (string):
                        default marker for empty parametersets
  norecursedirs (args): directory patterns to avoid for recursion
  testpaths (args):     directories to search for tests when no files or
                        directories are given in the command line.
  filterwarnings (linelist):
                        Each line specifies a pattern for
                        warnings.filterwarnings. Processed after
                        -W/--pythonwarnings.
  usefixtures (args):   list of default fixtures to be used with this
                        project
  python_files (args):  glob-style file patterns for Python test module
                        discovery
  python_classes (args):
                        prefixes or glob names for Python test class
                        discovery
  python_functions (args):
                        prefixes or glob names for Python test function and
                        method discovery
  disable_test_id_escaping_and_forfeit_all_rights_to_community_support (bool):
                        disable string escape non-ascii characters, might
                        cause unwanted side effects(use at your own risk)
  console_output_style (string):
                        console output: &quot;classic&quot;, or with additional
                        progress information (&quot;progress&quot; (percentage) |
                        &quot;count&quot;).
  xfail_strict (bool):  default for the strict parameter of xfail markers
                        when not given explicitly (default: False)
  enable_assertion_pass_hook (bool):
                        Enables the pytest_assertion_pass hook.Make sure to
                        delete any previously generated pyc cache files.
  junit_suite_name (string):
                        Test suite name for JUnit report
  junit_logging (string):
                        Write captured log messages to JUnit report: one of
                        no|log|system-out|system-err|out-err|all
  junit_log_passing_tests (bool):
                        Capture log information for passing tests to JUnit
                        report:
  junit_duration_report (string):
                        Duration time to report: one of total|call
  junit_family (string):
                        Emit XML for schema: one of legacy|xunit1|xunit2
  doctest_optionflags (args):
                        option flags for doctests
  doctest_encoding (string):
                        encoding used for doctest files
  cache_dir (string):   cache directory path.
  log_level (string):   default value for --log-level
  log_format (string):  default value for --log-format
  log_date_format (string):
                        default value for --log-date-format
  log_cli (bool):       enable log display during test run (also known as
                        &quot;live logging&quot;).
  log_cli_level (string):
                        default value for --log-cli-level
  log_cli_format (string):
                        default value for --log-cli-format
  log_cli_date_format (string):
                        default value for --log-cli-date-format
  log_file (string):    default value for --log-file
  log_file_level (string):
                        default value for --log-file-level
  log_file_format (string):
                        default value for --log-file-format
  log_file_date_format (string):
                        default value for --log-file-date-format
  log_auto_indent (string):
                        default value for --log-auto-indent
  pythonpath (paths):   Add paths to sys.path
  faulthandler_timeout (string):
                        Dump the traceback of all threads if a test takes
                        more than TIMEOUT seconds to finish.
  addopts (args):       extra command line options
  minversion (string):  minimally required pytest version
  required_plugins (args):
                        plugins that must be present for pytest to run

environment variables:
  PYTEST_ADDOPTS           extra command line options
  PYTEST_PLUGINS           comma-separated plugins to load during startup
  PYTEST_DISABLE_PLUGIN_AUTOLOAD set to disable plugin auto-loading
  PYTEST_DEBUG             set to enable debug tracing of pytest&#39;s internals


to see available markers type: pytest --markers
to see available fixtures type: pytest --fixtures
(shown according to specified file_or_dir or current dir if not specified; fixtures with leading &#39;_&#39; are only shown with the &#39;-v&#39; option
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br></div></div></details>
<h2 id="常用配置项"> 常用配置项</h2>
<p>介绍下常用的配置项，其他配置项可在参考资料中查阅</p>
<h3 id="addopts"> addopts</h3>
<p>添加命令行参数集</p>
<div><pre><code>[pytest]
addopts = -s -v --maxfail=2 -rf  # exit after 2 failures, report fail info
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>相当于</p>
<div><pre><code>pytest <span>-</span>s <span>-</span>v <span>-</span><span>-</span>maxfail<span>=</span><span>2</span> <span>-</span>rf test_hello<span>.</span>py
</code></pre>
<div><span>1</span><br></div></div><p>设置后之后在 cmd 中只需输入 pytest 就行，很方便</p>
<h3 id="testpaths"> testpaths</h3>
<p>设置执行测试用例的目录</p>
<div><pre><code>[pytest]
testpaths = testing
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>设置后，在根目录下运行 pytest 时，只会从 testing 目录中寻找并执行测试用例</p>
<p>例子：</p>
<p><img src="./images/15.png" alt="pytest" /></p>
<p>可以看到结果中只执行了 <code>testing/</code> 目录下的测试用例</p>
<h3 id="markers"> markers</h3>
<p>指定执行被标记的测试用例</p>
<div><pre><code>[pytest]
markers =
    slow:this is a slow
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>例子：</p>
<p><img src="./images/16.png" alt="pytest" /></p>
<p>可以看到只有被标记的 <code>test_04</code> 被执行了</p>
<div><p>注意</p>
<p>-m ：参数后要跟上执行的标记名，即在 markers 中设置的</p>
</div>
<h3 id="更改测试用例收集规则"> 更改测试用例收集规则</h3>
<p>pytest默认的测试用例收集规则</p>
<ul>
<li>文件名以 <code>test_*.py</code> 文件和 <code>*_test.py</code></li>
<li>以 <code>test_</code> 开头的函数</li>
<li>以 Test 开头的类，不能包含 <code>__init__</code> 方法</li>
<li>以 <code>test_</code> 开头的类里面的方法</li>
</ul>
<p>我们是可以修改或者添加这个用例收集规则的，建议在原有的规则上添加的，如下配置</p>
<div><pre><code>[pytest] 
python_files = test_*  *_test  test* 
python_classes = Test*   test* 
python_functions = test_*  test*
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="norecursedirs"> norecursedirs</h3>
<p>Pytest 收集测试用例时，会递归遍历所有子目录，包括某些你明知道没必要遍历的目录，遇到这种情况，可以使用 norecursedirs 参数简化 Pytest 的搜索工作</p>
<p><strong>默认设置</strong>：<code>norecursedirs = .* build dist CVS _darcs {arch} *.egg</code></p>
<p><strong>正确写法</strong>：多个路径用空格隔开</p>
<div><pre><code>[pytest] norecursedirs = .* build dist CVS _darcs {arch} *.egg venv src resources log report util
</code></pre>
<div><span>1</span><br></div></div><h2 id="参考资料"> 参考资料</h2>
<p><a href="https://docs.pytest.org/en/latest/reference/customize.html?highlight=ini" target="_blank" rel="noopener noreferrer">官方文档-Configuration</a></p>
<p><a href="https://docs.pytest.org/en/latest/reference/reference.html#ini-options-ref" target="_blank" rel="noopener noreferrer">官方文档-Configuration Options</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-28T07:39:59.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">自定义 mark</title>
    <id>https://www.snowji.cn/test/frameworks/pytest/mark/</id>
    <link href="https://www.snowji.cn/test/frameworks/pytest/mark/"/>
    <updated>2022-08-28T07:39:59.000Z</updated>
    <content type="html"><![CDATA[<h1 id="自定义-mark"> 自定义 mark</h1>
<h2 id="作用"> 作用</h2>
<ul>
<li>Pytest 可以支持自定义标记，自定义标记可以把一个项目划分多个模块，然后指定模块名称执行</li>
<li>比如标明哪些是 ios 用例，哪些是 android 的，运行代码时候指定 mark 名称运行就可以</li>
</ul>
<h2 id="示例"> 示例</h2>
<div><pre><code><span>import</span> pytest

<span>@pytest<span>.</span>mark<span>.</span>webtest</span>
<span>def</span> <span>test_send_http</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"1111"</span><span>)</span> <span># perform some webtest test for your app</span>

<span>def</span> <span>test_something_quick</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"2222"</span><span>)</span>

<span>def</span> <span>test_another</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"3333"</span><span>)</span>

<span>class</span> <span>TestClass</span><span>:</span>
    <span>def</span> <span>test_method</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"4444"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>使用命令：<code>pytest -s -v -m webtest test_mark.py</code></p>
<p>测试结果：</p>
<p><img src="./images/33.png" alt="pytest" /></p>
<p>可以看到结果中有个 warning</p>
<p><strong>原因</strong>：自定义的 mark 没有在 pytest.ini 文件中注册</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>
<p>新建 pytest.py 文件</p>
</li>
<li>
<p>在文件中输入</p>
</li>
</ul>
<div><pre><code>  <span>[</span>pytest<span>]</span>
  mark <span>=</span> 
  	webtest
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>注意</strong>: <code>pytest.ini</code> 需要和运行的测试用例同一个目录，或在根目录下作用于全局</p>
<h3 id="执行未标记的用例"> 执行未标记的用例</h3>
<div><pre><code>pytest <span>-</span>s <span>-</span>v <span>-</span>m <span>"not webtest"</span> test_mark<span>.</span>py
</code></pre>
<div><span>1</span><br></div></div><p>测试结果：</p>
<p><img src="./images/34.png" alt="pytest" /></p>
<h3 id="执行多个标记的用例"> 执行多个标记的用例</h3>
<div><pre><code>pytest <span>-</span>s <span>-</span>v <span>-</span>m <span>"login or webtest"</span> test_mark<span>.</span>py
</code></pre>
<div><span>1</span><br></div></div><p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-28T07:39:59.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">pytest-assume</title>
    <id>https://www.snowji.cn/test/frameworks/pytest/pytest-assume/</id>
    <link href="https://www.snowji.cn/test/frameworks/pytest/pytest-assume/"/>
    <updated>2022-08-28T07:39:59.000Z</updated>
    <content type="html"><![CDATA[<h1 id="pytest-assume"> pytest-assume</h1>
<h2 id="什么是-pytest-assume"> 什么是 pytest-assume</h2>
<ul>
<li>一个可以允许 pytest 测试用例中执行多个失败的断言的插件</li>
<li>即使上面的断言1，断言2，断言3 都失败的情况下，其下的断言都能被执行</li>
<li>源于 <code>pytest-expect</code> 插件并进行了改进
<ul>
<li>支持 showlocals（即 Pytest 命令行的 <code>-l</code> 参数, 显示执行过程中的局部变量）</li>
<li>可以全局使用，无需指定 fixtrue 装饰器（即任意 <code>test_xxx</code> 函数中都能用）</li>
<li>对断言输出做了一些格式上的美化</li>
</ul>
</li>
</ul>
<h2 id="为什么要使用-pytest-assume"> 为什么要使用 pytest-assume</h2>
<ul>
<li>使用原生 python 的 assert，就会遇到一个断言失败则全部失败的情况，比如说，断言1 结果为 Failed，那么其下的断言2 和断言3 都不会被执行</li>
<li>如果希望其下的断言1 和断言2 继续执行，就可能获取更多的断言结果更好的定位问题</li>
</ul>
<h2 id="pytest-assume-安装"> pytest-assume 安装</h2>
<div><pre><code>pip install git<span>+</span>https<span>:</span><span>//</span>github<span>.</span>com<span>/</span>astraw38<span>/</span>pytest<span>-</span>assume<span>.</span>git
或者
pip install pytest<span>-</span>assume
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="pytest-assume-使用"> pytest-assume 使用</h2>
<h3 id="简单例子"> 简单例子</h3>
<div><pre><code><span># Python 的 assert 断言</span>
<span>def</span> <span>test_add1</span><span>(</span><span>)</span><span>:</span>
    <span>assert</span> <span>1</span> <span>+</span> <span>4</span> <span>==</span> <span>5</span>
    <span>assert</span> <span>1</span> <span>+</span> <span>3</span> <span>==</span> <span>3</span>
    <span>assert</span> <span>2</span> <span>+</span> <span>5</span> <span>==</span> <span>7</span>
    <span>assert</span> <span>2</span> <span>+</span> <span>5</span> <span>==</span> <span>9</span>
    <span>print</span><span>(</span><span>"执行完成"</span><span>)</span>

<span># Pytest 的 assume 断言</span>
<span>import</span> pytest
<span>def</span> <span>test_add2</span><span>(</span><span>)</span><span>:</span>
    pytest<span>.</span>assume<span>(</span><span>1</span> <span>+</span> <span>4</span> <span>==</span> <span>5</span><span>)</span>
    pytest<span>.</span>assume<span>(</span><span>1</span> <span>+</span> <span>3</span> <span>==</span> <span>3</span><span>)</span>
    pytest<span>.</span>assume<span>(</span><span>2</span> <span>+</span> <span>5</span> <span>==</span> <span>7</span><span>)</span>
    pytest<span>.</span>assume<span>(</span><span>2</span> <span>+</span> <span>5</span> <span>==</span> <span>9</span><span>)</span>
    <span>print</span><span>(</span><span>"测试完成"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>执行结果：</p>
<details><summary>点击查看结果</summary>
<div><pre><code>test_assume<span>.</span>py<span>:</span><span>:</span>test_add1 FAILED
test_assume<span>.</span>py<span>:</span><span>1</span> <span>(</span>test_add1<span>)</span>
<span>4</span> <span>!=</span> <span>3</span>

Expected <span>:</span><span>3</span>
Actual   <span>:</span><span>4</span>
<span>&lt;</span>Click to see difference<span>></span>

<span>def</span> <span>test_add1</span><span>(</span><span>)</span><span>:</span>
        <span>assert</span> <span>1</span> <span>+</span> <span>4</span> <span>==</span> <span>5</span>
<span>></span>       <span>assert</span> <span>1</span> <span>+</span> <span>3</span> <span>==</span> <span>3</span>
E       <span>assert</span> <span>4</span> <span>==</span> <span>3</span>

test_assume<span>.</span>py<span>:</span><span>4</span><span>:</span> AssertionError

test_assume<span>.</span>py<span>:</span><span>:</span>test_add2 测试完成
FAILED
test_assume<span>.</span>py<span>:</span><span>10</span> <span>(</span>test_add2<span>)</span>
tp <span>=</span> <span>&lt;</span><span>class</span> <span>'pytest_assume.plugin.FailedAssumption'</span><span>></span><span>,</span> value <span>=</span> <span>None</span><span>,</span> tb <span>=</span> <span>None</span>

    <span>def</span> <span>reraise</span><span>(</span>tp<span>,</span> value<span>,</span> tb<span>=</span><span>None</span><span>)</span><span>:</span>
        <span>try</span><span>:</span>
            <span>if</span> value <span>is</span> <span>None</span><span>:</span>
                value <span>=</span> tp<span>(</span><span>)</span>
            <span>if</span> value<span>.</span>__traceback__ <span>is</span> <span>not</span> tb<span>:</span>
<span>></span>               <span>raise</span> value<span>.</span>with_traceback<span>(</span>tb<span>)</span>
E               pytest_assume<span>.</span>plugin<span>.</span>FailedAssumption<span>:</span> 
E               <span>2</span> Failed Assumptions<span>:</span>
E               
E               test_assume<span>.</span>py<span>:</span><span>13</span><span>:</span> AssumptionFailure
E               <span>>></span>	pytest<span>.</span>assume<span>(</span><span>1</span> <span>+</span> <span>3</span> <span>==</span> <span>3</span><span>)</span>
E               AssertionError<span>:</span> <span>assert</span> <span>False</span>
E               
E               test_assume<span>.</span>py<span>:</span><span>15</span><span>:</span> AssumptionFailure
E               <span>>></span>	pytest<span>.</span>assume<span>(</span><span>2</span> <span>+</span> <span>5</span> <span>==</span> <span>9</span><span>)</span>
E               AssertionError<span>:</span> <span>assert</span> <span>False</span>

E<span>:</span>\venv<span>-</span>path\pytest<span>-</span>path\lib\site<span>-</span>packages\six<span>.</span>py<span>:</span><span>718</span><span>:</span> FailedAssumption


<span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span> FAILURES <span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>=</span>
__________________________________ test_add1 __________________________________

    <span>def</span> <span>test_add1</span><span>(</span><span>)</span><span>:</span>
        <span>assert</span> <span>1</span> <span>+</span> <span>4</span> <span>==</span> <span>5</span>
<span>></span>       <span>assert</span> <span>1</span> <span>+</span> <span>3</span> <span>==</span> <span>3</span>
E       <span>assert</span> <span>4</span> <span>==</span> <span>3</span>

test_assume<span>.</span>py<span>:</span><span>4</span><span>:</span> AssertionError
__________________________________ test_add2 __________________________________

tp <span>=</span> <span>&lt;</span><span>class</span> <span>'pytest_assume.plugin.FailedAssumption'</span><span>></span><span>,</span> value <span>=</span> <span>None</span><span>,</span> tb <span>=</span> <span>None</span>

    <span>def</span> <span>reraise</span><span>(</span>tp<span>,</span> value<span>,</span> tb<span>=</span><span>None</span><span>)</span><span>:</span>
        <span>try</span><span>:</span>
            <span>if</span> value <span>is</span> <span>None</span><span>:</span>
                value <span>=</span> tp<span>(</span><span>)</span>
            <span>if</span> value<span>.</span>__traceback__ <span>is</span> <span>not</span> tb<span>:</span>
<span>></span>               <span>raise</span> value<span>.</span>with_traceback<span>(</span>tb<span>)</span>
E               pytest_assume<span>.</span>plugin<span>.</span>FailedAssumption<span>:</span> 
E               <span>2</span> Failed Assumptions<span>:</span>
E               
E               test_assume<span>.</span>py<span>:</span><span>13</span><span>:</span> AssumptionFailure
E               <span>>></span>	pytest<span>.</span>assume<span>(</span><span>1</span> <span>+</span> <span>3</span> <span>==</span> <span>3</span><span>)</span>
E               AssertionError<span>:</span> <span>assert</span> <span>False</span>
E               
E               test_assume<span>.</span>py<span>:</span><span>15</span><span>:</span> AssumptionFailure
E               <span>>></span>	pytest<span>.</span>assume<span>(</span><span>2</span> <span>+</span> <span>5</span> <span>==</span> <span>9</span><span>)</span>
E               AssertionError<span>:</span> <span>assert</span> <span>False</span>

E<span>:</span>\venv<span>-</span>path\pytest<span>-</span>path\lib\site<span>-</span>packages\six<span>.</span>py<span>:</span><span>718</span><span>:</span> FailedAssumption
<span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>=</span> short test summary info <span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>=</span>
FAILED test_assume<span>.</span>py<span>:</span><span>:</span>test_add1 <span>-</span> <span>assert</span> <span>4</span> <span>==</span> <span>3</span>
FAILED test_assume<span>.</span>py<span>:</span><span>:</span>test_add2 <span>-</span> pytest_assume<span>.</span>plugin<span>.</span>FailedAssumption<span>:</span> 

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br></div></div></details>
<p>可以看出：</p>
<ul>
<li>test_add1 断言失败后正确的断言没有执行</li>
<li>test_add2 断言失败后正确的断言继续执行</li>
</ul>
<h3 id="pytest-assume-上下文管理器-with"> pytest-assume 上下文管理器 with</h3>
<div><pre><code><span>import</span> pytest
<span>from</span> pytest <span>import</span> assume

<span>@pytest<span>.</span>mark<span>.</span>parametrize</span><span>(</span><span>(</span><span>'x'</span><span>,</span> <span>'y'</span><span>)</span><span>,</span> <span>[</span><span>(</span><span>1</span><span>,</span> <span>1</span><span>)</span><span>,</span> <span>(</span><span>1</span><span>,</span> <span>0</span><span>)</span><span>,</span> <span>(</span><span>0</span><span>,</span> <span>1</span><span>)</span><span>]</span><span>)</span>
<span>def</span> <span>test_simple_assume1</span><span>(</span>x<span>,</span> y<span>)</span><span>:</span>
    <span>with</span> assume<span>:</span> <span>assert</span> x <span>==</span> y
    <span>with</span> assume<span>:</span> <span>assert</span> <span>True</span>
    <span>with</span> assume<span>:</span> <span>assert</span> <span>False</span>

<span>@pytest<span>.</span>mark<span>.</span>parametrize</span><span>(</span><span>(</span><span>'x'</span><span>,</span> <span>'y'</span><span>)</span><span>,</span> <span>[</span><span>(</span><span>1</span><span>,</span> <span>1</span><span>)</span><span>,</span> <span>(</span><span>1</span><span>,</span> <span>0</span><span>)</span><span>,</span> <span>(</span><span>0</span><span>,</span> <span>1</span><span>)</span><span>]</span><span>)</span>
<span>def</span> <span>test_simple_assume2</span><span>(</span>x<span>,</span> y<span>)</span><span>:</span>
    <span>with</span> pytest<span>.</span>assume<span>:</span>
        <span>assert</span> x <span>==</span> y
        <span>assert</span> <span>True</span>
        <span>assert</span> <span>False</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><div><p>注意</p>
<p>如果上下文管理器里面包含多个断言，如果第一个断言失败，后面的不会被执行</p>
</div>
<h2 id="参考文档"> 参考文档</h2>
<p><a href="https://github.com/astraw38/pytest-assume" target="_blank" rel="noopener noreferrer">官方文档-pytest-assuem</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-28T07:39:59.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">pytest-html</title>
    <id>https://www.snowji.cn/test/frameworks/pytest/pytest-html/</id>
    <link href="https://www.snowji.cn/test/frameworks/pytest/pytest-html/"/>
    <updated>2022-08-28T07:39:59.000Z</updated>
    <content type="html"><![CDATA[<h1 id="pytest-html"> pytest-html</h1>
<p>用于生成 html 测试报告</p>
<h2 id="前提"> 前提</h2>
<p>Python &gt;=3.6 或 PyPy3</p>
<h2 id="安装-pytest-html"> 安装 pytest-html</h2>
<p>两种安装方式:</p>
<ul>
<li>使用 pip 安装</li>
</ul>
<div><pre><code> pip install pytest<span>-</span>html
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>从源安装</li>
</ul>
<div><pre><code> pip install <span>-</span>e <span>.</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="生成报告"> 生成报告</h2>
<p>在当前目录下创建报告</p>
<div><pre><code>pytest <span>-</span><span>-</span>html<span>=</span>report<span>.</span>html

</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="合并css"> 合并CSS</h3>
<p>上面命令生成的报告，css 和图像是分开的，分享报告的时候样式会丢失，为了更好的分享发邮件展示报告，可以把 css 样式合并到 html 里</p>
<div><pre><code>pytest <span>-</span><span>-</span>html<span>=</span>report<span>.</span>html <span>-</span><span>-</span>self<span>-</span>contained<span>-</span>html
</code></pre>
<div><span>1</span><br></div></div><div><p>注意事项</p>
<ul>
<li>在将文件或链接添加到独立报告时，插件会发出 warnings</li>
<li>在 html 测试报告中可能无法按预期显示文件或链接</li>
</ul>
</div>
<h2 id="参考文档"> 参考文档</h2>
<p><a href="https://github.com/pytest-dev/pytest-html" target="_blank" rel="noopener noreferrer">github</a></p>
<p><a href="https://pytest-html.readthedocs.io/en/latest/installing.html" target="_blank" rel="noopener noreferrer">官方文档-pytest-html</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-28T07:39:59.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">setup 与 teardown</title>
    <id>https://www.snowji.cn/test/frameworks/pytest/setup-teardown/</id>
    <link href="https://www.snowji.cn/test/frameworks/pytest/setup-teardown/"/>
    <updated>2022-08-28T07:39:59.000Z</updated>
    <content type="html"><![CDATA[<h1 id="setup-与-teardown"> setup 与 teardown</h1>
<h2 id="前言"> 前言</h2>
<p>学过 Unittest 的都知道有 2 个前置方法和 2 个后置方法</p>
<ul>
<li>setup()</li>
<li>teardown()</li>
<li>setupClass()</li>
<li>teardownClass()</li>
</ul>
<p>Pytest 框架也有类似于 setup 和 teardown 的语法:</p>
<ul>
<li>模块级：<code>setup_module/teardown_module</code>，开始于模块始末，全局的</li>
<li>函数级：<code>setup_function/teardown_function</code>，只对函数用例生效（不在类中）</li>
<li>类级：<code>setup_class/teardown_class</code>，只在类中前后运行一次(在类中)</li>
<li>方法级：<code>setup_method/teardown_method</code>，开始于方法始末（在类中）</li>
<li>类里面的：<code>setup/teardown</code>，运行在调用方法的前后</li>
</ul>
<h2 id="示例"> 示例</h2>
<div><pre><code><span>import</span> pytest

<span>def</span> <span>setup_module</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"setup_module：整个.py模块只执行一次，比如：所有用例开始前只打开一次浏览器"</span><span>)</span>

<span>def</span> <span>teardown_module</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"teardown_module：整个.py模块只执行一次，比如：所有用例结束只最后关闭浏览器"</span><span>)</span>

<span>def</span> <span>setup</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"setup：每个用例执行前都会执行"</span><span>)</span>

<span>def</span> <span>teardown</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"teardown：每个用例结束后都会执行"</span><span>)</span>

<span>def</span> <span>setup_function</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"setup_function：每个用例开始前都会执行"</span><span>)</span>

<span>def</span> <span>teardown_function</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"teardown_function：每个用例结束前都会执行"</span><span>)</span>

<span>def</span> <span>test_one</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"正在执行----test_one"</span><span>)</span>


<span>def</span> <span>test_two</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"正在执行----test_two"</span><span>)</span>


<span>class</span> <span>TestCase</span><span>(</span><span>)</span><span>:</span>

    <span>def</span> <span>setup_class</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"setup_class：整个测试类所有用例执行之前"</span><span>)</span>

    <span>def</span> <span>teardown_class</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"teardown_class：整个测试类所有用例执行之后"</span><span>)</span>

    <span>def</span> <span>setup</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"setup：类里面每个用例执行前都会执行"</span><span>)</span>

    <span>def</span> <span>teardown</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"teardown：类里面每个用例结束后都会执行"</span><span>)</span>

    <span>def</span> <span>setup_method</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"setup_method：类里面每个用例执行前都会执行"</span><span>)</span>

    <span>def</span> <span>teardown_method</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"teardown_method：类里面每个用例结束后都会执行"</span><span>)</span>


    <span>def</span> <span>test_three</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"正在执行----test_three"</span><span>)</span>

    <span>def</span> <span>test_four</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"正在执行----test_four"</span><span>)</span>

<span>if</span> __name__ <span>==</span> <span>"__main__"</span><span>:</span>
    pytest<span>.</span>main<span>(</span><span>[</span><span>"-s"</span><span>,</span><span>"-q"</span><span>,</span><span>"-ra"</span><span>,</span> <span>"sample.py"</span><span>]</span><span>)</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br></div></div><p>测试结果：</p>
<p><img src="./images/5.png" alt="pytest" /></p>
<p>注释掉以下内容，重新测试：</p>
<div><pre><code><span># def setup_function():</span>
<span>#     print("setup_function：每个用例开始前都会执行")</span>
<span>#</span>
<span># def teardown_function():</span>
<span>#     print("teardown_function：每个用例结束前都会执行")</span>


 <span># def setup_method(self):</span>
    <span>#     print("setup_method：类里面每个用例执行前都会执行")</span>
    <span>#</span>
    <span># def teardown_method(self):</span>
    <span>#     print("teardown_method：类里面每个用例结束后都会执行")</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>测试结果：</p>
<p><img src="./images/6.png" alt="pytest" /></p>
<div><pre><code><span>def</span> <span>setup_module</span><span>(</span><span>)</span><span>:</span>
    <span>global</span> user_data
    user_data <span>=</span> <span>{</span><span>"path"</span><span>:</span><span>"admin"</span><span>,</span><span>"name"</span><span>:</span><span>"admin"</span><span>}</span>
    <span>print</span><span>(</span><span>id</span><span>(</span>user_data<span>)</span><span>)</span>
    <span>print</span><span>(</span><span>"使用前的{}"</span><span>.</span><span>format</span><span>(</span>user_data<span>)</span><span>)</span>


<span>def</span> <span>teardown_module</span><span>(</span><span>)</span><span>:</span>
    <span>global</span> user_data
    user_data <span>=</span> <span>123</span>
    <span>print</span><span>(</span><span>"结束后的{}"</span><span>.</span><span>format</span><span>(</span>user_data<span>)</span><span>)</span>

<span>def</span> <span>test_003</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span>user_data<span>)</span>
    <span>print</span><span>(</span><span>id</span><span>(</span>user_data<span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>结果：</p>
<div><pre><code>test_fixture<span>.</span>py<span>:</span><span>:</span>test_003 <span>1920498803200</span>
使用前的<span>{</span><span>'path'</span><span>:</span> <span>'admin'</span><span>,</span> <span>'name'</span><span>:</span> <span>'admin'</span><span>}</span>
<span>{</span><span>'path'</span><span>:</span> <span>'admin'</span><span>,</span> <span>'name'</span><span>:</span> <span>'admin'</span><span>}</span>
<span>1920498803200</span>
PASSED结束后的<span>123</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>总结</strong>：</p>
<ul>
<li><code>setup_method/teardown_method</code> 和 <code>setup/teardown</code> 都可以作用于测试类中的方法</li>
<li><code>setup_method/teardown_method</code> 的优先级高于 <code>setup/teardown</code></li>
<li>setup 这种设置全局变量后，在测试用例中可以被访问</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-28T07:39:59.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Pytest 生成简单测试报告</title>
    <id>https://www.snowji.cn/test/frameworks/pytest/simple-report/</id>
    <link href="https://www.snowji.cn/test/frameworks/pytest/simple-report/"/>
    <updated>2022-08-28T07:39:59.000Z</updated>
    <content type="html"><![CDATA[<h1 id="pytest-生成简单测试报告"> Pytest 生成简单测试报告</h1>
<h2 id="前言"> 前言</h2>
<ul>
<li>Pytest 可以生成 JunitXML 报告</li>
<li>Pytest 可以生成在线测试报告</li>
</ul>
<h2 id="junitxml-报告"> JunitXML 报告</h2>
<p>在命令行下使用</p>
<div><pre><code>pytest test_parame.py --junit-xml=./report/01.xml
</code></pre>
<div><span>1</span><br></div></div><p>运行结果：
<img src="./images/13.png" alt="pytest" /></p>
<h2 id="在线测试报告"> 在线测试报告</h2>
<p>在命令行下使用</p>
<div><pre><code>pytest test_parame.py --pastebin=all
</code></pre>
<div><span>1</span><br></div></div><p>运行后，会生成一个在线报告地址，可以点击打开</p>
<p><img src="./images/14.png" alt="pytest" /></p>
<div><p>PS</p>
<ul>
<li>上面 2 种测试报告的可读性不是很友好</li>
<li>后续会继续讲解 Pytest 使用插件生成的报告</li>
</ul>
</div>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-28T07:39:59.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">skip/skipif</title>
    <id>https://www.snowji.cn/test/frameworks/pytest/skip-skipif/</id>
    <link href="https://www.snowji.cn/test/frameworks/pytest/skip-skipif/"/>
    <updated>2022-08-28T07:39:59.000Z</updated>
    <content type="html"><![CDATA[<h1 id="skip-skipif"> skip/skipif</h1>
<h2 id="skip-skipif-作用"> skip/skipif 作用</h2>
<ul>
<li><code>@pytest.mark.skip/skipif</code>  可以标记无法在某些平台上运行的测试功能，或希望失败的测试功能</li>
<li><code>skip/skipif</code> 意味着只有在满足某些条件时才希望测试通过，否则 Pytest 应该跳过运行测试</li>
<li>常见场景：是在非 Windows 平台上跳过仅限 Windows 的测试，或跳过测试依赖于当前不可用的外部资源</li>
</ul>
<h2 id="skip"> skip</h2>
<p>两种方式：</p>
<ul>
<li>使用 <code>@pytest.mark.skip</code> 标记</li>
<li>可以在用例运行中跳过</li>
</ul>
<div><pre><code><span>import</span> pytest

<span># 使用装饰器标记跳过 reason 可填</span>
<span>@pytest<span>.</span>mark<span>.</span>skip</span>
<span>def</span> <span>test_001</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"执行测试用例1"</span><span>)</span>

<span>@pytest<span>.</span>mark<span>.</span>skip</span><span>(</span>reason<span>=</span><span>"111"</span><span>)</span>
<span>def</span> <span>test_002</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"执行测试用例2"</span><span>)</span>


<span># 用例运行期间跳过</span>
<span>def</span> <span>test_003</span><span>(</span><span>)</span><span>:</span>
    pytest<span>.</span>skip<span>(</span><span>"222"</span><span>,</span>allow_module_level<span>=</span><span>True</span><span>)</span>
    <span>print</span><span>(</span><span>"执行测试用例3"</span><span>)</span>

<span>def</span> <span>test_004</span><span>(</span><span>)</span><span>:</span>
    pytest<span>.</span>skip<span>(</span><span>)</span>
    <span>print</span><span>(</span><span>"执行测试用例4"</span><span>)</span>

<span>def</span> <span>test_005</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"执行测试用例5"</span><span>)</span>

<span># 跳过类</span>
<span>@pytest<span>.</span>mark<span>.</span>skip</span>
<span>class</span> <span>Test_case</span><span>(</span><span>)</span><span>:</span>
    <span>def</span> <span>test_006</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"执行测试用例6"</span><span>)</span>

    <span>def</span> <span>test_007</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"执行测试用例7"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>测试结果：</p>
<p><img src="./images/26.png" alt="pytest" /></p>
<div><p>重点</p>
<ul>
<li><code>allow_module_level</code> : 跳过整个模块级别</li>
<li>使用 <code>pytest.skip()</code> 函数可以在测试用例执行中跳过</li>
</ul>
</div>
<h2 id="skipif"> skipif</h2>
<p>按条件跳过测试用例</p>
<div><pre><code><span>def</span> <span>test_001</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"执行测试用例1"</span><span>)</span>

<span>@pytest<span>.</span>mark<span>.</span>skipif</span><span>(</span>condition<span>=</span><span>2</span><span>></span><span>1</span><span>,</span>reason<span>=</span><span>"skip"</span><span>)</span>
<span>def</span> <span>test_002</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"执行测试用例2"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>测试结果：<code>test_002</code> 被跳过</p>
<div><p>注意</p>
<p>强烈建议不要在使用继承的类上使用 skipif ，Pytest 中的一个已知错误标记可能会导致超类中的意外行为</p>
</div>
<h3 id="全局-skip-skipif"> 全局 skip/skipif</h3>
<p>如果要跳过模块的所有测试功能，可以在全局级别使用 pytestmark 名称</p>
<div><pre><code>pytestmark = pytest.mark.skip/skipif(...)
</code></pre>
<div><span>1</span><br></div></div><h3 id="模块间共享-skip-skipif"> 模块间共享 skip/skipif</h3>
<div><pre><code><span>#test_mymodule.py</span>
myskip <span>=</span> pytest<span>.</span>mark<span>.</span>skip<span>/</span>skipif<span>(</span><span>.</span><span>.</span><span>.</span><span>)</span>
<span>@myskip</span>
<span>def</span> <span>test_001</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"执行测试用例1"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>其他模块可以导入 myskip</p>
<div><pre><code><span>from</span> test_mymodule <span>import</span> myskip
<span>@myskip</span>
<span>def</span> <span>test_002</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"执行测试用例2"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="pytest-importorskip-modname-str-minversion-optional-str-none-reason-optional-str-none"> pytest.importorskip( modname: str, minversion: Optional[str] = None, reason: Optional[str] = None )</h2>
<p><strong>作用</strong>: 如果缺少某些导入，则跳过模块中的所有测试</p>
<p><strong>参数列表</strong></p>
<ul>
<li>modname：模块名</li>
<li>minversion：版本号</li>
<li>reason：跳过原因，默认不给也行</li>
</ul>
<div><pre><code>docutils <span>=</span> pytest<span>.</span>importorskip<span>(</span><span>"pexpect"</span><span>,</span> minversion<span>=</span><span>"0.3"</span><span>)</span>
<span>@docutils</span>
<span>def</span> <span>test_001</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"1111"</span><span>)</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>执行结果一</strong>：如果找不到module</p>
<div><pre><code>Skipped: could not import &#39;pexpect&#39;: No module named &#39;pexpect&#39; 
collected 0 items / 1 skipped
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>执行结果二</strong>：如果版本对应不上</p>
<div><pre><code>Skipped: module &#39;sys&#39; has __version__ None, required is: &#39;0.3&#39; 
collected 0 items / 1 skipped
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-28T07:39:59.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">pytest-xdist 分布式测试的原理</title>
    <id>https://www.snowji.cn/test/frameworks/pytest/pytest-xdist-theory/</id>
    <link href="https://www.snowji.cn/test/frameworks/pytest/pytest-xdist-theory/"/>
    <updated>2022-08-28T07:39:59.000Z</updated>
    <content type="html"><![CDATA[<h1 id="pytest-xdist-分布式测试的原理"> pytest-xdist 分布式测试的原理</h1>
<h2 id="分布式结构"> 分布式结构</h2>
<ul>
<li>xdist 的分布式类似于一主多从的结构，master 机负责下发命令，控制 slave 机</li>
<li>slave 机根据 master 机的命令执行特定测试任务</li>
<li>在 xdist 中，主是 master，从是 workers</li>
</ul>
<h2 id="原理简介"> 原理简介</h2>
<ul>
<li>xdist 会产生一个或多个 workers，workers 都通过 master 来控制</li>
<li>每个 worker 负责执行完整的测试用例集，然后按照 master 的要求运行测试，而 master 机不执行测试任务</li>
</ul>
<h2 id="pytest-xdist-分布式测试的流程"> pytest-xdist 分布式测试的流程</h2>
<h3 id="第一步-创建worker"> 第一步：创建worker</h3>
<ul>
<li>master 会在总测试会话（test session）开始前产生一个或多个 worker</li>
<li>master 和 worker 之间是通过 execnet 和网关来通信的</li>
<li>实际编译执行测试代码的 worker 可能是本地机器也可能是远程机器</li>
</ul>
<h3 id="第二步-收集测试项用例"> 第二步：收集测试项用例</h3>
<ul>
<li>每个 worker 类似一个迷你型的 Pytest 执行器</li>
<li>worker 会执行一个完整的 test collection 过程【收集所有测试用例的过程】</li>
<li>然后把测试用例的 ids 返回给 master</li>
<li>master 是不会执行任何测试用例集的</li>
</ul>
<p><strong>注意</strong>：</p>
<p>为什么上面通过分布式测试的结果截图是没有输出用例的 print 内容，因为主机并不执行测试用例，pycharm 相当于一个 master</p>
<h3 id="第三步-master-检测-workers-收集到的测试用例集"> 第三步：master 检测 workers 收集到的测试用例集</h3>
<ul>
<li>master 接收到所有 worker 收集的测试用例集之后，master 会进行一些完整性检查，以确保所有 worker 都收集到一样的测试用例集（包括顺序）</li>
<li>如果检查通过，会将测试用例的 ids 列表转换成简单的索引列表，每个索引对应一个测试用例的在原来测试集中的位置</li>
<li>这个方案可行的原因是：所有的节点都保存着相同的测试用例集</li>
<li>并且使用这种方式可以节省带宽，因为 master 只需要告知 workers 需要执行的测试用例对应的索引，而不用告知完整的测试用例信息</li>
</ul>
<h3 id="第四步-测试用例分发"> 第四步：测试用例分发</h3>
<p><code>--dist-mode</code> 选项:</p>
<p>each：master 将完整的测试索引列表分发到每个 worker</p>
<p>load：master 将大约 25% 的测试用例以轮询的方式分发到各个 worker，剩余的测试用例则会等待 workers 执行完测试用例以后再分发</p>
<p><strong>注意</strong>:
可以使用 <code>pytest_xdist_make_scheduler</code> 这个 hook 来实现自定义测试分发逻辑</p>
<h3 id="第五步-测试用例的执行"> 第五步：测试用例的执行</h3>
<ul>
<li>workers 重写了 <code>pytest_runtestloop</code>：Pytest 的默认实现是循环执行所有在 test session 这个对象里面收集到的测试用例</li>
<li>但是在 xdist 里, workers 实际上是等待 master 为其发送需要执行的测试用例</li>
<li>当 worker 收到测试任务, 就顺序执行 <code>pytest_runtest_protocol</code></li>
<li>值得注意的一个细节是：workers 必须始终保持至少一个测试用例在的任务队列里, 以兼容 <code>pytest_runtest_protocol（item, nextitem）hook</code> 的参数要求，为了将 nextitem 传给 hook</li>
<li>worker 会在执行最后一个测试项前等待 master 的更多指令</li>
<li>如果它收到了更多测试项, 那么就可以安全的执行 <code>pytest_runtest_protocol</code>，因为这时 nextitem 参数已经可以确定</li>
<li>如果它收到一个 <code>shutdown</code> 信号, 那么就将 nextitem 参数设为 None, 然后执行 <code>pytest_runtest_protocol</code></li>
</ul>
<h3 id="第六步-测试用例再分发-dist-mode-load"> 第六步：测试用例再分发（--dist-mode=load）</h3>
<ul>
<li>当 workers 开始/结束执行时，会把测试结果返回给 master，这样其他 Pytest hook 比如：<code>pytest_runtest_protocol</code> 就可以正常执行</li>
<li>master 在 worker 执行完一个测试后，基于测试执行时长以及每个 work 剩余测试用例综合决定是否向这个 worker 发送更多的测试用例</li>
</ul>
<h3 id="第七步-测试结束"> 第七步：测试结束</h3>
<ul>
<li>当 master 没有更多执行测试任务时，它会发送一个 “shutdown” 信号给所有 worker</li>
<li>当 worker 将剩余测试用例执行完后退出进程</li>
<li>master 等待所有 worker 全部退出</li>
<li>此时仍需要处理诸如 <code>pytest_runtest_logreport</code> 等事件</li>
</ul>
<h2 id="参考资料"> 参考资料</h2>
<p><a href="https://www.jianshu.com/p/4c3ffa2" target="_blank" rel="noopener noreferrer">pytest-xdist</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-28T07:39:59.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">AttributeError: partially initialized module &amp;apos;selenium.webdriver&amp;apos; has no attribute &amp;apos;Chrome&amp;apos;</title>
    <id>https://www.snowji.cn/test/frameworks/selenium/attribute-error/</id>
    <link href="https://www.snowji.cn/test/frameworks/selenium/attribute-error/"/>
    <updated>2022-08-28T13:19:25.000Z</updated>
    <content type="html"><![CDATA[<h1 id="attributeerror-partially-initialized-module-selenium-webdriver-has-no-attribute-chrome"> AttributeError: partially initialized module 'selenium.webdriver' has no attribute 'Chrome'</h1>
<h2 id="问题描述"> 问题描述</h2>
<p>正常写的 UI 自动化代码：</p>
<div><pre><code>driver <span>=</span> webdriver<span>.</span>Chrome<span>(</span><span>'D:/GreenSoftware/chromedriver.exe'</span><span>)</span>
driver<span>.</span>get<span>(</span><span>"http://www.baidu.com"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>执行后，报错：</p>
<div><pre><code>AttributeError<span>:</span> partially initialized module <span>'selenium.webdriver'</span> has no attribute <span>'Chrome'</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="解决方法"> 解决方法</h2>
<p>将上述代码文件修改了下名字，重新运行时，成功</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-28T13:19:25.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">pytest-repeat</title>
    <id>https://www.snowji.cn/test/frameworks/pytest/pytest-repeat/</id>
    <link href="https://www.snowji.cn/test/frameworks/pytest/pytest-repeat/"/>
    <updated>2022-08-28T07:39:59.000Z</updated>
    <content type="html"><![CDATA[<h1 id="pytest-repeat"> pytest-repeat</h1>
<p>pytest-repeat 是 Pytest 的一个插件，用于重复执行单个用例，或多个测试用例，并指定重复次数</p>
<h2 id="环境要求"> 环境要求</h2>
<ul>
<li>Python 2.7, 3.5+ 或者 PyPy</li>
<li>pytest 3.6 或者更高</li>
</ul>
<h2 id="安装-pytest-repeat"> 安装 pytest-repeat</h2>
<div><pre><code>pip install pytest<span>-</span>repeat
</code></pre>
<div><span>1</span><br></div></div><h2 id="pytest-repeat-使用"> pytest-repeat 使用</h2>
<p>有两种方式：</p>
<ul>
<li>命令行模式</li>
<li>装饰器模式</li>
</ul>
<h3 id="命令行模式"> 命令行模式</h3>
<p>使用 <code>--count</code> 参数指定要重复几次</p>
<div><pre><code>pytest <span>-</span><span>-</span>count<span>=</span><span>10</span> test_file<span>.</span>py
</code></pre>
<div><span>1</span><br></div></div><p>使用上面的命令是每个用例会被重复执行，但有时候希望按 <code>test_1,test_2</code> 这样执行的顺序重复执行
<code>--repeat-scope</code> 就是用来解决这个问题的</p>
<h4 id="repeat-scope"> --repeat-scope</h4>
<p>作用：类似于 fixture 的 scope 参数，可以覆盖默认的测试用例执行顺序</p>
<p><code>--scope</code> 参数：</p>
<ul>
<li>function：默认，范围针对每个用例重复执行，再执行下一个用例</li>
<li>class：以 class 为用例集合单位，重复执行 class 里面的用例，再执行下一个</li>
<li>module：以模块为单位，重复执行模块里面的用例，再执行下一个</li>
<li>session：重复整个测试会话，即所有测试用例的执行一次，然后再执行第二次</li>
</ul>
<h5 id="示例"> 示例</h5>
<h6 id="repeat-scope-module"> --repeat-scope=module</h6>
<div><pre><code><span>def</span> <span>test_repeat1</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"测试用例执行111"</span><span>)</span>

<span>def</span> <span>test_repeat2</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"测试用例执行222"</span><span>)</span>

<span>class</span> <span>Test_repeat</span><span>:</span>
    <span>def</span> <span>test_repeat3</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>"测试用例执行333"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>执行结果：</p>
<div><pre><code>test_repeat.py::test_repeat1[1-2] 测试用例执行111
PASSED
test_repeat.py::test_repeat2[1-2] 测试用例执行222
PASSED
test_repeat.py::Test_repeat::test_repeat3[1-2] 测试用例执行333
PASSED
test_repeat.py::test_repeat1[2-2] 测试用例执行111
PASSED
test_repeat.py::test_repeat2[2-2] 测试用例执行222
PASSED
test_repeat.py::Test_repeat::test_repeat3[2-2] 测试用例执行333
PASSED
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h4 id="重复测试直到失败"> 重复测试直到失败</h4>
<ul>
<li>如果需要验证偶现问题，可以一次又一次地运行相同的测试直到失败，这个插件将很有用</li>
<li>可以将 pytest 的 <code>-x</code> 选项与 <code>pytest-repeat</code> 结合使用，以强制测试运行程序在第一次失败时停止</li>
</ul>
<p>例如：</p>
<div><pre><code><span>def</span> <span>test_example</span><span>(</span><span>)</span><span>:</span>
    <span>import</span> random
    flag <span>=</span> random<span>.</span>choice<span>(</span><span>[</span><span>True</span><span>,</span> <span>False</span><span>]</span><span>)</span>
    <span>print</span><span>(</span>flag<span>)</span>
    <span>assert</span> flag
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>执行命令：<code>pytest -s --count 5 -x test_repeat.py</code></p>
<p>执行结果：</p>
<p><img src="./images/36.png" alt="pytest" /></p>
<h3 id="装饰器模式"> 装饰器模式</h3>
<p>使用 <code>@pytest.mark.repeat(count)</code> 可以将代码中某些测试用例标记为重复执行</p>
<div><pre><code><span>@pytest<span>.</span>mark<span>.</span>repeat</span><span>(</span><span>5</span><span>)</span>
<span>def</span> <span>test_repeat</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"测试用例执行"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>执行命令：<code>pytest -s -v test_repeat.py</code></p>
<p>执行结果：</p>
<div><pre><code>test_repeat.py::test_repeat[1-5] 测试用例执行
PASSED
test_repeat.py::test_repeat[2-5] 测试用例执行
PASSED
test_repeat.py::test_repeat[3-5] 测试用例执行
PASSED
test_repeat.py::test_repeat[4-5] 测试用例执行
PASSED
test_repeat.py::test_repeat[5-5] 测试用例执行
PASSED
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="参考资料"> 参考资料</h2>
<p><a href="https://github.com/pytest-dev/pytest-repeat/" target="_blank" rel="noopener noreferrer">官方文档：pytest-repeat</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-28T07:39:59.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Selenium 框架</title>
    <id>https://www.snowji.cn/test/frameworks/selenium/selenium-theory/</id>
    <link href="https://www.snowji.cn/test/frameworks/selenium/selenium-theory/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="selenium-框架"> Selenium 框架</h1>
<h2 id="selenium-原理"> Selenium 原理</h2>
<h3 id="selenium-1-0-工作原理"> Selenium 1.0 工作原理</h3>
<p><strong>核心</strong>：Selenium RC （Remote Control）,基于JavaScript代码注入</p>
<p><strong>Selenium RC 利用的原理</strong>：JavaScript 代码可以很方便地获取页面上的任何元素并执行各种操作</p>
<p><strong>同源政策</strong>：只有来自<strong>相同域名、端口和协议</strong>的 JavaScript 代码才能被浏览器执行</p>
<p><strong>Selenium RC 组成</strong>：</p>
<p><img src="./images/RC.jpg" alt="RC" /></p>
<p><strong>Selenium RC Server</strong>：</p>
<ul>
<li>Selenium Core：被注入到浏览器页面中的 JavaScript 函数集合，用来实现界面元素的识别和操作</li>
<li>Http Proxy：作为代理服务器修改 JavaScript 的源，以达到“欺骗”被测站点的目的</li>
<li>Launcher：用来在启动测试浏览器时完成 Selenium Core 的注入和浏览器代理的设置</li>
</ul>
<p><strong>Client Libraries</strong>：是测试用例代码向 Selenium RC Server 发送 Http 请求的接口，支持多种语言</p>
<p><strong>Selenium RC的执行流程</strong>：</p>
<p><img src="./images/RC流程.jpg" alt="RC流程" /></p>
<p>具体如下：</p>
<ul>
<li>测试用例通过基于不同语言的 Client Libraries 向 Selenium RC Server 发送 Http 请求，要求与其建立连接</li>
<li>连接建立后，Selenium RC Server 的 Launcher 就会启动浏览器或者重用之前已经打开的浏览器，把Selenium Core（JavaScript 函数的集合）加载到浏览器页面当中，并同时把浏览器的代理设置为 Http Proxy</li>
<li>Selenium Core 接收到指令后，执行操作</li>
<li>如果浏览器收到新的页面请求信息，则会发送Http请求来请求新的 Web 页面。由于 Launcher 在启动浏览器时把 Http Proxy 设置成为了浏览器的代理，所以 Selenium RC Server 会接收到所有由它启动的浏览器发送的请求</li>
<li>Selenium RC Server 接收到浏览器发送的 Http 请求后，重组 Http 请求以规避“同源策略”，然后获取对应的Web 页面</li>
<li>Http Proxy 把接收的 Web 页面返回给浏览器，浏览器对接收的页面进行渲染</li>
</ul>
<h3 id="selenium-2-0-的工作原理"> Selenium 2.0 的工作原理</h3>
<p><strong>核心</strong>：Selenium WebDriver，典型的 Server-Client 模式</p>
<p><strong>原理</strong>：使用浏览器原生的 WebDriver 实现页面操作</p>
<p><strong>Selenium 2.0 工作原理图</strong>：</p>
<p><img src="./images/webdriver.jpg" alt="webdriver" /></p>
<p>具体执行流程如下：</p>
<ul>
<li>Selenium2.0 启动浏览器 Web Browser 时，后台会同时启动基于 WebDriver Wire 协议的 Web Service 作为 Selenium 的 Remote Server，并将其与浏览器绑定，绑定完成后，Remote Server 就开始监听 Client 端的操作请求</li>
<li>执行测试时，测试用例会作为 Client 端，将需要执行的页面操作请求以 Http Request 的方式发送给 Remote Server。该 HTTP Request 的 body，是以 WebDriver Wire 协议规定的 JSON 格式来描述需要浏览器执行的具体操作</li>
<li>Remote Server 接收到请求后，会对请求进行解析，并将解析结果发给 WebDriver，由 WebDriver 实际执行浏览器的操作</li>
<li>WebDriver 可以看做是直接操作浏览器的原生组件（Native Component），所以搭建测试环境时，通常都需要先下载浏览器对应的 WebDriver</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-28T13:19:25.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Selenium 等待方式</title>
    <id>https://www.snowji.cn/test/frameworks/selenium/selenium-wait/</id>
    <link href="https://www.snowji.cn/test/frameworks/selenium/selenium-wait/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="selenium-等待方式"> Selenium 等待方式</h1>
<p><strong>无法定位元素问题原因</strong>：</p>
<ul>
<li>页面中有 frame</li>
<li>元素未加载渲染</li>
</ul>
<p><strong>解决方式</strong>：增加等待时间</p>
<p><strong>等待的作用</strong>：</p>
<ul>
<li>为了提升自动化运行的成功率</li>
<li>在指定的地方，进行等待，以便于系统响应，在继续进行</li>
</ul>
<h2 id="常见等待方式"> 常见等待方式：</h2>
<h3 id="强制等待"> 强制等待</h3>
<p>使用 sleep() 的方式，不论元素是否加载完成，在程序执行到时，必须等待</p>
<div><pre><code><span>from</span> selenium <span>import</span> webdriver
<span>from</span> time <span>import</span> sleep

driver <span>=</span> webdriver<span>.</span>Firefox<span>(</span><span>)</span>
driver<span>.</span>get<span>(</span><span>'https://snowji.github.io'</span><span>)</span>

sleep<span>(</span><span>3</span><span>)</span>  <span># 强制等待3秒再执行下一步</span>

<span>print</span> driver<span>.</span>current_url
driver<span>.</span>quit<span>(</span><span>)</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><strong>优点</strong>：</p>
<ul>
<li>简单入门</li>
<li>可以用于调试</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>只能对单次生效</li>
<li>无法做有效的判断</li>
<li>浪费大量的时间</li>
<li>影响执行速度</li>
</ul>
<h3 id="隐式等待"> 隐式等待</h3>
<p>使用 <code>implicitly_wait(xx)</code></p>
<p><strong>定义</strong>：在规定的时间内网页加载完成，则执行下一步，否则要等待设置的最长时间，才会执行下一步</p>
<p><strong>作用</strong>：对 WebDriver 对象设置全局等待，每一次操作，如遇到页面加载，则默认进入隐式等待</p>
<div><pre><code><span>from</span> selenium <span>import</span> webdriver

driver <span>=</span> webdriver<span>.</span>Firefox<span>(</span><span>)</span>
driver<span>.</span>implicitly_wait<span>(</span><span>30</span><span>)</span>  <span># 隐性等待，最长等30秒</span>
driver<span>.</span>get<span>(</span><span>'https://snowji.github.io'</span><span>)</span>

<span>print</span> driver<span>.</span>current_url
driver<span>.</span>quit<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><strong>优点</strong>：</p>
<ul>
<li>隐性等待对整个 driver 周期都起作用，只需设置一次即可</li>
<li>如未找到元素，则进入隐式等待，当达到等待最大时长，则继续进行后续的代码，不会报错</li>
</ul>
<p><strong>缺点</strong>：一直等待整个页面全部加载完成或等待超时，包括 js 、css 代码，才会执行下一步</p>
<h3 id="显式等待"> 显式等待</h3>
<p><strong>作用</strong>：专门等待指定的元素</p>
<p><strong>使用方法</strong>：<code>WebDriverWait(driver, timeout, poll_frequency, ignored_exceptions).until(要执行的方法, 超时时返回的错误信息)</code></p>
<p><strong>优点</strong>：等待判断准确，不会浪费多余的等待时间，在用例中使用，可以提高执行效率</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>使用相对比较复杂</li>
<li>必须声明，只对单次生效</li>
</ul>
<div><pre><code><span>from</span> selenium <span>import</span> webdriver
<span>from</span> selenium<span>.</span>webdriver<span>.</span>support<span>.</span>wait <span>import</span> WebDriverWait
<span>from</span> selenium<span>.</span>webdriver<span>.</span>support <span>import</span> expected_conditions <span>as</span> EC
<span>from</span> selenium<span>.</span>webdriver<span>.</span>common<span>.</span>by <span>import</span> By

driver <span>=</span> webdriver<span>.</span>Firefox<span>(</span><span>)</span>
driver<span>.</span>implicitly_wait<span>(</span><span>10</span><span>)</span>  <span># 隐性等待和显性等待可以同时用，但要注意：等待的最长时间取两者之中的大者</span>
driver<span>.</span>get<span>(</span><span>'https://snowji.github.io'</span><span>)</span>
locator <span>=</span> <span>(</span>By<span>.</span>LINK_TEXT<span>,</span> <span>'CSDN'</span><span>)</span>

<span>try</span><span>:</span>
    WebDriverWait<span>(</span>driver<span>,</span> <span>20</span><span>,</span> <span>0.5</span><span>)</span><span>.</span>until<span>(</span>EC<span>.</span>presence_of_element_located<span>(</span>locator<span>)</span><span>)</span>
    <span>print</span> driver<span>.</span>find_element_by_link_text<span>(</span><span>'CSDN'</span><span>)</span><span>.</span>get_attribute<span>(</span><span>'href'</span><span>)</span>
<span>finally</span><span>:</span>
    driver<span>.</span>close<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><strong>注意</strong>：</p>
<ul>
<li>在  WebDriverWait..中显性等待起主要作用，其他操作中，隐性等待起决定性作用</li>
<li>同时存在隐性和显性时，等待时间取两者之间的大者</li>
</ul>
<h4 id="webdriverwait-类"> WebDriverWait 类</h4>
<p>引用：</p>
<div><pre><code>selenium<span>.</span>webdriver<span>.</span>support<span>.</span>wait<span>.</span>WebDriverWait
</code></pre>
<div><span>1</span><br></div></div><p>相关参数（从左至右依次）：</p>
<p>driver：webdriver 的实例</p>
<p>timeout：等待超时时间</p>
<p><code>poll_frequency</code>：调用 until 或 <code>until_not</code> 中的方法的间隔时间，默认是 0.5 秒</p>
<p><code>ignored_exceptions</code>：忽略的异常，如果在调用 until 或 <code>until_not</code> 的过程中抛出这个元组中的异常，则不中断代码，继续等待，如果抛出的是这个元组外的异常，则中断代码，抛出异常，默认只有 NoSuchElementException</p>
<p>相关方法：</p>
<ul>
<li>until()</li>
</ul>
<p>直到条件成立返回真，等待结束</p>
<p>超时，抛出 TimeoutExceion 异常，可自定义设置 message 信息</p>
<div><pre><code>WebDriverWait<span>(</span>driver<span>,</span> <span>20</span><span>,</span> <span>0.5</span><span>)</span><span>.</span>until<span>(</span>EC<span>.</span>presence_of_element_located<span>(</span>locator<span>)</span><span>,</span>message<span>=</span><span>'元素未找到'</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>
<p><code>until_not()</code></p>
<p>直到条件不成立返回真，等待结束</p>
<p>超时，抛出 TimeoutExceion 异常</p>
</li>
<li>
<p><code>expected_conditions</code> 异常处理模块</p>
<p><strong>验证元素是否出现</strong>：</p>
<p>传入的参数都是元组类型 locator</p>
<ul>
<li><code>presence_of_element_located</code></li>
<li><code>presence_of_all_elements_located</code></li>
</ul>
<p><strong>验证元素是否可见</strong>：</p>
<ul>
<li><code>visibility_of_element_located</code>：传入元组</li>
<li><code>invisibility_of_element_located</code>：传入元组</li>
<li><code>visibility_of</code>：传入 webelement</li>
</ul>
<p><strong>验证文本是否出现在元素</strong>：</p>
<ul>
<li><code>text_to_be_present_in_element</code>：判断元素的 text</li>
<li><code>text_to_be_present_in_element_value</code>：判断元素的 value</li>
</ul>
<p><strong>验证是否可切入frame</strong>：</p>
<p><code>frame_to_be_available_and_switch_to_it</code> ：可传入元组或直接定位的方式</p>
<p><strong>验证元素是否可点击</strong>：</p>
<p><code>element_to_be_clickable</code> ：传入 locator</p>
<p><strong>验证元素是否被选中</strong>：</p>
<ul>
<li>
<p><code>element_to_be_selected</code>：传入webelement 对象</p>
</li>
<li>
<p><code>element_located_to_be_selected</code>：传入 locator 元组</p>
</li>
<li>
<p><code>element_selection_state_to_be</code>：传入 webelement 对象以及状态，相等返回 true</p>
</li>
<li>
<p><code>element_located_selection_state_to_be</code>：传入 locator 以及状态，相等返回 true</p>
</li>
</ul>
<p><strong>判断元素是否仍在 DOM 中</strong>：</p>
<p><code>staleness_of</code> ：传入 webelement 对象，可以判断是否刷新</p>
<p><strong>常见 WebElement 方法</strong>：</p>
<ul>
<li><code>is_displayed()</code> ：判断元素是否展示出来</li>
<li><code>is_enabled()</code>：判断元素是否可操作</li>
<li><code>is_selected()</code>：判断元素是否被选中</li>
</ul>
</li>
</ul>
<div><p>总结</p>
<p>当多个等待一同被调用时，系统的等待时间取决于最长的等待时间</p>
</div>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-28T13:19:25.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">CSS 选择器</title>
    <id>https://www.snowji.cn/test/frameworks/selenium/select-css/</id>
    <link href="https://www.snowji.cn/test/frameworks/selenium/select-css/"/>
    <updated>2022-08-28T13:19:25.000Z</updated>
    <content type="html"><![CDATA[<h1 id="css-选择器"> CSS 选择器</h1>
<p>在了解本文之前，需要先了解 CSS 基础知识，不懂的小伙伴要自己去补充哦~</p>
<p><strong>CSS 选择器优点</strong>：</p>
<ul>
<li>语法简单</li>
<li>Vue、React 前端框架的盛行，元素很难存在 id 和 name 这种唯一元素</li>
<li>可以定位复杂元素</li>
</ul>
<p><strong>CSS 选择器缺点</strong>: 需要了解前端 CSS 知识</p>
<p><strong>常见的选择器</strong>：</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>名字</th>
<th>例子</th>
<th>例子描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>基础选择器</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>.class</td>
<td>class选择器</td>
<td>.intro</td>
<td>选择 <code>class=&quot;intro&quot;</code> 的所有元素。</td>
</tr>
<tr>
<td>#id</td>
<td>id选择器</td>
<td>#firstname</td>
<td>选择 <code>id=&quot;firstname&quot;</code> 的元素。</td>
</tr>
<tr>
<td>*</td>
<td>通配符</td>
<td></td>
<td>选择所有元素。</td>
</tr>
<tr>
<td>element</td>
<td>标签选择器</td>
<td>p</td>
<td>选择所有 <code>&lt;p&gt;</code> 元素。</td>
</tr>
<tr>
<td>elemnt.class</td>
<td>特定class的标签</td>
<td>input.kw</td>
<td>选择所有 <code>class='kw'</code> 的 <code>&lt;input&gt;</code> 元素</td>
</tr>
<tr>
<td><strong>关系选择器</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>element,element</td>
<td>分组选择器</td>
<td>div,p</td>
<td>同时选择所有 <code>&lt;div&gt;</code> 元素和所有 <code>&lt;p&gt;</code> 元素。</td>
</tr>
<tr>
<td>:not(element)</td>
<td>选取不被选中的元素</td>
<td>:not(div)</td>
<td>选取除<code>&lt;div&gt;</code>之外的所有元素</td>
</tr>
<tr>
<td>element element</td>
<td>后端选择器</td>
<td>div p</td>
<td>选择 <code>&lt;div&gt;</code> 元素内部的所有 <code>&lt;p&gt;</code> 元素**（包括子元素、孙子元素）**</td>
</tr>
<tr>
<td>element&gt;element</td>
<td>子元素选择器</td>
<td>div&gt;p</td>
<td>选择 <code>&lt;div&gt;</code> 元素下的<code>&lt;p&gt;</code> <strong>子元素</strong>。</td>
</tr>
<tr>
<td>element+element</td>
<td>相邻选择器</td>
<td>div+p</td>
<td>选择 <code>&lt;div&gt;</code> 元素<strong>之后的第一个兄弟</strong> <code>&lt;p&gt;</code> 元素。</td>
</tr>
<tr>
<td>element~element</td>
<td>兄弟选择器</td>
<td>div~p</td>
<td>选择 <code>&lt;div&gt;</code>元素<strong>之后的所有兄弟</strong> <code>&lt;p&gt;</code>元素。</td>
</tr>
<tr>
<td><strong>属性选择器</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>E[attr]</td>
<td>选取属性</td>
<td>[target]</td>
<td>选择带有 target 属性所有元素。</td>
</tr>
<tr>
<td>E[attribute=value]</td>
<td>选取属性等于 value 的元素</td>
<td>[target=_blank]</td>
<td>选择 <code>target=&quot;_blank&quot;</code> 的所有元素。</td>
</tr>
<tr>
<td>E[attribute~=value]</td>
<td>选取属性包含多个值，其中一个是 value 的元素</td>
<td>[title~=flower]</td>
<td>选择 title 属性包含单词 &quot;flower&quot; 的所有元素。</td>
</tr>
<tr>
<td>E[attribute|=value]</td>
<td>选取属性等于或第一个值等于 value 的元素</td>
<td>[lang|=en]</td>
<td>选择 lang 属性值为 &quot;en&quot; 或第一个值为 &quot;en&quot;的所有元素。</td>
</tr>
<tr>
<td>E[attribute^=value]</td>
<td>选取属性值以 value 开头的元素</td>
<td>[title^=flower]</td>
<td>选择 title 属性以单词 &quot;flower&quot; 开头的所有元素。</td>
</tr>
<tr>
<td>E[attribute$=value]</td>
<td>选取属性值以 value 结尾的元素</td>
<td>[title$=flower]</td>
<td>选择 title 属性以单词 &quot;flower&quot; 结尾的所有元素。</td>
</tr>
<tr>
<td>E[attribute*=value]</td>
<td>选取属性值包含 value 的元素</td>
<td>[title*=flower]</td>
<td>选择 title 属性包含 &quot;flower&quot; 所有元素。</td>
</tr>
</tbody>
</table>
<p><strong>伪类和伪元素选择器</strong>：</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>例子</th>
<th>例子描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>:first-child</td>
<td>p:first-child</td>
<td>选择属于父元素的第一个子元素的每个 <code>&lt;p&gt;</code> 元素。</td>
</tr>
<tr>
<td>:nth-child(n)</td>
<td>p:nth-child(2)</td>
<td>选择属于其父元素的第二个子元素的每个<code>&lt;p&gt;</code> 元素。</td>
</tr>
<tr>
<td>:nth-last-child(n)</td>
<td>p:nth-last-child(2)</td>
<td>同上，从最后一个子元素开始计数。</td>
</tr>
<tr>
<td>:nth-of-type(n)</td>
<td>p:nth-of-type(2)</td>
<td>选择属于其父元素第二个 <code>&lt;p&gt;</code> 元素的每个<code>&lt;p&gt;</code> 元素。</td>
</tr>
<tr>
<td>:nth-last-of-type(n)</td>
<td>p:nth-last-of-type(2)</td>
<td>同上，但是从最后一个子元素开始计数。</td>
</tr>
<tr>
<td>:last-child</td>
<td>p:last-child</td>
<td>选择属于其父元素最后一个子元素每个 <code>&lt;p&gt;</code>元素。</td>
</tr>
</tbody>
</table>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-28T13:19:25.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">selenium 定位方式</title>
    <id>https://www.snowji.cn/test/frameworks/selenium/selenium-locate-mode/</id>
    <link href="https://www.snowji.cn/test/frameworks/selenium/selenium-locate-mode/"/>
    <updated>2022-08-28T13:19:25.000Z</updated>
    <content type="html"><![CDATA[<h1 id="selenium-定位方式"> selenium 定位方式</h1>
<p>以百度搜索框为例：</p>
<p><img src="./../../theory/auto-test/images/id.jpg" alt="id" /></p>
<p>常见定位方式有以下几种：</p>
<ul>
<li><strong>根据 id 进行定位</strong></li>
</ul>
<div><pre><code><span>from</span> selenium <span>import</span> webdriver
<span>from</span> selenium<span>.</span>webdriver<span>.</span>common<span>.</span>by <span>import</span> By
driver <span>=</span> webdriver<span>.</span>Chrom<span>(</span><span>)</span>
driver<span>.</span>get<span>(</span><span>"https://www.baidu.com"</span><span>)</span>
<span>#通过元素的 id 进行定位元素</span>
driver<span>.</span>find_element<span>(</span>By<span>.</span>ID<span>,</span> <span>'kw'</span><span>)</span><span>.</span>send_keys<span>(</span><span>"test"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>
<li><strong>通过 name 定位</strong></li>
</ul>
<div><pre><code><span>from</span> selenium <span>import</span> webdriver
<span>from</span> selenium<span>.</span>webdriver<span>.</span>common<span>.</span>by <span>import</span> By
driver <span>=</span> webdriver<span>.</span>Chrom<span>(</span><span>)</span>
driver<span>.</span>get<span>(</span><span>"https://www.baidu.com"</span><span>)</span>
<span>#通过元素的 name 进行定位元素</span>
driver<span>.</span>find_element<span>(</span>By<span>.</span>NAME<span>,</span> <span>'wd'</span><span>)</span><span>.</span>send_keys<span>(</span><span>"test"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>
<li><strong>通过 class_name 定位</strong></li>
</ul>
<div><pre><code><span>from</span> selenium <span>import</span> webdriver
<span>from</span> selenium<span>.</span>webdriver<span>.</span>common<span>.</span>by <span>import</span> By
driver <span>=</span> webdriver<span>.</span>Chrom<span>(</span><span>)</span>
driver<span>.</span>get<span>(</span><span>"https://www.baidu.com"</span><span>)</span>
<span>#通过元素的 class_name 进行定位元素</span>
driver<span>.</span>find_element<span>(</span>By<span>.</span>CLASS_NAME<span>,</span> <span>'s_ipt'</span><span>)</span><span>.</span>send_keys<span>(</span><span>"test"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>
<li><strong>通过 tag（标签属性）定位</strong></li>
</ul>
<div><pre><code><span>from</span> selenium <span>import</span> webdriver
<span>from</span> selenium<span>.</span>webdriver<span>.</span>common<span>.</span>by <span>import</span> By
driver <span>=</span> webdriver<span>.</span>Chrom<span>(</span><span>)</span>
driver<span>.</span>get<span>(</span><span>"https://www.baidu.com"</span><span>)</span>
<span>#通过元素的 tag 进行定位元素</span>
driver<span>.</span>find_element<span>(</span>By<span>.</span>TAG_NAME<span>,</span> <span>'input'</span><span>)</span><span>.</span>send_keys<span>(</span><span>"test"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>
<li><strong>通过 link_text（链接文本）定位</strong></li>
</ul>
<div><pre><code><span>from</span> selenium <span>import</span> webdriver
<span>from</span> selenium<span>.</span>webdriver<span>.</span>common<span>.</span>by <span>import</span> By
driver <span>=</span> webdriver<span>.</span>Chrom<span>(</span><span>)</span>
driver<span>.</span>get<span>(</span><span>"https://www.baidu.com"</span><span>)</span>
<span>#通过元素的 link_text 进行定位元素</span>
driver<span>.</span>find_element<span>(</span>By<span>.</span>LINK_TEXT<span>,</span> <span>'百度首页'</span><span>)</span><span>.</span>send_keys<span>(</span><span>"test"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>
<li><strong>通过 partial_link_text（链接文本）定位</strong></li>
</ul>
<p>与上面的 <code>link_text</code> 类似，会模糊匹配 <code>link_ text</code> 中的文字</p>
<div><pre><code><span>from</span> selenium <span>import</span> webdriver
<span>from</span> selenium<span>.</span>webdriver<span>.</span>common<span>.</span>by <span>import</span> By
driver <span>=</span> webdriver<span>.</span>Chrom<span>(</span><span>)</span>
driver<span>.</span>get<span>(</span><span>"https://www.baidu.com"</span><span>)</span>
<span>#通过元素的 partial_link_text 进行定位元素</span>
driver<span>.</span>find_element<span>(</span>By<span>.</span>PARTIAL_LINK_TEXT<span>,</span> <span>'首页'</span><span>)</span><span>.</span>send_keys<span>(</span><span>"test"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>
<li><strong>通过 xpath 定位</strong></li>
</ul>
<p>利用浏览器调试功能，定位到元素所在的那一行右键--&gt;Copy--&gt;Copy XPath</p>
<div><pre><code><span>from</span> selenium <span>import</span> webdriver
<span>from</span> selenium<span>.</span>webdriver<span>.</span>common<span>.</span>by <span>import</span> By
driver <span>=</span> webdriver<span>.</span>Chrom<span>(</span><span>)</span>
driver<span>.</span>get<span>(</span><span>"https://www.baidu.com"</span><span>)</span>
<span>#通过元素的 xpath 进行定位元素</span>
driver<span>.</span>find_element<span>(</span>By<span>.</span>XPATH<span>,</span> <span>"//*[@id="</span>kw<span>"]"</span><span>)</span><span>.</span>send_keys<span>(</span><span>"test"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>对于 xpath 的理解，可以查看相对应的 <a href="/test/frameworks/selenium/xpath%E8%AF%AD%E6%B3%95">xpath语法</a> 和 <a href="/test/frameworks/selenium/selenium%E4%B8%ADxpath%E5%AE%9A%E4%BD%8D%E6%96%B9%E5%BC%8F">selenium中xpath定位方式</a></p>
<ul>
<li><strong>通过  CSS selector 定位</strong></li>
</ul>
<p>想理解 CSS 选择器的定位方式，需要先了解下 CSS 语法</p>
<div><pre><code><span>from</span> selenium <span>import</span> webdriver
driver <span>=</span> webdriver<span>.</span>Chrom<span>(</span><span>)</span>
driver<span>.</span>get<span>(</span><span>"https://www.baidu.com"</span><span>)</span>
<span>#通过元素的 CSS selector 进行定位元素</span>
driver<span>.</span>find_element<span>(</span>By<span>.</span>CSS_SELECTOR<span>,</span> <span>'#kw'</span><span>)</span><span>.</span>send_keys<span>(</span><span>"test"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>CSS 选择器的语法有很多，可以参考 <a href="/test/frameworks/selenium/css-selector">CSS选择定位</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-28T13:19:25.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Selenium 中 xpath定位方式</title>
    <id>https://www.snowji.cn/test/frameworks/selenium/xpath-positioning/</id>
    <link href="https://www.snowji.cn/test/frameworks/selenium/xpath-positioning/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="selenium-中-xpath定位方式"> Selenium 中 xpath定位方式</h1>
<p>了解了 xpath 的一些语法后，可以在 Selenium 中使用 xpath 来定位一些元素</p>
<h2 id="常用的一些定位方式"> 常用的一些定位方式：</h2>
<h3 id="通过元素属性定位"> 通过元素属性定位</h3>
<p><strong>语法</strong>：//tag[@attr=attr]</p>
<p>例子：以定位百度输入框为例：</p>
<p><img src="./images/baidu.jpg" alt="baidu" /></p>
<div><pre><code>xpath 路径：//input[@id=&#39;kw&#39;]
</code></pre>
<div><span>1</span><br></div></div><h3 id="使用逻辑运算符"> 使用逻辑运算符</h3>
<p><strong>语法</strong>：//tag[@attr1=attr1 and @attr2=attr2]</p>
<p>这个是逻辑与 (and)，逻辑或 (or)s 是也同样的</p>
<p><img src="./images/baidu.jpg" alt="baidu" /></p>
<div><pre><code>xpath 路径：//input[@id=&#39;kw&#39; and @class=&#39;s_ipt&#39;]
</code></pre>
<div><span>1</span><br></div></div><h3 id="通过文本定位"> 通过文本定位</h3>
<h4 id="text"> text()</h4>
<p><strong>语法：</strong>//tag[text()=xx]</p>
<p>这里用百度首页里面的 &quot;hao123&quot; 链接举例子</p>
<p><img src="./images/baidu1.jpg" alt="baidu1" /></p>
<div><pre><code> xpath 路径：//a[text()=&#39;hao123&#39;]
</code></pre>
<div><span>1</span><br></div></div><h4 id="contains-包含定位"> contains() 包含定位</h4>
<p><strong>语法</strong>：//tag[contains(text(),xx)] 或者//tag[contains(@attr,xx)]</p>
<p>前面一个是文本，后面一个是包含属性前面都讲了直接 @属性定位</p>
<p><img src="./images/baidu1.jpg" alt="baidu1" /></p>
<div><pre><code> xpath 路径：//a[contains(text(),&#39;hao123&#39;)]
</code></pre>
<div><span>1</span><br></div></div><h3 id="position-n-位置定位"> <code>position()=n</code> 位置定位</h3>
<p><strong>语法：</strong>//tag[@attr=attr][position()=2]</p>
<p>n 表示第几个元素，n 从 1 开始</p>
<p><img src="./images/baidu1.jpg" alt="baidu1" /></p>
<div><pre><code> xpath 路径：//a[@class=&#39;mnav&#39;][position()=2]
</code></pre>
<div><span>1</span><br></div></div><h3 id="last-n"> last()-n</h3>
<p><code>n=0</code> 或者不写 last() 默认倒数第一个，<code>n=1</code> 倒数第二，以此类推</p>
<p><img src="./images/baidu1.jpg" alt="baidu1" /></p>
<div><pre><code>xpath 路径：//div[@id=&#39;s-top-left&#39;]/a[last()-5]
</code></pre>
<div><span>1</span><br></div></div><h3 id="following-sibling-选取当前节点之后的所有同级节点"> following-sibling 选取当前节点之后的所有同级节点</h3>
<p>定位 &quot;hao123&quot; 这个 a 标签的父级元素（div）的同级的第一个 div</p>
<p><img src="./images/baidu1.jpg" alt="baidu1" /></p>
<div><pre><code>xpath 路径：//div[@id=&#39;s-top-left&#39;]/following-sibling::div[1]
</code></pre>
<div><span>1</span><br></div></div><h3 id="preceding-sibling-选取当前节点之前的所有同级节点"> preceding-sibling 选取当前节点之前的所有同级节点</h3>
<p>7 和 6 相反的，6 是同级往下走，7 是同级往上走的</p>
<p>定位 &quot;hao123&quot; 这个 a 标签的父级元素（div）的同级的第一个 div</p>
<p><img src="./images/baidu1.jpg" alt="baidu1" /></p>
<div><pre><code>xpath 路径：//div[@id=&#39;s-top-left&#39;]/preceding-sibling::div[1]
</code></pre>
<div><span>1</span><br></div></div><p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-28T13:19:25.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">XPath</title>
    <id>https://www.snowji.cn/test/frameworks/selenium/xpath-syntax/</id>
    <link href="https://www.snowji.cn/test/frameworks/selenium/xpath-syntax/"/>
    <updated>2022-08-28T13:19:25.000Z</updated>
    <content type="html"><![CDATA[<h1 id="xpath"> XPath</h1>
<p><strong>简介</strong>：XPath 是 XML 的路径语言，简单点说就是通过元素的路径来查找这个标签元素</p>
<h3 id="相关语法"> 相关语法</h3>
<ul>
<li><strong>获取节点</strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">表达式</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">nodename</td>
<td style="text-align:left">选取此节点的所有子节点</td>
</tr>
<tr>
<td style="text-align:left">/</td>
<td style="text-align:left">从根节点选取（取子节点）</td>
</tr>
<tr>
<td style="text-align:left">//</td>
<td style="text-align:left">从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置（取子孙节点）</td>
</tr>
<tr>
<td style="text-align:left">.</td>
<td style="text-align:left">选取当前节点</td>
</tr>
<tr>
<td style="text-align:left">..</td>
<td style="text-align:left">选取当前节点的父节点</td>
</tr>
<tr>
<td style="text-align:left">@</td>
<td style="text-align:left">选取属性</td>
</tr>
</tbody>
</table>
<p>例如：</p>
<table>
<thead>
<tr>
<th style="text-align:left">路径表达式</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">bookstore</td>
<td style="text-align:left">选取 bookstore 元素的所有子节点</td>
</tr>
<tr>
<td style="text-align:left">/bookstore</td>
<td style="text-align:left">选取根元素 bookstore。注释：假如路径起始于正斜杠（ / ），则此路径始终代表到某元素的绝对路径</td>
</tr>
<tr>
<td style="text-align:left">bookstore/book</td>
<td style="text-align:left">选取属于 bookstore 的子元素的所有 book 元素</td>
</tr>
<tr>
<td style="text-align:left">//book</td>
<td style="text-align:left">选取所有 book 子元素，而不管它们在文档中的位置</td>
</tr>
<tr>
<td style="text-align:left">bookstore//book</td>
<td style="text-align:left">选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置</td>
</tr>
<tr>
<td style="text-align:left">//@lang</td>
<td style="text-align:left">选取名为 lang 的所有属性</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>谓语</strong></li>
</ul>
<p><strong>特点</strong>：</p>
<ul>
<li>用来查找某个特定的节点或者包含某个指定的值的节点</li>
<li>谓语被嵌在方括号中</li>
</ul>
<p><strong>常见谓语表达式：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">路径表达式</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">/bookstore/book[1]</td>
<td style="text-align:left">选取属于 bookstore 子元素的第一个 book 元素</td>
</tr>
<tr>
<td style="text-align:left">/bookstore/book[last()]</td>
<td style="text-align:left">选取属于 bookstore 子元素的最后一个 book 元素</td>
</tr>
<tr>
<td style="text-align:left">/bookstore/book[last()-1]</td>
<td style="text-align:left">选取属于 bookstore 子元素的倒数第二个 book 元素</td>
</tr>
<tr>
<td style="text-align:left">/bookstore/book[position()❤️]</td>
<td style="text-align:left">选取最前面的两个属于 bookstore 元素的子元素的 book 元素</td>
</tr>
<tr>
<td style="text-align:left">//title[@lang]</td>
<td style="text-align:left">选取所有拥有名为 lang 的属性的 title 元素</td>
</tr>
<tr>
<td style="text-align:left">//title[@lang='eng']</td>
<td style="text-align:left">选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性</td>
</tr>
<tr>
<td style="text-align:left">/bookstore/book[price&gt;35.00]</td>
<td style="text-align:left">选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00</td>
</tr>
<tr>
<td style="text-align:left">/bookstore/book[price&gt;35.00]//title</td>
<td style="text-align:left">选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>选取未知节点</strong></li>
</ul>
<p>通过使用通配符来选取未知的元素</p>
<p>常用的通配符：</p>
<table>
<thead>
<tr>
<th style="text-align:left">通配符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">匹配任何元素节点</td>
</tr>
<tr>
<td style="text-align:left">@*</td>
<td style="text-align:left">匹配任何属性节点</td>
</tr>
<tr>
<td style="text-align:left">node()</td>
<td style="text-align:left">匹配任何类型的节点</td>
</tr>
</tbody>
</table>
<p>例如：</p>
<table>
<thead>
<tr>
<th style="text-align:left">路径表达式</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">/bookstore/*</td>
<td style="text-align:left">选取 bookstore 元素的所有子元素</td>
</tr>
<tr>
<td style="text-align:left">//*</td>
<td style="text-align:left">选取文档中的所有元素</td>
</tr>
<tr>
<td style="text-align:left">//title[@*]</td>
<td style="text-align:left">选取所有带有属性的 title 元素</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>选取若干路径</strong></li>
</ul>
<p>在路径表达式中使用 &quot;|&quot; 运算符，选取若干个路径</p>
<p>常用的表达式：</p>
<table>
<thead>
<tr>
<th style="text-align:left">路径表达式</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">//book/title \</td>
<td style="text-align:left">//book/price</td>
</tr>
<tr>
<td style="text-align:left">//title \</td>
<td style="text-align:left">//price</td>
</tr>
<tr>
<td style="text-align:left">/bookstore/book/title \</td>
<td style="text-align:left">//price</td>
</tr>
</tbody>
</table>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-28T13:19:25.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">面试相关</title>
    <id>https://www.snowji.cn/test/interview/</id>
    <link href="https://www.snowji.cn/test/interview/"/>
    <updated>2022-08-31T13:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="面试相关"> 面试相关</h1>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-31T13:13:11.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Redis</title>
    <id>https://www.snowji.cn/test/interview/database/redis/</id>
    <link href="https://www.snowji.cn/test/interview/database/redis/"/>
    <updated>2022-08-31T13:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="redis"> Redis</h1>
<ol>
<li>Resdis 可以替代 MySql 做数据存储么？</li>
</ol>
<ul>
<li>Redis 是存在内存中的，内存的大小有限</li>
<li>由于存在内存中，宕机后数据会丢失</li>
<li>Redis 也是可以持久化的，但 Redis 的持久化是为了数据备份，而不是存储数据</li>
<li>Redis 与 MySql 之间应该是相辅相成，配合使用</li>
</ul>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-31T13:13:11.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">面试技巧</title>
    <id>https://www.snowji.cn/test/interview/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <link href="https://www.snowji.cn/test/interview/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <updated>2022-08-31T13:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="面试技巧"> 面试技巧</h1>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-31T13:13:11.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">面试技巧</title>
    <id>https://www.snowji.cn/test/interview/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <link href="https://www.snowji.cn/test/interview/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <updated>2022-08-31T13:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="面试技巧"> 面试技巧</h1>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-31T13:13:11.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">测试基础篇</title>
    <id>https://www.snowji.cn/test/interview/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%982/</id>
    <link href="https://www.snowji.cn/test/interview/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%982/"/>
    <updated>2022-08-31T13:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="测试基础篇"> 测试基础篇</h1>
<h1 id="如何制定测试计划"> 如何制定测试计划</h1>
<p><strong>包含：</strong></p>
<ul>
<li>测试目标</li>
<li>测试范围</li>
<li>测试环境</li>
<li>测试类型</li>
<li>测试工具</li>
<li>模块划分：根据测试人员对于业务的熟悉及个人能力进行分配</li>
<li>测试负责人</li>
<li>测试执行轮次时间安排</li>
<li>相关文档在文档管理库中的位置</li>
<li>测试的风险</li>
</ul>
<h2 id="功能测试用例一般包含哪些内容"> 功能测试用例一般包含哪些内容</h2>
<p>要素：</p>
<ul>
<li>用例编号</li>
<li>用例优先级：核心要素</li>
<li>测试目的：核心要素</li>
<li>所属模块</li>
<li>前提条件</li>
<li>测试环境</li>
<li>输入数据</li>
<li>测试步骤</li>
<li>预期结果：核心要素</li>
<li>测试脚本等</li>
</ul>
<h2 id="黑盒测试用例设计方法"> 黑盒测试用例设计方法</h2>
<p>常用的方法：</p>
<ul>
<li>等价类划分</li>
<li>边界值</li>
<li>错误推测</li>
<li>因果图</li>
<li>判定表</li>
<li>正交分解</li>
<li>全局探索式</li>
<li>场景分析</li>
</ul>
<h2 id="什么是回归测试-如何做回归测试"> 什么是回归测试？如何做回归测试</h2>
<p><strong>回归测试</strong>：</p>
<p>在软件生命周期，只要软件发生了改变，就可能给该软件产生问题，每当软件发生改变时我们就必须重新测试现有的功能，以确定是否达到了预期的目的，检查修改是否破坏原有的正常功能</p>
<p><strong>如何做</strong>：</p>
<ul>
<li>在测试策略制定阶段，制定回归测试策略</li>
<li>确定需要回归测试的版本</li>
<li>回归测试版本发布，按照回归测试策略执行回归测试</li>
<li>回归测试通过，关闭缺陷跟踪单</li>
<li>回归测试不通过，缺陷跟踪单返回开发人员，开发重新修改再次提交测试回归</li>
</ul>
<h2 id="在项目中如何保证软件质量"> 在项目中如何保证软件质量</h2>
<p>项目质量不是仅仅靠某个人来保障，而是整个团队整体一起努力的结果：
产品：保证迭代过程中的产品逻辑，对于可能的兼容，升级做出预判，并给出方案
设计：满足产品表达的同时，保证设计的延续性
开发：产品细节的保证，技术方案选择要严谨，考虑兼容、性能，开发完成后要充分自测，严格遵循开发  规范操作
测试：验证产品逻辑，站在用户角度对交互设计进行系统验证，尽可能多的使用技术手段保证测试质量</p>
<h2 id="遇到概率性-bug-怎么办"> 遇到概率性 bug 怎么办</h2>
<ul>
<li>首先明确该类 bug 也需要提单，描述清楚一些操作环境、步骤、数据，并备注可能产生的原因</li>
<li>使用排除法、错误推断法查找规律，可以找开发、项目经理一起定位分析讨论</li>
<li>如最后未解决，需要在测试报告中体现，并分析可能造成的影响，权衡该 bug 是否可留</li>
</ul>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-31T13:13:11.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">性能面试题2</title>
    <id>https://www.snowji.cn/test/interview/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%80%A7%E8%83%BD%E9%9D%A2%E8%AF%95%E9%A2%982/</id>
    <link href="https://www.snowji.cn/test/interview/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%80%A7%E8%83%BD%E9%9D%A2%E8%AF%95%E9%A2%982/"/>
    <updated>2022-08-31T13:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="性能面试题2"> 性能面试题2</h1>
<p><em><strong>1.</strong></em> <strong>你知道哪些性能测试指标？TPS、QPS、RT代表意义？</strong></p>
<p><em><strong>2.</strong></em> <strong>说说你是如何根据Jmeter测试报告去分析系统性能瓶颈的？</strong></p>
<p><em><strong>3.</strong></em> <strong>Jmeter里面有个测试片段，可以说一下它的应用场景嘛？</strong></p>
<p><em><strong>4.</strong></em> <strong>我能不能在Jmeter中引用数据库的值对接口响应进行判断？</strong></p>
<p><em><strong>5.</strong></em> <strong>如果我有100个接口需要用Jmeter测试，有什么需要特别注意的嘛？</strong></p>
<p><em><strong>6.</strong></em> <strong>你一般是怎么配置Jmeter中的线程组，具体依据是什么？</strong></p>
<p><em><strong>7.</strong></em> <strong>能不能让Jmeter用200组不同的数据进行压力测试？</strong></p>
<p><em><strong>8.</strong></em> <strong>你知道DDT是什么意思嘛？它可以运用在Jmeter里面嘛？</strong></p>
<p><em><strong>9.</strong></em> <strong>Jmeter里面的response断言和json断言有什么区别？</strong></p>
<p><em><strong>10.</strong></em> <strong>你是怎么处理多个接口之间上下文依赖这个问题的？</strong></p>
<p><em><strong>11.</strong></em> <strong>你知道什么是尖峰(Spike)测试嘛？如何在Jmeter中实现它？</strong></p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-31T13:13:11.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">面试技巧</title>
    <id>https://www.snowji.cn/test/interview/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <link href="https://www.snowji.cn/test/interview/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <updated>2022-08-31T13:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="面试技巧"> 面试技巧</h1>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-31T13:13:11.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">移动面试题</title>
    <id>https://www.snowji.cn/test/interview/%E7%A7%BB%E5%8A%A8%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <link href="https://www.snowji.cn/test/interview/%E7%A7%BB%E5%8A%A8%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <updated>2022-08-31T13:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="移动面试题"> 移动面试题</h1>
<ol>
<li>
<p>Redis的操作方法</p>
</li>
<li>
<p>元祖和列表的区别，如何修改元祖</p>
<ol>
<li>书写上：列表是[],元祖是()</li>
<li></li>
</ol>
</li>
<li>
<p><code>__init__</code>和<code>__new__</code>的区别</p>
</li>
<li>
<p>查看端口占用情况的Linux命令</p>
<p>netstat命令：netstat -tunlp |grep 80</p>
<p>lsof命令：lsof -i:80</p>
</li>
<li>
<p>Nginx配置负载</p>
</li>
<li>
<p>Nginx配置域名反向代理</p>
</li>
<li>
<p>http属于七层协议的哪层</p>
<p>应用层</p>
</li>
<li>
<p>tcp协议三次握手四次挥手</p>
</li>
<li>
<p>网络协议</p>
</li>
<li>
<p>yum是干什么的</p>
<p>安装Linux中的软件</p>
</li>
<li>
<p>MySQL中的like和__分别是什么</p>
</li>
<li>
<p>MySQL复制表结构的命令</p>
</li>
<li>
<p>jmeter如何确定提取器是否获取到值</p>
</li>
<li>
<p>jmeter参数化作计时器</p>
</li>
<li>
<p>输入网址回车后发生了什么</p>
</li>
<li>
<p>404如何分析问题</p>
<ol>
<li>网址是否正确</li>
<li>页面是否存在</li>
<li>Nginx是否配置页面转发</li>
</ol>
</li>
<li>
<p>查看cpu、磁盘、内存命令</p>
</li>
<li>
<p>Linux如何抓包</p>
<p>tcpdump</p>
</li>
<li>
<p>ping 192.0.0.18 不通分析问题</p>
<ol>
<li>查看机器是否开机</li>
<li>查看机器是否已插网线</li>
<li>查看是否在同一网段</li>
<li>不同网段路由是否已配置</li>
<li>主机上的网关是否配置</li>
</ol>
</li>
<li>
<p>Python 字典和集合的区别</p>
<p>字典：无序的</p>
<p>集合：有序的</p>
</li>
</ol>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-31T13:13:11.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">面试技巧</title>
    <id>https://www.snowji.cn/test/interview/%E7%BC%96%E7%A8%8B%E9%A2%98/</id>
    <link href="https://www.snowji.cn/test/interview/%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    <updated>2022-08-31T13:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="面试技巧"> 面试技巧</h1>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-31T13:13:11.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">自动化面试题1</title>
    <id>https://www.snowji.cn/test/interview/%E8%87%AA%E5%8A%A8%E5%8C%96%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%87%AA%E5%8A%A8%E5%8C%96%E9%9D%A2%E8%AF%951/</id>
    <link href="https://www.snowji.cn/test/interview/%E8%87%AA%E5%8A%A8%E5%8C%96%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%87%AA%E5%8A%A8%E5%8C%96%E9%9D%A2%E8%AF%951/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="自动化面试题1"> 自动化面试题1</h1>
<h2 id="_1-你会封装自动化测试框架吗"> 1. 你会封装自动化测试框架吗？</h2>
<p>自动化框架主要的核心框架就是分层+PO 模式：</p>
<ul>
<li>基础封装层 BasePage</li>
<li>PO 页面对象层</li>
<li>TestCase 测试用例层</li>
<li>日志处理模块</li>
<li>ini 配置文件读取模块</li>
<li>unittest+ddt 数据驱动模块</li>
<li>jenkins 持续集成模式组成</li>
</ul>
<h2 id="_2-如何把自动化测试在公司中实施并推广起来的"> 2. 如何把自动化测试在公司中实施并推广起来的</h2>
<p>主要有以下几步：</p>
<ul>
<li>
<p>项目组调研选择自动化工具并开会演示 demo 案例，我们主要是演示 selenium 和 robotframework 两种</p>
</li>
<li>
<p>搭建自动化测试框架，在项目中逐步开展自动化</p>
</li>
<li>
<p>把该项目的自动化流程、框架固化成文档</p>
</li>
<li>
<p>推广到公司的其它项目组应用</p>
</li>
</ul>
<h2 id="_3-请描述一下自动化测试流程"> 3. 请描述一下自动化测试流程</h2>
<p>一般流程如下：</p>
<ul>
<li>
<p>编写自动化测试计划</p>
</li>
<li>
<p>设计自动化测试用例</p>
</li>
<li>
<p>编写自动化测试框架和脚本</p>
</li>
<li>
<p>调试并维护脚本</p>
</li>
<li>
<p>无人值守测试</p>
</li>
<li>
<p>后期脚本维护（添加用例、开发更新版本）</p>
</li>
</ul>
<h2 id="_4-自动化测试用例如何编写"> 4. 自动化测试用例如何编写？</h2>
<p>以下答案可任选：</p>
<ul>
<li>
<p>用例是自动化测试工程师自己设计的，一般刚开始以基本业务流程为主（登录--完成一个业务--退出）</p>
</li>
<li>
<p>从系统测试用例中进行筛选或由业务工程师提供</p>
</li>
</ul>
<h2 id="_5-上一个项目中自动化测试的执行策略"> 5. 上一个项目中自动化测试的执行策略</h2>
<p>常见的策略：</p>
<ul>
<li>设置定时任务定时执行，执行完毕后发送测试结果邮件</li>
<li>手动执行，一般不常用</li>
</ul>
<h2 id="_6-自动化测试发现-bug-多吗"> 6. 自动化测试发现 Bug 多吗</h2>
<p>不多，因为之前项目组是把已经测试通过的基本功能再进行自动化脚本编写和在后续版本执行自动化测试，它主要是保证已经测试通过的功能在新版本更新后没有问题</p>
<h2 id="_7-你觉得自动化测试的价值在哪里-你们公司为什么要做自动化测试"> 7. 你觉得自动化测试的价值在哪里？你们公司为什么要做自动化测试？</h2>
<p>能代替大量繁琐的回归测试工作，把业务测试人员解放出来，既而让业务测试人员把精力集中在复杂的业务功能模块上，自动化测试一般是对稳定下来的功能进行自动化，保证不会因为产品的更新导致之前稳定下来的功能出现 Bug</p>
<h2 id="_8-自动化测试有误报过-bug-吗-产生误报怎么办"> 8. 自动化测试有误报过 Bug 吗？产生误报怎么办？</h2>
<p>有误报过，有时候自动化测试报告中显示发现了 Bug，实际去通过手工测试去确认又不存在该 Bug</p>
<p>误报原因一般是：</p>
<ul>
<li>
<p>元素定位不稳定，需要尽量提高脚本的稳定性</p>
</li>
<li>
<p>开发更新了页面但是测试没有及时更新维护</p>
</li>
</ul>
<h2 id="_9-自动化测试过程中-你遇到了哪些问题-是如何解决的"> 9. 自动化测试过程中，你遇到了哪些问题，是如何解决的？</h2>
<p>遇到过以下的问题：</p>
<ul>
<li>
<p>频繁地变更页面，经常要修改页面对象类里面的代码</p>
</li>
<li>
<p>自动化测试偶尔出现过误报</p>
</li>
<li>
<p>自动化测试结果出现覆盖的情况：Jenkins 根据时间建立文件夹</p>
</li>
<li>
<p>自动化测试代码维护比较麻烦</p>
</li>
<li>
<p>自动化测试进行数据库对比数据</p>
</li>
</ul>
<h2 id="_10-在上一家公司做自动化测试用的什么框架"> 10. 在上一家公司做自动化测试用的什么框架？</h2>
<p>可以说出以下自己擅长的一种：</p>
<ul>
<li>
<p>python+selenium+unittest+htmltestrunner</p>
</li>
<li>
<p>python+selenium+pytest+allure</p>
</li>
<li>
<p>robotframework+Selenium2Library</p>
</li>
</ul>
<h2 id="_12-在-selenium-自动化测试中-你一般完成什么类型的测试-自动化覆盖率"> 12. 在 selenium 自动化测试中，你一般完成什么类型的测试？自动化覆盖率？</h2>
<p>主要是冒烟测试和回归测试</p>
<p>回归测试：主要写一些功能稳定的场景，通过自动化手段去实现，节约测试时间</p>
<p>因为自动化测试用例也是在不断的更新和迭代，没有刻意去统计，大概在 30%-40% 左右</p>
<h2 id="_13-在执行脚本过程-如何实现当前元素高亮显示"> 13. 在执行脚本过程，如何实现当前元素高亮显示？</h2>
<p>可以利用 javaScript 去修改当前元素的边框样式来到达高亮显示的效果</p>
<h2 id="_14-如果一个元素无法定位-你一般会考虑哪些方面的原因"> 14. 如果一个元素无法定位，你一般会考虑哪些方面的原因？</h2>
<p>可能存在的原因：</p>
<ul>
<li>
<p>页面加载元素过慢，加等待时间</p>
</li>
<li>
<p>页面有 frame 框架页，需要先跳转入frame 框架再定位</p>
</li>
<li>
<p>可能该元素是动态元素，定位方式要优化，可以使用部分元素定位或通过父节点或兄弟节点定位</p>
</li>
<li>
<p>可能识别了元素，但是不能操作，比如元素不可用，不可写等。需要使用 js 先把前置的操作完成</p>
</li>
</ul>
<h2 id="_15-元素定位方法你熟悉的有哪些"> 15. 元素定位方法你熟悉的有哪些？</h2>
<p>常见的定位方式：</p>
<ul>
<li>id</li>
<li>name</li>
<li>classname</li>
<li>link_text</li>
<li>css</li>
<li>xpath</li>
</ul>
<h2 id="_16-遇到-frame-框架页面怎么处理"> 16. 遇到 frame 框架页面怎么处理？</h2>
<p>一般有 3 步：</p>
<ul>
<li>
<p>先用 driver.switch_to.frame() 跳转进去 frame</p>
</li>
<li>
<p>然后再操作页面元素，</p>
</li>
<li>
<p>操作完后使用 driver.swith_to.default_content() 跳转出来</p>
</li>
</ul>
<h2 id="_17-遇到-alert-弹出窗如何处理"> 17. 遇到 alert 弹出窗如何处理？</h2>
<p>一般有 2 步：</p>
<ul>
<li>
<p>使用 driver.switch_to.alert 方法先跳转到 alert 弹出窗口</p>
</li>
<li>
<p>然后再通过 accept 点击确定按钮，通过 dismiss 点击取消难，通过 text() 获得弹出窗口的文本</p>
</li>
</ul>
<h2 id="_18-如何处理多窗口"> 18. 如何处理多窗口</h2>
<p>当你点击一个链接，这个链接会在一个新的 tab 打开，在新 tab 打开的页面查找元素：</p>
<ul>
<li>
<p>我们在点击链接前使用 driver.current_window_handle 获得当前窗口句柄</p>
</li>
<li>
<p>再点击链接。点击后通过 driver.window_handles 获得所有窗口的句柄</p>
</li>
<li>
<p>然后再循环找到新窗口的句柄，然后再通过 driver.switch_to.window() 方法跳转到新的窗口</p>
</li>
</ul>
<h2 id="_19-怎么验证元素是-enable-disabled-checked-状态"> 19. 怎么验证元素是 enable/disabled/checked 状态？</h2>
<p>定位元素后通过 isEnabled()、isSelected()、isDisplayed() 三个方法进行判断。</p>
<h2 id="_20-如何处理下拉菜单"> 20.  如何处理下拉菜单？</h2>
<p>在 Selenium 中有一个叫 Select 的类，这个类支持对下拉菜单进行操作</p>
<p>方法如下：</p>
<ul>
<li>
<p>定位元素</p>
</li>
<li>
<p>把定位的元素转化成Select对象</p>
<p>sel = Select(定位的元素对象)</p>
</li>
<li>
<p>通过下标或者值或者文本选中下拉框
sel.select_by_index(index)
sel.select_by_value(value)
sel.select_by_visible_text(text)</p>
</li>
</ul>
<h2 id="_21-在日历这种-web-表单你是如何处理的"> 21. 在日历这种 web 表单你是如何处理的?</h2>
<p>可以有以下方式：</p>
<ul>
<li>
<p>首先要分析当前网页试用日历插件的前端代码，是否能通过元素定位，点击日期实现</p>
</li>
<li>
<p>可能需要借助 javascript</p>
</li>
<li>
<p>有些日历控件一个文本输入框，可以直接 sendKeys() 方法来实现传入一个时间的数据</p>
</li>
</ul>
<h2 id="_22-举例一下说明一下你遇到过那些异常"> 22. 举例一下说明一下你遇到过那些异常</h2>
<p>常见的 selenium 异常有这些：</p>
<ul>
<li>NoSuchElementException：没有该元素异常</li>
<li>TimeoutException ：超时异常</li>
<li>ElementNotVisibleException ：元素不可见异常</li>
<li>NoSuchAttributeException ：没有这样属性异常</li>
<li>NoSuchFrameException ：没有该 frame 异常</li>
</ul>
<h2 id="_23-关闭浏览器中-quit-和-close-的区别"> 23. 关闭浏览器中 quit 和 close 的区别</h2>
<p>简单来说，两个都可以实现退出浏览器 session 功能：</p>
<p>close：是关闭你当前聚焦的 tab 页面</p>
<p>quit：是关闭全部浏览器 tab 页面，并退出浏览器 session</p>
<p>quit 一般用在结束测试之前的操作，close 用在执行用例过程中关闭某一个页面的操作</p>
<h2 id="_24-在-selenium-中如何实现截图-如何实现用例执行失败才截图"> 24. 在 Selenium 中如何实现截图，如何实现用例执行失败才截图</h2>
<p>在 Selenium 中提供了一个 get_screenshot_as_file() 的方法来截图的，一般结合 try/except 捕获异常时使用，进行错误截图</p>
<h2 id="_25-如何实现文件上传"> 25. 如何实现文件上传？</h2>
<p>定位元素后，直接使用 send_keys() 方法设置就行，参数为需要上传的文件的路径。</p>
<h2 id="_26-自动化中有哪三类等待-他们有什么特点"> 26. 自动化中有哪三类等待？他们有什么特点？</h2>
<p>有以下 3 种等待方式：</p>
<ul>
<li>
<p>线程等待（强制等待）</p>
<p>如 time.sleep(2) ：线程强制休眠 2 秒钟，2 秒过后，再执行后续的代码。建议少用。</p>
</li>
<li>
<p>imlicitlyWait（隐式等待）</p>
<p>会在指定的时间范围内不断的查找元素，直到找到元素或超时，特点是必须等待整个页面加载完成</p>
</li>
<li>
<p>WebDriverWait（显式等待）</p>
<p>通常是我们自定义的一个函数代码，这段代码用来等待某个元素加载完成，再继续执行后续的代码</p>
</li>
</ul>
<h2 id="_27-你写的测试脚本能在不同浏览器上运行吗"> 27. 你写的测试脚本能在不同浏览器上运行吗</h2>
<p>当然可以，实现的思路：</p>
<p>封装一个方法，分别传入一个浏览器的字符串，如果传入 IE 就使用 IE，如果传入 FireFox 就使用 FireFox，如果传入 Chrome 就使用 Chrome 浏览器，并且使用什么浏览器可以在总的 ini 配置文件中进行配置。需要注意的是每个浏览器使用的驱动不一样</p>
<h2 id="_28-什么是-po-模式-为什么要使用它"> 28. 什么是 PO 模式，为什么要使用它</h2>
<p>PO 是 Page Object 模式的简称，它是一种设计思想，意思是，把一个页面，当做一个对象，页面的元素和元素之间操作方法就是页面对象的属性和行为，PO 模式一般使用三层架构，分别为：基础封装层 BasePage，PO 页面对象层，TestCase 测试用例层。</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-31T13:13:11.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">面试技巧</title>
    <id>https://www.snowji.cn/test/interview/%E8%87%AA%E5%8A%A8%E5%8C%96%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <link href="https://www.snowji.cn/test/interview/%E8%87%AA%E5%8A%A8%E5%8C%96%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <updated>2022-08-31T13:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="面试技巧"> 面试技巧</h1>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-31T13:13:11.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">面试技巧</title>
    <id>https://www.snowji.cn/test/interview/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/</id>
    <link href="https://www.snowji.cn/test/interview/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
    <updated>2022-08-31T13:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="面试技巧"> 面试技巧</h1>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-31T13:13:11.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">简历编写和面试技巧</title>
    <id>https://www.snowji.cn/test/interview/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/%E7%AE%80%E5%8E%86%E7%BC%96%E5%86%99%E5%92%8C%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/</id>
    <link href="https://www.snowji.cn/test/interview/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/%E7%AE%80%E5%8E%86%E7%BC%96%E5%86%99%E5%92%8C%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
    <updated>2022-08-31T13:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="简历编写和面试技巧"> 简历编写和面试技巧</h1>
<h2 id="简历编写"> 简历编写</h2>
<p>一份好的简历，可以获得更多的面试邀请</p>
<p><strong>组成：</strong></p>
<ul>
<li>
<p>个人基本信息</p>
<ul>
<li>学历</li>
<li>性别</li>
<li>年龄</li>
</ul>
</li>
<li>
<p>技术说明</p>
<p>大多数简历中的技术说明，一般都是：</p>
<ul>
<li>熟悉测试流程</li>
<li>熟练掌握 LR</li>
<li>熟练使用 Postman、Jmeter</li>
<li>掌握 Python、Java等等</li>
</ul>
<p>这种说明给人的感觉是 get 不到你技术的点，不知道技术能力是什么程度，可以改写，比如：</p>
<p>以熟练掌握 LR 为例改写：</p>
<p>掌握 Load Runner 性能测试工具的应用，熟练使用 LR 进行脚本的录制、编写及增强脚本，基于 LR 实现对性能场景的设计与运行，并在运行过程中监听服务端资源，基于 LR 性能结果对系统进行性能分享，提出性能优化建议，能够应用 LR 实现梯度模型设计、性能瓶颈的测试。。。。</p>
</li>
<li>
<p>项目说明</p>
<p>项目选择最多不超过３个，规模最大的</p>
<p>项目介绍：</p>
<ul>
<li>项目介绍：介绍项目背景、应用客户群体</li>
<li>个人职责：个人在项目中担任的职责，以及自己参与的活动</li>
</ul>
</li>
</ul>
<h2 id="面试准备"> 面试准备</h2>
<p><strong>面试邀请获得之后：</strong></p>
<ul>
<li>查看公司基本信息</li>
<li>去面试前，整理自己</li>
</ul>
<p><strong>面试过程：</strong></p>
<ul>
<li>
<p>自我介绍</p>
<p>时间约为 2 分钟以内，简明扼要介绍自己的重点信息</p>
<p>包括：名字、年龄、学历、个人技能</p>
</li>
<li>
<p>项目交流</p>
</li>
<li>
<p>技术交流</p>
<ul>
<li>体现出重点技术的掌握</li>
<li>体现个人积极向上的状态</li>
<li>体现出自我学习能力</li>
</ul>
</li>
<li>
<p>薪资待遇</p>
<ul>
<li>薪资直接了当</li>
</ul>
</li>
<li>
<p>有什么需要你了解的</p>
<ul>
<li>产品相关</li>
<li>技术团队相关</li>
<li>福利相关</li>
</ul>
</li>
<li>
<p>上家公司的离职原因</p>
<ul>
<li>不吐槽</li>
<li>实话实说</li>
</ul>
</li>
<li>
<p>面试失败后，可以询问下原因，后面可以避免</p>
</li>
</ul>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-31T13:13:11.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">技能相关</title>
    <id>https://www.snowji.cn/test/interview/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/%E6%8A%80%E8%83%BD%E7%9B%B8%E5%85%B3/</id>
    <link href="https://www.snowji.cn/test/interview/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/%E6%8A%80%E8%83%BD%E7%9B%B8%E5%85%B3/"/>
    <updated>2022-08-31T13:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="技能相关"> 技能相关</h1>
<h2 id="测试基础"> 测试基础</h2>
<ul>
<li>
<p>问上家公司的测试流程</p>
<ul>
<li>直观说上家公司的测试流程是什么样的</li>
<li>在说完后，可以补上“但是个人觉得这个测试流程可以做些简单的优化，我不知道贵公司的测试流程是什么样的，在上家公司在一些什么特定的环节，添加一些什么流程和机制和跨部门交互的一些内容，通过这样手段可以更好的提高工作效率，让跨部门合作提高了效率之类的”</li>
</ul>
</li>
<li>
<p>测试案例</p>
<p>回答一般有以下两个维度：</p>
<p>项目的介绍</p>
<p>在项目中你所处的位置以及应用技术</p>
<p>例：XX 项目是一个XX平台，这个项目的时长是 XX ，客户群体是 XX，我在这个项目中主要负责自动化框架的设计，定期展开自动化框架的评估等等</p>
</li>
<li>
<p>测试手段</p>
<p>测试的工具</p>
<p>测试的技术</p>
</li>
</ul>
<h2 id="mysql-面试应对"> Mysql 面试应对</h2>
<ul>
<li>基本的增删改查
<ul>
<li>单表查询</li>
</ul>
</li>
</ul>
<h2 id="自动化面试应对"> 自动化面试应对</h2>
<ul>
<li>拥有自动化技能</li>
<li>能设计一个自动化测试框架（任何大中小型框架）</li>
<li>应用企业的系统做过自动化</li>
<li>自动化测试框架</li>
</ul>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-31T13:13:11.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">页面对象（Page Object）模型</title>
    <id>https://www.snowji.cn/test/theory/auto-test/PO-model/</id>
    <link href="https://www.snowji.cn/test/theory/auto-test/PO-model/"/>
    <updated>2022-08-23T01:44:38.000Z</updated>
    <content type="html"><![CDATA[<h1 id="页面对象-page-object-模型"> 页面对象（Page Object）模型</h1>
<h2 id="页面对象模型介绍"> 页面对象模型介绍</h2>
<p><img src="./images/早期代码.jpg" alt="早期代码" /></p>
<p><strong>上述代码存在的问题</strong>：</p>
<ul>
<li>脚本逻辑层次不够清晰，属于 All-in-one 的风格，既有页面元素的定位查找，又有对元素的操作</li>
<li>脚本的可读性差</li>
<li>脚本的每一行都直接描述各个页面上的元素操作，很难一眼看出脚本更高层的业务测试流程</li>
<li>通用步骤在大量测试脚本中重复出现</li>
</ul>
<p><strong>使用模块化封装</strong>：</p>
<p><img src="./images/页面模型.jpg" alt="页面模型" /></p>
<p><strong>优势</strong>：</p>
<ul>
<li>脚本可读性高，逻辑层次清晰</li>
<li>减少通用步骤在大量测试脚本中重复出现</li>
</ul>
<p><strong>页面模型核心</strong>：以页面（Web Page 或者Native App Page）为单位模块化封装页面上的控件以及控件的部分操作</p>
<p>进化上面的代码：</p>
<p><img src="./images/页面对象.jpg" alt="页面对象" /></p>
<p><strong>存在的问题</strong>：GUI的页面会经常变动，使用元素的属性进行定位元素，Page Class 的维护成本很高</p>
<h3 id="页面对象自动化生成"> 页面对象自动化生成</h3>
<p><strong>基本思路</strong>：不用再手工维护 Page Class 了，只需要提供 Web 的 URL，会自动帮你生成这个页面上所有控件的定位信息，并自动生成 Page Class</p>
<p><strong>适用场景</strong>：适用于需要维护大量页面对象的中大型 GUI 自动化测试项目</p>
<p><strong>注意</strong> ：依赖于数据的动态页面对象也会被包含在自动生成的 Page Class 里，而这种动态页面对象通常不应该包含在 Page Class 里，所以需要以手工的方式删除</p>
<p><strong>工具</strong>：UFT、Katalon Studio 等</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-23T01:44:38.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Appium 原理</title>
    <id>https://www.snowji.cn/test/theory/auto-test/appium-theory/</id>
    <link href="https://www.snowji.cn/test/theory/auto-test/appium-theory/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="appium-原理"> Appium 原理</h1>
<p>Appium  是目前主流的移动应用自动化测试框架，具有极强的灵活性：</p>
<ul>
<li>测试用例的实现支持多种编程语言，比如 Java、Ruby、Python 等</li>
<li>Appium Server 支持多平台，既有基于 Mac 的版本，也有基于 Windows 的版本</li>
<li>支持 Web App、Native App 和 Hybird App 三大类移动应用的测试</li>
<li>既支持 iOS，也支持 Android</li>
<li>既支持真机，也支持模拟器</li>
</ul>
<h2 id="原理"> 原理</h2>
<p><img src="./images/appium.jpg" alt="appium" /></p>
<h3 id="appium-server"> <strong>Appium Server</strong></h3>
<p><strong>本质</strong>：接受来自 Appium Client 的请求，解析后通过 WebDriver 协议和设备端上的代理打交道</p>
<ul>
<li>IOS</li>
</ul>
<p>Appium Server 把操作请求发送给 WebDriverAgent（简称 WDA），然后 WDA 再基于 XCUITest 完成 iOS模拟器或者真机上的自动化操作</p>
<ul>
<li>Android</li>
</ul>
<p>Appium Server 把操作请求发送给 appium-UIautomator2-server，然后 appium-UIautomator2-server 再基于 UIAutomator V2 完成 Android 模拟器或者真机上的自动化操作</p>
<h3 id="appium-client"> <strong>Appium Client</strong></h3>
<p>就是测试代码，使用对应语言的 Client 将基于 JSON Wire 协议的操作指令发给 Appium Server</p>
<h3 id="总结"> 总结</h3>
<ul>
<li>Appium 属于 C/S 架构</li>
<li>Appium Client 通过多语言支持的第三方库向 Appium Server 发起请求，Appium Server 会接受 Appium Client 发来的请求，接着和 iOS 或者 Android 平台上的代理工具打交道，代理工具在运行过程中不断接收请求，并根据 WebDriver 协议解析出要执行的操作，最后调用 iOS 或者 Android 平台上的原生测试框架完成测试</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-31T13:17:40.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">自动化测试</title>
    <id>https://www.snowji.cn/test/theory/auto-test/</id>
    <link href="https://www.snowji.cn/test/theory/auto-test/"/>
    <updated>2022-08-22T12:49:33.000Z</updated>
    <content type="html"><![CDATA[<h1 id="自动化测试"> 自动化测试</h1>
<h2 id="自动化介绍"> 自动化介绍</h2>
<p>使用程序自动执行测试用例，并生成测试报告。节约测试成本，提高测试效率。</p>
<h2 id="自动化使用场景"> 自动化使用场景</h2>
<ul>
<li>项目稳定，迭代少</li>
<li>线上冒烟测试</li>
<li>维护自动化脚本成本低</li>
</ul>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-22T12:49:33.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">数据驱动</title>
    <id>https://www.snowji.cn/test/theory/auto-test/data-driven/</id>
    <link href="https://www.snowji.cn/test/theory/auto-test/data-driven/"/>
    <updated>2022-08-22T12:56:33.000Z</updated>
    <content type="html"><![CDATA[<h1 id="数据驱动"> 数据驱动</h1>
<h2 id="数据驱动-2"> 数据驱动</h2>
<p><strong>概念</strong>：将测试数据与脚本分离，提高脚本复用性</p>
<p><img src="./images/数据驱动.jpg" alt="数据驱动" /></p>
<p><strong>作用</strong>：</p>
<ul>
<li>解决了大量重复脚本的问题，实现了“测试脚本和数据的解耦”</li>
<li>数据文件中不仅可以包含测试输入数据，还可以包含测试验证结果数据，甚至可以包含测试逻辑分支的控制变量</li>
<li>不仅适用于 GUI 测试，还可以用于 API 测试、接口测试、单元测试等</li>
</ul>
<h3 id="测试数据"> 测试数据</h3>
<p>常见数据类型：</p>
<ul>
<li>测试输入的数据</li>
<li>为测试准备的数据</li>
</ul>
<p><strong>测试数据创建的方式</strong></p>
<p><strong>从创建的技术角度，测试数据创建方式</strong>：</p>
<ul>
<li>API 调用</li>
</ul>
<p><strong>优势</strong>：测试数据的准确性直接由产品 API 保证</p>
<p><strong>缺点</strong>：并不是所有的测试数据都有相关的 API 来支持，对需要大量创建数据，基于 API 调用方式的执行效率</p>
<ul>
<li>数据库操作</li>
</ul>
<p><strong>存在的问题</strong>：</p>
<p>创建或修改一条测试数据可能会涉及很多业务表，任何的遗漏都会造成测试数据的不准确，从而导致有些测试因为数据问题而无法进行</p>
<p>解决思路：</p>
<ul>
<li>手工方式</li>
</ul>
<p>查阅设计文档和产品代码，找到相关的 SQL 语句集合，或直接找开发人员索要相关的 SQL 语句集合</p>
<ul>
<li>自动方式</li>
</ul>
<p>测试环境中，先在只有一个活跃用户的情况下，通过 GUI 界面操作完成数据的创建、修改，然后利用数据库监控工具获取这段时间内所有的业务表修改记录，以此为依据开发 SQL 语句集</p>
<p><strong>好处</strong>：可以创建和修改 API 不支持的测试数据，执行效率高于 API 调用方法</p>
<p><strong>缺点</strong>：数据库表操作的任何变更，都必须同步更新测试数据工具中的 SQL 语句</p>
<ul>
<li>综合运用 API 调用和数据库操作</li>
</ul>
<p><strong>从创建的时机角度，测试数据的创建方式</strong>：</p>
<ul>
<li>On-the-fly：用例执行过程中，实时创建测试数据</li>
</ul>
<p><strong>优点</strong>：不依赖被测试系统中的任何原有数据，也不会对原有数据产生影响，从数据层面隔离测试用例</p>
<p><strong>存在的问题</strong>：</p>
<ul>
<li>
<p>在用例执行过程中实时创建数据，导致测试的执行时间比较长</p>
</li>
<li>
<p>业务数据的连带关系，导致测试数据的创建效率非常低</p>
</li>
</ul>
<p>比如：需要创建一个订单数据，而这个订单必然会绑定买家和卖家，以及订单商品信息</p>
<p>如果完全基于 On-the-fly 模式，需要先实时创建买家和卖家这两个用户，然后再创建订单中的商品，最后才是创建这个订单本身。显然，这样的测试数据创建方式虽然是“自包含”的，但创建效率非常低，会使得测试用例执行时间变得更长，而这恰恰与互联网产品的测试策略产生冲突</p>
<ul>
<li>实时创建测试数据的方式对测试环境的依赖性很强</li>
</ul>
<p>比如：测试用户登录功能，基于 On-the-fly 方式，应该先调用测试数据工具实时创建一个用户，然后再用这个用户完成登录测试。这时，创建用户的 API 由于各种原因处于不可用的状态那么这时就会因为无法创建用户，而无法完成用户登录测试。</p>
<p><strong>使用场景</strong>：对于只能一次性使用的测试数据，比如商品、订单、优惠券等，往往采用 On-the-fly 的方式以保证不存在脏数据问题</p>
<ul>
<li>Out-of-box：用例执行前，事先创建好“开箱即用”的测试数据</li>
</ul>
<p><strong>优点</strong>：<strong>开箱即用</strong>，在被测系统中预先创建好了充足的、典型的测试数据，<strong>后续的测试用例可以直接使用</strong></p>
<p><strong>使用场景</strong>：对于相对稳定的测试数据，比如商品类型、图书类型等，往往采用 Out-of-box 的方式</p>
<p><strong>存在的问题</strong>：</p>
<ul>
<li>
<p>测试用例中需要硬编码（hardcode）测试数据，额外引入了测试数据和用例之间的依赖</p>
</li>
<li>
<p>只能被一次性使用的测试数据不适合 Out-of-box 的方式</p>
</li>
</ul>
<p>比如：优惠券在一个订单中被使用后，就失效了</p>
<ul>
<li>“预埋”的测试数据的可靠性远不如实时创建的数据</li>
</ul>
<p><strong>On-the-fly 和 Out-of-box 的互补</strong>：</p>
<ul>
<li>对于相对稳定、很少有修改的数据，建议采用 Out-of-box 的方式</li>
</ul>
<p>比如：商品类目、厂商品牌、部分标准的卖家和买家账号等</p>
<ul>
<li>
<p>对于一次性使用、经常需要修改、状态经常变化的数据，建议使用 On-the-fly 的方式</p>
</li>
<li>
<p>用 On-the-fly 方式创建测试数据时，上游数据的创建可以采用 Out-of-box 方式，以提高测试数据创建的效率</p>
</li>
</ul>
<p>比如：订单的创建可以采用 On-the-fly 方式，而与订单相关联的卖家、买家和商品信息可以使用 Out-of-box 方式创建</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-22T12:56:33.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">关键字驱动设计</title>
    <id>https://www.snowji.cn/test/theory/auto-test/keyword-driven-design/</id>
    <link href="https://www.snowji.cn/test/theory/auto-test/keyword-driven-design/"/>
    <updated>2022-08-23T01:43:19.000Z</updated>
    <content type="html"><![CDATA[<h1 id="关键字驱动设计"> 关键字驱动设计</h1>
<h2 id="什么是关键字驱动"> 什么是关键字驱动</h2>
<ul>
<li>是自动化测试的一种实现方式</li>
<li>将 UI 自动化中常用的操作行为，封装成自定义的函数，以便于直接调用</li>
</ul>
<h2 id="结构设计"> 结构设计</h2>
<ul>
<li>逻辑代码的实现，本身不存在任何价值，需要结合业务才能体现作用</li>
<li>只有测试代码才可以对系统的功能进行自动化测试</li>
<li>数据与代码进行分离，但凡数据需要改动，直接修改数据文件即可，不会影响到原因代码的稳定性</li>
</ul>
<h2 id="示例"> 示例</h2>
<p>在进行 UI 自动化测试时，经常会对输入框定位，然后输入值，再点击按钮操作</p>
<p>一般代码：</p>
<div><pre><code><span>from</span> selenium <span>import</span> webdriver
<span>from</span> selenium<span>.</span>webdriver<span>.</span>common<span>.</span>by <span>import</span> By
<span>from</span> time <span>import</span> sleep

driver <span>=</span> webdriver<span>.</span>Chrome<span>(</span><span>)</span>
driver<span>.</span>get<span>(</span><span>"http://www.baidu.com"</span><span>)</span>
driver<span>.</span>find_element<span>(</span>By<span>.</span>ID<span>,</span><span>'kw'</span><span>)</span><span>.</span>send_keys<span>(</span><span>'虚竹'</span><span>)</span>
driver<span>.</span>find_element<span>(</span>By<span>.</span>ID<span>,</span><span>'su'</span><span>)</span><span>.</span>click<span>(</span><span>)</span>
sleep<span>(</span><span>3</span><span>)</span>
driver<span>.</span>quit<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>上述代码中定位查找的操作比较多，代码比较重复</p>
<p>使用关键字改进上述代码</p>
<div><pre><code><span># 创建浏览器对象</span>
<span>def</span> <span>open_browser</span><span>(</span>type_<span>)</span><span>:</span>
    <span>try</span><span>:</span>
        driver <span>=</span> <span>getattr</span><span>(</span>webdriver<span>,</span>type_<span>)</span>
    <span>except</span><span>:</span>
        driver <span>=</span> webdriver<span>.</span>Chrome<span>(</span><span>)</span>
    <span>return</span> driver


<span>class</span> <span>WebKeys</span><span>:</span>
    <span># 获取driver</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span>type_<span>)</span><span>:</span>
        self<span>.</span>driver <span>=</span> open_browser<span>(</span>type_<span>)</span>

    <span># 打开网址</span>
    <span>def</span> <span>open</span><span>(</span>self<span>,</span>url<span>)</span><span>:</span>
        self<span>.</span>driver<span>.</span>get<span>(</span>url<span>)</span>

    <span># 查找元素</span>
    <span>def</span> <span>find</span><span>(</span>self<span>,</span>by<span>,</span>key<span>)</span><span>:</span>
        <span>return</span> self<span>.</span>driver<span>.</span>find_element<span>(</span>by<span>,</span> key<span>)</span>

    <span># 输入value</span>
    <span>def</span> <span>send</span><span>(</span>self<span>,</span>by<span>,</span>key<span>,</span>value<span>)</span><span>:</span>
        self<span>.</span>find<span>(</span>by<span>,</span>key<span>)</span><span>.</span>send_keys<span>(</span>value<span>)</span>

    <span># 退出</span>
    <span>def</span> <span>quit</span><span>(</span>self<span>)</span><span>:</span>
        self<span>.</span>driver<span>.</span>quit<span>(</span><span>)</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>对比上面的代码，这种重复性的操作就可以减少代码量</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-23T01:43:19.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">YAML</title>
    <id>https://www.snowji.cn/test/theory/auto-test/yaml/</id>
    <link href="https://www.snowji.cn/test/theory/auto-test/yaml/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="yaml"> YAML</h1>
<h2 id="什么是-yaml"> 什么是 YAML</h2>
<ul>
<li>是一种标记语言</li>
<li>配置文件后缀未 <code>.yml</code></li>
<li>使用空白符号缩进</li>
</ul>
<h2 id="基本语法"> 基本语法</h2>
<ul>
<li>大小写敏感</li>
<li>使用缩进表示层级关系</li>
<li>缩进不允许使用 tab，只允许空格</li>
<li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li>
<li>'#'表示注释</li>
</ul>
<h2 id="支持的数据结构"> 支持的数据结构</h2>
<ul>
<li>对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）</li>
<li>数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）</li>
<li>纯量（scalars）：单个的、不可再分的值</li>
</ul>
<h3 id="yaml-对象"> YAML 对象</h3>
<p>格式：</p>
<ul>
<li>对象键值对使用冒号结构表示 key: value，冒号后面要加一个空格</li>
<li>也可以使用 key:{key1: value1, key2: value2, ...}</li>
<li>还可以使用缩进表示层级关系</li>
</ul>
<div><pre><code><span># 使用 key: value 形式</span>
<span>name</span><span>:</span> admin
<span>age</span><span>:</span> <span>18</span>
<span>sex</span><span>:</span> male

<span># 使用 key:{key1: value1, key2: value2, ...} 形式</span>
<span>data</span><span>:</span> <span>{</span><span>name</span><span>:</span> admin<span>,</span> <span>age</span><span>:</span> <span>19</span><span>,</span> <span>sex</span><span>:</span> male<span>}</span>

<span># 使用缩进层级关系</span>
<span>dict1</span><span>:</span>
  <span>name</span><span>:</span> admin
  <span>age</span><span>:</span> <span>18</span>
  <span>sex</span><span>:</span> female
<span>dict2</span><span>:</span>
  <span>name</span><span>:</span> admin1
  <span>age</span><span>:</span> <span>13</span>
  <span>sex</span><span>:</span> male
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>输出 Python 结果：</p>
<div><pre><code><span>{</span><span>'name'</span><span>:</span> <span>'admin'</span><span>,</span> <span>'age'</span><span>:</span> <span>18</span><span>,</span> <span>'sex'</span><span>:</span> <span>'male'</span><span>}</span>

<span>{</span><span>'data'</span><span>:</span> <span>{</span><span>'name'</span><span>:</span> <span>'admin'</span><span>,</span> <span>'age'</span><span>:</span> <span>19</span><span>,</span> <span>'sex'</span><span>:</span> <span>'male'</span><span>}</span><span>}</span>

<span>{</span><span>'dict1'</span><span>:</span> <span>{</span><span>'name'</span><span>:</span> <span>'admin'</span><span>,</span> <span>'age'</span><span>:</span> <span>18</span><span>,</span> <span>'sex'</span><span>:</span> <span>'female'</span><span>}</span><span>,</span> <span>'dict2'</span><span>:</span> <span>{</span><span>'name'</span><span>:</span> <span>'admin1'</span><span>,</span> <span>'age'</span><span>:</span> <span>13</span><span>,</span> <span>'sex'</span><span>:</span> <span>'male'</span><span>}</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="yaml-数组"> YAML 数组</h3>
<p>格式：以 <code>-</code> 开头的行表示构成一个数组</p>
<div><pre><code><span>-</span> a
<span>-</span> b
<span>-</span> c
<span>-</span>
 <span>-</span> A
 <span>-</span> B
 <span>-</span> C
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>输出 Python 结果：</p>
<div><pre><code><span>[</span><span>'a'</span><span>,</span> <span>'b'</span><span>,</span> <span>'c'</span><span>,</span> <span>[</span><span>'A'</span><span>,</span> <span>'B'</span><span>,</span> <span>'C'</span><span>]</span><span>]</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="纯量"> 纯量</h3>
<p>包含：</p>
<ul>
<li>字符串</li>
<li>布尔值</li>
<li>整数</li>
<li>浮点数</li>
<li>Null</li>
<li>时间</li>
<li>日期</li>
</ul>
<div><pre><code><span>boolean</span><span>:</span> 
    <span>-</span> <span>TRUE</span>  <span>#true,True都可以</span>
    <span>-</span> <span>FALSE</span>  <span>#false，False都可以</span>
<span>float</span><span>:</span>
    <span>-</span> <span>3.14</span>
    <span>-</span> <span>6.8523015e+5</span>  <span>#可以使用科学计数法</span>
<span>int</span><span>:</span>
    <span>-</span> <span>123</span>
    <span>-</span> 0b1010_0111_0100_1010_1110    <span>#二进制表示</span>
<span>null</span><span>:</span>
    <span>nodeName</span><span>:</span> <span>'node'</span>
    <span>parent</span><span>:</span> <span>~</span>  <span>#使用~表示null</span>
<span>string</span><span>:</span>
    <span>-</span> 哈哈
    <span>-</span> <span>'Hello world'</span>  <span>#可以使用双引号或者单引号包裹特殊字符</span>
    <span>-</span> newline
      newline2    <span>#字符串可以拆成多行，每一行会被转化成一个空格</span>
<span>date</span><span>:</span>
    <span>-</span> <span>2018-02-17</span>    <span>#日期必须使用ISO 8601格式，即yyyy-MM-dd</span>
<span>datetime</span><span>:</span> 
    <span>-</span>  <span>2018-02-17T15:02:31+08:00</span>    <span>#时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h3 id="引用"> 引用</h3>
<p>锚点 &amp; 和别名 * ，可以用来引用</p>
<div><pre><code><span>defaults</span><span>:</span> <span>&amp;defaults</span>
  <span>adapter</span><span>:</span>  postgres
  <span>host</span><span>:</span>     localhost

<span>development</span><span>:</span>
  <span>database</span><span>:</span> myapp_development
  <span>&lt;&lt;</span><span>:</span> <span>*defaults</span>

<span>test</span><span>:</span>
  <span>database</span><span>:</span> myapp_test
  <span>&lt;&lt;</span><span>:</span> <span>*defaults</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>等同于</p>
<div><pre><code><span>defaults</span><span>:</span>
  <span>adapter</span><span>:</span>  postgres
  <span>host</span><span>:</span>     localhost

<span>development</span><span>:</span>
  <span>database</span><span>:</span> myapp_development
  <span>adapter</span><span>:</span>  postgres
  <span>host</span><span>:</span>     localhost

<span>test</span><span>:</span>
  <span>database</span><span>:</span> myapp_test
  <span>adapter</span><span>:</span>  postgres
  <span>host</span><span>:</span>     localhost
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>&amp; 用来建立锚点（defaults），&lt;&lt; 表示合并到当前数据，* 用来引用锚点</p>
<h2 id="参考资料"> 参考资料</h2>
<p><a href="https://www.ruanyifeng.com/blog/2016/07/yaml.html" target="_blank" rel="noopener noreferrer">YAML 语言教程</a></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-23T01:45:45.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">大型项目 GUI 自动化测试设计策略</title>
    <id>https://www.snowji.cn/test/theory/auto-test/%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AEGUI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E7%AD%96%E7%95%A5/</id>
    <link href="https://www.snowji.cn/test/theory/auto-test/%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AEGUI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E7%AD%96%E7%95%A5/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="大型项目-gui-自动化测试设计策略"> 大型项目 GUI 自动化测试设计策略</h1>
<h2 id="测试策略设计"> 测试策略设计</h2>
<p>大型网站 GUI 自动化测试应该做得比较轻量级，而不应该把大量的功能测试，以及功能的组合测试放在 GUI 自动化测试</p>
<p>GUI 的验证不是在系统全部完成后才真正开展的，应该是分阶段、分层次来设计制定测试策略的</p>
<p><strong>策略设计</strong>：</p>
<ul>
<li>从前端组件的级别来保证质量，需要对那些自定义开发的组件进行完整全面的测试</li>
</ul>
<p>公共组件库会被很多上层的前端模块依赖，它的质量将直接影响这些上层模块的质量，所以会对这些公共组件进行严格的单元测试</p>
<p><strong>常用的方案</strong>：基于 Jest 开展单元测试，并考量 JavaScript 的代码覆盖率指标</p>
<p>完成单元测试后，在页面层面再次验证控件相关的功能和状态 ：</p>
<ul>
<li>
<p>先构建一个空页面，并加入被测控件，构建出一个被称为 Dummy Page 并包含被测控件的测试页面</p>
</li>
<li>
<p>从黑盒的角度，在测试页面上通过手工和自动化的方式操作被测控件，并验证其功能的正确性</p>
</li>
<li>
<p>在每一个前端模块构建的页面对象库上，封装开发自己的业务流程脚本，组装成每个前端模块的测试用例</p>
</li>
</ul>
<p>以用户管理模块为例，组装过程如下：</p>
<ul>
<li>把用户管理模块中涉及到的所有页面，比如登录页面、用户注册页面等，按照页面对象模型的要求写成Page 类；</li>
<li>利用这些 Page 类封装业务流程脚本，比如用户登录流程，用户注册流程等；</li>
<li>在 GUI 测试用例脚本中，调用封装好的业务流程脚本构成该模块的 GUI 测试用例。</li>
</ul>
<p><strong>自动化用例原则</strong>：优先选取业务关键路径以及 Happy Path 作为自动化测试的范围</p>
<ul>
<li>
<p>组合各个前端模块，并站在终端用户的视角，以黑盒的方式使用网站的端到端（E2E）测试</p>
<ul>
<li>通过探索式测试的方法手工执行测试，目标是尽可能多地发现新问题</li>
<li>通过 GUI 自动化测试执行基本业务功能的回归测试，保证网站核心业务相关的所有功能的正确性</li>
</ul>
</li>
</ul>
<p><strong>GUI 自动化测试用例脚本开发</strong>：</p>
<p>最好的做法：</p>
<ul>
<li>
<p>成立一个专门的 E2E 测试团队，负责这种系统级别的 GUI 测试</p>
</li>
<li>
<p>E2E 团队应该尽可能地利用各个模块已有的页面对象和业务流程脚本，组装端到端的 GUI 测试</p>
</li>
</ul>
<h2 id="测试脚本管理"> 测试脚本管理</h2>
<p>将各个模块的页面对象和业务流程脚本放在各自的代码库中，并引入页面对象和业务流程脚本的版本管理机制</p>
<p><img src="./images/测试脚本管理.jpg" alt="测试脚本管理" /></p>
<p><strong>好处</strong>：</p>
<ul>
<li>
<p>E2E 团队不需要重复开发任何的页面对象和业务流程脚本，可以始终保证与各个模块的最新实现同步</p>
</li>
<li>
<p>同时端到端的 GUI 测试用例脚本也会比较稳定，不会因为各个模块的改动而频繁地修改</p>
</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-23T01:47:57.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">必备知识</title>
    <id>https://www.snowji.cn/test/theory/basic-essentials/</id>
    <link href="https://www.snowji.cn/test/theory/basic-essentials/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="必备知识"> 必备知识</h1>
<h2 id="测试方法"> 测试方法</h2>
<p><strong>常用黑盒测试方法</strong>：</p>
<ul>
<li>边界值</li>
<li>等价类</li>
<li>场景法</li>
<li>错误推断</li>
<li>因果图法</li>
<li>正交试验法</li>
</ul>
<h2 id="测试流程"> 测试流程</h2>
<p>一般标准化的测试流程</p>
<p><img src="./images/cslc.png" alt="cslc" /></p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-22T11:11:53.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">编程题</title>
    <id>https://www.snowji.cn/test/interview/%E7%BC%96%E7%A8%8B%E9%A2%98/%E7%BC%96%E7%A8%8B%E9%A2%98/</id>
    <link href="https://www.snowji.cn/test/interview/%E7%BC%96%E7%A8%8B%E9%A2%98/%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    <updated>2022-08-31T13:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="编程题"> 编程题</h1>
<h2 id="_1-冒泡排序"> 1. 冒泡排序</h2>
<h2 id="_2-1-9999数列中数字3出现的次数。用递推方法解出"> 2. 1~9999数列中数字3出现的次数。用递推方法解出</h2>
<h2 id="_3-从一个数组中找出前4个最大的数-用最优解"> 3. 从一个数组中找出前4个最大的数，用最优解</h2>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-31T13:13:11.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">面试心理学</title>
    <id>https://www.snowji.cn/test/interview/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/%E9%9D%A2%E8%AF%95%E5%BF%83%E7%90%86%E5%AD%A6/</id>
    <link href="https://www.snowji.cn/test/interview/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/%E9%9D%A2%E8%AF%95%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    <updated>2022-08-31T13:13:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="面试心理学"> 面试心理学</h1>
<ul>
<li>
<p>主导权</p>
<p>掌控整体面试节奏的权力</p>
<p>在回答一些不会的问题时，可以反问面试官</p>
<p>例：问：请问有做过接口自动化测试</p>
<p>答：一般做 web 自动化比较多，接口自动化没有接触过，请问贵公司现在是有在做接口自动化这块嘛？</p>
<p>但会存在以下几种结果：</p>
<ul>
<li>回复</li>
<li>不回复</li>
<li>产生抗拒：不要尝试了</li>
</ul>
</li>
<li>
<p>交流</p>
<p>一定要清楚</p>
</li>
<li>
<p>口头禅</p>
<p>尽量不要说</p>
</li>
<li>
<p>肢体语言</p>
<p>可以适量有</p>
<p>身体语言：</p>
<ul>
<li>
<p>身体后仰</p>
<p>表明面试官对当前的话题不感兴趣，这时候可以结束这个话题</p>
</li>
<li>
<p>撇嘴/抿嘴、摇头</p>
<p>表示面试官对你的观点不赞同</p>
</li>
<li>
<p>十指交叉</p>
<p>单独动作：表示面试官有自己的观点，但在听你在说观点</p>
<p>加上抿嘴：表示不认同你的观点</p>
</li>
</ul>
</li>
</ul>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-31T13:13:11.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">提高 GUI 测试稳定性</title>
    <id>https://www.snowji.cn/test/theory/auto-test/%E6%8F%90%E9%AB%98GUI%E6%B5%8B%E8%AF%95%E7%A8%B3%E5%AE%9A%E6%80%A7/</id>
    <link href="https://www.snowji.cn/test/theory/auto-test/%E6%8F%90%E9%AB%98GUI%E6%B5%8B%E8%AF%95%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="提高-gui-测试稳定性"> 提高 GUI 测试稳定性</h1>
<p><strong>GUI 不稳定因素</strong>：</p>
<ul>
<li>非预计的弹出对话框</li>
<li>页面控件属性的细微变化</li>
<li>被测系统的 A/B 测试</li>
<li>随机的页面延迟造成控件识别失败</li>
<li>测试数据问题</li>
</ul>
<h2 id="不稳定解决思路"> 不稳定解决思路</h2>
<h3 id="非预计的弹出对话框"> 非预计的弹出对话框</h3>
<p><strong>包含场景</strong>：</p>
<ul>
<li>GUI 自动化测试用例执行过程中，操作系统弹出的非预计对话框</li>
<li>被测软件本身也有可能在非预期的时间弹出预期的对话框</li>
</ul>
<p><strong>解决方案</strong>：</p>
<ul>
<li>当自动化脚本发现控件无法正常定位，或者无法操作时，GUI 自动化框架自动进入“异常场景恢复模式”</li>
<li>在“异常场景恢复模式”下，GUI 自动化框架依次检查各种可能出现的对话框，一旦确认了对话框的类型，立即执行预定义的操作（比如，单击“确定”按钮，关闭这个对话框），接着重试刚才失败的步骤</li>
</ul>
<p><strong>局限性</strong>：只能处理已知可能出现的对话框。而对于新类型的对话框，只能通过自动化的方式尝试点击上面的按钮进行处理</p>
<h3 id="页面控件属性的细微变化"> 页面控件属性的细微变化</h3>
<p>例：“登录”按钮的 ID 从 “Button_Login_001” 变成了 “Button_Login_888”，还是按照原来 “Button_Login_001” 来定位“登录”按钮，就会因为 ID 值的变化，定位不到它</p>
<p><strong>定位控件思路</strong>：</p>
<ul>
<li>通过控件类型（Button）缩小了范围</li>
<li>通过属性值中的关键字（Login）进一步缩小范围</li>
<li>根据属性值变化前后的相似性，最终定位到该控件</li>
</ul>
<p><strong>结论</strong>：采用“组合属性”定位控件会更精准，而且成功率会更高，如果能在此基础上加入“模糊匹配”技术，可以进一步提高控件的识别率</p>
<h3 id="被测系统的-a-b-测试"> 被测系统的 A/B 测试</h3>
<p>概念：</p>
<ul>
<li>A/B 测试，是互联网产品常用的一种测试方法</li>
<li>为 Web 或 App 的界面或流程提供两个不同的版本，然后让用户随机访问其中一个版本，并收集两个版本的用户体验数据和业务数据，最后分析评估出最好的版本用于正式发布</li>
</ul>
<p><strong>造成 GUI 不稳定原因</strong>：A/B 测试通常会发布到实际生产环境</p>
<p><strong>解决思路</strong>：在测试脚本内部对不同的被测版本做分支处理，脚本需要能够区分 A 和 B 两个的不同版本，并做出相应的处理</p>
<h3 id="随机的页面延迟造成控件识别失败"> 随机的页面延迟造成控件识别失败</h3>
<p><strong>解决方案</strong>：加入重试（retry）机制</p>
<p>重试机制：当某一步 GUI 操作失败时，框架会自动发起重试, 重试可以是步骤级别的，也可以是页面级别的，甚至是业务流程级别的</p>
<p><strong>注意</strong>：对于那些会修改一次性使用数据的场景，切忌不要盲目启用页面级别和业务流程级别的重试</p>
<h3 id="测试数据问题"> 测试数据问题</h3>
<p>比如：测试用例所依赖的数据被其他用例修改了</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-23T01:51:24.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">如何做好测试计划</title>
    <id>https://www.snowji.cn/test/theory/basic-essentials/%E5%A6%82%E4%BD%95%E6%89%8D%E8%83%BD%E5%81%9A%E5%A5%BD%E6%B5%8B%E8%AF%95%E8%AE%A1%E5%88%92/</id>
    <link href="https://www.snowji.cn/test/theory/basic-essentials/%E5%A6%82%E4%BD%95%E6%89%8D%E8%83%BD%E5%81%9A%E5%A5%BD%E6%B5%8B%E8%AF%95%E8%AE%A1%E5%88%92/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="如何做好测试计划"> 如何做好测试计划</h1>
<h2 id="测试计划的好处"> 测试计划的好处</h2>
<ul>
<li>知道确切的测试范围，采取怎么样的测试策略</li>
<li>预估具体的工作量和测试资源，每个人分工明确，不容易出现重复测试和漏测的情况</li>
<li>测试进度是可控的，实时知道目前测试完成情况，能预估完成的时间节点</li>
<li>可以提前识别潜在风险，当需求发生变化时，我们需要做出响应</li>
</ul>
<h2 id="测试计划内容"> 测试计划内容</h2>
<h3 id="测试范围"> 测试范围</h3>
<p><strong>内容</strong>：被测对象、主要测试内容</p>
<p>测试范围的确定通常是在<strong>测试需求分析完成后进行</strong>，确定测试范围的过程在一定程度上也是对测试需求分析的进一步检验，有助于在早期阶段就发现潜在的测试遗漏。</p>
<p>由于不可能进行穷尽测试，而且测试的时间和资源都是有限的，<strong>测试范围需要明确测什么和不测什么</strong>。</p>
<h3 id="测试策略"> 测试策略</h3>
<p><strong>目的</strong>：测试策略需要明确<strong>先测什么后测什么</strong>和<strong>如何来测</strong>，要求<strong>明确测试的重点</strong>，以及各项测试的<strong>先后顺序</strong>。</p>
<p>比如：对用户登录模块来讲，「用户无法正常登录」和「用户无法重置密码」这两个潜在问题，按照优先级来先测「用户正常登录」，再测「用户重置密码」。</p>
<p><strong>测试策略还需要说明，采用什么样的测试类型和测试方法</strong>，要给出为什么要选用这个测试类型，还要详细说明具体的实施方法。</p>
<ul>
<li>
<p><strong>功能测试</strong></p>
<ul>
<li>应该根据测试需求分析的思维导图来设计</li>
<li>主线业务的功能测试由于经常需要执行回归测试，需要考虑实施自动化测试，<strong>通常应该先实现主干业务流程的测试自动化</strong></li>
<li>还要评估被测软件的可测试性，如果有可测试性的问题，需要提前考虑切实可行的变通方案</li>
</ul>
</li>
<li>
<p><strong>兼容性测试</strong></p>
<ul>
<li>兼容性测试的测试，一般是在功能测试的后期</li>
<li>Web测试需要确定覆盖的浏览器类型和版本</li>
<li>移动设备测试需要确定覆盖的设备类型和具体iOS/Android的版本</li>
<li><strong>确定需要覆盖的移动设备类型以及 iOS/Android 的版本列表</strong>：
<ul>
<li>如果是既有产品，你可以通过大数据技术分析产品的历史数据得出 Top 30% 的移动设备以及 iOS/Android 的版本列表</li>
<li>如果是一个全新的产品，你可以通过 TalkingData 这样的网站来查看目前主流的移动设备，分辨率大小</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>性能测试</strong></p>
<ul>
<li>对于性能测试，需要在明确了性能需求的前提下，结合被测系统的特点，设计性能测试场景并确定性能测试框架</li>
<li><strong>性能需求</strong>：并发用户数、响应时间、事务吞吐量等<br>
比如：是直接在 API 级别发起压力测试，还是必须模拟终端用户行为进行基于协议的压力测试</li>
<li>如果性能是背景数据敏感的场景，还需要确定背景数据量级与分布，并决定产生背景数据的技术方案<br>
比如：是通过 API 并发调用来产生测试数据，还是直接在数据库上做批量 insert 和 update 操作，或者是两种方式的结合</li>
<li>性能测试的实施，是一个比较复杂的问题。首先，需要根据你想要解决的问题，确定性能测试的类型；然后，根据具体的性能测试类型开展测试</li>
<li><strong>性能测试步骤</strong>：
<ul>
<li>先要根据业务场景来决定需要开发哪些单用户脚本</li>
<li><strong>脚本开发涉及的概念</strong>：思考时间、集合点、动态关联等等</li>
<li>脚本开发完成后，你还要以脚本为单位组织测试场景</li>
<li><strong>场景定义</strong>：
<ul>
<li>百分之多少的用户在做登录、百分之多少的用户在做查询</li>
<li>每个用户的操作步骤之间需要等待多少时间、并发用户的增速是 5 秒一个，还是 5 秒 2 个等等</li>
</ul>
</li>
<li>具体的测试场景执行
<ul>
<li><strong>关键点</strong>：性能测试执行完成后性能测试报告的解读</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="测试资源"> 测试资源</h3>
<p><strong>包含</strong>：测试人员、测试环境</p>
<p><strong>需要明确的问题</strong>：谁来测、在哪里测</p>
<p><strong>测试人员资源</strong>：</p>
<ul>
<li>测试工程师的数量</li>
<li>测试工程师的个人经验和能力</li>
</ul>
<p><strong>规划好测试资源的前提</strong>：</p>
<ul>
<li>了解项目本身</li>
<li>对测试团队的人员特点有清晰的把控，针对团队成员的实际情况去安排测试计划</li>
<li>把具体的任务清晰地落实到每个人的身上，有利于建立清晰的责任机制，避免后续可能发生的扯皮</li>
</ul>
<h3 id="测试进度"> 测试进度</h3>
<p><strong>主要内容</strong>：各类测试的开始时间，所需工作量，预计完成时间，并以此为依据来建议最终产品的上线发布时间</p>
<p>比如：版本接受测试（Build Acceptance Test）的工作量，冒烟测试（Smoke Test）的工作量，自动化脚本开发的工作量，缺陷修复的验证工作量，需要几轮回归测试、每一轮回归测试的工作量等等</p>
<p><strong>不同模式下的测试进度</strong>：</p>
<ul>
<li>
<p>传统瀑布模型<br>
测试进度<strong>完全依赖于开发完成并递交测试版本的时间</strong>，如果开发提交测试版本发生了延误，那么在不裁剪测试需求的情况下，产品整体的上线时间就同样会延期</p>
</li>
<li>
<p>敏捷模式<br>
测试活动贯穿于整个开发过程，测试工作会和开发工作<strong>同步进行</strong><br>
比如：采用行为驱动开发（Behavior-Driven Development）模式，测试进度就不会完全依赖于开发递交可测试版本的时间</p>
</li>
</ul>
<p><strong>行为驱动开发</strong>：常说的 BDD，指的是可以通过自然语言书写非程序员可读的测试用例，并通过 StepDef 来关联基于自然语言的步骤描述和具体的业务操作，最典型的框架就是知名「Cucumber」。</p>
<h3 id="测试风险预估"> 测试风险预估</h3>
<p>在制定测试计划时，要预估整个测试过程中可能存在的<strong>潜在风险</strong>，以及当这些风险发生时的应对策略</p>
<p><strong>存在测试风险的主要原因</strong>：</p>
<ul>
<li>需求变更<br>
比如：增加需求、删减需求、修改需求等，一定要重新进行测试需求分析，确定变更后的测试范围和资源评估，并与项目经理和产品经理及时沟通因此引起的测试进度变化</li>
<li>开发延期</li>
<li>发现重大缺陷</li>
<li>人员变动</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-22T12:13:27.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">代码级测试方法</title>
    <id>https://www.snowji.cn/test/theory/basic-essentials/%E4%BB%A3%E7%A0%81%E7%BA%A7%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/</id>
    <link href="https://www.snowji.cn/test/theory/basic-essentials/%E4%BB%A3%E7%A0%81%E7%BA%A7%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="代码级测试方法"> 代码级测试方法</h1>
<h2 id="常见代码错误类型"> 常见代码错误类型</h2>
<h3 id="语法特征错误"> 语法特征错误</h3>
<p>存在形式：</p>
<ul>
<li>
<p>从编程语法上就能发现的错误</p>
</li>
<li>
<p>比较隐晦的语法错误，不会再编译时出现，但会在运行时出错</p>
</li>
</ul>
<p>比如：</p>
<div><pre><code><span>def</span> <span>demoMethod</span><span>(</span><span>)</span>
<span>{</span>
   a<span>[</span><span>10</span><span>]</span><span>;</span>
  a<span>[</span><span>10</span><span>]</span><span>=</span><span>88</span><span>;</span>
  <span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="边界行为特征错误"> 边界行为特征错误</h3>
<p>通常都是发生在一些边界条件上，代码在执行过程中发生异常，崩溃或者超时</p>
<p>比如：</p>
<div><pre><code><span>def</span> <span>division</span><span>(</span>a<span>,</span> b<span>)</span>
<span>{</span>
  <span>return</span> a<span>/</span>b<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="经验特征错误"> 经验特征错误</h3>
<p>根据过往经验发现代码错误</p>
<h3 id="算法错误"> 算法错误</h3>
<ul>
<li>
<p>代码完成的计算（或者功能）和之前预先设计的计算结果（或者功能）不一致</p>
</li>
<li>
<p>完全的算法错误并不常见，因为不能准确完成基本功能需求的代码，是一定不会被递交的</p>
</li>
</ul>
<h3 id="部分算法错误"> 部分算法错误</h3>
<p>在一些特定的条件或者输入情况下，算法不能准确完成业务要求实现的功能</p>
<h2 id="代码级测试常用方法"> 代码级测试常用方法</h2>
<p><strong>代码级测试方法主要分为两大类，分别是静态方法和动态方法</strong></p>
<h3 id="静态方法"> 静态方法</h3>
<p>在不实际执行代码的基础上发现代码缺陷的方法，又可以进一步细分为人工静态方法和自动静态方法</p>
<p><strong>人工静态方法</strong>：</p>
<p>通过人工阅读代码查找代码中潜在错误的方法，通常采用的手段包括，<strong>开发人员代码走查、结对编程、同行评审</strong>等</p>
<p><strong>局限性</strong>：</p>
<ul>
<li>过度依赖于代码评审者的个人能力，同样的评审流程，发现的问题却相差悬殊</li>
<li>如果开发人员自行走查自己的代码，会存在“思维惯性”，开发过程中没有能考虑的输入和边界值，代码走查时也一样会被遗漏</li>
<li>由于完全依赖人工，效率普遍较低</li>
</ul>
<p><strong>自动静态方法</strong>：</p>
<p>在不运行代码的方式下，通过词法分析、语法分析、控制流分析等技术，并结合各种预定义和自定义的代码规则，对程序代码进行静态扫描发现语法错误、潜在语义错误，以及部分动态错误的一种代码分析技术</p>
<p><strong>优点</strong>：可以发现语法特征错误、边界行为特征错误和经验特征错误这三类“有特征”的错误</p>
<p><strong>缺点</strong>：不能发现算法错误和部分算法错误这两种“无特征”的错误</p>
<h3 id="动态方法"> 动态方法</h3>
<p>通过实际执行代码发现代码中潜在缺陷的方法，同样可以进一步细分为人工动态方法和自动动态方法</p>
<p><strong>人工动态方法</strong>：</p>
<p>设计代码的输入和预期的正确输出的集合，然后执行代码，判断实际输出是否符合预期</p>
<p><strong>人工动态方法是最主要的测试手段，可以真正检测代码的逻辑功能</strong></p>
<p><strong>关注点</strong>：是“什么样的输入，执行了什么代码，产生了什么样的输出”，所以最善于发现算法错误和部分算法错误</p>
<p><strong>自动动态方法</strong>：</p>
<p>基于代码自动生成边界测试用例并执行，以捕捉潜在的异常、崩溃和超时的方法</p>
<p><strong>自动动态方法，可以覆盖边界行为特征错误</strong></p>
<p><strong>不足</strong>：对于发现算法错误无能为力</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-22T12:02:56.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">如何设计一个「好的」测试用例</title>
    <id>https://www.snowji.cn/test/theory/basic-essentials/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%A5%BD%E7%9A%84%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/</id>
    <link href="https://www.snowji.cn/test/theory/basic-essentials/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%A5%BD%E7%9A%84%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    <updated>2022-10-30T08:58:48.000Z</updated>
    <content type="html"><![CDATA[<h1 id="如何设计一个「好的」测试用例"> 如何设计一个「好的」测试用例</h1>
<h2 id="如何理解什么是「好的」测试用例"> 如何理解什么是「好的」测试用例</h2>
<p>「好的」测试用例一定是一个完备的集合，<strong>能够覆盖所有等价类以及各种边界值，而跟能否发现缺陷无关</strong>。</p>
<p>举个「池塘捕鱼」的例子：</p>
<ul>
<li>被测软件：池塘</li>
<li>软件缺陷：池塘中的鱼</li>
<li>测试用例集：捕鱼网</li>
</ul>
<p>好的测试用例集就是一张能够覆盖整个池塘的大渔网，只要池塘里有鱼，这个大渔网就一定能把鱼给捞上来。</p>
<p>如果渔网本身是完整的且合格的，那么捞不到鱼，就证明池塘中没有鱼，而渔网的好坏与池塘中是否有鱼无关。</p>
<h2 id="「好的」测试用例具备的特征"> 「好的」测试用例具备的特征</h2>
<ul>
<li>
<p>整体完整性<br>
好的测试用例一定是一个完备的整体，是有效测试用例组成的集合，能够完全覆盖测试需求。</p>
</li>
<li>
<p>等价类划分的准确性<br>
指的是对于每个等价类都能保证只要其中一个输入测试通过，其他输入也一定测试通过。</p>
</li>
<li>
<p>等价类集合完备性<br>
需要保证所有可能的边界值和边界条件都已经正确识别。</p>
</li>
</ul>
<h2 id="最常用的三种测试用例设计方法"> 最常用的三种测试用例设计方法</h2>
<p>需求例子：</p>
<p>学生信息系统中有一个「考试成绩」的输入项，成绩的取值范围是 0~100 之间的整数，考试成绩及格的分数线是 60。</p>
<h3 id="等价类划分法"> 等价类划分法</h3>
<p>我们只要从每个等价类中任意选取一个值进行测试，就可以用少量具有代表性的测试输入取得较好的测试覆盖结果。</p>
<p>等价类划分方法的另一个关键点是要找出所有「无效等价类」。</p>
<h4 id="用例设计"> 用例设计</h4>
<table>
<thead>
<tr>
<th style="text-align:center">有效等价类</th>
<th style="text-align:center">无效等价类</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0~59 之间的任意整数</td>
<td style="text-align:center">小于 0 的负数</td>
</tr>
<tr>
<td style="text-align:center">59~100 之间的任意整数</td>
<td style="text-align:center">大于 100 的整数</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">0~100 之间的任何浮点数</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">其他任意非数字字符</td>
</tr>
</tbody>
</table>
<h3 id="边界值法"> 边界值法</h3>
<p>边界值分析是对等价类划分的补充，通常选取正好等于、刚刚大于或刚刚小于边界的值作为测试数据。</p>
<h4 id="用例设计-2"> 用例设计</h4>
<p>选取的边界值数据应该包括：-1，0，1，59，60，61，99，100，101。</p>
<h3 id="错误推断法"> 错误推断法</h3>
<p>错误推测方法是指基于对被测试软件系统设计的理解、过往经验以及个人直觉，推测出软件可能存在的缺陷，从而有针对性地设计测试用例的方法，强调的是<strong>对被测试软件的需求理解以及设计实现的细节把握</strong>，当然还有个人的能力。</p>
<p>例如 Web 界面的 GUI 功能测试：</p>
<ul>
<li>考虑浏览器在有缓存和没有缓存下的表现</li>
<li>Web Service 的 API 测试，需要考虑被测 API 所依赖的第三方 API 出错下的处理逻辑</li>
<li>对于代码级的单元测试，需要考虑被测函数的输入参数为空情况下的内部处理逻辑</li>
</ul>
<h3 id="如何设计出「好的」测试用例"> 如何设计出「好的」测试用例</h3>
<p>例子：面向终端用户的 GUI 测试</p>
<p><strong>最核心测试点</strong>：验证软件对需求的满足程度，要求测试工程师对被测软件的需求有深入的理解。</p>
<p><strong>如何做到</strong>：测试工程师在需求分析和设计阶段就开始介入，是理解和掌握软件的原始业务需求的最好时机。</p>
<p><strong>结果</strong>：设计针对性明确、从终端用户使用场景考虑的端到端的测试用例集，主要目的是验证各个业务需求是否被满足，基于黑盒的测试设计方法。</p>
<p><strong>重点</strong>：在具体的用例设计时，首先需要搞清楚每一个业务需求所对应的多个软件功能需求点，然后分析出每个软件功能需求点对应的多个测试需求点，最后再针对每个测试需求点设计测试用例。</p>
<p>辅助例子：【用户登录】的用例设计，理清概念。</p>
<ul>
<li>关系映射图：</li>
</ul>
<p><img src="./images/用户登录.png" alt="用户登录" /></p>
<ul>
<li>设计关键点
<ul>
<li>从软件功能需求出发，<strong>全面地、无遗漏</strong>地识别出测试需求是至关重要的，这将直接关系到用例的测试覆盖率，比如，如果你没有识别出用户登录功能的安全性测试需求，那么后续设计的测试用例就完全不会涉及安全性，最终造成重要测试漏洞。</li>
<li>对于识别出的每个测试需求点，需要<strong>综合运用等价类划分、边界值分析和错误推测方法</strong>来全面地设计测试用例。要综合运用这三种方法，并针对每个测试需求点的具体情况，进行灵活选择。</li>
</ul>
</li>
<li>以「登录」的功能性需求为例：
<ul>
<li>首先应该对「用户名」和「密码」这两个输入项分别进行等价类划分，列出对应的有效等价类和无效等价类，对于无效等价类的识别可以采用错误猜测法（比如，用户名包含特殊字符等），然后基于两者可能的组合，设计出第一批测试用例。</li>
<li>等价类划分完后，你需要补充「用户名」和「密码」这两个输入项的边界值的测试用例，比如用户名为空（NULL）、用户名长度刚刚大于允许长度等。</li>
</ul>
</li>
</ul>
<p><strong>用例设计其他经验</strong></p>
<ul>
<li>
<p>深入理解被测试软件的架构，发现系统边界以及系统集成上的潜在缺陷。<br>
不能把整个被测系统看作一个大黑盒，必须对内部的架构有清楚的认识，比如数据库连接方式、数据库的读写分离、消息中间件 Kafka 的配置、缓存系统的层级分布、第三方系统的集成等等。</p>
</li>
<li>
<p>深入理解被测软件的设计与实现细节，深入理解软件内部的处理逻辑。
单单根据测试需求点设计的用例，只能覆盖「表面」的一层，往往会覆盖不到内部的处理流程、分支处理，而没有覆盖到的部分就很可能出现缺陷遗漏，不要以开发代码的实现为依据设计测试用例。</p>
</li>
<li>
<p>需要引入需求覆盖率和代码覆盖率来衡量测试执行的完备性，并以此为依据来找出遗漏的测试点。</p>
</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-22T12:23:21.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">如何高效填写缺陷</title>
    <id>https://www.snowji.cn/test/theory/basic-essentials/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%A1%AB%E5%86%99%E7%BC%BA%E9%99%B7/</id>
    <link href="https://www.snowji.cn/test/theory/basic-essentials/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%A1%AB%E5%86%99%E7%BC%BA%E9%99%B7/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="如何高效填写缺陷"> 如何高效填写缺陷</h1>
<h2 id="缺陷组成"> 缺陷组成</h2>
<h3 id="缺陷标题"> 缺陷标题</h3>
<ul>
<li>对「什么问题」的描述不仅要做到<strong>清晰简洁</strong>，最关键是要足够具体，不能采用过于笼统的描述，描述问题的同时还必须清楚地表述问题出现的场景。<br>
例如：「用户不能正常登录」「搜索功能有问题」和「用户信息页面的地址栏位置不正确」等。</li>
<li>标题应该尽可能描述<strong>问题本质</strong>，而避免只停留在问题的表面。</li>
</ul>
<p><strong>例如</strong>：</p>
<ul>
<li>描述问题表现的缺陷：商品金额输入框，可以输入英文字母和其他字符。</li>
<li>描述问题表现的本质：商品金额输入框，没有对输入内容做校验。</li>
<li>缺陷标题不易过长，对缺陷更详细的描述应该放在「缺陷概述」里。</li>
</ul>
<h3 id="缺陷概述"> 缺陷概述</h3>
<p>缺陷概述通常会<strong>提供更多概括性的缺陷本质与现象的描述</strong>，是缺陷标题的细化。</p>
<p><strong>目的</strong>：<strong>清晰简洁地描述缺陷，使开发工程师能够聚焦缺陷的本质</strong>。</p>
<p>描述内容包含：</p>
<ul>
<li>列出同一类型的缺陷可能出现的所有场景</li>
<li>描述同样的问题是否会在之前的版本中重现</li>
</ul>
<h3 id="缺陷影响"> 缺陷影响</h3>
<p>缺陷引起的问题对用户或者对业务的影响范围以及严重程度</p>
<p><strong>前提</strong>：必须对软件的应用场景以及需求有深入的理解</p>
<p><strong>作用</strong>：决定了缺陷的优先级和严重程度</p>
<ul>
<li>开发经理会以此为依据来决定修复该缺陷的优先级</li>
<li>产品经理会以此为依据来衡量缺陷的严重程度，并决定是否要等该缺陷被修复后才能发布产品</li>
</ul>
<h3 id="环境配置"> 环境配置</h3>
<p>描述测试环境的配置细节，为缺陷的重现提供必要的环境信息</p>
<p>例如：</p>
<ul>
<li>操作系统的类型与版本</li>
<li>被测软件版本</li>
<li>浏览器的种类和版本</li>
<li>被测软件的配置信息</li>
</ul>
<p><strong>注意</strong>：环境配置的内容通常是<strong>按需描述</strong>，也就是说通常只描述那些重现缺陷的环境敏感信息。</p>
<h3 id="前置条件"> 前置条件</h3>
<p>指测试步骤开始前系统应该处在的状态，其目的是减少缺陷重现步骤的描述。</p>
<p>例如：某个业务操作需要先完成用户登录。</p>
<p>前置条件：用户已完成登录。</p>
<h3 id="缺陷重现步骤"> 缺陷重现步骤</h3>
<p>缺陷重现步骤是整个<strong>缺陷报告中最核心的内容</strong></p>
<p><strong>目的</strong>：用简洁的语言向开发工程师展示缺陷重现的具体操作步骤</p>
<p><strong>注意</strong>：操作步骤通常是从用户角度出发来描述的，每个步骤都应该是可操作并且是连贯的，所以往往会采用步骤列表的表现形式</p>
<p><strong>避免的常见问题</strong>：</p>
<ul>
<li>笼统的描述，缺乏可操作的具体步骤</li>
<li>出现与缺陷重现不相关的步骤</li>
<li>缺乏对测试数据的相关描述</li>
</ul>
<h3 id="期望结果和实际结果"> 期望结果和实际结果</h3>
<p>期望结果：需要说明<strong>应该发生什么</strong>，而不是<strong>什么不应该发生</strong>。</p>
<p>实际结果：应该说明<strong>发生了什么</strong>，而不是<strong>什么没有发生</strong>。</p>
<h3 id="优先级和严重程度"> 优先级和严重程度</h3>
<p><strong>差异</strong>：</p>
<p>严重程度：指因缺陷引起的故障对软件产品的影响程度，<strong>是缺陷本身的属性，通常确定后就不再变化</strong>。</p>
<p>优先级：指缺陷必须被修复的紧急程度，<strong>是缺陷的工程属性，会随着项目进度、解决缺陷的成本等因素而变动</strong>。</p>
<p><strong>两者之间关系</strong>：</p>
<ol>
<li>缺陷越严重，优先级就越高；</li>
<li>缺陷影响的范围越大，优先级也会越高；</li>
<li>有些缺陷虽然从用户影响角度来说不算严重，但是会妨碍测试或者是自动化测试的执行，这类缺陷属于典型的严重程度低，但是优先级高；</li>
<li>有些缺陷虽然严重程度比较高，但是考虑到修复成本以及技术难度，也会出现优先级较低的情况。</li>
</ol>
<h3 id="变通方案"> 变通方案</h3>
<p>提供一种临时绕开当前缺陷而不影响产品功能的方式。</p>
<p><strong>实施前提</strong>：</p>
<ul>
<li>根原因分析
<ul>
<li>在发现缺陷的同时，定位出问题的根本原因，清楚地描述缺陷产生的原因。</li>
<li>变通方案的有无以及实施的难易程度，是<strong>决定缺陷优先级和严重程度的重要依据</strong>。</li>
</ul>
</li>
</ul>
<p><strong>对优先级的影响</strong>：</p>
<ul>
<li>如果某个严重的缺陷没有任何可行的变通方案，不管修复缺陷代价有多大，优先级一定会是最高的。</li>
<li>如果缺陷存在比较简单的变通方案，那么优先级就不一定会是最高的了。</li>
</ul>
<h3 id="附件"> 附件</h3>
<p>为缺陷的存在提供必要的证据支持。</p>
<p><strong>常见的附件</strong>：</p>
<ul>
<li>界面截图</li>
<li>测试用例日志</li>
<li>服务器端日志等</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-22T12:17:00.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">用户登录</title>
    <id>https://www.snowji.cn/test/theory/basic-essentials/%E5%BC%80%E7%AF%87%E4%B9%8B%E5%85%B8%E5%9E%8B%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95/</id>
    <link href="https://www.snowji.cn/test/theory/basic-essentials/%E5%BC%80%E7%AF%87%E4%B9%8B%E5%85%B8%E5%9E%8B%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95/"/>
    <updated>2022-10-30T08:58:48.000Z</updated>
    <content type="html"><![CDATA[<h1 id="用户登录"> 用户登录</h1>
<h2 id="最常用的黑盒测试方法"> 最常用的黑盒测试方法</h2>
<ul>
<li>
<p>等价类划分</p>
<ul>
<li>将可能的输入数据分成若干子集</li>
<li>输入的数据对于揭露程序中潜在错误都具有等同效果就构成了无效等价类</li>
<li>输入的数据是有效的则构成有效等价类</li>
<li>后续从每个等价类中任意选取一个值进行测试，就可以用少量具有代表性的测试输入取得较好的测试覆盖结果</li>
<li>边界值</li>
<li>选取输入、输出的边界值进行测试</li>
<li>选取正好等于、刚刚大于或刚刚小于边界的值作为测试数据</li>
</ul>
</li>
</ul>
<h2 id="测试用例设计"> 测试用例设计</h2>
<h3 id="设计思路"> 设计思路</h3>
<p>一般从以下两个方面进行考虑：</p>
<ul>
<li>显示功能性需求<br>
指的是软件本身需要实现的具体功能，如「登录成功或失败」、「非注册用户无法登录」等。</li>
<li>非功能性需求<br>
主要涉及<strong>安全性</strong>、<strong>性能、兼容性</strong>三大方面，这些往往是决定软件质量的关键因素。</li>
</ul>
<h3 id="登录用例设计"> 登录用例设计</h3>
<p><img src="./images/login.png" alt="login" /></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-22T11:53:28.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">互联网产品如何设计测试策略</title>
    <id>https://www.snowji.cn/test/theory/basic-essentials/%E4%BA%92%E8%81%94%E7%BD%91%E4%BA%A7%E5%93%81%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%B5%8B%E8%AF%95%E7%AD%96%E7%95%A5/</id>
    <link href="https://www.snowji.cn/test/theory/basic-essentials/%E4%BA%92%E8%81%94%E7%BD%91%E4%BA%A7%E5%93%81%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%B5%8B%E8%AF%95%E7%AD%96%E7%95%A5/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="互联网产品如何设计测试策略"> 互联网产品如何设计测试策略</h1>
<h2 id="互联网产品"> 互联网产品</h2>
<p><strong>特点</strong>：快</p>
<ul>
<li>互联网产品的上线周期通常是以「天」甚至是以「小时」为单位。</li>
<li>发布流程通常包含了代码静态扫描、单元测试、编译、打包、上传、下载、部署和测试的全流程。</li>
</ul>
<p><strong>通常情况下，互联网产品要求全回归测试的执行时间不能超过 4 小时</strong>。</p>
<p>如何在保证测试质量和测试覆盖率的前提下，有效缩短测试执行时间就是本文的主题。</p>
<h2 id="传统软件产品的测试策略设计"> 传统软件产品的测试策略设计</h2>
<p><strong>常用的模型</strong>：金字塔模型</p>
<p><img src="./images/传统测试策略.jpg" alt="传统测试策略" /></p>
<h3 id="单元测试-重要"> 单元测试（重要）</h3>
<ul>
<li>处于金字塔最底部，属于白盒测试范畴，通常由开发工程师完成</li>
<li>能尽早发现缺陷，降低修复成本</li>
<li>传统软件产品，生命周期都比较长，通常会有多个版本持续发布，为了在后期的版本升级过程中能够尽早发现并快速定位问题，每次 build 过程中都会多次反复执行单元测试</li>
</ul>
<h3 id="api-测试"> API 测试</h3>
<p>处于金字塔中间，<strong>主要针对的是各模块暴露的接口，通常采用灰盒测试方法</strong></p>
<p><strong>灰盒测试</strong>：</p>
<p>概述：介于<strong>白盒</strong>和<strong>黑盒</strong>之间的一种测试技术</p>
<p>核心思想：利用测试执行的代码覆盖率来指导测试用例的设计</p>
<p>例如 API 接口测试 ：</p>
<ul>
<li>以黑盒方式设计如何调用 API 的测试用例</li>
<li>测试执行过程中统计代码覆盖率，然后根据代码覆盖率情况来补充更多、更有针对性的测试用例</li>
</ul>
<h3 id="gui-测试"> GUI 测试</h3>
<p>处于金字塔最上层，模拟用户在软件界面上的各种操作，并验证这些操作对应的结果是否正确</p>
<p><strong>优点</strong>：能够实际模拟真实用户的行为，直接验证软件的商业价值</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>执行的代价比较大，就算是采用 GUI 自动化测试技术，用例的维护和执行代价依然很大</li>
<li>GUI 测试的稳定性问题，是长期以来阻碍 GUI 测试发展的重要原因</li>
</ul>
<h2 id="互联网产品的测试策略设计"> 互联网产品的测试策略设计</h2>
<h3 id="gui-测试-轻量级测试"> GUI 测试（轻量级测试）</h3>
<p><strong>互联网产品迭代周期对 GUI 测试的影响</strong>：</p>
<ul>
<li>给开发 GUI 自动化测试用例的时间非常有限</li>
<li>客户端界面的频繁变化 , 导致 GUI 自动化测试的效率会非常低</li>
<li>GUI 测试是轻量级的, 不允许去执行大量的用例</li>
</ul>
<p><strong>测试策略</strong>：以<strong>手工为主，自动化为辅</strong></p>
<ul>
<li>手工测试：利用探索性测试思想，针对新开发或者新修改的界面功能进行测试</li>
<li>自动化：主要放在相对稳定且核心业务的基本功能验证, <strong>只覆盖最核心且直接影响主营业务流程的 E2E 场景</strong></li>
</ul>
<h3 id="api-测试-重点测试"> API 测试（重点测试）</h3>
<p>菱形的测试策略 ：<strong>重量级 API 测试，轻量级 GUI 测试，轻量级单元测试</strong></p>
<p><img src="./images/菱形测试策略.jpg" alt="菱形测试策略" /></p>
<p><strong>重量级 API 测试原因</strong>：<strong>API 测试可以实现良好的投入产出比</strong></p>
<ul>
<li>API 测试用例的开发与调试效率比 GUI 测试要高得多, 而且测试用例的代码实现比较规范</li>
<li>API 测试用例的执行稳定性远远高于 GUI 测试</li>
<li>单个 API 测试用例的执行时间往往要比 GUI 测试短很多</li>
<li>很多互联网产品采用了微服务架构，而对微服务的测试，本质上就是对不同的 Web Service 的测试，也就是 API 测试</li>
<li>API 接口的改动一般比较少，在调用方式没有改变的情况下，测试用例不需要做大的改动，用例的可重用性很高, 可以保证较高的投入产出比</li>
</ul>
<h3 id="单元测试-轻量级测试"> 单元测试（轻量级测试）</h3>
<p><strong>轻量级原因</strong>：互联网产品的<strong>快</strong></p>
<ul>
<li>快速实现功能<br>
互联网产品追求的是最快速的功能实现并上线，基本不会有时间去做全面的单元测试</li>
<li>快速寻求用户反馈</li>
<li>快速试错</li>
<li>快速迭代更新</li>
</ul>
<p>频繁的迭代会让单元测试处于不断重写的状态。</p>
<p><strong>采用「分而治之」测试策略思想</strong>：</p>
<p>全面单元测试只会应用在那些<strong>相对稳定和最核心的模块和服务</strong>上，而应用层或者上层业务服务很少会大规模开展单元测试。</p>
<ul>
<li>后端基础服务和一些公共应用服务相对稳定，对于系统全局来说是「牵一发而动全身」，所以后端服务很有必要开展全面的单元测试。</li>
<li>对于一些核心算法和关键应用，比如银行网关接口，第三方支付集成接口等，也要做比较全面的单元测试。</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-22T12:06:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">测试工程师核心竞争力</title>
    <id>https://www.snowji.cn/test/theory/basic-essentials/%E6%B5%8B%E8%AF%95%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%A0%B8%E5%BF%83%E7%AB%9E%E4%BA%89%E5%8A%9B/</id>
    <link href="https://www.snowji.cn/test/theory/basic-essentials/%E6%B5%8B%E8%AF%95%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%A0%B8%E5%BF%83%E7%AB%9E%E4%BA%89%E5%8A%9B/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="测试工程师核心竞争力"> 测试工程师核心竞争力</h1>
<h2 id="竞争力"> 竞争力</h2>
<h3 id="作为测试人员-必须要深入理解业务-但是业务知识不能等同于测试能力"> 作为测试人员，必须要深入理解业务，但是业务知识不能等同于测试能力</h3>
<p>对测试技术本身以及产品技术实现不能缺乏系统的思考和理解，所体现的价值不仅仅能够体现在这个特定的产品业务上，而一旦离开了这个业务领域，很难快速适应其他业务领域测试</p>
<h3 id="测开的核心是-测试-开发的目的是更好的服务测试"> 测开的核心是‘测试’，开发的目的是更好的服务测试</h3>
<p>在此基础上设计、开发帮助测试人员提高效率并解决实际问题的工具</p>
<h2 id="业务测试工程师的核心竞争力"> 业务测试工程师的核心竞争力</h2>
<h3 id="测试策略设计能力-最核心竞争力"> 测试策略设计能力, 最<strong>核心竞争力</strong></h3>
<p>对于各种不同的被测软件，能够<strong>快速准确地理解需求，并在有限的时间和资源下，明确测试重点以及最适合的测试方法的能力</strong></p>
<p><strong>明确测试中的关键问题</strong>：</p>
<ul>
<li>测试要具体执行到什么程度</li>
<li>测试需要借助于什么工具</li>
<li>如何运用自动化测试以及自动化测试框架，以及如何选型</li>
<li>测试人员资源如何合理分配</li>
<li>测试进度如何安排</li>
<li>测试风险如何应对</li>
</ul>
<h3 id="测试用例设计能力"> 测试用例设计能力</h3>
<p><strong>概述</strong>：无论对于什么类型的测试，都能设计出<strong>高效地发现缺陷，保证产品质量的优秀测试用例</strong></p>
<ul>
<li>
<p>不仅需要深入理解被测软件的业务需求和目标用户的使用习惯，还要熟悉软件的具体设计和运行环境，包括技术架构、缓存机制、中间件技术、第三方服务集成等等</p>
</li>
<li>
<p>不仅仅局限于熟悉业务领域的测试用例设计，而是能够融会贯通，熟练地把系统性的测试设计方法和具体业务有机结合，对任何被测软件都可以输出出色的测试用例</p>
</li>
<li>
<p>要想提高测试用例设计能力，<strong>平时就要多积累，对常见的缺陷模式、典型的错误类型以及遇到过的缺陷，要不断地总结、归纳，才能逐渐形成体系化的用例设计思维</strong></p>
</li>
</ul>
<h3 id="快速学习能力"> 快速学习能力</h3>
<p><strong>两个层面</strong>：</p>
<ul>
<li>对不同业务需求和功能的快速学习与理解能力</li>
<li>对于测试新技术和新方法的学习与应用能力</li>
</ul>
<p>学习新内容时，要做到<strong>理解其原理</strong>，而不是只停留在表面的、简单的操作和使用，长期保持这种学习状态，可以在很大程度上提高逻辑思维和理解能力</p>
<h3 id="探索性测试思维"> 探索性测试思维</h3>
<p><strong>概述</strong>：探索性测试是指，测试工程师在执行测试的过程中不断学习被测系统，同时结合基于自己经验的错误猜测和逻辑推理，整理和分析出更多的有针对性的测试关注点</p>
<p><strong>本质</strong>：是“测试用例设计能力”和“快速学习能力”有机结合的必然结果</p>
<p><strong>敏捷测试方法</strong>：优秀的探索性测试思维可以实现低成本的“精准测试”，精准测试最通俗的理解可以概括为针对开发代码的变更，目标明确并且有针对性地对变更点以及变更关联点做测试</p>
<h3 id="缺陷分析能力"> 缺陷分析能力</h3>
<p><strong>包含依次递进的三个层面</strong>：</p>
<ul>
<li>对于已经发现的缺陷，结合发生错误的上下文以及后台日志，可以预测或者定位缺陷的发生原因，甚至可以明确指出具体出错的代码行，由此可以大幅缩短缺陷的修复周期，并提高开发工程师对于测试工程师的认可以及信任度</li>
<li>根据已经发现的缺陷，结合探索性测试思维，推断同类缺陷存在的可能性，并由此找出所有相关的潜在缺陷</li>
<li>可以对一段时间内所发生的缺陷类型和趋势进行合理分析，由点到面预估整体质量的健康状态，并能够对高频缺陷类型提供系统性的发现和预防措施，并以此来调整后续的测试策略</li>
</ul>
<h3 id="自动化测试技术"> 自动化测试技术</h3>
<p><strong>两个方面</strong>：</p>
<ul>
<li>自动化测试技术本身不绑定被测对象</li>
</ul>
<p>比如：你掌握了GUI的自动化测试技术，那么就可以基于这个技术去做任何GUI系统的界面功能测试</p>
<ul>
<li>自动化测试技术需要测试工程师具备一定的写代码的能力</li>
</ul>
<p><strong>核心价值</strong>：是“测试”本身，“自动化”仅仅是手段，不要本末倒置，把大量的精力放在“自动化”上，一味追求自动化而把本质的“测试”弱化了</p>
<h3 id="良好的沟通能力"> 良好的沟通能力</h3>
<p><strong>两方面</strong>：</p>
<ul>
<li>对接产品经理和项目经理，以确保需求的正确实现和项目整体质量的达标</li>
<li>和开发人员不断地沟通、协调，确保缺陷的及时修复与验证</li>
</ul>
<h2 id="测试开发工程师的核心竞争力"> 测试开发工程师的核心竞争力</h2>
<h3 id="测试系统需求分析能力"> 测试系统需求分析能力</h3>
<p>除了代码开发能力，测试开发工程师更要具备测试系统需求分析的能力</p>
<p>能够站在测试架构师的高度，识别出测试基础架构的需求和提高效率的应用场景</p>
<h3 id="更宽广的知识体系"> 更宽广的知识体系</h3>
<p>不仅需要和传统的测试开发工程师打交道，还要和 CI/CD、和运维工程师们有紧密的联系</p>
<p>了解更高级别的测试架构部署和生产架构部署、必须对开发采用的各种技术非常熟悉</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-22T11:57:54.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">深入浅出静态方法</title>
    <id>https://www.snowji.cn/test/theory/basic-essentials/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/</id>
    <link href="https://www.snowji.cn/test/theory/basic-essentials/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="深入浅出静态方法"> 深入浅出静态方法</h1>
<h2 id="人工静态方法"> 人工静态方法</h2>
<p><strong>手段</strong>：代码走查、结对编程，同行评审</p>
<ul>
<li>代码走查
<ul>
<li>是由开发人员检查自己的代码，尽可能多地发现各类潜在错误</li>
<li>存在问题：个人能力的差异，以及开发人员的“思维惯性”，很多错误并不能在这个阶段被及时发现</li>
</ul>
</li>
<li>结对编程
<ul>
<li>敏捷软件开发的方法，一般是由两个开发人员结成对子在一台计算机上共同完成开发任务</li>
<li>一个开发人员实现代码，通过被称为“驾驶员”；另一个开发人员审查输入的每一行代码，通常被称为“观察员”</li>
<li><strong>应用场景</strong>：用于一些非常关键和底层算法的代码实现</li>
<li><strong>不足</strong>：对人员的利用率比较低</li>
</ul>
</li>
<li>同行评审（ <strong>使用最普遍</strong> ）
<ul>
<li>把代码递交到代码仓库，或者合并代码分支（Branch）到主干（Master）前，需要同技术级别或者更高技术级别的一个或多个同事对代码进行评审，只有通过所有评审后，代码才会被真正递交</li>
<li><strong>具体使用</strong>：项目使用 GitHub 管理代码，并采用 GitFlow 的分支管理策略，在递交代码或者分支合并时，需要先递交 Pull Request（PR），只有这个 PR 经过了所有评审者的审核，才能被合并</li>
</ul>
</li>
</ul>
<h2 id="自然静态方法"> 自然静态方法</h2>
<p><strong>特点</strong>：</p>
<ul>
<li>相比于编译器，可以做到对代码更加严格、个性化的检查</li>
<li>不真正检测代码的逻辑功能，只是站在代码本身的视角，基于规则，尽可能多地去发现代码错误</li>
<li>由于静态分析算法并不实际执行代码，是基于代码的词法分析、语法分析、控制流分析等技术，由于分析技术的局限性以及代码写法的多样性，会存在一定的误报率</li>
</ul>
<p>基于这些特点，自动静态方法能够以极低的成本发现以下问题：</p>
<ul>
<li>使用未初始化的变量</li>
<li>变量在使用前未定义</li>
<li>变量声明了但未使用</li>
<li>变量类型不匹配</li>
<li>部分的内存泄漏问题</li>
<li>空指针引用</li>
<li>缓冲区溢出</li>
<li>数组越界</li>
<li>不可达的僵尸代码</li>
<li>过高的代码复杂度</li>
<li>死循环</li>
<li>大量的重复代码块</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-22T12:32:16.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">测试覆盖率</title>
    <id>https://www.snowji.cn/test/theory/basic-essentials/%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87/</id>
    <link href="https://www.snowji.cn/test/theory/basic-essentials/%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="测试覆盖率"> 测试覆盖率</h1>
<p>测试覆盖率通常被用来衡量测试的充分性和完整性，主要分为两大类：</p>
<ul>
<li>面向项目的需求覆盖率</li>
<li>是更偏向技术的代码覆盖率</li>
</ul>
<h2 id="需求覆盖率"> 需求覆盖率</h2>
<p><strong>概念</strong>：是指测试对需求的覆盖程度</p>
<p><strong>如何做</strong>：将每一条分解后的软件需求和对应的测试建立<strong>一对多</strong>的映射关系，保证测试可以覆盖每个需求</p>
<p><strong>统计方法</strong>：传统瀑布模型，自上而下地制定计划、分析需求、设计软件、编写代码、测试和运维等</p>
<p><strong>缺点</strong>：传统瀑布模型在流程上是重量级的，已经很难适应当今互联网时代下的敏捷开发实践</p>
<p><strong>结论</strong>：互联网测试项目中很少直接基于需求来衡量测试覆盖率，而是将软件需求转换成测试需求，然后基于测试需求再来设计测试点，测试覆盖率，通常默认指代码覆盖率，而不是需求覆盖率</p>
<h3 id="代码覆盖率"> 代码覆盖率</h3>
<p><strong>定义</strong>：至少被执行了一次<strong>条目数</strong>占整个条目数的百分比</p>
<p><strong>条目数</strong>：</p>
<ul>
<li>如果是语句：对应的就是代码行覆盖率</li>
<li>如果是函数：对应的就是函数覆盖率</li>
<li>如果是路径：对应的就是路径覆盖率</li>
</ul>
<p><strong>3 种最常用代码覆盖率指标</strong>：</p>
<ul>
<li>
<p>行覆盖率（语句覆盖率）<br>
指已经被执行到的语句占总可执行语句（不包含类似C++的头文件声明、代码注释、空行等等）的百分比。</p>
</li>
<li>
<p>判定覆盖（分支覆盖）<br>
代码中每个判断的取真分支和取假分支是否各被覆盖至少各一次，比如，对于 <code>if(a&gt;0 &amp;&amp; b&gt;0)</code>，就要求覆盖 <code>a&gt;0 &amp;&amp; b&gt;0</code> 为 TURE 和 FALSE 各一次。</p>
</li>
<li>
<p>条件覆盖<br>
判定中的每个条件的可能取值至少满足一次，度量判定中的每个条件的结果 TRUE 和 FALSE 是否都被测试到了。比如，对于 <code>if(a&gt;0 &amp;&amp; b&gt;0)</code>，就要求 <code>a&gt;0</code> 取 TRUE 和 FALSE 各一次，同时要求 <code>b&gt;0</code> 取 TRUE 和 FALSE 各一次。</p>
</li>
</ul>
<p><strong>目的</strong>：找出潜在的遗漏测试用例，并有针对性的进行补充，同时还可以识别出代码中那些由于需求变更等原因造成的不可达的废弃代码。</p>
<p><strong>局限性</strong>：</p>
<p>所设计的测试用例已经达到 100% 的代码覆盖率，软件产品的质量也做不到万无一失。</p>
<p>其根本原因在于代码覆盖率的计算是基于现有代码的，并不能发现那些「未考虑某些输入」以及「未处理某些情况」形成的缺陷。</p>
<p>极端例子：一个被测函数里面只有一行代码，只要这个函数被调用过了，那么衡量这一行代码质量的所有覆盖率指标都会是 100%，但是这个函数是否真正实现了应该需要实现的功能？</p>
<p><strong>结论</strong>：</p>
<ul>
<li>代码覆盖率反映的仅仅是已有代码的哪些逻辑被执行过了，哪些逻辑还没有被执行过，对于那些压根还没有代码实现的部分，基于代码覆盖率的统计指标就无能为力了</li>
<li>高的代码覆盖率不一定能保证软件的质量，但是低的代码覆盖率一定不能能保证软件的质量</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-22T11:11:53.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">移动应用测试方法与思路</title>
    <id>https://www.snowji.cn/test/theory/basic-essentials/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E5%8F%8A%E6%80%9D%E8%B7%AF/</id>
    <link href="https://www.snowji.cn/test/theory/basic-essentials/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E5%8F%8A%E6%80%9D%E8%B7%AF/"/>
    <updated>2022-10-30T08:58:48.000Z</updated>
    <content type="html"><![CDATA[<h1 id="移动应用测试方法与思路"> 移动应用测试方法与思路</h1>
<h2 id="三类移动应用的特点"> 三类移动应用的特点</h2>
<p>常见三类移动端应用：</p>
<ul>
<li>Web App</li>
<li>Native App</li>
<li>Hybrid App</li>
</ul>
<h3 id="web-app"> Web App：</h3>
<p>概念：<strong>移动端的Web浏览器</strong></p>
<p><strong>主要技术</strong>：</p>
<ul>
<li>
<p>HTML、JavaScript、CSS 等 Web 技术栈</p>
</li>
<li>
<p>Web App 所访问的页面内容都是放在服务器端的，本质上就是 Web 网页，所以是跨平台的</p>
</li>
</ul>
<h3 id="native-app"> Native App</h3>
<p>指的是移动端的原生应用，Android 是 apk，iOS 是 ipa</p>
<p>Native App 可以提供比较好的用户体验以及性能，而且可以方便地操作手机本地资源</p>
<h3 id="hybrid-app"> Hybrid App</h3>
<p>在原生移动应用中嵌入了 Webview，然后通过该 Webview 来访问网页，利用了 Web App 和 Native App 的优点</p>
<p><strong>优点</strong>：</p>
<ul>
<li>Hybrid App 维护更新简单</li>
<li>用户体验优异</li>
<li>较好的跨平台特性</li>
</ul>
<h2 id="三类不同移动应用的测试方法"> 三类不同移动应用的测试方法</h2>
<h3 id="web-app-2"> Web App</h3>
<p><strong>本质</strong>：Web 浏览器的测试 ，所有的 GUI 测试都适用</p>
<h3 id="native-app-2"> Native App</h3>
<p>数据驱动、页面对象以及业务流程封装的思想依旧适用，可以把这些方法应用到测试用例设计中</p>
<h3 id="hybrid-app-2"> Hybrid App</h3>
<ul>
<li>对 Native Container 的测试，可能需要用到 XCUITest 或者 UiAutomator2 这样的原生测试框架</li>
<li>对 Container中HTML5 的测试，基本和传统的网页测试没区别，原本基于 GUI 的测试思想和方法都能适用</li>
</ul>
<h2 id="移动应用专项测试的思路和方法"> 移动应用专项测试的思路和方法</h2>
<p>6 个主要专项：</p>
<ul>
<li>交叉事件测试</li>
<li>兼容性测试</li>
<li>流量测试</li>
<li>电量测试</li>
<li>弱网络测试</li>
<li>边界测试</li>
</ul>
<h3 id="交叉事件-中断事件"> 交叉事件（中断事件）</h3>
<p><strong>概述</strong>：App 执行过程中，有其他事件或者应用中断当前应用执行的测试</p>
<p>比如：App 在前台运行过程中，突然有电话打进来，或者收到短信</p>
<p><strong>测试方式</strong>：手工测试 ，<strong>且是在真机上进行，不使用模拟器</strong></p>
<p><strong>覆盖的一些主要场景</strong>：</p>
<ul>
<li>多个 App 同时在后台运行，并交替切换至前台是否影响正常功能</li>
<li>要求相同系统资源的多个 App 前后台交替切换是否影响正常功能<br>
比如两个 App 都需要播放音乐，那么两者在交替切换的过程中，播放音乐功能是否正常；</li>
<li>App 运行时接听电话</li>
<li>App 运行时接收信息</li>
<li>App 运行时提示系统升级</li>
<li>App 运行时发生系统闹钟事件</li>
<li>App 运行时进入低电量模式</li>
<li>App 运行时第三方安全软件弹出告警</li>
<li>App 运行时发生网络切换<br>
比如由 Wifi 切换到移动 4G 网络，或者从 4G 网络切换到 3G 网络等</li>
</ul>
<h3 id="兼容性测试"> 兼容性测试</h3>
<p>App 在各种终端设备、各种操作系统版本、各种屏幕分辨率、各种网络环境下，功能的正确性</p>
<p><strong>覆盖的一些测试场景</strong>：</p>
<ul>
<li>不同操作系统的兼容性，包括主流的 Andoird 和 iOS 版本</li>
<li>主流的设备分辨率下的兼容性</li>
<li>主流移动终端机型的兼容性</li>
<li>同一操作系统中，不同语言设置时的兼容性</li>
<li>不同网络连接下的兼容性，比如 Wifi、GPRS、EDGE、CDMA200 等</li>
<li>在单一设备上，与主流热门 App 的兼容性，比如微信、抖音、淘宝等</li>
</ul>
<p><strong>云测平台</strong>： 国外最知名的是 SauceLab，国内主流的是 Testin</p>
<h3 id="流量测试"> 流量测试</h3>
<p><strong>包含内容</strong>：</p>
<ul>
<li>App 执行业务操作引起的流量</li>
<li>App 在后台运行时的消耗流量</li>
<li>App 安装完成后首次启动耗费的流量</li>
<li>App 安装包本身的大小</li>
<li>App 内购买或者升级需要的流量</li>
</ul>
<p><strong>目的</strong>： 想办法减少 App 产生的流量</p>
<p><strong>测试方法</strong>：</p>
<ul>
<li><strong>借助于 Android 和 iOS 自带的工具进行流量统计</strong></li>
<li><strong>可利用 tcpdump、Wireshark 和 fiddler 等网络分析工具</strong></li>
</ul>
<p><strong>测试工具</strong>：</p>
<ul>
<li>
<p>Android<br>
网络流量信息通常存储在 <code>/proc/net/dev</code> 目录下，也可以直接利用 ADB 工具获取实时的流量信息
性能监控小工具 Emmagee，实时显示 App 运行过程中 CPU、内存和流量等信息</p>
</li>
<li>
<p>iOS<br>
使用 Xcode 自带的性能分析工具集中的 Network Activity</p>
</li>
</ul>
<p><strong>减少 App 消耗的流量常用方法</strong>：</p>
<ul>
<li>启用数据压缩，尤其是图片</li>
<li>使用优化的数据格式，比如同样信息量的 JSON 文件就要比 XML 文件小</li>
<li>遇到既需要加密又需要压缩的场景，一定是先压缩再加密</li>
<li>减少单次 GUI 操作触发的后台调用数量</li>
<li>每次回传数据尽可能只包括必要的数据</li>
<li>启用客户端的缓存机制</li>
</ul>
<h3 id="耗电量测试"> 耗电量测试</h3>
<p><strong>三个方面考量</strong>：</p>
<ul>
<li>App 运行但没有执行业务操作时的耗电量</li>
<li>App 运行且密集执行业务操作时的耗电量</li>
<li>App 后台运行的耗电量</li>
</ul>
<p><strong>测试方法</strong>：</p>
<ul>
<li>Android 通过 adb 命令 <code>adb shell dumpsys battery</code> 来获取应用的耗电量信息</li>
<li>iOS 通过 Apple 的官方工具 Sysdiagnose 来收集耗电量信息，通过 Instrument 工具链中的 Energy Diagnostics 进行耗电量分析</li>
</ul>
<h3 id="弱网络测试"> 弱网络测试</h3>
<p><strong>概述</strong>：移动应用的网络环境比较多样，而且经常出现需要在不同网络之间切换的场景</p>
<p><strong>目的</strong>：保证在复杂网络环境下的质量</p>
<p><strong>做法</strong>：模拟这些网络环境</p>
<p><strong>测试工具</strong>：Facebook 的 Augmented Traffic Control（ATC），能够在移动终端设备上通过 Web 界面随时切换不同的网络环境，同时多个移动终端设备可以连接到同一个 Wifi，各自模拟不同的网络环境，相互之间不会有任何影响</p>
<h3 id="边界测试"> 边界测试</h3>
<p><strong>概述</strong>：App 在一些临界状态下的行为功能的验证测试</p>
<p><strong>基本思路</strong>：找出各种潜在的临界场景，并对每一类临界场景做验证和测试</p>
<p><strong>主要场景</strong>：</p>
<ul>
<li>系统内存占用大于 90% 的场景</li>
<li>系统存储占用大于 95% 的场景</li>
<li>飞行模式来回切换的场景</li>
<li>App 不具有某些系统访问权限的场景，比如，App 由于隐私设置不能访问相册或者通讯录等</li>
<li>长时间使用 App，系统资源是否有异常，比如内存泄漏、过多的链接数等</li>
<li>出现 ANR 的场景</li>
<li>操作系统时间早于或者晚于标准时间的场景</li>
<li>时区切换的场景</li>
</ul>
<p>(完)</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-22T12:40:24.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">微服务下的 API 测试</title>
    <id>https://www.snowji.cn/test/theory/basic-essentials/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8B%E7%9A%84API%E6%B5%8B%E8%AF%95/</id>
    <link href="https://www.snowji.cn/test/theory/basic-essentials/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8B%E7%9A%84API%E6%B5%8B%E8%AF%95/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="微服务下的-api-测试"> 微服务下的 API 测试</h1>
<h2 id="微服务架构"> 微服务架构</h2>
<h3 id="单体结构"> 单体结构</h3>
<p><strong>概述</strong>：将所有的业务场景的表示层、业务逻辑层和数据访问层放在同一个工程中，最终经过编译、打包，并部署在服务器上</p>
<p><strong>优点</strong>：发布简单、方便调试、架构复杂性低等</p>
<p><strong>应用场景</strong>：传统企业级应用软件</p>
<p><strong>单体架构存在的问题</strong>：</p>
<ul>
<li><strong>灵活性差</strong><br>
无论是多小的修改，也要打包发布整个应用，每次编译打包都要花费很长时间</li>
<li><strong>可扩展性差</strong><br>
高并发场景下，无法以模块为单位灵活扩展容量，不利于应用的横向扩展</li>
<li><strong>稳定性差</strong><br>
缺乏容错机制，应用中任何一个模块有问题时，都可能会造成应用整体的不可用</li>
<li><strong>可维护性差</strong><br>
随着业务复杂性的提升，代码的复杂性也直线上升，业务规模比较庞大时，整体项目的可维护性会大打折扣</li>
</ul>
<h3 id="微服务架构-2"> 微服务架构</h3>
<p><strong>产生原因</strong>：随着互联网产品的普及，应用所承载的流量越来越庞大，单体架构的问题被逐渐暴露并不断放大</p>
<p><strong>概述</strong>：大型复杂软件系统不再由一个单体组成，而是由一系列相互独立的微服务组成，开发和部署都没有依赖</p>
<p><strong>特点</strong>：</p>
<ul>
<li>每个服务运行在其独立的进程中，开发采用的技术栈也是独立的</li>
<li>服务间采用轻量级通信机制进行沟通，通常是基于 HTTP 协议的 RESTful API</li>
<li>每个服务都围绕着具体的业务进行构建，并且能够被独立开发、独立部署、独立发布</li>
<li>对运维提出了非常高的要求，促进了 CI/CD 的发展与落地</li>
</ul>
<p><strong>存在的测试挑战</strong>：</p>
<p>一个应用是由很多相互独立的微服务组成，每个微服务都会对外暴露接口，一个微服务通常还会去调用其他微服务 ，测试挑战主要来自两方面：</p>
<ul>
<li>过于庞大的测试用例数量</li>
</ul>
<p><strong>传统 API 测试的策略</strong>：</p>
<ul>
<li>根据被测 API 输入参数的各种组合调用 API，并验证相关结果的正确性；</li>
<li>衡量上述测试过程的代码覆盖率；</li>
<li>根据代码覆盖率进一步找出遗漏的测试用例；</li>
<li>以代码覆盖率达标作为 API 测试成功完成的标志</li>
</ul>
<p><strong>举个例子</strong>：</p>
<p>采用单体架构开发了一个系统，这个系统对外提供了 3 个 Restful API 接口</p>
<p>设计测试策略：</p>
<ul>
<li>针对这 3 个 API 接口，分别基于边界值和等价类方法设计测试用例并执行</li>
<li>在测试执行过程中，启用代码覆盖率统计</li>
<li>假设测试完成后代码行覆盖率是 80%，需要找到那些还没有被执行到的 20% 的代码行</li>
<li>要保证代码覆盖率达到既定的要求，完成 API 测试</li>
</ul>
<p><strong>当我们采用微服务架构时，原本的单体应用会被拆分成多个独立模块，也就是很多个独立的service，原本单体应用的全局功能将会由这些拆分得到的API共同协作完成</strong></p>
<p><strong>改造上面的例子</strong>：</p>
<p>采用微服务架构，该系统被拆分成了 10 个独立的 service，每个 service 平均对外暴露 3 个 API 接口</p>
<p><strong>采用传统 API 测试策略，存在的问题</strong>：</p>
<ul>
<li>测试用例的数量多达 30 个 ，需要耗费大量的测试执行时间和资源</li>
<li>互联网模式下，由于发布周期的特殊性，测试的执行时间非常有限</li>
<li>微服务之间的耦合关系</li>
</ul>
<p>例：但是 Service T 的内部又调用了 Service X 和 Service Y，如果 Service X 和 Service Y 由于各种原因处于不可用的状态，此时就无法对 Service T 进行完整的测试</p>
<p><img src="./images/耦合示例.jpg" alt="耦合示例" /></p>
<p><strong>解耦方式</strong>：实现  <strong>Mock Service</strong> 来代替被依赖的真实 Service</p>
<p><strong>关键点</strong>：能够模拟真实 Service 的 Request 和 Response</p>
<p><strong>解决方法</strong>：<strong>基于消费契约的 API 测试</strong></p>
<p><strong>基于消费契约的 API 测试</strong>：</p>
<p>举个例子：</p>
<p>被测对象：Service T</p>
<p>Service T 的使用者：Service A、Service B</p>
<p>三者之间的关系：</p>
<p><img src="./images/关系.jpg" alt="关系" /></p>
<p><strong>思考</strong>：</p>
<ul>
<li>Service T 的使用者是确定的，只有 Service A 和 Service B</li>
<li>如果可以把 Service A 和 Service B 对Service T 所有可能的调用方式都测试到，那么就一定可以保证 Service T 的质量</li>
<li>可能存在某些 Service T 的其他调用方式会出错，但系统中并没有其他 Service 会以这种可能出错的方式来调用 Service T，不会影响整个系统的功能</li>
</ul>
<p><strong>问题转换</strong>：找到 Service A 和 Service B 对 Service T 所有可能的调用方式组成集合，作为 Service T 的测试用例</p>
<p><strong>测试用例集合本质</strong>：Service T 可以对外提供的<strong>服务的契约</strong>，称为“基于消费者契约的API测试”</p>
<p><strong>问题解决方案</strong>：在逻辑结构上，在 Service T 前放置一个代理，所有进出 Service T 的 Request 和 Response 都会经过这个代理，并被记录成 JSON 文件，构成了 Service T 的契约</p>
<p>原理过程：</p>
<p><img src="./images/原理过程.jpg" alt="原理过程" /></p>
<p><strong>实际应用</strong>：不可能在每个Service前去放置这样一个代理，微服务架构中会存在一个叫作 API Gateway 的组件，用于记录所有 API 之间相互调用关系的日志，可以通过解析 API Gateway 的日志分析得到每个 Service 的契约</p>
<p><strong>微服务测试的依赖解耦和 Mock Service</strong>：</p>
<p><strong>契约的本质</strong>：Request 和 Response 的组合，具体的表现形式往往是 JSON 文件</p>
<p><strong>Mock Service 依据</strong>：契约的 JSON 文件</p>
<p><img src="./images/API调用依赖.jpg" alt="API 调用依赖" /></p>
<p><strong>解耦服务之间的依赖</strong>：当用 Service X 的契约启动 Mock Service X 后，原本真实的 Service X 将被 Mock Service X 替代</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-22T12:37:14.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">自动化理解及应用场景</title>
    <id>https://www.snowji.cn/test/theory/basic-essentials/%E8%87%AA%E5%8A%A8%E5%8C%96%E7%90%86%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <link href="https://www.snowji.cn/test/theory/basic-essentials/%E8%87%AA%E5%8A%A8%E5%8C%96%E7%90%86%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <updated>2022-10-30T08:58:48.000Z</updated>
    <content type="html"><![CDATA[<h1 id="自动化理解及应用场景"> 自动化理解及应用场景</h1>
<h2 id="什么是自动化测试"> 什么是自动化测试</h2>
<p>意义：</p>
<p><strong>自动化测试是把人对软件的测试行为转化为由机器执行测试行为的一种实践</strong></p>
<p>本质：</p>
<p><strong>先写一段代码，然后去测试另一段代码，所以实现自动化测试用例本身属于开发工作，需要投入大量的时间和精力，并且已经开发完成的用例还必须随着被测对象的改变而不断更新，需要为此付出维护测试用例的成本</strong></p>
<h2 id="为什么需要自动化测试"> 为什么需要自动化测试</h2>
<p><strong>优势</strong>：</p>
<ul>
<li>自动化测试可以替代大量的手工机械重复性操作，测试工程师可以把更多的时间花在更全面的用例设计和新功能的测试上</li>
<li>自动化测试可以大幅提升回归测试的效率，非常适合敏捷开发过程</li>
<li>自动化测试可以更好地利用无人值守时间，去更频繁地执行测试，特别适合现在非工作时间执行测试，工作时间分析失败用例的工作模式</li>
<li>自动化测试可以高效实现某些手工测试无法完成或者代价巨大的测试类型，比如关键业务 7×24 小时持续运行的系统稳定性测试和高并发场景的压力测试等</li>
<li>自动化测试还可以保证每次测试执行的操作以及验证的一致性和可重复性，避免人为的遗漏或疏忽</li>
</ul>
<p><strong>劣势</strong>：</p>
<ul>
<li>自动化测试并不能取代手工测试，它只能替代手工测试中执行频率高、机械化的重复步骤</li>
<li>自动测试远比手动测试脆弱，无法应对被测系统的变化</li>
<li>自动化测试用例的开发工作量远大于单次的手工测试，所以只有当开发完成的测试用例的有效执行次数大于等于 5 次时，才能收回自动化测试的成本</li>
<li>手工测试发现的缺陷数量通常比自动化测试要更多，并且自动化测试仅仅能发现回归测试范围的缺陷</li>
<li>测试的效率很大程度上依赖自动化测试用例的设计以及实现质量，不稳定的自动化测试用例实现比没有自动化更糟糕</li>
<li>实行自动化测试的初期，用例开发效率通常都很低，大量初期开发的用例通常会在整个自动化测试体系成熟，和测试工程师全面掌握测试工具后，需要重构</li>
<li>业务测试专家和自动化测试专家通常是两批人，前者懂业务不懂自动化技术，后者懂自动化技术但不懂业务，只有二者紧密合作，才能高效开展自动化测试</li>
<li>自动化测试开发人员必须具备一定的编程能力</li>
</ul>
<h2 id="自动化测试应用场景"> 自动化测试应用场景</h2>
<h3 id="需求稳定-不会频繁变更"> 需求稳定，不会频繁变更</h3>
<p>需求不稳定，过高的需求变更频率会导致自动化测试用例的维护成本直线上升</p>
<h3 id="研发和维护周期长-需要频繁执行回归测试"> 研发和维护周期长，需要频繁执行回归测试</h3>
<ul>
<li>
<p>软件产品比软件项目更适合自动化</p>
<ul>
<li>软件产品的生命周期一般都比较长，通常会有多个版本陆续发布，每次版本发布都会有大量的回归测试需求</li>
<li>软件产品预留给自动化测试开发的时间也比较充裕，可以和产品一起迭代</li>
<li>自动化测试用例的执行比高于 1:5，即开发完成的用例至少可以被有效执行 5 次以上时，自动化测试的优势才可以被更好地体现</li>
</ul>
</li>
<li>
<p>软件项目的自动化，需要根据项目具体情况而定</p>
</li>
</ul>
<p>短期项目：以手工测试为主</p>
<p>中长期项目：对比较稳定的软件功能进行自动化测试，对变动较大或者需求暂时不明确的功能进行手工测试，最终目标是用 20% 的精力去覆盖 80% 的回归测试</p>
<h3 id="需要在多平台上重复运行相同的测试场景"> 需要在多平台上重复运行相同的测试场景</h3>
<ul>
<li>对于 GUI 测试，同样的测试用例需要在多种不同的浏览器上执行</li>
<li>对于移动端应用测试，同样的测试用例需要在多个不同的 Android 或者 iOS 版本上执行，或者是同样的测试需要在大量不同的移动终端上执行</li>
<li>对于一些企业级软件，如果对于不同的客户有不同的定制版本，各个定制版本的主体功能绝大多数是一致的，可能只有个别功能有轻微差别，测试也是需要覆盖每个定制版本的所有测试</li>
</ul>
<h3 id="某些测试项目通过手工测试无法实现-或者手工成本太高"> 某些测试项目通过手工测试无法实现，或者手工成本太高</h3>
<ul>
<li>性能测试</li>
<li>压力测试</li>
</ul>
<h3 id="被测软件的开发较为规范-能够保证系统的可测试性"> 被测软件的开发较为规范，能够保证系统的可测试性</h3>
<p><strong>注意</strong>：<strong>某些用例的自动化必须要求开发人员在产品中预留可测试性接口</strong></p>
<p>如：有些用户登录操作，需要图片验证码，开发人员需要提供绕开图片验证码的路径</p>
<h3 id="测试人员已经具备一定的编程能力"> 测试人员已经具备一定的编程能力</h3>
<p><strong>存在的阻力</strong>：</p>
<ul>
<li>前期的学习成本，很难在短期内对实际项目产生实质性的帮助</li>
<li>热衷于学习使用自动化测试技术，以至于他们的工作重点会发生错误的偏移，把大量的精力放在自动化测试技术的学习与实践上，而忽略了测试用例的设计，这将直接降低软件整体的质量</li>
</ul>
<h2 id="不同阶段的自动化技术"> 不同阶段的自动化技术</h2>
<p>在软件研发生命周期的各个阶段都有自动化测试技术的存在，并且对提升测试效率有着至关重要的作用</p>
<h3 id="单元测试阶段"> 单元测试阶段</h3>
<p><strong>观点</strong>：</p>
<p>单元测试本身就是<strong>自动化</strong>的，它根据软件详细设计采用等价类划分和边界值分析方法设计测试用例，在测试代码实现后再以自动化的方式统一执行</p>
<p><strong>广义理解</strong>：</p>
<p>单元测试阶段的「自动化」内涵不仅仅指测试用例执行的自动化，还应该包含以下五个方面：</p>
<ul>
<li>
<p>用例框架代码生成的自动化<br>
有些框架代码应该由自动化工具生成，单元测试开发者可以把更多的精力放在测试逻辑的覆盖和测试数据的选择上，从而大幅提高单元测试用例的质量和开发效率</p>
</li>
<li>
<p>部分测试输入数据的自动化生成<br>
能够根据不同变量类型自动生成测试输入数据</p>
</li>
</ul>
<p><strong>例子说明</strong>：</p>
<p>函数原型：<code>void fun（int* p, short b）</code></p>
<p>入参 <code>int* p</code>：生成 “空”和“非空”的两个指针 p</p>
<p>函数执行：观察执行情况</p>
<ul>
<li>自动桩代码的生成</li>
</ul>
<p><strong>桩代码（stub code）</strong>：是用来代替真实代码的临时代码</p>
<p>如：某个函数 A 的内部实现中调用了一个尚未实现的函数 B，为了对函数A的逻辑进行测试，那么就需要模拟一个函数 B，这个模拟的函数B实现就是所谓的桩代码</p>
<p><strong>自动桩代码</strong> ：自动化工具可以对被测试代码进行扫描分析，自动为被测函数内部调用的其他函数生成可编程的桩代码，并提供基于测试用例的桩代码管理机制，<strong>单元测试开发者只需重点关注桩代码内的具体逻辑实现，以及桩代码的返回值</strong></p>
<p><strong>抽桩</strong>：用真实函数代替原本桩代码函数的操作，就称为“抽桩”</p>
<ul>
<li>被测代码的自动化静态分析</li>
</ul>
<p><strong>目的</strong>：对代码进行静态扫描，识别出违反编码规则或编码风格的代码行</p>
<ul>
<li>测试覆盖率的自动统计与分析</li>
</ul>
<p>单元测试用例执行结束后，自动化工具可以自动统计各种测试覆盖率，如代码行覆盖率、分支覆盖率、MC/DC 覆盖率等。这些自动统计的指标，可以衡量单元测试用例集合的充分性和完备性，提供适当增补测试用例以提高测试覆盖率的依据</p>
<h3 id="代码级集成测试"> 代码级集成测试</h3>
<p>代码级集成测试是指将已经开发完成的软件模块放在一起测试</p>
<p><strong>关注点</strong>：软件模块之间的接口调用和数据传递</p>
<p><strong>与单元测试异同点</strong>：</p>
<p>相似：</p>
<p>从测试用例设计和测试代码结构来看，代码级集成测试和单元测试非常相似，它们都是对被测试函数以不同的输入参数组合进行调用并验证结果</p>
<p>区别：</p>
<p>代码级集成测试中被测函数内部调用的其他函数必须是真实的，不允许使用桩代码代替，而单元测试中允许使用桩代码来模拟内部调用的其他函数</p>
<p><strong>缺点</strong>：</p>
<p>代码级集成测试对测试框架的要求非常高，这个框架除了可以顺利装载自己的软件模块外，还必须能装载其他相互依赖的模块，做到被测软件模块可运行</p>
<p><strong>应用场景</strong>：</p>
<p>主要应用在早期非互联网的传统软件企业，软件以“单体”应用居多，一个软件内部包含大量的功能，每一个软件功能都是通过不同的内部模块来实现的，那么这些内部模块在做集成的时候，就需要做代码级集成测试</p>
<p>现在的软件企业，尤其是互联网企业，追求的是系统复杂性的解耦，会去尽量避免“大单体”应用，采用 Web Service 或者 RPC 调用的方式来协作完成各个软件功能，基本不会去做代码级集成测试</p>
<h3 id="web-service-测试"> Web Service 测试</h3>
<p><strong>类型</strong>：</p>
<ul>
<li>
<p>SOAP API</p>
</li>
<li>
<p>REST API</p>
</li>
</ul>
<p><strong>典型工具</strong>：</p>
<ul>
<li>
<p>SoapUI</p>
</li>
<li>
<p>Postman</p>
</li>
</ul>
<p><strong>代码的 API 测试用例，通常包含三大步骤</strong> ：</p>
<ul>
<li>
<p>准备 API 调用时需要的测试数据；</p>
</li>
<li>
<p>准备 API 的调用参数并发起 API 的调用；</p>
</li>
<li>
<p>验证 API 调用的返回结果</p>
</li>
</ul>
<p>除了以上的用例执行外，还包括以下 4 个方面：</p>
<ul>
<li>测试脚手架代码的自动化生成</li>
</ul>
<p><strong>核心</strong>：如何设计测试用例的输入参数以及组合，以及在不同参数组合情况下 Response 的验证</p>
<ul>
<li>部分测试输入数据的自动生成</li>
</ul>
<p>API 测试对应的是 API 的参数以及 API 调用的 Payload，数据生成的原则同样遵循边界值原则</p>
<ul>
<li>Response 验证的自动化</li>
</ul>
<p><strong>关注点</strong>：返回状态码 、 Scheme 结构以及具体的字段值</p>
<p><strong>核心思想</strong>：自动比较两次相同 API 调用的返回结果，并自动识别出有差异的字段值，比较过程可以通过规则配置去掉诸如时间戳、会话 ID（Session ID）等动态值</p>
<ul>
<li>基于 SoapUI 或者 Postman 的自动化脚本生成</li>
</ul>
<h3 id="gui-测试阶段"> GUI 测试阶段</h3>
<p><strong>两大方向</strong>：</p>
<ul>
<li>
<p>传统 Web 浏览器：业内主流的开源方案采用 Selenium，商业方案采用 Micro Focus 的 UFT</p>
</li>
<li>
<p>移动端原生应用：通常采用主流的 Appium，它对 iOS 环境集成了 XCUITest，对 Android 环境集成了 UIAutomator 和 Espresso</p>
</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-22T12:42:49.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">接口测试基础</title>
    <id>https://www.snowji.cn/test/theory/interface-test/</id>
    <link href="https://www.snowji.cn/test/theory/interface-test/"/>
    <updated>2022-08-23T03:12:14.000Z</updated>
    <content type="html"><![CDATA[<h1 id="接口测试基础"> 接口测试基础</h1>
<h2 id="什么是接口"> 什么是接口</h2>
<p>为保证项目的高耦合性，基本上前端和后端的开发是分离的。接口就是连接前后端的桥梁，前端通过接口向后端获取数据，后端通过接口向前端输出数据。</p>
<h2 id="接口测试的目的"> 接口测试的目的</h2>
<p><img src="./images/test.jpg" alt="test" /></p>
<p>上图将测试分为 3 层：</p>
<ul>
<li>
<p>底层 unit(单元测试)</p>
<p>一般由开发测试，由于在最底层，发现问题和解决问题的成本会降低</p>
</li>
<li>
<p>中层接口测试</p>
<p>接口开发完成并联调完成后，进入接口测试阶段，可以发现在 UI 层发现不了的问题</p>
</li>
<li>
<p>顶层 UI(功能或业务测试) 测试</p>
<p>一般由测试进行的 UI 测试或业务测试，基本处于金字的最顶尖，此时对于发现的问题和解决，成本比较高。但这种 UI 的测试又是不可缺少的，因为它是直接面向用户的，所以有必要测试。</p>
</li>
</ul>
<h1 id="常用测试工具"> 常用测试工具</h1>
<ul>
<li>Postman</li>
<li>Jmeter</li>
<li>fiddler</li>
<li>代码</li>
</ul>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-23T03:12:14.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Cookie</title>
    <id>https://www.snowji.cn/test/theory/interface-test/cookie/</id>
    <link href="https://www.snowji.cn/test/theory/interface-test/cookie/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="cookie"> Cookie</h1>
<h2 id="什么是-cookie"> 什么是 Cookie</h2>
<ul>
<li>以 K-V 形式存储在浏览器中的一种数据</li>
<li>可以在服务端设置，也可以在浏览器端用 JScript 设置</li>
<li>拥有 maxAge、Domain、Path 等属性，可以实现父子域名之间的数据传递</li>
</ul>
<h2 id="如何设置-cookie"> 如何设置 Cookie</h2>
<ul>
<li>浏览器</li>
</ul>
<p>通过 JScript 代码进行设置</p>
<div><pre><code>document<span>.</span>cookie <span>=</span> <span>"firstName=dongyuanxin; path=/"</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>服务端
<ul>
<li>通过给 Http Response Headers 中的 <code>Set-Cookie</code> 字段赋值，来设置 Cookie</li>
<li>客户端接收到 <code>Set-Cookie</code> 字段后，将其存储在浏览器中</li>
</ul>
</li>
</ul>
<p>在浏览器中可以看到服务端返回的 Cookie</p>
<p><img src="./images/cookie.png" alt="cookie" /></p>
<p>浏览器成功保存了 Cookie 的值，可以在 <code>Application =&gt; Storage =&gt; Cookies =&gt; 当前域名</code> 中查看</p>
<p><img src="./images/cookie1.png" alt="cookie1" /></p>
<p><strong>使用 Cookie 例子</strong>：</p>
<p>以用户购买商品为例：</p>
<ul>
<li>监测到浏览器客户端没有标识用户的 Cookie，跳转到登陆界面</li>
<li>用户账号密码登陆，后端验证，成功后，在 <code>Set-cookie</code> 中设置标识用户的 Cookie</li>
<li>登陆成功，保存用户标识的 Cookie</li>
<li>购买商品，自动携带用户身份的 Cookie，后端验证无误后，购买成功</li>
</ul>
<h2 id="总结"> 总结</h2>
<ul>
<li>需要将用户的身份信息保存在客户端，不安全，可以被攻击者窃取</li>
<li>Cookie 有大小限制</li>
<li>只能使用字符串型作为 value 值</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-23T06:25:23.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">跨域</title>
    <id>https://www.snowji.cn/test/theory/interface-test/cross-domain/</id>
    <link href="https://www.snowji.cn/test/theory/interface-test/cross-domain/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="跨域"> 跨域</h1>
<h2 id="什么是跨域问题"> 什么是跨域问题</h2>
<p>前端调用的后端接口不属于同一个域（域名或端口不同），就会产生跨域问题，也就是说你的应用访问了该应用域名或端口之外的域名或端口</p>
<p><img src="./images/ky.png" alt="ky" /></p>
<h3 id="为什么会出现跨域"> 为什么会出现跨域</h3>
<p>受浏览器的<strong>同源策略</strong>的限制</p>
<h2 id="同源策略"> 同源策略</h2>
<h3 id="为什么要有同源策略"> 为什么要有同源策略</h3>
<p>同源策略是页面中的一种安全策略</p>
<p><strong>举个没有安全策略的例子</strong>：</p>
<p>比如你打开一个银行站点，又不小心打开了一个恶意站点，在没有任何安全措施的情况下，恶意站点可以做很多事情：</p>
<ul>
<li>修改银行站点的 DOM、CSSOM 等信息</li>
<li>在银行站点内部插入 JavaScript 脚本</li>
<li>劫持用户登录的用户名和密码</li>
<li>读取银行站点的 Cookie、IndexDB 等数据</li>
<li>甚至还可以将这些信息上传至自己的服务器，这样就可以在你不知情的情况下伪造一些转账请求等信息</li>
</ul>
<p><strong>总结</strong>：同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性</p>
<h3 id="什么是同源"> 什么是同源</h3>
<p>如果两个 URL 的协议、域名和端口都相同，这两个 URL 就是同源，如：</p>
<table>
<thead>
<tr>
<th>当前页面 URL</th>
<th>被请求页面 URL</th>
<th>是否同源</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>http://www.test.com/</td>
<td>http://www.test.com/index.html</td>
<td>是</td>
<td>协议、域名、端口号相同</td>
</tr>
<tr>
<td>http://www.test.com/</td>
<td>https://www.test.com/index.html</td>
<td>否</td>
<td>协议不同（http/https）</td>
</tr>
<tr>
<td>http://www.test.com/</td>
<td>http://www.baidu.com/</td>
<td>否</td>
<td>主域名不同（test/baidu）</td>
</tr>
<tr>
<td>http://www.test.com/</td>
<td>http://blog.test.com/</td>
<td>否</td>
<td>子域名不同（www/blog）</td>
</tr>
<tr>
<td>http://www.test.com:8080/</td>
<td>http://www.test.com:7001/</td>
<td>否</td>
<td>端口号不同（8080/7001）</td>
</tr>
</tbody>
</table>
<h3 id="同源策略-2"> 同源策略</h3>
<p>定义：</p>
<ul>
<li>浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的</li>
<li>两个不同的源之间若想要相互访问资源或者操作 DOM，有一套基础的安全策略的制约，称为同源策略</li>
</ul>
<h4 id="同源策略主要表现在-dom、web-数据和网络这三个层面"> 同源策略主要表现在 DOM、Web 数据和网络这三个层面</h4>
<h5 id="dom-层面"> DOM 层面</h5>
<p>同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作</p>
<p>例子：</p>
<p>打开某网的官网，并打开一个专栏：</p>
<p><img src="./images/dom1.png" alt="dom1" /></p>
<p>由于页面是同源关系，可以在第二个页面操作第一个页面的 DOM ：</p>
<p><img src="./images/dom2.png" alt="dom2" /></p>
<p>如果打开的第二个页面和第一个页面不是同源关系，那就无法操作：</p>
<p><img src="./images/dom3.png" alt="dom3" /></p>
<h5 id="数据层面"> 数据层面</h5>
<ul>
<li>源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据</li>
<li>由于同源策略，无法通过第二个页面的 opener 来访问第一个页面中的 Cookie、IndexDB 或者 LocalStorage 等内容</li>
</ul>
<h5 id="网络层面"> 网络层面</h5>
<p>同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点</p>
<h2 id="跨域问题解决方案"> 跨域问题解决方案</h2>
<h3 id="设置-document-domain-解决无法读取非同源网页的-cookie-问题"> 设置 document.domain 解决无法读取非同源网页的 Cookie 问题</h3>
<ul>
<li>浏览器是通过 document.domain 属性来检查两个页面是否同源，只要通过设置相同的 document.domain，两个页面就可以共享 Cookie</li>
<li>此方案仅限主域相同，子域不同的跨域应用场景</li>
</ul>
<h3 id="跨文档通信-api-window-postmessage"> 跨文档通信 API：window.postMessage()</h3>
<ul>
<li>页面和其打开的新窗口的数据传递</li>
<li>多窗口之间消息传递</li>
<li>页面与嵌套的iframe消息传递</li>
<li>上面三个场景的跨域数据传递</li>
</ul>
<h3 id="jsonp"> JSONP</h3>
<p>是服务器与客户端跨源通信的常用方法</p>
<p>优点：简单适用，兼容性好（兼容低版本 IE）</p>
<p>缺点：是只支持 Get 请求，不支持 Post 请求</p>
<p>核心思想：网页通过添加一个<code>元素</code>，向服务器请求 JSON 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来</p>
<h3 id="cors"> CORS</h3>
<p>是跨域资源分享（Cross-Origin Resource Sharing）的缩写</p>
<ul>
<li>普通跨域请求：只需服务器端设置 Access-Control-Allow-Origin</li>
<li>带 Cookie 跨域请求：前后端都需要进行设置</li>
<li>webpack 本地代理</li>
</ul>
<p>在 <code>webpack.config.js</code> 中利用 WebpackDevServer 配置本地代理</p>
<p><img src="./images/webpack.png" alt="web" /></p>
<h3 id="websocket"> Websocket</h3>
<ul>
<li>WebSocket 和 HTTP 都是应用层协议，都基于 TCP 协议</li>
<li>WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的服务器与客户端都能主动向对方发送或接收数据</li>
<li>WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了</li>
</ul>
<h3 id="nginx反向代理"> Nginx反向代理</h3>
<p>使用 Nginx 反向代理实现跨域，是最简单的跨域方式</p>
<p>配置 Nginx，在一个服务器上配置多个前缀来转发 http/https 请求到多个真实的服务器</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T02:34:58.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Python+Excel+Json+Email 框架介绍</title>
    <id>https://www.snowji.cn/test/theory/auto-test/exercise/simple-frame/</id>
    <link href="https://www.snowji.cn/test/theory/auto-test/exercise/simple-frame/"/>
    <updated>2022-08-23T01:54:35.000Z</updated>
    <content type="html"><![CDATA[<h1 id="python-excel-json-email-框架介绍"> Python+Excel+Json+Email 框架介绍</h1>
<h2 id="项目介绍"> 项目介绍</h2>
<ul>
<li>
<p>本框架是集成 Python+Excel+Json+Email 开发的接口自动化框架</p>
</li>
<li>
<p>适用于自动化开发新人入门</p>
</li>
</ul>
<p><strong>项目地址</strong>：</p>
<p>GitHub：https://github.com/xuefengji/API-Testing/tree/master/Interface</p>
<h2 id="项目结构"> 项目结构</h2>
<p>目录介绍：</p>
<div><pre><code>Interface<span>:</span><span>.</span>
├─base
├─config
├─datas
├─main
├─report
└─util
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><strong>base</strong>: 二次封装了 Get 和 Post 请求</p>
<p><strong>config</strong>：</p>
<ul>
<li>data_config.py: 封装了 excel 数据</li>
<li>data_depend.py: 封装了数据依赖的处理</li>
<li>get_data.py：封装获取 excel 数据</li>
</ul>
<p><strong>datas</strong>：</p>
<ul>
<li>数据集，比如接口测试的用例和登录的信息、邮箱信息等</li>
<li>运行程序前需要在 email_count.py 中填写邮件信息</li>
</ul>
<p><strong>main</strong>：入口函数</p>
<p><strong>report</strong>：测试报告路径</p>
<p><strong>util</strong>：</p>
<ul>
<li>commutil: 实际结果与期望结果比较</li>
<li>operation_mysql: 操作数据库</li>
<li>operationexcle: 操作 excel</li>
<li>operation_cookie: 操作 cookie</li>
<li>operation_json: 操作 Json 数据</li>
<li>send_mail: 发送邮件</li>
</ul>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-23T01:54:35.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Restful 规范</title>
    <id>https://www.snowji.cn/test/theory/interface-test/restful-standard/</id>
    <link href="https://www.snowji.cn/test/theory/interface-test/restful-standard/"/>
    <updated>2022-09-02T02:34:58.000Z</updated>
    <content type="html"><![CDATA[<h1 id="restful-规范"> Restful 规范</h1>
<h2 id="概述"> 概述</h2>
<p>Rest：</p>
<ul>
<li>Representational State Transfer 的简称</li>
<li>代表的是一种软件架构风格，基于 HTTP、URL、XML、JSON 等标准和协议，支持轻量级、跨平台、跨语言的架构设计</li>
</ul>
<p>作用：通过一套统一的接口为所有 Web 相关提供服务，实现前后端分离</p>
<h2 id="rest-设计原则"> Rest 设计原则</h2>
<h3 id="规范原则"> 规范原则：</h3>
<ul>
<li>每一个 URL 代表一种资源</li>
<li>同一种资源有多种表现形式（XML/JSON）</li>
<li>所以操作都是无状态的</li>
<li>规范统一接口</li>
<li>返回一致的数据格式</li>
<li>可缓存(客户端可以缓存响应的内容)</li>
</ul>
<h4 id="理解为什么所有的操作需要无状态"> 理解为什么所有的操作需要无状态：</h4>
<ul>
<li>基于 C/S 架构的 HTTP 请求本身是无状态的，向客户端发的每一次请求都必须带有充分的信息能够让服务器识别</li>
<li>请求信息一般包含在 URL 的查询参数或 Header 中，服务端能够根据请求参数，不需要报错客户端的状态，直接将数据返回</li>
</ul>
<p><strong>无状态的优点</strong>：</p>
<p>可以大大提高服务器的健壮性和扩展性</p>
<h4 id="理解规范统一的接口"> 理解规范统一的接口：</h4>
<p><strong>Rest 接口约束定义</strong>：</p>
<ul>
<li>资源识别</li>
</ul>
<p>通过 URL 表示要操作的资源</p>
<ul>
<li>请求动作</li>
</ul>
<p>通过请求动作（HTTP Method）标识要执行的操作</p>
<ul>
<li>响应信息</li>
</ul>
<p>通过返回的状态码标识这次请求的执行结果</p>
<p><strong>举个例子</strong>：</p>
<p>对数据进行增删改查，设计接口</p>
<p><strong>未使用 Rest 规范前</strong>：</p>
<p>需要设计 4 个接口，XXX/api/add、XXX/api/delete、XXX/api/query、XXX/api/update，难维护</p>
<p><strong>使用 Rest 规范</strong>：</p>
<p>只需要设计一个接口 XXX/api，使用不同的请求方式 GET、POST 、DELETE、PUT，维护方便</p>
<h4 id="理解返回一致的数据格式"> 理解返回一致的数据格式：</h4>
<p>服务端返回的数据可以是 XML 或 JSON 或直接返回状态码</p>
<p><strong>返回 JSON 数据</strong>：</p>
<div><pre><code>返回错误的数据格式：
{
    &quot;code&quot;: 401,
    &quot;status&quot;: &quot;error&quot;,
    &quot;message&quot;: &#39;用户没有权限&#39;,
    &quot;data&quot;: null
}
正确的数据格式可以如下：
{
    &quot;code&quot;: 200,
    &quot;status&quot;: &quot;success&quot;,
    &quot;data&quot;: [{
        &quot;userName&quot;: &quot;tugenhua&quot;,
        &quot;age&quot;: 31
    }]
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="url-及参数设计规范"> URL 及参数设计规范</h2>
<h3 id="url-设计规范"> URL 设计规范</h3>
<ul>
<li>URL 末尾不需要出现斜杠/</li>
<li>在 URL 中使用 / 是表达层级关系的</li>
<li>在 URL 中可以使用连接符 - 来提升可读性</li>
<li>在 URL 中不允许出现下划线 _</li>
<li>在 URL 中尽量使用小写字符</li>
<li>在 URL 中不允许出现文件扩展名、</li>
<li>在 URL 中使用复数形式</li>
</ul>
<p><strong>接口设计对比</strong>：</p>
<div><pre><code>未使用规范前，接口形式不固定：
http://xxx.com/api/getallUsers; // GET请求方式，获取所有的用户信息
http://xxx.com/api/getuser/1;   // GET请求方式，获取标识为1的用户信息
http://xxx.com/api/user/delete/1 // GET、POST 删除标识为1的用户信息
http://xxx.com/api/updateUser/1  // POST请求方式 更新标识为1的用户信息
http://xxx.com/api/User/add      // POST请求方式，添加新的用户

使用规范后：
http://xxx.com/api/users;     // GET请求方式 获取所有用户信息
http://xxx.com/api/users/1;   // GET请求方式 获取标识为1的用户信息
http://xxx.com/api/users/1;   // DELETE请求方式 删除标识为1的用户信息
http://xxx.com/api/users/1;   // PATCH请求方式，更新标识为1的用户部分信息
http://xxx.com/api/users;     // POST请求方式 添加新的用户
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="http-请求规范"> HTTP 请求规范</h3>
<ul>
<li>GET（SELECT）: 查询；从服务器取出资源</li>
<li>POST（CREATE）: 新增; 在服务器上新建一个资源</li>
<li>PUT（UPDATE）: 更新; 在服务器上更新资源(客户端提供改变后的完整资源)</li>
<li>PATCH（UPDATE）: 更新；在服务器上更新部分资源(客户端提供改变的属性)</li>
<li>DELETE（DELETE）: 删除; 从服务器上删除资源</li>
</ul>
<h3 id="参数命名规范"> 参数命名规范</h3>
<p>推荐采用下划线方式：</p>
<div><pre><code>http://xxx.com/api/today_login // 获取今天登录的用户。
http://xxx.com/api/today_login&amp;sort=login_desc // 获取今天登录的用户、登录时间降序排序。
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="http-状态码相关"> HTTP 状态码相关</h2>
<h3 id="状态码范围"> 状态码范围</h3>
<ul>
<li>1xx: 信息，请求收到了，继续处理</li>
<li>2xx: 代表成功. 行为被成功地接收、理解及采纳</li>
<li>3xx: 重定向</li>
<li>4xx: 客户端错误，请求包含语法错误或请求无法实现</li>
<li>5xx: 服务器端错误</li>
</ul>
<p>具体的状态码及解释可参考 <a href="/basic-skills/network/HTTP协议/">HTTP 协议中的状态码</a></p>
<h3 id="返回统一数据格式"> 返回统一数据格式</h3>
<p>包含的字段：</p>
<ul>
<li>code：HTTP 响应状态码</li>
<li>status：比如  success（code 在 200-299 之间） 、fail（code 在 500-599 之间）、error（code 在400-499 之间）</li>
<li>data：请求成功时返回的数据信息，当 status 为 fail 或 error 时，包含错误原因或异常信息</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T02:34:58.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Session</title>
    <id>https://www.snowji.cn/test/theory/interface-test/session/</id>
    <link href="https://www.snowji.cn/test/theory/interface-test/session/"/>
    <updated>2022-08-24T02:12:25.000Z</updated>
    <content type="html"><![CDATA[<h1 id="session"> Session</h1>
<h2 id="什么是-session"> 什么是 Session</h2>
<p>通过 K-V 数据格式来保存数据：</p>
<ul>
<li>K: 称为 SessionID 保存在客户端</li>
<li>V: 称为 Session 保存在服务端</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>客户端只要存储 SessionID 具体映射的数据结构存储在服务端</li>
<li>跳出了浏览器 Cookie 只能存储字符型的限制</li>
<li>客户端存储 SessionID 还是需要借助 Cookie 实现</li>
</ul>
<h2 id="具体流程"> 具体流程</h2>
<p><img src="./images/session.png" alt="session" /></p>
<ul>
<li>接口登录成功后，服务器生成 SessionID 和 Session</li>
<li>将 SessionID 返给客户端</li>
<li>客户端发送 HTTP 请求时，会携带 Cookie 中的 SessionID</li>
<li>服务端获得 SessionID 后，根据值找到对应的 Session 数据比对
<img src="./images/session1.png" alt="session1" /></li>
</ul>
<h2 id="优势与不足"> 优势与不足</h2>
<h3 id="优势"> 优势</h3>
<ul>
<li>传输数据少，数据结构灵活</li>
</ul>
<p>相较于 Cookie 来说，客户端仅保留 SessionID ，传输数据量小，速度快</p>
<ul>
<li>更安全</li>
</ul>
<p>Session 的验证都是在服务端按照指定规则完成，而 Cookie 可能被客户端通过 JavaScript 代码篡改</p>
<h3 id="不足"> 不足</h3>
<ul>
<li>Session 会在一定时间内保存在服务器上，当访问增多，会比较占用服务器的性能</li>
<li>多台后端服务器无法共享 Session</li>
</ul>
<p>分布式部署服务时，不能共享服务器之间的状态</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>专门准备一台服务器存储 Session，所有有关 Session 的操作都由它调用</li>
</ul>
<p><strong>注意</strong>：只是单点服务器时，如果服务器 down 机了，Session 就不能查询</p>
<ul>
<li>服务器之间的调用，可以通过内网 IP 走 RPC 调用（不走 HTTP）</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-24T01:56:16.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">了解性能</title>
    <id>https://www.snowji.cn/test/theory/performance-test/</id>
    <link href="https://www.snowji.cn/test/theory/performance-test/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="了解性能"> 了解性能</h1>
<h2 id="什么是性能"> 什么是性能</h2>
<p><strong>简单概述</strong>：软件处理得及时性</p>
<p><strong>不同系统的性能关注点</strong>：</p>
<ul>
<li>
<p>Web 类应用和手机端应用，一般以终端用户感受到的端到端的响应时间来描述系统的性能</p>
</li>
<li>
<p>非交互式的应用，比如典型的电信和银行后台处理系统，响应时间关注更多的是事件处理的速度，以及单位时间的事件吞吐量</p>
</li>
</ul>
<h2 id="不同对象对性能的理解"> 不同对象对性能的理解</h2>
<p><strong>对象群体</strong>：终端用户、系统运维人员、软件设计开发人员和性能测试人员</p>
<p><img src="./images/软件维度.jpg" alt="软件维度" /></p>
<h3 id="终端用户眼中的性能"> 终端用户眼中的性能</h3>
<p>终端用户（也就是软件系统使用者）的维度来讲，用户在界面上完成一个操作开始，到系统把本次操作的结果以用户能察觉的方式展现出来的全部时间</p>
<p>响应时间是终端用户对系统性能的最直观印象，包括了系统响应时间和前端展现时间</p>
<ul>
<li>系统响应时间，反应的是系统能力，又可以进一步细分为应用系统处理时间、数据库处理时间和网络传输时间等；</li>
<li>前端展现时间，取决于用户端的处理能力</li>
</ul>
<h3 id="系统运维人员眼中的性能"> 系统运维人员眼中的性能</h3>
<p>从软件系统运维（也就是系统运维人员）的角度，性能包括：</p>
<ul>
<li>单个用户的响应时间</li>
<li>关注大量用户并发访问时的负载，</li>
<li>更大负载情况下的系统健康状态、并发处理能力、当前部署的系统容量、可能的系统瓶颈、系统配置层面的调优、数据库的调优，以及长时间运行稳定性和可扩展性</li>
</ul>
<p><strong>常见情况</strong>：系统运维人员在最大并发用户数和系统响应时间之间进行权衡取舍</p>
<p>比如：当有两套系统配置方案可以提供以下系统能力的时</p>
<ul>
<li>
<p>配置方案A可以提供 100万 并发访问用户的能力，此时用户的登录响应时间是 3 秒</p>
</li>
<li>
<p>配置方案B可以提供 500万 并发访问用户的能力，此时用户的登录响应时间是 8 秒</p>
</li>
</ul>
<p>从全局利益最大化角度来看，系统具有更大并发用户承载能力的价值会更大，一般都会选择方案 B</p>
<p><strong>有些系统为了能够承载更多的并发用户，往往会牺牲等待时间而引入预期的等待机制</strong></p>
<p>比如：火车票购票网站
优点：在处理极大并发用户时采用了排队机制，尽可能提高系统容量
不足：增加了用户实际感受到的响应时间</p>
<h3 id="软件设计开发人员眼中的性能"> 软件设计开发人员眼中的性能</h3>
<p>从软件系统开发（也就是软件设计开发人员）的角度来讲，关注的是性能相关的设计和实现细节</p>
<p><strong>性能包含</strong>：算法设计、架构设计、性能最佳实践、数据库相关、软件性能</p>
<p><strong>算法设计包含的点</strong>：</p>
<ul>
<li>核心算法的设计与实现是否高效</li>
<li>必要时，设计上是否采用 buffer 机制以提高性能，降低 I/O</li>
<li>是否存在潜在的内存泄露</li>
<li>是否存在并发环境下的线程安全问题</li>
<li>是否存在不合理的线程同步方式</li>
<li>是否存在不合理的资源竞争</li>
</ul>
<p><strong>架构设计包含的内容</strong>：</p>
<ul>
<li>站在整体系统的角度，是否可以方便地进行系统容量和性能扩展</li>
<li>应用集群的可扩展性是否经过测试和验证</li>
<li>缓存集群的可扩展性是否经过测试和验证</li>
<li>数据库的可扩展性是否经过测试和验证</li>
</ul>
<p><strong>性能最佳实践包含的点</strong>：</p>
<ul>
<li>代码实现是否遵守开发语言的性能最佳实践；</li>
<li>关键代码是否在白盒级别进行性能测试；</li>
<li>是否考虑前端性能的优化；</li>
<li>必要的时候是否采用数据压缩传输；</li>
<li>对于既要压缩又要加密的场景，是否采用先压缩后加密的顺序。</li>
</ul>
<p><strong>数据库相关的点</strong>：</p>
<ul>
<li>数据库表设计是否高效</li>
<li>是否引入必要的索引</li>
<li>SQL 语句的执行计划是否合理</li>
<li>SQL 语句除了功能是否要考虑性能要求</li>
<li>数据库是否需要引入读写分离机制</li>
<li>系统冷启动后，缓存大量不命中的时候，数据库承载的压力是否超负荷</li>
</ul>
<p><strong>软件性能的可测试性包含的点</strong>：</p>
<ul>
<li>是否为性能分析（Profiler）提供必要的接口支持</li>
<li>是否支持高并发场景下的性能打点</li>
<li>是否支持全链路的性能分析</li>
</ul>
<p><strong>注意</strong>：软件开发人员一般不会关注系统部署级别的性能，比如软件运行目标操作系统的调优、应用服务器的参数调优、数据库的参数调优、网络环境的调优等</p>
<h3 id="性能测试人员眼中的性能"> 性能测试人员眼中的性能</h3>
<p>性能工程的角度看，性能测试工程师需要关注：</p>
<ul>
<li>算法设计</li>
<li>架构设计</li>
<li>性能最佳实践</li>
<li>数据库相关</li>
<li>软件性能的可测试性</li>
</ul>
<p><strong>性能测试人员需要的技能</strong>：</p>
<ul>
<li>性能需求的总结和抽象能力</li>
<li>根据性能测试目标，精准的性能测试场景设计和计算能力</li>
<li>性能测试场景和性能测试脚本的开发和执行能力</li>
<li>测试性能报告的分析解读能力</li>
<li>性能瓶颈的快速排查和定位能力</li>
<li>性能测试数据的设计和实现能力</li>
<li>面对互联网产品，全链路压测的设计与执行能力，能够和系统架构师一起处理流量标记、影子数据库等的技术设计能力</li>
<li>深入理解性能测试工具的内部实现原理，当性能测试工具有限制时，可以进行扩展二次开发；</li>
<li>极其宽广的知识面，既要有“面”的知识，比如系统架构、存储架构、网络架构等全局的知识，还要有大量“点”的知识积累，比如数据库 SQL 语句的执行计划调优、JVM 垃圾回收（GC）机制、多线程常见问题等等</li>
</ul>
<p><strong>性能的三个最常用的指标</strong> ：</p>
<p>并发用户数、响应时间，系统吞吐量</p>
<p><strong>并发用户数</strong>:</p>
<p>是性能需求与测试最常用，最重要的指标之一</p>
<p>包含：</p>
<ul>
<li>业务层面</li>
</ul>
<p>业务层面的并发用户数，指的是实际使用系统的用户总数</p>
<p>单靠这个指标并不能反映系统实际承载的压力，还要结合用户行为模型才能得到系统实际承载的压力</p>
<ul>
<li>后端服务器层面</li>
</ul>
<p>后端服务器层面的并发用户数，是“同时向服务器发送请求的数量”，直接反映了系统实际承载的压力</p>
<p><strong>业务并发用户数与 服务器层面的并发用户数区别</strong>：</p>
<p>举个例子：</p>
<p>一个已经投入运行的 ERP 系统，该系统所在企业共有 5000名 员工并都拥有账号，说明这个系统有 5000 个潜在用户</p>
<p><strong>日志分析结果</strong>：</p>
<ul>
<li>系统最大在线用户数是 2500 人，从宏观角度来看，2500就是这个系统的最大并发用户数</li>
<li>2500 这个数据仅仅是说在最高峰时段有 2500 个用户登录了系统，而服务器所承受的压力取决于登录用户的行为，并不能准确表现服务器此时此刻正在承受的压力</li>
</ul>
<p>假设：某一时间点上，这 2500个 用户中</p>
<p>30% 用户处于页面浏览状态（对服务器没有发起请求）</p>
<p>20% 用户在填写订单（也没有对服务器发起请求）</p>
<p>5% 用户在递交订单</p>
<p>15% 用户在查询订单</p>
<p>而另外的 30% 用户没有进行任何操作</p>
<p>那么此时，这 2500个 “并发用户”中真正对服务器产生压力的只有 500个 用户（（5%+15%）*2500=500）</p>
<p><strong>结论</strong>：</p>
<ul>
<li>5000 是最大的“系统潜在用户数”</li>
<li>2500 是最大的“业务并发用户数”</li>
<li>500 是某个时间点上的“实际并发用户数”</li>
<li>服务器层面的并发用户数，这个指标同时取决于业务并发用户数和用户行为模式，而且用户行为模式占的比重较大</li>
</ul>
<p><strong>获取用户行为模式的方法</strong>，主要分为两种：</p>
<ul>
<li>对于已经上线的系统来说，往往采用系统日志分析法获取用户行为统计和峰值并发量等重要信息</li>
<li>而对于未上线的全新系统来说，通常的做法是参考行业中类似系统的统计信息来建模，然后分析</li>
</ul>
<p><strong>响应时间</strong>：</p>
<p>概述：<strong>响应时间反映了完成某个操作所需要的时间</strong></p>
<p><strong>包含 2 部分</strong>：</p>
<ul>
<li>前端展现时间</li>
</ul>
<p>取决于客户端收到服务器返回的数据后渲染页面所消耗的时间</p>
<p>会使用一些编程技巧在数据尚未完全接收完成时呈现数据，以减少用户实际感受到的主观响应时间</p>
<ul>
<li>
<p>系统响应时间</p>
<ul>
<li>Web服务器时间</li>
<li>应用服务器时间</li>
<li>数据库时间</li>
<li>各服务器间通信的网络时间</li>
</ul>
</li>
</ul>
<p><strong>严格上，响应时间应该包含两层含义</strong>：</p>
<ul>
<li>技术层面的标准定义</li>
<li>基于用户主观感受时间的定义</li>
</ul>
<p><strong>系统吞吐量</strong>：</p>
<p>是最能直接体现软件系统负载承受能力的指标</p>
<p><strong>通常衡量吞吐量的方式</strong>：</p>
<ul>
<li>Requests/Second</li>
</ul>
<p>表示的吞吐量，主要受网络设置、服务器架构、应用服务器制约</p>
<ul>
<li>Pages/Second</li>
</ul>
<p>表示的吞吐量，主要受网络设置、服务器架构、应用服务器制约</p>
<ul>
<li>Bytes/Second</li>
</ul>
<p>表示的吞吐量，主要受应用服务器和应用本身实现的制约</p>
<p>业务上：可以用单位时间的业务处理数量来衡量</p>
<p><strong>注意</strong>：吞吐量可以反映服务器承受负载的情况，但在不同并发用户数的场景下，即使系统具有相近的吞吐量，但是得到的系统性能瓶颈也会相差甚远</p>
<p>比如：个测试场景中采用 100个 并发用户，每个用户每隔 1秒 发出一个 Request，另外一个测试场景采用 1000个 并发用户，每个用户每隔 10秒 发出一个 Request</p>
<p>这两个场景具有相同的吞吐量, 都是 100 Requests/second，但两个场景所占用的资源是不同的，性能拐点肯定不同</p>
<p><strong>结论</strong>：性能测试场景的指标，必然不是单个，需要根据实际情况组合并发用户数、响应时间这两个指标</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-24T02:20:51.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">三种状态机制</title>
    <id>https://www.snowji.cn/test/theory/interface-test/three-state-mechanism/</id>
    <link href="https://www.snowji.cn/test/theory/interface-test/three-state-mechanism/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="三种状态机制"> 三种状态机制</h1>
<h2 id="为什么要有状态机制"> 为什么要有状态机制</h2>
<ul>
<li>HTTP 协议无状态</li>
<li>随着 Web 应用的发展，越来越多的场景需要表示用户身份</li>
</ul>
<p><strong>理解无状态例子</strong>：</p>
<p>需求：去超市买瓶酱油</p>
<ul>
<li>到了超市买了酱油，告诉售货员给我准备个面粉，下次来拿</li>
<li>第二次去超市拿面粉，售货员说他不记得你什么时候说过要准备面粉，这次你让售货员给你写了个纸条，盖上超市的印章</li>
<li>第三次去超市，带上纸条给售货员，这是售货员就会给你准备面粉</li>
</ul>
<p>总结：所谓 HTTP 无状态，就是当同一浏览器发送 HTTP 请求给 Server 时，Server 响应，但是不会知道是同一浏览器发出的请求</p>
<h2 id="常见的状态机制"> 常见的状态机制</h2>
<ul>
<li>Cookie</li>
<li>Session</li>
<li>token</li>
</ul>
<p>随后会详细介绍这 3 种状态机制</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-02T02:34:58.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Token</title>
    <id>https://www.snowji.cn/test/theory/interface-test/token/</id>
    <link href="https://www.snowji.cn/test/theory/interface-test/token/"/>
    <updated>2022-08-24T01:57:54.000Z</updated>
    <content type="html"><![CDATA[<h1 id="token"> Token</h1>
<p><strong>疑问</strong>：</p>
<p>前面学习了 Cookie 和 Session ，对比 Cookie 来说，Session 解决了很多问题，那为什么还需要 Token？</p>
<ul>
<li>Cookie 不安全</li>
<li>分布式的部署中 Session 不能共享</li>
</ul>
<p><strong>Token 的作用</strong> ：</p>
<ul>
<li>解决了上面的问题</li>
<li>将状态保存在客户端，并且借助加密算法进行验证保证安全性</li>
</ul>
<h2 id="具体流程"> 具体流程</h2>
<p><img src="./images/token.png" alt="token" /></p>
<p><strong>整体流程如下</strong>:</p>
<ul>
<li>用户尝试登陆</li>
<li>登陆成功后，后端依靠加密算法，将凭证生成 Token，返回给客户端</li>
<li>客户端保存 Token，每次发送请求时，携带 Token</li>
<li>后端在接收到带有 Token 的请求时，验证 Token 的有效性</li>
</ul>
<p>整个流程中，重要的是<strong>生成 Token、验证 Token</strong>的过程</p>
<p>请求成功后，服务端返回数据，如下：</p>
<p><img src="./images/token1.png" alt="token1" /></p>
<h2 id="token-优势与不足"> Token 优势与不足</h2>
<h3 id="优势"> 优势</h3>
<ul>
<li>服务器变成无状态了，实现分布式 Web 应用授权</li>
<li>可以进行跨域授权，不再局限父子域名</li>
<li>Token 设计绝对了它本身可以携带更多不敏感数据，例如最常用的 JWT</li>
<li>安全性更高，密钥保存在服务器。若密钥被窃取，可以统一重新下发密钥</li>
</ul>
<h3 id="不足"> 不足</h3>
<p>Token 增加了服务器压力（毕竟要加密）</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-24T01:57:54.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">性能分析思路</title>
    <id>https://www.snowji.cn/test/theory/performance-test/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/</id>
    <link href="https://www.snowji.cn/test/theory/performance-test/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/"/>
    <updated>2022-08-24T03:27:18.000Z</updated>
    <content type="html"><![CDATA[<h1 id="性能分析思路"> 性能分析思路</h1>
<p><strong>包含</strong>：</p>
<ul>
<li>瓶颈的精准判断</li>
<li>线程递增的策略</li>
<li>性能衰减的过程</li>
<li>响应时间的拆分</li>
<li>构建分析决策树</li>
<li>场景的对比</li>
</ul>
<h2 id="瓶颈的精准判断"> 瓶颈的精准判断</h2>
<h3 id="tps-曲线"> TPS 曲线</h3>
<p>例如，TPS 的曲线图：</p>
<p><img src="./images/tps曲线.jpg" alt="tps曲线" /></p>
<p>对应的响应时间的图：</p>
<p><img src="./images/响应时间图1.jpg" alt="响应时间图1" /></p>
<p>根据上面的图进行判断：</p>
<ul>
<li>
<p>有瓶颈</p>
<p>第二阶梯时出现瓶颈，响应时间增加，但 TPS 没有增加很多</p>
</li>
<li>
<p>瓶颈和压力有关</p>
</li>
<li>
<p>压力呈阶梯，并且增长幅度在衰减</p>
</li>
</ul>
<p><strong>TPS 曲线的作用</strong>：</p>
<ul>
<li>
<p>明确有没有瓶颈</p>
</li>
<li>
<p>明确瓶颈和压力有没有关系</p>
<p>TPS 随着压力变化就有关系，不随压力变化就无关</p>
</li>
</ul>
<h3 id="响应时间曲线"> 响应时间曲线</h3>
<p>例如，响应时间图：</p>
<p><img src="./images/响应时间图2.jpg" alt="响应时间图2" /></p>
<p>对应的线程数的曲线图：</p>
<p><img src="./images/线程图.jpg" alt="线程图" /></p>
<p>对应的 TPS 的图：</p>
<p><img src="./images/对应tps图.jpg" alt="对应tps图" /></p>
<p>由上面的图，可以看出：</p>
<ul>
<li>对比响应时间和线程图：响应时间随着线程数的增加而增加</li>
<li>对比 3张 图：有瓶颈，在线程数达 40 时，出现瓶颈</li>
</ul>
<p><strong>结论</strong>：</p>
<ul>
<li>响应时间判断业务的快慢</li>
<li>TPS 判断是否有瓶颈</li>
</ul>
<h2 id="线程递增的策略"> 线程递增的策略</h2>
<p><strong>性能场景对比</strong>：</p>
<p>场景 1：</p>
<p>线程图：</p>
<p><img src="./images/场景1线程.jpg" alt="场景1线程" /></p>
<p>TPS：</p>
<p><img src="./images/场景1tps.jpg" alt="场景1tps" /></p>
<p>响应时间：</p>
<p><img src="./images/场景1响应时间.jpg" alt="场景1响应时间" /></p>
<p>场景 2：</p>
<p>线程图：</p>
<p><img src="./images/场景2线程.jpg" alt="场景1线程" /></p>
<p>TPS：</p>
<p><img src="./images/场景2tps.jpg" alt="场景1tps" /></p>
<p>响应时间：</p>
<p><img src="./images/场景2响应时间.jpg" alt="场景1响应时间" /></p>
<p><strong>对比</strong>：</p>
<p><img src="./images/对比图.jpg" alt="对比图" /></p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-24T03:27:18.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">工具仅是工具</title>
    <id>https://www.snowji.cn/test/theory/performance-test/%E5%B7%A5%E5%85%B7%E4%BB%85%E6%98%AF%E5%B7%A5%E5%85%B7/</id>
    <link href="https://www.snowji.cn/test/theory/performance-test/%E5%B7%A5%E5%85%B7%E4%BB%85%E6%98%AF%E5%B7%A5%E5%85%B7/"/>
    <updated>2022-08-24T03:20:50.000Z</updated>
    <content type="html"><![CDATA[<h1 id="工具仅是工具"> 工具仅是工具</h1>
<h2 id="性能学习阶段"> 性能学习阶段</h2>
<ul>
<li>
<p>性能工具学习期</p>
<p>常用性能工具：Jmeter、loadRunner</p>
<p>使用：做脚本、发压力</p>
</li>
<li>
<p>性能场景学习期</p>
<p>重点关注：合理的性能测试，不再关注工具的使用</p>
<p>涉及内容：</p>
<ul>
<li>调整业务比例，设计到压力工具中</li>
<li>参数化数据的提取逻辑</li>
<li>场景中观察数据等等</li>
</ul>
</li>
<li>
<p>性能分析学习期</p>
<p>根据测试数据，分析性能瓶颈</p>
</li>
</ul>
<h2 id="公司性能团队成长阶段"> 公司性能团队成长阶段</h2>
<ul>
<li>性能团队初建</li>
</ul>
<p>做脚本，拿出 TPS 和响应时间，做版本基线对比，出数据罗列式的性能测试报告</p>
<ul>
<li>
<p>性能团队初成熟</p>
<ul>
<li>在各个流程关卡上做性能标准</li>
<li>考虑准入准出规则</li>
</ul>
</li>
<li>
<p>性能团队已成熟</p>
<ul>
<li>通过测试和分析优化后，性能提升了</li>
<li>通过测试和分析优化后，节省了成本</li>
</ul>
</li>
</ul>
<h2 id="使用工具的误区"> 使用工具的误区</h2>
<p>工具只能作为压力发起的工具，并不能通过工具知道瓶颈在哪，需要通过对数据进行分析</p>
<h2 id="如何选择合适的工具"> 如何选择合适的工具</h2>
<p>使用工具的，需要了解：</p>
<ul>
<li>工具能做什么</li>
<li>工具不能做什么</li>
<li>使用工具的目标</li>
<li>工具达不到目标，该怎么办</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-24T03:20:50.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">TPS 与响应时间之间的关系</title>
    <id>https://www.snowji.cn/test/theory/performance-test/TPS%E4%B8%8E%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</id>
    <link href="https://www.snowji.cn/test/theory/performance-test/TPS%E4%B8%8E%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <updated>2022-08-24T03:20:50.000Z</updated>
    <content type="html"><![CDATA[<h1 id="tps-与响应时间之间的关系"> TPS 与响应时间之间的关系</h1>
<h2 id="解析经典性能图"> 解析经典性能图</h2>
<p>一张经典图：</p>
<p><img src="./images/性能图.jpg" alt="性能图" /></p>
<p>上述图中描述的是：</p>
<ul>
<li>三条曲线</li>
</ul>
<p>吞吐量曲线（紫色）、使用率/用户数曲线（绿色）、响应时间曲线（深蓝色）</p>
<ul>
<li>三个区域</li>
</ul>
<p>轻负载区、重负载区、塌陷区</p>
<ul>
<li>两个点</li>
</ul>
<p>最优并发用户数、最大并发用户数</p>
<ul>
<li>三个状态描述</li>
</ul>
<p>资源饱和、吞吐下降、用户受影响</p>
<p><strong>存在的误差</strong>：</p>
<ul>
<li>重负载区的资源饱和 TPS 达到最大值之间都不是在同样的并发用户数之下</li>
</ul>
<p>如：当 CPU 达到 100% 后，随着压力增加，队列慢慢变长，但由于并发用户数的增加幅度会超过队列长度，此时 TPS 会增加，也就是在资源使用率达上限之后，还会有一段时间 TPS 才会达上限</p>
<ul>
<li>
<p>响应时间不会这么陡峭，不一定是在塌陷区上升，在重载区就有可能上升</p>
</li>
<li>
<p>吞吐量曲线不一定出现下降的趋势，控制好的系统会持平</p>
</li>
<li>
<p>最优并发数通常是一种感觉，并没有足够的证据证明</p>
</li>
<li>
<p>最大并发数，肯定是在之前的某个位置</p>
</li>
<li>
<p>没有考虑锁或线程配置不合理的情况</p>
</li>
</ul>
<h2 id="场景定义"> 场景定义</h2>
<p>根据场景进行一些概念的定义：</p>
<p><img src="./images/场景定义.jpg" alt="场景定义" /></p>
<p><strong>如此划分原因</strong>：在具体场景的操作层面，只有场景中的配置是可操作的</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-24T03:18:56.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">如何进行场景设计</title>
    <id>https://www.snowji.cn/test/theory/performance-test/%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1/</id>
    <link href="https://www.snowji.cn/test/theory/performance-test/%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1/"/>
    <updated>2022-08-24T03:27:18.000Z</updated>
    <content type="html"><![CDATA[<h1 id="如何进行场景设计"> 如何进行场景设计</h1>
<p><strong>前提条件</strong>：</p>
<ul>
<li>列出测试业务比例、业务目标 TPS  和响应时间指标</li>
</ul>
<p>例如：</p>
<p><img src="./images/业务.jpg" alt="业务" /></p>
<h2 id="基准性能场景"> 基准性能场景</h2>
<p><strong>业务１</strong></p>
<p>场景执行时长：17 分钟</p>
<p>结果：</p>
<p><img src="./images/statics.jpg" alt="statics" /></p>
<p>由上图可以看出：</p>
<ul>
<li>TPS 达 573.24</li>
<li>平均响应时间是 109.83ｍｓ</li>
<li>发送字节很少</li>
<li>接收字节 966.22KB/ｓ</li>
<li>响应最小时间 43ｍｓ，最长 694ｍｓ</li>
</ul>
<p>对于上述的这些结果，不能得出结论，需要结合以下图表：</p>
<p><strong>线程图</strong>：</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-24T03:27:18.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">性能测试基础</title>
    <id>https://www.snowji.cn/test/theory/performance-test/%E6%80%A7%E8%83%BD%E5%9F%BA%E6%9C%AC%E6%8C%87%E6%A0%87/</id>
    <link href="https://www.snowji.cn/test/theory/performance-test/%E6%80%A7%E8%83%BD%E5%9F%BA%E6%9C%AC%E6%8C%87%E6%A0%87/"/>
    <updated>2022-08-24T03:27:18.000Z</updated>
    <content type="html"><![CDATA[<h1 id="性能测试基础"> 性能测试基础</h1>
<h2 id="性能测试类型"> 性能测试类型</h2>
<ul>
<li>负载测试：主要看系统能承受多大的负载，直至系统崩溃</li>
<li>并发测试：主要看系统最大能支持多大并发</li>
<li>压力测试：高压力，持续一段时间，看系统运行的状态</li>
<li>容量测试：系统能承受的最大容量，可以是最大用户数量、数据库数量</li>
<li>可靠性测试：达到最大压力时，系统长时间运行，是否会有内存泄漏</li>
<li>配置测试：不同的配置下，系统的性能表现</li>
</ul>
<h2 id="基本流程"> 基本流程</h2>
<p><img src="./images/性能测试流程.png" alt="性能测试流程" /></p>
<h2 id="性能测试术语解释"> 性能测试术语解释：</h2>
<p>1、事务</p>
<p>2、虚拟用户数（线程数）</p>
<p>3、断言</p>
<p>4、集合点</p>
<h2 id="性能测试指标"> 性能测试指标：</h2>
<ul>
<li>
<p>系统指标（与用户场景和需求相关）：</p>
</li>
<li>
<p>TPS（每秒事务数）：每秒钟系统处理的事务数</p>
</li>
<li>
<p>并发用户数：同一时间并发的用户数</p>
<p>业务层面：实际使用系统的用户总数</p>
<p>后端服务器层面：同时向服务器发送请求的数量</p>
</li>
<li>
<p>吞吐量：</p>
<p>request/second</p>
<p>pages/second</p>
<p>bytes/second</p>
</li>
<li>
<p>吞吐率：</p>
</li>
<li>
<p>响应时间：客户端发送请求后，服务器作出回应后返回给client的时间</p>
<p>前端响应：前端拿到服务端返回的数据后，浏览器渲染到曾献的时间</p>
<p>系统响应时间：包含了请求时间、数据传输时间、应用服务处理时间、数据库时间等</p>
</li>
<li>
<p>点击量</p>
</li>
<li>
<p>点击率：同一时间，用户的点击率</p>
</li>
</ul>
<h2 id="并发用户、响应时间与吞吐量之间的关系"> 并发用户、响应时间与吞吐量之间的关系</h2>
<ul>
<li>当系统并发用户数较少时，系统的吞吐量也低，系统处于空闲状态，我们往往把这个阶段称为 “空闲区间”。</li>
<li>当系统整体负载并不是很大时，随着系统并发用户数的增长，系统的吞吐量也会随之呈线性增长，我们往往把这个阶段称为 “线性增长区间”</li>
<li>随着系统并发用户数的进一步增长，系统的处理能力逐渐趋于饱和，因此每个用户的响应时间会逐渐变长。相应地，系统的整体吞吐量并不会随着并发用户数的增长而继续呈线性增长。我们往往把这个阶段称为系统的“拐点”</li>
<li>随着系统并发用户数的增长，系统处理能力达到过饱和状态。此时，如果继续增加并发用户数，最终所有用户的响应时间会变得无限长。相应地，系统的整体吞吐量会降为零，系统处于被压垮的状态。我们往往把这个阶段称为“过饱和区间”</li>
</ul>
<h2 id="场景分析设计"> 场景分析设计</h2>
<p>1、用户量访问比较大的功能
2、与金钱相关比较重要的场景
3、影响业务主流程的场景
4、开发人员任务可能存在性能问题的场景
5、应该考虑综合场景，防止线程争用导致现场死锁以及数据库死锁
6、应该做稳定性能场景测试，防止长时间运行导致的内存泄露情况发生</p>
<h2 id="硬件指标"> 硬件指标：</h2>
<ul>
<li>cpu 使用率</li>
<li>内存使用率</li>
<li>io</li>
</ul>
<h2 id="软件指标"> 软件指标</h2>
<ul>
<li>服务器的配置</li>
<li>架构是否合理</li>
<li>数据库方面：
<ul>
<li>是否有索引</li>
<li>数据库锁</li>
<li>表空间设计是否合理</li>
<li>慢查询等</li>
</ul>
</li>
</ul>
<h2 id="性能测试工具"> 性能测试工具</h2>
<p>1、jmeter：开源的 Java 项目</p>
<p>2、loadrunner：</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-24T03:27:18.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">性能调优</title>
    <id>https://www.snowji.cn/test/theory/performance-test/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E6%94%BB%E7%95%A5/</id>
    <link href="https://www.snowji.cn/test/theory/performance-test/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E6%94%BB%E7%95%A5/"/>
    <updated>2022-08-24T03:27:18.000Z</updated>
    <content type="html"><![CDATA[<h1 id="性能调优"> 性能调优</h1>
<h2 id="系统性能定义"> 系统性能定义</h2>
<p><strong>包含两个方面：</strong></p>
<ul>
<li>吞吐量(Throughput)：每秒钟处理的请求数/任务数</li>
<li>系统延迟(Latency)：系统处理一个请求或任务时的延迟</li>
</ul>
<p><strong>两个指标之间的关系：</strong></p>
<ul>
<li>
<p>Throughput 越大，Latency 会越差</p>
<p>请求量过大，系统太繁忙，所以响应速度自然会低</p>
</li>
<li>
<p>Latency 越好，能支持的 Throughput 就会越高</p>
<p>Latency 短说明处理速度快，于是就可以处理更多的请求</p>
</li>
</ul>
<h2 id="系统性能测试"> 系统性能测试</h2>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-24T03:27:18.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">常见测试点</title>
    <id>https://www.snowji.cn/test/theory/safety-test/common-test-points/</id>
    <link href="https://www.snowji.cn/test/theory/safety-test/common-test-points/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="常见测试点"> 常见测试点</h1>
<h2 id="验证码相关"> 验证码相关</h2>
<table>
<thead>
<tr>
<th>检查项</th>
<th>描述</th>
<th>操作步骤</th>
</tr>
</thead>
<tbody>
<tr>
<td>验证码爆破</td>
<td>1.是否容易识别 2.错误后是否会更新验证码</td>
<td>验证码识别：<br />1. 查看验证码中的内容是否一眼就可辨别<br /> 2. 截图验证码去验证码识别的网站进行识别，是否能识别 <br /> 验证码更新：<br /> 1. 输入错误的验证码后提交，是否提示验证码错误，且验证码刷新 <br />2. 输入的用户名或密码错误后，验证码是否刷新 <br />3. 页面刷新时，验证码是否刷新</td>
</tr>
<tr>
<td>验证码可重复使用</td>
<td>是否存在验证码可使用多次</td>
<td>1. 输入的用户名和密码错误后，重新输入时使用之前的验证码提交数据，是否可以提交数据<br /> 2. 登录成功后，注销重新登录时，使用之前的验证码，是否可以登录</td>
</tr>
<tr>
<td>后端校验验证码</td>
<td>验证码是否可被绕过</td>
<td>1. 直接使用接口工具，传入用户名和密码，不传入验证码，直接登录，查看后端是否检验验证码</td>
</tr>
<tr>
<td>验证码有效期</td>
<td>验证码是否有有效期</td>
<td>1. 发送验证码成功后，一定时间后，是否会失效过期 <br />2. 使用该失效的验证码进行登录是否能登录成功</td>
</tr>
<tr>
<td>验证码内容在返回数据中</td>
<td>请求接口中是否返回了验证码信息</td>
<td>1. 使用发送验证码接口，发送验证码 <br />2. 看接口返回的数据中是否有验证码相关的信息</td>
</tr>
<tr>
<td>验证码是否设置上限</td>
<td>短信验证码发送是否有上限</td>
<td>1. 频繁发送短信验证码，是否有限制</td>
</tr>
</tbody>
</table>
<h2 id="密码相关"> 密码相关</h2>
<table>
<thead>
<tr>
<th>检查项</th>
<th>描述</th>
<th>操作步骤</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认口令</td>
<td>是否存在默认密码，如有，则登录后需要强制修改</td>
<td>1. 登录时使用默认的密码，登录成功后有强制修改密码的提示信息 <br />2. 未在规定时间修改密码后，不能使用之前默认的密码登录</td>
</tr>
<tr>
<td>弱口令</td>
<td>密码强度不足</td>
<td>1. 设置密码时是否可以包含数字、大小写字母、特殊字符等 <br />2. 密码长度是否不小于 8 位</td>
</tr>
<tr>
<td>密码加密</td>
<td>提交数据时，密码是否加密传输</td>
<td>1. 提交数据时，接口抓包，看传的密码参数是否加密</td>
</tr>
<tr>
<td>密码加密存储</td>
<td>数据库中密码是否以加密的形式存储</td>
<td>1. 可以查看用户表中所存储的密码是否加密</td>
</tr>
<tr>
<td>密码重复使用</td>
<td>新旧密码是否重复</td>
<td>1. 修改密码时，输入之前旧的密码，是否有提示信息提示不能与旧的密码一致</td>
</tr>
<tr>
<td>密码锁定</td>
<td>密码错误达限后锁定</td>
<td>1. 输入的密码错误达上限之后，重新再输入时提示密码被锁定，XX 后在试的提示信息<br /> 2. 已过锁定的时间，重新输入密码时是否能正常输入</td>
</tr>
<tr>
<td>密码可复制</td>
<td>密码框是否不允许复制粘贴</td>
<td>1. 输入在密码框中的密码，是否能被复制<br /> 2. 是否复制内容在密码框中进行粘贴</td>
</tr>
</tbody>
</table>
<h2 id="登录相关"> 登录相关</h2>
<table>
<thead>
<tr>
<th>检查项</th>
<th>描述</th>
<th>操作步骤</th>
</tr>
</thead>
<tbody>
<tr>
<td>登录失败</td>
<td>登录失败的提示是否模糊</td>
<td>1. 登录失败时，提示信息是否模糊，如：用户名或密码错误</td>
</tr>
<tr>
<td>记住密码</td>
<td>登录成功后记住密码</td>
<td>1. 登录成功后，注销重新登录时，是否记住之前输入的密码</td>
</tr>
<tr>
<td>cookie 或 token 过期</td>
<td>授权的 cookie或 token 过期</td>
<td>1. cookie 或 token 过期后，访问需要授权的页面是否跳转到登录页 <br />2. 使用接口工具，使用之前已过期的 token 进行登录，是否登录失败 <br />3. 登录成功后，修改本地缓存中的 token 信息，使用已过期的，刷新页面是否会跳转至登录页</td>
</tr>
<tr>
<td>生成的 token 或cookie 是否有规律</td>
<td></td>
<td>1. 多次登录后，查看接口返回的 token 或 cookie 数据是否存在一定的规律，防止伪造</td>
</tr>
</tbody>
</table>
<h2 id="权限相关"> 权限相关</h2>
<table>
<thead>
<tr>
<th>检查项</th>
<th>描述</th>
<th>操作步骤</th>
</tr>
</thead>
<tbody>
<tr>
<td>越权访问</td>
<td>是否存在越权获取非本账号(权限，角色)的数据</td>
<td>1. 账户 A 和 B 的权限不一致，使用 A 账户登录，是否可以查看 B 用户中的数据</td>
</tr>
<tr>
<td>权限越界</td>
<td>是否存在可获取高级别的权限角色</td>
<td>1. 使用低级别的账号登录<br /> 2. 在浏览器中输入高级别账号可访问的页面，是否能访问，是否有提示权限不足</td>
</tr>
<tr>
<td>列目录或资源文件漏洞</td>
<td>是否存在可以访问在网页上访问到服务器的目录和文件</td>
<td></td>
</tr>
<tr>
<td>未授权访问</td>
<td>是否存在可访问未授权的接口（无token）</td>
<td>1. 无token时，访问需要token的接口，是否不能访问，提示没有登录</td>
</tr>
<tr>
<td>使用其他账户的token访问</td>
<td>小程序的token 是否可以登录管理后台</td>
<td>1. 小程序登录后，复制 token <br />2. 使用 Burp Suite 安全工具或抓包工具 fiddler 拦截登录接口，伪造返回数据，将小程序端中获得的 token 放在接口返回的数据中 <br />3. 放开接口，正常登录，看是否能正常登录成功</td>
</tr>
</tbody>
</table>
<h2 id="文件上传"> 文件上传</h2>
<table>
<thead>
<tr>
<th>检查项</th>
<th>描述</th>
<th>操作步骤</th>
</tr>
</thead>
<tbody>
<tr>
<td>上传文件漏洞</td>
<td>是否存在可上传恶意修改文件头的文件</td>
<td></td>
</tr>
<tr>
<td>越权下载文件漏洞</td>
<td>是否存在可下载权限以外的文件</td>
<td>1. 登录成功后，使用当前用户的权限，下载不在权限范围内的文件，是否能正常下载</td>
</tr>
<tr>
<td>检查文件类型</td>
<td>前后端是否都校验文件类型</td>
<td>1. 上传文件时，使用抓包工具抓取上传的接口，进行断点，修改文件的类型后，发送，后端是否校验文件类型 <br />2. 使用抓包工具或安全工具，拦截接口，将 content-type 的类型修改为其他的类型，看前端是否能上传相应类型的文件 <br />3. 修改文件的类型为限制的类型，上传，上传成功后是否能正常打开</td>
</tr>
</tbody>
</table>
<h2 id="接口相关"> 接口相关</h2>
<table>
<thead>
<tr>
<th>检查项</th>
<th>描述</th>
<th>操作步骤</th>
</tr>
</thead>
<tbody>
<tr>
<td>接口加密</td>
<td>接口是否完成验签和数据加密</td>
<td></td>
</tr>
<tr>
<td>使用https协议</td>
<td>访问接口是否使用 https 协议传输</td>
<td>1. 接口协议是否使用的是 https 协议，保障安全性</td>
</tr>
<tr>
<td>接口防重提交</td>
<td>并发请求接口是否存在重复提交（如新增、报名、预订，下单等）</td>
<td>1. 对一些新增的接口，可使用接口工具对某一个接口设置多个进程同时访问，是否有防重提交限制</td>
</tr>
<tr>
<td>接口限流</td>
<td>接口是否设置了限流，防止 DDoS 攻击</td>
<td>1. 可使用工具 Jmeter 或脚本对接口进行大量的访问，是否有限流设置</td>
</tr>
<tr>
<td>接口暴露关键信息</td>
<td>url 中是否暴露关键信息，如 id 等</td>
<td>1. url 中是否有明显的关键信息显示，如 userid、订单 id 等</td>
</tr>
<tr>
<td>反射性 XSS 攻击</td>
<td>页面输入框是否过滤特殊字符</td>
<td>1. url后面加上一些语句，如：<script>alert(&quot;1&quot;) </script>；是否有弹窗 2. 系统中可输入的地方输入上述类似的内容后提交，查看是否会有弹窗</td>
</tr>
<tr>
<td>CSRF跨站请求伪造</td>
<td>请求头中的 Referer 字段是否被验证</td>
<td>1. 使用抓包工具抓取一个正常的请求包，去掉请求头中的Referer 中的值，重新提交，是否有效<br /> 2. 查看不同接口请求，Referer 值是否有边防变动</td>
</tr>
</tbody>
</table>
<h2 id="系统服务相关"> 系统服务相关</h2>
<table>
<thead>
<tr>
<th>检查项</th>
<th>描述</th>
<th>操作步骤</th>
</tr>
</thead>
<tbody>
<tr>
<td>服务端口是否默认</td>
<td>常用的服务端口是否使用默认的端口</td>
<td>1. telnet 端口是否修改 <br />2. mysql 是否使用默认端口 3306 <br />3. ssh 是否使用默认 22 端口</td>
</tr>
<tr>
<td>一些默认端口是否关闭</td>
<td>一些默认端口且不常用的端口是否关闭</td>
<td>1. 是否关闭远程连接 3389 端口</td>
</tr>
</tbody>
</table>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-24T03:31:57.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">性能测试概念</title>
    <id>https://www.snowji.cn/test/theory/performance-test/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%A6%82%E5%BF%B5/</id>
    <link href="https://www.snowji.cn/test/theory/performance-test/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%A6%82%E5%BF%B5/"/>
    <updated>2022-08-24T03:27:18.000Z</updated>
    <content type="html"><![CDATA[<h1 id="性能测试概念"> 性能测试概念</h1>
<p><strong>概念</strong>：</p>
<ul>
<li>针对系统的性能指标，建立性能测试模型，制定性能测试方案，制定监控策略</li>
<li>在场景条件之下执行性能场景，分析判断性能瓶颈并调优，最终得出性能结果来评估系统的性能指标是否满足既定值</li>
</ul>
<h2 id="性能指标"> 性能指标</h2>
<p>应该具有的指标：时间指标、容量指标、资源利用率指标</p>
<h2 id="性能测试模型"> 性能测试模型</h2>
<p><strong>模型</strong>：真实场景的抽象</p>
<p><strong>不同行业的模型</strong>：</p>
<ul>
<li>不敢线上压测的企业</li>
</ul>
<p>比如：有 100 个业务，可能只有 50个 业务有并发量</p>
<p>数据：从生产环境数据中统计业务的并发数</p>
<ul>
<li>互联网云架构企业</li>
</ul>
<p>直接在线上导流做性能测试</p>
<ul>
<li>银行类的金融企业</li>
</ul>
<p>测试环境中用业务模型模拟线上的流量</p>
<p>性能测试要选择合适自己系统业务逻辑的方式，用最低的成本、最快的时间做事情</p>
<h2 id="性能测试方案"> 性能测试方案</h2>
<p><strong>关键点</strong>：</p>
<ul>
<li>测试环境</li>
<li>测试数据</li>
<li>测试模型</li>
<li>性能指标</li>
<li>压力策略</li>
<li>准入准出</li>
<li>进度风险</li>
</ul>
<h2 id="性能监控"> 性能监控</h2>
<p>要有分层、分段的能力，要有全局监控、定向监控的能力</p>
<h2 id="性能预定的条件"> 性能预定的条件</h2>
<p><strong>包含</strong>：</p>
<ul>
<li>软硬件环境</li>
<li>测试数据</li>
<li>测试执行策略</li>
<li>压力补偿等</li>
</ul>
<h2 id="性能场景"> 性能场景</h2>
<p>定义：</p>
<ul>
<li>在既定的环境（包括动态扩展策略）、既定的数据（包括场景执行中的数据变化）、既定的执行策略、既定的监控之下，执行性能脚本</li>
<li>同时观察系统各层级的性能状态参数变化，并实时判断分析场景是否符合预期</li>
</ul>
<p><strong>场景分类</strong>：</p>
<ul>
<li>
<p>基准性能场景</p>
</li>
<li>
<p>容量性能场景（核心）</p>
</li>
<li>
<p>稳定性性能场景</p>
</li>
</ul>
<p><strong>核心元素</strong>：时间</p>
<ul>
<li>异常性能场景</li>
</ul>
<h2 id="性能分析调优"> 性能分析调优</h2>
<p><strong>性能项目类型</strong>：</p>
<ul>
<li>新系统性能测试</li>
</ul>
<p>一般测试系统的最大容量</p>
<ul>
<li>旧系统新版本性能测试</li>
</ul>
<p>一般和旧系统的性能进行比较，可根据历史数据进行容量推算，对调优要求不大</p>
<ul>
<li>新系统性能测试优化</li>
</ul>
<p>不仅要求测试出最大容量，还要求调优到最好</p>
<p><strong>几种性能测试</strong>：</p>
<ul>
<li>性能验证</li>
</ul>
<p>针对给定的指标，只做性能验证</p>
<ul>
<li>性能测试</li>
</ul>
<p>针对给定的系统，全面的进行性能测试，得到系统最大容量，但不进行调优</p>
<ul>
<li>性能测试+分析调优</li>
</ul>
<p>针对给定的系统，全面的进行性能测试，同时将系统调优到最优状态</p>
<h2 id="性能报告"> 性能报告</h2>
<p><strong>明确</strong>：调优前后的 TPS 、响应时间、资源对比图</p>
<h2 id="总结"> 总结</h2>
<p><img src="./images/概念总结.jpg" alt="概念总结" /></p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-24T03:27:18.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">性能指标理解</title>
    <id>https://www.snowji.cn/test/theory/performance-test/%E6%8C%87%E6%A0%87%E7%90%86%E8%A7%A3/</id>
    <link href="https://www.snowji.cn/test/theory/performance-test/%E6%8C%87%E6%A0%87%E7%90%86%E8%A7%A3/"/>
    <updated>2022-08-24T03:27:18.000Z</updated>
    <content type="html"><![CDATA[<h1 id="性能指标理解"> 性能指标理解</h1>
<h2 id="指标间关系"> 指标间关系</h2>
<p>包含：业务指标、技术指标</p>
<p><strong>两者之间关系</strong>：是映射的关系，技术指标在业务场景的前提下制定</p>
<p>例如：系统要支持 1000万 人在线</p>
<p><img src="./images/性能指标关系.jpg" alt="性能指标关系" /></p>
<p><strong>常用性能指标表示法</strong>：不包括资源指标</p>
<p><img src="./images/常用指标.jpg" alt="常用指标" /></p>
<h2 id="指标理解"> 指标理解</h2>
<h3 id="并发"> 并发</h3>
<ul>
<li>
<p>绝对并发</p>
<p><img src="./images/绝对并发.jpg" alt="绝对并发" /></p>
<p>严格按照上图的逻辑达到系统，绝对并发用户数是 4 ，描述 1秒 内的并发用户数是 16</p>
</li>
<li>
<p>相对并发</p>
<p><img src="./images/相对并发.jpg" alt="相对并发" /></p>
<p>并发数是 16TPS ，1秒 内系统处理了 16 个事务</p>
</li>
</ul>
<h3 id="tps-重要"> TPS（重要）</h3>
<p>含义：每秒事务数</p>
<p><strong>如何定义 T</strong>：根据场景的目的和 T 的作用定义 T</p>
<p>比如：接口层性能测试，T 可定义为接口级；业务级性能测试，T 可直接定义为每个业务步骤和完整的业务流</p>
<p><img src="./images/定义T.jpg" alt="定义T" /></p>
<ul>
<li>单独测试接口 1 2 3，则 T 就是接口级</li>
<li>从用户角度下单，接口 1 2 3 处于同一个业务，T 即为业务级</li>
</ul>
<p><strong>作用</strong>：反应系统的处理能力</p>
<h3 id="qps"> QPS</h3>
<p><strong>不同描述，不同意义</strong>：</p>
<ul>
<li>描述数据库中的 Query Per Second，表示数据库中 sql 的每秒执行条数</li>
<li>描述前端每秒查询数，不包括插入、更新、删除操作</li>
</ul>
<p><strong>不足</strong>：不够全面的描述系统的性能，不建议使用此指标描述系统整体性能</p>
<h3 id="rps"> RPS</h3>
<p>含义：每秒请求数</p>
<p><strong>不同描述，不同意义</strong>：</p>
<p><img src="./images/RPS.jpg" alt="RPS" /></p>
<p>用户点击 1 次，发出 3 个 Http Resquest，调用 2次 订单服务，2次 库存服务，1次 积分服务，Request 如何计算</p>
<ul>
<li>描述整体，算有 3个 RPS</li>
<li>从 HTTP 理解，Http Request 是比较准确的描述</li>
</ul>
<h3 id="cps-cpm"> CPS／CPM</h3>
<p>含义：每秒、每分钟调用次数，在接口级测试中常用到</p>
<p><strong>不同描述，不同意义</strong>：</p>
<ul>
<li>
<p>接口级</p>
</li>
<li>
<p>操作系统级，描述系统性能能力，会出现混乱</p>
<p><strong>处理方式</strong>：</p>
<ul>
<li>统一概念，在各层面上加上限制条件描述</li>
<li>团队中定义清楚术语的使用层级</li>
<li>如果没有定义使用层级，再说概念时，加上相应背景条件</li>
</ul>
</li>
</ul>
<h3 id="响应时间-rt-重要"> 响应时间 RT（重要）</h3>
<p><img src="./images/RT.jpg" alt="RT" /></p>
<p>RT = T2 - T1</p>
<p><strong>响应时间定位复杂的解决方案</strong>：链路监控工具、Metrics 使用</p>
<h3 id="压力工具中的线程数和用户数与-tps"> 压力工具中的线程数和用户数与 TPS</h3>
<p><strong>三者之间的关系</strong>：</p>
<p>示意图：</p>
<p><img src="./images/关系.jpg" alt="关系" /></p>
<p><strong>TPS 定义</strong>：上图中有 4个 并发线程，每个线程在 1秒 内完成 4个 事务，总的 TPS 是 16</p>
<p><strong>用户数定义</strong>：需要对在线用户做并发度分析，很多业务中并发度低于 5%，甚至低于 1%</p>
<p>比如：系统有 1万 用户在线，拿 5% 计算：</p>
<p>TPS = 10000 用户 *5%=500（TPS）</p>
<p>并发线程数（响应时间按 100ms 算）= 500（TPS）/（1000ms/100ms）=50（并发线程）</p>
<p><strong>性能分析强调的</strong>：趋势</p>
<h3 id="业务模型"> 业务模型</h3>
<p><strong>如何得到业务模型</strong>：</p>
<ul>
<li>
<p>根据生产环境的统计信息做业务比例的统计，设定到压力工具中，适用于不能直接在线上做压力测试的系统</p>
</li>
<li>
<p>直接在生产环境中做流量复制的方式或压力工具直接生产环境进行压力测试</p>
<p><strong>重要的点</strong>：组织协调能力</p>
</li>
</ul>
<h3 id="响应时间"> 响应时间</h3>
<p><strong>258 原则不合理原因</strong>：该结果统计时间过久，已不适用</p>
<p><strong>响应时间如何设计比较合理</strong>：</p>
<ul>
<li>同行业的对比数据</li>
<li>找到使用系统的样本用户做统计，结果就是有效响应时间的制定标准</li>
</ul>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-24T03:27:18.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">CSRF</title>
    <id>https://www.snowji.cn/test/theory/safety-test/csrf/</id>
    <link href="https://www.snowji.cn/test/theory/safety-test/csrf/"/>
    <updated>2022-08-24T03:31:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="csrf"> CSRF</h1>
<h2 id="什么是-csrf"> 什么是 CSRF</h2>
<p>CSRF：Cross-site request forgery 跨站请求伪造</p>
<ul>
<li>本质上是钓鱼</li>
<li>攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求</li>
<li>利用受害者在被攻击网站已经获取的登录凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的</li>
</ul>
<p><strong>原理</strong>：</p>
<p><img src="./images/csrf1.png" alt="csrf" /></p>
<p><strong>一个典型的 CSRF 攻击有着如下的流程</strong>：</p>
<ul>
<li>受害者登录 a.com，并保留了登录凭证（Cookie）</li>
<li>攻击者引诱受害者访问了 b.com</li>
<li>b.com 向 a.com 发送了一个请求：a.com/act=xx，浏览器会默认携带 a.com 的 Cookie</li>
<li>a.com 接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求</li>
<li>a.com 以受害者的名义执行了 act=xx</li>
<li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让 a.com 执行了自己定义的操作</li>
</ul>
<h2 id="csrf-攻击方式"> CSRF 攻击方式</h2>
<h3 id="get-请求产生的-csrf"> get 请求产生的 CSRF</h3>
<p>有 href 和 HTTP 请求两种方式</p>
<h4 id="href-攻击的方式"> href 攻击的方式</h4>
<div><pre><code><span>&lt;</span>a href<span>=</span><span>"http://bank.com/transfer?account_number_from=123456789&amp;account_number_to=987654321&amp;amount=100000"</span><span>></span>View my Pictures<span>!</span><span>&lt;</span><span>/</span>a<span>></span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>已经登录了bank.com</li>
<li>点击 &quot;View my Pictures&quot; 这一链接时，会将钱从一个账户转移到另一个账户，数额为 100000</li>
</ul>
<h4 id="http-请求方式"> HTTP 请求方式</h4>
<div><pre><code><span>&lt;</span>img src<span>=</span><span>"http://bank.example/withdraw/account=xiaoming&amp;amount=10000&amp;for=hacker"</span> <span>/</span><span>></span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>受害者访问含有这个 img 的页面后，浏览器会自动向 http://bank.example/withdraw/account=xiaoming&amp;amount=10000&amp;for=hacker 发出一次 HTTP 请求</li>
<li>在攻击者接收到请求的时候我们便可以“借用”对方的 Cookie</li>
</ul>
<h3 id="post-请求产生的-csrf"> post 请求产生的 CSRF</h3>
<ul>
<li>post 请求所产生的 CSRF 是利用地最多的攻击方式</li>
<li>这种类型的 CSRF 通常利用的是一个自动提交的表单</li>
</ul>
<div><pre><code><span>&lt;</span>form action<span>=</span><span>"http://bank.example/withdraw"</span> method<span>=</span><span>POST</span><span>></span> 
	<span>&lt;</span>input type<span>=</span><span>"hidden"</span> name<span>=</span><span>"account"</span> value<span>=</span><span>"xiaoming"</span> <span>/</span><span>></span> 
	<span>&lt;</span>input type<span>=</span><span>"hidden"</span> name<span>=</span><span>"amount"</span> value<span>=</span><span>"10000"</span> <span>/</span><span>></span> 
	<span>&lt;</span>input type<span>=</span><span>"hidden"</span> name<span>=</span><span>"for"</span> value<span>=</span><span>"hacker"</span> <span>/</span><span>></span> 
<span>&lt;</span><span>/</span>form<span>></span> 
<span>&lt;</span>script<span>></span> document<span>.</span>forms<span>[</span><span>0</span><span>]</span><span>.</span><span>submit</span><span>(</span><span>)</span><span>;</span> <span>&lt;</span><span>/</span>script<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>访问该页面后，表单会自动提交，相当于模拟用户完成了一次 POST 操作</p>
<h2 id="csrf-的防御手段"> CSRF 的防御手段</h2>
<p>主流的 CSRF 防御手段有以下两种：</p>
<ul>
<li>使用同源检测与 Samesite Cookie</li>
<li>多加一层验证手段 CSRF Token</li>
</ul>
<h3 id="csrf-token"> CSRF Token</h3>
<p><strong>工作原理</strong>：</p>
<ul>
<li>CSRF Token 每随着页面被操作，比如 f5 刷新，点击按钮等等，都会导致 CSRF Token 变化</li>
<li>每一个请求的 CSRF Token 会通过后端代码验证 Token 是否正确，在时间戳上是否有效，如果加密字符串一致且时间未过期，那么这个 Token 就是有效的</li>
</ul>
<h3 id="限制同源"> 限制同源</h3>
<p>通过设置 Set-Cookie 的值</p>
<h4 id="strict"> Strict</h4>
<ul>
<li>Strict 最为严格，完全禁止第三方 Cookie</li>
<li>跨站点时，任何情况下都不会发送 Cookie</li>
<li>只有当前网页的 URL 与请求目标一致，才会带上 Cookie</li>
</ul>
<div><pre><code>Set<span>-</span>Cookie<span>:</span> CookieName<span>=</span>CookieValue<span>;</span> SameSite<span>=</span>Strict<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="lax"> Lax</h4>
<ul>
<li>Lax 规则稍稍放宽，大多数情况也是不发送第三方 Cookie</li>
<li>导航到目标网址的 Get 请求除外</li>
</ul>
<div><pre><code>Set<span>-</span>Cookie<span>:</span> CookieName<span>=</span>CookieValue<span>;</span> SameSite<span>=</span>Lax<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="none"> None</h4>
<ul>
<li>代表关闭了 SameSite</li>
<li>一般攻击要进行绕过可以尝试将 SameSite 设置为 None</li>
</ul>
<div><pre><code>Set<span>-</span>Cookie<span>:</span> CookieName<span>=</span>CookieValue<span>;</span> SameSite<span>=</span>None<span>;</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-24T03:31:57.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">XSS</title>
    <id>https://www.snowji.cn/test/theory/safety-test/xss/</id>
    <link href="https://www.snowji.cn/test/theory/safety-test/xss/"/>
    <updated>2022-08-24T03:31:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="xss"> XSS</h1>
<h2 id="什么是-xss"> 什么是 XSS</h2>
<ul>
<li>全称跨站脚本(Cross Site Scripting)，为避免与层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故缩写为 XSS</li>
<li>一种将任意 Javascript 代码插入到其他 Web 用户页面里执行以达到攻击目的的漏洞</li>
<li>攻击者利用浏览器的动态展示数据功能，在 HTML 页面里嵌入恶意代码</li>
<li>用户浏览该页时，潜入在 HTML 中的恶意代码会被执行，用户浏览器被攻击者控制，从而达到攻击者的特殊目的，如 cookie 窃取等</li>
</ul>
<h2 id="xss-基本攻击手段"> XSS 基本攻击手段</h2>
<p>XSS 根据效果不同主要分为三种类型：</p>
<ul>
<li>反射型 XSS</li>
<li>存储型 XSS</li>
<li>DOM 型 XSS</li>
</ul>
<h3 id="反射型-xss-及绕过手段"> 反射型 XSS 及绕过手段</h3>
<h4 id="什么是反射型-xss"> 什么是反射型 XSS</h4>
<ul>
<li>反射型 XSS，也叫非持久型 XSS</li>
<li>利用比较简单，比如在搜索框中输入一段 JavaScript 代码，点击搜索按钮后，会执行该代码</li>
</ul>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-24T03:31:57.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">SQL 注入原理</title>
    <id>https://www.snowji.cn/test/theory/safety-test/sql-injection-principle/</id>
    <link href="https://www.snowji.cn/test/theory/safety-test/sql-injection-principle/"/>
    <updated>2022-08-24T03:31:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="sql-注入原理"> SQL 注入原理</h1>
<h2 id="什么是-sql-注入"> 什么是 SQL 注入</h2>
<ul>
<li>
<p>由于用户不可控输入，攻击者可以任意的输入恶意的 SQL 语句，使原始的查询语句的语义发生改变</p>
</li>
<li>
<p>在<strong>数据交互</strong>时，<strong>前端的数据传入到后台处理</strong>时，<strong>没有做严格的判断</strong>，导致其传入的“数据”<strong>拼接</strong>到 SQL 语句中后，<strong>被当作 SQL 语句的一部分执行</strong></p>
</li>
</ul>
<p><img src="./images/sql1.png" alt="sql" /></p>
<p><strong>注入漏洞经常出现的位置</strong>:</p>
<ul>
<li>常发生于用户和服务交互处（增删改查操作），Ajax，接口等等</li>
</ul>
<p><strong>实现注入攻击的两个关键条件(重点)</strong>:</p>
<ul>
<li>第一个：用户能控制输入——用户能控制输入变量</li>
<li>第二个：原本程序要执行的代码，<strong>拼接</strong>了用户输入的数据（正是拼接的这个过程导致了代码的注入）</li>
</ul>
<h2 id="sql注入危害"> SQL注入危害</h2>
<p>攻击者利用 SQL 注入漏洞，带来的风险有很多，例如：</p>
<ul>
<li>数据库被拖库</li>
<li>管理员和重要人员信息泄露</li>
<li>甚至还能通过 SQL 注入漏洞直 接获取 webshell 或者服务器系统权限等等</li>
</ul>
<p><strong>具体危害如下</strong>：</p>
<ul>
<li>绕过登录验证：使用万能密码登录网站后台等</li>
<li>获取敏感数据：获取网站管理员帐号、密码等</li>
<li>文件系统操作：列目录，读取、写入文件等</li>
<li>注册表操作：读取、写入、删除注册表等</li>
<li>执行系统命令：远程执行命令</li>
</ul>
<h2 id="sql注入防御"> SQL注入防御</h2>
<ul>
<li>对传进 SQL 语句里面的变量进行过滤，不允许危险字符传入</li>
<li>预编译参数化查询 (提前编译 SQL 语句，将所有的用户输入都当做『数据』，而非『语法』)在设计与数据库连接并访问数据时，在需要填入数值或数据的地方，使用参数（Parameter）来给值</li>
<li>目前有很多 ORM 框架会自动使用参数化解决注入问题,但其也提供了&quot;拼接&quot;的方式,所以使用时需要慎重</li>
<li><strong>采用黑名单、白名单</strong>等形式对用户提交的信息进行过滤，一旦发现用户参数中出现敏感的词或者内容，则将其删除，使得执行失败</li>
<li>安全设计遵循“数据与代码分离”原则</li>
<li>使用 WAF(web 应用防护墙)等安全产品</li>
</ul>
<h3 id="如何发现被-sql-注入攻击"> 如何发现被 SQL 注入攻击</h3>
<blockquote>
<p>日志监控---&gt;蜜罐数据---&gt;异常报警</p>
</blockquote>
<p><strong>监测方面</strong></p>
<p>目前大多都是：日志监控 + WAF</p>
<ul>
<li>日志推荐走数据库日志，越是离资源操作 近的地方，越是容易做到真正的安全</li>
<li>数据库日志容易解析，语法出错的、语法读 Info表的，都明确是黑客嘛，还能帮我们发现 SQL 注入点</li>
</ul>
<p><strong>蜜罐方面</strong></p>
<ul>
<li>数据库里可放置一些蜜罐数据的帐号和密码，假如这有一个服务，可以先从日志入手，发现请求恶意异常时，自动转发蜜罐</li>
<li>比如用户表里，前几十行里，做些用户名和密码 进行，实际上没有人用，一旦被登录，立马报警</li>
</ul>
<h2 id="sql注入分类"> SQL注入分类</h2>
<h3 id="按照数据类型分类"> 按照数据类型分类</h3>
<ul>
<li>
<p>数字型</p>
</li>
<li>
<p>字符型</p>
</li>
</ul>
<h3 id="按照注入点分类-哪些地方存在-sql注入"> 按照注入点分类(哪些地方存在 SQL注入)</h3>
<ul>
<li>
<p>GET 型（注入点在 UR）</p>
</li>
<li>
<p>POST 型（注入点在表单输入框中，且数据提交方式是 POST，如登录框、注册框）</p>
</li>
<li>
<p>COOKIE 型（注入点在 cookie中）</p>
</li>
<li>
<p>Header 型(注入点在头部)</p>
</li>
<li>
<p>其他(请求报文中只要能够被后端脚本引擎接受的数据均可 SQ L注入)</p>
</li>
</ul>
<h3 id="按照数据获取的方式分类"> 按照数据获取的方式分类</h3>
<ul>
<li>
<p>回显注入--联合查询</p>
</li>
<li>
<p>报错注入--报错回显(extractvalue(), updatexml(), floor())</p>
</li>
<li>
<p>盲注（没有错误回显）</p>
<ul>
<li>bool 盲注--逻辑语句判断查询出的字符</li>
<li>时间盲注--利用页面演示情况判断数据库中的数据</li>
</ul>
</li>
</ul>
<p><strong>注意:</strong></p>
<p><strong><code>盲注，time盲注，报错注入，union注入</code></strong>,这些注入漏洞出现频率较高</p>
<p><strong><code>在不影响正常服务的情况下，拼接查询算最高危害的，接下来就是union。</code></strong></p>
<p><strong><code>比较好检测的注入有：盲注，time盲注，报错注入等</code></strong></p>
<h2 id="sql注入流程"> SQL注入流程</h2>
<p><img src="./images/sql2.png" alt="sql" /></p>
<h3 id="流程细节"> 流程细节</h3>
<ul>
<li>
<p>找疑似注入点--找数据输入的地方</p>
</li>
<li>
<p>判断注入点----找输入点中与数据库有交互的地方</p>
</li>
<li>
<p>确认注入存在----确认找到于数据库有交互的地方是不是存在sql注入</p>
</li>
<li>
<p>选择攻击目标----选择攻击后需要达到的目的</p>
</li>
<li>
<p>根据选择的目标构sql语言</p>
</li>
<li>
<p>提交sql语言</p>
</li>
<li>
<p>判断网页响应是否与目标一致</p>
<ul>
<li>后端语言对输入的 sql 语句有限制，考虑重构sql语句</li>
<li>选择的目标在当前网站不具备成功的条件，考虑重新选择目标</li>
</ul>
</li>
<li>
<p>响应符合预期，则完成注入</p>
</li>
</ul>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-24T03:31:57.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Jmeter + Ant + Jenkins 实现自动化</title>
    <id>https://www.snowji.cn/test/tools/Jmeter/apply/Jmeter+Ant+Jenkins%20%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96/</id>
    <link href="https://www.snowji.cn/test/tools/Jmeter/apply/Jmeter+Ant+Jenkins%20%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    <updated>2022-10-27T01:51:20.000Z</updated>
    <content type="html"><![CDATA[<h1 id="jmeter-ant-jenkins-实现自动化"> Jmeter + Ant + Jenkins 实现自动化</h1>
<p><strong>前言</strong>:</p>
<ul>
<li>本文是基于 Jmeter5.0+ 在 Windows 环境下</li>
<li>先安装好 Java 环境 和 Jmeter，可参考 <a href="/test/tools/Jmeter/jmeter-install-linux">Jmeter在Windows上安装</a></li>
</ul>
<h2 id="ant-的安装与配置"> Ant 的安装与配置</h2>
<h3 id="下载安装"> 下载安装</h3>
<p><strong>下载</strong>：</p>
<p>下载地址：http://ant.apache.org/</p>
<p>选择 JDK 8 的安装包</p>
<p><img src="./../images/ant1.png" alt="ant1" /></p>
<p><strong>配置环境变量</strong>：</p>
<p>将 Ant 目录下的 <code>/bin</code> 和 <code>/lib</code> 路径添加到环境变量中</p>
<p>配置完成后，在 cmd 中输入 <code>ant -version</code>, 出现以下内容说明安装成功</p>
<div><pre><code>E:<span>\</span>greenSoftware<span>\</span>apache-jmeter-5.2.1<span>\</span>apache-jmeter-5.2.<span><span>1</span>></span>ant -version
Apache Ant<span>(</span>TM<span>)</span> version <span>1.10</span>.12 compiled on October <span>13</span> <span>2021</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="相关文件配置"> 相关文件配置</h3>
<p><strong>拷贝 jar 包</strong>：</p>
<p>将 Jmeter 目录中的 extras 文件夹下 <code>ant-jmeter-1.1.1.jar</code> 文件拷贝到 Ant 安装目录下的 lib 文件夹下</p>
<p><strong>配置 Ant 的编译文件</strong>：</p>
<p>配置前准备：</p>
<ul>
<li>在 Jmeter 下创建 scripts 目录用于存放脚本</li>
<li>在 Jmeter 下创建 reports 目录用于存放测试报告</li>
</ul>
<p>编写 build.xml 文件，存放于 Jmeter 的安装目录下，文件内容如下，修改相应的部分即可：</p>
<div><pre><code><span>&lt;?xml version="1.0" encoding="UTF8"?></span>
<span><span><span>&lt;</span>project</span> <span>name</span><span><span>=</span><span>"</span>ant-jmeter-test<span>"</span></span> <span>default</span><span><span>=</span><span>"</span>run<span>"</span></span> <span>basedir</span><span><span>=</span><span>"</span>.<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>tstamp</span><span>></span></span>
        <span><span><span>&lt;</span>format</span> <span>property</span><span><span>=</span><span>"</span>time<span>"</span></span> <span>pattern</span><span><span>=</span><span>"</span>yyyyMMddHHmmss<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;/</span>tstamp</span><span>></span></span>
    <span>&lt;!-- 需要改成自己本地的 Jmeter 目录--></span>  
    <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>"</span>jmeter.home<span>"</span></span> <span>value</span><span><span>=</span><span>"</span>E:\greenSoftware\apache-jmeter-5.2.1\apache-jmeter-5.2.1<span>"</span></span> <span>/></span></span>
    <span>&lt;!-- 需要修改成jmeter生成jtl格式的结果报告的路径--></span> 
    <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>"</span>jmeter.result.jtl.dir<span>"</span></span> <span>value</span><span><span>=</span><span>"</span>E:\greenSoftware\apache-jmeter-5.2.1\apache-jmeter-5.2.1\reports<span>"</span></span> <span>/></span></span>
    <span>&lt;!-- 需要修改成jmeter生成html格式的结果报告的路径--></span>
    <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>"</span>jmeter.result.html.dir<span>"</span></span> <span>value</span><span><span>=</span><span>"</span>E:\greenSoftware\apache-jmeter-5.2.1\apache-jmeter-5.2.1\reports<span>"</span></span> <span>/></span></span>
    <span>&lt;!-- 生成的报告的前缀，可修改--></span>  
    <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>"</span>ReportName<span>"</span></span> <span>value</span><span><span>=</span><span>"</span>TestReport<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>"</span>jmeter.result.jtlName<span>"</span></span> <span>value</span><span><span>=</span><span>"</span>${jmeter.result.jtl.dir}/${ReportName}${time}.jtl<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>"</span>jmeter.result.htmlName<span>"</span></span> <span>value</span><span><span>=</span><span>"</span>${jmeter.result.html.dir}/${ReportName}${time}.html<span>"</span></span> <span>/></span></span>
     
    <span><span><span>&lt;</span>target</span> <span>name</span><span><span>=</span><span>"</span>run<span>"</span></span><span>></span></span>
        <span><span><span>&lt;</span>antcall</span> <span>target</span><span><span>=</span><span>"</span>test<span>"</span></span> <span>/></span></span>
        <span><span><span>&lt;</span>antcall</span> <span>target</span><span><span>=</span><span>"</span>report<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;/</span>target</span><span>></span></span>
     
    <span><span><span>&lt;</span>target</span> <span>name</span><span><span>=</span><span>"</span>test<span>"</span></span><span>></span></span>
        <span><span><span>&lt;</span>taskdef</span> <span>name</span><span><span>=</span><span>"</span>jmeter<span>"</span></span> <span>classname</span><span><span>=</span><span>"</span>org.programmerplanet.ant.taskdefs.jmeter.JMeterTask<span>"</span></span> <span>/></span></span>
        <span><span><span>&lt;</span>jmeter</span> <span>jmeterhome</span><span><span>=</span><span>"</span>${jmeter.home}<span>"</span></span> <span>resultlog</span><span><span>=</span><span>"</span>${jmeter.result.jtlName}<span>"</span></span><span>></span></span>
             <span>&lt;!-- 修改成jmeter的脚本目录，"*.jmx"指包含此目录下的所有jmeter脚本--></span>
            <span><span><span>&lt;</span>testplans</span> <span>dir</span><span><span>=</span><span>"</span>E:\greenSoftware\apache-jmeter-5.2.1\apache-jmeter-5.2.1\scripts<span>"</span></span> <span>includes</span><span><span>=</span><span>"</span>*.jmx<span>"</span></span> <span>/></span></span>
            <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>"</span>jmeter.save.saveservice.output_format<span>"</span></span> <span>value</span><span><span>=</span><span>"</span>xml<span>"</span></span><span>/></span></span>
        <span><span><span>&lt;/</span>jmeter</span><span>></span></span>
    <span><span><span>&lt;/</span>target</span><span>></span></span>
     
    <span><span><span>&lt;</span>path</span> <span>id</span><span><span>=</span><span>"</span>xslt.classpath<span>"</span></span><span>></span></span>
        <span><span><span>&lt;</span>fileset</span> <span>dir</span><span><span>=</span><span>"</span>${jmeter.home}/lib<span>"</span></span> <span>includes</span><span><span>=</span><span>"</span>xalan*.jar<span>"</span></span><span>/></span></span>
        <span><span><span>&lt;</span>fileset</span> <span>dir</span><span><span>=</span><span>"</span>${jmeter.home}/lib<span>"</span></span> <span>includes</span><span><span>=</span><span>"</span>serializer*.jar<span>"</span></span><span>/></span></span>
    <span><span><span>&lt;/</span>path</span><span>></span></span> 
     
    <span><span><span>&lt;</span>target</span> <span>name</span><span><span>=</span><span>"</span>report<span>"</span></span><span>></span></span>
        <span><span><span>&lt;</span>tstamp</span><span>></span></span><span><span><span>&lt;</span>format</span> <span>property</span><span><span>=</span><span>"</span>report.datestamp<span>"</span></span> <span>pattern</span><span><span>=</span><span>"</span>yyyy/MM/dd HH:mm<span>"</span></span><span>/></span></span><span><span><span>&lt;/</span>tstamp</span><span>></span></span>
        <span><span><span>&lt;</span>xslt</span> 
              <span>classpathref</span><span><span>=</span><span>"</span>xslt.classpath<span>"</span></span>
              <span>force</span><span><span>=</span><span>"</span>true<span>"</span></span>
              <span>in</span><span><span>=</span><span>"</span>${jmeter.result.jtlName}<span>"</span></span>
              <span>out</span><span><span>=</span><span>"</span>${jmeter.result.htmlName}<span>"</span></span>
              <span>style</span><span><span>=</span><span>"</span>${jmeter.home}/extras/jmeter-results-report_21.xsl<span>"</span></span><span>></span></span>
              <span>&lt;!-- 修改自己本地存在的样式文件名 --></span>
              <span><span><span>&lt;</span>param</span> <span>name</span><span><span>=</span><span>"</span>dateReport<span>"</span></span> <span>expression</span><span><span>=</span><span>"</span>${report.datestamp}<span>"</span></span><span>/></span></span>
        <span><span><span>&lt;/</span>xslt</span><span>></span></span>
             
        <span><span><span>&lt;</span>copy</span> <span>todir</span><span><span>=</span><span>"</span>${jmeter.result.html.dir}<span>"</span></span><span>></span></span>
            <span><span><span>&lt;</span>fileset</span> <span>dir</span><span><span>=</span><span>"</span>${jmeter.home}/extras<span>"</span></span><span>></span></span>
                <span><span><span>&lt;</span>include</span> <span>name</span><span><span>=</span><span>"</span>collapse.png<span>"</span></span> <span>/></span></span>
                <span><span><span>&lt;</span>include</span> <span>name</span><span><span>=</span><span>"</span>expand.png<span>"</span></span> <span>/></span></span>
            <span><span><span>&lt;/</span>fileset</span><span>></span></span>
        <span><span><span>&lt;/</span>copy</span><span>></span></span>
    <span><span><span>&lt;/</span>target</span><span>></span></span>
<span><span><span>&lt;/</span>project</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div><p><strong>修改 <code>jmeter.properties</code> 文件</strong>：</p>
<ul>
<li>进入 Jmeter 安装目录 <code>/bin</code> 目录下打开 <code>jmeter.properties</code>文件</li>
<li>将 <code>#jmeter.save.saveservice.output_format=csv</code> 修改为 <code>jmeter.save.saveservice.output_format=xml</code>并去掉注释</li>
</ul>
<h3 id="调试运行-ant"> 调试运行 Ant</h3>
<p><strong>前提</strong>：在 Jmeter 安装目录的 scripts 目录中创建 .jmx 脚本</p>
<p>进入 build.xml 文件目录下，进入 cmd 运行环境，输入 ant 命令：</p>
<div><pre><code>E:<span>\</span>greenSoftware<span>\</span>apache-jmeter-5.2.1<span>\</span>apache-jmeter-5.2.<span><span>1</span>></span>ant
Buildfile: E:<span>\</span>greenSoftware<span>\</span>apache-jmeter-5.2.1<span>\</span>apache-jmeter-5.2.1<span>\</span>build.xml

run:

test:
   <span>[</span>jmeter<span>]</span> Executing <span>test</span> plan: E:<span>\</span>greenSoftware<span>\</span>apache-jmeter-5.2.1<span>\</span>apache-jmeter-5.2.1<span>\</span>scripts<span>\</span>login.jmx <span>==</span><span>></span> E:<span>\</span>greenSoftware<span>\</span>apache-jmeter-5.2.1<span>\</span>apache-jmeter-5.2.1<span>\</span>reports<span>\</span>TestReport20221022171155.jtl
   <span>[</span>jmeter<span>]</span> Creating summariser <span>&lt;</span>summary<span>></span>
   <span>[</span>jmeter<span>]</span> Created the tree successfully using E:<span>\</span>greenSoftware<span>\</span>apache-jmeter-5.2.1<span>\</span>apache-jmeter-5.2.1<span>\</span>scripts<span>\</span>login.jmx
   <span>[</span>jmeter<span>]</span> Starting standalone <span>test</span> @ Sat Oct <span>22</span> <span>17</span>:11:59 CST <span>2022</span> <span>(</span><span>1666429919792</span><span>)</span>
   <span>[</span>jmeter<span>]</span> Waiting <span>for</span> possible Shutdown/StopTestNow/HeapDump/ThreadDump message on port <span>4445</span>
   <span>[</span>jmeter<span>]</span> summary +      <span>1</span> <span>in</span> 00:00:01 <span>=</span>    <span>1.4</span>/s Avg:   <span>560</span> Min:   <span>560</span> Max:   <span>560</span> Err:     <span>0</span> <span>(</span><span>0.00</span>%<span>)</span> Active: <span>1</span> Started: <span>1</span> Finished: <span>0</span>
   <span>[</span>jmeter<span>]</span> summary <span>=</span>      <span>1</span> <span>in</span> 00:00:01 <span>=</span>    <span>1.4</span>/s Avg:   <span>560</span> Min:   <span>560</span> Max:   <span>560</span> Err:     <span>0</span> <span>(</span><span>0.00</span>%<span>)</span>
   <span>[</span>jmeter<span>]</span> Tidying up <span>..</span>.    @ Sat Oct <span>22</span> <span>17</span>:12:00 CST <span>2022</span> <span>(</span><span>1666429920899</span><span>)</span>
   <span>[</span>jmeter<span>]</span> <span>..</span>. end of run

report:
     <span>[</span>xslt<span>]</span> Processing E:<span>\</span>greenSoftware<span>\</span>apache-jmeter-5.2.1<span>\</span>apache-jmeter-5.2.1<span>\</span>reports<span>\</span>TestReport20221022171155.jtl to E:<span>\</span>greenSoftware<span>\</span>apache-jmeter-5.2.1<span>\</span>apache-jmeter-5.2.1<span>\</span>reports<span>\</span>TestReport20221022171155.html
     <span>[</span>xslt<span>]</span> Loading stylesheet E:<span>\</span>greenSoftware<span>\</span>apache-jmeter-5.2.1<span>\</span>apache-jmeter-5.2.1<span>\</span>extras<span>\</span>jmeter-results-report_21.xsl
     <span>[</span>copy<span>]</span> Copying <span>2</span> files to E:<span>\</span>greenSoftware<span>\</span>apache-jmeter-5.2.1<span>\</span>apache-jmeter-5.2.1<span>\</span>reports

BUILD SUCCESSFUL
Total time: <span>7</span> seconds
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>出现 BUILD SUCCESSFUL 说明运行成功，可以查看下 reports 目录下的测试报告：</p>
<p><img src="./../images/ant2.png" alt="ant2" /></p>
<p>未完待续......</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-10-21T08:47:29.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">JMeter</title>
    <id>https://www.snowji.cn/test/tools/Jmeter/</id>
    <link href="https://www.snowji.cn/test/tools/Jmeter/"/>
    <updated>2022-08-29T06:04:05.000Z</updated>
    <content type="html"><![CDATA[<h1 id="jmeter"> JMeter</h1>
<h2 id="简介"> 简介</h2>
<p>JMeter：是 Apche 公司使用 Java 平台开发的一款测试工具</p>
<h2 id="jmeter-可以做什么"> JMeter 可以做什么</h2>
<ul>
<li>接口测试</li>
<li>性能测试</li>
<li>压力测试</li>
<li>数据库测试</li>
<li>Java 程序测试</li>
</ul>
<h2 id="jmeter-的优点"> JMeter 的优点</h2>
<ul>
<li>开源免费</li>
<li>支持多协议</li>
<li>轻量级</li>
<li>功能强大</li>
</ul>
<h2 id="jmeter-支持的协议"> JMeter 支持的协议</h2>
<ul>
<li>
<p>web：HTTP，HTTPS 站点的 Web1.0 的 Web 2.0 (ajax, flex and flex-ws-amf)</p>
</li>
<li>
<p>Web Services: SOAP / XML-RPC</p>
</li>
<li>
<p>通过 JDBC 驱动程序的数据库</p>
</li>
<li>
<p>目录: LDAP</p>
</li>
<li>
<p>通过 JMS 面向消息的服务</p>
</li>
<li>
<p>邮件协议: POP3, IMAP, SMTP</p>
</li>
<li>
<p>FTP 服务</p>
</li>
</ul>
<h2 id="jmeter-的扩展性体现"> JMeter 的扩展性体现</h2>
<ul>
<li>脚本化的采样器【BeanShell、Groovy】</li>
<li>随意增删的采样器</li>
<li>负载统计信息可以增删定时器</li>
<li>数据分析和可视化插件提供了出色的扩展性和个性化</li>
<li>JMeter 自带方法可以向测试计划提供动态输入或数据处理能力</li>
<li>通过针对 Maven，Gradle 和 Jenkins 的第三方开源库轻松进行持续集成。</li>
</ul>
<h2 id="jmeter-缺点"> JMeter 缺点</h2>
<ul>
<li>
<p>无法验证 JScript 程序</p>
</li>
<li>
<p>无法验证 UI</p>
</li>
</ul>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-29T06:04:05.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">badboy 录制脚本</title>
    <id>https://www.snowji.cn/test/tools/Jmeter/badboy-recording-script/</id>
    <link href="https://www.snowji.cn/test/tools/Jmeter/badboy-recording-script/"/>
    <updated>2022-08-29T06:04:05.000Z</updated>
    <content type="html"><![CDATA[<h1 id="badboy-录制脚本"> badboy 录制脚本</h1>
<p><strong>重点</strong>: 此方式只能录制 Web 端</p>
<h2 id="badboy-下载安装"> badboy 下载安装</h2>
<p>可在网盘下载：<a href="https://pan.baidu.com/s/1sHfcOAe3jm9zeig8iGjJig#list/path=%2F" target="_blank" rel="noopener noreferrer">百度网盘下载链接</a> 密码：6666</p>
<p>下载安装完成后，打开界面，如下所示：</p>
<p><img src="./images/badboy1.png" alt="badboy" /></p>
<h2 id="脚本录制"> 脚本录制</h2>
<p><strong>第一步</strong>：在输入栏中输入要录制的地址</p>
<p><strong>第二步</strong>：打开录制按钮</p>
<p><strong>第三步</strong>：进入页面开始录制</p>
<p><strong>第四步</strong>：录制结束后，停止录制</p>
<p><img src="./images/badboy2.png" alt="badboy" /></p>
<p>录制好后左边的 Step1 下会有 HTTP 请求</p>
<p><img src="./images/badboy3.png" alt="badboy" /></p>
<p><strong>第五步</strong>: 将录制好的脚本导出为 JMeter 脚本</p>
<p><img src="./images/badboy4.png" alt="badboy" /></p>
<p><strong>第六步</strong>：在 JMeter 中打开这个脚本并进行回放</p>
<p><img src="./images/badboy5.png" alt="badboy" /></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-29T06:04:05.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">BeanShell</title>
    <id>https://www.snowji.cn/test/tools/Jmeter/beanshell/</id>
    <link href="https://www.snowji.cn/test/tools/Jmeter/beanshell/"/>
    <updated>2022-08-30T08:47:09.000Z</updated>
    <content type="html"><![CDATA[<h1 id="beanshell"> BeanShell</h1>
<h2 id="什么是-beanshell"> 什么是 BeanShell</h2>
<ul>
<li>
<p>BeanShell 是一种类似 JAVA 的脚本语言</p>
</li>
<li>
<p>通过 BeanShell 可以对请求数据、响应数据或环境变量进行更加灵活的处理和判断</p>
</li>
<li>
<p>还可以直接调用外部的 JAR 包，例如：可以直接引入现成的第三方 JSON 解析包来使用</p>
</li>
</ul>
<p><strong>Jmeter 中 BeanShell</strong>：</p>
<ul>
<li>
<p>定时器：BeanShell Timer</p>
</li>
<li>
<p>前置处理器：BeanShell PreProcessor</p>
</li>
<li>
<p>采样器：BeanShell Sampler</p>
</li>
<li>
<p>后置处理器：BeanShell PostProcessor</p>
</li>
<li>
<p>断言：BeanShell Assert</p>
</li>
<li>
<p>监听器：BeanShell Listener</p>
</li>
</ul>
<h2 id="beanshell的内置变量和方法"> BeanShell的内置变量和方法</h2>
<p>BeanShell 有一些默认的内置变量和方法，用户可以通过这些变量与 JMeter 进行交互</p>
<h3 id="log"> log</h3>
<p><strong>作用</strong>：输出信息到日志</p>
<p><strong>用法</strong>：</p>
<div><pre><code>log<span>.</span><span>debu</span><span>(</span>“调试信息”<span>)</span>

log<span>.</span><span>info</span><span>(</span>“响应状态码” <span>+</span> <span><span>prev<span>.</span></span>ResponseCode</span><span>)</span>
    
log<span>.</span><span>warn</span><span>(</span>“警告信息”<span>)</span>

log<span>.</span><span>error</span><span>(</span>“出错信息”<span>)</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>示例：</p>
<p><img src="./images/beanshell1.png" alt="beanshell" /></p>
<h3 id="prev"> prev</h3>
<p><strong>作用</strong>：获取当前请求结果</p>
<p><strong>用法</strong>：</p>
<div><pre><code>prev<span>.</span><span>getResponseDataAsString</span><span>(</span><span>)</span>：获取响应体数据（<span>String</span> 类型<span>)</span>

prev<span>.</span><span>getResponseCode</span><span>(</span><span>)</span>：获取状态码（同 <span>ResponseCode</span>，<span>String</span> 类型）
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>示例：</p>
<p><img src="./images/beanshell2.png" alt="beanshell" /></p>
<h3 id="vars"> vars</h3>
<p><strong>作用</strong>：操作 JMeter 的变量</p>
<p><strong>用法</strong>：</p>
<div><pre><code>vars<span>.</span><span>get</span><span>(</span>“变量名”<span>)</span>：获取变量的值（假设为 <span>String</span> 类型）

vars<span>.</span><span>put</span><span>(</span>“变量名”<span>,</span> 变量值<span>)</span>：设置变量值
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>示例：</p>
<p><img src="./images/beanshell3.png" alt="beanshell" /></p>
<div><p>注意</p>
<ul>
<li>
<p>vars 设置的变量类似于局部变量</p>
</li>
<li>
<p>vars 不可以跨线程获取变量</p>
</li>
</ul>
</div>
<p><img src="./images/beanshell4.png" alt="beanshell" /></p>
<h3 id="props"> props</h3>
<p><strong>作用</strong>：操作 JMeter 变量，类似 vars</p>
<p><strong>用法</strong>：</p>
<div><pre><code>props<span>.</span><span>get</span><span>(</span>“变量名”<span>)</span>：获取变量的值（假设为 <span>String</span> 类型）

props<span>.</span><span>put</span><span>(</span>“变量名”<span>,</span> 变量值<span>)</span>：设置变量值
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><p>注意</p>
<ul>
<li>
<p>props 设置的变量类似于全局变量</p>
</li>
<li>
<p>props 可以跨线程获取变量</p>
</li>
</ul>
</div>
<p><img src="./images/beanshell5.png" alt="beanshell" /></p>
<h3 id="ctx"> ctx</h3>
<p><strong>作用</strong>：获取当前线程上下文数据（可获取所有信息）</p>
<p><strong>用法</strong>：</p>
<div><pre><code>ctx<span>.</span><span>getVariables</span><span>(</span>“变量名”<span>)</span>：获取变量值（同 vars<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span>

ctx<span>.</span><span>setVariables</span><span>(</span>“变量名”<span>,</span> “变量值”<span>)</span>：设置变量（同 vars<span>.</span><span>put</span><span>(</span><span>)</span><span>)</span>

ctx<span>.</span><span>getProperties</span><span>(</span>“属性名”<span>)</span>：获取属性值（同 props<span>.</span><span>get</span><span>(</span><span>)</span>）

ctx<span>.</span><span>setProperties</span><span>(</span>“属性名”<span>,</span>“属性值”<span>)</span>：设置属性（同 props<span>.</span><span>put</span><span>(</span><span>)</span>）

ctx<span>.</span><span>getPreviousResult</span><span>(</span><span>)</span>：获取当前请求结果同（prev）

ctx<span>.</span><span>getCurrentSampler</span><span>(</span><span>)</span>：获取当前采样器

ctx<span>.</span><span>getPreviousSampler</span><span>(</span><span>)</span>：获取前一采样器

ctx<span>.</span><span>getThreadNum</span><span>(</span><span>)</span>：获取线程数

ctx<span>.</span><span>getThreadGroup</span><span>(</span><span>)</span>：获取线程组

ctx<span>.</span><span>getThread</span><span>(</span><span>)</span>：获取当前线程

ctx<span>.</span><span>getEngine</span><span>(</span><span>)</span>：获取引擎

ctx<span>.</span><span>isSamplingStarted</span><span>(</span><span>)</span>：判断采样器是否启动

ctx<span>.</span><span>isRecording</span><span>(</span><span>)</span>：判断是否开启录制

ctx<span>.</span><span>getSamplerContext</span><span>(</span><span>)</span>：获取采样器上下文数据 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>可参考 JMeter 的 API 文档</p>
<p><img src="./images/beanshell6.png" alt="beanshell" /></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-30T08:47:09.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Counter 计数器</title>
    <id>https://www.snowji.cn/test/tools/Jmeter/counter/</id>
    <link href="https://www.snowji.cn/test/tools/Jmeter/counter/"/>
    <updated>2022-08-30T08:33:55.000Z</updated>
    <content type="html"><![CDATA[<h1 id="counter-计数器"> Counter 计数器</h1>
<h2 id="简介"> 简介</h2>
<p>位置：配置元件中</p>
<p>作用：循环递增生成数字</p>
<p>取值范围：计数器使用 long 来存储值，因此取值范围是 <code>-2 ^ 63 到</code>2 ^ 63-1 `</p>
<p>可在测试计划任一位置添加</p>
<h2 id="界面介绍"> 界面介绍</h2>
<p><img src="./images/counter1.png" alt="counter" /></p>
<p>字段介绍：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Starting value</td>
<td>初始值，long 整型，默认 0</td>
</tr>
<tr>
<td>Increment</td>
<td>每次迭代的递增值，默认 0，表示不增加</td>
</tr>
<tr>
<td>Maximum value</td>
<td>最大值，包含此值</td>
</tr>
<tr>
<td>Number format</td>
<td>数字可选格式</td>
</tr>
<tr>
<td>Exported Variable Name</td>
<td>引用名称</td>
</tr>
<tr>
<td>Track counter independently for rach user</td>
<td>每个用户都有一个独立的计数器</td>
</tr>
<tr>
<td>Reset counter on each Thread Group Iteration</td>
<td>每次线程组迭代时计数器将重置为初始值</td>
</tr>
</tbody>
</table>
<h2 id="counter-实例"> Counter 实例</h2>
<h3 id="基础例子"> 基础例子</h3>
<p>测试计划结构树</p>
<p><img src="./images/counter2.png" alt="counter" /></p>
<p>线程组和 Counter 配置：</p>
<p><img src="./images/counter3.png" alt="counter" /></p>
<p>运行结果：</p>
<p><img src="./images/counter4.png" alt="counter" /></p>
<p>由于设置的 Increment 为 2 ，所以计数器只能计数 5 次，但线程数有 10 个，所以会重新计数</p>
<h3 id="counter-loop-controller"> Counter + Loop Controller</h3>
<p>测试计划结构树：</p>
<p><img src="./images/counter6.png" alt="counter" /></p>
<p>线程组、Counter、Loop Controller 配置：</p>
<p><img src="./images/counter5.png" alt="counter" /></p>
<p>运行结果：</p>
<p><strong>未勾选 Track counter independently for rach user</strong>：</p>
<p><img src="./images/counter7.png" alt="counter" /></p>
<p>以上结果可以看出：</p>
<ul>
<li>因为有 5 个线程，每个线程循环 3 次，一共 15 个请求，所以计数器是循环了 15 次</li>
<li>此时计数器是对<strong>所有线程共享</strong>的，属于线程组全局计数器，所以计数器是累计循环了 15 次</li>
</ul>
<p><strong>勾选 Track counter independently for rach user</strong>：</p>
<p><img src="./images/counter8.png" alt="counter" /></p>
<p>以上结果可以看出：</p>
<ul>
<li>每个线程运行时，计数器都是从初始值算起的</li>
<li>此时计数器是<strong>每个线程独享</strong>的，不再是公共计数器，所以每次有<strong>新的线程运行</strong>时，都是新的计数器开始循环计数</li>
<li>计数器的计数与控制器的循环次数有关</li>
</ul>
<p><strong>注意</strong>：使用计数器生成的变量，值的类型为 string，所以有比较之类的操作时，需要带 &quot;&quot; 操作</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-30T08:33:55.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">CSV Data Set config</title>
    <id>https://www.snowji.cn/test/tools/Jmeter/csv/</id>
    <link href="https://www.snowji.cn/test/tools/Jmeter/csv/"/>
    <updated>2022-09-01T05:58:36.000Z</updated>
    <content type="html"><![CDATA[<h1 id="csv-data-set-config"> CSV Data Set config</h1>
<p>作用：使用 CSV Data Set config 进行参数化设置</p>
<p><strong>适用于大量测试数据时的使用</strong></p>
<h2 id="界面"> 界面</h2>
<p>右击 add--Sample--Config Element--CSV Data Set config 进行添加</p>
<p><img src="./images/csv.png" alt="csv" /></p>
<h2 id="csv-data-set-config-各个参数说明"> CSV Data Set Config 各个参数说明：</h2>
<h3 id="filename"> <strong>Filename</strong></h3>
<p>csv 文件所在的路径以及名称</p>
<p><strong>注意</strong>：不一定要 .csv 文件，亲测 .txt 格式的文件也可以的</p>
<h3 id="file-encoding"> <strong>File encoding</strong></h3>
<p>页面的编码方式，可以不填写</p>
<h3 id="variable-names-comma-delimited"> <strong>Variable Names(comma-delimited)</strong></h3>
<p>变量名，可以在后面被引用</p>
<h3 id="delimiter-use-t-for-tab"> <strong>Delimiter(use '\t' for Tab)</strong></h3>
<p>用来隔开变量的分隔符</p>
<h3 id="allow-quoted-data"> <strong>Allow quoted data?</strong></h3>
<p>是否允许引用数据</p>
<p>目前设置成 True 或者 False 都能正常引用数据</p>
<h3 id="recycle-on-eof"> <strong>Recycle on EOF?</strong></h3>
<p>到了文件尾是否循环</p>
<p>True：继续从文件第一行开始读取</p>
<p>False：不再循环</p>
<h3 id="stop-thread-on-eof"> <strong>Stop thread on EOF?</strong></h3>
<p>到了文件尾是否停止线程</p>
<p>True：停止</p>
<p>False：不停止</p>
<p><strong>注意</strong>：当 Recycle on EOF 设置为 True 时，此项设置无效</p>
<h3 id="sharing-mode"> <strong>Sharing mode</strong></h3>
<p>共享模式</p>
<h4 id="all-threads"> <strong>All threads</strong>：</h4>
<ul>
<li>测试计划中所有线程</li>
<li>假如说有线程1 到线程 n (n&gt;1)，线程1 取了一次值后，线程2 取值时，取到的是 csv 文件中的下一行，即与线程1 取的不是同一行</li>
</ul>
<p>例子：设置 1 个线程组，设置 2 个线程数，选择该模式，可以查看取的数据不一致</p>
<p><img src="./images/all.png" alt="all" /></p>
<h4 id="current-thread-group"> <strong>Current thread group</strong>：</h4>
<ul>
<li>当前线程组</li>
<li>假设有线程组A、线程组B，A组内有线程A1 到线程An，线程组B 内有线程B1 到线程Bn。取之情况是：线程A1 取到了第 1 行，线程A2 取第 2 行，现在B1 取第 1 行，线程B2 取第 2 行</li>
</ul>
<p>例子：设置 2 个线程组，每个线程组设置 1 个线程数，选择该模式，可以查看取的数据一致</p>
<p><img src="./images/all1.png" alt="all" /></p>
<h4 id="current-thread"> <strong>Current thread</strong>：</h4>
<ul>
<li>当前线程</li>
<li>假设测试计划内有线程1 到线程n (n&gt;1)，则线程1 取了第 1 行，线程2 也取第 1 行使用</li>
</ul>
<p>例子：设置 1 个线程组，设置 2 个线程数，选择该模式，可以查看取的数据一致</p>
<p><img src="./images/all2.png" alt="all" /></p>
<p><strong>总结</strong>：</p>
<ul>
<li>要使用 CSV 文件中的所有参数，在线程组中就必须设置线程数或循环次数</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-01T05:58:36.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">安装监听器插件</title>
    <id>https://www.snowji.cn/test/tools/Jmeter/extend-monitor/</id>
    <link href="https://www.snowji.cn/test/tools/Jmeter/extend-monitor/"/>
    <updated>2022-08-29T06:04:05.000Z</updated>
    <content type="html"><![CDATA[<h1 id="安装监听器插件"> 安装监听器插件</h1>
<h2 id="监听器插件下载"> 监听器插件下载</h2>
<blockquote>
<p>官网地址：https://jmeter-plugins.org/downloads/old/</p>
</blockquote>
<p>下载 JMeterPlugins-Standard 和 JMeterPlugins-Extras 包</p>
<p><img src="./images/monitor1.png" alt="images" /></p>
<p>下载完成后，将其进行解压</p>
<h2 id="放置监听器插件"> 放置监听器插件</h2>
<p>找到上面下载并解压的文件夹中的 <code>lib-&gt;ext-&gt;JMeterPlugins-Standard.jar</code>、<code>JMeterPlugins-Extras.jar</code></p>
<p>将这两个文件复制到 JMeter 文件夹的<code>lib-&gt;ext</code> 文件下</p>
<h2 id="重启-jmeter-生效插件配置"> 重启 JMeter 生效插件配置</h2>
<p>上述操作完成后，重新打开 JMeter 监听器，可以发现监听器中出现 jp@gc 等表示监听器插件添加成功</p>
<p><img src="./images/monitor2.png" alt="images" /></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-29T06:04:05.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">ForEach 控制器</title>
    <id>https://www.snowji.cn/test/tools/Jmeter/foreach-controller/</id>
    <link href="https://www.snowji.cn/test/tools/Jmeter/foreach-controller/"/>
    <updated>2022-09-01T03:27:06.000Z</updated>
    <content type="html"><![CDATA[<h1 id="foreach-控制器"> ForEach 控制器</h1>
<p>位置：逻辑控制器中</p>
<h2 id="什么是-foreach-控制器"> 什么是 ForEach 控制器</h2>
<p>用来遍历取出变量的一种控制器</p>
<ul>
<li>ForEach 控制器一般和用户自定义变量或 JDBC 结果变量一起使用，用于可以遍历读取相关的返回值</li>
<li>该控制器下的 Samplers 和控制器都会被执行一次或多次，每次读取不同的变量值</li>
<li>ForEach 控制器可以省略正则提取器提取出来的变量值用 <code>_</code> 分隔的 <code>_</code></li>
</ul>
<h2 id="界面介绍"> 界面介绍</h2>
<p><img src="./images/for1.png" alt="for" /></p>
<p>字段介绍：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Input Variable Prefix</td>
<td>输入变量名的前缀，默认为一个空字符串作为前缀</td>
</tr>
<tr>
<td>Start index for loop(exclusive)</td>
<td>循环开始的索引<br />不包括此值<br />默认从 1 开始</td>
</tr>
<tr>
<td>End index for loop(inclusive)</td>
<td>循环结束的索引<br />包括此值</td>
</tr>
<tr>
<td>Output variable</td>
<td>输出的变量名<br />后面的 sampler 可使用该变量名</td>
</tr>
<tr>
<td>Add”_”before number</td>
<td>输入的变量名和索引之间是否有 <code>_</code> 间隔<br />不勾选的话，则变量名和索引直接相连<br />默认勾选</td>
</tr>
</tbody>
</table>
<h2 id="foreach-控制器实例"> ForEach 控制器实例</h2>
<h3 id="foreach-用户自定义变量"> ForEach + 用户自定义变量</h3>
<p>测试计划结构树：</p>
<p><img src="./images/for.png" alt="for" /></p>
<p>用户自定义变量：</p>
<p><img src="./images/for2.png" alt="for" /></p>
<p>ForEach 勾选 Add”_”before number  ：</p>
<p><img src="./images/for3.png" alt="for" /></p>
<p>测试结果：</p>
<p><img src="./images/for4.png" alt="for" /></p>
<p>上面结果可以看出：</p>
<ul>
<li>Start index for loop(exclusive) 填 1 ，则从第二个变量开始取值</li>
<li>勾选 Add”_”before number 后没有取 第 4 个值</li>
</ul>
<h4 id="无输出变量名"> 无输出变量名</h4>
<p><img src="./images/for5.png" alt="for" /></p>
<p>测试结果：</p>
<p><img src="./images/for4.png" alt="for" /></p>
<p><strong>重点</strong>：无输出变量名时，可使用 <code>${}</code> 获取变量</p>
<h3 id="foreach-jdbc-request"> ForEach + JDBC Request</h3>
<h4 id="使用-variable-names-接收-jdbc-返回的数据"> 使用 Variable Names 接收 JDBC 返回的数据</h4>
<p>测试计划结构树 + JDBC Request：</p>
<p><img src="./images/for6.png" alt="for" /></p>
<p>JDBC 返回的结果：</p>
<p><img src="./images/for7.png" alt="for" /></p>
<p>ForEach:</p>
<p><img src="./images/for8.png" alt="for" /></p>
<p>测试结果：</p>
<p><img src="./images/for9.png" alt="for" /></p>
<h4 id="使用-result-variable-name-接收-jdbc-返回的数据"> 使用 Result variable name 接收 JDBC 返回的数据</h4>
<p>测试计划结构树 + JDBC Request：</p>
<p><img src="./images/for10.png" alt="for" /></p>
<p>JDBC 返回的结果：</p>
<p><img src="./images/for11.png" alt="for" /></p>
<ul>
<li>这里通过 Result Variable name 去接收所有数据，只有一个变量，是无法循环的</li>
<li>所以我们需要通过<strong>正则提取器</strong>将需要的 phone 字段的值提取出来</li>
</ul>
<p>正则提取器：</p>
<p><img src="./images/for12.png" alt="for" /></p>
<p>正则表达式提取的结果：</p>
<p><img src="./images/for13.png" alt="for" /></p>
<p>ForEach:</p>
<p>但是正则会提取不必要的字段值（如：mobile_phone_1_g0），所以注意 ForEach 的输入变量前缀要写正确</p>
<p><img src="./images/for14.png" alt="for" /></p>
<p>测试结果：</p>
<p><img src="./images/for15.png" alt="for" /></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-01T03:27:06.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">HTTP 请求</title>
    <id>https://www.snowji.cn/test/tools/Jmeter/http-request/</id>
    <link href="https://www.snowji.cn/test/tools/Jmeter/http-request/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="http-请求"> HTTP 请求</h1>
<p><strong>前提</strong>：想要更好的掌握 HTTP 请求的配置，需要先了解什么是 HTTP 请求，可以参考：<a href="/basic-skills/network/HTTP%E5%8D%8F%E8%AE%AE">HTTP协议</a></p>
<p>线程组右击选择添加--&gt;取样器--&gt;HTTP请求，界面如下：</p>
<p><img src="./images/http1.png" alt="" /></p>
<h2 id="基本配置"> 基本配置</h2>
<p>字段介绍：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>名称</td>
<td>建议自定义一个识别度高的名称</td>
</tr>
<tr>
<td>注释</td>
<td>对于测试没有任何影响，仅记录作用</td>
</tr>
<tr>
<td>协议</td>
<td>http 或 https，默认：http 不区分大小写</td>
</tr>
<tr>
<td>服务器名称或IP</td>
<td>服务器域名或者 ip，<strong>不包括协议</strong>，如：www.baidu.com、192.168.196.128</td>
</tr>
<tr>
<td>端口号</td>
<td>目标服务器的端口号，**默认：**80</td>
</tr>
<tr>
<td>方法</td>
<td>发送 HTTP 请求的方法</td>
</tr>
<tr>
<td>路径</td>
<td>目标请求的 URL 路径不包括<strong>协议、host、ip、端口</strong></td>
</tr>
<tr>
<td>内容编码</td>
<td>请求的编码方式，**默认：**iso8859</td>
</tr>
<tr>
<td>自动重定向</td>
<td>发出的请求的响应码是 <strong>3xx</strong>，会自动跳转到新目标页面只记录最终页面的返回结果</td>
</tr>
<tr>
<td>跟随重定向</td>
<td>和自动重定向<strong>唯一不同</strong>的是：会记录重定向过程中的的<strong>所有请求</strong>的响应结果</td>
</tr>
<tr>
<td>使用 KeepAlive</td>
<td>JMeter 和目标服务器之间使用 Keep-Alive 方式进行 HTTP 通信真正做性能测试强烈建议不勾选</td>
</tr>
<tr>
<td>对 POST 使用multipart/form-data</td>
<td>POST 请求需要上传文件时勾选</td>
</tr>
<tr>
<td>与浏览器兼容的头</td>
<td>当勾选 multipart/form-data 时，勾选此项 HTTP 请求头中的 Content-Type 和 Content-Transfer-Encoding 被忽略而只发送 Content-Disposition 部分</td>
</tr>
</tbody>
</table>
<h3 id="请求参数"> 请求参数</h3>
<p><img src="./images/http2.png" alt="http2" /></p>
<p>字段介绍：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>名称</td>
<td>参数名</td>
</tr>
<tr>
<td>值</td>
<td>参数值</td>
</tr>
<tr>
<td>URL 编码?</td>
<td>是否要 URL 编码？如果参数值包含了中文、特殊字符（非数字字母以外），最好勾上，当然全都勾上最稳妥</td>
</tr>
<tr>
<td>内容类型</td>
<td>参数值的资源类型**默认：**text/plain</td>
</tr>
<tr>
<td>包含等于?</td>
<td>当你的参数值<strong>为空</strong>的时候，可以选择不包含=，默认勾选如果参数值<strong>不为空</strong>，则不可以取消勾选</td>
</tr>
</tbody>
</table>
<p>例子：百度搜索</p>
<p><img src="./images/http3.png" alt="http3" /></p>
<p>请求参数：</p>
<p><img src="./images/http4.png" alt="http4" /></p>
<p><strong>注意</strong>：</p>
<ul>
<li>最终表单的参数列表会拼接到 URL 中，所以如果包含了中文、特殊字符就要勾选<strong>编码？</strong></li>
<li>使用 GET 请求方式的不能使用消息体数据传参，会无法识别参数</li>
</ul>
<h3 id="消息体数据"> 消息体数据</h3>
<p><img src="./images/http5.png" alt="http5" /></p>
<ul>
<li>传入 Json 格式的数据，JMeter 不能识别为 Json，必须添加请求头 content-type: application/json</li>
<li>参数列表中有参数时，是不能切换到消息体数据的，必须先删除</li>
</ul>
<p>例子：用户登录</p>
<p><strong>注意</strong>：</p>
<ul>
<li>勾选选项【对 POST 使用 multipart/form-data】时，选择 GET  请求时，参数会不生效</li>
<li>添加了请求头时，不要再勾选上述选项，会导致所有的请求参数被<strong>当成文件以二进制传输</strong>，不会被识别，接口会提示参数为空</li>
</ul>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-29T06:22:02.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">JDBC  连接配置</title>
    <id>https://www.snowji.cn/test/tools/Jmeter/jdbc-configuration/</id>
    <link href="https://www.snowji.cn/test/tools/Jmeter/jdbc-configuration/"/>
    <updated>2022-08-30T02:55:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="jdbc-连接配置"> JDBC  连接配置</h1>
<h2 id="前提条件"> 前提条件</h2>
<ul>
<li>本文所述为连接 Mysql</li>
<li>需要先下载连接 Mysql 的 jar 包</li>
</ul>
<p><strong>jar 包下载</strong>：</p>
<p>下载链接：https://dev.mysql.com/downloads/</p>
<p><img src="./images/jdbc1.png" alt="jdbc" /></p>
<p>选择 Connect/J ，选择下图框出来的</p>
<p><img src="./images/jdbc2.png" alt="jdbc" /></p>
<p>选择 ZIP 文件下载</p>
<p><img src="./images/jdbc3.png" alt="jdbc" /></p>
<p>下载完成后，将解压出的 jar 包文件放在 lib/ext 目录下</p>
<h2 id="jdbc-连接配置-2"> JDBC 连接配置</h2>
<p>位置：配置元件中 JDBC Connection Configuration</p>
<p>在配置 JDBC Connection Configuration 前需要在测试计划中引入连接的 jar 包</p>
<p><strong>方式一</strong>：</p>
<p>将上述下载好的 jar 包放入 JMeter 文件下的 lib/ext 目录下，JMeter 启动时，可以自动加载</p>
<p><strong>方式二</strong>：</p>
<p>在测试计划底部引入 jar 包</p>
<p><img src="./images/jdbc6.png" alt="jdbc" /></p>
<h2 id="配置介绍"> 配置介绍</h2>
<p><img src="./images/jdbc5.png" alt="jdbc" /></p>
<p>参数介绍：</p>
<p><strong>Variable Name Bound to Pool 部分</strong>：</p>
<p>Variable Name for created Pool：变量名绑定到池，与 JDBC 取样器中对应</p>
<p><strong>Connection Pool Configuration 部分</strong>：</p>
<p>此部分一般用默认值</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Max Number of Connections</td>
<td>最大连接数，性能测试时，建议填 0</td>
</tr>
<tr>
<td>Max Wait(ms)</td>
<td>在连接池中取回连接最大等待时间</td>
</tr>
<tr>
<td>Time Between Eviction Runs(ms)</td>
<td>线程可空闲时间<br />如果使用当前连接池中某个连接在空闲 Time Between Eviction Runs Millis 时间后仍然没有使用，则被物理性的关闭掉</td>
</tr>
<tr>
<td>Auto Commit</td>
<td>自动提交 SQL 语句</td>
</tr>
<tr>
<td>Transation Isolation</td>
<td>事务隔离级别</td>
</tr>
<tr>
<td>Preinit Pool</td>
<td>立即初始化连接池<br />如果为 False 则第一个 JDBC 的请求的响应时间会比较长，因为包含了连接池建立的时间</td>
</tr>
<tr>
<td>Init SQL statements separated by new line</td>
<td>初始化语句，在连接成功后执行</td>
</tr>
</tbody>
</table>
<p><strong>Connection Validation by Pool  部分</strong>：</p>
<p>验证连接池是否可响应</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Test While Idle</td>
<td>当连接空闲时是否断开</td>
</tr>
<tr>
<td>Soft Min Evictable Idle Time(ms)</td>
<td>连接在池中处于空闲状态的最短时间</td>
</tr>
<tr>
<td>Validation Query</td>
<td>一个简单的查询，确定数据库是否仍在响应<br />默认为 JDBC 驱动程序的 isValid() 方法，适用于许多数据库</td>
</tr>
</tbody>
</table>
<p><strong>Database Connection Configuration 部分</strong>：</p>
<p>数据库连接配置</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Database URL</td>
<td>数据库连接 URL</td>
</tr>
<tr>
<td>JDBC Driver class</td>
<td>数据库驱动，可根据数据库类型下拉选择相应的驱动</td>
</tr>
<tr>
<td>Username</td>
<td>数据库登录用户名</td>
</tr>
<tr>
<td>Password</td>
<td>数据库登录密码</td>
</tr>
<tr>
<td>Connection Properties</td>
<td>建立连接时要设置的连接属性</td>
</tr>
</tbody>
</table>
<p>Database URL 举例</p>
<div><pre><code>jdbc:mysql://localhost:3306/dbname?useUnicode=true&amp;characterEncoding=UTF8&amp;autoReconnect=true&amp;allowMultiQueries=true（允许执行多条 sql）
</code></pre>
<div><span>1</span><br></div></div><p>常见数据库的连接 URL和驱动</p>
<table>
<thead>
<tr>
<th>数据库</th>
<th>驱动</th>
<th>URL</th>
</tr>
</thead>
<tbody>
<tr>
<td>MySQL</td>
<td>com.mysql.jdbc.Driver</td>
<td>jdbc:mysql://host:port/{dbname}</td>
</tr>
<tr>
<td>PostgreSQL</td>
<td>org.postgresql.Driver</td>
<td>jdbc:postgresql:{dbname}</td>
</tr>
<tr>
<td>Oracle</td>
<td>oracle.jdbc.driver.OracleDriver</td>
<td>jdbc:oracle:thin:user/pass@//host:port/service</td>
</tr>
<tr>
<td>sqlServer</td>
<td>com.microsoft.sqlserver.jdbc.SQLServerDriver</td>
<td>jdbc:sqlserver://host:port;databaseName=databaseName</td>
</tr>
</tbody>
</table>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-30T02:55:37.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">If 控制器</title>
    <id>https://www.snowji.cn/test/tools/Jmeter/if-controller/</id>
    <link href="https://www.snowji.cn/test/tools/Jmeter/if-controller/"/>
    <updated>2022-08-30T08:20:13.000Z</updated>
    <content type="html"><![CDATA[<h1 id="if-控制器"> If 控制器</h1>
<p>作用：通过条件来判断是否执行其下的元件</p>
<h2 id="界面介绍"> 界面介绍</h2>
<p><img src="./images/if1.png" alt="if" /></p>
<p>字段说明：</p>
<ul>
<li>**Expression (must evaluate to true or false) ：**表达式（值必须是 true 或 false )，也就是说，在右边文本框中输入的条件值必须是 true 或 false（默认情况下）</li>
<li>**Interpret Condition as Variable Expression?：**默认勾选，将条件解释为变量表达式（有信息提示需要使用<code>${____jexl3 }</code>或 <code>${__groovy }</code> 表达式）</li>
<li>**Evaluate for all children?：**条件作用于每个子项</li>
</ul>
<h2 id="if-控制器实例"> If 控制器实例</h2>
<h3 id="expression-使用非变量"> Expression 使用非变量</h3>
<p>测试计划结构树：</p>
<p><img src="./images\if2.png" alt="if" /></p>
<h4 id="控制器-1"> 控制器 1：</h4>
<p>不勾选 Interpret Condition as Variable Expression</p>
<p><img src="./images\if3.png" alt="if" /></p>
<h4 id="控制器-2"> 控制器 2：</h4>
<p>勾选 Interpret Condition as Variable Expression 使用 <code>__jexl3</code></p>
<p><img src="./images\if4.png" alt="if" /></p>
<h4 id="控制器-3"> 控制器 3：</h4>
<p>勾选 Interpret Condition as Variable Expression 使用 <code>__groovy</code></p>
<p><img src="./images\if5.png" alt="if" /></p>
<p>测试结果：</p>
<p><img src="./images\if6.png" alt="if" /></p>
<h3 id="expression-使用变量"> Expression 使用变量</h3>
<p><strong>注意</strong>：使用变量时，必须勾选 Interpret Condition as Variable Expression</p>
<p>测试计划结构树 + 用户自定义变量：</p>
<p><img src="./images\if7.png" alt="if" /></p>
<p>If 控制器 + 测试结果：</p>
<p><img src="./images\if8.png" alt="if" /></p>
<h3 id="evaluate-for-all-children"> Evaluate for all children</h3>
<p>测试计划结构树 + 用户自定义变量：</p>
<p><img src="./images\if9.png" alt="if" /></p>
<p>If 控制器：</p>
<p><img src="./images\if10.png" alt="if" /></p>
<p>后置脚本处理器：</p>
<p><img src="./images\if11.png" alt="if" /></p>
<p>测试结果：</p>
<p><img src="./images\if12.png" alt="if" /></p>
<p><strong>总结</strong>：</p>
<p>勾选了 Evaluate for all children? 意味着它的每个子元素在运行前都会运行一次 if 控制器里面的条件表达式，看看是否还是 true，是的话就可以运行，false 就不运行</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-30T08:20:13.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">配置文件</title>
    <id>https://www.snowji.cn/test/tools/Jmeter/jmeter-configuration-file/</id>
    <link href="https://www.snowji.cn/test/tools/Jmeter/jmeter-configuration-file/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="配置文件"> 配置文件</h1>
<h2 id="jmeter-properties"> jmeter.properties</h2>
<p>官方配置文档：https://jmeter.apache.org/usermanual/properties_reference.html</p>
<p>所在目录：JMeter 安装目录下的bin目录</p>
<p><strong>是 JMeter 核心配置项文件</strong></p>
<p><strong>注意</strong>：</p>
<p>将需要修改的属性值，复制粘贴到同目录下的 user.properties</p>
<p>**好处：**当 JMeter 升级时，可以避免修改项需要重新应用</p>
<h2 id="常用的配置"> 常用的配置</h2>
<h3 id="语言设置"> 语言设置</h3>
<ul>
<li><code>language=en</code>：默认英文</li>
<li><code>language=zh_CN</code>：可进行修改</li>
</ul>
<p>**注意：**这个只有在 jmeter.properties 文件中声明才会生效，官方也提醒了</p>
<h3 id="编码格式设置"> 编码格式设置</h3>
<ul>
<li><code>sampleresult.default.encoding=ISO-8859-1</code>：默认 ISO-8859-1</li>
<li><code>sampleresult.default.encoding=UTF-8</code>：可以改成常用的 UTF-8</li>
</ul>
<h3 id="输出测试报告模板格式"> 输出测试报告模板格式</h3>
<p><code>jmeter.save.saveservice.output_format=csv</code></p>
<h3 id="捕捉cookie"> 捕捉cookie</h3>
<p>Cookies应该存储为变量</p>
<p><code>CookieManager.save.cookies=false</code>：默认</p>
<p><code>CookieManager.save.cookies=true</code>：将 cookie 存储为变量</p>
<h3 id="快捷方式-ctrl-数字0-9"> 快捷方式（ctrl+数字0-9）</h3>
<ul>
<li><code>gui.quick_0=ThreadGroupGui</code></li>
<li><code>gui.quick_1=HttpTestSampleGui</code></li>
<li><code>gui.quick_2=RegexExtractorGui</code></li>
<li><code>gui.quick_3=AssertionGui</code></li>
<li><code>gui.quick_4=ConstantTimerGui</code></li>
<li><code>gui.quick_5=TestActionGui</code></li>
<li><code>gui.quick_6=JSR223PostProcessor</code></li>
<li><code>gui.quick_7=JSR223PreProcessor</code></li>
<li><code>gui.quick_8=DebugSampler</code></li>
<li><code>gui.quick_9=ViewResultsFullVisualizer</code></li>
</ul>
<h3 id="post-请求头参数-content-type"> POST 请求头参数 Content-Type</h3>
<p>在 5.0 版本之后默认是 false，若不修改则请求中不会添加</p>
<p>post_add_content_type_if_missing=false：默认</p>
<p>post_add_content_type_if_missing=true：添加 Content-Type: application/x-www-form-urlencoded</p>
<h3 id="配置远程主机-host"> 配置远程主机 host</h3>
<p><code>remote_hosts=127.0.0.1</code></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-29T06:04:05.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">JDBC Request</title>
    <id>https://www.snowji.cn/test/tools/Jmeter/jdbc-request/</id>
    <link href="https://www.snowji.cn/test/tools/Jmeter/jdbc-request/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="jdbc-request"> JDBC Request</h1>
<h2 id="前提"> 前提</h2>
<ul>
<li>需要了解 SQL 语句</li>
<li>JDBC Request 主要是向数据库发送请求，获取返回的数据集</li>
<li>需要和 JDBC  Connection Configuration 一起使用，具体配置可参考 <a href="test/tools/Jmeter/JDBC%E8%BF%9E%E6%8E%A5%E9%85%8D%E7%BD%AE">JDBC 连接配置</a></li>
<li>位置：取样器中</li>
</ul>
<h2 id="界面介绍"> 界面介绍</h2>
<p><img src="./images/jdbc7.png" alt="jdbc" /></p>
<p>参数字段：</p>
<p><strong>Variable Name Bound to Pool 部分</strong>：</p>
<p>Variable Name of Pool declared in JDBC Connection Configuration：数据库连接池配置的名称，与 JDBC Connection Configuration 中一致</p>
<p><strong>SQL Query 部分</strong>：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Query Type</td>
<td>SQL 语句的类型</td>
</tr>
<tr>
<td>SQL Query</td>
<td>SQL 语句<br />语句结尾不需要添加 <code>;</code><br />变量用 <code>?</code> 占位</td>
</tr>
<tr>
<td>Parameter values</td>
<td>需要传递的变量值，多个变量用 <code>,</code> 分隔</td>
</tr>
<tr>
<td>Parameter types</td>
<td>变量类型</td>
</tr>
<tr>
<td>Variable Names</td>
<td>保存 SQL 语句返回的数据和返回数据的总行数<br />用 <code>,</code> 分隔</td>
</tr>
<tr>
<td>Result Variable Name</td>
<td>一个 Object 变量存储所有返回值</td>
</tr>
<tr>
<td>Query timeout(s)</td>
<td>超时时间；默认0，代表无限时间</td>
</tr>
<tr>
<td>Limit ResultSet</td>
<td>和 limit 类似作用，限制 sql 语句返回结果集的行数</td>
</tr>
<tr>
<td>Handle ResultSet</td>
<td>如何定义 callable statements 返回的结果集；默认是存储为字符串</td>
</tr>
</tbody>
</table>
<h2 id="实例"> 实例</h2>
<h3 id="纯-sql-的例子"> 纯 SQL 的例子</h3>
<p>JDBC  Request</p>
<p><img src="./images/jdbc8.png" alt="jdbc" /></p>
<p>输入的是 SQL 语句，不同类型的语句需要选择不同的 Query Type</p>
<p>运行结果：</p>
<p><img src="./images/jdbc9.png" alt="jdbc" /></p>
<h3 id="使用参数的例子"> 使用参数的例子</h3>
<p>JDBC Request</p>
<p><img src="./images/jdbc10.png" alt="jdbc" /></p>
<p>运行结果：</p>
<p><img src="./images/jdbc11.png" alt="jdbc" /></p>
<p><strong>注意</strong>:</p>
<ul>
<li>Parameter value、Parameter type 填写<strong>值的数量要与语句中的参数个数保持一致</strong>，用,分隔</li>
<li>问号是<strong>占位符</strong>，可以<strong>避免 SQL 注入</strong>的问题</li>
<li>SQL 中<strong>使用占位符</strong>时，<strong>Query Type</strong> <strong>必须选择</strong> Prepared Select Statement 或者 Prepared Update Statement</li>
<li>如果在 Parameter values 中使用变量，且是字符串类型，不需要加上引号，只需要在 Parameter types 里写明为 varchar 即可</li>
</ul>
<h3 id="使用变量的例子"> 使用变量的例子</h3>
<p>JDBC Request</p>
<p>在测试计划中添加一个用户自定义的变量：nick</p>
<p><img src="./images/jdbc12.png" alt="jdbc" /></p>
<p>运行结果：</p>
<p><img src="./images/jdbc11.png" alt="jdbc" /></p>
<p><strong>重点</strong>:</p>
<ul>
<li>如果在 SQL 语句中使用变量，且是字符串类型，需要加上引号（前提是变量值没有加引号），如 <code>${nick_name}</code></li>
</ul>
<h2 id="使用-variable-names-的例子"> 使用 Variable Names 的例子</h2>
<p>JDBC Request</p>
<p>这里添加了 Debug Sample</p>
<p><img src="./images/jdbc14.png" alt="jdbc" /></p>
<p>运行结果：</p>
<p><img src="./images/jdbc13.png" alt="jdbc" /></p>
<p>Debug Sample 结果：</p>
<p><img src="./images/jdbc15.png" alt="jdbc" /></p>
<p><strong>重点</strong>：</p>
<ul>
<li>test：数据库连接池对象</li>
<li><code>a_#</code>、<code>b_#</code>、<code>c_#</code>、<code>d_#</code>：代表第几列，从第一列开始</li>
<li><code>a_#</code>=3：第一列取 3 行数据，因为 SQL 中限制了 limit = 3</li>
<li>a_1：第 1 列、第 1 行</li>
<li>b_2：第 2 列、第 2 行</li>
<li>以此类推....</li>
<li>一般如果 HTTP 请求需要用到 SQL 查出来的数据的话，就会用到 Variable names 这个字段</li>
</ul>
<h2 id="使用-result-variable-name-的例子"> 使用 Result variable name 的例子</h2>
<p>JDBC Request</p>
<p><img src="./images/jdbc16.png" alt="jdbc" /></p>
<p>运行的 Request 结果和 Debug Sample 的结果：</p>
<p><img src="./images/jdbc17.png" alt="jdbc" /></p>
<p><strong>注意</strong>：Result variable name 的结果是一个数组，每个元素代表一个记录</p>
<h2 id="使用-limit-resultset-的例子"> 使用 Limit ResultSet 的例子</h2>
<p>JDBC Request</p>
<p><img src="./images/jdbc18.png" alt="jdbc" /></p>
<p>运行结果：</p>
<p><img src="./images/jdbc13.png" alt="jdbc" /></p>
<p><strong>重点</strong>：</p>
<ul>
<li>Limit ResultSet 是对 SQL 语句返回的结果集限制行数</li>
<li><code>imit 10</code> 限制只返回了 10 条数据，然后 <code>Limit ResultSet = 3</code> 限制结果集最终只返回 3 条数据</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-01T03:06:41.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Linux 下安装 JMeter</title>
    <id>https://www.snowji.cn/test/tools/Jmeter/jmeter-install-linux/</id>
    <link href="https://www.snowji.cn/test/tools/Jmeter/jmeter-install-linux/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="linux-下安装-jmeter"> Linux 下安装 JMeter</h1>
<h2 id="安装步骤"> 安装步骤</h2>
<ul>
<li>
<p>下载 Linux 版本相应的 JMeter 版本</p>
<p>apache-jmeter-5.3.tar</p>
<p>解压 <code>tar -zxvf apache-jmeter-5.3.tar</code></p>
</li>
<li>
<p>是否安装 jdk 环境</p>
<p><code>Java -version</code></p>
<p>注意：jdk 必须是 Java 8 以上版本</p>
<p>如果没有安装，需要先安装，如何安装，自行百度</p>
</li>
<li>
<p>添加到环境变量</p>
<p><code>vi /etc/profile</code>，在文件末尾添加以下三行：</p>
<div><pre><code><span>export</span> <span>JMETER_HOME</span><span>=</span>/usr/local/apache-jmeter-5.3
<span>export</span> <span>CLASSPATH</span><span>=</span><span>$JMETER_HOME</span>/lib/ext/ApacheJMeter_core.jar:<span>$JMETER_HOME</span>/lib/jorphan.jar:<span>$CLASSPATH</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
</ul>
<p>export PATH=$JMETER_HOME/bin:$PATH</p>
<div><pre><code>
添加完成之后，使用 `source /etc/profile` 命令使环境变量生效

输入：`jmeter -v` 如果出现以下信息，则表示安装成功

```shell
   / \  |  _ \ / \  / ___| | | | ____|     | |  \/  | ____|_   _| ____|  _ \
/ _ \ | |_) / _ \| |   | |_| |  _|    _  | | |\/| |  _|   | | |  _| | |_) |
 / ___ \|  __/ ___ \ |___|  _  | |___  | |_| | |  | | |___  | | | |___|  _ &lt;
/_/   \_\_| /_/   \_\____|_| |_|_____|  \___/|_|  |_|_____| |_| |_____|_| \_\ 5.3

Copyright (c) 1999-2020 The Apache Software Foundation
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="运行-jmeter"> 运行 JMeter</h2>
<ul>
<li>
<p>在 windows 环境写好脚本后，将脚本上传到已安装 Jmeter 的 Linux 环境中</p>
</li>
<li>
<p>执行命令：<code>jmeter -n -t test.jmx -l test.jtl</code></p>
<p>参数解释：</p>
<div><pre><code>-h 帮助 -<span>></span> 打印出有用的信息并退出

-n 非 GUI 模式 -<span>></span> 在非 GUI 模式下运行 JMeter

-t 测试文件 -<span>></span> 要运行的 JMeter 测试脚本文件

-l 日志文件 -<span>></span> 记录结果的文件

-r 远程执行 -<span>></span> 启动远程服务

-H 代理主机 -<span>></span> 设置 JMeter 使用的代理主机

-P 代理端口 -<span>></span> 设置 JMeter 使用的代理主机的端口号
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div></li>
<li>
<p>运行完成后，会在当前目录生成一个 test.jtl 的文件，可以将文件下载到 windows 上的 jmeter 中查看，也可生成 html 文件下载后查看</p>
<p>注意：拷到windows机器，打开windows 上的 jmeter（注意：Linux上的 jdk 和 jmeter 版本必须和windows 上的保持一致，包括插件也要一致</p>
<p>生成 html 文件需执行命令：<code>jmeter -g -test.jtl -o report</code>，在 report 文件夹中含有 index.html 文件，直接打开即可查看</p>
</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-29T06:04:05.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">HTTP 请求默认值</title>
    <id>https://www.snowji.cn/test/tools/Jmeter/http-request-default/</id>
    <link href="https://www.snowji.cn/test/tools/Jmeter/http-request-default/"/>
    <updated>2022-08-30T08:11:01.000Z</updated>
    <content type="html"><![CDATA[<h1 id="http-请求默认值"> HTTP 请求默认值</h1>
<h2 id="界面介绍"> 界面介绍</h2>
<p><img src="./images/http-default1.png" alt="http" /></p>
<p>界面与 HTTP Resquest 类似，就不重复介绍字段值意思啦</p>
<p>HTTP 请求默认值，可以添加在测试计划、线程组、HTTP 请求下</p>
<p><strong>思考</strong>：既然测试计划、线程组、HTTP 请求下都可以添加，那优先级顺序是什么样子的呢？</p>
<h2 id="请求默认值优先级"> 请求默认值优先级</h2>
<p>先看个例子：</p>
<p>创建一个测试计划，下面创建 2 个线程组，每个线程组下创建 2 个 HTTP 请求，测试计划、线程组、HTTP 请求下分别创建一个 HTTP 请求默认值，如图：</p>
<p><img src="./images/test-plan.png" alt="test-plan" /></p>
<p>配置如下：</p>
<p><strong>测试计划下的 HTTP 请求默认值配置(后面简称 1)</strong>：</p>
<p><img src="./images/plan-1.png" alt="plan-1" /></p>
<p><strong>线程组1 下的 HTTP 请求默认值配置(后面简称 2)</strong>:</p>
<p><img src="./images/plan-2.png" alt="plan-1" /></p>
<p><strong>HTTP1 下的 HTTP 请求默认值配置(后面简称 3)</strong>:</p>
<p><img src="./images/plan-3.png" alt="plan-1" /></p>
<p><strong>HTTP2 配置了个参数</strong>:</p>
<p><img src="./images/plan-4.png" alt="plan-1" /></p>
<p>其他 HTTP 请求暂无其他配置</p>
<p><strong>运行查看结果</strong>：</p>
<p>HTTP1：</p>
<ul>
<li>使用了 3 请求默认值中的协议、端口、编码</li>
<li>请求了 3 请求默认值中的 url，覆盖了其他 1 和 2 的请求默认值中的 url</li>
<li>参数拼接了 1 和 2 请求默认值中设置的参数</li>
</ul>
<p><img src="./images/response1.png" alt="response" /></p>
<p>HTTP2：</p>
<ul>
<li>使用了 2 请求默认值中的协议、端口和 1 请求默认值中的编码</li>
<li>请求了 1 请求默认值中的 url</li>
<li>参数拼接了 1 和 2 请求默认值中和本身 HTTP 请求中设置的参数</li>
</ul>
<p><img src="./images/response2.png" alt="response" /></p>
<p>HTTP3、HTTP4：</p>
<p>所在线程组由于没有设置额外的请求默认值，本身请求也没有设置，所以请求的是 1 请求默认值中的 URL，使用的也是 1 中设置的协议、端口和编码、参数</p>
<p><img src="./images/response3.png" alt="response" /></p>
<p><strong>总结</strong>：</p>
<ul>
<li>测试计划、线程组、HTTP 请求均可添加请求默认值</li>
<li>测试计划下请求默认值的作用域是<strong>所有线程组中的 HTTP 请求</strong></li>
<li>线程组下的请求默认值的作用域是<strong>该线程组下的所有 HTTP 请求</strong></li>
<li>HTTP 请求下的请求默认值的作用域是<strong>该 HTTP 请求</strong></li>
<li>优先顺序：HTTP 本身请求 &gt; HTTP 请求下的默认值 &gt; 线程组下的请求默认值 &gt; 测试计划下的请求默认值</li>
<li>参数不会按照上述的优先顺序，所有请求默认值中的参数或请求体会被拼接(Json 格式的请求体不会被合并)</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-30T08:11:01.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">目录介绍</title>
    <id>https://www.snowji.cn/test/tools/Jmeter/jmeter-catalogue/</id>
    <link href="https://www.snowji.cn/test/tools/Jmeter/jmeter-catalogue/"/>
    <updated>2022-08-29T06:04:05.000Z</updated>
    <content type="html"><![CDATA[<h1 id="目录介绍"> 目录介绍</h1>
<h2 id="jmeter-安装目录说明"> JMeter 安装目录说明</h2>
<p>JMeter 版本：5.4.3</p>
<p>[<img src="./images/content.png" alt="img" /></p>
<table>
<thead>
<tr>
<th>文件夹</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>bin</td>
<td>包含启动、配置等相关命令自己写的脚本默认另存为该目录下</td>
</tr>
<tr>
<td>docs</td>
<td>官方接口文档，二次开发需要了解的一些接口</td>
</tr>
<tr>
<td>extras</td>
<td>辅助库，持续集成会用到（后面讲）</td>
</tr>
<tr>
<td>lib</td>
<td>存放各种 JMeter 核心库的源码 jar 包存放自己二次开发的 jar 包</td>
</tr>
<tr>
<td>lib\ext</td>
<td>官方提供的第三方插件</td>
</tr>
<tr>
<td>license</td>
<td>包含 non-ASF 软件的许可证</td>
</tr>
<tr>
<td>printable_docs</td>
<td>离线的帮助文档，可以查看函数等内容</td>
</tr>
<tr>
<td>LICENSE</td>
<td>JMeter 许可说明</td>
</tr>
<tr>
<td>NOTICE</td>
<td>JMeter 简单信息说明</td>
</tr>
<tr>
<td>README.md</td>
<td>JMeter 官方基本介绍</td>
</tr>
</tbody>
</table>
<h3 id="bin目录-重点"> bin目录(重点)</h3>
<p><img src="./images/bin.png" alt="img1" /></p>
<table>
<thead>
<tr>
<th>文件</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>jmeter.properties</td>
<td>JMeter 核心配置文件，各种配置基本在这完成</td>
</tr>
<tr>
<td>log4j2.xml</td>
<td>JMeter 日志配置管理</td>
</tr>
<tr>
<td>jmeter.log</td>
<td>JMeter 运行日志记录，什么输出信息、警告、报错都在这里进行了记录</td>
</tr>
<tr>
<td>jmeter.bat</td>
<td>windows 下 JMeter 的<strong>启动</strong>文件，**带 **cmd 窗口</td>
</tr>
<tr>
<td>jmeterw.cmd</td>
<td>windows 下 JMeter 的<strong>启动</strong>文件，<strong>不带</strong> cmd 窗口</td>
</tr>
<tr>
<td>shutdown.cmd</td>
<td>windows 下 JMeter 的<strong>关闭</strong>文件</td>
</tr>
<tr>
<td>stoptest.cmd</td>
<td>windows 下 JMeter 停止测试的文件</td>
</tr>
<tr>
<td>jmeter-server.bat</td>
<td>windows 下 JMeter 服务器模式的启动文件</td>
</tr>
<tr>
<td>jmeter-server</td>
<td>mac 或者 Liunx 分布式压测使用的启动文件</td>
</tr>
</tbody>
</table>
<h3 id="docs-目录"> docs 目录</h3>
<p>主要是 JMeter 的接口文档目录</p>
<p>可以打开页面查看</p>
<h3 id="extras-目录"> extras 目录</h3>
<p>扩展插件目录</p>
<h3 id="lib-目录"> lib 目录</h3>
<p>jar 包存放的目录</p>
<ul>
<li>lib：存放 JMeter 所依赖的外部 jar</li>
<li>lib\ext：存放 JMeter 所依赖的核心 jar,插件包也在此目录下</li>
<li>lib\junit：存放 Junit 测试脚本</li>
</ul>
<h3 id="licenses-目录"> Licenses 目录</h3>
<p>JMeter 证书目录</p>
<h3 id="printable-docs目录"> Printable_docs目录</h3>
<p><code>Printable_docs</code> 的 usermanual 子目录下的内容是 JMeter 的用户手册文档</p>
<p>usermanual 下 <code>component_reference.html</code> 是最常用到的核心元件帮助文档</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-29T06:04:05.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Jmeter 安装</title>
    <id>https://www.snowji.cn/test/tools/Jmeter/jmeter-install-windows/</id>
    <link href="https://www.snowji.cn/test/tools/Jmeter/jmeter-install-windows/"/>
    <updated>2022-08-29T06:04:05.000Z</updated>
    <content type="html"><![CDATA[<h1 id="jmeter-安装"> Jmeter 安装</h1>
<h2 id="下载"> 下载</h2>
<p>http://jmeter.apache.org/ 下载最新版本的 JMeter，解压文件到任意目录</p>
<p><strong>注意</strong>：不要放在<strong>含有中文</strong>的目录下</p>
<h2 id="安装依赖环境"> 安装依赖环境</h2>
<h3 id="jdk-安装"> JDK 安装</h3>
<h4 id="下载-2"> 下载</h4>
<p>https://www.oracle.com/java/technologies/javase-jdk8-downloads.html</p>
<p>下载成功后进行安装，记住安装的目录</p>
<h4 id="配置-java-环境"> 配置 Java 环境</h4>
<ul>
<li>
<p>在高级设置中点击环境变量选项</p>
<p><img src="./images/path1.png" alt="path1" /></p>
</li>
<li>
<p>在环境变量中添加新建一个 JAVA_HOME 变量，设置之前安装 JDK 的目录</p>
<p><img src="./images/path2.png" alt="path2" /></p>
</li>
<li>
<p>将 JAVA_HOME 配置到 path 中</p>
<p><img src="./images/path3.png" alt="path3" /></p>
</li>
<li>
<p>点击确定后，Java 环境变量就安装好了，可以在 cmd 中运行命令进行查看</p>
<p><img src="./images/path4.png" alt="path4" /></p>
</li>
</ul>
<h3 id="配置-jmeter-环境"> 配置 JMeter 环境</h3>
<h4 id="下载-3"> 下载</h4>
<p>https://jmeter.apache.org/download_jmeter.cgi 下载 .zip 的文件</p>
<p>下载完成后解压，</p>
<h4 id="打开界面"> 打开界面</h4>
<p>可以有两种方式打开</p>
<ul>
<li>执行 .bat 文件</li>
</ul>
<p>在目录中 bin 目录下双击 jmeter.bat 即可打开</p>
<ul>
<li>
<p>配置 JMeter 环境</p>
<p>类似于配置 Java 的环境，新建 JMeter 的变量，并添加进 path 中</p>
<p>在 cmd 窗口中输入 jmeter，即可打开 JMeter</p>
<p><img src="./images/path5.png" alt="path5" /></p>
<p>上述操作 cmd 窗口会一直显示，如果想要关闭，可以输入 jmeterw，此时就不会显示 cmd 窗口了</p>
</li>
</ul>
<h3 id="jmeter-运行原理"> JMeter 运行原理</h3>
<ul>
<li>JMeter 是运行在 jvm 虚拟机上的</li>
<li>JMeter 是以线程的方式运行的，减少负载机</li>
<li>JMeter 通过线程组驱动多个线程执行</li>
<li>GUI 模式一般用来调试，压力测试一般在非 GUI 模式下进行</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-29T06:04:05.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">JMeter 界面介绍</title>
    <id>https://www.snowji.cn/test/tools/Jmeter/jmeter-interface-introduction/</id>
    <link href="https://www.snowji.cn/test/tools/Jmeter/jmeter-interface-introduction/"/>
    <updated>2022-08-29T06:04:05.000Z</updated>
    <content type="html"><![CDATA[<h1 id="jmeter-界面介绍"> JMeter 界面介绍</h1>
<p><strong>主页面布局</strong>：</p>
<p>JMeter 的主界面布局分为标题栏、菜单栏、工具栏、树形标签栏和内容栏</p>
<ul>
<li>标题栏：主要显示计划信息及 JMeter 版本</li>
<li>菜单栏：全部的功能都包含在菜单栏中</li>
<li>工具栏：工具栏中的按钮在菜单栏都可以找到，显示了常用功能的快捷按钮</li>
<li>树形标签栏：显示测试计划相关的标签</li>
<li>内容栏：配合树形标签显示，选中哪个标签，内容栏中就显示相应内容和操作</li>
</ul>
<p><img src="./images/jm.png" alt="jm" /></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-29T06:04:05.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">JMeter 录制脚本</title>
    <id>https://www.snowji.cn/test/tools/Jmeter/jmeter-transcribe/</id>
    <link href="https://www.snowji.cn/test/tools/Jmeter/jmeter-transcribe/"/>
    <updated>2022-08-29T06:04:05.000Z</updated>
    <content type="html"><![CDATA[<h1 id="jmeter-录制脚本"> JMeter 录制脚本</h1>
<p>需要使用 JMeter 的代理服务</p>
<h2 id="代理服务界面"> 代理服务界面：</h2>
<p>测试计划中邮件添加非测试元件：</p>
<p><img src="./images/proxy1.png" alt="proxy" /></p>
<p>参数说明：</p>
<p><strong>State</strong>：</p>
<p>代理服务器的状态</p>
<p><strong>Global Settings</strong>：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Port</td>
<td>JMeter 作为代理服务器的端口号</td>
</tr>
<tr>
<td>HTTPS Domains</td>
<td>添加 HTTPS 请求的域名，如果有多个用 , 隔开</td>
</tr>
</tbody>
</table>
<p><strong>Test Plan Creation</strong>：</p>
<p>test plan content：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Target Controller</td>
<td>录制脚本保存的节点</td>
</tr>
<tr>
<td>Grouping</td>
<td>分组方式：<br />不对样本分组，请求什么就记录什么<br />在组间添加分隔，每一个 sampler 结束都会有分隔符间隔开<br />每个组放入一个控制器，在每个 sampler 请求开始时会生成一个简单控制器<br />只存储每个组的第一个样本，每个 sampler 请求时，如果有子请求，不会记录子请求<br />每个 sampler 请求开始时会生成一个事务控制器</td>
</tr>
<tr>
<td>Capture HTTP Header</td>
<td>勾选，请求时会记录 HTTP 信息头</td>
</tr>
<tr>
<td>Add Assertions</td>
<td>勾选，请求时会记录断言</td>
</tr>
<tr>
<td>Regex matching</td>
<td>正则表达式匹配</td>
</tr>
</tbody>
</table>
<p>HTTP Sampler settings:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Transaction name</td>
<td></td>
</tr>
<tr>
<td>Naming scheme</td>
<td></td>
</tr>
<tr>
<td>Counter start value</td>
<td></td>
</tr>
<tr>
<td>Create new transaction after request(ms)</td>
<td></td>
</tr>
<tr>
<td>Recording`s default encoding</td>
<td></td>
</tr>
<tr>
<td>Retrieve All Embedded Resources</td>
<td></td>
</tr>
<tr>
<td>Redirect Automatically</td>
<td></td>
</tr>
<tr>
<td>Follow Redirects</td>
<td></td>
</tr>
<tr>
<td>Use KeepAlive</td>
<td></td>
</tr>
<tr>
<td>Type</td>
<td></td>
</tr>
</tbody>
</table>
<p>GraphQL HTTP Sampler settings:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Delete GraphQL Request</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Requests Filtering</strong>:</p>
<p>Content-type filter:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Include</td>
<td>Content-type 包含模式，填的是正则表达式</td>
</tr>
<tr>
<td>Exclude</td>
<td>Content-type 排除模式，填的是正则表达式</td>
</tr>
</tbody>
</table>
<p>URL Patterns to Include:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>URL Patterns to Include</td>
<td>URL 模式包含</td>
</tr>
</tbody>
</table>
<p>URL Patterns to Exclude:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>URL Patterns to Exclude</td>
<td></td>
</tr>
</tbody>
</table>
<p>Notify Child Listeners of filtered samplers:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Notify Child Listeners of filtered samplers</td>
<td>后台监听 sampler，app 后台运行时有请求时需要勾选</td>
</tr>
</tbody>
</table>
<h2 id="录制实例"> 录制实例</h2>
<p>以录制移动端脚本为例</p>
<ul>
<li>代理端口号设置为 8888，HTTPS Domain 为 localhost（代表运行 JMeter 的机器作为代理服务器），其余设置默认，点击 start 按钮启动</li>
</ul>
<p><img src="./images/proxy2.png" alt="proxy" /></p>
<ul>
<li>
<p>设置移动端代理</p>
<p><strong>注意</strong>：移动端连接的网络必须要和代理服务器在<strong>同一网络</strong></p>
<p><img src="./images/proxy3.png" alt="proxy" /></p>
</li>
<li>
<p>设置完成后，进行录制，可以在 Thread Group 下生成脚本，可以对录制的脚本进行回放</p>
<p><img src="./images/proxy4.png" alt="proxy" /></p>
</li>
</ul>
<p>代理录制 Web 端时，同样需要设置浏览器代理</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-29T06:04:05.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">JSON 提取器</title>
    <id>https://www.snowji.cn/test/tools/Jmeter/json-extractor/</id>
    <link href="https://www.snowji.cn/test/tools/Jmeter/json-extractor/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="json-提取器"> JSON 提取器</h1>
<p>位置：后置处理器中</p>
<h2 id="什么是-json-提取器"> 什么是 JSON 提取器</h2>
<p>用来提取 JSON 数据的一种方式</p>
<h2 id="为什么要用-json-提取器"> 为什么要用 JSON 提取器</h2>
<ul>
<li>JSON 是目前大多数接口响应内容的数据格式</li>
<li>在接口测试中，不同接口之间可能会有<strong>数据依赖</strong>，在 Jmeter 中可以通过后置处理器来提取接口的响应内容</li>
<li>JSON 提取器是其中一个可以用来提取响应内容的元件</li>
</ul>
<h3 id="json-提取器的应用场景"> JSON 提取器的应用场景</h3>
<ul>
<li>提取某个特定的值</li>
<li>提取多个值</li>
<li>按条件取值</li>
<li>提取值组成的列表</li>
</ul>
<h2 id="界面介绍"> 界面介绍</h2>
<p><img src="./images/json1.png" alt="json" /></p>
<p>字段介绍：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Apply to</td>
<td>应用范围，默认是 Main sample only</td>
</tr>
<tr>
<td>Names of created variables</td>
<td>提取值的变量名<br />多个变量使用 <code>;</code> 分隔<br />必填项</td>
</tr>
<tr>
<td>JSON Path expressions</td>
<td>JSON Path 表达式，提取某个值<br />多个表达式用 <code>;</code> 分隔<br />必填项</td>
</tr>
<tr>
<td>Match No.(0 for Random)</td>
<td>获取提取的值：<br />0：代表随机取<br />-1：表示取所有值<br />1：取第一个值<br /><br />若值大于匹配总数，在设置了缺省值的情况下返回缺省值，否则返回空<br />非必填项</td>
</tr>
<tr>
<td>Compute concatenation var(suffix_ALL)</td>
<td>如果匹配多个值，将使用 <code>,</code> 分隔符将他们连接起来并存储<br />存储在名为 <code>&lt;variable name&gt;_ALL</code> 的 var 中</td>
</tr>
<tr>
<td>Defaults Values</td>
<td>缺省值，匹配不到时取改值，可写 error<br />非必填项</td>
</tr>
</tbody>
</table>
<h2 id="json-提取器实例"> JSON 提取器实例</h2>
<p>在介绍例子之前，首先先来学习下 JSON Path 的语法</p>
<h3 id="json-path-语法"> JSON Path 语法</h3>
<ul>
<li>$: 代表整个 JSON 数据，根节点</li>
<li>. : 代表下个节点</li>
</ul>
<h3 id="实例应用"> 实例应用</h3>
<p>测试结构树：</p>
<p><img src="./images/json2.png" alt="json" /></p>
<p>查看用户接口需要在请求头中添加登录后获取的 token，配置如下：</p>
<p><img src="./images/json3.png" alt="json" /></p>
<h4 id="提取单个值"> 提取单个值</h4>
<table>
<thead>
<tr>
<th>JSON Path</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>$.data.total(绝对路径方式)</td>
<td>3</td>
</tr>
<tr>
<td>$..total(相对路径方式)</td>
<td>3</td>
</tr>
<tr>
<td>$..users[0].role</td>
<td>user</td>
</tr>
<tr>
<td>$.data.users[0].ext_info.yesapi_points</td>
<td>0</td>
</tr>
</tbody>
</table>
<h5 id="切片提取单个值"> 切片提取单个值</h5>
<p>与 Python 中的切片类似</p>
<table>
<thead>
<tr>
<th><strong>JSON Path</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>$..name[2]</td>
<td>第三个 name</td>
</tr>
<tr>
<td>$..name[-2]</td>
<td>倒数第二个 name</td>
</tr>
<tr>
<td>$..name[0,1]</td>
<td>前面两个 name</td>
</tr>
<tr>
<td>$..name[:2]</td>
<td>第一、二个 name</td>
</tr>
<tr>
<td>$..name[1:2]</td>
<td>第二个 name</td>
</tr>
<tr>
<td>$..name[-2:]</td>
<td>倒数两个 name</td>
</tr>
<tr>
<td>$..name[1:]</td>
<td>第二个开始的所有 name</td>
</tr>
</tbody>
</table>
<h4 id="提取多个值"> 提取多个值</h4>
<p><strong>注意</strong>: 提取多个值时 Match No. 必须填 -1</p>
<div><pre><code>以下几种几种方式均可：
$..name
$.data[*]..name
$..[*].name
$.data..name
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>重点</strong>:</p>
<ul>
<li><strong>不能</strong>通过取下标的方式（ name[0] ）来获取值，因为默认是获取 <strong>ASCII码大</strong>的那个值 ，除非提取器设置了 Match No</li>
<li>调用变量时，不再是 ${name} 而是 ·${name_1} 、 ${name_2}</li>
</ul>
<h4 id="按条件取值"> 按条件取值</h4>
<p>格式：</p>
<div><pre><code>[?(expression)]
</code></pre>
<div><span>1</span><br></div></div><p>例子：</p>
<table>
<thead>
<tr>
<th>JSON Path</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>$..data[*].[?(@.name==&quot;xiaoai&quot;)]</td>
<td>提取 name 等于 “xiaoai” 的记录</td>
</tr>
<tr>
<td>$..data[*].[?(@.lastLoginTime &gt; &quot;2021-07-20&quot;)]</td>
<td>提取 lastLoginTime 字段大于 2021-07-20 的记录</td>
</tr>
<tr>
<td>$.data[?(@.total)]</td>
<td>提取 data 中包含 total 字段的记录</td>
</tr>
<tr>
<td>$..data[*].[?(@.name=~/.*xiaoai.*?/)]</td>
<td>提取 name 中包含 “xiaoai” 的记录</td>
</tr>
</tbody>
</table>
<p><strong>@</strong>：代表当前节点</p>
<p><strong>=~</strong></p>
<ul>
<li>后面跟正则表达式，如果想提取<strong>包含指定字符</strong>的值，可以使用此正则：/.<em>指定字符串.</em>?/i</li>
<li>i 代表大小写不敏感</li>
</ul>
<h4 id="勾选-compute-concatenation-var"> 勾选 Compute concatenation var</h4>
<p>JSON 提取器</p>
<p><img src="./images/json6.png" alt="json" /></p>
<p>结果：</p>
<div><pre><code>name_1=zhangsan
name_2=lisi
name_3=wangwu
name_ALL=zhangsan,lisi,wangwu
name_matchNr=3
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="提取多个变量"> 提取多个变量</h4>
<p><img src="./images/json7.png" alt="json" /></p>
<p><strong>注意</strong>：</p>
<p>提取多个变量时，<code>Default Values</code>  必须填写</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-01T01:39:57.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">正则提取器</title>
    <id>https://www.snowji.cn/test/tools/Jmeter/regularity-extractor/</id>
    <link href="https://www.snowji.cn/test/tools/Jmeter/regularity-extractor/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="正则提取器"> 正则提取器</h1>
<p>位置：后置处理器中</p>
<h2 id="什么是正则提取器"> 什么是正则提取器</h2>
<p>使用正则表达式来获取数据的一种方式</p>
<h2 id="为什么需要正则提取器"> 为什么需要正则提取器</h2>
<ul>
<li>JSON 提取器<strong>只针对</strong>接口返回且数据格式为 JSON 的响应内容</li>
<li>如果想提取的是响应头、请求头的值，而非响应内容的值呢？</li>
<li>这个时候正则提取器的作用就出来了，它可以提取请求任一部分的值</li>
</ul>
<h2 id="界面介绍"> 界面介绍</h2>
<p><img src="./images/regular1.png" alt="regular" /></p>
<p>字段介绍：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Apply to</td>
<td>1. 作用于主节点的取样器及对应子节点的取样器<br />2. 仅作用于主节点的取样器（一般默认）<br />3. 仅作用于子节点的取样器<br />4. 作用于 JMeter 变量，<strong>从指定变量值中提取需要的值</strong></td>
</tr>
<tr>
<td>Field to check</td>
<td>1. 响应报文的主体，最常用<br />2. 替换了所有的 HTML 转义符的响应主体内容，HTML 转义符处理时不考虑上下文，因此可能有不正确的转换，<strong>不太建议使用</strong><br />3. 从不同类型的文件中提取文本，<strong>注意这个选项比较影响性能</strong><br />4. 响应信息头<br />5. 请求信息头<br />6. 请求url<br />7. 响应状态码<br />8. 响应信息</td>
</tr>
<tr>
<td>Names of created variables</td>
<td>接收提取值的变量名<br />必传</td>
</tr>
<tr>
<td>Regular Expression</td>
<td>正则表达式</td>
</tr>
<tr>
<td>Template</td>
<td>从找到的匹配项中创建字符串的模板</td>
</tr>
<tr>
<td>Match No.(0 for Random)</td>
<td>取第几个值<br /> 0：随机，<strong>默认</strong> <br />-1：所有 <br /> 1：第一个值 非必传</td>
</tr>
<tr>
<td>Default Value</td>
<td>缺省值，匹配不到值的时候取该值<br /> 非必传</td>
</tr>
<tr>
<td>Use empty default value</td>
<td>勾选后，提取不到值时，则返回空字符串</td>
</tr>
</tbody>
</table>
<p><strong>Template 注意</strong>：</p>
<ul>
<li>如果<strong>一条</strong>正则表达式有<strong>多个提取结果</strong>，则提取结果是数组形式</li>
<li>模板 <code>$1$</code>、<code>$2$</code>.....表示把解析到的第几个值赋给变量，从 1 开始匹配</li>
<li><code>$0$</code> 表示整个表达式匹配的内容</li>
<li>若只有一个结果，只能是$1$</li>
</ul>
<h2 id="正则提取器实例"> 正则提取器实例</h2>
<p>在介绍例子之前，首先先来学习下 正在表达式的语法</p>
<h3 id="json-path-语法"> JSON Path 语法</h3>
<p>有关于正则表达式的了解，可以参考<a href="/basic-skills/regular/regular">正则表达式</a></p>
<h3 id="实例应用"> 实例应用</h3>
<p>测试结构树：</p>
<p><img src="./images/regular2.png" alt="json" /></p>
<p>查看用户接口需要在请求头中添加登录后获取的 token，配置如下：</p>
<p><img src="./images/regular3.png" alt="json" /></p>
<p><strong>知识点</strong>:</p>
<ul>
<li><code>( )</code> 里面写匹配规则，用于解析正则表达式</li>
<li><code>.*?</code> 表示匹配任意长度的任意字符，这也是最常用的正则表达式</li>
<li>一般<code>(.+?)</code> 和 <code>(.*?)</code>能够满足我们 <strong>80%</strong> 的使用场景</li>
<li>一般正在表达式可以写成 <code>左边界(.+?)右边界</code> 或 <code>左边界(.*?)右边界</code></li>
</ul>
<h4 id="一条正则表达式提取一个结果"> 一条正则表达式提取一个结果</h4>
<h5 id="未填写模板"> 未填写模板</h5>
<p>提取器：</p>
<p><img src="./images/regular4.png" alt="regular" /></p>
<p>测试结果：</p>
<p><img src="./images/regular5.png" alt="regular" /></p>
<p><strong>注意</strong>：如果正则匹配到值，但是没有填模板，则返回空</p>
<h5 id="添加模板"> 添加模板</h5>
<h6 id="_0"> $0$</h6>
<p>提取器：</p>
<p><img src="./images/regular6.png" alt="regular" /></p>
<p>测试结果：</p>
<p><img src="./images/regular7.png" alt="regular" /></p>
<p>上面测试结果表示：</p>
<ul>
<li><code>$0$</code> 模板其实返回的就是 <code>name_g0</code> 的值</li>
<li>返回了整个正则表达式，不只是 ( ) 内匹配到的值</li>
</ul>
<h6 id="_1"> $1$</h6>
<p>提取器：</p>
<p><img src="./images/regular9.png" alt="regular" /></p>
<p>测试结果：</p>
<p><img src="./images/regular8.png" alt="regular" /></p>
<p>上面测试结果表示：</p>
<ul>
<li><code>$1$</code> 模板其实返回的就是 <code>name_g1</code> 的值</li>
<li>仅返回 ( ) 内匹配到的值</li>
</ul>
<h6 id="_2"> $2$</h6>
<p>提取器：</p>
<p><img src="./images/regular10.png" alt="regular" /></p>
<p>测试结果：</p>
<p><img src="./images/regular11.png" alt="regular" /></p>
<p>上面测试结果表示：</p>
<ul>
<li><code>$2$</code> 模板并不存在，其实就是<code>name_g2</code> 变量不存在，即使勾了使用空默认值，也返回 null</li>
</ul>
<p><strong>小结</strong>：</p>
<ul>
<li>其实 name 在 JSON 字符串中有三个可匹配到的值，如果不填写匹配数字 Match No. ，则会随机取一个 name 并返回</li>
<li>像上述的几个例子，都填了 1 ，所以都返回了第一个匹配到的 name</li>
</ul>
<h4 id="一条正则表达式提取多个结果"> 一条正则表达式提取多个结果</h4>
<p>有 2 种情况：</p>
<ul>
<li>一条表达式有多个 ( )</li>
<li>一个 ( ) 匹配到多个值，且 Match No 填了 <strong>-1</strong></li>
</ul>
<h5 id="一个-匹配到多个值"> 一个 ( ) 匹配到多个值</h5>
<p>提取器：</p>
<p><img src="./images/regular12.png" alt="regular" /></p>
<p>运行结果：</p>
<p><img src="./images/regular13.png" alt="regular" /></p>
<p>可以搭配 ForEach 控制器获取相应的值：</p>
<p><img src="./images/regular14.png" alt="regular" /></p>
<p>运行结果：</p>
<p><img src="./images/regular15.png" alt="regular" /></p>
<h5 id="一条表达式有多个"> 一条表达式有多个 ( )</h5>
<h6 id="无模板"> 无模板</h6>
<p>提取器：</p>
<p><img src="./images/regular16.png" alt="regular" /></p>
<p>结果：</p>
<p><img src="./images/regular17.png" alt="regular" /></p>
<h6 id="只有一个模板"> 只有一个模板</h6>
<p>提取器：</p>
<p><img src="./images/regular18.png" alt="regular" /></p>
<p>结果：</p>
<p><img src="./images/regular19.png" alt="regular" /></p>
<p>根据上面结果发现：</p>
<ul>
<li>result1 拿的就是 <code>result1_g1</code> 的值</li>
<li><code>$1$</code> 获取的是第一个 ( ) 匹配到的值，<code>$2$</code> 获取的是第二个 ( ) 匹配到的值，以此类推</li>
</ul>
<h6 id="有-2-个模板"> 有 2 个模板</h6>
<p>提取器：</p>
<p><img src="./images/regular20.png" alt="regular" /></p>
<p>上面 2 种方式的结果一样：</p>
<p><img src="./images/regular19.png" alt="regular" /></p>
<p><strong>小结</strong>：</p>
<ul>
<li>如果其中一个 ( ) 匹配不到元素，那也无法获取到值</li>
<li><strong>引用名称、匹配数字、缺省值</strong>三个字段也只需要填一个值即可，不需要跟 ( ) 的数量一致</li>
<li>多个模板（ $1$$2$ ）的时候，可以用空格、<code>,</code> 、<code>.</code> 、<code>-</code>连接模板，最终会显示在变量上</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-01T05:32:11.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">JMeter 插件安装</title>
    <id>https://www.snowji.cn/test/tools/Jmeter/jmeter-plug-install/</id>
    <link href="https://www.snowji.cn/test/tools/Jmeter/jmeter-plug-install/"/>
    <updated>2022-08-29T06:04:05.000Z</updated>
    <content type="html"><![CDATA[<h1 id="jmeter-插件安装"> JMeter 插件安装</h1>
<p><strong>下载插件</strong></p>
<p>下载地址：https://jmeter-plugins.org/install/Install/</p>
<p><img src="./images/cj.png" alt="cj" /></p>
<p><strong>下载完成后，将该 jar 包放入目录的 lib/ext 目录下</strong></p>
<p><img src="./images/ext.png" alt="ext" /></p>
<p><strong>打开 JMeter 可以看到已经安装的插件</strong></p>
<p><img src="./images/cj1.png" alt="cj1" />可以在 Available Plugins 选项下，安装需要的插件</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-29T06:04:05.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Once Only 控制器</title>
    <id>https://www.snowji.cn/test/tools/Jmeter/once-only/</id>
    <link href="https://www.snowji.cn/test/tools/Jmeter/once-only/"/>
    <updated>2022-08-30T08:14:14.000Z</updated>
    <content type="html"><![CDATA[<h1 id="once-only-控制器"> Once Only 控制器</h1>
<p>位置：逻辑控制器中</p>
<h2 id="什么是-once-only-控制器"> 什么是 Once Only 控制器</h2>
<ul>
<li>
<p>每个线程内，该控制器下的内容只会被执行一次</p>
</li>
<li>
<p>无论循环多少次，都只执行一遍</p>
</li>
</ul>
<h2 id="界面介绍"> 界面介绍</h2>
<p><img src="./images/once1.png" alt="once" /></p>
<h2 id="实例介绍"> 实例介绍</h2>
<h3 id="简单例子"> 简单例子</h3>
<p>测试结构树 + 线程组设置：</p>
<p><img src="./images/once2.png" alt="once" /></p>
<p>测试结果：</p>
<p><img src="./images/once3.png" alt="once" /></p>
<p>上面结果说明，Once Only Controller 中的取样器只执行了 1 次</p>
<h3 id="once-only-controller-loop-controller"> Once Only Controller + Loop Controller</h3>
<p>测试计划结构树 + 线程组配置 + Loop 控制器配置</p>
<p><img src="./images/once4.png" alt="once" /></p>
<p>测试结果：</p>
<p><img src="./images/once5.png" alt="once" /></p>
<ul>
<li>仅在通过循环控制器的第一次迭代中执行控制器里面的内容</li>
<li>而循环控制器会执行 2 次，所以仅一次控制器也会执行 2 次</li>
</ul>
<p><strong>应用场景</strong>：</p>
<ul>
<li>对于需要登录的测试，可以将登录请求放置在此控制器中，因为每个线程只需要登录一次即可建立会话</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-30T08:14:14.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Loop Controller</title>
    <id>https://www.snowji.cn/test/tools/Jmeter/loop-controller/</id>
    <link href="https://www.snowji.cn/test/tools/Jmeter/loop-controller/"/>
    <updated>2022-08-30T08:16:32.000Z</updated>
    <content type="html"><![CDATA[<h1 id="loop-controller"> Loop Controller</h1>
<p><strong>界面</strong></p>
<p>右键 Add--&gt;Logic Controller--&gt;Loop Controller，添加 Loop Controller</p>
<p><img src="./images/loop.png" alt="loop" /></p>
<p>参数说明：</p>
<p><strong>Loop Count</strong>：循环次数</p>
<ul>
<li>Infinite：无限循环</li>
<li>自定义次数：可自定义要循环的次数</li>
</ul>
<p><strong>循环次数与线程组循环次数的关系</strong>：</p>
<p>可以理解为<strong>父子关系</strong></p>
<p>例子：</p>
<p>线程组的线程数设置为 2 ，循环次数设置为 1，循环控制器的循环次数设置为 3，为了查看结果方便，新增了个计数器</p>
<p><img src="./images/loop1.png" alt="loop1" /></p>
<p>上图结果可以看出，1 个线程会循环执行 3 次后，再去执行其他线程</p>
<p>如果循环控制器选择 Infinite 选项，线程会永远交替执行</p>
<p><img src="./images/loop3.png" alt="loop2" /></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-30T08:16:32.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Simple 控制器</title>
    <id>https://www.snowji.cn/test/tools/Jmeter/simple-controller/</id>
    <link href="https://www.snowji.cn/test/tools/Jmeter/simple-controller/"/>
    <updated>2022-08-30T08:11:17.000Z</updated>
    <content type="html"><![CDATA[<h1 id="simple-控制器"> Simple 控制器</h1>
<p>位置：逻辑控制器中</p>
<h2 id="什么是简单控制器"> 什么是简单控制器</h2>
<ul>
<li>是 JMeter 里最简单的一个控制器</li>
<li>可以提供一个分组控制</li>
<li>不具备任何的逻辑控制功能</li>
</ul>
<h2 id="界面介绍"> 界面介绍</h2>
<p><img src="./images/simple.png" alt="simple" /></p>
<p>例子：</p>
<p>测试结构树 + 结果：</p>
<p><img src="./images/simple1.png" alt="simple" /></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-30T08:11:17.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Random 控制器</title>
    <id>https://www.snowji.cn/test/tools/Jmeter/random-controller/</id>
    <link href="https://www.snowji.cn/test/tools/Jmeter/random-controller/"/>
    <updated>2022-08-30T08:27:56.000Z</updated>
    <content type="html"><![CDATA[<h1 id="random-控制器"> Random 控制器</h1>
<p>作用：其下的子项会被随机执行</p>
<p>应用场景：做容量测试的时候，随机分配业务比例，最大程度的模拟用户场景</p>
<h2 id="界面介绍"> 界面介绍</h2>
<p><img src="./images/random1.png" alt="random" /></p>
<p><strong>Ignore sub-controller blocks</strong>：忽略子控制器，勾选后，随机控制器下的子控制器中的多个子项只会被执行一个</p>
<h2 id="random-controller-实例"> Random Controller 实例</h2>
<h3 id="未勾选-ignore-sub-controller-blocks"> 未勾选 Ignore sub-controller blocks</h3>
<p>测试计划结构树 + 测试结果：</p>
<p><img src="./images/random2.png" alt="random" /></p>
<p>可以看到取样器随机执行</p>
<h3 id="勾选-ignore-sub-controller-blocks"> 勾选 Ignore sub-controller blocks</h3>
<p>测试计划结构树 + Random Controller：</p>
<p><img src="./images/random3.png" alt="random" /></p>
<p>Loop Controller：</p>
<p><img src="./images/random6.png" alt="random" /></p>
<p>测试结果：</p>
<p><img src="./images/random4.png" alt="random" /></p>
<p>可以看到上述结果：</p>
<ul>
<li>如果随机到循环控制器时，只会执行了一次</li>
<li>循环控制器中按照依次执行的顺序选择了第一个执行</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-30T08:27:56.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Switch Controller</title>
    <id>https://www.snowji.cn/test/tools/Jmeter/switch-controller/</id>
    <link href="https://www.snowji.cn/test/tools/Jmeter/switch-controller/"/>
    <updated>2022-08-30T08:30:52.000Z</updated>
    <content type="html"><![CDATA[<h1 id="switch-controller"> Switch Controller</h1>
<p>作用：控制该控制器下的取样器执行</p>
<p>应用场景：可以用在模拟多线程同时操作不同请求的测试场景</p>
<h2 id="界面介绍"> 界面介绍</h2>
<p><img src="./images/switch1.png" alt="switch" /></p>
<p>Switch Value：</p>
<ul>
<li>数字
<ul>
<li>0 表示运行 Switch 控制器里的第一个请求，1 表示运行第二个请求以此类推</li>
<li>数字超过取值范围了，就默认是 0</li>
<li>不填：默认执行数字 0 的请求，即顺位第一个请求</li>
</ul>
</li>
<li>字符：输入 Switch 控制器里面请求的名称，匹配与请求中的名称相同则执行该请求</li>
<li>变量</li>
</ul>
<h2 id="实例"> 实例</h2>
<h3 id="填入数字"> 填入数字</h3>
<h4 id="不填"> 不填</h4>
<p>测试计划结构树 + Switch：</p>
<p><img src="./images/switch2.png" alt="switch" /></p>
<p>测试结果：</p>
<p><img src="./images/swicth3.png" alt="switch" /></p>
<p>执行了第一个请求</p>
<h4 id="数字在范围内"> 数字在范围内</h4>
<p>测试计划树结构 + Switch ：</p>
<p><img src="./images/switch4.png" alt="switch" /></p>
<p>测试结果：</p>
<p><img src="./images/switch5.png" alt="switch" /></p>
<p>执行了第 2 个请求</p>
<h4 id="数字不在范围内"> 数字不在范围内</h4>
<p>测试计划树结构 + Switch ：</p>
<p><img src="./images/switch6.png" alt="switch" /></p>
<p>测试结果：</p>
<p><img src="./images/swicth3.png" alt="switch" /></p>
<p>执行了第 1 个请求</p>
<h3 id="填入取样器名"> 填入取样器名</h3>
<p>测试计划树结构 + Switch ：</p>
<p><img src="./images/switch7.png" alt="switch" /></p>
<p>测试结果：</p>
<p><img src="./images/swicth3.png" alt="switch" /></p>
<p>执行了第 1 个请求</p>
<h3 id="变量"> 变量</h3>
<p>测试计划树 + Switch + 用户自定义变量：</p>
<p><img src="./images/switch8.png" alt="switch" /></p>
<p>测试结果：</p>
<p><img src="./images/switch9.png" alt="switch" /></p>
<p>随机获取数字，随机执行请求</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-30T08:30:52.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">测试计划</title>
    <id>https://www.snowji.cn/test/tools/Jmeter/test-plan-introduction/</id>
    <link href="https://www.snowji.cn/test/tools/Jmeter/test-plan-introduction/"/>
    <updated>2022-08-29T06:04:05.000Z</updated>
    <content type="html"><![CDATA[<h1 id="测试计划"> 测试计划</h1>
<h2 id="测试计划的作用"> 测试计划的作用</h2>
<ul>
<li>测试计划描述了 JMeter 在执行时，一系列的步骤</li>
<li>一个完整的测试计划包含了一个或多个【线程组、逻辑控制器、采样器、监听器、定时器、断言和配置元素】</li>
</ul>
<h2 id="测试计划添加-删除元件"> 测试计划添加/删除元件</h2>
<p><img src="./images/test1.png" alt="img" /></p>
<ul>
<li>通过右键点击树中的元件，选中要添加的元件</li>
<li>也可以通过合并（merge）或打开（open）从文件中加载和添加元件</li>
<li>删除一个元件，请确保选中了该元件，右键单击该件素，并选择**删除（remove）**选项</li>
</ul>
<h2 id="配置树元素"> 配置树元素</h2>
<ul>
<li>树中的每一个控件都能通过右边内容区显示</li>
<li>树中的每一个控件都能在树中随意拖动</li>
</ul>
<h2 id="保存测试计划"> 保存测试计划</h2>
<ul>
<li>
<p>建议在执行之前保存测试计划</p>
</li>
<li>
<p>从文件菜单中选择 save 或 save Test Plan As… 进行保存</p>
</li>
</ul>
<h2 id="执行测试计划"> 执行测试计划</h2>
<ul>
<li>可以通过 <code>ctrl+r</code> 运行测试计划</li>
<li>通过右侧的数字：<strong>活动线程数/线程总数</strong>，这仅适用于本地运行的测试</li>
<li>使用客户端-服务器模式时，它们不包括在远程系统上启动的任何线程**【分布式压测时，master 机不会显示所有远程 salve 机的线程总数】**</li>
</ul>
<p><img src="./images/test2.png" alt="img" /></p>
<h3 id="特别注意"> 特别注意</h3>
<p>仅在<strong>调试</strong>测试计划时，才应该使用上面的 GUI 模式**【界面模式】<strong>，如果实际运行</strong>负载测试<strong>的时候，应该使用 CLI 模式</strong>【命令行模式、无界面模式】**</p>
<h2 id="暂停运行测试计划"> 暂停运行测试计划</h2>
<p><img src="./images/test3.png" alt="img" /></p>
<p>两种暂停方式</p>
<ul>
<li>停止线程（ctrl + .）<strong>【硬中断】</strong></li>
<li>关闭线程（ctrl + ,）<strong>【软中断】</strong></li>
</ul>
<h3 id="stop"> stop</h3>
<ul>
<li>许多采样器（Samplers）都是可中断的，这意味着可以提前终止活动采样</li>
<li>stop 命令将检查所有线程是否已在默认超时（即 5000 ms = 5 秒）内停止</li>
<li>如果有线程还没被停止，则会发送一条信息；此时可以再发送一次 stop 命令，但如果还是失败的话，就得退出 Jmeter 来清理</li>
</ul>
<h3 id="特别注意-2"> 特别注意</h3>
<p>上述说的默认超时可以通过 JMeter 属性来改变 <code>jmeterengine.threadstop.wait</code> <strong>【jmeter安装目录 / bin / jmeter.properties】</strong></p>
<p>[<img src="./images/jmeter.png" alt="img" />]</p>
<h3 id="shutdown"> shutdown</h3>
<ul>
<li>
<p>线程会在当前运行任务结束后停止，<strong>不会中断</strong>活动线程正在执行的任务</p>
</li>
<li>
<p>会出现一个【正在停止测试】的窗口（如下图），直到所有线程都运行完成了才会关闭</p>
</li>
<li>
<p>如果停止时间太久，也可以直接发 stop 命令</p>
</li>
</ul>
<h3 id="注意点"> 注意点</h3>
<ul>
<li>在 <strong>Linux CLI</strong> 模式下，是没有快捷键来停止线程运行的，所以 JMeter 在 CLI 模式下会监听特定端口上的命令（默认端口 4445，可以通过 <code>jmeterengine.nongui.port</code> 修改）</li>
<li>如果 4445 端口被占用了（比如，另一个 JMeter 实例用了），JMeter 会自动选择备用端口；</li>
<li>JMeter 将尝试监听下一个更高的端口，直到到达 JMeter 属性 <code>jmeterengine.nongui.maxport</code> 为止，该属性默认为 4455</li>
</ul>
<h2 id="在-cli-模式下-如何停止线程执行"> 在 CLI 模式下，如何停止线程执行</h2>
<p>在bin目录下，运行脚本</p>
<ul>
<li>
<p>stoptest.cmd / stoptest.sh <strong>【硬中断】</strong></p>
</li>
<li>
<p>shutdown.cmd / shutdown.sh <strong>【软中断】</strong></p>
</li>
</ul>
<p>**注意，**只有在同一个 host 下运行的脚本，JMeter 才会接受</p>
<h2 id="错误报告"> 错误报告</h2>
<p><img src="./images/report.png" alt="report" /></p>
<ul>
<li>JMeter 向 <strong>JMeter.log</strong> 文件报告警告和错误，以及测试运行本身的一些信息</li>
<li>JMeter 显示在 <strong>JMeter.log</strong> 文件中发现的警告/错误数量</li>
<li>单击警告图标，就可以显示 JMeter窗口底部的 <strong>jmeter.log</strong> 文件</li>
<li>偶尔会出现 JMeter 无法捕获和记录的错误，这些将出现在命令控制台上</li>
</ul>
<p><strong>注意</strong>：在日志文件中通常不报告抽样错误(例如没有找到的 HTTP 404 文件)</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-29T06:04:05.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">测试计划参数详解</title>
    <id>https://www.snowji.cn/test/tools/Jmeter/test-plan-parameters/</id>
    <link href="https://www.snowji.cn/test/tools/Jmeter/test-plan-parameters/"/>
    <updated>2022-08-29T06:04:05.000Z</updated>
    <content type="html"><![CDATA[<h1 id="测试计划参数详解"> 测试计划参数详解</h1>
<h2 id="测试计划参数"> 测试计划参数</h2>
<p><img src="./images/plan1.png" alt="img" /></p>
<h3 id="名称和注释"> 名称和注释</h3>
<p>整个测试脚本保存的名称，和对该测试计划的注释</p>
<h3 id="用户定义的变量"> 用户定义的变量</h3>
<ul>
<li>用户添加的变量，相当于全局变量，<strong>所有线程组都共用</strong></li>
<li>一般添加一些系统常用的配置</li>
<li>一般不建议在测试计划上添加变量，因为不方便启用（disable）和禁用（enable）</li>
<li>可以添加用户自定义变量组件来代替，如下图</li>
</ul>
<p><img src="./images/plan2.png" alt="img" /></p>
<h3 id="独立运行每个线程组"> 独立运行每个线程组</h3>
<ul>
<li>
<p>用于控制测试计划中的多个线程组的执行顺序</p>
</li>
<li>
<p>不勾选，默认<strong>各线程组并行、随机执行</strong></p>
</li>
</ul>
<p><strong>作用：<strong>勾选后，用于控制测试计划中的多个线程组的执行顺序，保证</strong>顺序执行</strong>各线程组</p>
<p><strong>下图是没有勾选时</strong>，多个线程组执行的顺序，可以看到并不完全是顺序执行的</p>
<p><img src="./images/plan3.png" alt="img" /></p>
<p><strong>下图是勾选后</strong>，多个线程组的执行顺序，可以看到当执行完第一个线程组所有取样器才会执行第二个线程组的，按顺序执行</p>
<p><img src="./images/plan4.png" alt="img" /></p>
<h4 id="特别注意"> 特别注意</h4>
<ul>
<li>线程组中的<strong>取样器执行顺序</strong>：默认是从上到下执行</li>
<li>交替控制器、随机控制器、随机顺序控制器、循环控制器可以改变取样器的执行顺序</li>
</ul>
<h3 id="主线程结束后运行-teardown-线程组"> 主线程结束后运行 tearDown 线程组</h3>
<ul>
<li>当线程组停止运行时仍继续运行 tearDown 线程组</li>
<li>该选项结合线程组的执行配置使用，如图所示，目前已很少使用
<img src="./images/plan5.png" alt="plan5" /></li>
</ul>
<h3 id="函数测试模式"> 函数测试模式</h3>
<p>勾选后，如果监听器（如：查看结果树）配置了保存到一个文件中（如下图），那么 JMeter 会将每次的请求结果保存到文件中</p>
<p>在负载测试中不建议勾选，平时调试脚本情况下可以勾选</p>
<p><img src="./images/plan6.png" alt="img" /></p>
<h3 id="添加目录或-jar-包到-classpath"> 添加目录或 jar 包到 classpath</h3>
<p>当脚本需要调用外部的 java 文件或 jar 包时，可以把 jar 包路径添加到这里，然后在 BeanShell 中直接 import 进来，并调用 jar 包中的方法</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-29T06:04:05.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">线程组</title>
    <id>https://www.snowji.cn/test/tools/Jmeter/thread-group/</id>
    <link href="https://www.snowji.cn/test/tools/Jmeter/thread-group/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="线程组"> 线程组</h1>
<h2 id="简介"> 简介</h2>
<p><img src="./images/group.png" alt="group" /></p>
<h3 id="什么是线程组"> 什么是线程组</h3>
<ul>
<li>是任何测试计划的起点，相当于业务流程</li>
<li>所有控制器和采样器必须在一个线程组下</li>
<li>线程组决定了 JMeter 测试计划中执行的线程数</li>
</ul>
<h3 id="作用"> 作用</h3>
<ul>
<li>设置线程数</li>
<li>设置 ramp-up period</li>
<li>设置执行测试的次数</li>
</ul>
<h3 id="特点"> 特点</h3>
<p>每个线程将完整地执行测试计划，并且完全独立于其他测试线程，多线程用于模拟到服务器应用程序的并发连接</p>
<h2 id="线程组属性"> 线程组属性</h2>
<p><img src="./images/group1.png" alt="group1" /></p>
<h3 id="在取样错误后要执行的动作"> 在取样错误后要执行的动作</h3>
<ul>
<li>继续(默认)：忽略错误，继续执行</li>
<li>启动下一进程循环：忽略错误，线程当前循环终止，执行下一个循环</li>
<li>停止线程：当前线程停止执行，不影响其他线程正常执行</li>
<li>停止测试：整个测试会在所有当前正在执行的线程执行完毕后停止</li>
<li>立即停止测试：整个测试会立即停止执行，当前正在执行的取样器可能会被中断</li>
</ul>
<h3 id="线程属性"> 线程属性</h3>
<h4 id="线程数"> 线程数</h4>
<ul>
<li>模拟真实用户，1 线程 = 1 虚拟用户</li>
<li>windows 下，2g 的 java 内存，1m 的栈空间，最大启动线程数=1000</li>
<li>Linux 下，2g 的 java内存，1m 的栈空间，最大启动线程数=2000</li>
<li>在 JMeter 中，先启动线程，再运行线程，后释放线程**【启动线程并运行，释放线程】**</li>
<li><strong>线程数建议不超过 1000</strong></li>
</ul>
<h4 id="ramp-up-时间"> Ramp-Up 时间</h4>
<ul>
<li>预期线程组的所有线程从启动-运行-释放的总时间</li>
<li><code>ramp up=0</code> 时，表示瞬时加压，启动线程的时间无限趋近于 0</li>
<li><strong>特别注意</strong>：在负载测试的时候，尽量<strong>把 ramp up 设置大</strong>一些，让性能曲线平缓，容易找到瓶颈点</li>
</ul>
<h5 id="配置注意事项"> 配置注意事项</h5>
<h6 id="ramp-up需要设置足够长的时间来避免在测试刚开始时工作量过大"> Ramp-up需要设置足够长的时间来避免在测试刚开始时工作量过大</h6>
<ul>
<li>假如需要大量线程的话，不建议设置成 0，0 属于瞬时加压【过小的 ramp-up period 】</li>
<li>如果设置 0，JMeter 将在测试开始时就启动全部线程并立即发送请求，这样很容易让服务器达到饱满状态，且瞬间会增加很大的负载量，容易让服务器超载，这样是不合理的；</li>
<li>不合理的原因并不是因为平均压力值过高，而是因为所有线程都在<strong>初始状态时一起并发访问</strong>，从而引起不正常的初始访问峰值，可以通过 JMeter 的聚合报告看到这种情况</li>
</ul>
<h6 id="ramp-up还必须足够短-保证最后一个线程在第一个线程完成之前开始运行"> Ramp-up还必须足够短，保证最后一个线程在第一个线程完成之前开始运行</h6>
<ul>
<li>如果 Ramp-up 过大，则会降低访问峰值的负载，即没有达到预期的压力峰值，无法获取准确的服务器最大负载情况【过大的 ramp-up period 】</li>
<li>**具体的表现为：**一些线程还没有启动，初期启动的部分线程已经结束了【导致实际并发量并会小于预期并发量】</li>
</ul>
<h6 id="如何确定一个合理的-ramp-up-period"> 如何确定一个合理的 ramp-up period</h6>
<ul>
<li>首先，让初始点击率接近平均点击率，前提是确定合理的访问量</li>
<li>初始的 <code>ramp-up period = 平均点击率= 总线程/点击率</code>；<code>假如线程数=100</code>，<code>点击率=10次/s</code>，则 <code>ramp-up period = 100/10 = 10s</code></li>
</ul>
<h4 id="循环次数"> 循环次数</h4>
<ul>
<li>每个线程循环执行的次数，<strong>默认一次</strong>，<strong>值 != -1</strong></li>
<li>如果设置为<strong>永远</strong>，那么 JMeter 将以最大的可能去发送请求，以此测试出<strong>最大并发数</strong></li>
</ul>
<h4 id="线程配置例子"> 线程配置例子</h4>
<p><img src="./images/group2.png" alt="group2" /></p>
<p>说明：20s 内启动并运行 20 个线程，一共启动 20 个线程，总共发送 20 个请求（10*2），每秒启动一个线程，然后运行 1次</p>
<p><strong>注意</strong>：如果 ramp-up 时间内，所有线程不能启动运行完的话，时间则会顺延下去</p>
<h4 id="same-user-on-each-iteration"> Same user on each iteration</h4>
<ul>
<li>
<p>【选中】默认选中，每次循环用第一次的 cookie，不再更新【可以理解为每次循环都是同一个用户】</p>
</li>
<li>
<p>【不选中】每次循环都是用新的 cookie 值【可以理解为每次循环都是不同的用户】</p>
</li>
</ul>
<h4 id="延迟创建线程直到需要"> 延迟创建线程直到需要</h4>
<p>延迟创建线程，直到线程被需要、采样器开始执行时才会被创建，避免资源浪费</p>
<p>【选中】JMete将根据 Ramp-up 时间来分配线程。否则，无论 Ramp-up 时间如何设定，所有线程都将在测试开始时分配给 JVM 进程</p>
<h4 id="调度器"> 调度器</h4>
<p><img src="./images/dd.png" alt="dd" /></p>
<p>作用：控制每个线程组运行的持续时间以及它在多少秒后再启动</p>
<p>持续时间：线程组运行的持续时间</p>
<p>启动延迟：测试计划开始后，线程组的<strong>线程</strong>将在多少秒后<strong>再启动运行</strong></p>
<p><strong>注意事项</strong>：</p>
<ul>
<li>调度器只有在循环次数勾选永远或值为 -1 时，才会生效</li>
<li>当线程组运行完持续时间后，会<strong>逐步释放线程</strong>，不会一下子把所有线程释放掉，而释放线程也是需要时间的</li>
<li>测试计划总的时间（右上角的时间）会 &gt; 持续时间+启动延迟</li>
</ul>
<h2 id="常见线程组"> 常见线程组</h2>
<p><img src="./images/group3.png" alt="group3" /></p>
<h3 id="普通线程组"> 普通线程组</h3>
<p>就是上面介绍的线程组</p>
<h3 id="setup-线程组"> setUp 线程组</h3>
<ul>
<li>用于执行预测试操作的特殊线程组</li>
<li>与普通线程组操作类似</li>
<li><strong>注意事项</strong>：在普通线程组执行测试前被执行</li>
</ul>
<p><strong>应用场景例子</strong>：</p>
<ul>
<li>测试数据库操作功能时，用于执行打开数据库连接的操作</li>
<li>测试用户购物功能时，用于执行用户的注册、登录等操作</li>
</ul>
<h3 id="teardown-线程组"> tearDown 线程组</h3>
<ul>
<li>用于执行测试后操作的特殊线程组</li>
<li>与普通线程组操作类似</li>
<li><strong>注意事项</strong>：在普通线程组执行测试后被执行</li>
</ul>
<p><strong>应用场景例子</strong>：</p>
<ul>
<li>测试数据库操作功能时，用于执行关闭数据库连接的操作</li>
<li>测试用户购物功能时，用于执行用户的退出等操作</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-29T06:04:05.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">用户参数</title>
    <id>https://www.snowji.cn/test/tools/Jmeter/user-preferences/</id>
    <link href="https://www.snowji.cn/test/tools/Jmeter/user-preferences/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="用户参数"> 用户参数</h1>
<p>作用：可动态引入参数</p>
<p>适用范围：适用于参数取值范围很小的时候使用</p>
<p>位置：前置处理器中</p>
<h2 id="界面介绍"> 界面介绍</h2>
<p>测试计划、线程组、 HTTP 请求中均可右键在前置处理器中添加用户参数</p>
<p><img src="./images/user1.png" alt="user" /></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Add Variable</td>
<td>添加变量</td>
</tr>
<tr>
<td>Delete Variable</td>
<td>可删除变量</td>
</tr>
<tr>
<td>Add User</td>
<td>添加用户</td>
</tr>
<tr>
<td>Delete User</td>
<td>删除用户</td>
</tr>
</tbody>
</table>
<h2 id="用户参数实例"> 用户参数实例</h2>
<p>测试计划、线程组、HTTP 请求中添加用户参数</p>
<p><img src="./images/user2.png" alt="user" /></p>
<p><strong>第一个用户参数中的配置（测试计划中的用户参数）</strong>：</p>
<p><img src="./images/user3.png" alt="user" /></p>
<p><strong>第二个用户参数中的配置（线程组1 中的用户参数）</strong>：</p>
<p><img src="./images/user4.png" alt="user" /></p>
<p><strong>第三个用户参数中的配置（ HTTP Request 1 中的用户参数）</strong>：</p>
<p><img src="./images/user5.png" alt="user" /></p>
<p>结果查看：</p>
<p><img src="./images/user6.png" alt="user" /></p>
<p>看到上述结果发现 HTTP Rquest 2 居然使用了测试计划中的用户参数，线程组中的参数没有生效</p>
<p>禁用测试计划中的用户参数后，重新运行，结果如下：</p>
<p><img src="./images/user7.png" alt="user" /></p>
<p>对比两次引用同一变量结果，发现线程组中的用户参数<strong>居然没有生效</strong></p>
<p><strong>思考</strong>：上面的用户参数只有一个值，如果有多个值，如何选择不同的值？</p>
<p>将 HTTP Request 3 中增加变量值：</p>
<p><img src="./images/user8.png" alt="user" /></p>
<p>在线程组1 中将线程数修改为 3，其他设置不变，结果如下：</p>
<p><img src="./images/user9.png" alt="user" /></p>
<p>前面学习 CSV 时，如果要获取全部变量也可以通过设置线程组的循环次数，是否在用户参数中同样适用？</p>
<p>将线程组1 中的线程数设置为 1 ，循环次数设置为 3，运行结果如下：</p>
<p><img src="./images/user10.png" alt="user" /></p>
<p>对比两次结果，发现用户参数只能通过设置线程组的线程数与参数数量一致时才能获取所有的参数值</p>
<p><strong>总结</strong>：</p>
<ul>
<li>测试计划中的用户参数作用于所有线程组</li>
<li>测试计划与线程组同时存在同名的用户参数时，线程组中的<strong>不会生效</strong></li>
<li>HTTP 请求中的用户参数优先级<strong>最高</strong></li>
<li>只能设置线程组中的线程数才能获取所有变量</li>
<li>通过用户参数获取的参数是动态的</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-09-01T05:49:25.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">用户自定义的变量</title>
    <id>https://www.snowji.cn/test/tools/Jmeter/user-defined-variables/</id>
    <link href="https://www.snowji.cn/test/tools/Jmeter/user-defined-variables/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="用户自定义的变量"> 用户自定义的变量</h1>
<p>适用于常量配置：数据库地址、测试环境地址等</p>
<p>位置：测试计划/配置原件</p>
<h2 id="界面介绍"> 界面介绍</h2>
<p><img src="./images/userdefault1.png" alt="userdefault" /></p>
<p>界面很简单，单击 Add 就可以新增变量</p>
<h2 id="用户自定义变量实例"> 用户自定义变量实例</h2>
<p>测试计划、线程组1、HTTP 请求下均添加用户自定义的变量</p>
<p><img src="./images/userdefault2.png" alt="user" /></p>
<p><strong>第一个用户自定义变量设置（测试计划中）</strong>:</p>
<p><img src="./images/userdefault3.png" alt="user" /></p>
<p><strong>第二个用户自定义变量设置（线程组1 中）</strong>:</p>
<p><img src="./images/userdefault4.png" alt="user" /></p>
<p><strong>第三个用户自定义变量设置（HTTP Request 1中）</strong>:</p>
<p><img src="./images/userdefault5.png" alt="user" /></p>
<p>运行结果如下：</p>
<p><img src="./images/userdefault6.png" alt="userdefault" /></p>
<p>上述结果中发现，所有的 HTTP 请求的请求参数的值都一样</p>
<p>为了进一步验证，在 HTTP Request 2 下添加一个用户自定义参数</p>
<p><img src="./images/userdefault7.png" alt="user" /></p>
<p>运行结果如下：</p>
<p><img src="./images/userdefault8.png" alt="user" /></p>
<p>结果显示使用了 HTTP Request 2 中设置的值</p>
<p>删除 HTTP 请求下的所有用户自定义的参数，运行结果：</p>
<p><img src="./images/userdefault9.png" alt="user" /></p>
<p>结果显示使用了线程组1 中的参数</p>
<p>删除线程组中的用户自定义参数，可以自行实验</p>
<p><strong>总结</strong>：</p>
<ul>
<li>用户自定义的参数作用于所有的 HTTP 请求</li>
<li>用户自定义变量定义的参数定义后不会改变</li>
<li>HTTP 请求中的用户自定义的变量优先级<strong>最高</strong>，线程组的用户自定义参数 &gt; 测试计划中的</li>
<li>用户自定义参数会选取最新的值作用于所有 HTTP 请求上</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-30T08:45:58.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">While 控制器</title>
    <id>https://www.snowji.cn/test/tools/Jmeter/while-controller/</id>
    <link href="https://www.snowji.cn/test/tools/Jmeter/while-controller/"/>
    <updated>2022-08-30T08:25:10.000Z</updated>
    <content type="html"><![CDATA[<h1 id="while-控制器"> While 控制器</h1>
<p>和 Python 中的 while 循环一样，将一直运行其所有子项，直到条件为 false 为止</p>
<h2 id="界面介绍"> 界面介绍</h2>
<p><img src="./images/while1.png" alt="while" /></p>
<p><strong>Condition 可填的值</strong>：</p>
<ul>
<li>BLANK (不输入任何值) ：循环中的最后一个样本失败时退出循环</li>
<li>LAST：当循环中的最后一个样本失败时退出循环，如果循环之前的最后一个样本失败，不会进入循环</li>
<li>其他：当条件等于字符串 false 时退出（或不进入）循环</li>
</ul>
<p><strong>其他可填的值</strong>：</p>
<ul>
<li><code>${VAR}</code> ：变量VAR在其它项中被赋值为 <strong>false</strong></li>
<li><code>${__javaScript(${C}&lt;10)}</code> ：针对<strong>数字型变量</strong>进行对比判断</li>
<li><code>${__javaScript(&quot;${C}&quot;==&quot;abc&quot;)}</code> ：针对<strong>字符串类型变量</strong>进行对比判断，区别在于双引号</li>
<li><code>${_P(property)}</code> ：属性被赋予 <strong>false</strong></li>
</ul>
<h2 id="while-控制器例子"> While 控制器例子</h2>
<h3 id="blank"> BLANK</h3>
<ul>
<li>此时其子节点下最后一个节点运行失败，才会停止</li>
<li>否则会一直循环下去（哪怕只有一个失败也不行，需要全部都失败了才退出）</li>
</ul>
<p>测试结构树 + While Controller：</p>
<p><img src="./images/while2.png" alt="while" /></p>
<p>测试结果：</p>
<p><img src="./images/while3.png" alt="while" /></p>
<p>看到会一直在循环</p>
<p><strong>设置某个请求地址不存在，再次执行，发现失败后，还是会一直在循环执行</strong></p>
<p><img src="./images/while4.png" alt="while" /></p>
<p><strong>设置所有的请求地址，无法请求，所有请求失败后，退出循环执行</strong></p>
<p><img src="./images/while5.png" alt="while" /></p>
<h3 id="last"> LAST</h3>
<ul>
<li>
<p>当参数设置为 LAST 时，如果 While Controller 的上一个节点运行失败，则不再执行while controller</p>
</li>
<li>
<p>否则继续执行，与参数为空的情况一致</p>
</li>
</ul>
<p>测试结构树 + While Controller：</p>
<p><img src="./images/while6.png" alt="while" /></p>
<p>测试结果：</p>
<p><img src="./images/while7.png" alt="while" /></p>
<p>可以看到循环执行</p>
<p><strong>修改上一个节点【查询不同状态订单all】请求失败，再执行，While 控制器里面的不会再请求</strong></p>
<p><img src="./images/while8.png" alt="while" /></p>
<p>退出循环了</p>
<p><strong>修改上一个节点【查询不同状态订单all】请求成功，执行，与参数为空的情况一致</strong></p>
<p><img src="./images/while9.png" alt="while" /></p>
<h3 id="表达式"> 表达式</h3>
<ul>
<li>可以使用函数助手生成表达式</li>
<li>表达式的结果为 true，则执行 While Controller</li>
<li>参数中也可以直接输入 true 或 false 来控制是否执行 While Controller</li>
</ul>
<p>测试计划结构树 + Counter + While Controller：</p>
<p>Counter 设置的范围：0-10</p>
<p><img src="./images/while10.png" alt="while" /></p>
<p>测试结果：</p>
<p><img src="./images/while11.png" alt="while" /></p>
<p>满足了表达式后，执行了 5 次，退出循环</p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-30T08:25:10.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">断点</title>
    <id>https://www.snowji.cn/test/tools/fiddler/breakpoints/</id>
    <link href="https://www.snowji.cn/test/tools/fiddler/breakpoints/"/>
    <updated>2022-10-30T07:39:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="断点"> 断点</h1>
<h2 id="什么是断点"> 什么是断点</h2>
<ul>
<li>将客户端发送给服务端的请求或服务端返回给客户端的响应暂停住</li>
<li>可以对请求或响应进行数据修改，再放行该请求或响应</li>
</ul>
<h2 id="断点的功能原理"> 断点的功能原理</h2>
<ul>
<li>开启 fiddler 后，客户端与服务端的交互都会经过 fiddler</li>
<li>发给服务端或返回给客户端的数据能被截取到，进行篡改</li>
</ul>
<p><img src="./images/breakpoints.png" alt="fiddler" /></p>
<h2 id="全局断点"> 全局断点</h2>
<ul>
<li>
<p>请求前断点</p>
<p>设置全局请求前断点，会将所有经过 fiddler 的接口在发送请求到 fiddler 的时候，fiddler 会暂停向服务器发送请求，此时，可以篡改接口的请求数据。</p>
<p>全局请求前断点设置，在 Rules-Automatic Breakpoints 中选择 Before Resquests 如下：</p>
<p><img src="./images/before.png" alt="before" /></p>
<p>或者直接在状态栏，点击一下，待出现下面的图标，即表示开启全局请求前断点，在点击 2 下，表示取消断点：</p>
<p><img src="./images/before1.png" alt="before" /></p>
<p>设置成功后，可以对请求的接口进行数据的修改，如：</p>
<p><img src="./images/before2.png" alt="before" /></p>
<p>此时可以修改提交的数据，然后点击绿色的 Run to Completion 后，fiddler 将该请求发送至服务器，获取服务器返回的数据</p>
</li>
<li>
<p>请求后断点</p>
<p>设置全局请求后断点，fiddler 会接受所有接口返回的数据，此时不会直接返给前端，可以修改返回的数据。</p>
<p>全局请求后断点设置，在 Rules-Automatic Breakpoints 中选择 after Resquests 如图：</p>
<p><img src="./images/after.png" alt="after" /></p>
<p>或者直接在状态栏，点击两下，待出现下面的图标，即表示开启全局请求前断点，在点击 1 下，表示取消断点：</p>
<p><img src="./images/after1.png" alt="after" /></p>
<p>设置成功后，可以对请求的接口进行数据的修改，有以下两种方式：</p>
<ul>
<li>
<p>在左边的 list 界面中，点击响应后断点的接口，右边选择 response 中的 raw，修改返回数据后，点击 Run to Completion 即可将返回的数据返回给前端</p>
<p><img src="./images/after2.png" alt="after" /></p>
</li>
<li>
<p>点击 choose response ，选择想要返回的内容：</p>
<p><img src="./images/after3.png" alt="after" /></p>
<p>然后在点击 Run to Completion ，就会把上述中设置的返回值返回给前端</p>
</li>
</ul>
</li>
</ul>
<h2 id="局部断点"> 局部断点</h2>
<p>局部断点是在局部的接口上进行断点，只是与全局断点的设置方式不一致，其余的数据操作部分可参考上面的全局断点部分</p>
<ul>
<li>
<p>局部请求前断点</p>
<p>在状态面板中输入：bpu token(url 中包含的值) 或者 bpu 完整url</p>
<p>输入：bpu 即可取消断点</p>
</li>
<li>
<p>局部请求后断点</p>
<p>在状态面板中输入：bpafter token(url 中包含的值) 或者 bpafter 完整url</p>
<p>输入：bpafter 即可取消断点</p>
</li>
</ul>
<h2 id="断点的作用"> 断点的作用</h2>
<ul>
<li>模拟网络中断</li>
<li>mock 数据</li>
<li>可以测试一些极端的测试</li>
</ul>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-30T12:51:36.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">fiddler</title>
    <id>https://www.snowji.cn/test/tools/fiddler/</id>
    <link href="https://www.snowji.cn/test/tools/fiddler/"/>
    <updated>2022-08-30T12:51:36.000Z</updated>
    <content type="html"><![CDATA[<h1 id="fiddler"> fiddler</h1>
<h2 id="原理"> 原理</h2>
<p>一般数据请求和响应的流程：</p>
<p><img src="./images/baserequest.png" alt="baserequest" /></p>
<p>开启 fiddler 的数据请求和响应流程：</p>
<p><img src="./images/fiddlerrequest.png" alt="requets" /></p>
<p>对于 HTTPS 的数据请求和响应：</p>
<p><img src="./images/https9.png" alt="requets" /></p>
<p>对比上面的流程，可以看出：</p>
<ul>
<li>fiddler 相当于是个代理，将客户端的请求转发给服务器，将服务器返回的数据转发给客户端</li>
<li>开启 fiddler 相当于将 fiddler 设置为系统的代理</li>
</ul>
<h2 id="基本界面介绍"> 基本界面介绍：</h2>
<p><img src="./images/Uibase.png" alt="baseUi" /></p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-30T12:51:36.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">Composer</title>
    <id>https://www.snowji.cn/test/tools/fiddler/composer/</id>
    <link href="https://www.snowji.cn/test/tools/fiddler/composer/"/>
    <updated>2022-08-30T12:51:36.000Z</updated>
    <content type="html"><![CDATA[<h1 id="composer"> Composer</h1>
<h2 id="composer-功能介绍"> Composer 功能介绍</h2>
<ul>
<li>创建 HTTP request 请求然后发送</li>
<li>允许自定义请求发送到服务器</li>
<li>简单的接口测试工具，发包工具</li>
<li>可以对请求进行重放</li>
</ul>
<p><strong>fiddler 创建 request 的方式</strong>:</p>
<ul>
<li>手写一个 request</li>
<li>在 Web Sessions 会话列表中拖拽一个已有的 request 到 Composer 中</li>
</ul>
<h2 id="composer-界面说明"> Composer 界面说明</h2>
<p>界面展示：</p>
<p><img src="./images/composer1.png" alt="composer" /></p>
<p>字段说明：</p>
<ul>
<li>
<p>Parsed：</p>
<ul>
<li>表示已经被解析的整个 HTTP 请求</li>
<li>包括请求行，请求头和请求体（就是最直观的看到 Request 请求的展示）</li>
</ul>
</li>
<li>
<p>Raw：这个就是真实原始的 HTTP 请求，是没有解析过的展示</p>
</li>
<li>
<p>Scratchpad：可以存储已经收集好的 HTTP 请求，可存储多个不同的请求</p>
</li>
<li>
<p>Optinos：Request Optinos 请求选项</p>
</li>
<li>
<p>Inspect Session：检查会话，当开启此功能并重放的时候，会自动跳入 Inspectors 功能模块，进行检查 HTTP 请求和响应</p>
</li>
<li>
<p>Fix Content-Length header：</p>
<ul>
<li>默认勾选</li>
<li>当使用 POST 请求进行重放的时候，如果没有 Content-Length 的请求头，fiddler 会自动加上此请求头，如果有但是请求正文大小错误，则它会自动修正</li>
</ul>
</li>
<li>
<p>Follow Redirects：会自动重定向 301，302 的请求</p>
</li>
<li>
<p>Automatically Authenticate：自动进行身份认证，包括认证 NTLM，http 401，http 407</p>
</li>
<li>
<p>UI Options：</p>
<ul>
<li>Tear off：
<ul>
<li>此功能是在原有的 fiddler 功能选项里面，将 Composer 这个功能弹出一个浮动窗口</li>
<li>如果不需要直接关闭这个窗口就会恢复原样</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Log Requests：记录保存重放的 HTTP 请求</p>
</li>
<li>
<p>Request Body：这里设置请求体的内容，一般用在 POST 请求</p>
</li>
<li>
<p>Upload file：此功能是自己在本地构造好一个 HTTP 请求，然后上传到 fiddler 中进行重放</p>
</li>
<li>
<p>Execute：执行重放功能或者执行新编辑请求的按钮</p>
</li>
</ul>
<h2 id="composer-使用"> Composer 使用</h2>
<h3 id="自定义请求"> 自定义请求</h3>
<p>手动填写 HTTP Request 请求的几个元素，点击 Execute 即可发送该请求：</p>
<ul>
<li>
<p>请求的URL</p>
</li>
<li>
<p>请求方式</p>
</li>
<li>
<p>请求头信息</p>
</li>
<li>
<p>请求参数</p>
<p><img src="./images/composer2.png" alt="composer" /></p>
</li>
</ul>
<h3 id="重复发送请求"> 重复发送请求</h3>
<p><strong>作用</strong>：可以模拟重复发很多请求的功能，在测试一些接口返回请求频繁的功能时会用到</p>
<p><strong>步骤</strong>：</p>
<ul>
<li>
<p>先用 fiddler 抓取到需要重复执行的请求</p>
</li>
<li>
<p>选中该请求，把它拖拽的 Composer 面板中</p>
</li>
<li>
<p>点击 Execute 按钮，重复执行该请求</p>
</li>
</ul>
<h3 id="篡改请求数据"> 篡改请求数据</h3>
<p><strong>作用</strong>：可以用来模拟一些请求参数的异常值测试</p>
<p><strong>步骤</strong>：</p>
<ul>
<li>首先需要抓取到一个请求，另外将界面切到 Composer 界面</li>
<li>把该请求拖拽到 Composer 界面中</li>
<li>直接在 Composer 中的 Request Body 或者是请求头信息中修改数据</li>
<li>点击 Execute 按钮执行发送请求</li>
</ul>
<p><img src="./images/composer3.png" alt="composer" /></p>
<p>执行完毕，可以和正常的浏览器请求一样在 Inspectors 中查看一些信息</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-30T12:51:36.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">请求后断点应用</title>
    <id>https://www.snowji.cn/test/tools/fiddler/apply/breakpoint-apply/</id>
    <link href="https://www.snowji.cn/test/tools/fiddler/apply/breakpoint-apply/"/>
    <updated>2022-08-30T12:51:36.000Z</updated>
    <content type="html"><![CDATA[<h1 id="请求后断点应用"> 请求后断点应用</h1>
<h2 id="前言"> 前言</h2>
<ul>
<li>本文中的场景，是在公司实际项目中遇到的一些场景之一</li>
<li>通过场景，讲述使用 fiddler 进行解决项目中存在的问题</li>
</ul>
<h2 id="请求前断点"> 请求前断点</h2>
<h3 id="需求概况"> 需求概况</h3>
<h3 id="测试分析"> 测试分析</h3>
<h2 id="请求后断点"> 请求后断点</h2>
<h3 id="需求概况-2"> 需求概况</h3>
<p>页面：会员回顾的页面，根据会员消费显示相应的页面展示</p>
<p>会员：新用户、老用户，不同的会员会有不同的消费数据</p>
<p>会员消费查询：用户进入页面后，接口会去掉第三方接口获得用户消费数据</p>
<h3 id="测试分析-2"> 测试分析</h3>
<p>测试需求：需要根据不同的用户身份，覆盖所有的页面，并保证页面数据正确性</p>
<p>测试难点：因为是调用第三方接口返回的数据，不能在库里造数据</p>
<p>解决方案：使用 fiddler 请求后断点拦截查询信息的接口，修改返回的数据返给前端，通过不同的信息数据显示不同的页面</p>
<p>具体应用可以参考 <a href="/test/tools/fiddler/breakpoints">fiddler 断点</a> 中的请求后断点</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-30T12:51:36.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">抓取 HTTPS 设置</title>
    <id>https://www.snowji.cn/test/tools/fiddler/crawl-https-packets/</id>
    <link href="https://www.snowji.cn/test/tools/fiddler/crawl-https-packets/"/>
    <updated>2022-10-18T07:44:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="抓取-https-设置"> 抓取 HTTPS 设置</h1>
<h2 id="前言"> 前言</h2>
<ul>
<li>fiddler 默认是只抓取 HTTP 的数据包</li>
<li>如果想抓取 HTTPS 的数据包，需要进行一些配置</li>
</ul>
<h2 id="设置-https"> 设置 HTTPS</h2>
<ul>
<li>
<p>toos --&gt; Options 打开选项，并选择 HTTPS 选项卡</p>
<p><img src="./images/https1.png" alt="https" /></p>
</li>
<li>
<p>勾选 Capture Https CONNECTs -&gt; Decrypt HTTPS traffic，然后在 Actions 中点击 Trust Root Certificate</p>
<p><img src="./images/https2.png" alt="https" /></p>
<p><img src="./images/https3.png" alt="https" /></p>
</li>
<li>
<p>安装证书成功后会在证书中查看到</p>
<p><img src="./images/https4.png" alt="https" /></p>
</li>
</ul>
<p>根据上面的步骤完成后，需要重启 fiddler 即可抓取到 HTTPS 的数据包了</p>
<p><strong>注意</strong>：如果之前安装过 fiddler，需要重置之前的证书，再重新安装证书</p>
<p><img src="./images/http10.png" alt="https" /></p>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-30T12:51:36.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
  <entry>
    <title type="html">抓取手机端数据包设置</title>
    <id>https://www.snowji.cn/test/tools/fiddler/crawl-app-packets/</id>
    <link href="https://www.snowji.cn/test/tools/fiddler/crawl-app-packets/"/>
    <updated>2022-08-30T12:51:36.000Z</updated>
    <content type="html"><![CDATA[<h1 id="抓取手机端数据包设置"> 抓取手机端数据包设置</h1>
<p>fiddler 除了抓取 PC 端的数据包外，也可以抓取手机端的数据包</p>
<h2 id="设置"> 设置</h2>
<h3 id="fiddler-设置"> fiddler 设置</h3>
<ul>
<li>
<p>打开 tools--&gt;Options，并选择 Connections 选项卡</p>
<p><img src="./images/https5.png" alt="https" /></p>
</li>
<li>
<p>勾选上图中的 &quot;Allow remote computers connect&quot;，并填入端口号，上面填写的是 8888 可以根据自己实际填写，然后点击确定</p>
</li>
<li>
<p>需要重启 fiddler</p>
</li>
</ul>
<h3 id="手机端设置"> 手机端设置</h3>
<ul>
<li>
<p>进入 WLAN 页，并进入详情页</p>
<p><img src="./images/https6.png" alt="https" /></p>
</li>
<li>
<p>代理方式选择 “手动”，另外主机名是 fiddler 所在机器的 IP，端口是上面设置的 8888 端口</p>
<p><img src="./images/https7.png" alt="https" /></p>
<p>设置完成后，点击确定</p>
</li>
<li>
<p>安装 fiddler 证书</p>
<ul>
<li>在手机浏览器网址中输入 fiddler 所在机器的 IP+ fiddler 监听的端口，如：192.168.0.4:8888</li>
<li>点击页面中的 “fiddlerRootcertificate” 链接，在弹出的对话框中随便设置一个名称确定即可</li>
</ul>
</li>
</ul>
<p><img src="./images/https8.png" alt="https" /></p>
<ul>
<li>完成后，即可在 fiddler 上抓取手机端的数据包啦</li>
</ul>
<p>（完）</p>
]]></content>
    <author>
      <name>snowji</name>
    </author>
    <contributor>
      <name>snowji</name>
    </contributor>
    <published>2022-08-30T12:51:36.000Z</published>
    <rights>Copyright by snowji</rights>
  </entry>
</feed>